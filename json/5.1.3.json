[{"id":"/sicpjs/5.1.3","tag":"TITLE","body":"5.1.3  \n    Subroutines"},{"tag":"TEXT","id":"#p1","child":[{"body":"When designing a machine to perform a computation, we would often\n    prefer to arrange for components to be shared by different parts of\n    the computation rather than duplicate the components.  Consider a\n    machine that includes two GCD computations—one that finds the GCD of\n    the contents of registers ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" and one that finds the\n    GCD of the contents of registers ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"c"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"d"},{"body":".  We might start\n    by assuming we have a primitive ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":" operation,\n    then expand the two instances of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":" in terms\n    of more primitive operations.\n    \n\tFigure ","tag":"#text"},{"tag":"REF","body":"5.7","href":"/sicpjs/5.1.3#fig-5.7"},{"body":"\n    shows just the GCD portions of the resulting machine's data paths,\n    without showing how they connect to the rest of the machine.  The figure\n    also shows the corresponding portions of the machine's controller\n    sequence.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_javascript/Fig5.7b.std.svg","id":"#fig-5.7","captionHref":"/sicpjs/5.1.3#fig-5.7","captionName":"Figure 5.7 ","captionBody":[{"body":"Portions of the data paths and controller sequence for\n          a machine with two GCD computations.","tag":"#text"}]}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    This machine has two remainder operation boxes and two boxes for\n    testing equality.  If the duplicated components are complicated, as is the\n    remainder box, this will not be an economical way to build the\n    machine.  We can avoid duplicating the data-path components by using\n    the same components for both GCD computations, provided that doing so\n    will not affect the rest of the larger machine's computation.  If the\n    values in registers ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" are not needed by the time the\n    controller gets to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd_2"},{"body":" (or if these values\n    can be moved to other registers for safekeeping), we can change the machine\n    so that it uses registers ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":", rather than registers\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"c"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"d"},{"body":", in\n    computing the second GCD as well as the first.  If we do this, we obtain the\n    controller sequence shown in\n    figure ","tag":"#text"},{"tag":"REF","body":"5.8","href":"/sicpjs/5.1.3#fig-5.8"},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    We have removed the duplicate data-path components (so that the data paths\n    are again as in figure ","tag":"#text"},{"tag":"REF","body":"5.1","href":"/sicpjs/5.1#fig-5.1"},{"body":"), but the\n    controller now has two GCD sequences that differ only in their entry-point\n    labels.  It would be better to replace these two sequences by branches to a\n    single sequence—a ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"tag":"EM","child":[{"body":"subroutine","tag":"#text"}]},{"body":"—at the end of which we branch back to the\n    correct place in the main instruction sequence.  We can accomplish this as\n    follows: Before branching to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":", we place a\n    distinguishing value (such as 0 or 1) into a special register, \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":".  At the end of the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":" subroutine we return either to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"after_gcd_1"},{"body":" or to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"after_gcd_2"},{"body":", depending\n    on the value of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register.\n    Figure ","tag":"#text"},{"tag":"REF","body":"5.9","href":"/sicpjs/5.1.3#fig-5.9"},{"body":" shows the relevant portion\n    of the resulting controller sequence, which includes only a single copy of\n    the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":" instructions.\n    ","tag":"#text"},{"tag":"FIGURE","snippet":{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n\"gcd_1\",\n  test(list(op(\"=\"), reg(\"b\"), constant(0))),\n  branch(label(\"after_gcd_1\")),\n  assign(\"t\", list(op(\"rem\"), reg(\"a\"), reg(\"b\"))),\n  assign(\"a\", reg(\"b\")),\n  assign(\"b\", reg(\"t\")),\n  go_to(label(\"gcd_1\")),\n\"after_gcd_1\",\n  $\\vdots$\n\"gcd_2\",\n  test(list(op(\"=\"), reg(\"b\"), constant(0))),\n  branch(label(\"after_gcd_2\")),\n  assign(\"t\", list(op(\"rem\"), reg(\"a\"), reg(\"b\"))),\n  assign(\"a\", reg(\"b\")),\n  assign(\"b\", reg(\"t\")),\n  go_to(label(\"gcd_2\")),\n\"after_gcd_2\"\n\t"},"captionHref":"/sicpjs/5.1.3#fig-5.8","captionName":"Figure 5.8 ","captionBody":[{"body":"Portions of the controller sequence for a machine that\n      uses the same data-path components for two different GCD\n      computations.","tag":"#text"}]},{"tag":"FIGURE","snippet":{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n\"gcd\",\n  test(list(op(\"=\"), reg(\"b\"), constant(0))),\n  branch(label(\"gcd_done\")),\n  assign(\"t\", list(op(\"rem\"), reg(\"a\"), reg(\"b\"))),\n  assign(\"a\", reg(\"b\")),\n  assign(\"b\", reg(\"t\")),\n  go_to(label(\"gcd\")),\n\"gcd_done\",\n  test(list(op(\"=\"), reg(\"continue\"), constant(0))),\n  branch(label(\"after_gcd_1\")),\n  go_to(label(\"after_gcd_2\")),\n  $\\vdots$\n  // Before branching to $\\texttt{gcd}$ from the first place where\n  // it is needed, we place 0 in the $\\texttt{continue}$ register\n  assign(\"continue\", constant(0)),\n  go_to(label(\"gcd\")),\n\"after_gcd_1\",\n  $\\vdots$\n  // Before the second use of $\\texttt{gcd}$, we place 1 in the $\\texttt{continue}$ register\n  assign(\"continue\", constant(1)),\n  go_to(label(\"gcd\")),\n\"after_gcd_2\"\n\t"},"captionHref":"/sicpjs/5.1.3#fig-5.9","captionName":"Figure 5.9 ","captionBody":[{"body":"\n\tUsing a ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register to avoid\n\tthe duplicate controller sequence in\n\tfigure ","tag":"#text"},{"tag":"REF","body":"5.8","href":"/sicpjs/5.1.3#fig-5.8"},{"body":".\n      ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    This is a reasonable approach for handling small problems, but it would be\n    awkward if there were many instances of GCD computations in the controller\n    sequence.  To decide where to continue executing after the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":" subroutine, we would need tests in the data\n    paths and branch instructions in the controller for all the places that use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":". A more powerful method for implementing\n    subroutines is to have the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register\n    hold the label of the entry point in the controller sequence at which\n    execution should continue when the subroutine is finished. Implementing this\n    strategy requires a new kind of connection between the data paths and the\n    controller of a register machine: There must be a way to assign to a\n    register a label in the controller sequence in such a way that this value\n    can be fetched from the register and used to continue execution at the\n    designated entry point.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    To reflect this ability, we will extend the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assign"},{"body":"\n    instruction of the register-machine language to allow a register to be\n    assigned as value a label from the controller sequence (as a special\n    kind of constant).  We will also extend the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"go_to"},{"body":"\n    instruction to allow execution to continue at the entry point described by\n    the contents of a register rather than only at an entry point described by\n    a constant label.  Using these new constructs we can terminate the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":" subroutine with a branch to the location\n    stored in the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register.  This leads\n    to the controller sequence shown in\n    figure ","tag":"#text"},{"tag":"REF","body":"5.10","href":"/sicpjs/5.1.3#fig-5.10"},{"body":".\n  ","tag":"#text"}]},{"tag":"FIGURE","snippet":{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n\"gcd\",\n  test(list(op(\"=\"), reg(\"b\"), constant(0))),\n  branch(label(\"gcd_done\")),\n  assign(\"t\", list(op(\"rem\"), reg(\"a\"), reg(\"b\"))),\n  assign(\"a\", reg(\"b\")),\n  assign(\"b\", reg(\"t\")),\n  go_to(label(\"gcd\")),\n\"gcd_done\",\n  go_to(reg(\"continue\")),\n  $\\vdots$\n  // Before calling $\\texttt{gcd}$, we assign to $\\texttt{continue}$\n  // the label to which $\\texttt{gcd}$ should return.\n  assign(\"continue\", label(\"after_gcd_1\"))),\n  go_to(label(\"gcd\")),\n\"after_gcd_1\",\n  $\\vdots$\n  // Here is the second call to $\\texttt{gcd}$, with a different continuation.\n  assign(\"continue\", label(\"after_gcd_2\")),\n  go_to(label(\"gcd\")),\n\"after_gcd_2\"\n\t"},"captionHref":"/sicpjs/5.1.3#fig-5.10","captionName":"Figure 5.10 ","captionBody":[{"body":"\n\tAssigning labels to the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register\n\tsimplifies  and generalizes the strategy shown in\n\tfigure ","tag":"#text"},{"tag":"REF","body":"5.9","href":"/sicpjs/5.1.3#fig-5.9"},{"body":".\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    A machine with more than one subroutine could use multiple\n    continuation registers (e.g., ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd_continue"},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial_continue"},{"body":") or we could have all\n    subroutines share a single\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register.  Sharing is more economical,\n    but we must be careful if we have a subroutine\n    (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sub1"},{"body":") that calls another subroutine\n    (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sub2"},{"body":").  Unless\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sub1"},{"body":" saves the contents of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" in some other register before setting\n    up ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" for the call to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sub2"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sub1"},{"body":" will\n    not know where to go when it is finished.  The mechanism developed in the\n    next section to handle recursion also provides a better solution to this\n    problem of nested subroutine calls.\n  ","tag":"#text"}]}]