[{"id":"/sicpjs/4.4.2","tag":"TITLE","body":"4.4.2  \n    How the Query System Works"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"4.4.4","href":"/sicpjs/4.4.4"},{"body":" we will\n    present an implementation of the query interpreter as a collection of\n    functions.\n    In this section we give an overview that explains the general\n    structure of the system independent of low-level implementation\n    details.  After describing the implementation of the interpreter, we\n    will be in a position to understand some of its limitations and some\n    of the subtle ways in which the query language's logical operations\n    differ from the operations of mathematical logic.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    It should be apparent that the query evaluator must perform some kind\n    of search in order to match queries against facts and rules in the\n    data base.  One way to do this would be to implement the query system\n    as a nondeterministic program, using the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"amb"},{"body":"\n    evaluator of section ","tag":"#text"},{"tag":"REF","body":"4.3","href":"/sicpjs/4.3"},{"body":"\n    (see exercise ","tag":"#text"},{"tag":"REF","body":"4.75","href":"/sicpjs/4.4.4#ex-4.75"},{"body":").  Another possibility\n    is to manage the search with the aid of streams.  Our implementation follows\n    this second approach.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    The query system is organized around two central operations, called\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"pattern matching","tag":"#text"}]},{"body":" and ","tag":"#text"},{"tag":"EM","child":[{"body":"unification","tag":"#text"}]},{"body":".  We first describe\n    pattern matching and explain how this operation, together with the\n    organization of information in terms of streams of frames, enables us\n    to implement both simple and compound queries.  We next discuss\n    unification, a generalization of pattern matching needed to implement\n    rules.  Finally, we show how the entire query interpreter fits\n    together through a\n    function\n    that classifies\n    queries\n    in a manner analogous to the way\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":"\n    classifies expressions for the interpreter described in\n    section ","tag":"#text"},{"tag":"REF","body":"4.1","href":"/sicpjs/4.1"},{"body":".\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Pattern matching","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    A ","tag":"#text"},{"tag":"EM","child":[{"body":"pattern matcher","tag":"#text"}]},{"body":" is a program that tests whether some datum\n    fits a specified pattern.  For example, the \n    \n\tdatum\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(list(\"a\", \"b\"), \"c\", list(\"a\", \"b\"))"},{"body":"\n    matches the pattern\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, \"c\", $x)"},{"body":"\n    with the pattern variable\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"a\", \"b\")"},{"body":".\n    \n    The same\n    \n\tdata list\n      \n    matches the pattern\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, $y, $z)"},{"body":"\n    with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$z"},{"body":"\n    both bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"a\", \"b\")"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"c\""},{"body":".\n    It also matches the pattern\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(list($x, $y), \"c\", list($x, $y))"},{"body":"\n    with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a\""},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"b\""},{"body":".\n    However, it does not match the pattern\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, \"a\", $y)"},{"body":",\n      \n    since that pattern specifies a list whose second element is the\n    string ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a\""},{"body":".","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    The pattern matcher used by the query system takes as inputs a\n    pattern, a datum, and a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"frame","tag":"#text"}]},{"body":" that specifies bindings for\n    various pattern variables.  It checks whether the datum matches the\n    pattern in a way that is consistent with the bindings already in the\n    frame.  If so, it returns the given frame augmented by any bindings\n    that may have been determined by the match.  Otherwise, it indicates\n    that the match has failed.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n\tUsing the pattern\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, $y, $x)"},{"body":"\n    to match\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"a\", \"b\", \"a\")"},{"body":"\n\tgiven an empty frame, for example,\n      \n    will return a frame specifying that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    is bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a\""},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    is bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"b\""},{"body":".\n    Trying the match with the same pattern, the same datum, and a frame\n    specifying that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    is bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a\""},{"body":"\n    will fail.  Trying the match with the same pattern, the same datum, and a\n    frame in which\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    is bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"b\""},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    is unbound will return the given frame augmented by a binding of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a\""},{"body":".","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    The pattern matcher is all the mechanism that is needed to process\n    \n    simple\n    queries that don't involve rules.  For instance, to process the query\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"job($x, list(\"computer\", \"programmer\"))"},{"body":"\n    we scan through all assertions in the data base and select those that\n    match the pattern with respect to an initially empty frame.  For each\n    match we find, we use the frame returned by the match to instantiate\n    the pattern with a value for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":".","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Streams of frames","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    The testing of patterns against frames is organized through the use of\n    \n    streams.  Given a single frame, the matching process runs through the\n    data-base entries one by one.  For each data-base entry, the matcher\n    generates either a special symbol indicating that the match has failed\n    or an extension to the frame.  The results for all the data-base\n    entries are collected into a stream, which is passed through a filter\n    to weed out the failures.  The result is a stream of all the frames\n    that extend the given frame via a match to some assertion in the data\n    base.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/4.4.2#footnote-1"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    In our system, a query takes an input stream of frames and performs\n    the above matching operation for every frame in the stream, as\n    indicated in\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"4.5","href":"/sicpjs/4.4.2#fig-4.5"},{"body":".\n      \n    That is, for\n    each frame in the input stream, the query generates a new stream consisting\n    of all extensions to that frame by matches to assertions in the data base.\n    All these streams are then combined to form one huge stream, which contains\n    all possible extensions of every frame in the input stream. This stream is\n    the output of the query.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"80%","src":"img_javascript/Fig4.4a.std.svg","id":"#fig-4.5","captionHref":"/sicpjs/4.4.2#fig-4.5","captionName":"Figure 4.5 ","captionBody":[{"body":"A query processes a stream of frames.","tag":"#text"}]}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    To answer a\n    \n    simple query, we use the query with an input stream\n    consisting of a single empty frame.  The resulting output stream\n    contains all extensions to the empty frame (that is, all answers to\n    our query).  This stream of frames is then used to generate a stream\n    of copies of the original query pattern with the variables\n    instantiated by the values in each frame, and this is the stream that\n    is finally printed.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"Compound queries","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    The real elegance of the stream-of-frames implementation is evident\n    when we deal with compound queries.  The processing of compound\n    queries makes use of the ability of our matcher to demand that a match\n    be consistent with a specified frame.  For example, to handle the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":" of two queries, such as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"and(can_do_job($x, list(\"computer\", \"programmer\", \"trainee\")),\n    job($person, $x))"},{"body":"\n    (informally, \"","tag":"#text"},{"body":"Find all people who can do the job of a computer\n    programmer trainee","tag":"#text"},{"body":"\"), we first find all entries that match the\n    pattern\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"can_do_job($x, list(\"computer\", \"programmer\", \"trainee\"))"},{"body":"\n    This produces a stream of frames, each of which contains a binding for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":".\n    Then for each frame in the stream we find all entries that\n    match\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"job($person, $x)"},{"body":"\n    in a way that is consistent with the given binding for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":".\n    Each such match will produce a frame containing bindings for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$person"},{"body":".\n    The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":" of two queries can be viewed as a series\n    combination of the two component queries, as shown in\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"4.6","href":"/sicpjs/4.4.2#fig-4.6"},{"body":".\n      \n    The frames that pass through the\n    first query filter are filtered and further extended by the second query.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"80%","src":"img_javascript/Fig4.5a.std.svg","id":"#fig-4.6","captionHref":"/sicpjs/4.4.2#fig-4.6","captionName":"Figure 4.6 ","captionBody":[{"body":"\n\t    The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":" combination of two queries is\n            produced by operating on the stream of frames in series.\n\t  ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    Figure ","tag":"#text"},{"tag":"REF","body":"4.7","href":"/sicpjs/4.4.2#fig-4.7"},{"body":"\n    shows the analogous method for\n    computing the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"or"},{"body":" of two queries as a parallel\n    combination of the two component queries.  The input stream of frames is\n    extended separately by each query.  The two resulting streams are then\n    merged to produce the final output stream.\n\n    ","tag":"#text"},{"tag":"FIGURE","scale":"80%","src":"img_javascript/Fig4.6a.std.svg","id":"#fig-4.7","captionHref":"/sicpjs/4.4.2#fig-4.7","captionName":"Figure 4.7 ","captionBody":[{"body":"\n\t    The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"or"},{"body":" combination of two\n\t    queries is produced by operating on the stream of frames in parallel\n\t    and merging the results.\n\t  ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    Even from this high-level description, it is apparent that the\n    processing of compound queries can be slow.\n    \n    For example, since a query may produce more than one output frame for each\n    input frame, and each query in an ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":" gets its\n    input frames from the previous query, an ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":"\n    query could, in the worst case, have to perform a number of matches that is\n    exponential in the number of queries (see \n    exercise ","tag":"#text"},{"tag":"REF","body":"4.73","href":"/sicpjs/4.4.4#ex-4.73"},{"body":").","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/4.4.2#footnote-2"},{"body":"\n    Though systems for handling only simple queries are quite practical, dealing\n    with complex queries is extremely difficult.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/4.4.2#footnote-3"}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n    From the stream-of-frames viewpoint, the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" of\n    some query acts as a filter that removes all frames for which the query can\n    be satisfied.  For instance, given the pattern\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"not(job($x, list(\"computer\", \"programmer\")))"},{"body":"\n    we attempt, for each frame in the input stream, to produce extension\n    frames that satisfy\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"job($x, list(\"computer\", \"programmer\"))"},{"body":".\n      \n    We remove from the input stream all frames for which such extensions exist.\n    The result is a stream consisting of only those frames in which the binding\n    for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    does not satisfy\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"job($x, list(\"computer\", \"programmer\"))"},{"body":".\n      \n    For example, in processing the query\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"and(supervisor($x, $y),\n    not(job($x, list(\"computer\", \"programmer\"))))"},{"body":"\n    the first clause will generate frames with bindings for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":".\n    The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" clause will then filter these by\n    removing all frames in which the binding for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    satisfies the restriction that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    is a computer programmer.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/4.4.2#footnote-4"}]},{"tag":"TEXT","id":"#p15","child":[{"body":"\n    The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"javascript_predicate"},{"body":"\n\tsyntactic form\n      \n    is implemented as a similar filter on frame streams.  We use each frame in\n    the stream to instantiate any variables in the pattern, then apply the\n    JavaScript\n    predicate.  We remove from the input stream all frames for which the\n    predicate fails.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h4","child":[{"body":"Unification","tag":"#text"}]},{"tag":"TEXT","id":"#p16","child":[{"body":"\n    In order to handle rules in the query language, we must be able to\n    find the rules whose conclusions match a given query pattern.  Rule\n    conclusions are like assertions except that they can contain\n    variables, so we will need a generalization of pattern\n    matching—called ","tag":"#text"},{"tag":"EM","child":[{"body":"unification","tag":"#text"}]},{"body":"—in which both the\n    \"","tag":"#text"},{"body":"pattern","tag":"#text"},{"body":"\" and the \"","tag":"#text"},{"body":"datum","tag":"#text"},{"body":"\" may contain variables.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p17","child":[{"body":"\n    A unifier takes two patterns, each containing constants and variables,\n    and determines whether it is possible to assign values to the\n    variables that will make the two patterns equal.  If so, it returns a\n    frame containing these bindings.  For example, unifying\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, \"a\", $y)"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($y, $z, \"a\")"},{"body":"\n    will specify a frame in which\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$z"},{"body":"\n    must all be bound to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a\""},{"body":".\n    On the other hand, unifying\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, $y, \"a\")"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, \"b\", $y)"},{"body":"\n    will fail, because there is no value for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    that can make the two patterns equal. (For the second elements of the\n    patterns to be equal,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    would have to be\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"b\""},{"body":";\n    however, for the third elements to be equal,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    would have to be\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a\""},{"body":".)\n    The unifier used in the query system, like the pattern matcher, takes a\n    frame as input and performs unifications that are consistent with this frame.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p18","child":[{"body":"\n    The unification algorithm is the most technically difficult part of\n    the query system.  With complex patterns, performing unification may\n    seem to require deduction.\n    To unify\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"list($x, $x)"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":false,"body":"list(list(\"a\", $y, \"c\"), list(\"a\", \"b\", $z))"},{"body":"\n    for example,\n    the algorithm must infer that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    should be\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"a\", \"b\", \"c\")"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    should be\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"b\""},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$z"},{"body":"\n    should be\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"c\""},{"body":".\n    We may think of this process as solving a set of equations among the pattern\n    components.  In general, these are simultaneous equations, which may require\n    substantial manipulation to solve.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/4.4.2#footnote-5"},{"body":"  For example,\n    unifying\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, $x)"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(list(\"a\", $y, \"c\"), list(\"a\", \"b\", $z))"},{"body":"\n    may be thought of as specifying the simultaneous equations\n    ","tag":"#text"},{"body":"\n\t  \\[\\begin{array}{lll}\n\t  \\texttt{\\$x} & = & \\texttt{list(\"a\", \\$y, \"c\")} \\\\\n\t  \\texttt{\\$x} & = & \\texttt{list(\"a\", \"b\", \\$z)} \\\\\n\t  \\end{array}\\]\n\t","tag":"LATEX"},{"body":"\n    These equations imply that\n    ","tag":"#text"},{"body":"\n\t  \\[\\begin{array}{lll}\n\t  \\texttt{list(\"a\", \\$y, \"c\")} & = &  \\texttt{list(\"a\", \"b\", \\$z)}\n\t  \\end{array}\\]\n\t","tag":"LATEX"},{"body":"\n    which in turn implies that\n    ","tag":"#text"},{"body":"\n\t  \\[\\begin{array}{lllllll}\n\t  \\texttt{\"a\"} & = & \\texttt{\"a\"},\\qquad\n             \\texttt{\\$y} & = & \\texttt{\"b\"},\\qquad\n             \\texttt{\"c\"} & = & \\texttt{\\$z}\n\t     \\end{array}\\]\n\t","tag":"LATEX"},{"body":"\n    and hence that\n    ","tag":"#text"},{"body":"\n\t  \\[\\begin{array}{lll}\n\t  \\texttt{\\$x} & = & \\texttt{list(\"a\", \"b\", \"c\")}\n\t  \\end{array}\\]\n\t","tag":"LATEX"}]},{"tag":"TEXT","id":"#p19","child":[{"body":"\n    In a successful pattern match, all pattern variables become bound, and\n    the values to which they are bound contain only constants.  This is\n    also true of all the examples of unification we have seen so far.\n    \n    In general, however, a successful unification may not completely\n    determine the variable values; some variables may remain unbound and\n    others may be bound to values that contain variables.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p20","child":[{"body":"\n    Consider the unification of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, \"a\")"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(list(\"b\", $y), $z)"},{"body":".\n    \n    We can deduce that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"$=$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":"list(\"b\", $y)"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a\""},{"body":"$=$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":"$z"},{"body":",\n    but we cannot further solve for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    or\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":".\n    The unification doesn't fail, since it is certainly possible to make\n    the two patterns equal by assigning values to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":".\n    Since this match in no way restricts the values\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    can take on, no binding for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    is put into the result frame. The match does, however, restrict the value of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":".\n    Whatever value\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    has,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    must be\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"b\", $y)"},{"body":".\n      \n    A binding of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    to the pattern\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"b\", $y)"},{"body":"\n    is thus put into the frame.  If a value for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"\n    is later determined and added to the frame (by a pattern match or\n    unification that is required to be consistent with this frame), the\n    previously bound\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    will refer to this value.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-6","body":"6","href":"/sicpjs/4.4.2#footnote-6"}]},{"tag":"SUBHEADING","id":"#h5","child":[{"body":"Applying rules","tag":"#text"}]},{"tag":"TEXT","id":"#p21","child":[{"body":"\n    Unification is the key to the component of the query system that makes\n    inferences from rules. To see how this is accomplished, consider\n    processing a query that involves applying a rule, such as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":false,"body":"lives_near($x, list(\"Hacker\", \"Alyssa\", \"P\"))"},{"body":"\n    To process this query, we first use the ordinary pattern-match\n    function\n    described above to see if there are any assertions in the data base that\n    match this pattern.  (There will not be any in this case, since our data\n    base includes no direct assertions about who lives near whom.)  The next\n    step is to attempt to unify the query pattern with the conclusion of each\n    rule.  We find that the pattern unifies with the conclusion of the rule\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":false,"body":"rule(lives_near($person_1, $person_2),\n     and(address($person_1, pair($town, $rest_1)),\n         address($person_2, list($town, $rest_2)),\n         not(same($person_1, $person_2))))"},{"body":"\n    resulting in a frame specifying that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n\tshould be bound to (have the same value as)\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$person_1"},{"body":"\n\tand that\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$person_2"},{"body":"\n\tis bound to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"Hacker\", \"Alyssa\", \"P\")"},{"body":".\n      \n    Now, relative to this frame, we evaluate the compound query given by the body\n    of the rule.  Successful matches will extend this frame by providing a\n    binding for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$person_1"},{"body":",\n    and consequently a value for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":",\n    which we can use to instantiate the original query pattern.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p22","child":[{"body":"\n    In general, the query evaluator uses the following method to apply a\n    rule when trying to establish a query pattern in a frame that\n    specifies bindings for some of the pattern variables:\n\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tUnify the query with the conclusion of the rule to form, if\n\tsuccessful, an extension of the original frame.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tRelative to the extended frame, evaluate the query formed by\n\tthe body of the rule.\n      ","tag":"#text"}]}]}]},{"tag":"TEXT","id":"#p23","child":[{"body":"\n    Notice how similar this is to the method for applying a\n    function\n    in the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":"/","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply"},{"body":"\n    evaluator for\n    JavaScript:","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tBind the\n\tfunction's\n\tparameters to its arguments to form a frame that extends the original\n\tfunction\n\tenvironment.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tRelative to the extended environment, evaluate the expression\n\tformed by the body of the\n\tfunction.","tag":"#text"}]}]},{"body":"\n    The similarity between the two evaluators should come as no surprise.\n    Just as\n    function\n    definitions are the means of abstraction in\n    JavaScript,\n    rule definitions are the means of abstraction in the query language.\n    In each case, we unwind the abstraction by creating appropriate\n    bindings and evaluating the rule or\n    function\n    body relative to these.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h6","child":[{"body":"Simple queries","tag":"#text"}]},{"tag":"TEXT","id":"#p24","child":[{"body":"\n    We saw earlier in this section how to evaluate simple queries in the\n    absence of rules.  Now that we have seen how to apply rules, we can\n    describe how to evaluate simple queries by using both rules and\n    assertions.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p25","child":[{"body":"\n    Given the query pattern and a stream of frames, we produce, for each\n    frame in the input stream, two streams:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"a stream of extended frames obtained by matching the pattern\n      against all assertions in the data base (using the pattern matcher),\n      and\n\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"a stream of extended frames obtained by applying all\n      possible rules (using the unifier).","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-7","body":"7","href":"/sicpjs/4.4.2#footnote-7"}]}]},{"body":"\n    Appending these two streams produces a stream that consists of all the\n    ways that the given pattern can be satisfied consistent with the\n    original frame.  These streams (one for each frame in the input\n    stream) are now all combined to form one large stream, which therefore\n    consists of all the ways that any of the frames in the original input\n    stream can be extended to produce a match with the given pattern.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h7","child":[{"body":"The query evaluator and the driver loop","tag":"#text"}]},{"tag":"TEXT","id":"#p26","child":[{"body":"\n    Despite the complexity of the underlying matching operations, the\n    system is organized much like an\n    \n    evaluator for any language.  The\n    function\n    that coordinates the matching operations is called \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate_query"},{"body":",\n      \n    and it plays a role analogous to that of the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":"function\n    for\n    JavaScript.The function\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate_query"},{"body":"\n    takes as inputs a query and a stream of frames.  Its output is a stream of\n    frames, corresponding to successful matches to the query pattern, that\n    extend some frame in the input stream, as indicated in\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"4.5","href":"/sicpjs/4.4.2#fig-4.5"},{"body":".\n      \n    Like\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate_query"},{"body":"\n    classifies the different types of expressions (queries) and dispatches to an\n    appropriate\n    function\n    for each.  There is a\n    function\n    for each\n    syntactic\n    form\n    (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"or"},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":", and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"javascript_predicate"},{"body":")\n      \n    and one for simple queries.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p27","child":[{"body":"\n    The\n    \n    driver loop, which is analogous to the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"driver_loop"},{"body":"function\n    for the other evaluators in this chapter, reads queries\n    typed by the user.\n    For each query, it calls\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate_query"},{"body":"\n    with the query and a stream that consists of a single empty frame.  This\n    will produce the stream of all possible matches (all possible extensions to\n    the empty frame).  For each frame in the resulting stream, it instantiates\n    the original query using the values of the variables found in the frame.\n    This stream of instantiated queries is then printed.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-8","body":"8","href":"/sicpjs/4.4.2#footnote-8"}]},{"tag":"TEXT","id":"#p28","child":[{"body":"\n    The driver also checks for the special command\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assert"},{"body":",\n    which signals that the input is not a query but rather an assertion or rule\n    to be added to the data base.  For instance,\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":false,"body":"assert(job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\")))\n\nassert(rule(wheel($person),\n            and(supervisor($middle_manager, $person),\n                supervisor($x, $middle_manager))))"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/4.4.2#footnote-link-1","child":[{"body":"Because matching is generally very\n    \n    expensive, we would\n    like to avoid applying the full matcher to every element of the data\n    base.  This is usually arranged by breaking up the process into a\n    fast, coarse match and the final match.  The coarse match filters the\n    data base to produce a small set of candidates for the final match.\n    With care, we can arrange our data base so that some of the work of\n    coarse matching can be done when the data base is constructed rather\n    then when we want to select the candidates.  This is called\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"indexing","tag":"#text"}]},{"body":" the data base.  There is a vast technology built around\n    data-base-indexing schemes.  Our implementation, described in\n    section ","tag":"#text"},{"tag":"REF","body":"4.4.4","href":"/sicpjs/4.4.4"},{"body":", contains a\n    simpleminded form of such an optimization.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/4.4.2#footnote-link-2","child":[{"body":"But this kind\n    of exponential explosion is not common in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":"\n    queries because the added conditions tend to reduce rather than expand\n    the number of frames produced.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/4.4.2#footnote-link-3","child":[{"body":"There is a large\n    literature on data-base-management systems that is concerned with how to\n    handle complex queries efficiently.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/4.4.2#footnote-link-4","child":[{"body":"There is a subtle difference between this\n    filter implementation of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" and the usual\n    meaning of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" in mathematical logic.  See\n    section ","tag":"#text"},{"tag":"REF","body":"4.4.3","href":"/sicpjs/4.4.3"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/4.4.2#footnote-link-5","child":[{"body":"In one-sided pattern matching,\n    all the equations that contain pattern variables are explicit and already\n    solved for the unknown (the pattern variable).","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-6","count":6,"href":"/sicpjs/4.4.2#footnote-link-6","child":[{"body":"Another way to think of unification is\n    that it generates the most general pattern that is a specialization of the\n    two input patterns.\n    \n\tThis means that the unification of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, \"a\")"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(list(\"b\", $y), $z)"},{"body":"\n    is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(list(\"b\", $y), \"a\")"},{"body":"\n    and\n    \n\tthat\n      \n    the unification of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($x, \"a\", $y)"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list($y, $z, \"a\")"},{"body":",\n      \n    discussed above, is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"a\", \"a\", \"a\")"},{"body":".\n      \n    For our implementation, it is more convenient to think of the result\n    of unification as a frame rather than a pattern.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-7","count":7,"href":"/sicpjs/4.4.2#footnote-link-7","child":[{"body":"Since unification is a\n      \n      generalization of matching, we could simplify the system by using the\n      unifier to produce both streams.  Treating the easy case with the\n      simple matcher, however, illustrates how matching (as opposed to\n      full-blown unification) can be useful in its own right.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-8","count":8,"href":"/sicpjs/4.4.2#footnote-link-8","child":[{"body":"The reason we\n    use\n    \n    streams (rather than lists) of frames is that the\n    recursive application of rules can generate infinite numbers of values that\n    satisfy a query.  The delayed evaluation embodied in streams is crucial\n    here: The system will print responses one by one as they are generated,\n    regardless of whether there are a finite or infinite number of\n    responses.","tag":"#text"}]}]