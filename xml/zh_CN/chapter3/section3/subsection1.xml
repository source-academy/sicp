<SUBSECTION> 
   <NAME>
    可变列表结构
  </NAME> 

  <LABEL NAME="sec:mutable-list-structure"></LABEL>
   <INDEX>可变数据对象<SUBINDEX>列表结构<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>列表结构<SUBINDEX>可变的<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>可变数据对象<SUBINDEX>对<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>对偶<SUBINDEX>可变</SUBINDEX></INDEX> 

   <TEXT>
    关于
    <SPLITINLINE>
      <SCHEME>
	对偶<EMDASH></EMDASH><SCHEMEINLINE>cons</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	对偶<EMDASH></EMDASH><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE><EMDASH></EMDASH>能</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE><EMDASH></EMDASH>能
      </JAVASCRIPT>
    </SPLITINLINE>
    这些基本操作可以用来构造列表结构并从列表结构中选择部分，但它们无法修改列表结构。到目前为止我们使用的列表操作，如<SCHEMEINLINE>append</SCHEMEINLINE>和<SCHEMEINLINE>list</SCHEMEINLINE>也同样如此，因为它们可以用
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    来定义。要修改列表结构，我们需要新的操作.
  </TEXT> 

   <TEXT>
    对偶的原始变更器为
    <INDEX><USE>set_head</USE> (原始函数)</INDEX>
    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>set_head</USE> (\textit{ns})</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <INDEX><USE>set_tail</USE> (原始函数)</INDEX>
    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>set_tail</USE> (\textit{ns})</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    接受两个参数，其中第一个必须是一个对偶。它修改该对偶，用第二个参数的指针替换
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针，此替换操作由
    <SPLITINLINE><SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>执行。<FOOTNOTE>
    <SPLIT>
      <SCHEME>
	<SCHEMEINLINE>Set-car!</SCHEMEINLINE> 和
	<SCHEMEINLINE>set-cdr!</SCHEMEINLINE> 返回依赖于实现的
	<INDEX><USE>set-car!</USE> (原始函数)<SUBINDEX>的值</SUBINDEX></INDEX>
	<INDEX>未指定的值<SUBINDEX><ORDER>set-car</ORDER><SCHEMEINLINE>set-car!</SCHEMEINLINE></SUBINDEX></INDEX>
	<INDEX><USE>set-cdr!</USE> (原始函数)<SUBINDEX>的值</SUBINDEX></INDEX>
	<INDEX>未指定的值<SUBINDEX><ORDER>set-cdr</ORDER><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SUBINDEX></INDEX>
	值。类似于 <SCHEMEINLINE>set!</SCHEMEINLINE>，它们应仅用于其副作用。
      </SCHEME>
      <JAVASCRIPT>
	函数 <JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE> 返回值
	<JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>。
	<INDEX><USE>set_head</USE> (原始函数)<SUBINDEX>的值</SUBINDEX></INDEX>
	<INDEX><USE>set_tail</USE> (原始函数)<SUBINDEX>的值</SUBINDEX></INDEX>
	它们应仅用于其副作用。
      </JAVASCRIPT>
    </SPLIT></FOOTNOTE>
  </TEXT> 

   <TEXT>
    例如，假设 <SCHEMEINLINE>x</SCHEMEINLINE> 被绑定到
    <SPLITINLINE>
      <SCHEME>
	列表
	<SCHEMEINLINE>((a b) c d)</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>list(list(&quot;a&quot;, &quot;b&quot;), &quot;c&quot;, &quot;d&quot;)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    以及 <SCHEMEINLINE>y</SCHEMEINLINE> 被绑定到
    <SPLITINLINE>
      <SCHEME>
	列表
	<SCHEMEINLINE>(e f)</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>list(&quot;e&quot;, &quot;f&quot;)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    如下图所示
    <SPLITINLINE>
      <SCHEME>
        图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>.
      </SCHEME>
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
    求值表达式
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(set-car! x y)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>set_head(x, y)</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    将修改 <SCHEMEINLINE>x</SCHEMEINLINE> 所绑定的对偶，用 <SCHEMEINLINE>y</SCHEMEINLINE> 的值替换其
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    。操作的结果如图所示
    <SPLITINLINE>
      <SCHEME>
        图<SPACE></SPACE><REF NAME="fig:set-car_scheme"></REF>.
      </SCHEME>
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:set-car"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
    结构 <SCHEMEINLINE>x</SCHEMEINLINE> 已经被修改，并且
    <SPLITINLINE>
      <SCHEME>
	现在将打印为
	<SCHEMEINLINE>((e<SPACE></SPACE>f)<SPACE></SPACE>c<SPACE></SPACE>d)</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	现在等价于
	<JAVASCRIPTINLINE>list(list(&quot;e&quot;, &quot;f&quot;), &quot;c&quot;, &quot;d&quot;)</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    被替换指针所标识的、代表列表
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(a b)</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;a&quot;, &quot;b&quot;)</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    的对偶现在已与原结构分离。<FOOTNOTE>由此，我们可以看出，列表上的变更操作可能会产生不属于任何可访问结构的<QUOTE>垃圾</QUOTE>。我们将在第<SPACE></SPACE><REF NAME="sec:gc"></REF>节中看到，<SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    内存管理系统包括一个<INDEX>garbage collection<SUBINDEX>mutation and</SUBINDEX></INDEX> <EM>garbage collector</EM>（垃圾回收器），它能够识别并回收未使用对偶所占用的内存空间。</FOOTNOTE>
  </TEXT> 

     <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-13.svg"></FIGURE>
          <CAPTION>
	    列表 <SCHEMEINLINE>x</SCHEMEINLINE>:
	    <SCHEMEINLINE>((a b) c d)</SCHEMEINLINE> 和
	    <SCHEMEINLINE>y</SCHEMEINLINE>: <SCHEMEINLINE>(e f)</SCHEMEINLINE>.
          </CAPTION>
          <LABEL NAME="fig:two-lists_scheme"></LABEL>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-13.svg"></FIGURE>
          <CAPTION>
	    列表 <SCHEMEINLINE>x</SCHEMEINLINE>:
	    <JAVASCRIPTINLINE>list(list(&quot;a&quot;, &quot;b&quot;), &quot;c&quot;, &quot;d&quot;)</JAVASCRIPTINLINE>
	    和 <SCHEMEINLINE>y</SCHEMEINLINE>:
	    <JAVASCRIPTINLINE>list(&quot;e&quot;, &quot;f&quot;)</JAVASCRIPTINLINE>.
          </CAPTION>
          <LABEL NAME="fig:two-lists"></LABEL>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT> 
     <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-14.svg"></FIGURE>
          <CAPTION>
	    <SCHEMEINLINE>(set-car! x y)</SCHEMEINLINE> 对图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>中列表的作用.
          </CAPTION>
          <LABEL NAME="fig:set-car_scheme"></LABEL>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-14.svg"></FIGURE>
          <CAPTION>
	    <JAVASCRIPTINLINE>set_head(x, y)</JAVASCRIPTINLINE> 对图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>中列表的作用.
          </CAPTION>
          <LABEL NAME="fig:set-car"></LABEL>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT> 
     <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-15.svg"></FIGURE>
          <CAPTION>
	    <SCHEMEINLINE>(define z (cons y (cdr x)))</SCHEMEINLINE> 对图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>中列表的作用.
          </CAPTION>
          <LABEL NAME="fig:list-cons_scheme"></LABEL>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-15.svg"></FIGURE>
          <CAPTION>
	    <JAVASCRIPTINLINE>const z = pair(y, tail(x));</JAVASCRIPTINLINE> 对图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>中列表的作用.
          </CAPTION>
          <LABEL NAME="fig:list-cons"></LABEL>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT> 
     <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-16.svg"></FIGURE>
          <CAPTION>
	    <SCHEMEINLINE>(set-cdr! x y)</SCHEMEINLINE> 对图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>中列表的作用.
	  </CAPTION>
          <LABEL NAME="fig:set-cdr_scheme"></LABEL>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-16.svg"></FIGURE>
          <CAPTION>
	    <JAVASCRIPTINLINE>set_tail(x, y)</JAVASCRIPTINLINE> 对图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>中列表的作用.
	  </CAPTION>
          <LABEL NAME="fig:set-cdr"></LABEL>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT> 
  
   <SHORT_PAGE LINES="3"></SHORT_PAGE> 
   <TEXT>
    比较
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE></SPACE><REF NAME="fig:set-car_scheme"></REF>
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE></SPACE><REF NAME="fig:set-car"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    与
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE></SPACE><REF NAME="fig:list-cons_scheme"></REF>,
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE></SPACE><REF NAME="fig:list-cons"></REF>,
      </JAVASCRIPT>
    </SPLITINLINE>
    它展示了执行
    <SNIPPET HIDE="yes">
      <NAME>mutable_list_example</NAME>
      <SCHEME>
(define x &apos;((a b) c d))
(define y &apos;(e f))
      </SCHEME>
      <JAVASCRIPT>
const x = list(list(&quot;a&quot;, &quot;b&quot;), &quot;c&quot;);
const y = list(&quot;e&quot;, &quot;f&quot;);
      </JAVASCRIPT>
    </SNIPPET>
    的结果
    <SNIPPET>
      <REQUIRES>mutable_list_example</REQUIRES>
      <SCHEME>
(define z (cons y (cdr x)))
      </SCHEME>
      <JAVASCRIPT>
const z = pair(y, tail(x));
      </JAVASCRIPT>
    </SNIPPET>
    ，其中 <SCHEMEINLINE>x</SCHEMEINLINE> 和 <SCHEMEINLINE>y</SCHEMEINLINE>
    分别绑定到原始列表
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>.
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE></SPACE><REF NAME="fig:two-lists"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
    该
    <SPLITINLINE>
      <SCHEME>
	       variable
      </SCHEME>
      <JAVASCRIPT>
	       name
      </JAVASCRIPT>
    </SPLITINLINE>
      <SCHEMEINLINE>z</SCHEMEINLINE> 现在绑定到由
    <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    操作创建的新对；而绑定到 <SCHEMEINLINE>x</SCHEMEINLINE> 的列表保持不变.
  </TEXT> 

   <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    操作类似于
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    。唯一的区别在于，这对的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针被替换为新的指针，而不是
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针。
    执行
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(set-cdr! x y)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail(x, y)</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    操作对
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE></SPACE><REF NAME="fig:two-lists"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    中的列表所产生的效果显示在
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE></SPACE><REF NAME="fig:set-cdr_scheme"></REF>.
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE></SPACE><REF NAME="fig:set-cdr"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
    中。
    此处，
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针在绑定到
    <SCHEMEINLINE>x</SCHEMEINLINE>
    的位置被替换为了指向
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(e f)</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;e&quot;, &quot;f&quot;)</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    的指针。
    此外，原来作为
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    部分的列表
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(c d)</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;c&quot;, &quot;d&quot;)</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    ，现在已与整个结构分离。
  </TEXT> 

   <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    通过创建新的对来构造新的列表结构，
    <SPLITINLINE>
      <SCHEME>而 <SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>而在 JavaScript 中为 <JAVASCRIPTINLINE>set_@head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    以及
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    用于修改现有的对。
    实际上，我们可以借助这两个变异器，
    <INDEX><USE>pair</USE>（原始函数）<SUBINDEX>通过变异器实现</SUBINDEX></INDEX>
    来实现
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    ，再配合一个
    <SPLITINLINE><SCHEME>过程</SCHEME><JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-new-pair</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_new_pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    该函数返回一个不属于任何现有列表结构的新对。
    我们获得这个新对后，将它的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针设置为指向指定的对象，并将这个新对作为
    <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
    的结果返回。
    <FOOTNOTE>
    <SPLIT>
      <SCHEME>
	<SCHEMEINLINE>get-new-pair</SCHEMEINLINE>
	是 Lisp 实现中内存管理必须实现的操作之一。我们将在 <REF NAME="sec:memory-as-vectors"></REF> 节中讨论这一点。
      </SCHEME>
      <JAVASCRIPT>
	<REF NAME="sec:memory-as-vectors"></REF> 节将展示内存管理系统如何实现 <JAVASCRIPTINLINE>get_new_pair</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLIT>
  </FOOTNOTE>

  <SNIPPET HIDE="yes">
    <NAME>get_new_pair</NAME>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
// 本书提出了一个原始函数 get_new_pair。
// 由于 JavaScript 不提供这样的函数，为了示例，我们将其定义如下：

function get_new_pair() {
    return pair(undefined, undefined);
}
{    
    </JAVASCRIPT>
  </SNIPPET>
  <SNIPPET POSTPADDING="no">
    <INDEX><DECLARATION>pair</DECLARATION>（原始函数）<SUBINDEX>通过变异器实现</SUBINDEX></INDEX>
    <REQUIRES>get_new_pair</REQUIRES>
    <EXAMPLE>mutable_pair_example</EXAMPLE>
    <EXPECTED>[ [ 1, 2 ], 4 ]</EXPECTED>
    <SCHEME>
(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
    </SCHEME>
    <JAVASCRIPT>
function pair(x, y) {
    const fresh = get_new_pair();
    set_head(fresh, x);
    set_tail(fresh, y);
    return fresh;
}
    </JAVASCRIPT>
  </SNIPPET>

  <SNIPPET HIDE="yes">
    <NAME>mutable_pair_example</NAME>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
pair(pair(1, 2), 4);
}
    </JAVASCRIPT>
  </SNIPPET>
  </TEXT> 

  <EXERCISE>
    <LABEL NAME="ex:append"></LABEL> 
    以下
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
用于拼接列表的方法是在章节<SPACE></SPACE><REF NAME="sec:sequences"></REF>中引入的：
<SNIPPET HIDE="yes">
      <NAME>append_example3</NAME>
      <EXPECTED>9</EXPECTED>
      <JAVASCRIPT>
append(list(1, 3), list(5, 7, 9));	
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
list_ref(append(list(1, 3), list(5, 7, 9)), 4);	
      </JAVASCRIPT_TEST>
    </SNIPPET>
     <INDEX><DECLARATION>追加</DECLARATION></INDEX>
<SNIPPET EVAL="yes">
      <NAME>append2</NAME>
      <EXAMPLE>append_example3</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      <SCHEME>
(define (append x y)
  (if (null? x)
    y
    (cons (car x) (append (cdr x) y))))
      </SCHEME>
      <JAVASCRIPT>
function append(x, y) {
    return is_null(x)
           ? y
           : pair(head(x), append(tail(x), y));
}
      </JAVASCRIPT>
    </SNIPPET>
     <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>追加</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>append</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    依次构造一个新列表，
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>cons</SCHEMEINLINE>操作，将 <SCHEMEINLINE>x</SCHEMEINLINE> 的元素添加到 <SCHEMEINLINE>y</SCHEMEINLINE> 上。
      </SCHEME>
      <JAVASCRIPT>
	将 <SCHEMEINLINE>x</SCHEMEINLINE> 的元素附加到 <JAVASCRIPTINLINE>y</JAVASCRIPTINLINE> 的前端。
      </JAVASCRIPT>
    </SPLITINLINE>
    该
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>append</USE><SUBINDEX><ORDER>追加变异器</ORDER><USE>append_mutator</USE> vs.</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>append!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>append_mutator</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    类似于 
<SCHEMEINLINE>append</SCHEMEINLINE>，但它是一个变异器而不是一个构造器。它通过将这些列表拼接在一起来追加它们，同时修改最后一对<SCHEMEINLINE>x</SCHEMEINLINE>以使其
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    现在是<SCHEMEINLINE>y</SCHEMEINLINE> . （调用
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>append!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>append_mutator</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    时传入空<SPACE></SPACE>是错误的<SCHEMEINLINE>x</SCHEMEINLINE> 。)<SNIPPET EVAL="yes">
      <INDEX><DECLARATION>append_mutator</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <NAME>append_mutator</NAME>
      <REQUIRES>last_pair</REQUIRES>
      <SCHEME>
(define (append! x y)
  (set-cdr! (last-pair x) y)
            x)
      </SCHEME>
      <JAVASCRIPT>
function append_mutator(x, y) {
    set_tail(last_pair(x), y);
    return x;
}
      </JAVASCRIPT>
    </SNIPPET>
    这里
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>最后一对</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>last_pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    是一个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>睡觉</JAVASCRIPT>
    </SPLITINLINE>
    返回其参数中最后一对：
<SNIPPET HIDE="yes">
      <NAME>last_pair_example_2</NAME>
      <JAVASCRIPT>
last_pair(list(1, 2, 3, 4, 5));
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>last_pair</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <NAME>last_pair</NAME>
      <EXAMPLE>last_pair_example_2</EXAMPLE>
      <EXPECTED>[ 5, null ]</EXPECTED>
      <SCHEME>
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
      </SCHEME>
      <JAVASCRIPT>
function last_pair(x) {
    return is_null(tail(x))
           ? x
           : last_pair(tail(x));
}
      </JAVASCRIPT>
    </SNIPPET>
    考虑交互
<SNIPPET EVAL="yes">
      <NAME>append_interaction_1</NAME>
      <REQUIRES>append2</REQUIRES>
      <REQUIRES>append_mutator</REQUIRES>
      <SCHEME>
(define x (list &apos;a &apos;b))
      </SCHEME>
      <JAVASCRIPT>
const x = list(&quot;a&quot;, &quot;b&quot;);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_2</NAME>
      <REQUIRES>append_interaction_1</REQUIRES>
      <SCHEME>
(define y (list &apos;c &apos;d))
      </SCHEME>
      <JAVASCRIPT>
const y = list(&quot;c&quot;, &quot;d&quot;);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_3</NAME>
      <REQUIRES>append_interaction_2</REQUIRES>
      <SCHEME>
(define z (append x y))
      </SCHEME>
      <JAVASCRIPT>
const z = append(x, y);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_4</NAME>
      <REQUIRES>append_interaction_3</REQUIRES>
      <SCHEME>
z
      </SCHEME>
      <SCHEMEOUTPUT>
(a b c d)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
z;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[&quot;a&quot;, [&quot;b&quot;, [&quot;c&quot;, [&quot;d, null]]]]	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_5</NAME>
      <REQUIRES>append_interaction_4</REQUIRES>
      <SCHEME>
(cdr x)
      </SCHEME>
      <SCHEMEOUTPUT>
&lt;response&gt;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
tail(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
<META>response</META>
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_6</NAME>
      <REQUIRES>append_interaction_5</REQUIRES>
      <SCHEME>
(define w (append! x y))
      </SCHEME>
      <JAVASCRIPT>
const w = append_mutator(x, y);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_7</NAME>
      <REQUIRES>append_interaction_6</REQUIRES>
      <SCHEME>
w
      </SCHEME>
      <SCHEMEOUTPUT>
(a b c d)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
w;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[&quot;a&quot;, [&quot;b&quot;, [&quot;c&quot;, [&quot;d&quot;, null]]]]      
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_8</NAME>
      <REQUIRES>append_interaction_7</REQUIRES>
      <SCHEME>
(cdr x)
      </SCHEME>
      <SCHEMEOUTPUT>
&lt;response&gt;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
tail(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
<META>response</META>
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    缺少哪些<META>response</META>？
    请绘制盒子与指针图来解释你的答案。
</EXERCISE>

  
  <EXERCISE>
    请考虑以下内容
    <INDEX>列表中的循环</INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-cycle</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_cycle</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    它使用了
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>last-pair</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>last_pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    定义在练习<SPACE></SPACE><REF NAME="ex:append"></REF>中：
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_cycle</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <NAME>make_cycle</NAME>
      <REQUIRES>last_pair</REQUIRES>
      <EXAMPLE>make_cycle_example</EXAMPLE>
      <SCHEME>
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
            x)
      </SCHEME>
      <JAVASCRIPT>
function make_cycle(x) {
    set_tail(last_pair(x), x);
    return x;
}
      </JAVASCRIPT>
    </SNIPPET>
    绘制一个盒子和指针图，展示由
    <SCHEMEINLINE>z</SCHEMEINLINE>
    创建的结构，该结构由
    <SNIPPET EVAL="yes">
      <NAME>make_cycle_example</NAME>
      <REQUIRES>make_cycle</REQUIRES>
      <EXPECTED>&apos;b&apos;</EXPECTED>
      <SCHEME>
(define z (make-cycle (list &apos;a &apos;b &apos;c)))
      </SCHEME>
      <JAVASCRIPT>
const z = make_cycle(list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
const z = make_cycle(list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
list_ref(z, 100);	
      </JAVASCRIPT_TEST>
    </SNIPPET>
    如果我们尝试计算
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(last-pair z)</SCHEMEINLINE>?</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>last_pair(z)</JAVASCRIPTINLINE>?</JAVASCRIPT>
    </SPLITINLINE>
    <LABEL NAME="ex:make-cycle"></LABEL>
    <SOLUTION>
      (由 GitHub 用户 jonathantorres 提供)
      如果我们尝试计算 <JAVASCRIPTINLINE>last_pair(z)</JAVASCRIPTINLINE>，程序将进入无限循环，因为列表的末尾指向了开头。

      <FIGURE SRC="img_javascript/ex-3-13-sol.png">
	<LABEL NAME="ex:3-13-sol"></LABEL>
      </FIGURE>
    </SOLUTION>
  </EXERCISE>


  
  <EXERCISE>
    以下内容
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    非常有用，尽管有点晦涩：
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>mystery</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <NAME>mystery_loop</NAME>
      <REQUIRES>mystery_loop_example_1</REQUIRES>
      <EXAMPLE>mystery_loop_example_2</EXAMPLE>
      <SCHEME>
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x &apos;()))
      </SCHEME>
      <JAVASCRIPT>
function mystery(x) {
    function loop(x, y) {
        if (is_null(x)) {
            return y;
        } else {
            const temp = tail(x);
            set_tail(x, y);
            return loop(temp, x);
        }
    }
    return loop(x, null);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Loop</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>loop</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    使用了名为 <QUOTE>临时</QUOTE>
    <SPLITINLINE>
      <SCHEME>
	变量
      </SCHEME>
      <JAVASCRIPT>
	名称
      </JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>temp</SCHEMEINLINE>
    来保存 <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    的旧值，因为下一行的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    会破坏
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    解释 <SCHEMEINLINE>mystery</SCHEMEINLINE> 的一般功能。假设
    <SCHEMEINLINE>v</SCHEMEINLINE> 被如下定义：
    <SNIPPET>
      <NAME>mystery_loop_example_1</NAME>
      <SCHEME>
(define v (list &apos;a &apos;b &apos;c &apos;d))
      </SCHEME>
      <JAVASCRIPT>
const v = list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
      </JAVASCRIPT>
    </SNIPPET>
    绘制一个盒子和指针图，表示
    <SCHEMEINLINE>v</SCHEMEINLINE> 所绑定的列表。假设我们现在执行
    <SNIPPET>
      <NAME>mystery_loop_example_2</NAME>
      <REQUIRES>mystery_loop</REQUIRES>
      <SCHEME>
(define w (mystery v))
      </SCHEME>
      <JAVASCRIPT>
const w = mystery(v);
      </JAVASCRIPT>
    </SNIPPET>
    绘制盒子和指针图，显示在执行该
    <SPLITINLINE>
      <SCHEME>表达式。</SCHEME>
      <JAVASCRIPT>程序。</JAVASCRIPT>
    </SPLITINLINE>
    后，<SCHEMEINLINE>v</SCHEMEINLINE> 和 <SCHEMEINLINE>w</SCHEMEINLINE> 的结构。将会打印出
    <SCHEMEINLINE>v</SCHEMEINLINE> 和 <SCHEMEINLINE>w</SCHEMEINLINE> 的值。
    <LABEL NAME="ex:mystery"></LABEL>
    <SOLUTION>
      （由 GitHub 用户 jonathantorres 提供）
      调用 <JAVASCRIPTINLINE>mystery(x)</JAVASCRIPTINLINE> 会就地反转列表 <JAVASCRIPTINLINE>x</JAVASCRIPTINLINE>。
      初始时，
      <JAVASCRIPTINLINE>v</JAVASCRIPTINLINE> 如下所示：
      
      <FIGURE SRC="img_javascript/ex-3-14-sol-2.png">
	<LABEL NAME="ex:3-14-sol-1"></LABEL>
      </FIGURE>

      执行完       
      <JAVASCRIPTINLINE>const w = mystery(v);</JAVASCRIPTINLINE>
      后，
      <JAVASCRIPTINLINE>v</JAVASCRIPTINLINE> 和
      <JAVASCRIPTINLINE>w</JAVASCRIPTINLINE> 的值变为：
      
      <FIGURE SRC="img_javascript/ex-3-14-sol-2.png">
	<LABEL NAME="ex:3-14-sol-2"></LABEL>
      </FIGURE>

      函数 <JAVASCRIPTINLINE>display</JAVASCRIPTINLINE>
      对 <JAVASCRIPTINLINE>v</JAVASCRIPTINLINE> 打印 <JAVASCRIPTINLINE>[&quot;a&quot;, null]</JAVASCRIPTINLINE>，
      对 <JAVASCRIPTINLINE>w</JAVASCRIPTINLINE> 打印 <JAVASCRIPTINLINE>[&quot;d&quot;, [&quot;c&quot;, [&quot;b&quot;, [&quot;a&quot;, null]]]]</JAVASCRIPTINLINE>。
    </SOLUTION>
  </EXERCISE>


  
  <INDEX>可变数据对象<SUBINDEX>列表结构<CLOSE></CLOSE></SUBINDEX></INDEX>

  
  <INDEX>列表结构<SUBINDEX>可变<CLOSE></CLOSE></SUBINDEX></INDEX>

  
  <INDEX>可变数据对象<SUBINDEX>对<CLOSE></CLOSE></SUBINDEX></INDEX>

  
  <INDEX>对<SUBINDEX>可变&lt;/CLOSE&gt;</SUBINDEX></INDEX>


  
  <SUBHEADING>
    <NAME>共享与身份</NAME>
  </SUBHEADING>


  
  <INDEX>数据<SUBINDEX>共享<OPEN></OPEN></SUBINDEX></INDEX>

  
  <INDEX>数据<SUBINDEX>共享<OPEN></OPEN></SUBINDEX></INDEX>


  
  <TEXT>
    我们在章节<SPACE></SPACE><REF NAME="sec:costs-of-assignment"></REF>中提到了赋值引入所引发的关于
    <INDEX>同一性与变化<SUBINDEX>共享数据及</SUBINDEX></INDEX>
    <INDEX>变化与同一性<SUBINDEX>共享数据及</SUBINDEX></INDEX>
    <QUOTE>同一性</QUOTE> 和 <QUOTE>变化</QUOTE> 的理论问题。这些问题在实践中出现，
    当单个对在不同的数据对象之间被<EM>共享</EM>时。例如，考虑由下列构成的结构
    <SNIPPET EVAL="yes">
      <NAME>pair_example1</NAME>
      <SCHEME>
(define x (list &apos;a &apos;b))
(define z1 (cons x x))
      </SCHEME>
      <JAVASCRIPT>
const x = list(&quot;a&quot;, &quot;b&quot;);
const z1 = pair(x, x);
      </JAVASCRIPT>
    </SNIPPET>
    如
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE></SPACE><REF NAME="fig:identity1_scheme"></REF>,
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE></SPACE><REF NAME="fig:identity1"></REF>,
      </JAVASCRIPT>
    </SPLITINLINE>
    所示，<SCHEMEINLINE>z1</SCHEMEINLINE> 是一对，其中的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    均指向同一个<SCHEMEINLINE>x</SCHEMEINLINE>。这种<SCHEMEINLINE>x</SCHEMEINLINE>在
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    之间的共享，是<INDEX>
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
    </INDEX>
    直接实现方式的必然结果。一般来说，使用
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    构造列表会产生一个由许多个体对相互连接构成的结构，其中很多单独的对被多个不同结构共享。
    <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE SPLIT_SCALE="0.7" SRC="img_original/ch3-Z-G-17.svg"></FIGURE>
          <CAPTION>
	    列表<SCHEMEINLINE>z1</SCHEMEINLINE>由<SCHEMEINLINE>(cons x x)</SCHEMEINLINE>构成。
	  </CAPTION>
          <LABEL NAME="fig:identity1_scheme"></LABEL>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-17.svg"></FIGURE>
          <CAPTION>
	    列表<SCHEMEINLINE>z1</SCHEMEINLINE>由<JAVASCRIPTINLINE>pair(x, x)</JAVASCRIPTINLINE>构成。
          </CAPTION>
          <LABEL NAME="fig:identity1"></LABEL>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
    <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-18.svg"></FIGURE>
          <CAPTION>
	    列表<SCHEMEINLINE>z2</SCHEMEINLINE>由<SCHEMEINLINE>(cons (list &apos;a &apos;b) (list &apos;a &apos;b))</SCHEMEINLINE>构成。
	  </CAPTION>
          <LABEL NAME="fig:identity2_scheme"></LABEL>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-18.svg"></FIGURE>
          <CAPTION>
	    列表<SCHEMEINLINE>z2</SCHEMEINLINE>由<JAVASCRIPTINLINE>pair(list(&quot;a&quot;, &quot;b&quot;), list(&quot;a&quot;, &quot;b&quot;))</JAVASCRIPTINLINE>构成。
	  </CAPTION>
          <LABEL NAME="fig:identity2"></LABEL>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>


  
  <TEXT>
    相对于
    <SPLITINLINE>
      <SCHEME>
	figure<SPACE></SPACE><REF NAME="fig:identity1_scheme"></REF>,
	figure<SPACE></SPACE><REF NAME="fig:identity2_scheme"></REF>
      </SCHEME>
      <JAVASCRIPT>
	figure<SPACE></SPACE><REF NAME="fig:identity1"></REF>,
	figure<SPACE></SPACE><REF NAME="fig:identity2"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    所展示的结构是由
    <SNIPPET EVAL="yes">
      <NAME>pair_example2</NAME>
      <SCHEME>
(define z2 (cons (list &apos;a &apos;b) (list &apos;a &apos;b)))
      </SCHEME>
      <JAVASCRIPT>
const z2 = pair(list(&quot;a&quot;, &quot;b&quot;), list(&quot;a&quot;, &quot;b&quot;));
      </JAVASCRIPT>
    </SNIPPET>
    创建的。在该结构中，这两个
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(a b)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;a&quot;, &quot;b&quot;)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    列表中的对是不同的，尽管
    <SPLITINLINE>
      <SCHEME>
	    实际的符号是共享的。
	    <FOOTNOTE>这两个对之所以不同，是因为每次调用
	    <SCHEMEINLINE>cons</SCHEMEINLINE>都会返回一个新的对。符号是共享的；在 Scheme 中，
        <INDEX>symbol(s)<SUBINDEX>uniqueness of</SUBINDEX></INDEX>
	    表示具有任意给定名称的唯一符号。由于 Scheme 不提供修改符号的方式，所以这种共享是无法被检测的。另请注意，正是这种共享使我们能够使用 <SCHEMEINLINE>eq?</SCHEMEINLINE> 来比较符号，该函数仅仅检查指针是否相等。<LABEL NAME="foot:symbol-sharing_scheme"></LABEL></FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	    它们包含相同的字符串。<FOOTNOTE>这两个对之所以不同，是因为每次调用 <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
	    都会返回一个新的对。字符串在
        <INDEX>string(s)<SUBINDEX>uniqueness of</SUBINDEX></INDEX>
	    的意义上是“相同的”，也就是说，它们作为原始数据（就像数字一样）由相同的字符以相同的顺序组成。由于 JavaScript 不提供修改字符串的方式，因此任何 JavaScript 解释器的设计者可能为字符串实现的共享都是无法检测到的。我们认为，诸如数字、布尔值和字符串等原始数据只有在它们不可区分时才被视为<EM>相同的</EM>。<LABEL NAME="foot:symbol-sharing"></LABEL>
	    </FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT> 
    当看作一个列表时，  
<SCHEMEINLINE>z1</SCHEMEINLINE>  和
     <SCHEMEINLINE>z2</SCHEMEINLINE> 两者都表示 <QUOTE>相同的</QUOTE> 列表: 
<SNIPPET>
      <NAME>abab</NAME>
      <EXPECTED>[ [ &apos;a&apos;, [ &apos;b&apos;, null ] ], [ &apos;a&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
((a b) a b)
      </SCHEME>
      <JAVASCRIPT>
list(list(&quot;a&quot;, &quot;b&quot;), &quot;a&quot;, &quot;b&quot;)
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list(list(&quot;a&quot;, &quot;b&quot;), &quot;a&quot;, &quot;b&quot;);
      </JAVASCRIPT_RUN>
    </SNIPPET> 通常，如果我们只用  
<SPLITINLINE>
  <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE>,</SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
</SPLITINLINE>
<SPLITINLINE>
  <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>,</SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
</SPLITINLINE>
以及
<SPLITINLINE>
  <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>.</SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
</SPLITINLINE>
对列表进行操作，那么共享在总体上是完全无法检测到的。然而，若我们允许对列表结构进行修改操作，共享就变得显著起来。作为共享可能造成区别的一个例子，请考虑下面这个
<SPLITINLINE>
  <SCHEME>procedure,</SCHEME>
  <JAVASCRIPT>function,</JAVASCRIPT>
</SPLITINLINE>
它修改了应用它所作用的结构的
<SPLITINLINE>
  <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
</SPLITINLINE>
。<SNIPPET EVAL="yes">
      <NAME>set_to_wow</NAME>
      <SCHEME>
(define (set-to-wow! x)
  (set-car! (car x) &apos;wow)
  x)
      </SCHEME>
      <JAVASCRIPT>
function set_to_wow(x) {
    set_head(head(x), &quot;wow&quot;);
    return x;
}
      </JAVASCRIPT>
    </SNIPPET> 尽管 <SCHEMEINLINE>z1</SCHEMEINLINE>  和
     <SCHEMEINLINE>z2</SCHEMEINLINE> 是<QUOTE>相同</QUOTE>的结构,
    应用
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-to-wow!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_to_wow</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    对它们将产生不同的结果.  使用 <SCHEMEINLINE>z1</SCHEMEINLINE> , 改变
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    也改变
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    因为在 <SCHEMEINLINE>z1</SCHEMEINLINE>  这个
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和这个
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    构成相同的对。 带有 <SCHEMEINLINE>z2</SCHEMEINLINE> ，这个
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    是不同的，因此
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-to-wow!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_to_wow</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    仅修改
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>:</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>:</JAVASCRIPT>
    </SPLITINLINE>
<SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_1</NAME>
      <REQUIRES>pair_example1</REQUIRES>
      <EXPECTED>[ [ &apos;a&apos;, [ &apos;b&apos;, null ] ], [ &apos;a&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
z1
      </SCHEME>
      <SCHEMEOUTPUT>
            ((a b) a b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
z1; 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>      
[[&quot;a&quot;, [&quot;b&quot;, null]], [&quot;a&quot;, [&quot;b&quot;, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_2</NAME>
      <REQUIRES>set_to_wow</REQUIRES>
      <REQUIRES>pair_example1</REQUIRES>
      <EXPECTED>[ [ &apos;wow&apos;, [ &apos;b&apos;, null ] ], [ &apos;wow&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
(set-to-wow! z1)
      </SCHEME>
      <SCHEMEOUTPUT>
((wow b) wow b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_to_wow(z1); 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[[&quot;wow&quot;, [&quot;b&quot;, null]], [&quot;wow&quot;, [&quot;b&quot;, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_3</NAME>
      <REQUIRES>pair_example2</REQUIRES>
      <EXPECTED>[ [ &apos;a&apos;, [ &apos;b&apos;, null ] ], [ &apos;a&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
z2
      </SCHEME>
      <SCHEMEOUTPUT>
((a b) a b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
z2;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>&gt;
[[&quot;a&quot;, [&quot;b&quot;, null]], [&quot;a&quot;, [&quot;b&quot;, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_4</NAME>
      <REQUIRES>set_to_wow</REQUIRES>
      <REQUIRES>pair_example2</REQUIRES>
      <EXPECTED>[ [ &apos;wow&apos;, [ &apos;b&apos;, null ] ], [ &apos;a&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
(set-to-wow! z2)
      </SCHEME>
      <SCHEMEOUTPUT>
((wow b) a b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_to_wow(z2); 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[[&quot;wow&quot;, [&quot;b&quot;, null]], [&quot;a&quot;, [&quot;b&quot;, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>

  
  <TEXT>
    <SPLIT>
      <SCHEME>
        检测列表结构共享的一种方法是使用谓词 <SCHEMEINLINE>eq?</SCHEMEINLINE>，我们在章节<SPACE></SPACE><REF NAME="sec:quotation"></REF>中介绍了这一方法，用于测试两个符号是否相等。更一般地，<SCHEMEINLINE>(eq? x y)</SCHEMEINLINE>测试的是<SCHEMEINLINE>x</SCHEMEINLINE>和<SCHEMEINLINE>y</SCHEMEINLINE>是否为同一对象（也就是说，测试<SCHEMEINLINE>x</SCHEMEINLINE>和<SCHEMEINLINE>y</SCHEMEINLINE>在指针意义上是否相等）。
      </SCHEME>
      <JAVASCRIPT>
        检测列表结构共享的一种方法是使用<INDEX><USE>===</USE><SUBINDEX><ORDER>equality</ORDER>as equality of pointers</SUBINDEX></INDEX>
        <INDEX><USE>===</USE><SUBINDEX><ORDER>general</ORDER>as general comparison operator</SUBINDEX></INDEX>
        <INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>===</USE>（用于非原始值）</SUBINDEX></INDEX>
        原始谓词 <JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>，我们在章节<SPACE></SPACE><REF NAME="sec:conditionals"></REF>中介绍了此谓词来测试两个数字是否相等，并在章节<SPACE></SPACE><REF NAME="sec:strings"></REF>中扩展到测试两个字符串是否相等。当对两个非原始值应用时，<JAVASCRIPTINLINE>x === y</JAVASCRIPTINLINE>测试的是<SCHEMEINLINE>x</SCHEMEINLINE>和<SCHEMEINLINE>y</SCHEMEINLINE>是否为同一对象（也就是说，测试<SCHEMEINLINE>x</SCHEMEINLINE>和<SCHEMEINLINE>y</SCHEMEINLINE>在指针意义上是否相等）。
      </JAVASCRIPT>
    </SPLIT>
    因此，按照下列方式定义的 <SCHEMEINLINE>z1</SCHEMEINLINE> 和 <SCHEMEINLINE>z2</SCHEMEINLINE>：
    <SPLITINLINE>
      <SCHEME>
        图<SPACE></SPACE><REF NAME="fig:identity1_scheme"></REF>和<SPACE></SPACE><REF NAME="fig:identity2_scheme"></REF>，
      </SCHEME>
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:identity1"></REF>和<SPACE></SPACE><REF NAME="fig:identity2"></REF>，
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>(eq? (car<SPACE></SPACE>z1) (cdr<SPACE></SPACE>z1))</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>head(z1) === tail(z1)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    为真，而
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>(eq? (car z2) (cdr z2))</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>head(z2) === tail(z2)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    为假。
  </TEXT>


  
  <TEXT>
    正如接下来的各节中所展示的那样，我们可以利用共享来大幅扩展由对构成的数据结构的种类。另一方面，共享也可能使
    <INDEX>可变数据对象<SUBINDEX>共享数据</SUBINDEX></INDEX>
    变得危险，因为对结构所做的修改同样会影响那些恰好共享被修改部分的其他结构。变更操作
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    应谨慎使用；除非我们对数据对象的共享方式有充分了解，否则变更可能会产生意想不到的结果。<FOOTNOTE>处理可变数据对象共享的微妙问题反映了在第<SPACE></SPACE><REF NAME="sec:costs-of-assignment"></REF>节中提出的<QUOTE>sameness</QUOTE>和<QUOTE>change</QUOTE>的根本问题。我们在该节中提到，允许语言中发生变更要求复合对象必须具有一种与其组成部分不同的<QUOTE>identity</QUOTE>。在
    <SPLITINLINE>
      <SCHEME>Lisp,</SCHEME>
      <JAVASCRIPT>JavaScript,</JAVASCRIPT>
    </SPLITINLINE>
    中，我们认为这种<QUOTE>identity</QUOTE>正是通过
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eq?</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    即通过指针相等性来测试的。由于在大多数
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    实现中，一个指针本质上是一个内存地址，因此我们规定数据对象<QUOTE>itself</QUOTE>是存储在计算机中某一特定内存位置集合中的信息，从而“解决了问题”。这对于简单的
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    程序来说已足够，但这决不是一种解决计算模型中<QUOTE>sameness</QUOTE>问题的通用方法。</FOOTNOTE>
  </TEXT>


  
  <EXERCISE>
    <LABEL NAME="ex:3_15"></LABEL>
    绘制盒子与指针图，以解释
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-to-wow!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_to_wow</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    对上述结构<SCHEMEINLINE>z1</SCHEMEINLINE>和<SCHEMEINLINE>z2</SCHEMEINLINE>的影响。
  </EXERCISE>


  
  <SHORT_PAGE LINES="1"></SHORT_PAGE>

  
  <EXERCISE>
    本·比特迪德尔决定编写一个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    用于计算任何列表结构中对的数量。
    <QUOTE>它很简单，</QUOTE>他推理道。  <QUOTE>在任何结构中，对的数量等于在 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    中的数量，加上在 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    中的数量，再加上一个以计算当前这一对。</QUOTE> 因此本·比特迪德尔编写了如下
    <SPLITINLINE>
      <SCHEME>过程：</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <NAME>count_pairs</NAME>
      <INDEX><DECLARATION>count_pairs</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <SCHEME>
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
      </SCHEME>
      <JAVASCRIPT>
function count_pairs(x) {
    return ! is_pair(x)
           ? 0
           : count_pairs(head(x)) + 
             count_pairs(tail(x)) +
             1;
}
      </JAVASCRIPT>
    </SNIPPET>
    证明这个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    不正确。特别是，绘制由正好三个对构成的列表结构的框和指针图，对于这些结构，本·比特迪德尔的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    将分别返回 3；返回 4；返回 7；以及根本不返回任何值。
    <LABEL NAME="ex:count-pairs"></LABEL>
    <SOLUTION>
      <SNIPPET>
        <NAME>exercise_3_16_solution</NAME>
	      <REQUIRES>count_pairs</REQUIRES>
        <EXAMPLE>exercise_3_16_solution_example</EXAMPLE>
        <SCHEME>
        </SCHEME>
        <JAVASCRIPT>
const three_list = list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
const one = pair(&quot;d&quot;, &quot;e&quot;);
const two = pair(one, one);
const four_list = pair(two, &quot;f&quot;);
const seven_list = pair(two, two);
const cycle = list(&quot;g&quot;, &quot;h&quot;, &quot;i&quot;);
set_tail(tail(tail(cycle)), cycle);
        </JAVASCRIPT>
      </SNIPPET>

      <SNIPPET HIDE="yes">
	      <NAME>exercise_3_16_solution_example</NAME>
	      <JAVASCRIPT>
// return 3; return 4; return 7;
display(count_pairs(three_list));
display(count_pairs(four_list));
display(count_pairs(seven_list));

// never return at all
display(count_pairs(cycle));	
	      </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>


  
  <EXERCISE>
    <LABEL NAME="ex:count-pairs2"></LABEL>
    设计一个正确版本的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>count-pairs</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>count_pairs</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，用于返回任意结构中不同对的数量。（提示：遍历该结构，同时维护一个辅助数据结构，用于记录哪些对已经被计数。）
    <SOLUTION>
      <SNIPPET>
        <EXAMPLE>exercise_3_17_solution_example</EXAMPLE>
        <JAVASCRIPT>
// GitHub 用户 clean99 提供的解决方案
	  
function count_pairs(x) {
    let counted_pairs = null;
    function is_counted_pair(current_counted_pairs, x) {
        return is_null(current_counted_pairs)
               ? false
               : head(current_counted_pairs) === x
               ? true
               : is_counted_pair(tail(current_counted_pairs), x);
    }
    function count(x) {
        if(! is_pair(x) || is_counted_pair(counted_pairs, x)) {
            return 0;
        } else {
            counted_pairs = pair(x, counted_pairs);
            return count(head(x)) +
                   count(tail(x)) +
                   1;
        }
    }
    return count(x);
}
        </JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
         <NAME>exercise_3_17_solution_example</NAME>
         <JAVASCRIPT>
const three_list = list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
const one = pair(&quot;d&quot;, &quot;e&quot;);
const two = pair(one, one);
const four_list = pair(two, &quot;f&quot;);
const seven_list = pair(two, two);
const cycle = list(&quot;g&quot;, &quot;h&quot;, &quot;i&quot;);
set_tail(tail(tail(cycle)), cycle);

// 返回 3；返回 3；返回 3；
display(count_pairs(three_list));
display(count_pairs(four_list));
display(count_pairs(seven_list));

// 返回 3
display(count_pairs(cycle));
         </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  
  <EXERCISE>
    Write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that examines a list and
    <INDEX>cycle in list<SUBINDEX>detecting</SUBINDEX></INDEX>
    determines whether it contains a cycle, that is,
    whether a program that tried to find the end of the list by taking
    successive
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>s</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>s</JAVASCRIPT>
    </SPLITINLINE>
    would go into an infinite loop. Exercise<SPACE></SPACE><REF NAME="ex:make-cycle"></REF>
    constructed such lists.
    <LABEL NAME="ex:find-cycle"></LABEL>
   <SOLUTION>
      <SNIPPET>
	<EXAMPLE>exercise_3_18_solution_example</EXAMPLE>
	<JAVASCRIPT>
// solution provided by GitHub user clean99

function contains_cycle(x) {
    let counted_pairs = null;
    function is_counted_pair(counted_pairs, x) {
        return is_null(counted_pairs)
               ? false
               : head(counted_pairs) === x
               ? true
               : is_counted_pair(tail(counted_pairs), x);
    }
    function detect_cycle(x) {
        if (is_null(x)) {
            return false;
        } else if (is_counted_pair(counted_pairs, x)) {
            return true;
        } else {
            counted_pairs = pair(x, counted_pairs);
            return detect_cycle(tail(x));
        }
    }
    return detect_cycle(x);
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
         <NAME>exercise_3_18_solution_example</NAME>
         <JAVASCRIPT>
const three_list = list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
const cycle = list(&quot;g&quot;, &quot;h&quot;, &quot;i&quot;);
set_tail(tail(tail(cycle)), cycle);

// displays false
display(contains_cycle(three_list));

// displays true
display(contains_cycle(cycle));
	 </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE><!-- Error occurred while translating this section -->

  <EXERCISE>
    <LABEL NAME="ex:3_19"></LABEL>
    Redo exercise<SPACE></SPACE><REF NAME="ex:find-cycle"></REF> using an algorithm that
    takes only a constant amount of space.  (This requires a very clever idea.)
    <SNIPPET HIDE="yes">
      <NAME>pair2_example</NAME>
      <JAVASCRIPT>
const x = pair(1, 2);
set_head(x, 3);
head(x);
      </JAVASCRIPT>
    </SNIPPET>
    <SOLUTION>
      Define a fast pointer and a slow pointer. The fast pointer goes forward
      2 steps every time, while the slow pointer goes forward 1 step every time.
      If there is a cycle in the list, the fast pointer will eventually catch
      up with the slow pointer.
      <SNIPPET HIDE="yes">
	<NAME>contains_cycle_example</NAME>
	<REQUIRES>make_cycle</REQUIRES>
	<JAVASCRIPT>
const c = make_cycle(list(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;));
const c1 = append(list(&quot;a&quot;, &quot;b&quot;), c);

contains_cycle(c1);
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET EVAL="yes">
	<NAME>contains_cycle</NAME>
	<EXAMPLE>contains_cycle_example</EXAMPLE>
	<JAVASCRIPT>
function contains_cycle(x) {
    function detect_cycle(fast, slow) {
        return is_null(fast) || is_null(tail(fast))
               ? false
               : fast === slow
               ? true
               : detect_cycle(tail(tail(fast)), tail(slow));
    }
    return detect_cycle(tail(x), x);
}
	</JAVASCRIPT>
	</SNIPPET>
    </SOLUTION>
  </EXERCISE><!-- Error occurred while translating this section -->

  <INDEX>data<SUBINDEX>shared<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>shared data<CLOSE></CLOSE></INDEX><!-- Error occurred while translating this section -->

  <SUBHEADING> 
    <NAME>Mutation is just assignment</NAME>
  </SUBHEADING><!-- Error occurred while translating this section -->

  <INDEX>mutable data objects<SUBINDEX>functional representation of<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>mutable data objects<SUBINDEX>implemented with assignment<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>pair(s)<SUBINDEX>functional representation of<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>functional representation of data<SUBINDEX>mutable data<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->

  <TEXT>
    When we introduced compound data, we observed in
    section<SPACE></SPACE><REF NAME="sec:data?"></REF> that pairs can be represented purely
    in terms of
    <SPLITINLINE>
      <SCHEME>procedures:</SCHEME>
      <JAVASCRIPT>functions:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>pair</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>head</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>tail</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <EXAMPLE>cons_1_2_run</EXAMPLE>
      <EXPECTED>1</EXPECTED>
      <SCHEME>
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m &apos;car) x)
          ((eq? m &apos;cdr) y)
          (else (error &quot;Undefined operation - - CONS&quot; m))))
  dispatch)

(define (car z) (z &apos;car))

(define (cdr z) (z &apos;cdr))
      </SCHEME>
      <JAVASCRIPT>
function pair(x, y) {
    function dispatch(m) {
        return m === &quot;head&quot;
               ? x
               : m === &quot;tail&quot;
               ? y
               : error(m, &quot;undefined operation -- pair&quot;);
    }
    return dispatch;	      
}
<SHORT_SPACE></SHORT_SPACE>
function head(z) { return z(&quot;head&quot;); }
<SHORT_SPACE></SHORT_SPACE>
function tail(z) { return z(&quot;tail&quot;); }
      </JAVASCRIPT>
    </SNIPPET>
    The same observation is true for mutable data.  We can implement
    mutable data objects as
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    using assignment and local state. For instance, we can extend the above
    pair implementation to handle
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in a manner analogous to the way we implemented bank accounts using
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in section<SPACE></SPACE><REF NAME="sec:local-state-variables"></REF>:
    <SNIPPET HIDE="yes">
      <NAME>cons_1_2_run_3</NAME>
      <JAVASCRIPT>
const x = pair(1, 2);
set_head(x, 3);
head(x);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>pair</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>head</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>tail</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>set_head</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>set_tail</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <NAME>pair2</NAME>
      <EXAMPLE>cons_1_2_run_3</EXAMPLE>
      <EXPECTED>3</EXPECTED>
      <SCHEME>
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m &apos;car) x)
          ((eq? m &apos;cdr) y)
          ((eq? m &apos;set-car!) set-x!)
          ((eq? m &apos;set-cdr!) set-y!)
          (else (error &quot;Undefined operation - - CONS&quot; m))))
  dispatch)

(define (car z) (z &apos;car))

(define (cdr z) (z &apos;cdr))

(define (set-car! z new-value)
  ((z &apos;set-car!) new-value)
  z)

(define (set-cdr! z new-value)
  ((z &apos;set-cdr!) new-value)
  z)
      </SCHEME>
      <JAVASCRIPT>
function pair(x, y) {
    function set_x(v) { x = v; }
    function set_y(v) { y = v; }
    return m =&gt; m === &quot;head&quot;
                ? x
                : m === &quot;tail&quot;
                ? y
                : m === &quot;set_head&quot;
                ? set_x
                : m === &quot;set_tail&quot;
                ? set_y
                : error(m, &quot;undefined operation -- pair&quot;);
}
<SHORT_SPACE_AND_ALLOW_BREAK></SHORT_SPACE_AND_ALLOW_BREAK>
function head(z) { return z(&quot;head&quot;); }
<SHORT_SPACE></SHORT_SPACE>
function tail(z) { return z(&quot;tail&quot;); }
<SHORT_SPACE></SHORT_SPACE>
function set_head(z, new_value) {
    z(&quot;set_head&quot;)(new_value);
    return z;
}
function set_tail(z, new_value) {
    z(&quot;set_tail&quot;)(new_value);
    return z;
}
      </JAVASCRIPT> <!--  FIXME: add allow break without space after tail  -->
    </SNIPPET>
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    Assignment is all that is needed, theoretically, to account for the
    behavior of mutable data.  As soon as we admit
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>assignment</JAVASCRIPT>
    </SPLITINLINE>
    to our language, we raise all the issues, not only of assignment, but of
    mutable data in general.<FOOTNOTE>On the other hand, from the viewpoint of
    implementation, assignment requires us to modify the environment, which is
    itself a mutable data structure.  Thus, assignment and mutation are
    equipotent: Each can be implemented in terms of the other.</FOOTNOTE>
  </TEXT><!-- Error occurred while translating this section -->

  <EXERCISE>
    Draw environment diagrams to illustrate the evaluation of the sequence
    of
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <NAME>pair2_example1</NAME>
      <REQUIRES>pair2</REQUIRES>
      <SCHEME>
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)

(car x)
      </SCHEME>
      <JAVASCRIPT>
const x = pair(1, 2);
const z = pair(x, x);
set_head(tail(z), 17);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>pair2_example2</NAME>
      <REQUIRES>pair2_example1</REQUIRES>
      <EXPECTED>17</EXPECTED>
      <SCHEME>
(car x)
      </SCHEME>
      <SCHEMEOUTPUT>
            17
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
head(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
17
      </JAVASCRIPT_OUTPUT>
      </SNIPPET>
    using the 
    <SPLITINLINE>
      <SCHEME>
            procedural 
      </SCHEME>
      <JAVASCRIPT>
            functional
      </JAVASCRIPT>
    </SPLITINLINE>
    implementation of pairs given above.  (Compare
    exercise<SPACE></SPACE><REF NAME="ex:two-accounts"></REF>.)
    <LABEL NAME="ex:cons-with-assignment"></LABEL>
  </EXERCISE><!-- Error occurred while translating this section -->

  <INDEX>mutable data objects<SUBINDEX>functional representation of<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>mutable data objects<SUBINDEX>implemented with assignment<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>pair(s)<SUBINDEX>functional representation of<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>functional representation of data<SUBINDEX>mutable data<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>mutable data objects<CLOSE></CLOSE></INDEX><!-- Error occurred while translating this section -->
</SUBSECTION>

