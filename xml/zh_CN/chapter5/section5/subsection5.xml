<SUBSECTION>
  <NAME>
    An Example of Compiled Code
  </NAME><!-- Error occurred while translating this section -->

  <LABEL NAME="sec:compiled-code"></LABEL>

  <INDEX>compiler for JavaScript<SUBINDEX>example compilation<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX><USE>factorial</USE><SUBINDEX>compilation of<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->

  <TEXT>
    Now that we have seen all the elements of the compiler, let us examine
    an example of compiled code to see how things fit together.  We will
    compile the
    <SPLITINLINE>
      <SCHEME>definition</SCHEME>
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    of a recursive
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>factorial</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>factorial</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	by calling
	<SCHEMEINLINE>compile</SCHEMEINLINE>:
      </SCHEME>
      <JAVASCRIPT>
	by passing as first argument to
	<SCHEMEINLINE>compile</SCHEMEINLINE>
	the result of applying
	<SCHEMEINLINE>parse</SCHEMEINLINE> to
	a string representation of the program
	(here using
	<INDEX><ORDER>&apos;&apos;</ORDER><JAVASCRIPTINLINE>`</JAVASCRIPTINLINE> (back quote)</INDEX>
	<INDEX>quotation marks<SUBINDEX>back quotes</SUBINDEX></INDEX>
	<INDEX>back quotes</INDEX>
	<INDEX>string(s)<SUBINDEX>typed over multiple lines</SUBINDEX></INDEX>
	back quotes
	<JAVASCRIPTINLINE>`</JAVASCRIPTINLINE><LATEXINLINE>$\ldots$</LATEXINLINE><JAVASCRIPTINLINE>`</JAVASCRIPTINLINE>, which work like
	single and double quotation marks
	but allow the string to span multiple lines):
      </JAVASCRIPT>
    </SPLITINLINE>
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no">
      <SCHEME>
(compile
 &apos;(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 &apos;val
 &apos;next)
      </SCHEME>
      <JAVASCRIPT>
compile(parse(`
function factorial(n) {
    return n === 1
           ? 1
           : factorial(n - 1) * n;
}
              `),
        &quot;val&quot;,
        &quot;next&quot;);
      </JAVASCRIPT>
    </SNIPPET>
    We have specified that the value of the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>define</SCHEMEINLINE> expression</SCHEME>
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    should be placed in the <!-- Error occurred while translating this section --><SCHEMEINLINE>val</SCHEMEINLINE> register.
    We don<APOS></APOS>t care what the compiled
    code does after executing the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>define</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>declaration,</JAVASCRIPT>
    </SPLITINLINE>
    so our choice of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>&quot;next&quot;</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    as the linkage
    descriptor is arbitrary.
  <!-- Error occurred while translating this section --></TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Compile</SCHEMEINLINE>
	determines that the
	expression is a definition, so it
      </SCHEME>
      <JAVASCRIPT>
	The function <SCHEMEINLINE>compile</SCHEMEINLINE>
	determines that it was given a function declaration, so it transforms it
  to a constant declaration and then
      </JAVASCRIPT>
    </SPLITINLINE>
calls    
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-definition</SCHEMEINLINE> to compile </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compile_declaration</JAVASCRIPTINLINE>. This compiles
      </JAVASCRIPT>
    </SPLITINLINE>
    code to compute the value to be assigned (targeted to
    <!-- Error occurred while translating this section --><SCHEMEINLINE>val</SCHEMEINLINE>), followed by code to install the
    <SPLITINLINE>
      <SCHEME>definition,</SCHEME>
      <JAVASCRIPT>declaration,</JAVASCRIPT>
    </SPLITINLINE>
    followed by code to put the value of the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>define</SCHEMEINLINE> (which is the symbol
	<SCHEMEINLINE>ok</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
	declaration (which is the value
	<SCHEMEINLINE>undefined</SCHEMEINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    into the target register, followed finally by the linkage code.
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Env</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	The <SCHEMEINLINE>env</SCHEMEINLINE> register
      </JAVASCRIPT>
    </SPLITINLINE>
    is preserved around the computation of the
    value, because it is needed in order to install the
    <SPLITINLINE>
      <SCHEME>
	definition.
      </SCHEME>
      <JAVASCRIPT>
	declaration.
      </JAVASCRIPT>
    </SPLITINLINE>
    Because
    the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>&quot;next&quot;</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    there is no linkage code
    in this case.  The skeleton of the compiled code is thus
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
$\langle save$ env $if\ modified\ by\ code\ to\ compute\ value\rangle$
$\langle compilation\ of\ definition\ value, target$ val$, linkage$ next$\rangle$
$\langle restore$ env $if\ saved\ above\rangle$
(perform (op define-variable!)
         (const factorial)
         (reg val)
         (reg env))
(assign val (const ok))
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>save <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if modified by code to compute value</METAPHRASE>
<METAPHRASE>compilation of declaration value, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>&quot;next&quot;</JAVASCRIPTINLINE></METAPHRASE>
<METAPHRASE>restore <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if saved above</METAPHRASE>
perform(list(op(&quot;assign_symbol_value&quot;),
             constant(&quot;factorial&quot;),
             reg(&quot;val&quot;),
             reg(&quot;env&quot;))),
assign(&quot;val&quot;, constant(undefined))
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The expression that is
    <SPLITINLINE>
      <SCHEME>to be</SCHEME>
      <JAVASCRIPT></JAVASCRIPT>
    </SPLITINLINE>
    compiled to produce the value for the
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>name</JAVASCRIPT>
    </SPLITINLINE>
    <!-- Error occurred while translating this section --><SCHEMEINLINE>factorial</SCHEMEINLINE>
    is a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>
    expression whose value is the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that computes factorials.
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Compile</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	The function
	<SCHEMEINLINE>compile</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    handles this
    by calling
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-lambda</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_lambda_expression</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which compiles the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body, labels it as a new entry point, and generates the instruction that
    will combine the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body at the new entry point with the runtime environment and assign the
    result to <!-- Error occurred while translating this section --><SCHEMEINLINE>val</SCHEMEINLINE>.  The sequence then skips around
    the compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code, which is inserted at this point.  The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code itself begins by extending the
    <SPLITINLINE>
      <SCHEME>procedure<APOS></APOS>s definition</SCHEME>
      <JAVASCRIPT>function<APOS></APOS>s declaration</JAVASCRIPT>
    </SPLITINLINE>
    environment by a frame that binds the
    <SPLITINLINE><SCHEME>formal</SCHEME></SPLITINLINE>
    parameter <!-- Error occurred while translating this section --><SCHEMEINLINE>n</SCHEMEINLINE> to the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    argument.  Then comes the actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body.  Since this code for the value of the
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>name</JAVASCRIPT>
    </SPLITINLINE>
    doesn<APOS></APOS>t modify the <!-- Error occurred while translating this section --><SCHEMEINLINE>env</SCHEMEINLINE> register, the
    optional <!-- Error occurred while translating this section --><SCHEMEINLINE>save</SCHEMEINLINE>
    and <!-- Error occurred while translating this section --><SCHEMEINLINE>restore</SCHEMEINLINE> shown above aren<APOS></APOS>t
    generated.  (The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code at
    <SPLITINLINE><SCHEME><SCHEMEINLINE>entry2</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>entry1</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
     isn<APOS></APOS>t executed at this point,
    so its use of <!-- Error occurred while translating this section --><SCHEMEINLINE>env</SCHEMEINLINE> is irrelevant.)
    Therefore, the skeleton for the compiled code becomes
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
  (assign val (op make-compiled-procedure)
              (label entry2)
              (reg env))
  (goto (label after-lambda1))
entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment)
              (const (n))
              (reg argl)
              (reg env))
  $\langle compilation\ of\ procedure\ body\rangle$
after-lambda1
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
      </SCHEME>
      <JAVASCRIPT>
$\texttt{ }\texttt{ }$assign(&quot;val&quot;, list(op(&quot;make_compiled_function&quot;), 
                     label(&quot;entry1&quot;), 
                     reg(&quot;env&quot;))),
  go_to(label(&quot;after_lambda2&quot;)),
&quot;entry1&quot;,
  assign(&quot;env&quot;, list(op(&quot;compiled_function_env&quot;), reg(&quot;fun&quot;))),
  assign(&quot;env&quot;, list(op(&quot;extend_environment&quot;),
                     constant(list(&quot;n&quot;)), 
                     reg(&quot;argl&quot;), 
                     reg(&quot;env&quot;))),
  <METAPHRASE>compilation of function body</METAPHRASE>
&quot;after_lambda2&quot;,
  perform(list(op(&quot;assign_symbol_value&quot;), 
               constant(&quot;factorial&quot;), 
               reg(&quot;val&quot;), 
               reg(&quot;env&quot;))),
  assign(&quot;val&quot;, constant(undefined))
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body is always compiled (by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-lambda-body</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>compile_lambda_body</JAVASCRIPTINLINE>)</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>as a sequence</SCHEME>
    </SPLITINLINE>
    with target <!-- Error occurred while translating this section --><SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>&quot;next&quot;</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The
    <SPLITINLINE>
      <SCHEME>
	sequence
      </SCHEME>
      <JAVASCRIPT>
	body
      </JAVASCRIPT>
    </SPLITINLINE>
    in this case consists of
    a single
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE> expression:
      </SCHEME>
      <JAVASCRIPT>
	return statement:<FOOTNOTE>
  Because of the <JAVASCRIPTINLINE>append_return_undefined</JAVASCRIPTINLINE> in
  <JAVASCRIPTINLINE>compile_lambda_body</JAVASCRIPTINLINE>, the body actually
  consists of a sequence with two return statements. However, the dead-code check
  in <JAVASCRIPTINLINE>compile_@sequence</JAVASCRIPTINLINE> will stop after the compilation
  of the first return statement,
  so the body effectively consists of only a single return statement.
</FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no">
      <SCHEME>
(if (= n 1)
    1
    (* (factorial (- n 1)) n))
      </SCHEME>
      <JAVASCRIPT>
return n === 1
       ? 1
       : factorial(n - 1) * n;
      </JAVASCRIPT>
    </SNIPPET>

    <SPLIT>
      <JAVASCRIPT>
	      The function
	      <JAVASCRIPTINLINE>compile_return_statement</JAVASCRIPTINLINE>
        generates code to revert the stack using the marker and to restore
       	the <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> register,
	      and then compiles the return 
        expression with target <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
	      <SCHEMEINLINE>&quot;return&quot;</SCHEMEINLINE>, because
	      its value is to be returned from the function.
      </JAVASCRIPT>
    </SPLIT>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Compile-if</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	The return expression is a conditional expression, 
	for which
	<JAVASCRIPTINLINE>compile_conditional</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    generates code that first computes the predicate (targeted to
    <!-- Error occurred while translating this section --><SCHEMEINLINE>val</SCHEMEINLINE>), then checks the result and branches
    around the true branch if the predicate is false.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Env</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>Registers <SCHEMEINLINE>env</SCHEMEINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and <!-- Error occurred while translating this section --><SCHEMEINLINE>continue</SCHEMEINLINE>
    are preserved around the predicate code, since they may be needed for the
    rest of the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>if</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>conditional</JAVASCRIPT>
    </SPLITINLINE>
    expression.
    <SPLIT>
      <SCHEME>
	Since the <SCHEMEINLINE>if</SCHEMEINLINE> expression
	is the final expression (and only expression) in the sequence making up
	the procedure
	body, its target is <SCHEMEINLINE>val</SCHEMEINLINE> and its linkage is
	<SCHEMEINLINE>return</SCHEMEINLINE>,
	so the
      </SCHEME>
      <JAVASCRIPT>
	The
      </JAVASCRIPT>
    </SPLIT>
    true and false branches are both
    compiled with target <!-- Error occurred while translating this section --><SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>&quot;return&quot;</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    (That is, the value of the conditional,
    which is the value computed by either of its branches, is the value of the
    <SPLITINLINE>
      <SCHEME>procedure.)</SCHEME>
      <JAVASCRIPT>function.)</JAVASCRIPT>
    </SPLITINLINE>
    <!-- Error occurred while translating this section --><SNIPPET LATEX="yes">
      <SCHEME>
  $\langle save$ continue, env $if\ modified\ by\ predicate\ and\ needed\ by\ branches\rangle$
  $\langle compilation\ of\ predicate, target$ val$,\ linkage$ next$\rangle$
  $\langle restore$ continue, env $if\ saved\ above\rangle$
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5
  $\langle compilation\ of\ true\ branch, target$ val$,\ linkage$ return$\rangle$
false-branch4
  $\langle compilation\ of\ false\ branch, target$ val$,\ linkage$ return$\rangle$
after-if3
      </SCHEME>
      <JAVASCRIPT><!--   The $\texttt{ }\texttt{ }$ below is a hack to ensure the leading spaces are not consumed  -->
$\texttt{ }\texttt{ }$revert_stack_to_marker(),
  restore(&quot;continue&quot;),
  <METAPHRASE>save <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>, <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if modified by predicate and needed by branches</METAPHRASE>
  <METAPHRASE>compilation of predicate, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>&quot;next&quot;</JAVASCRIPTINLINE></METAPHRASE>
  <METAPHRASE>restore <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>, <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if saved above</METAPHRASE>
  test(list(op(&quot;is_falsy&quot;), reg(&quot;val&quot;))),
  branch(label(&quot;false_branch4&quot;)),
&quot;true_branch3&quot;,
  <METAPHRASE>compilation of true branch, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>&quot;return&quot;</JAVASCRIPTINLINE></METAPHRASE>
&quot;false_branch4&quot;,
  <METAPHRASE>compilation of false branch, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>&quot;return&quot;</JAVASCRIPTINLINE></METAPHRASE>
&quot;after_cond5&quot;,
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The predicate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(= n 1)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>n === 1</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is a
    <SPLITINLINE>
      <SCHEME>procedure call.</SCHEME>
      <JAVASCRIPT>function application (after transformation of the
      operator combination).
      </JAVASCRIPT>
    </SPLITINLINE>
    This looks up the
    <SPLITINLINE>
      <SCHEME>
    operator
    (the symbol <SCHEMEINLINE>=</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
	function expression
	(the symbol <JAVASCRIPTINLINE>&quot;===&quot;</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    and places this value in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    It then assembles the arguments <!-- Error occurred while translating this section --><SCHEMEINLINE>1</SCHEMEINLINE> and the value
    of <!-- Error occurred while translating this section --><SCHEMEINLINE>n</SCHEMEINLINE> into <!-- Error occurred while translating this section --><SCHEMEINLINE>argl</SCHEMEINLINE>.
    Then it tests whether
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    contains a primitive or a compound
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    and dispatches to a primitive branch or a compound branch accordingly.
    Both branches resume at the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>after-call</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>after_call</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    label.
    <SPLITINLINE>
      <JAVASCRIPT>
      The compound branch must set up
      <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> to jump past the primitive
      branch and push a marker to the stack to match the revert
      operation in the compiled return statement of the function.
      </JAVASCRIPT>
    </SPLITINLINE>
    The requirements to preserve registers around the evaluation of the
    <SPLITINLINE>
      <SCHEME>
	operator and operands
      </SCHEME>
      <JAVASCRIPT>
	function and argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    don<APOS></APOS>t result in
    any saving of registers, because in this case those evaluations don<APOS></APOS>t
    modify the registers in question.
    <!-- Error occurred while translating this section --><SNIPPET LATEX="yes">
      <SCHEME>
  (assign proc
          (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
after-call15
      </SCHEME>
      <JAVASCRIPT><!--   The $\texttt{ }\texttt{ }$ below is a hack to ensure the leading spaces are not consumed  -->
$\texttt{ }\texttt{ }$assign(&quot;fun&quot;, list(op(&quot;lookup_symbol_value&quot;),
                     constant(&quot;===&quot;), reg(&quot;env&quot;))),
  assign(&quot;val&quot;, constant(1)),
  assign(&quot;argl&quot;, list(op(&quot;list&quot;), reg(&quot;val&quot;))),
  assign(&quot;val&quot;, list(op(&quot;lookup_symbol_value&quot;),
                     constant(&quot;n&quot;), reg(&quot;env&quot;))),
  assign(&quot;argl&quot;, list(op(&quot;pair&quot;), reg(&quot;val&quot;), reg(&quot;argl&quot;))),
  test(list(op(&quot;is_primitive_function&quot;), reg(&quot;fun&quot;))),
  branch(label(&quot;primitive_branch6&quot;)),
&quot;compiled_branch7&quot;,
  assign(&quot;continue&quot;, label(&quot;after_call8&quot;)),
  save(&quot;continue&quot;),
  push_marker_to_stack(),
  assign(&quot;val&quot;, list(op(&quot;compiled_function_entry&quot;), reg(&quot;fun&quot;))),
  go_to(reg(&quot;val&quot;)),
&quot;primitive_branch6&quot;,
  assign(&quot;val&quot;, list(op(&quot;apply_primitive_function&quot;),
                     reg(&quot;fun&quot;), 
                     reg(&quot;argl&quot;))),
&quot;after_call8&quot;,
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The true branch, which is the constant 1, compiles (with target
    <!-- Error occurred while translating this section --><SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>&quot;return&quot;</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    to
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(assign val (const 1))
(goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
$\texttt{ }\texttt{ }$assign(&quot;val&quot;, constant(1)),
  go_to(reg(&quot;continue&quot;)),
      </JAVASCRIPT>
    </SNIPPET>
    The code for the false branch is another
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call, where the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is the value of the symbol
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>*</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>&quot;*&quot;</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and the arguments
    are <!-- Error occurred while translating this section --><SCHEMEINLINE>n</SCHEMEINLINE> and the result of another
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call (a call to <!-- Error occurred while translating this section --><SCHEMEINLINE>factorial</SCHEMEINLINE>).
    Each of these calls sets up
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and <!-- Error occurred while translating this section --><SCHEMEINLINE>argl</SCHEMEINLINE> and its own primitive
    and compound branches.  Figure<SPACE></SPACE><REF NAME="fig:comp-factorial1"></REF>
    shows the complete compilation of the
    <SPLITINLINE>
      <SCHEME>
	definition
      </SCHEME>
      <JAVASCRIPT>
	declaration
      </JAVASCRIPT>
    </SPLITINLINE>
    of the <!-- Error occurred while translating this section --><SCHEMEINLINE>factorial</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    Notice that the possible <!-- Error occurred while translating this section --><SCHEMEINLINE>save</SCHEMEINLINE> and
    <!-- Error occurred while translating this section --><SCHEMEINLINE>restore</SCHEMEINLINE> of
    <!-- Error occurred while translating this section --><SCHEMEINLINE>continue</SCHEMEINLINE> and
    <!-- Error occurred while translating this section --><SCHEMEINLINE>env</SCHEMEINLINE> around the predicate, shown above,
    are in fact generated, because these registers are modified by the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call in the predicate and needed for the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call and the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>&quot;return&quot;</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    linkage in the branches.
  <!-- Error occurred while translating this section --></TEXT>

  <FIGURE CENTER="no" CONTINUED="yes">
    <SNIPPET SMALL="yes" EVAL="no" LATEX="yes">
      <NAME>compiled_factorial_1</NAME>
      <SCHEME>
;; construct the procedure and skip over code for the procedure body
  (assign val
          (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))

entry2     ; calls to factorial will enter here
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
         (op extend-environment) (const (n)) (reg argl) (reg env))
;; begin actual procedure body
  (save continue)
  (save env)

;; compute (= n 1)
  (assign proc (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

  after-call15   ; val now contains result of (= n 1)
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5  ; return 1
  (assign val (const 1))
  (goto (reg continue))

false-branch4
;; compute and return $\texttt{(* (factorial (- n 1)) n)}$
  (assign proc (op lookup-variable-value) (const *) (reg env))
  (save continue)
  (save proc)   ; save * procedure
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op list) (reg val))
  (save argl)   ; save partial argument list for *

;; compute $\texttt{(factorial (- n 1))}$, which is the other argument for *
  (assign proc
          (op lookup-variable-value) (const factorial) (reg env))
  (save proc)  ; save factorial procedure
    </SCHEME>
    <JAVASCRIPT>
// construct the function and skip over the code for the function body
  assign(&quot;val&quot;, list(op(&quot;make_compiled_function&quot;), 
                     label(&quot;entry1&quot;), reg(&quot;env&quot;))),
  go_to(label(&quot;after_lambda2&quot;)),
&quot;entry1&quot;,                           // calls to $\texttt{factorial}$ will enter here
  assign(&quot;env&quot;, list(op(&quot;compiled_function_env&quot;), reg(&quot;fun&quot;))),
  assign(&quot;env&quot;, list(op(&quot;extend_environment&quot;), constant(list(&quot;n&quot;)), 
                     reg(&quot;argl&quot;), reg(&quot;env&quot;))),
// begin actual function body
  revert_stack_to_marker(),         // starts with a return statement
  restore(&quot;continue&quot;),
  save(&quot;continue&quot;),                 // preserve registers across predicate
  save(&quot;env&quot;),
// compute $\texttt{n === 1}$
  assign(&quot;fun&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;===&quot;), reg(&quot;env&quot;))),
  assign(&quot;val&quot;, constant(1)),
  assign(&quot;argl&quot;, list(op(&quot;list&quot;), reg(&quot;val&quot;))),
  assign(&quot;val&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;n&quot;), reg(&quot;env&quot;))),
  assign(&quot;argl&quot;, list(op(&quot;pair&quot;), reg(&quot;val&quot;), reg(&quot;argl&quot;))),
  test(list(op(&quot;is_primitive_function&quot;), reg(&quot;fun&quot;))),
  branch(label(&quot;primitive_branch6&quot;)),
&quot;compiled_branch7&quot;,
  assign(&quot;continue&quot;, label(&quot;after_call8&quot;)),
  save(&quot;continue&quot;),
  push_marker_to_stack(),
  assign(&quot;val&quot;, list(op(&quot;compiled_function_entry&quot;), reg(&quot;fun&quot;))),
  go_to(reg(&quot;val&quot;)),
&quot;primitive_branch6&quot;,
  assign(&quot;val&quot;, list(op(&quot;apply_primitive_function&quot;), reg(&quot;fun&quot;), reg(&quot;argl&quot;))),
&quot;after_call8&quot;,                      // $\texttt{val}$ now contains result of $\texttt{n === 1}$
  restore(&quot;env&quot;),
  restore(&quot;continue&quot;),
  test(list(op(&quot;is_falsy&quot;), reg(&quot;val&quot;))),
  branch(label(&quot;false_branch4&quot;)),
&quot;true_branch3&quot;,                     // return 1
  assign(&quot;val&quot;, constant(1)),
  go_to(reg(&quot;continue&quot;)),
&quot;false_branch4&quot;,
// compute and return $\texttt{factorial(n - 1) * n}$
  assign(&quot;fun&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;*&quot;), reg(&quot;env&quot;))),
  save(&quot;continue&quot;),
  save(&quot;fun&quot;),                      // save $\texttt{*}$ function
  assign(&quot;val&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;n&quot;), reg(&quot;env&quot;))),
  assign(&quot;argl&quot;, list(op(&quot;list&quot;), reg(&quot;val&quot;))),
  save(&quot;argl&quot;),                     // save partial argument list for $\texttt{*}$
// compute $\texttt{factorial(n - 1)}$ which is the other argument for $\texttt{*}$
  assign(&quot;fun&quot;, list(op(&quot;lookup_symbol_value&quot;), 
                     constant(&quot;factorial&quot;), reg(&quot;env&quot;))),
  save(&quot;fun&quot;),                      // save $\texttt{factorial}$ function
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>
    Compilation of the declaration of the <SCHEMEINLINE>factorial</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    (continued on next page).
  </CAPTION>
  <!-- Error occurred while translating this section --><LABEL NAME="fig:comp-factorial1"></LABEL>
  </FIGURE>
  <FIGURE CENTER="no">
  <SNIPPET SMALL="yes" LATEX="yes">
    <NAME>compiled_factorial_2</NAME>
    <SCHEME>
  ;; $\texttt{compute (- n 1)}$, which is the argument for $\texttt{factorial}$
  (assign proc (op lookup-variable-value) (const -) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch label primitive-branch8))
compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call6   ; val now contains result of $\texttt{(- n 1)}$
  (assign argl (op list) (reg val))
  (restore proc) ; restore factorial
;; apply factorial
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch10
  (assign continue (label after-call9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call9      ; val now contains result of $\texttt{(factorial (- n 1))}$
  (restore argl) ; restore partial argument list for *
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc) ; restore *
  (restore continue)
  ;; apply * and return its value
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch13
;; note that a compound procedure here is called tail-recursively
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call12
after-if3
after-lambda1
;; assign the procedure to the variable factorial
  (perform
  (op define-variable!) (const factorial) (reg val) (reg env))
  (assign val (const ok))
    </SCHEME>
    <JAVASCRIPT>
// compute $\texttt{n - 1}$ which is the argument for $\texttt{factorial}$
  assign(&quot;fun&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;-&quot;), reg(&quot;env&quot;))),
  assign(&quot;val&quot;, constant(1)),
  assign(&quot;argl&quot;, list(op(&quot;list&quot;), reg(&quot;val&quot;))),
  assign(&quot;val&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;n&quot;), reg(&quot;env&quot;))),
  assign(&quot;argl&quot;, list(op(&quot;pair&quot;), reg(&quot;val&quot;), reg(&quot;argl&quot;))),
  test(list(op(&quot;is_primitive_function&quot;), reg(&quot;fun&quot;))),
  branch(label(&quot;primitive_branch10&quot;)),
&quot;compiled_branch11&quot;,
  assign(&quot;continue&quot;, label(&quot;after_call12&quot;)),
  save(&quot;continue&quot;),
  push_marker_to_stack(),
  assign(&quot;val&quot;, list(op(&quot;compiled_function_entry&quot;), reg(&quot;fun&quot;))),
  go_to(reg(&quot;val&quot;)),
&quot;primitive_branch10&quot;,
  assign(&quot;val&quot;, list(op(&quot;apply_primitive_function&quot;), reg(&quot;fun&quot;), reg(&quot;argl&quot;))),
&quot;after_call12&quot;,                     // $\texttt{val}$ now contains result of $\texttt{n - 1}$
  assign(&quot;argl&quot;, list(op(&quot;list&quot;), reg(&quot;val&quot;))),
  restore(&quot;fun&quot;),                   // restore $\texttt{factorial}$
// apply $\texttt{factorial}$
  test(list(op(&quot;is_primitive_function&quot;), reg(&quot;fun&quot;))),
  branch(label(&quot;primitive_branch14&quot;)),
&quot;compiled_branch15&quot;,
  assign(&quot;continue&quot;, label(&quot;after_call16&quot;)),
  save(&quot;continue&quot;),                 // set up for compiled function $-$
  push_marker_to_stack(),           //   return in function will restore stack
  assign(&quot;val&quot;, list(op(&quot;compiled_function_entry&quot;), reg(&quot;fun&quot;))),
  go_to(reg(&quot;val&quot;)),
&quot;primitive_branch14&quot;,
  assign(&quot;val&quot;, list(op(&quot;apply_primitive_function&quot;), reg(&quot;fun&quot;), reg(&quot;argl&quot;))),
&quot;after_call16&quot;,                     // $\texttt{val}$ now contains result of $\texttt{factorial(n - 1)}$
  restore(&quot;argl&quot;),                  // restore partial argument list for $\texttt{*}$
  assign(&quot;argl&quot;, list(op(&quot;pair&quot;), reg(&quot;val&quot;), reg(&quot;argl&quot;))),
  restore(&quot;fun&quot;),                   // restore $\texttt{*}$
  restore(&quot;continue&quot;),
// apply $\texttt{*}$ and return its value
  test(list(op(&quot;is_primitive_function&quot;), reg(&quot;fun&quot;))),
  branch(label(&quot;primitive_branch18&quot;)),
&quot;compiled_branch19&quot;, // note that a compound function here is called tail-recursively
  save(&quot;continue&quot;),
  push_marker_to_stack(),
  assign(&quot;val&quot;, list(op(&quot;compiled_function_entry&quot;), reg(&quot;fun&quot;))),
  go_to(reg(&quot;val&quot;)),
&quot;primitive_branch18&quot;,
  assign(&quot;val&quot;, list(op(&quot;apply_primitive_function&quot;), reg(&quot;fun&quot;), reg(&quot;argl&quot;))),
  go_to(reg(&quot;continue&quot;)),
&quot;after_call20&quot;,
&quot;after_cond5&quot;,
&quot;after_lambda2&quot;,
// assign the function to the name $\texttt{factorial}$
  perform(list(op(&quot;assign_symbol_value&quot;), 
               constant(&quot;factorial&quot;), reg(&quot;val&quot;), reg(&quot;env&quot;))),
  assign(&quot;val&quot;, constant(undefined))
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>(continued)</CAPTION>
  <!-- Error occurred while translating this section --><LABEL NAME="fig:continued_1"></LABEL>
</FIGURE>

  <SPLITINLINE>
    <SCHEME>
      <INDEX>compiler for Scheme<SUBINDEX>example compilation<CLOSE></CLOSE></SUBINDEX></INDEX>
    </SCHEME>
    <JAVASCRIPT>
      <INDEX>compiler for JavaScript<SUBINDEX>example compilation<CLOSE></CLOSE></SUBINDEX></INDEX>
    </JAVASCRIPT>
  </SPLITINLINE><!-- Error occurred while translating this section -->
  
  <EXERCISE>
    Consider the following declaration of a factorial
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    which is slightly different from the one given above:
    <SNIPPET EVAL="no">
      <SCHEME>
(define (factorial-alt n)
  (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
      </SCHEME>
      <JAVASCRIPT>
function factorial_alt(n) {
    return n === 1
           ? 1
           : n * factorial_alt(n - 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Compile this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    and compare the resulting code with that produced for
    <SCHEMEINLINE>factorial</SCHEMEINLINE>.  Explain any differences you find.
    Does either program execute more efficiently than the other?
    <LABEL NAME="ex:5_36"></LABEL>
  </EXERCISE><!-- Error occurred while translating this section -->

  <EXERCISE>
    Compile the
    <INDEX>iterative process<SUBINDEX>recursive process vs.</SUBINDEX></INDEX>
    <INDEX>recursive process<SUBINDEX>iterative process vs.</SUBINDEX></INDEX>
    iterative factorial
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
(define (factorial n)
  (define (iter product counter)
    (if (&gt; counter n)
        product
        (iter (* counter product)
        (+ counter 1))))
  (iter 1 1))
      </SCHEME>
      <JAVASCRIPT>
function factorial(n) {
    function iter(product, counter) {
        return counter &gt; n
               ? product
               : iter(product * counter, counter + 1);
    }
    return iter(1, 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Annotate the resulting code, showing the essential difference between
    the code for iterative and recursive versions of
    <SCHEMEINLINE>factorial</SCHEMEINLINE> that makes one process build up
    stack space and the other run in constant stack space.
    <LABEL NAME="ex:compiled-fact"></LABEL>
  </EXERCISE><!-- Error occurred while translating this section -->

<EXERCISE>
  What
  <SPLITINLINE>
    <SCHEME>
      expression
    </SCHEME>
    <JAVASCRIPT>
      program
    </JAVASCRIPT>
  </SPLITINLINE>
  was compiled to produce the code shown in
  figure<SPACE></SPACE><REF NAME="fig:compilation-example1"></REF>?
  <LABEL NAME="ex:compiled-code"></LABEL>
</EXERCISE><!-- Error occurred while translating this section -->
      
  <FIGURE CENTER="no" CONTINUED="yes">
  <SNIPPET SMALL="yes" LATEX="yes">
    <SCHEME>
  (assign val (op make-compiled-procedure) label entry16)
                                           (reg env))
  (goto (label after-lambda15))
entry16
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
    (op extend-environment) (const (x)) (reg argl) (reg env))
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc (op lookup-variable-value) (const g) (reg env))
  (save proc)
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch19
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch22
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
    </SCHEME>
    <JAVASCRIPT><!--   The $\texttt{ }\texttt{ }$ below is a hack to ensure the leading spaces are not consumed  -->
$\texttt{ }\texttt{ }$assign(&quot;val&quot;, list(op(&quot;make_compiled_function&quot;), 
                     label(&quot;entry1&quot;), reg(&quot;env&quot;))),
&quot;entry1&quot;
  assign(&quot;env&quot;, list(op(&quot;compiled_function_env&quot;), reg(&quot;fun&quot;))), 
  assign(&quot;env&quot;, list(op(&quot;extend_environment&quot;), 
                     constant(list(&quot;x&quot;)), reg(&quot;argl&quot;), reg(&quot;env&quot;))), 
  revert_stack_to_marker(), 
  restore(&quot;continue&quot;), 
  assign(&quot;fun&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;+&quot;), reg(&quot;env&quot;))), 
  save(&quot;continue&quot;), 
  save(&quot;fun&quot;), 
  save(&quot;env&quot;), 
  assign(&quot;fun&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;g&quot;), reg(&quot;env&quot;))), 
  save(&quot;fun&quot;), 
  assign(&quot;fun&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;+&quot;), reg(&quot;env&quot;))), 
  assign(&quot;val&quot;, constant(2)), 
  assign(&quot;argl&quot;, list(op(&quot;list&quot;), reg(&quot;val&quot;))), 
  assign(&quot;val&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;x&quot;), reg(&quot;env&quot;))), 
  assign(&quot;argl&quot;, list(op(&quot;pair&quot;), reg(&quot;val&quot;), reg(&quot;argl&quot;))), 
  test(list(op(&quot;is_primitive_function&quot;), reg(&quot;fun&quot;))), 
  branch(label(&quot;primitive_branch3&quot;)), 
&quot;compiled_branch4&quot;
  assign(&quot;continue&quot;, label(&quot;after_call5&quot;)), 
  save(&quot;continue&quot;), 
  push_marker_to_stack(), 
  assign(&quot;val&quot;, list(op(&quot;compiled_function_entry&quot;), reg(&quot;fun&quot;))), 
  go_to(reg(&quot;val&quot;)), 
&quot;primitive_branch3&quot;, 
  assign(&quot;val&quot;, list(op(&quot;apply_primitive_function&quot;), reg(&quot;fun&quot;), reg(&quot;argl&quot;))), 
&quot;after_call5&quot;, 
  assign(&quot;argl&quot;, list(op(&quot;list&quot;), reg(&quot;val&quot;))), 
  restore(&quot;fun&quot;), 
  test(list(op(&quot;is_primitive_function&quot;), reg(&quot;fun&quot;))), 
  branch(label(&quot;primitive_branch7&quot;)), 
&quot;compiled_branch8&quot;, 
  assign(&quot;continue&quot;, label(&quot;after_call9&quot;)), 
  save(&quot;continue&quot;), 
  push_marker_to_stack(), 
  assign(&quot;val&quot;, list(op(&quot;compiled_function_entry&quot;), reg(&quot;fun&quot;))), 
  go_to(reg(&quot;val&quot;)), 
&quot;primitive_branch7&quot;, 
  assign(&quot;val&quot;, list(op(&quot;apply_primitive_function&quot;), reg(&quot;fun&quot;), reg(&quot;argl&quot;))), 
&quot;after_call9&quot;, 
  assign(&quot;argl&quot;, list(op(&quot;list&quot;), reg(&quot;val&quot;))), 
  restore(&quot;env&quot;), 
  assign(&quot;val&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;x&quot;), reg(&quot;env&quot;))), 
  assign(&quot;argl&quot;, list(op(&quot;pair&quot;), reg(&quot;val&quot;), reg(&quot;argl&quot;))), 
  restore(&quot;fun&quot;), 
  restore(&quot;continue&quot;), 
  test(list(op(&quot;is_primitive_function&quot;), reg(&quot;fun&quot;))), 
  branch(label(&quot;primitive_branch11&quot;)), 
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>
    An example of compiler output (continued on next page).
    See exercise<SPACE></SPACE><REF NAME="ex:compiled-code"></REF>.
  </CAPTION>
  <!-- Error occurred while translating this section --><LABEL NAME="fig:compilation-example1"></LABEL>
  </FIGURE>
  <FIGURE CENTER="no">
    <SNIPPET EVAL="no" SMALL="yes" LATEX="yes">
      <SCHEME>
after-call20
  (assign argl (op list), (reg val))
  (restore env)
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch label primitive-branch25))
compiled-branch24
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch25
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call23
after-lambda15
  (perform (op define-variable!) (const f) (reg val) (reg env))
  (assign val (const ok))
    </SCHEME>
    <JAVASCRIPT><!--  The $\texttt{ }\texttt{ }$ below is a hack to ensure the leading spaces are not consumed -->
&quot;compiled_branch12&quot;, 
  save(&quot;continue&quot;), 
  push_marker_to_stack(), 
  assign(&quot;val&quot;, list(op(&quot;compiled_function_entry&quot;), reg(&quot;fun&quot;))), 
  go_to(reg(&quot;val&quot;)), 
&quot;primitive_branch11&quot;, 
  assign(&quot;val&quot;, list(op(&quot;apply_primitive_function&quot;), reg(&quot;fun&quot;), reg(&quot;argl&quot;))), 
  go_to(reg(&quot;continue&quot;)), 
&quot;after_call13&quot;, 
&quot;after_lambda2&quot;, 
  perform(list(op(&quot;assign_symbol_value&quot;),
               constant(&quot;f&quot;), reg(&quot;val&quot;), reg(&quot;env&quot;))),
  assign(&quot;val&quot;, constant(undefined))
    </JAVASCRIPT>
  </SNIPPET>
    <CAPTION>(continued)</CAPTION>
    <LABEL NAME="fig:continued_2"></LABEL>
  </FIGURE><!-- Error occurred while translating this section -->

  <INDEX><USE>factorial</USE><SUBINDEX>compilation of<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->

  <EXERCISE>
    What
    <INDEX>order of evaluation<SUBINDEX>in compiler</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>compiler for Scheme<SUBINDEX>order of operand evaluation</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>compiler for JavaScript<SUBINDEX>order of argument evaluation</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    order of evaluation does our compiler produce for
    <SPLITINLINE>
      <SCHEME>operands of a combination?</SCHEME>
      <JAVASCRIPT>arguments of an application?</JAVASCRIPT>
    </SPLITINLINE>
    Is it left-to-right (as mandated by the ECMAScript specification), right-to-left, or some other order?
    Where in the compiler is this order determined?  Modify the compiler
    so that it produces some other order of evaluation.  (See the
    discussion of order of evaluation for the explicit-control evaluator
    in section<SPACE></SPACE><REF NAME="sec:eceval-core"></REF>.)  How does changing the
    order of
    <SPLITINLINE>
      <SCHEME>operand</SCHEME>
      <JAVASCRIPT>argument</JAVASCRIPT>
    </SPLITINLINE>
    evaluation affect the efficiency of the code that
    constructs the argument list?
    <LABEL NAME="ex:5_39"></LABEL>
  </EXERCISE><!-- Error occurred while translating this section -->

  <EXERCISE>
    One way to understand the compiler<APOS></APOS>s
    <INDEX>compiler for JavaScript<SUBINDEX>stack usage</SUBINDEX></INDEX>
    <INDEX><USE>preserving</USE></INDEX>
    <SCHEMEINLINE>preserving</SCHEMEINLINE> mechanism for
    optimizing stack usage is to see what extra operations would
    be generated if we did not use this idea.  Modify
    <SCHEMEINLINE>preserving</SCHEMEINLINE> so
    that it always generates the <SCHEMEINLINE>save</SCHEMEINLINE> and
    <SCHEMEINLINE>restore</SCHEMEINLINE> operations.
    Compile some simple expressions and identify the unnecessary stack
    operations that are generated.
    Compare the code to that generated with the
    <SCHEMEINLINE>preserving</SCHEMEINLINE> mechanism intact.
    <LABEL NAME="ex:5_40"></LABEL>
  </EXERCISE><!-- Error occurred while translating this section -->

  <EXERCISE>
    <LABEL NAME="ex:open-code"></LABEL>
    Our compiler is clever about avoiding unnecessary stack operations,
    but it is not clever at all when it comes to compiling calls to the primitive
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    of the language in terms of the primitive operations
    supplied by the machine.  For example, consider how much code is
    compiled to compute
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(+ a 1)</SCHEMEINLINE>:</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>a + 1</JAVASCRIPTINLINE>:</JAVASCRIPT>
    </SPLITINLINE>
    The code sets up an argument list in <!-- Error occurred while translating this section --><SCHEMEINLINE>argl</SCHEMEINLINE>, puts
    the primitive addition
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    (which it finds by looking up the symbol
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>+</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>&quot;+&quot;</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in the environment) into
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>,</JAVASCRIPT>
      </SPLITINLINE>
    and tests whether the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is primitive or compound.  The
    compiler always generates code to perform the test, as well as code
    for primitive and compound branches (only one of which will be executed).
    We have not shown the part of the controller that implements
    primitives, but we presume that these instructions make use of
    primitive arithmetic operations in the machine<APOS></APOS>s data paths.  Consider
    how much less code would be generated if the compiler could
    <INDEX>compiler for JavaScript<SUBINDEX>open coding of primitives</SUBINDEX></INDEX>
    <INDEX>open coding of primitives</INDEX>
    <EM>open-code</EM> primitives<EMDASH></EMDASH>that is, if it could generate code to
    directly use these primitive machine operations.  The expression
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(+ a 1)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>a + 1</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    might be compiled into something as simple as<!-- Error occurred while translating this section --><FOOTNOTE>We have used
    the same symbol <SCHEMEINLINE>+</SCHEMEINLINE> here to denote both the
    source-language
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    and the machine operation.  In general there will not be a
    one-to-one correspondence between primitives of the source language
    and primitives of the machine.</FOOTNOTE>
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no">
      <SCHEME>
(assign val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
      </SCHEME>
      <JAVASCRIPT>
assign(&quot;val&quot;, list(op(&quot;lookup_symbol_value&quot;), constant(&quot;a&quot;), reg(&quot;env&quot;))),
assign(&quot;val&quot;, list(op(&quot;+&quot;), reg(&quot;val&quot;), constant(1)))
      </JAVASCRIPT>
    </SNIPPET>
    In this exercise we will extend our compiler to support open coding of
    selected primitives.  Special-purpose code will be generated for calls to these primitive
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    instead of the general
    <SPLITINLINE>
      <SCHEME>procedure-application</SCHEME>
      <JAVASCRIPT>function-application</JAVASCRIPT>
    </SPLITINLINE>
    code.  In order to support this, we will augment
    our machine with special argument registers
    <!-- Error occurred while translating this section --><SCHEMEINLINE>arg1</SCHEMEINLINE> and <!-- Error occurred while translating this section --><SCHEMEINLINE>arg2</SCHEMEINLINE>.
    The primitive arithmetic operations of the machine will take their
    inputs from <!-- Error occurred while translating this section --><SCHEMEINLINE>arg1</SCHEMEINLINE> and
    <!-- Error occurred while translating this section --><SCHEMEINLINE>arg2</SCHEMEINLINE>. The results may be put into
    <!-- Error occurred while translating this section --><SCHEMEINLINE>val</SCHEMEINLINE>, <SCHEMEINLINE>arg1</SCHEMEINLINE>, or
    <!-- Error occurred while translating this section --><SCHEMEINLINE>arg2</SCHEMEINLINE>.
    <P></P>
    The compiler must be able to recognize the application of an
    open-coded primitive in the source program.  We will augment the
    dispatch in the <!-- Error occurred while translating this section --><SCHEMEINLINE>compile</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to recognize the names of these primitives in addition to the
    <SPLITINLINE>
      <SCHEME>
	<INDEX>reserved words</INDEX>
	reserved words (the special forms)
	it currently recognizes.<FOOTNOTE>Making
	the primitives into reserved words is in general a bad idea, since a user
	cannot then rebind these names to different procedures.
	Moreover, if we add reserved words to
	a compiler that is in use, existing programs that define procedures
	with these names will stop working.  See
	exercise<SPACE></SPACE><REF NAME="ex:cte-open-code"></REF> for ideas on how to avoid
	this problem.</FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	syntactic forms it currently recognizes.
      </JAVASCRIPT>
    </SPLITINLINE>
    For each
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>syntactic</JAVASCRIPT>
    </SPLITINLINE>
    form our compiler has a code
    generator.  In this exercise we will construct a family of code generators
    for the open-coded primitives.
    <!-- Error occurred while translating this section --><OL>
      <LI>
	The open-coded primitives, unlike the
	<SPLITINLINE>
	  <SCHEME>special</SCHEME>
	  <JAVASCRIPT>syntactic</JAVASCRIPT>
	</SPLITINLINE>
	forms, all need their
	<SPLITINLINE>
	  <SCHEME>operands</SCHEME>
	  <JAVASCRIPT>argument expressions</JAVASCRIPT>
	</SPLITINLINE>
	evaluated.  Write a code generator
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>spread-arguments</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>spread_arguments</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	for use by all the open-coding code generators.
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>Spread-arguments</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    The function
	    <JAVASCRIPTINLINE>spread_arguments</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	should take
	<SPLITINLINE>
	  <SCHEME>an operand list</SCHEME>
	  <JAVASCRIPT>a list of argument expressions</JAVASCRIPT>
	</SPLITINLINE>
	and compile the given
	<SPLITINLINE>
	  <SCHEME>operands</SCHEME>
	  <JAVASCRIPT>argument expressions</JAVASCRIPT>
	</SPLITINLINE>
	targeted to
	successive argument registers.  Note that an
	<SPLITINLINE>
	  <SCHEME>operand</SCHEME>
	  <JAVASCRIPT>argument expression</JAVASCRIPT>
	</SPLITINLINE>
	may contain a call
	to an open-coded primitive, so argument registers will have to be
	preserved during
	<SPLITINLINE>
	  <SCHEME>operand</SCHEME>
	  <JAVASCRIPT>argument-expression</JAVASCRIPT>
	</SPLITINLINE>
	evaluation.
      </LI>
      <!-- Error occurred while translating this section --><LI>
	<SPLIT>
	  <JAVASCRIPT>
	    The JavaScript operators
	    <JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,
	    <SCHEMEINLINE>*</SCHEMEINLINE>,
	    <SCHEMEINLINE>-</SCHEMEINLINE>, and <SCHEMEINLINE>+</SCHEMEINLINE>,
	    among others, are implemented in the register machine as
	    primitive functions and are referred to in the global environment
	    with the symbols
	    <JAVASCRIPTINLINE>&quot;===&quot;</JAVASCRIPTINLINE>,
	    <SCHEMEINLINE>&quot;*&quot;</SCHEMEINLINE>,
	    <SCHEMEINLINE>&quot;-&quot;</SCHEMEINLINE>, and
	    <SCHEMEINLINE>&quot;+&quot;</SCHEMEINLINE>. In JavaScript, it is
	    not possible to redeclare these names, because they do not
	    meet the syntactic restrictions for names. This means it is safe
	    to open-code them.
	  </JAVASCRIPT>
	</SPLIT>
	For each of the primitive
	<SPLITINLINE>
	  <SCHEME>procedures</SCHEME>
	  <JAVASCRIPT>functions</JAVASCRIPT>
	</SPLITINLINE>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>=</SCHEMEINLINE>,</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,</JAVASCRIPT>
	</SPLITINLINE>
	<SCHEMEINLINE>*</SCHEMEINLINE>,
	<SCHEMEINLINE>-</SCHEMEINLINE>, and <SCHEMEINLINE>+</SCHEMEINLINE>,
	write a code generator that takes
	<SPLITINLINE>
	  <SCHEME>a combination with that operator,
	  </SCHEME>
	  <JAVASCRIPT>an application with a function expression that
	  names that function,
	  </JAVASCRIPT>
	</SPLITINLINE>
	together with a target and a linkage descriptor, and
	produces code to spread the arguments into the registers and then
	perform the operation targeted to the given target with the given
	linkage.
	<SPLITINLINE>
	  <SCHEME>You need only handle expressions with two operands.</SCHEME>
	</SPLITINLINE>
	Make <SCHEMEINLINE>compile</SCHEMEINLINE> dispatch to these code
	generators.
      </LI>
      <LI>
	Try your new compiler on the <SCHEMEINLINE>factorial</SCHEMEINLINE>
	example.  Compare the resulting code with the result produced without
	open coding.
      </LI>
      <!-- Error occurred while translating this section --><SPLIT>
	<SCHEME>
	  <LI>
	    Extend your code generators for <SCHEMEINLINE>+</SCHEMEINLINE> and
	    <SCHEMEINLINE>*</SCHEMEINLINE> so that they
	    can handle expressions with arbitrary numbers of operands.  An
	    expression with more than two operands will have to be compiled into a
	    sequence of operations, each with only two inputs.
	  </LI>
	</SCHEME>
      </SPLIT>
    <!-- Error occurred while translating this section --></OL>
  </EXERCISE>
</SUBSECTION>

