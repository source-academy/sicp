<SUBSECTION>
   <NAME>
    数据导向编程和可加性
  </NAME> 

  <LABEL NAME="sec:data-directed"></LABEL>
   <INDEX>数据导向编程<OPEN></OPEN></INDEX> 
   <INDEX>可加性<OPEN></OPEN></INDEX> 

   <TEXT>
    检查数据类型并调用适当<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>的一般策略被称为<INDEX>模块性<SUBINDEX>通过类型分派</SUBINDEX></INDEX><INDEX>分派<SUBINDEX>按类型</SUBINDEX></INDEX><INDEX>类型<SUBINDEX>基于类型分派</SUBINDEX></INDEX><EM>按类型分派</EM>。这是一种在系统设计中实现模块性的强大策略。然而，按照<REF NAME="sec:manifest-types"></REF>节实现分派有两个显著的弱点。一个弱点是通用接口<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE><SPLITINLINE>
      (real-part,
      <JAVASCRIPT>(<JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE><SPLITINLINE>
      imag-part,
      <JAVASCRIPT><JAVASCRIPTINLINE>imag_part</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>magnitude和angle）必须知道所有不同的表示。例如，假设我们想把一种新的复数表示集成到我们的复数系统中。我们需要用一种类型标识这种新表示，然后在每个通用接口<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>中添加一个子句，以检查新类型并应用适当的选择器以适应这种表示。
  </TEXT> 
   <TEXT>
    该技术的另一个弱点是，尽管各个表示可以单独设计，但我们必须确保整个系统中没有两个<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>具有相同的名称。这就是Ben和Alyssa为什么必须更改他们在<REF NAME="sec:representations-complex-numbers"></REF>节的原始<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>名称的原因。
  </TEXT> 
   <TEXT>
    这两种弱点的根本问题在于，实施通用接口的技术不是<EM>可加性</EM>的。实现通用选择器的人员
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    必须在每次安装新表示时修改这些
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，而接口个别表示的人员必须修改他们的代码以避免名称冲突。在每一种情况下，必须对代码进行的更改是直接的，但仍然要进行这些更改，这成为了不便和错误的来源。对于复数系统而言，这不是什么大问题，但假设复数的不同表示不止两种而是成百上千种。而且假设有许多通用选择器需要在抽象数据接口中维护。事实上，假设没有一个程序员知道所有的接口
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    或所有的表示。在诸如大型数据库管理系统的程序中，这个问题是现实的，必须加以解决。
  </TEXT> 
   <TEXT>
    我们需要的是一种进一步模块化系统设计的方法。这由被称为<EM>数据导向编程</EM>的编程技术提供。要理解数据导向编程是如何工作的，应首先注意到，每当我们处理一组通用于不同类型的泛型操作时，我们实际上是在处理一个二维表格，其中一个轴是可能的操作，另一个轴是可能的类型。表中的条目是为每种类型的参数实现每个操作的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。在前一节开发的复数系统中，操作名称、数据类型和实际
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    之间的对应关系分散在通用接口
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的各种条件语句中。但相同的信息本可以在一个表中组织起来，如
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:operator-table_scheme"></REF>.
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:operator-table"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
    所示。
  </TEXT> 
   <DO_BREAK_PAGE></DO_BREAK_PAGE> 
   <TEXT>
    数据导向编程是一种直接与这样的<INDEX>表<SUBINDEX>用于数据导向编程</SUBINDEX></INDEX>表格协同工作的编程技术。之前，我们通过一组<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>实现了将复数算法代码与两个表示包接口的机制，这些函数各自执行显式的类型分派。这里我们将接口实现为一个单一的<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>，它在表中查找操作名称和参数类型的组合以找到要应用的正确<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>，然后应用于该参数的内容。如果这样做，那么为系统添加新的表示包时，我们无需更改任何现有的<SPLITINLINE>
      过程;
      <JAVASCRIPT>函数;</JAVASCRIPT>
    </SPLITINLINE>我们只需在表中添加新的条目。
  </TEXT> 
  <TEXT>
     <SPLIT>
      
        <FIGURE SRC="img_original/ch2-Z-G-63.svg">
          <CAPTION>复数系统的操作表。</CAPTION>
          
	</FIGURE>
      
      <JAVASCRIPT>
        <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.7" SCALE="0.59" SRC="img_javascript/ch2-Z-G-63.svg">
          <CAPTION>复数系统的操作表。</CAPTION>
          
	</FIGURE>
      </JAVASCRIPT>
    </SPLIT>
    To implement this plan, assume that we have two
    <SPLITINLINE>
      过程,
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
     <SCHEMEINLINE>put</SCHEMEINLINE> 和 <SCHEMEINLINE>get</SCHEMEINLINE> ，用于操作<INDEX>操作与类型表</INDEX>操作与类型表： <UL>
       <LI>
       <INDEX><USE>放入</USE></INDEX> 
	<SPLITINLINE>
	  
	    (放入 
	    $\langle \textit{操作} \rangle\ \langle \textit{类型}
	    \rangle \ \langle \textit{项目} \rangle$
	    
	    )
	  
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>put(</JAVASCRIPTINLINE>&lt;!--   
	       --&gt;<META>op</META>&lt;!--   
	       --&gt;<JAVASCRIPTINLINE>, </JAVASCRIPTINLINE>&lt;!--   
	       --&gt;<META>type</META>&lt;!--   
	       --&gt;<JAVASCRIPTINLINE>, </JAVASCRIPTINLINE>&lt;!--   
	       --&gt;<META>item</META>&lt;!--   
	       --&gt;<JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	<BR></BR>
	在表中安装
	<SPLITINLINE>
	  
	    $\langle \textit{项目} \rangle$
	  
	  <JAVASCRIPT>
	    <META>item</META>
	  </JAVASCRIPT>
	</SPLITINLINE>
	，由
	<SPLITINLINE>
	  
	    $\langle \textit{操作} \rangle$ 和
	    $\langle \textit{类型} \rangle$索引。
	  
	  <JAVASCRIPT>
	    <META>op</META> 和
	    <META>type</META>索引。
	  </JAVASCRIPT>
	</SPLITINLINE>
      </LI>
        <LI>
	<INDEX><USE>获取</USE></INDEX> 
	<SPLITINLINE>
	  
	    (获取 
	    $\langle \textit{操作} \rangle\ \langle
	    \textit{类型}$
	    )
	  
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>get(</JAVASCRIPTINLINE>&lt;!--   
	       --&gt;<META>op</META>&lt;!--   
	       --&gt;<JAVASCRIPTINLINE>, </JAVASCRIPTINLINE>&lt;!--   
	       --&gt;<META>type</META>&lt;!--   
	       --&gt;<JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	<BR></BR>
	在表中查找
	<SPLITINLINE>
	  
	    $\langle \textit{操作} \rangle$、
	    $\langle \textit{类型} \rangle$
	  
	  <JAVASCRIPT>
	    <META>op</META>、
	    <META>type</META>
	  </JAVASCRIPT>
	</SPLITINLINE>
	项并返回找到的项目。如果未找到任何项目，
	获取返回
	<SPLITINLINE>
	  假。
	  <JAVASCRIPT>
	    一个使用名称<INDEX><USE>undefined</USE>（预声明的名称）</INDEX>
	    <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>引用并由基本谓词
	    <INDEX><USE>is_undefined</USE>（基本函数）</INDEX>
	    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>is_undefined</USE></SUBINDEX></INDEX>
	    <JAVASCRIPTINLINE>is_undefined</JAVASCRIPTINLINE>识别的独特基本值。<FOOTNOTE>
	    在任何JavaScript实现中，名称<JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>
	    是预声明的，除了用于引用该基本值外，不应用于其他目的。
	  </FOOTNOTE>
	  </JAVASCRIPT>
	</SPLITINLINE>
      </LI>
     </UL> 
    现在，我们可以假设 
<SCHEMEINLINE>put</SCHEMEINLINE> 和
     <SCHEMEINLINE>get</SCHEMEINLINE> 包含在我们的语言中。在chapter<SPACE></SPACE><REF NAME="chap:state"></REF>（section<SPACE></SPACE><REF NAME="sec:tables"></REF>）中，我们将看到如何实现这些以及其他用于操纵表的操作。
   </TEXT>
  <TEXT> 
    以下是数据导向编程在复数系统中的应用方式。开发直角坐标表示的Ben按照最初的方法实现他的代码。他定义了一组<SPLITINLINE>
      过程,
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>或一个<INDEX>包</INDEX><INDEX>包<SUBINDEX>直角坐标表示</SUBINDEX></INDEX><INDEX><USE>直角坐标</USE>包</INDEX><EM>包</EM>，并通过在表中添加条目来接口到系统的其他部分，这些条目告诉系统如何在直角坐标数上操作。这是通过调用以下<SPLITINLINE>
      过程:
      <JAVASCRIPT>函数:</JAVASCRIPT>
    </SPLITINLINE>实现的。
     <SNIPPET HIDE="yes">
      <NAME>operation_table_from_chapter_3</NAME>
      <JAVASCRIPT>
// operation_table, put and get
// from chapter 3 (section 3.3.3)
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET CHAP="3" HIDE="yes">
      <NAME>install_rectangular_package_usage</NAME>
      <JAVASCRIPT>
install_rectangular_package();
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="3">
      <INDEX><DECLARATION>install_rectangular_package</DECLARATION></INDEX> 
      <NAME>install_rectangular_package</NAME>
      <REQUIRES>operation_table_from_chapter_3</REQUIRES>
      <REQUIRES>operation_table</REQUIRES>
      <REQUIRES>attach_tag</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <EXAMPLE>install_rectangular_package_usage</EXAMPLE>
      <SCHEME>
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))

  ;; interface to the rest of the system
  (define (tag x) (attach-tag &apos;rectangular x))
  (put &apos;real-part &apos;(rectangular) real-part)
  (put &apos;imag-part &apos;(rectangular) imag-part)
  (put &apos;magnitude &apos;(rectangular) magnitude)
  (put &apos;angle &apos;(rectangular) angle)
  (put &apos;make-from-real-imag &apos;rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put &apos;make-from-mag-ang &apos;rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  &apos;done)
      </SCHEME>
      <JAVASCRIPT>
function install_rectangular_package() {
    // internal functions
    function real_part(z) { return head(z); }
    function imag_part(z) { return tail(z); }
    function make_from_real_imag(x, y) { return pair(x, y); }
    function magnitude(z) {
        return math_sqrt(square(real_part(z)) + square(imag_part(z)));
    }
    function angle(z) {
        return math_atan2(imag_part(z), real_part(z));
    }
    function make_from_mag_ang(r, a) {
        return pair(r * math_cos(a), r * math_sin(a));
    }

    // interface to the rest of the system
    function tag(x) { return attach_tag(&quot;rectangular&quot;, x); }
    put(&quot;real_part&quot;, list(&quot;rectangular&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;rectangular&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;rectangular&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;rectangular&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;rectangular&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT> 
    注意，这里的内部
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    是Ben在<REF NAME="sec:representations-complex-numbers"></REF>节中独立工作时编写的相同
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>。为了与系统其他部分接口，不需要进行任何更改。此外，由于这些
    <SPLITINLINE>
      过程定义
      <JAVASCRIPT>函数声明</JAVASCRIPT>
    </SPLITINLINE>
    是安装时的内部
    <SPLITINLINE>
      过程,
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    Ben不需要担心与直角坐标包外的其他
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的名称冲突。为了与系统其他部分接口，Ben将他的
    <SPLITINLINE>
      实部
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    安装在操作名称
    <SPLITINLINE>
      实部
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和类型
    <SPLITINLINE>
      
      (直角坐标),
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;rectangular&quot;)</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    下，类似地用于其他选择器。
 <FOOTNOTE>我们使用的是
    <SPLITINLINE>
      (直角坐标)
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;rectangular&quot;)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    列表，而不是
    <SPLITINLINE>
      符号直角坐标
      <JAVASCRIPT>字符串<JAVASCRIPTINLINE>&quot;rectangular&quot;</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    ，以便可能存在具有多个不同类型参数的操作。</FOOTNOTE> 接口还定义了外部系统使用的构造器。<FOOTNOTE>构造器安装时的类型不必是列表，因为构造器总是用于创建特定类型的对象。</FOOTNOTE> 这些与Ben内部定义的构造器相同，只是在它们上面附加了标签。
   </TEXT>
   <DO_BREAK_PAGE></DO_BREAK_PAGE> 
  <TEXT> 
    Alyssa<APOS></APOS>s
    <INDEX>包<SUBINDEX>极坐标表示</SUBINDEX></INDEX>
    <INDEX><USE>极坐标</USE>包</INDEX>
    极坐标包是类似的：
     <SNIPPET CHAP="4">
      <INDEX><DECLARATION>install_polar_package</DECLARATION></INDEX> 
      <NAME>install_polar_package</NAME>
      <REQUIRES>operation_table_from_chapter_3</REQUIRES>
      <REQUIRES>operation_table</REQUIRES>
      <REQUIRES>attach_tag</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>install_polar_package_usage</EXAMPLE>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))

  ;; interface to the rest of the system
  (define (tag x) (attach-tag &apos;polar x))
  (put &apos;real-part &apos;(polar) real-part)
  (put &apos;imag-part &apos;(polar) imag-part)
  (put &apos;magnitude &apos;(polar) magnitude)
  (put &apos;angle &apos;(polar) angle)
  (put &apos;make-from-real-imag &apos;polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put &apos;make-from-mag-ang &apos;polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  &apos;done)
      </SCHEME>
      <JAVASCRIPT>
function install_polar_package() {
    // internal functions
    function magnitude(z) { return head(z); }
    function angle(z) { return tail(z); }
    function make_from_mag_ang(r, a) { return pair(r, a); }
    function real_part(z) {
        return magnitude(z) * math_cos(angle(z));
    }
    function imag_part(z) {
        return magnitude(z) * math_sin(angle(z));
    }
    function make_from_real_imag(x, y) {
        return pair(math_sqrt(square(x) + square(y)),
                    math_atan2(y, x));
    }

    // interface to the rest of the system
    function tag(x) { return attach_tag(&quot;polar&quot;, x); }
    put(&quot;real_part&quot;, list(&quot;polar&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;polar&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;polar&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;polar&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;polar&quot;, 
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;polar&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4" HIDE="yes">
      <NAME>install_polar_package_usage</NAME>
      <REQUIRES>install_polar_package</REQUIRES>
      <JAVASCRIPT>
install_polar_package();
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
   <TEXT>
    即使Ben和Alyssa仍然使用各自的原始
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    并定义为相同的名称（例如，
    <SPLITINLINE>
      实部),
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE>),</JAVASCRIPT>
    </SPLITINLINE>
    这些声明现在属于不同的内部
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    （参见节<SPACE></SPACE><REF NAME="sec:block-structure"></REF>），因此没有名称冲突。
  </TEXT> 
  <TEXT> <TEXT>
    复数算术选择器通过一个通用<QUOTE>操作</QUOTE><SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>访问表，该通用操作被称为<SPLITINLINE>
      apply-generic,
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>，它将通用操作应用于一些参数。<SPLITINLINE>
      apply-generic
      <JAVASCRIPT>
	函数
	<JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>会根据操作名称和参数类型在表中查找，并在存在时应用结果<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>：
</TEXT> <FOOTNOTE>
     <SPLIT>
      
	apply-generic使用了在
	<INDEX>点尾注释<SUBINDEX><ORDER>过程</ORDER>用于程序参数</SUBINDEX></INDEX>
       练习<SPACE></SPACE><REF NAME="ex:dotted-arglist"></REF>中描述的点尾注释，因为不同的通用操作可能具有不同数量的参数。在
	<SPLITINLINE>
	  apply-generic,
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>,
	  </JAVASCRIPT>
	</SPLITINLINE>
	op的值是
	<SPLITINLINE>
	  apply-generic
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	的第一个参数，而args的值是剩余参数的列表。
	<BR></BR>
      
    </SPLIT>
    <SPLIT>
      
	apply-generic还使用了
	原语过程apply，它接受两个参数，一个过程和一个列表。apply利用列表中的元素作为参数来应用该过程。
      
      <JAVASCRIPT>
	函数<JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>使用了
	段<INDEX><USE>apply_in_underlying_javascript</USE></INDEX>
	apply_in_underlying_javascript中给出的函数,
        它接受两个参数，一个函数和一个列表，并用列表中的元素作为参数来应用该函数。参见部分<SPACE></SPACE><REF NAME="sec:running-eval"></REF>
	<PDF_ONLY>
	  (脚注<SPACE></SPACE><REF NAME="foot:vector-array"></REF>),
	</PDF_ONLY>
	<WEB_ONLY>
	  (脚注<SPACE></SPACE>2),
	</WEB_ONLY>
      </JAVASCRIPT>
    </SPLIT>
    例如,
     <SNIPPET EVAL="no">
      <SCHEME>
	(apply + (list 1 2 3 4))
      </SCHEME>
      <JAVASCRIPT>
	apply_in_underlying_javascript(sum_of_squares, list(1, 3))
      </JAVASCRIPT>
    </SNIPPET> 
    返回10。 </FOOTNOTE>
    <SNIPPET HIDE="yes">
      <NAME>apply_definition</NAME>
      <JAVASCRIPT>
// In Source, most functions have a fixed number of arguments.
// (The function list is the only exception, to this so far.)
// The function apply_in_underlying_javascript allows us to
// apply any given function fun to all elements of the argument 
// list args, as if they were separate arguments
function apply(fun, args) {
    return apply_in_underlying_javascript(fun, args);
}	  
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>apply_generic</DECLARATION></INDEX> 
      <NAME>apply_generic</NAME>
      <REQUIRES>apply_definition</REQUIRES>
      <SCHEME>
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
        (apply proc (map contents args))
        (error
          &quot;No method for these types -- APPLY-GENERIC&quot;
          (list op type-tags))))))
      </SCHEME>
      <JAVASCRIPT>
function apply_generic(op, args) {
    const type_tags = map(type_tag, args);
    const fun = get(op, type_tags);
    return ! is_undefined(fun)
           ? apply_in_underlying_javascript(fun, map(contents, args))
           : error(list(op, type_tags),
                   &quot;no method for these types -- apply_generic&quot;);
}
      </JAVASCRIPT>
    </SNIPPET> 
    使用
    <SPLITINLINE>
      apply-generic,
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    我们可以定义我们的通用选择器如下：
     <SNIPPET CHAP="4">
      <INDEX><DECLARATION>real_part</DECLARATION><SUBINDEX>data-directed</SUBINDEX></INDEX>
      <INDEX><DECLARATION>imag_part</DECLARATION><SUBINDEX>data-directed</SUBINDEX></INDEX>
      <INDEX><DECLARATION>magnitude</DECLARATION><SUBINDEX>data-directed</SUBINDEX></INDEX>
      <INDEX><DECLARATION>angle</DECLARATION><SUBINDEX>data-directed</SUBINDEX></INDEX>
      <NAME>generic_selectors</NAME>
      <REQUIRES>apply_generic</REQUIRES>
      <EXAMPLE>generic_selectors_example</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      <SCHEME>
(define (real-part z) (apply-generic &apos;real-part z))
(define (imag-part z) (apply-generic &apos;imag-part z))
(define (magnitude z) (apply-generic &apos;magnitude z))
(define (angle z) (apply-generic &apos;angle z))
      </SCHEME>
      <JAVASCRIPT>
function real_part(z) { return apply_generic(&quot;real_part&quot;, list(z)); }
<SHORT_SPACE></SHORT_SPACE>
function imag_part(z) { return apply_generic(&quot;imag_part&quot;, list(z)); }
<SHORT_SPACE></SHORT_SPACE>
function magnitude(z) { return apply_generic(&quot;magnitude&quot;, list(z)); }
<SHORT_SPACE></SHORT_SPACE>
function angle(z)     { return apply_generic(&quot;angle&quot;, list(z));     }
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>generic_selectors_example</NAME>
      <REQUIRES>install_rectangular_package</REQUIRES>
      <REQUIRES>install_rectangular_package_usage</REQUIRES>
      <REQUIRES>install_polar_package</REQUIRES>
      <REQUIRES>complex_number_calculation</REQUIRES>
      <REQUIRES>generic_constructors</REQUIRES>
      <JAVASCRIPT>
const my_complex_number = 
    make_from_real_imag(1.0, 4.5);

const result = 
    add_complex(my_complex_number,
                my_complex_number);

imag_part(result);		
      </JAVASCRIPT>
    </SNIPPET> 
    注意，如果向系统中添加新的表示，这些都不会发生任何变化。
   </TEXT>
   <TEXT>
    我们还可以从表中提取构造器，以供包外的程序使用，这些程序通过实部和虚部以及模长和角度构造复数。如在<REF NAME="sec:manifest-types"></REF>节中，我们在有实部和虚部时构造直角坐标数，而在有模长和角度时构造极坐标数：
    
      <INDEX><DECLARATION>make_complex_from_real_imag</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_complex_from_mag_ang</DECLARATION></INDEX> 
      <NAME>generic_constructors</NAME>
      <REQUIRES>generic_selectors</REQUIRES>	
      <EXAMPLE>generic_selectors_example</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      
(define (make-from-real-imag x y)
  ((get &apos;make-from-real-imag &apos;rectangular) x y))

(define (make-from-mag-ang r a)
  ((get &apos;make-from-mag-ang &apos;polar) r a))
      
      <JAVASCRIPT>
function make_from_real_imag(x, y) {
   return get(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;)(x, y);
}
function make_from_mag_ang(r, a) {
   return get(&quot;make_from_mag_ang&quot;, &quot;polar&quot;)(r, a);
}
      </JAVASCRIPT>
    
  </TEXT> 

  <EXERCISE> 
    节<SPACE></SPACE><REF NAME="sec:symbolic-differentiation"></REF>描述了一个执行<INDEX>符号微分</INDEX><INDEX>微分<SUBINDEX>符号</SUBINDEX></INDEX>符号微分的程序：
     <SNIPPET>
      <NAME>deriv_2_4</NAME>
      <REQUIRES>is_variable</REQUIRES>
      <REQUIRES>is_same_variable</REQUIRES>
      <REQUIRES>is_sum</REQUIRES>
      <REQUIRES>make_sum</REQUIRES>
      <REQUIRES>addend</REQUIRES>
      <REQUIRES>augend</REQUIRES>
      <REQUIRES>is_product</REQUIRES>
      <REQUIRES>multiplier</REQUIRES>
      <REQUIRES>multiplicand</REQUIRES>
      <EXAMPLE>xyx4</EXAMPLE>
      <EXPECTED>[ &apos;*&apos;, [ &apos;x&apos;, [ &apos;y&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp)
          (make-sum (deriv (addend exp) var)
                    (deriv (augend exp) var)))
        ((product? exp)
          (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
        ;; more rules can be added here
        (else (error &quot;unknown expression type -- DERIV&quot; exp))))
      </SCHEME>
      <JAVASCRIPT>
function deriv(exp, variable) {
    return is_number(exp)
           ? 0
           : is_variable(exp)
           ? is_same_variable(exp, variable) ? 1 : 0
           : is_sum(exp)
           ? make_sum(deriv(addend(exp), variable), 
                      deriv(augend(exp), variable))
           : is_product(exp)
           ? make_sum(make_product(multiplier(exp), 
                                   deriv(multiplicand(exp), variable)),
                      make_product(deriv(multiplier(exp), variable), 
                                   multiplicand(exp)))
           // more rules can be added here
           : error(exp, &quot;unknown expression type -- deriv&quot;);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>xyx4</NAME>
      <REQUIRES>deriv_2_4</REQUIRES>
      <SCHEME>
(deriv &apos;(* (* x y) (+ x 4)) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
(+ (* (* x y) (+ 1 0))
(* (+ (* x 0) (* 1 y))
(+  x 4)))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 4)), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(tail(head(tail(deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 4)), &quot;x&quot;)))));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(&quot;+&quot;, list(&quot;*&quot;, list(&quot;*&quot;, x, y), list(&quot;+&quot;, 1, 0)),
          list(&quot;*&quot;, list(&quot;+&quot;, list(&quot;*&quot;, x, 0), list(&quot;*&quot;, 1, y)),
                    list(&quot;+&quot;,  x, 4)))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    我们可以将此程序视为对要微分的表达式类型进行分派。在这种情况下，数据的<QUOTE>类型标签</QUOTE>是代数运算符符号，例如
    <SPLITINLINE>
      (如+)
      <JAVASCRIPT>(如&quot;+&quot;)</JAVASCRIPT>
    </SPLITINLINE>
    ，执行的操作是
     <SCHEMEINLINE>deriv</SCHEMEINLINE> . 我们可以通过重写基本导数<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>为数据导向风格来转换这个程序
     <SNIPPET EVAL="no">
      <INDEX><DECLARATION>deriv</DECLARATION> (symbolic)<SUBINDEX>data-directed</SUBINDEX><FRAGILE></FRAGILE></INDEX>
      <NAME>deriv_generic</NAME>
      <REQUIRES>is_variable</REQUIRES>
      <REQUIRES>is_same_variable</REQUIRES>
      <EXAMPLE>deriv_x_example</EXAMPLE>
      <SCHEME>
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get &apos;deriv (operator exp)) (operands exp)
                                           var))))

(define (operator exp) (car exp))

(define (operands exp) (cdr exp))
      </SCHEME>
      <JAVASCRIPT>
function deriv(exp, variable) {
    return is_number(exp)
           ? 0
           : is_variable(exp)
           ? is_same_variable(exp, variable) ? 1 : 0
           : get(&quot;deriv&quot;, operator(exp))(operands(exp), variable);
}
function operator(exp) { return head(exp); }
<SHORT_SPACE></SHORT_SPACE>
function operands(exp) { return tail(exp); }
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>deriv_x_example</NAME>
      <SCHEME>
(deriv &apos;(+ x 3) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
(+ 1 0)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(&quot;x&quot;, &quot;x&quot;);
// 1
      </JAVASCRIPT>
    </SNIPPET>
     <OL>
      <LI>
	解释上面所做的事情。为什么我们不能将谓词
	<SPLITINLINE>
	  number?
	  <JAVASCRIPT><JAVASCRIPTINLINE>is_number</JAVASCRIPTINLINE>
	</JAVASCRIPT></SPLITINLINE>
	和
	<SPLITINLINE>
	  variable?
	  <JAVASCRIPT><JAVASCRIPTINLINE>is_variable</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	并入数据导向分派中？
      </LI>
      <LI>
	编写求和及乘积导数的
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	，以及将它们安装到上述程序使用的表中的辅助代码。
      </LI>
      <LI>
	选择任何你喜欢的额外微分规则，例如指数规则（练习<SPACE></SPACE><REF NAME="ex:deriv-exponentiation"></REF>），并将它安装到这个数据导向系统中。
      </LI>
      <LI>
	在这个简单的代数操纵器中，表达式的类型是将它结合在一起的代数运算符。然而，假设我们以相反的方式索引
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	，这样在deriv中的分派行看起来像
	
          
((get (operator exp) &apos;deriv) (operands exp) var)
          
          <JAVASCRIPT>
get(operator(exp), &quot;deriv&quot;)(operands(exp), variable);
          </JAVASCRIPT>
	
	对导数系统有哪些相应的更改是必需的？
      </LI>
    </OL>
     <LABEL NAME="ex:data-directed-differentiation"></LABEL>
    <SOLUTION>
      <OL>
         <LI>
          <EM>解释上面所做的事情。为什么我们不能将谓词
	  <SPLITINLINE>
	    number?
	    <JAVASCRIPT><JAVASCRIPTINLINE>is_number</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>
	  和
	  <SPLITINLINE>
	    same-variable?
	    <JAVASCRIPT><JAVASCRIPTINLINE>is_same_variable</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>并入数据导向分派中？</EM>
	  <P></P>
	  运算符符号非常方便地作为操作符表中的<QUOTE>类型</QUOTE>键。对于数字和变量，尽管我们可以为这些类型的表达式引入名称，如果我们改变表达式作为列表的表示方式，会没有如此明显的键。
        </LI>
	 <LI>
           <EM>编写求和及乘积导数的
          <SPLITINLINE>
	    过程
	    <JAVASCRIPT>函数</JAVASCRIPT>
	  </SPLITINLINE>
          以及将它们安装到上述程序使用的表中的辅助代码。</EM>
	  <P></P>
	   <SNIPPET CHAP="4">
	    <NAME>deriv_generic_sum_product</NAME>
	    <REQUIRES>deriv_generic</REQUIRES>
	    <REQUIRES>deriv_generic_data</REQUIRES>
	    <REQUIRES>operation_table_from_chapter_3</REQUIRES>
	    <REQUIRES>operation_table</REQUIRES>
	    <EXAMPLE>deriv_xyx3_generic_example</EXAMPLE>
	    <EXPECTED>[ &apos;*&apos;, [ &apos;x&apos;, [ &apos;y&apos;, null ] ] ]</EXPECTED>
	    <SCHEME>
(define (deriv-sum exp var) 
  (make-sum (deriv (addend exp) var)
            (deriv (augend exp) var)))
 
(define (deriv-product exp var) 
  (make-sum (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
 
(define (install-deriv)
  (put &apos;deriv &apos;+ deriv-sum)
  (put &apos;deriv &apos;* deriv-product)
  &apos;done)
            </SCHEME>
	    <JAVASCRIPT>
function deriv_sum(operands, variable) {		
    return make_sum(deriv(addend(operands), variable),
                    deriv(augend(operands), variable));
}
function deriv_product(operands, variable) {
    return make_sum(make_product(multiplier(operands),
                        deriv(multiplicand(operands),
                              variable)),
                    make_product(deriv(multiplier(
                                             operands),
                                       variable),
                        multiplicand(operands)));
}
function install_deriv() {
    put(&quot;deriv&quot;, &quot;+&quot;, deriv_sum);
    put(&quot;deriv&quot;, &quot;*&quot;, deriv_product);
    return &quot;done&quot;;
}
install_deriv();    
	    </JAVASCRIPT>
	  </SNIPPET>
	  <SNIPPET HIDE="yes">
	    <NAME>deriv_generic_data</NAME>
	    <JAVASCRIPT>
function make_sum(a1, a2) {
    return list(&quot;+&quot;, a1, a2);
}
            
function make_product(m1, m2) {
    return list(&quot;*&quot;, m1, m2);
}
            
function addend(operands) {
    return head(operands);
}
            
function augend(operands) {
    return head(tail(operands));
}
            
function multiplier(operands) {
    return head(operands);
}
            
function multiplicand(operands) {
    return head(tail(operands));
}
	    </JAVASCRIPT>
	  </SNIPPET>
	  <SNIPPET HIDE="yes">
            <NAME>deriv_xyx3_generic_example</NAME>
            <SCHEME>
(deriv &apos;(* (* x y) (+ x 3)) &apos;x)
            </SCHEME>
            <SCHEMEOUTPUT>
(+ (* (* x y) (+ 1 0))
(* (+ (* x 0) (* 1 y))
(+  x 3)))
            </SCHEMEOUTPUT>
            <JAVASCRIPT>
deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;);
// [ &quot;+&quot;,
//   [[&quot;*&quot;, [[&quot;*&quot;, [&quot;x&quot;, [&quot;y&quot;, null]]], 
//           [[&quot;+&quot;, [1, [0, null]]], null]]],
//    [[&quot;*&quot;,
//      [[&quot;+&quot;,
//        [[&quot;*&quot;, [&quot;x&quot;, [0, null]]], 
//         [[&quot;*&quot;, [1, [&quot;y&quot;, null]]], null]]],
//         [[&quot;+&quot;, [&quot;x&quot;, [3, null]]], null] ] ],
//     null ]]]
            </JAVASCRIPT>
            <JAVASCRIPT_TEST>
head(tail(head(tail(deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;)))));
	    </JAVASCRIPT_TEST>
	  </SNIPPET>
	</LI>
        <LI>
	   <EM>
            选择任何你喜欢的额外微分规则，例如指数的规则（练习<SPACE></SPACE><REF NAME="ex:deriv-exponentiation"></REF>），并将其安装到这个数据导向系统中。
	  </EM>
	  <P></P>
	   <SNIPPET HIDE="yes">
	    <NAME>deriv_expo_data</NAME>
	    <JAVASCRIPT>
function make_exponentiation(base, exp) {
    return list(&quot;**&quot;, base, exp);
}
function base(operands) {
    return head(operands);
}
function exponent(operands) {
    return head(tail(operands));
}
	    </JAVASCRIPT>
	  </SNIPPET>
	  <SNIPPET HIDE="yes">
	    <NAME>example_deriv_expo_generic</NAME>
	    <JAVASCRIPT>
deriv(list(&quot;**&quot;, &quot;x&quot;, 4), &quot;x&quot;);
	    </JAVASCRIPT>
	    <JAVASCRIPT_TEST>
head(tail(head(tail(head(tail(tail(deriv(list(&quot;**&quot;, &quot;x&quot;, 4), &quot;x&quot;))))))));
	    </JAVASCRIPT_TEST>
	    <SCHEME>
	    </SCHEME>
	  </SNIPPET>
	  <SNIPPET CHAP="4">
	    <NAME>deriv_expo_put_it_all_together</NAME>
	    <REQUIRES>deriv_generic</REQUIRES>
	    <REQUIRES>deriv_generic_data</REQUIRES>
	    <REQUIRES>deriv_expo_data</REQUIRES>
	    <REQUIRES>operation_table_from_chapter_3</REQUIRES>
	    <REQUIRES>operation_table</REQUIRES>
	    <EXAMPLE>example_deriv_expo_generic</EXAMPLE>
	    <EXPECTED>&apos;x&apos;</EXPECTED>
	    <SCHEME>
(define (deriv-exponentiation expr var)
  (let ((base (base expr))
        (exponent (exponent expr)))
    (make-product exponent
                  (make-product (make-exponentiation base (make-sum exponent -1))
                                (deriv base var)))))
 
(define (install-exponentiation-extension)
  (put &apos;deriv &apos;** deriv-exponentiation)
  &apos;done)
            </SCHEME>
	    <JAVASCRIPT>
function deriv_exponentiation(operands, variable) {		
    const bas = base(operands);
    const exp = exponent(operands);
    return make_product(exp,
               make_product(make_exponentiation(bas, make_sum(exp, -1)),
	                    deriv(bas, variable)));
}
function install_exponentiation_extension() {
    put(&quot;deriv&quot;, &quot;**&quot;, deriv_exponentiation);
    return &quot;done&quot;;
}
install_exponentiation_extension();
	    </JAVASCRIPT>
	  </SNIPPET>

        </LI>
         <LI>
	  <EM>
            在这个简单的代数操作器中，表达式的类型是将其结合在一起的代数运算符。然而，假设我们以相反的方式索引
            <SPLITINLINE>
	      过程
	      <JAVASCRIPT>函数</JAVASCRIPT>
	    </SPLITINLINE>
            ，这样deriv中的分派行看起来像
            
              
((get (operator exp) &apos;deriv) (operands exp) var)
              
              <JAVASCRIPT>
get(operator(exp), &quot;deriv&quot;)(operands(exp), variable);
              </JAVASCRIPT>
            
            对导数系统有哪些相应的更改是必需的？
	  </EM>
	  <P></P>
	  我们需要更改微分库安装过程中的参数顺序：
	  
	    
(put &apos;+ &apos;deriv deriv-sum )
(put &apos;* &apos;deriv deriv-product)	    
(put &apos;** &apos;deriv deriv-exponentiation)
            
	    <JAVASCRIPT>
put(&quot;+&quot;, &quot;deriv&quot;, deriv_sum);
put(&quot;*&quot;, &quot;deriv&quot;, deriv_product);
put(&quot;**&quot;, &quot;deriv&quot;, deriv_exponentiation);
	    </JAVASCRIPT>
	  
        </LI>
       </OL>
    </SOLUTION>
  </EXERCISE>
  <EXERCISE> 
    Insatiable<INDEX>数据库<SUBINDEX>Insatiable Enterprises 公司人事</SUBINDEX></INDEX> Enterprises, Inc., 是一个高度分散的集团公司，由位于世界各地的大量独立部门组成。该公司的计算机设施刚刚通过一个巧妙的网络接口方案互连，使得整个网络对任何用户而言看似为一台单一计算机。Insatiable 的总裁在首次尝试利用网络从各部门文件中提取管理信息时，却发现虽然所有部门文件都被实现为<SPLITINLINE>
      
	Scheme,
      
      <JAVASCRIPT>
	JavaScript,
      </JAVASCRIPT>
    </SPLITINLINE>数据结构，但每个部门使用的具体数据结构却不尽相同。各部门经理紧急召开会议，以寻找一种既能满足总部需求又能保持各部门现有自治性的策略来整合文件。
    <P></P>
    <DO_BREAK_PAGE></DO_BREAK_PAGE>
    显示如何用<INDEX>数据库<SUBINDEX>数据导向编程</SUBINDEX></INDEX>数据导向编程实现这种策略。作为示例，假设每个部门的人事记录包含一个文件，里面有以员工姓名为关键字的一组记录。集合的结构因部门而异。此外，每个员工的记录本身也是一个集合（在各部门间的结构不同），其中包含的信息以诸如标识符为关键字。
     <SCHEMEINLINE>address</SCHEMEINLINE> 和
     <SCHEMEINLINE>salary</SCHEMEINLINE> 。尤其是：
     <OL>
      <LI> 
    为总部实现一个
	<SPLITINLINE>
	  get-record
	  <JAVASCRIPT><JAVASCRIPTINLINE>get_record</JAVASCRIPTINLINE>
	</JAVASCRIPT></SPLITINLINE>
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
    ，该过程可以从指定的人事文件中检索特定员工的记录。
    <SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
    应适用于任何部门的文件。解释个别部门的文件应该如何结构化。特别是，必须提供什么类型的信息？
     </LI>
      <LI> 
    为总部实现一个
	<SPLITINLINE>
	  get-salary
	  <JAVASCRIPT><JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE>
	</JAVASCRIPT></SPLITINLINE>
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
    ，该过程可以从任何部门的人事文件中返回特定员工记录的薪资信息。为了使该操作正常工作，记录应该如何结构化？
     </LI>
      <LI> 
    为总部实现一个
	<SPLITINLINE>
	  find-employee-record
	  <JAVASCRIPT><JAVASCRIPTINLINE>find_employee_record</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	<SPLITINLINE>
	  过程。
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
    该过程应搜索所有部门的文件以找到给定员工的记录并返回该记录。假设这个
    <SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
    的参数是员工的姓名和所有部门文件的列表。
     </LI>
       <LI>
        当 Insatiable 收购一家新公司时，为了将新的人员信息纳入中央系统，必须进行哪些更改？
      </LI>
     </OL>
    <SOLUTION>
      <OL>
         <LI>
          <EM>为总部实现一个
	  <SPLITINLINE>
	    get-record
	    <JAVASCRIPT><JAVASCRIPTINLINE>get_record</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>
          <SPLITINLINE>
	    过程
	    <JAVASCRIPT>函数</JAVASCRIPT>
	  </SPLITINLINE>
          ，该过程可以从指定的人事文件中检索特定员工的记录。
          <SPLITINLINE>
	    过程
	    <JAVASCRIPT>函数</JAVASCRIPT>
	  </SPLITINLINE>
          应适用于任何部门的文件。解释个别部门的文件应该如何结构化。特别是，必须提供什么类型的信息？</EM>
	  <P></P>
	  我们正在使用一个在<REF NAME="sec:manifest-types"></REF>段中标记的函数，为每个部门的文件标记一个唯一标识符。我们假设每个部门都提供了一个<JAVASCRIPTINLINE>get_record</JAVASCRIPTINLINE>函数的实现，并将其安装在公司范围的操作表中。
	  
	    <JAVASCRIPT>
function make_insatiable_file(division, file) {
    return pair(division, file);
}
function insatiable_file_division(insatiable_file) {
    return head(insatiable_file);
}
function insatiable_file_content(insatiable_file) {
    return tail(insatiable_file);
}
function get_record(employee_name, insatiable_file) {
    const the_division 
        = insatiable_file_division(insatiable_file);
    const division_record = get(&quot;get_record&quot;, the_division)
                            (employee_name, 
                             insatiable_file_content(
                                 insatiable_file));
    return ! is_undefined(record)
           ? attach_tag(the_division, division_record)
           : undefined;
}
	    </JAVASCRIPT>
	  
        </LI>
          <LI>
          <EM>为总部实现一个
	  <SPLITINLINE>
	    get-salary
	    <JAVASCRIPT><JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>
          <SPLITINLINE>
	    过程
	    <JAVASCRIPT>函数</JAVASCRIPT>
	  </SPLITINLINE>
          ，该过程可以从任何部门的人事文件中返回特定员工记录的薪水信息。为了使该操作正常工作，记录应该如何结构化？</EM>
	  <P></P>
	  每个部门都需要实现诸如<JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE>的函数，并将它们安装在Insatiable的操作表中。然后，Insatiable的函数<JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE>可以像这样：
	  
	    <JAVASCRIPT>
function make_insatiable_record(division, record) {
    return pair(division, record);
}
function insatiable_record_division(insatiable_record) {
    return head(insatiable_record);
}
function insatiable_record_content(insatiable_record) {
    return tail(insatiable_record);
}
function get_salary(insatiable_record) {
    const the_division = 
        insatiable_record_division(insatiable_record);
    return get(&quot;get_salary&quot;, the_division)
           (insatiable_record_content);
}
	    </JAVASCRIPT>
	  
	  请注意，我们依赖于<JAVASCRIPTINLINE>get_record</JAVASCRIPTINLINE>返回的任何员工记录都与其部门标签相关，这被用于通用函数<JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE>中，以便从操作表中检索正确的实现。
        </LI>
          <LI>
          <EM>
	    为总部实现一个
	    <SPLITINLINE>
	      find-employee-record
	    <JAVASCRIPT><JAVASCRIPTINLINE>find_employee_record</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
            <SPLITINLINE>
	      过程。
	      <JAVASCRIPT>函数。</JAVASCRIPT>
	    </SPLITINLINE>
            该过程应搜索所有部门的文件以找到给定员工的记录并返回该记录。假设这个
            <SPLITINLINE>过程
	    <JAVASCRIPT>函数</JAVASCRIPT>
	    </SPLITINLINE>
            的参数是员工的姓名和所有部门文件的列表。
	  </EM>
	  
	    <JAVASCRIPT>
function find_employee_record(employee_name, 
                              personnel_files) {
    if (is_null(personnel_files)) {
        return undefined;
    } else {
        const insatiable_record 
            = get_record(employee_name,
                         head(personnel_files));
        return ! is_undefined(insatiable_record)
               ? insatiable_record
               : find_employee_record(employee_name, 
                                      tail(personnel_files));
    }
}
	    </JAVASCRIPT>
	  
        </LI>
          <LI>
          <EM>
	    当 Insatiable 收购一家新公司时，为了将新的人员信息纳入中央
            系统，必须进行哪些更改？
	  </EM>
	  <P></P>
	  我们需要为每个新收购的公司做以下事情：
	  <UL>
	    <LI>
	      确定一个名称作为与新部门有关的任何数据项的标签。
	    </LI>
	    <LI>
	      编写所有特定于部门的函数，例如
	      <JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE>
	      并使用部门标签将它们安装在公司范围的操作表中。
	    </LI>
	    <LI>
	      将员工文件添加到
	      <JAVASCRIPTINLINE>personnel_files</JAVASCRIPTINLINE>列表中。
	      请注意，这是一个<QUOTE>破坏性</QUOTE>操作<EMDASH></EMDASH>类似于操作表的扩展<EMDASH></EMDASH>在于数据结构被永久地和不可逆转地修改; 详见<REF NAME="sec:mutable-data"></REF>段。
	    </LI>
	  </UL>
        </LI>
       </OL>
    </SOLUTION>
    <LABEL NAME="ex:2_74"></LABEL>
  </EXERCISE>
   <INDEX>数据导向编程<CLOSE></CLOSE></INDEX> 
   <INDEX>可加性<CLOSE></CLOSE></INDEX> 

   <SUBHEADING>
    <NAME>消息传递</NAME>
  </SUBHEADING> 

   <INDEX>消息传递<OPEN></OPEN></INDEX> 

   <TEXT>
    数据导向编程的关键思想是通过处理显式的操作与类型表（例如
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:operator-table_scheme"></REF>中的表）
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:operator-table"></REF>中的表）。
      </JAVASCRIPT>
    </SPLITINLINE>来在程序中处理通用操作。在
    <REF NAME="sec:manifest-types"></REF>节中，我们使用的编程风格是通过让每个操作处理自己的分派来组织所需的类型分派。实际上，这将操作与类型表分解为行，每个通用操作<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>表示表的一行。
  </TEXT> 
  <TEXT> 
    一种替代的实现策略是将表分解为列，与其使用基于数据类型的<QUOTE>智能操作</QUOTE>，不如使用基于操作名称的<QUOTE>智能数据对象</QUOTE>。我们可以通过安排这样一种方式来实现，例如让一个数据对象（如直角坐标数）被表示为一个<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>，该过程（或函数）将所需的操作名称作为输入并执行所指示的操作。在这种规则中，
    <SPLITINLINE>
      make-from-real-imag
      <JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>可以写成
     <SNIPPET CHAP="3">
      <INDEX><DECLARATION>make_from_real_imag</DECLARATION><SUBINDEX>message-passing</SUBINDEX></INDEX>
      <NAME>make_from_real_imag_message_passing</NAME>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>message_passing_example</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      <SCHEME>
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op &apos;real-part) x)
          ((eq? op &apos;imag-part) y)
          ((eq? op &apos;magnitude)
            (sqrt (+ (square x) (square y))))
          ((eq? op &apos;angle) (atan y x))
          (else
            (error &quot;Unknown op -- MAKE-FROM-REAL-IMAG&quot; op))))
  dispatch)
      </SCHEME>
      <JAVASCRIPT>
function make_from_real_imag(x, y) {
    function dispatch(op) {
        return op === &quot;real_part&quot;
               ? x
               : op === &quot;imag_part&quot;
               ? y
               : op === &quot;magnitude&quot;
               ? math_sqrt(square(x) + square(y))
               : op === &quot;angle&quot;
               ? math_atan2(y, x)
               : error(op, &quot;unknown op -- make_from_real_imag&quot;);
    }
    return dispatch;
}
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
function make_from_real_imag(x, y) {
    function dispatch(op) {
        return op === &quot;real_part&quot;
               ? x
               : op === &quot;imag_part&quot;
               ? y
               : op === &quot;magnitude&quot;
               ? math_sqrt(square(x) + square(y))
               : op === &quot;angle&quot;
               ? math_atan2(y, x)
               : error(op, &quot;unknown op -- make_from_real_imag&quot;);
    }
    return dispatch;
}
    
function make_from_mag_ang(r, a) {
    function dispatch(op) {
        return op === &quot;real_part&quot;
               ? r * math_cos(a)
               : op === &quot;imag_part&quot;
               ? r * math_sin(a)
               : op === &quot;magnitude&quot;
               ? r
               : op === &quot;angle&quot;
               ? a
               : error(op, &quot;unknown op -- make_from_real_imag&quot;);
    }
    return dispatch;
}
    
function apply_generic(op, arg) {
    return head(arg)(op);
}
function real_part(z) {
   return apply_generic(&quot;real_part&quot;, list(z));
}
function imag_part(z) {
   return apply_generic(&quot;imag_part&quot;, list(z));
}
function magnitude(z) {
   return apply_generic(&quot;magnitude&quot;, list(z));
}
function angle(z) {
   return apply_generic(&quot;angle&quot;, list(z));
}
function add_complex(z1, z2) {
    return make_from_real_imag(
               real_part(z1) + real_part(z2),
               imag_part(z1) + imag_part(z2));
}
function sub_complex(z1, z2) {
    return make_from_real_imag(
               real_part(z1) - real_part(z2),
               imag_part(z1) - imag_part(z2));
}
function mul_complex(z1, z2) {
    return make_from_mag_ang(
               magnitude(z1) * magnitude(z2),
               angle(z1) + angle(z2));
}
function div_complex(z1, z2) {
    return make_from_mag_ang(
               magnitude(z1) / magnitude(z2),
               angle(z1) - angle(z2));
}
// operation_table, put and get
// from chapter 3 (section 3.3.3)
function assoc(key, records) {
    return is_null(records)
           ? undefined
           : equal(key, head(head(records)))
           ? head(records)
           : assoc(key, tail(records));
}
function make_table() {
    const local_table = list(&quot;*table*&quot;);
    function lookup(key_1, key_2) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            return undefined;
        } else {
            const record = assoc(key_2, tail(subtable));
            return is_undefined(record)
                   ? undefined
                   : tail(record);
        }
    }
    function insert(key_1, key_2, value) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            set_tail(local_table,
                     pair(list(key_1, pair(key_2, value)),
                          tail(local_table)));
        } else {
            const record = assoc(key_2, tail(subtable));
            if (is_undefined(record)) {
      	        set_tail(subtable,
	                       pair(pair(key_2, value),
                              tail(subtable)));
	    } else {
                set_tail(record, value);
            }
        }
    }
    function dispatch(m) {
        return m === &quot;lookup&quot;
               ? lookup
               : m === &quot;insert&quot;
               ? insert
               : &quot;undefined operation -- table&quot;;
    }
    return dispatch;
}
const operation_table = make_table();
const get = operation_table(&quot;lookup&quot;);
const put = operation_table(&quot;insert&quot;);
function attach_tag(type_tag, contents) {
    return pair(type_tag, contents);
}
function type_tag(datum) {
    return is_pair(datum)
           ? head(datum)
           : error(datum, &quot;bad tagged datum -- type_tag&quot;);
}
function contents(datum) {
    return is_pair(datum)
           ? tail(datum)
           : error(datum, &quot;bad tagged datum -- contents&quot;);
}
function install_rectangular_package() {
    function real_part(z) { return head(z); }
    function imag_part(z) { return tail(z); }
    function make_from_real_imag(x, y) { return pair(x, y); }
    function magnitude(z) {
        return math_sqrt(square(real_part(z)) +
                   square(imag_part(z)));
    }
    function angle(z) {
        return math_atan2(imag_part(z), real_part(z));
    }
    function make_from_mag_ang(r, a) {
        return pair(r * math_cos(a), r * math_sin(a));
    }
    // interface to the rest of the system
    function tag(x) {
        return attach_tag(&quot;rectangular&quot;, x);
    }
    put(&quot;real_part&quot;, list(&quot;rectangular&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;rectangular&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;rectangular&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;rectangular&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;rectangular&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}

install_rectangular_package();
function install_polar_package() {
    // internal functions
    function magnitude(z) { return head(z); }
    function angle(z) { return tail(z); }
    function make_from_mag_ang(r, a) { return pair(r, a); }
    function real_part(z) {
       return magnitude(z) * math_cos(angle(z));
    }
    function imag_part(z) {
       return magnitude(z) * math_sin(angle(z));
    }
    function make_from_real_imag(x, y) {
       return pair(math_sqrt(square(x) + square(y)),
                   math_atan2(y, x));
    }

    // interface to the rest of the system
    function tag(x) { return attach_tag(&quot;polar&quot;, x); }
    put(&quot;real_part&quot;, list(&quot;polar&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;polar&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;polar&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;polar&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;polar&quot;, 
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;polar&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}

install_polar_package();	
      </JAVASCRIPT_RUN>
    </SNIPPET> 
    相应的<SPLITINLINE>
      apply-generic
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程,
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    应用通用操作到一个参数时，现在简单地将操作名传递给数据对象并让对象完成工作：<FOOTNOTE>这种组织的一个限制是它只允许单参数通用<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>。</FOOTNOTE>
     <SNIPPET CHAP="3">
      <INDEX><DECLARATION>apply_generic</DECLARATION><SUBINDEX>with message passing</SUBINDEX></INDEX>
      <NAME>apply_generic_message_passing</NAME>
      <REQUIRES>make_from_real_imag_message_passing</REQUIRES>
      <EXAMPLE>message_passing_example</EXAMPLE>
      <SCHEME>
(define (apply-generic op arg) (arg op))
      </SCHEME>
      <JAVASCRIPT>
function apply_generic(op, arg) { return head(arg)(op); }
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>message_passing_example</NAME>
      <JAVASCRIPT>
const my_complex_number = 
    make_from_real_imag(1.0, 4.5);

const result = 
    add_complex(my_complex_number,
                my_complex_number);

imag_part(result);		
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4" HIDE="yes">
      <NAME>generic_selectors_message_passing</NAME>
      <REQUIRES>apply_generic_message_passing</REQUIRES>
      <EXAMPLE>generic_selectors_example</EXAMPLE>
      <SCHEME>
(define (real-part z) (apply-generic &apos;real-part z))
(define (imag-part z) (apply-generic &apos;imag-part z))
(define (magnitude z) (apply-generic &apos;magnitude z))
(define (angle z) (apply-generic &apos;angle z))
      </SCHEME>
      <JAVASCRIPT>
function real_part(z) {
   return apply_generic(&quot;real_part&quot;, list(z));
}
function imag_part(z) {
   return apply_generic(&quot;imag_part&quot;, list(z));
}
function magnitude(z) {
   return apply_generic(&quot;magnitude&quot;, list(z));
}
function angle(z) {
   return apply_generic(&quot;angle&quot;, list(z));
}
      </JAVASCRIPT>
    </SNIPPET> 
    注意
    <SPLITINLINE>
      make-from-real-imag
      <JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    返回的值是一个
    <SPLITINLINE>
      过程<EMDASH></EMDASH>内部
      <JAVASCRIPT>函数<EMDASH></EMDASH>内部</JAVASCRIPT>
    </SPLITINLINE>
     <SCHEMEINLINE>dispatch</SCHEMEINLINE>
     <SPLITINLINE>
      过程。
      <JAVASCRIPT>函数。</JAVASCRIPT>
    </SPLITINLINE>
    这是当<SPLITINLINE>
      apply-generic
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>请求执行操作时被调用的<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
   </TEXT>
   <TEXT>
    这种编程风格被称为<EM>消息传递</EM>。这个名称来自于这样一个图象：一个数据对象是一个接收到所请求操作名称作为<QUOTE>消息</QUOTE>的实体。我们已经在<REF NAME="sec:data?"></REF>节中看到过一个消息传递的例子，在那里我们展示了如何用没有数据对象仅用
    <SPLITINLINE>
      cons,
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      car,
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    可以被定义为只有
    <SPLITINLINE>
      过程。
      <JAVASCRIPT>函数。</JAVASCRIPT>
    </SPLITINLINE>
    在这里我们看到消息传递不是一个数学技巧，而是一种组织通用操作系统的有用技术。在本章的剩余部分中，我们将继续使用数据导向编程，而非消息传递，来讨论通用算术操作。在<REF NAME="chap:state"></REF>中，我们将返回到消息传递，并且我们将看到它在结构化模拟程序中可以是一种强有力的工具。
  </TEXT> 

   <EXERCISE>
    实现构造器
     <INDEX><USE>make_from_mag_ang</USE><SUBINDEX>消息传递</SUBINDEX></INDEX>
    <SPLITINLINE>
      make-from-mag-ang
      <JAVASCRIPT><JAVASCRIPTINLINE>make_from_mag_ang</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    以消息传递风格。这个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    应当类似于上述给出的
    <SPLITINLINE>
      make-from-real-imag
      <JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程。
      <JAVASCRIPT>函数。</JAVASCRIPT>
    </SPLITINLINE>
    <SOLUTION>
      
	<NAME>make_from_mag_ang_message_passing</NAME>
	<REQUIRES>make_from_real_imag_message_passing</REQUIRES>
	<EXAMPLE>message_passing_example_2</EXAMPLE>
	<EXPECTED>4.589053123706931</EXPECTED>
        
        
        <JAVASCRIPT>
function make_from_mag_ang(r, a) {
    function dispatch(op) {
        return op === &quot;real_part&quot;
            ? r * math_cos(a)
            : op === &quot;imag_part&quot;
            ? r * math_sin(a)
            : op === &quot;magnitude&quot;
            ? r
            : op === &quot;angle&quot;
            ? a
            : error(op, &quot;unknown op -- make_from_real_imag&quot;);
    }
    return dispatch;
}
        </JAVASCRIPT>
	<JAVASCRIPT_RUN>
	</JAVASCRIPT_RUN>
      

      
	<NAME>message_passing_example_2</NAME>
	<JAVASCRIPT>
const my_complex_number = 
    make_from_mag_ang(3.0, 0.7);

const result = 
    add_complex(my_complex_number,
                my_complex_number);

real_part(result);		
	</JAVASCRIPT>
      
    </SOLUTION>
    
  </EXERCISE> 

   <EXERCISE>
    随着具有通用操作的大型系统的发展，可能需要新的数据对象类型或新的操作。对于三种策略中的每一种<EMDASH></EMDASH>具有显式<INDEX>分派<SUBINDEX>比较不同风格</SUBINDEX></INDEX>分派的通用操作、数据导向风格和消息传递风格<EMDASH></EMDASH>描述在系统中为了增加新类型或新操作而必须进行的更改。对于需要经常添加新类型的系统，哪种组织最合适？对于需要经常添加新操作的系统，哪种最合适？
    
    <SOLUTION>
      <UL>
	<LI>
	  <EM>具有显式分派的通用操作</EM>：对于每种新类型，我们需要触及每个通用接口函数，添加一个新案例。
	</LI>
	<LI>
	  <EM>数据导向风格</EM>：在这里，通用接口函数的实现可以简洁地打包在每个新类型的<QUOTE>安装</QUOTE>库中。我们也可以为新操作提供<QUOTE>安装</QUOTE>库。
	</LI>
	<LI>
	  <EM>消息传递风格</EM>：与数据导向风格类似，我们需要为每种新类型编写一个库。在这种情况下，库由一个分派函数组成，每个通用接口函数都有一个案例。
	</LI>
      </UL>
      总的来说，当我们需要频繁添加新操作时，使用数据导向风格是最好的，而在我们频繁添加新类型时，消息传递风格更为合适。
    </SOLUTION>
  </EXERCISE> 
</SUBSECTION>
