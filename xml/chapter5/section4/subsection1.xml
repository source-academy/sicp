<SUBSECTION>
  <NAME>
    The Core of the Explicit-Control Evaluator
  </NAME>

  <LABEL NAME="sec:eceval-core"/>
  <SPLITINLINE>
    <SCHEME>
      <INDEX>explicit-control evaluator for Scheme<SUBINDEX>controller<OPEN/></SUBINDEX></INDEX>
    </SCHEME>
    <JAVASCRIPT>
      <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>controller<OPEN/></SUBINDEX></INDEX>
    </JAVASCRIPT>
  </SPLITINLINE>

  <TEXT>
    The central element in the evaluator is the sequence of instructions
    beginning at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    This corresponds to the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of the metacircular evaluator described in
    section<SPACE/><REF NAME="sec:core-of-evaluator"/>.  When the controller
    starts at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    it evaluates the 
<SPLITINLINE><SCHEME>expression</SCHEME><JAVASCRIPT>component</JAVASCRIPT></SPLITINLINE>
 specified by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><SCHEMEINLINE>comp</SCHEMEINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in the environment specified by <SCHEMEINLINE>env</SCHEMEINLINE>.  When
    evaluation is complete, the controller will go to the entry point stored in
    <SCHEMEINLINE>continue</SCHEMEINLINE>, and the
    <SCHEMEINLINE>val</SCHEMEINLINE> register will hold the value of the
    <SPLITINLINE><SCHEME>expression.</SCHEME><JAVASCRIPT>component.</JAVASCRIPT></SPLITINLINE>
    As with the metacircular
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>eval</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    the structure of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is a case analysis on the syntactic type of the <SPLITINLINE><SCHEME>expression</SCHEME><JAVASCRIPT>component</JAVASCRIPT></SPLITINLINE> to be
    evaluated.<FOOTNOTE>In our controller, the dispatch is written as a
    sequence of <SCHEMEINLINE>test</SCHEMEINLINE> and
    <SCHEMEINLINE>branch</SCHEMEINLINE> instructions.  Alternatively,
    it could have been written in a data-directed style (and in a real
    system it probably would have been) to avoid the need to perform
    sequential tests and to facilitate the definition of new 
    <SPLITINLINE><SCHEME>expression</SCHEME><JAVASCRIPT>component</JAVASCRIPT></SPLITINLINE>
    types.
    <SPLITINLINE>
      <SCHEME>
        A machine designed to run Lisp would probably include a
        <SCHEMEINLINE>dispatch-on-type</SCHEMEINLINE> instruction
        that would efficiently execute such data-directed
        dispatches.
      </SCHEME>
      <JAVASCRIPT>
        Most common JavaScript implementations today do not interpret the
        JavaScript source code directly. Instead, source is transformed
        into an intermediate representation called <EM>bytecode</EM>, which is
        typically interpreted in a loop similar to our dispatch functions.
        Some JavaScript interpreters are register machines, like ours;
        others are stack machines, in which operations pop and push
        operands from and to a stack instead of keeping a large number of
        registers. For performance reasons, most JavaScript interpreters
        compile commonly executed parts of a program from bytecode to
        machine code. This is called Just-In-Time compilation (JIT). We
        will address compilation in section <REF NAME="sec:compilation"/>.
      </JAVASCRIPT>
    </SPLITINLINE>
  </FOOTNOTE>
  <INDEX><DECLARATION>eval_dispatch</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
eval-dispatch
(test (op self-evaluating?) (reg exp))
(branch (label ev-self-eval))
(test (op variable?) (reg exp))
(branch (label ev-variable))
(test (op quoted?) (reg exp))
(branch (label ev-quoted))
(test (op assignment?) (reg exp))
(branch (label ev-assignment))
(test (op definition?) (reg exp))
(branch (label ev-definition))
(test (op if?) (reg exp))
(branch (label ev-if))
(test (op lambda?) (reg exp))
(branch (label ev-lambda))
(test (op begin?) (reg exp))
(branch (label ev-begin))
(test (op application?) (reg exp))
(branch (label ev-application))
(goto (label unknown-expression-type))
      </SCHEME>
      <JAVASCRIPT>
"eval_dispatch",
      test(list(op("is_literal"), reg("comp"))),
      branch(label("ev_literal")),
      test(list(op("is_name"), reg("comp"))),
      branch(label("ev_name")),
      test(list(op("is_application"), reg("comp"))),
      branch(label("ev_application")),
      test(list(op("is_operator_combination"), reg("comp"))),
      branch(label("ev_operator_combination")),
      test(list(op("is_conditional"), reg("comp"))),
      branch(label("ev_conditional")),
      test(list(op("is_lambda_expression"), reg("comp"))),
      branch(label("ev_lambda")),
      test(list(op("is_sequence"), reg("comp"))),
      branch(label("ev_sequence_start")),
      test(list(op("is_block"), reg("comp"))),
      branch(label("ev_block")),
      test(list(op("is_return_statement"), reg("comp"))),
      branch(label("ev_return")),
      test(list(op("is_function_declaration"), reg("comp"))),
      branch(label("ev_function_declaration")),
      test(list(op("is_declaration"), reg("comp"))),
      branch(label("ev_declaration")),
      test(list(op("is_assignment"), reg("comp"))),
      branch(label("ev_assignment")),
      go_to(label("unknown_component_type")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Evaluating simple expressions</NAME>
  </SUBHEADING>

  <SPLITINLINE>
    <SCHEME>
      <INDEX>explicit-control evaluator for Scheme<SUBINDEX>expressions with no subexpressions to evaluate<OPEN/></SUBINDEX></INDEX>
    </SCHEME>
    <JAVASCRIPT>
      <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>expressions with no subexpressions to evaluate<OPEN/></SUBINDEX></INDEX>
    </JAVASCRIPT>
  </SPLITINLINE>

    <TEXT>
    Numbers and strings<SPLITINLINE><SCHEME> (which are self-evaluating)</SCHEME></SPLITINLINE>,
    <SPLITINLINE>
      <SCHEME>
	variables,
	quotations,
      </SCHEME>
      <JAVASCRIPT>
	names,
      </JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>
    expressions have no
    subexpressions to be evaluated.  For these, the evaluator simply
    places the correct value in the
    <SCHEMEINLINE>val</SCHEMEINLINE> register and continues
    execution at the entry point specified by
    <SCHEMEINLINE>continue</SCHEMEINLINE>.  Evaluation
    of simple expressions is performed by the following controller code:
    <INDEX><DECLARATION>ev_literal</DECLARATION></INDEX> 
    <INDEX><DECLARATION>ev_name</DECLARATION></INDEX> 
    <INDEX><DECLARATION>ev_lambda</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
ev-self-eval
(assign val (reg exp))
(goto (reg continue))
ev-variable
(assign val (op lookup-variable-value) (reg exp) (reg env))
(goto (reg continue))
ev-quoted
(assign val (op text-of-quotation) (reg exp))
(goto (reg continue))
ev-lambda
(assign unev (op lambda-parameters) (reg exp))
(assign exp (op lambda-body) (reg exp))
(assign val (op make-procedure)
(reg unev) (reg exp) (reg env))
(goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
"ev_literal",
      assign("val", list(op("literal_value"), reg("comp"))),
      go_to(reg("continue")),

"ev_name",
      assign("val", list(op("symbol_of_name"), reg("comp"), reg("env"))),
      assign("val", list(op("lookup_symbol_value"), reg("val"), reg("env"))),
      go_to(reg("continue")),
      
"ev_lambda",
      assign("unev", list(op("lambda_parameter_symbols"), reg("comp"))),
      assign("comp", list(op("lambda_body"), reg("comp"))),
      assign("val", list(op("make_function"),
                         reg("unev"), reg("comp"), reg("env"))),
      go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
    Observe how
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-lambda</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_lambda</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    uses the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>unev</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>unev</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    registers to hold the parameters and body of the lambda expression so
    that they can be passed to the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-procedure</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_function</JAVASCRIPTINLINE>
    </JAVASCRIPT></SPLITINLINE>
    operation, along with the environment in <SCHEMEINLINE>env</SCHEMEINLINE>.
    <SPLITINLINE>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme<SUBINDEX>expressions with no subexpressions to evaluate<CLOSE/></SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript<SUBINDEX>expressions with no subexpressions to evaluate<CLOSE/></SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <SUBHEADING> 
    <NAME>
      <SPLITINLINE>
        <SCHEME>Evaluating procedure applications</SCHEME>
        <JAVASCRIPT>Evaluating function applications and operator combinations</JAVASCRIPT>
      </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <SPLITINLINE>
    <SCHEME>
      <INDEX>explicit-control evaluator for Scheme<SUBINDEX>procedure application<OPEN/></SUBINDEX></INDEX>
      <INDEX>explicit-control evaluator for Scheme<SUBINDEX>combinations<OPEN/></SUBINDEX></INDEX>
    </SCHEME>
    <JAVASCRIPT>
      <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>function application<OPEN/></SUBINDEX></INDEX>
      <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>combinations<OPEN/></SUBINDEX></INDEX>
    </JAVASCRIPT>
  </SPLITINLINE>

  <TEXT>
    <SPLIT>
      <SCHEME>
	A procedure application is specified by a combination containing an
  <SPLITINLINE>
    <SCHEME>operator</SCHEME>
    <JAVASCRIPT>function expression</JAVASCRIPT>
  </SPLITINLINE>
  and
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>.
	The
  <SPLITINLINE>
    <SCHEME>operator</SCHEME>
    <JAVASCRIPT>function expression</JAVASCRIPT>
  </SPLITINLINE>
  is a subexpression whose value is a
	procedure, and the 
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
  are subexpressions whose values are the
	arguments to which the procedure
	should be applied.
      </SCHEME>
      <JAVASCRIPT>
	A function application is specified by a combination containing
	a function expression and argument expressions.
	The function expression is a subexpression whose value is a function,
	and the argument expressions are subexpressions whose values are the
	arguments to which the function
	should be applied.
      </JAVASCRIPT>
    </SPLIT>
    The metacircular
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    handles applications by calling itself recursively to
    evaluate each element of the combination, and then passing the results
    to <SCHEMEINLINE>apply</SCHEMEINLINE>, which performs the actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application.  The
    explicit-control evaluator does the same thing; these recursive calls
    are implemented by
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>goto</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>go_to</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    instructions, together with 
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>stack usage</SUBINDEX></INDEX>
    use of the stack to save registers that will be restored after the recursive
    call returns.  Before each call we will be careful to identify which
    registers must be saved (because their values will be needed
    later).<FOOTNOTE>This is an important but subtle point in translating
    algorithms from a procedural language, such as
    <SPLITINLINE>
      <SCHEME>Lisp,</SCHEME>
      <JAVASCRIPT>JavaScript,</JAVASCRIPT>
    </SPLITINLINE>
    to a register-machine language.  As an alternative to saving only what is
    needed, we could save all the registers (except
    <SCHEMEINLINE>val</SCHEMEINLINE>) before each recursive call.
    This is called a 
    <INDEX>framed-stack discipline</INDEX>
    <INDEX>stack<SUBINDEX>framed</SUBINDEX></INDEX>
    <EM>framed-stack</EM> discipline.  This
    would work but might save more registers than necessary; this could be
    an important consideration in a system where stack operations are
    expensive.  Saving registers whose contents will not be needed later
    may also hold on to useless data that could otherwise be
    garbage-collected, freeing space to be reused.</FOOTNOTE>
  </TEXT>

  <TEXT>
    As in the metacircular evaluator, operator combinations
    are transformed into applications of primitive functions
    corresponding to the operators. This takes place at <JAVASCRIPTINLINE>ev_operator_combination</JAVASCRIPTINLINE>,
    which performs this transformation in place in <JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE> and falls through to
    <JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>. 
  </TEXT>

  <TEXT>
    We begin the evaluation of an application by evaluating the
    <SPLITINLINE>
      <SCHEME>
	operator
      </SCHEME>
      <JAVASCRIPT>
	function expression
      </JAVASCRIPT>
    </SPLITINLINE>
    to produce a
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    which will later be applied to the evaluated
    <SPLITINLINE>
      <SCHEME>
	operands.
      </SCHEME>
      <JAVASCRIPT>
	argument expressions.
      </JAVASCRIPT>
    </SPLITINLINE>
    To evaluate the
    <SPLITINLINE>
      <SCHEME>
	operator,
      </SCHEME>
      <JAVASCRIPT>
	function expression,
      </JAVASCRIPT>
    </SPLITINLINE>
    we move it to the 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    register and go to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The environment in the <SCHEMEINLINE>env</SCHEMEINLINE> register is already
    the correct one in which to evaluate the
    <SPLITINLINE>
      <SCHEME>operator.</SCHEME>
      <JAVASCRIPT>function expression.</JAVASCRIPT>
    </SPLITINLINE>
    However, we save <SCHEMEINLINE>env</SCHEMEINLINE> because we will need it
    later to evaluate the
    <SPLITINLINE>
      <SCHEME>
	operands.
      </SCHEME>
      <JAVASCRIPT>
	argument expressions.
      </JAVASCRIPT>
    </SPLITINLINE>
    We also extract the
    <SPLITINLINE>
      <SCHEME>
	operands
      </SCHEME>
      <JAVASCRIPT>
	argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    into <SCHEMEINLINE>unev</SCHEMEINLINE> and save this on the stack.  We set
    up <SCHEMEINLINE>continue</SCHEMEINLINE> so that
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    will resume at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-appl-did-operator</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>ev_appl_did_function_expression</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    after the
    <SPLITINLINE>
      <SCHEME>
	operator
      </SCHEME>
      <JAVASCRIPT>
	function expression
      </JAVASCRIPT>
    </SPLITINLINE>
    has been evaluated.  First, however, we save the old value of
    <SCHEMEINLINE>continue</SCHEMEINLINE>, which tells the controller where to
    continue after the application.
    <INDEX><DECLARATION>ev_operator_combination</DECLARATION></INDEX> 
    <INDEX><DECLARATION>ev_application</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
ev-application
(save continue)
(save env)
(assign unev (op operands) (reg exp))
(save unev)
(assign exp (op operator) (reg exp))
(assign continue (label ev-appl-did-operator))
(goto (label eval-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_operator_combination",
      assign("comp", list(op("operator_combination_to_application"),
                          reg("comp"), reg("env"))),
"ev_application",
      save("continue"),
      save("env"),
      assign("unev", list(op("arg_expressions"), reg("comp"))),
      save("unev"),
      assign("comp", list(op("function_expression"), reg("comp"))),
      assign("continue", label("ev_appl_did_function_expression")),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme<SUBINDEX>operand evaluation<OPEN/></SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript<SUBINDEX>argument evaluation<OPEN/></SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    Upon returning from evaluating the
    <SPLITINLINE>
      <SCHEME>
	operator subexpression,
      </SCHEME>
      <JAVASCRIPT>
	function expression,
      </JAVASCRIPT>
    </SPLITINLINE>
    we proceed
    to evaluate the
    <SPLITINLINE>
      <SCHEME>
	operands
      </SCHEME>
      <JAVASCRIPT>
	argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    of the
    <SPLITINLINE>
      <SCHEME>combination</SCHEME>
      <JAVASCRIPT>application</JAVASCRIPT>
    </SPLITINLINE>
    and to accumulate the
    resulting arguments in a list, held in <SCHEMEINLINE>argl</SCHEMEINLINE>.
    First we restore the unevaluated
    <SPLITINLINE>
      <SCHEME>
	operands
      </SCHEME>
      <JAVASCRIPT>
	argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    and the environment.  We
    initialize <SCHEMEINLINE>argl</SCHEMEINLINE> to an empty list.  Then we
    assign to the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    register the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that was produced by evaluating the
    <SPLITINLINE>
      <SCHEME>
	operator.
      </SCHEME>
      <JAVASCRIPT>
	function expression.
      </JAVASCRIPT>
    </SPLITINLINE>
    If there are
    no
    <SPLITINLINE>
      <SCHEME>
	operands,
      </SCHEME>
      <JAVASCRIPT>
	argument expressions,
      </JAVASCRIPT>
    </SPLITINLINE>
    we go directly to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Otherwise we save
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    on the stack and start the argument-evaluation
    loop:<FOOTNOTE>We add to the evaluator data-structure
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in section<SPACE/><REF NAME="sec:eval-data-structures"/> the following two
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for manipulating argument lists:
    <INDEX><DECLARATION>empty_arglist</DECLARATION></INDEX> 
    <INDEX><DECLARATION>adjoin_arg</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>empty_arglist</NAME>
      <SCHEME>
(define (empty-arglist) '())

(define (adjoin-arg arg arglist)
  (append arglist (list arg)))
      </SCHEME>
      <JAVASCRIPT>
function empty_arglist() { return null; }

function adjoin_arg(arg, arglist) {
    return append(arglist, list(arg));
}
      </JAVASCRIPT>
    </SNIPPET>
    We also use an additional syntax
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to test for the last
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    in a combination:
    <INDEX><DECLARATION>is_last_argument_expression</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>is_last_argument_expression</NAME>
      <SCHEME>
(define (last-operand? ops)
(null? (cdr ops)))
      </SCHEME>
      <JAVASCRIPT>
function is_last_argument_expression(arg_expression) {
    return is_null(tail(arg_expression));
}
      </JAVASCRIPT>
    </SNIPPET>
  </FOOTNOTE>
  <SNIPPET EVAL="no">
    <SCHEME>
ev-appl-did-operator
(restore unev)                  ; the operands
(restore env)
(assign argl (op empty-arglist))
(assign proc (reg val))         ; the operator
(test (op no-operands?) (reg unev))
(branch (label apply-dispatch))
(save proc)
    </SCHEME>
    <JAVASCRIPT>
"ev_appl_did_function_expression",
      restore("unev"), // the argument expressions
      restore("env"),
      assign("argl", list(op("empty_arglist"))),
      assign("fun", reg("val")), // the function
      test(list(op("is_null"),
                reg("unev"))),
      branch(label("apply_dispatch")),
      save("fun"),
    </JAVASCRIPT>
  </SNIPPET>
  </TEXT>

  <TEXT>
    Each cycle of the argument-evaluation loop evaluates an 
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    from the list in <SCHEMEINLINE>unev</SCHEMEINLINE> and accumulates the
    result into <SCHEMEINLINE>argl</SCHEMEINLINE>. To evaluate an
  <SPLITINLINE>
    <SCHEME>operand,</SCHEME>
    <JAVASCRIPT>argument expression,</JAVASCRIPT>
  </SPLITINLINE>
    we place it in the 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    register and go to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    after setting <SCHEMEINLINE>continue</SCHEMEINLINE> so that execution will
    resume with the argument-accumulation phase.  But first we save the
    arguments accumulated so far (held in <SCHEMEINLINE>argl</SCHEMEINLINE>), the
    environment (held in <SCHEMEINLINE>env</SCHEMEINLINE>), and the remaining
    <SPLITINLINE>
      <SCHEME>operands</SCHEME>
      <JAVASCRIPT>argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    to be evaluated (held in <SCHEMEINLINE>unev</SCHEMEINLINE>).  A special case
    is made for the evaluation of the last
    <SPLITINLINE>
      <SCHEME>operand</SCHEME>
      <JAVASCRIPT>argument expression,</JAVASCRIPT>
    </SPLITINLINE>
    which is handled at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-appl-last-arg</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_appl_last_arg</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
ev-appl-operand-loop
(save argl)
(assign exp (op first-operand) (reg unev))
(test (op last-operand?) (reg unev))
(branch (label ev-appl-last-arg))
(save env)
(save unev)
(assign continue (label ev-appl-accumulate-arg))
(goto (label eval-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_appl_argument_expression_loop",
      save("argl"),
      assign("comp", list(op("head"), reg("unev"))),
      test(list(op("is_last_argument_expression"),
                reg("unev"))),
      branch(label("ev_appl_last_arg")),
      save("env"),
      save("unev"),
      assign("continue", label("ev_appl_accumulate_arg")),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    When an
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    has been evaluated, the value is accumulated into the list
    held in <SCHEMEINLINE>argl</SCHEMEINLINE>.  The
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    is then removed from
    the list of unevaluated
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
    in <SCHEMEINLINE>unev</SCHEMEINLINE>, and
    the argument-evaluation continues.
    <SNIPPET EVAL="no">
      <SCHEME>
ev-appl-accumulate-arg
(restore unev)
(restore env)
(restore argl)
(assign argl (op adjoin-arg) (reg val) (reg argl))
(assign unev (op rest-operands) (reg unev))
(goto (label ev-appl-operand-loop))
      </SCHEME>
      <JAVASCRIPT>
"ev_appl_accumulate_arg",
      restore("unev"),
      restore("env"),
      restore("argl"),
      assign("argl", list(op("adjoin_arg"),
                          reg("val"), reg("argl"))),
      assign("unev", list(op("tail"), reg("unev"))),
      go_to(label("ev_appl_argument_expression_loop")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Evaluation of the last argument <SPLITINLINE><JAVASCRIPT>expression</JAVASCRIPT></SPLITINLINE> is handled differently.  There is no
    need to save the environment or the list of unevaluated 
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
    before going to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    since they will not be required after the last
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    is evaluated.
    Thus, we return from the evaluation to a special entry point
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-appl-accum-last-arg</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_appl_accum_last_arg</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which restores the argument list, accumulates the new argument, restores the
    saved
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    and goes off to perform the application.<FOOTNOTE>The optimization of
    treating the last 
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    <INDEX>evlis tail recursion</INDEX>
    specially is known as <EM>evlis tail recursion</EM> (see 
    <INDEX>Wand, Mitchell</INDEX>
    <CITATION>Wand 1980</CITATION>). We could be somewhat more efficient
    in the argument evaluation loop if we made evaluation of the first
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    a special case too.  This would permit us to postpone
    initializing <SCHEMEINLINE>argl</SCHEMEINLINE> until after evaluating the
    first
    <SPLITINLINE>
      <SCHEME>
	operand,
      </SCHEME>
      <JAVASCRIPT>
	argument expression,
      </JAVASCRIPT>
    </SPLITINLINE>
    so
    as to avoid saving <SCHEMEINLINE>argl</SCHEMEINLINE> in this case.  The
    compiler in section<SPACE/><REF NAME="sec:compilation"/> performs this
    optimization.  (Compare the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>construct-arglist</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>construct_arglist</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of section<SPACE/><REF NAME="sec:compiling-combinations"/>.)</FOOTNOTE>
    <SNIPPET EVAL="no">
      <SCHEME>
ev-appl-last-arg
(assign continue (label ev-appl-accum-last-arg))
(goto (label eval-dispatch))
ev-appl-accum-last-arg
(restore argl)
(assign argl (op adjoin-arg) (reg val) (reg argl))
(restore proc)
(goto (label apply-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_appl_last_arg",
      assign("continue", label("ev_appl_accum_last_arg")),
      go_to(label("eval_dispatch")),
      
"ev_appl_accum_last_arg",
      restore("argl"),
      assign("argl", list(op("adjoin_arg"),
                          reg("val"), reg("argl"))),
      restore("fun"),
      go_to(label("apply_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>order of evaluation<SUBINDEX>in explicit-control evaluator</SUBINDEX></INDEX>
    The details of the argument-evaluation loop determine the order in
    which the interpreter evaluates the
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
    of a combination (e.g.,
    left to right or right to left<EMDASH/>see
    exercise<SPACE/><REF NAME="ex:order-of-evaluation"/>).  This order is not
    determined by the metacircular evaluator, which inherits its control
    structure from the underlying <SPLITINLINE><SCHEME>Scheme</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> in which it
    is implemented.<FOOTNOTE>
    <SPLIT>
      <SCHEME>
        The order of operand evaluation in the metacircular evaluator is
        determined by the order of evaluation of the arguments to
        <SCHEMEINLINE>cons</SCHEMEINLINE> in the procedure
        <SCHEMEINLINE>list-of-values</SCHEMEINLINE> of section<SPACE/><REF
        NAME="sec:core-of-evaluator"/> (see exercise<SPACE/><REF
        NAME="ex:arg-eval-order"/>).
      </SCHEME>
      <JAVASCRIPT>
        The order of argument-expression evaluation by the
        <JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE> in the metacircular
        evaluator is determined by the order of evaluation of the arguments to
        <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>, which is used to construct the
        argument list. The version of
        <JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE>
        in footnote<SPACE/><REF NAME="foot:mceval-higher-order"/> of section<SPACE/><REF
        NAME="sec:mc-eval"/> calls <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
        directly; the version in the text uses
        <JAVASCRIPTINLINE>map</JAVASCRIPTINLINE>, which calls
        <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLIT>
    </FOOTNOTE>
    
    <SPLITINLINE>
      <SCHEME>
        Because the <SCHEMEINLINE>first-operand</SCHEMEINLINE> selector (used in
        <SCHEMEINLINE>ev-appl-operand-loop</SCHEMEINLINE> to extract successive
        operands from <SCHEMEINLINE>unev</SCHEMEINLINE>) is implemented as
        <SCHEMEINLINE>car</SCHEMEINLINE> and the
        <SCHEMEINLINE>rest-operands</SCHEMEINLINE> selector is implemented as
        <SCHEMEINLINE>cdr</SCHEMEINLINE>, the explicit-control evaluator will
        evaluate the operands of a combination in left-to-right order.
      </SCHEME>
      <JAVASCRIPT>
        Because we use <JAVASCRIPTINLINE>head</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE> to extract successive operands
        from <JAVASCRIPTINLINE>unev</JAVASCRIPTINLINE> the explicit-control
        evaluator will evaluate the argument expressions of a combination in
        left-to-right order. 
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme<SUBINDEX>operand evaluation<CLOSE/></SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript<SUBINDEX>argument evaluation<CLOSE/></SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <SUBHEADING> 
    <NAME>
      <SPLITINLINE>
	<SCHEME>Procedure</SCHEME>
	<JAVASCRIPT>Function</JAVASCRIPT>
      </SPLITINLINE>
    application</NAME>
  </SUBHEADING>

  <LABEL NAME="sec:procedure-application"/>
  <TEXT>
    The entry point
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>apply-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    corresponds to the <SCHEMEINLINE>apply</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of the metacircular evaluator.  By the time we get to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    register contains the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to apply and <SCHEMEINLINE>argl</SCHEMEINLINE> contains the list of
    evaluated arguments to which it must be applied.  The saved value of
    <SCHEMEINLINE>continue</SCHEMEINLINE> (originally passed to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and saved at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-application</SCHEMEINLINE>),</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>),
      </JAVASCRIPT>
    </SPLITINLINE>
    which tells where to return with the result of the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application, is on the stack.  When the application is complete, the
    controller transfers to the entry point specified by the saved
    <SCHEMEINLINE>continue</SCHEMEINLINE>, with the result of the application in
    <SCHEMEINLINE>val</SCHEMEINLINE>.  As with the metacircular
    <SCHEMEINLINE>apply</SCHEMEINLINE>, there are two cases to consider.  Either
    the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to be applied is a primitive or it is a compound
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><DECLARATION>apply_dispatch</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
apply-dispatch
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-apply))
(test (op compound-procedure?) (reg proc))  
(branch (label compound-apply))
(goto (label unknown-procedure-type))
      </SCHEME>
      <JAVASCRIPT>
"apply_dispatch",
      test(list(op("is_primitive_function"), reg("fun"))),
      branch(label("primitive_apply")),
      test(list(op("is_compound_function"), reg("fun"))),
      branch(label("compound_apply")),
      go_to(label("unknown_function_type")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>primitive <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    We assume that each primitive is implemented so as to obtain its
    arguments from <SCHEMEINLINE>argl</SCHEMEINLINE> and place its result in
    <SCHEMEINLINE>val</SCHEMEINLINE>.  To specify how the machine handles
    primitives, we would have to provide a sequence of controller instructions
    to implement each primitive and arrange for
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>primitive-apply</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>primitive_apply</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to dispatch to the
    instructions for the primitive identified by the
    contents of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    Since we are interested in the structure of the evaluation process rather
    than the details of the primitives, we will instead just use an
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-primitive-procedure</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_primitive_function</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> operation
    that applies the
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    in 
    <SPLITINLINE><SCHEME>proc</SCHEME><JAVASCRIPT>fun</JAVASCRIPT></SPLITINLINE>
    to the arguments in <SCHEMEINLINE>argl</SCHEMEINLINE>.  For the purpose of simulating the evaluator with the simulator
    of section<SPACE/><REF NAME="sec:simulator"/> we use the
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-primitive-procedure</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_primitive_function</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which calls on the underlying
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    system to perform the application, just as we did for the metacircular
    evaluator in section<SPACE/><REF NAME="sec:running-eval"/>.  After computing
    the value of the primitive application, we restore
    <SCHEMEINLINE>continue</SCHEMEINLINE> and go
    to the designated entry point.
    <INDEX><DECLARATION>primitive_apply</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
primitive-apply
(assign val (op apply-primitive-procedure)
      (reg proc)
      (reg argl))
(restore continue)
(goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
"primitive_apply",
      assign("val", list(op("apply_primitive_function"), 
                         reg("fun"), 
                         reg("argl"))),
      restore("continue"),
      go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>compound <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>To apply a compound procedure, we proceed just as with</SCHEME>
      <JAVASCRIPT>
The sequence of instructions labeled
          <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> specifies the
          application of compound functions. To apply a compound
      function, we proceed in a way similar to what we did in</JAVASCRIPT>
    </SPLITINLINE>
    the metacircular evaluator.  We construct a frame
    that binds the
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s</SCHEME>
      <JAVASCRIPT>function<APOS/>s</JAVASCRIPT>
    </SPLITINLINE>
    parameters to the arguments, use this frame to extend the environment
    carried by the
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    and evaluate in this extended environment the sequence of
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    that forms the body of the
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function. </JAVASCRIPT>
    </SPLITINLINE>
    <SPLIT>
      <SCHEME>
        <SCHEMEINLINE>Ev-sequence</SCHEMEINLINE>, described below
        in section<SPACE/><REF NAME="sec:sequence-evaluation"/>,
        handles the evaluation of the sequence.
      </SCHEME>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>Compound-apply</SCHEMEINLINE> is the only
        place in the interpreter where the
        <SCHEMEINLINE>env</SCHEMEINLINE> register is ever assigned a
      new value.</SCHEME>
      <JAVASCRIPT>
	      The only places in the interpreter where the
	      <SCHEMEINLINE>env</SCHEMEINLINE> register is assigned a
	      new value are
	      <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> and
	      <JAVASCRIPTINLINE>ev_block</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    
    Just as in the metacircular evaluator, the new environment is constructed
    from the environment carried by the
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    together with the argument list and the corresponding list of
    <SPLITINLINE>
      <SCHEME>variables</SCHEME>
      <JAVASCRIPT>names</JAVASCRIPT>
    </SPLITINLINE>
    to be bound.
    <SPLITINLINE>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme<SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE> application<CLOSE/></SUBINDEX></INDEX>
	<INDEX>explicit-control evaluator for Scheme<SUBINDEX>combinations<CLOSE/></SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript<SUBINDEX>function application<CLOSE/></SUBINDEX></INDEX>
	<INDEX>explicit-control evaluator for JavaScript<SUBINDEX>combinations<CLOSE/></SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

      <JAVASCRIPT>
        <TEXT>
          Unlike primitive functions, compound
          functions use our stack as a temporary storage for register values.
          Careful management of the stack is essential for our explicit-control
          evaluator to be tail recursive, and to correctly implement return
          statements. Last, compound functions must also handle the implicit
          returning of <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> in lieu of
          a return through an explicit return statement. For primitive
          functions, these aspects were all handled for us by the underlying
          JavaScript engine.
      </TEXT>
      <TEXT>
        We will address these three problems together by introducing two new
        instructions for stack management, and two sequences of instructions labeled
        <JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE> for handing explicit
        returns and <JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE> for
        handling implicit returning of undefined. First, we explain the need 
        for the additional stack management
        instructions and how they are used during function calls and returns. 
        Then, we will explain implicit returning of undefined.
        The interaction with tail recursion will be explained in section<SPACE/><REF NAME="sec:tail-recursion-return"/>.
      </TEXT>
      <TEXT>
        Returning from a compound function should jump to the value of
        <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> at the time of the
        function call, which was stored on the stack at
        <JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>. Doing so requires
        that we restore the stack to its state at that moment in time by popping
        all subsequently saved values which are no longer needed. Such values
        may differ in number for different return statements and may be
        introduced in the evaluation of sequences of statements (explained
        shortly) which need temporary storage to process statements in a loop.
        To address this unknown variable,
        <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> pushes a special
        marker on the stack to indicate the top-value of the stack after
        function returns. For simplicity, we introduce a new instruction for pushing
        the marker: <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE>.<FOOTNOTE>
        This special instruction, and its counterpart
        <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE>, are not strictly
        necessary and could be implemented by explicitly pushing and popping a
        marker value to and off the stack. Any value that could not be confused
        for a value in the program can be used as a marker value. See exercises
        <REF NAME="ex:save_marker1"/> and <REF NAME="ex:save_marker2"/>.
      </FOOTNOTE>
      </TEXT>
      </JAVASCRIPT>
    </SPLIT>
    <INDEX><DECLARATION>compound_apply</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
compound-apply
(assign unev (op procedure-parameters) (reg proc))
(assign env (op procedure-environment) (reg proc))
(assign env (op extend-environment)
      (reg unev) (reg argl) (reg env))
(assign unev (op procedure-body) (reg proc))
(goto (label ev-sequence))
      </SCHEME>
      <JAVASCRIPT>
"compound_apply",
      assign("unev", list(op("function_parameters"), reg("fun"))),
      assign("env", list(op("function_environment"), reg("fun"))),
      assign("env", list(op("extend_environment"), 
                         reg("unev"), reg("argl"), reg("env"))),
      assign("comp", list(op("function_body"), reg("fun"))),
      save_marker(),
      assign("continue", label("return_undefined")),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

    <SPLIT>
      <JAVASCRIPT>
        <TEXT>
        When a return statement is evaluated at <JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE>,
        we use the <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE> instruction to restore the stack to its state at the beginning of the
        function call by popping all values from the stack down to and including
        the marker. 
        As a consequence, <JAVASCRIPTINLINE>restore("continue")</JAVASCRIPTINLINE>
        will restore the continuation of the function call. We can then proceed to
        evaluate the return expression, whose result will be placed in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>
        and thus be the value returned from the function when we continue after the dispatcher.
      </TEXT>

    <SNIPPET EVAL="no">
      <JAVASCRIPT>
"ev_return",
      restore_marker(),
      restore("continue"),
      assign("comp", list(op("return_expression"), reg("comp"))),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
      
      <TEXT>
        To ensure the undefined return value of a function that does not
        explicitly return via a return statement, we instruct <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE>
        to continue to <JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE> where
        <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> will be assigned to <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>.
        Because a function that ends with an explicit return will continue to
        the value of <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> <EM>before</EM> the
        <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE>, it will not execute
        these instructions, and keep its return value. To get rid of the marker
        on the stack, there is a <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE> command
        also in <JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE>.
      </TEXT>

    <SNIPPET EVAL="no">
      <JAVASCRIPT>
"return_undefined",
      restore_marker(),
      restore("continue"),
      assign("val", constant(undefined)),
      go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
   
      </JAVASCRIPT>
    </SPLIT>
  
  <SUBHEADING> 
    <NAME><SPLITINLINE><JAVASCRIPT>Blocks and </JAVASCRIPT></SPLITINLINE>Sequence Evaluation</NAME>
  </SUBHEADING>

  <LABEL NAME="sec:sequence-evaluation"/>
  <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>sequences of statements<OPEN/></SUBINDEX></INDEX>

  <SPLIT>
    <JAVASCRIPT>
      <TEXT>
        <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>declarations</SUBINDEX></INDEX>

        The body of a block is evaluated with
        respect to the current environment extended by a binding
        of all local names to the value
        <JAVASCRIPTINLINE>"*unassigned*"</JAVASCRIPTINLINE>.
        We temporarily make use of the <JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE>
        register to hold the list of all variables declared in the block,
        which is obtained by the function <JAVASCRIPTINLINE>scan_out_declarations</JAVASCRIPTINLINE>
        from section<SPACE/><REF NAME="sec:core-of-evaluator"/>.
        <INDEX>scanning out declarations<SUBINDEX>in register machine</SUBINDEX></INDEX>
    <SNIPPET EVAL="no">
      <JAVASCRIPT>
"ev_block",
      assign("comp", list(op("block_body"), reg("comp"))),
      assign("val", list(op("scan_out_declarations"), reg("comp"))),

      save("comp"), // temporarily use for *unassigned* values
      assign("comp", list(op("list_of_unassigned"), reg("val"))),
      assign("env", list(op("extend_environment"), 
                         reg("val"), 
                         reg("comp"), 
                         reg("env"))),
      restore("comp"),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>

      According to section<SPACE/><REF NAME="sec:representing-expressions"/>,
      all lambda expressions and functions have a block as their body. However,
      <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> does not jump to
      <JAVASCRIPTINLINE>ev_block</JAVASCRIPTINLINE> but to the dispatcher,
      seemingly an additional hoop. By deferring to the dispatcher rather than
      using a fixed label, we open up for more flexible parsing, such as
      foregoing blocks when there are no variable declarations (so no need to
      scan out declarations), or foregoing sequences where there is only a
      single statement. Assuming the parser follows the specification in
      section<SPACE/><REF NAME="sec:representing-expressions"/>,
      <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> and will always jump
      (via the dispatcher) to <JAVASCRIPTINLINE>ev_block</JAVASCRIPTINLINE> and
      <JAVASCRIPTINLINE>ev_block</JAVASCRIPTINLINE> will always jump (via the dispatcher)
      to <JAVASCRIPTINLINE>ev_sequence_start</JAVASCRIPTINLINE>.
    </TEXT>
      
    </JAVASCRIPT>
  </SPLIT>
  
  <TEXT>
    <SPLIT>
      <SCHEME>
        The portion of the explicit-control evaluator at
        <SCHEMEINLINE>ev-sequence</SCHEMEINLINE> is analogous to the
        metacircular evaluator<APOS/>s
        <SCHEMEINLINE>eval-sequence</SCHEMEINLINE> procedure. It handles
        sequences of expressions in procedure bodies or in explicit
        <SCHEMEINLINE>begin</SCHEMEINLINE> expressions.
      </SCHEME>
      <JAVASCRIPT>
        The portions of the explicit-control evaluator whose labels begin with
        <JAVASCRIPTINLINE>ev_sequence</JAVASCRIPTINLINE> are similar to the
        metacircular evaluator<APOS/>s
        <JAVASCRIPTINLINE>eval_sequence</JAVASCRIPTINLINE> function. They handle
        sequences of statements in function bodies or at the top level.

        The handling of returns in the explicit-control evaluator deviates from
        the metacircular evaluator in order to support tail recursion. Because a
        return statement will ensure that it continues to the proper place in
        the program by manipulating the stack, sequence evaluation does not need to be
        concerned with returns, or even be aware of the existence of explicit
        returns in the language.
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>explicit<SCHEMEINLINE>begin</SCHEMEINLINE> expressions</SCHEME>
      <JAVASCRIPT>Sequences of statements</JAVASCRIPT>
    </SPLITINLINE>
    are evaluated 
    <SPLITINLINE>
      <SCHEME>
	      by placing the sequence of expressions
      </SCHEME>
      <JAVASCRIPT>
	      at <JAVASCRIPTINLINE>ev_sequence_start</JAVASCRIPTINLINE> by placing the sequence of statements
      </JAVASCRIPT>
    </SPLITINLINE>
    to be evaluated in
    <SCHEMEINLINE>unev</SCHEMEINLINE>, saving
    <SCHEMEINLINE>continue</SCHEMEINLINE> on the
    stack, and jumping to 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><DECLARATION>ev_sequence_start</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
ev-begin
(assign unev (op begin-actions) (reg exp))
(save continue)
(goto (label ev-sequence))
      </SCHEME>
      <JAVASCRIPT>
"ev_sequence_start",
      save("continue"),
      assign("unev", list(op("sequence_statements"), reg("comp"))),
      go_to(label("ev_sequence")),
      </JAVASCRIPT>
    </SNIPPET>
    
    <SPLIT>
      <SCHEME>
        The implicit sequences in procedure bodies are handled by jumping to
        <SCHEMEINLINE>ev-sequence</SCHEMEINLINE> from
        <SCHEMEINLINE>compound-apply</SCHEMEINLINE>, at which point
        <SCHEMEINLINE>continue</SCHEMEINLINE> is already on the stack, having
        been saved at <SCHEMEINLINE>ev-application</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
        Saving <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> allows
        the register to be used in the iteration over the statements in the
        sequence and contributes to values on the stack that will be removed
        during the evaluation of an explicit return statement. 
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    The entries at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence-continue</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence_continue</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    form a loop that successively evaluates each
    <SPLITINLINE>
      <SCHEME>
	expression
      </SCHEME>
      <JAVASCRIPT>
	statement
      </JAVASCRIPT>
    </SPLITINLINE>
    in a sequence.  The
    list of unevaluated
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    is kept in <SCHEMEINLINE>unev</SCHEMEINLINE>.
    Before evaluating each
    <SPLITINLINE>
      <SCHEME>
	expression,
      </SCHEME>
      <JAVASCRIPT>
	statement,
      </JAVASCRIPT>
    </SPLITINLINE>
    we check to see if there are additional
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    to be evaluated in the sequence.  If so, we save the rest of the
    unevaluated
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    (held in <SCHEMEINLINE>unev</SCHEMEINLINE>) and the
    environment in which these must be evaluated (held in
    <SCHEMEINLINE>env</SCHEMEINLINE>) and call
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to evaluate the
    <SPLITINLINE>
      <SCHEME>
	expression.
      </SCHEME>
      <JAVASCRIPT>
	statement.
      </JAVASCRIPT>
    </SPLITINLINE>
    The two saved registers are restored upon
    the return from this evaluation, at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence-continue</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence_continue</JAVASCRIPTINLINE> (or removed by an explicit return statement, as this terminates the function instead of returning to <JAVASCRIPTINLINE>ev_sequence_continue</JAVASCRIPTINLINE>).
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    The final
    <SPLITINLINE>
      <SCHEME>
	expression
      </SCHEME>
      <JAVASCRIPT>
	statement
      </JAVASCRIPT>
    </SPLITINLINE>
    in the sequence is handled differently, at the
    entry point
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence-last-exp</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>ev_sequence_last_statement</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Since there are no more
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    to be evaluated after this one, we need
    not save <SCHEMEINLINE>unev</SCHEMEINLINE> or
    <SCHEMEINLINE>env</SCHEMEINLINE> before going to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>.
    </JAVASCRIPT></SPLITINLINE>
    The value of the whole sequence is the value of the last
    <SPLITINLINE>
      <SCHEME>
	expression,
      </SCHEME>
      <JAVASCRIPT>
	statement,
      </JAVASCRIPT>
    </SPLITINLINE>
    so
    after the evaluation of the last
    <SPLITINLINE>
      <SCHEME>
	expression
      </SCHEME>
      <JAVASCRIPT>
	statement
      </JAVASCRIPT>
    </SPLITINLINE>
    there is nothing left to do
    except continue at the entry point currently held on the stack (which was
    saved by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-application</SCHEMEINLINE> or <SCHEMEINLINE>ev-begin</SCHEMEINLINE>.)</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>, <JAVASCRIPTINLINE>ev_sequence_start</JAVASCRIPTINLINE> or
      <JAVASCRIPTINLINE>ev_conditional</JAVASCRIPTINLINE>.)</JAVASCRIPT>
    </SPLITINLINE>
    Rather than setting up <SCHEMEINLINE>continue</SCHEMEINLINE> to arrange for
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to return here and then restoring <SCHEMEINLINE>continue</SCHEMEINLINE> from
    the stack and continuing at that entry point, we restore
    <SCHEMEINLINE>continue</SCHEMEINLINE> from the stack before going to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    so that
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    will continue at that entry point after evaluating the
    <SPLITINLINE>
      <SCHEME>
	expression.
      </SCHEME>
      <JAVASCRIPT>
	statement.
      </JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><DECLARATION>ev_sequence</DECLARATION><SUBINDEX>with tail recursion</SUBINDEX></INDEX>
    <SNIPPET EVAL="no">
      <SCHEME>
ev-sequence
(assign exp (op first-exp) (reg unev))
(test (op last-exp?) (reg unev))
(branch (label ev-sequence-last-exp))
(save unev)
(save env)
(assign continue (label ev-sequence-continue))
(goto (label eval-dispatch))
ev-sequence-continue
(restore env)
(restore unev)
(assign unev (op rest-exps) (reg unev))
(goto (label ev-sequence))
ev-sequence-last-exp
(restore continue)
(goto (label eval-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_sequence",
      assign("comp", list(op("first_statement"), reg("unev"))),
      test(list(op("is_last_statement"), reg("unev"))),
      branch(label("ev_sequence_last_statement")),
      save("unev"),
      save("env"),
      assign("continue", label("ev_sequence_continue")),
      go_to(label("eval_dispatch")),
      
"ev_sequence_continue",
      restore("env"),
      restore("unev"),
      assign("unev", list(op("rest_statements"), reg("unev"))),
      go_to(label("ev_sequence")),

"ev_sequence_last_statement",
      restore("continue"),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SPLIT>
    <JAVASCRIPT>
      <SUBHEADING> 
        <NAME>Example: Stack Management</NAME>
      </SUBHEADING>
      <TEXT>
Our explicit-control evaluator saves register values to the stack, occasionally
to make space for a temporary value in a register whose contents is then
immediately restored, but most commonly before processing an instruction which
may overwrite the saved registers as part of its evaluation.
      </TEXT>
      <TEXT>
With the exception of return statements, which we shall soon address, after
evaluating an instruction, the stack will hold at its top precisely what is
about to be restored by its continuation. For example, when we construct the
list of arguments to a function at
<JAVASCRIPTINLINE>ev_appl_argument_expression_loop</JAVASCRIPTINLINE>, we push
<JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> and
<JAVASCRIPTINLINE>unev</JAVASCRIPTINLINE> to the stack before evaluating the
current argument expression, and when we continue at
<JAVASCRIPTINLINE>ev_appl_accumulate_arg</JAVASCRIPTINLINE>, we pop the stack to
restore the environment and the remainder of the argument list. Each instruction
only stores to the stack what is needed by the continuation and as a result, at
the end of a program, the stack will be empty.
      </TEXT>
      <TEXT>
The ability to return from a function in the middle of a sequence of statements
destroys this property and thus necessitates the additional stack management for function application 
that we recently introduced. Consider the following body of a function
<JAVASCRIPTINLINE>f</JAVASCRIPTINLINE>:

    <SNIPPET EVAL="no">
      <JAVASCRIPT>
x = 42;
if (x > 0) { return x; } else { ... }; 
x = x + 1;
      </JAVASCRIPT>
    </SNIPPET>

The evaluation of this program starts at
<JAVASCRIPTINLINE>ev_sequence_start</JAVASCRIPTINLINE> by saving the current
continuation, which is the label
<JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE> which was setup at
<JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> and then jumping to
<JAVASCRIPTINLINE>ev_sequence</JAVASCRIPTINLINE>. We then evaluate each
statement in the sequence in a loop. Each turn of the loop, we place the first
of the remaining statements in the sequence in
<JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE>. Then, like we did when evaluating the
argument list, we save <JAVASCRIPTINLINE>unev</JAVASCRIPTINLINE> (the list of
statements) and <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE>, and install
<JAVASCRIPTINLINE>ev_sequence_continue</JAVASCRIPTINLINE> as the continuation
before jumping to the dispatcher to evaluate the statement in
<JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE>.
      </TEXT>
      <TEXT>
If the return statement did not exist, we would do two saves before and two
restores after each statement, except the last which needs neither, and at the evaluation of the
last statement, at <JAVASCRIPTINLINE>ev_sequence_last_statement</JAVASCRIPTINLINE>,
restore the continuation saved at <JAVASCRIPTINLINE>ev_sequence_start</JAVASCRIPTINLINE>.
Consequently, we would have restored the stack to its state right 
when we jumped to <JAVASCRIPTINLINE>ev_sequence_start</JAVASCRIPTINLINE>.
      </TEXT>
      <TEXT>
When we evaluate a return statement inside a function
<JAVASCRIPTINLINE>f</JAVASCRIPTINLINE>, we must skip all remaining statements in
<JAVASCRIPTINLINE>f</JAVASCRIPTINLINE><APOS/>s body and after evaluating the
return expression jump to the continuation of the call to
<JAVASCRIPTINLINE>f</JAVASCRIPTINLINE>. To do so, we must remove any data saved
on the stack for continuations which are cancelled by the return, as these will
never pop their values from the stack.
      </TEXT>
      <TEXT>
In the example above, the continuation cancelled by the return statement is
<JAVASCRIPTINLINE>ev_sequence_continue</JAVASCRIPTINLINE>, which means that
<JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> and
<JAVASCRIPTINLINE>unev</JAVASCRIPTINLINE> must be popped from the stack. If the
return statement was inside a nested sequence (which would be the case if there
were more statements in the consequent branch of the conditional), there would
also be a continuation for the nested sequence and associated saves on the
stack to remove. This illustrates that different return statements must remove differently
many values from the stack depending on the structure of the program where they appear.
      </TEXT>
      <TEXT>
Our solution to this problem which was introduced in
<JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> is to insert a marker in the
stack during a function call that marks the place to which a return in the
function body must restore the stack (which is done at
<JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE>). The instructions
<JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE> and <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE> were defined
to simplify this stack management.
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>

    
</SUBSECTION>
