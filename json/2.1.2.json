[{"id":"/sicpjs/2.1.2","tag":"TITLE","body":"2.1.2  \n    Abstraction Barriers"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    Before continuing with more examples of compound data and data\n    abstraction, let us consider some of the issues raised by the\n    rational-number example.  We defined the rational-number operations in\n    terms of a constructor\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_rat"},{"body":"\n    and selectors ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"numer"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"denom"},{"body":".  In general, the underlying idea of data\n    abstraction is to identify for each type of data object a basic set of\n    operations in terms of which all manipulations of data objects of that type\n    will be expressed, and then to use only those operations in manipulating the\n    data.\n  ","tag":"#text"}]},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ch2-Z-G-6.svg","id":"#fig-2.1","captionHref":"/sicpjs/2.1.2#fig-2.1","captionName":"Figure 2.1 ","captionBody":[{"body":"Data-abstraction barriers in the rational-number package.\n        ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    We can envision the structure of the rational-number system as\n    shown in\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"2.1","href":"/sicpjs/2.1.2#fig-2.1"},{"body":".\n      \n    The horizontal lines represent ","tag":"#text"},{"tag":"EM","child":[{"body":"abstraction barriers","tag":"#text"}]},{"body":" that isolate\n    different \"","tag":"#text"},{"body":"levels","tag":"#text"},{"body":"\" of the system.  At each level, the barrier\n    separates the programs (above) that use the data abstraction from the\n    programs (below) that implement the data abstraction.  Programs that\n    use rational numbers manipulate them solely in terms of the\n    functions\n    supplied \"","tag":"#text"},{"body":"for public use","tag":"#text"},{"body":"\" by the rational-number package:\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_rat"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sub_rat"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_rat"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_rat"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"equal_rat"},{"body":".\n    These, in turn, are implemented solely in terms of the\n    \n    constructor and\n    \n    selectors\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_rat"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"numer"},{"body":", and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"denom"},{"body":",\n    which themselves are implemented in terms of pairs.  The details of how\n    pairs are implemented are irrelevant to the rest of the rational-number\n    package so long as pairs can be manipulated by the use of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":".\n    In effect,\n    functions\n    at each level are the interfaces that define the abstraction barriers and\n    connect the different levels.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    This simple idea has many advantages.  One advantage is that it makes\n    programs much easier to maintain and to modify.  Any complex data\n    structure can be represented in a variety of ways with the primitive\n    data structures provided by a programming language.  Of course, the\n    choice of representation influences the programs that operate on it;\n    thus, if the representation were to be changed at some later time, all\n    such programs might have to be modified accordingly.  This task could\n    be time-consuming and expensive in the case of large programs unless\n    the dependence on the representation were to be confined by design to\n    a very few program modules.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    For example, an alternate way to address the problem of\n    \n    reducing rational\n    numbers to lowest terms is to perform the reduction whenever we\n    access the parts of a rational number, rather than when we construct\n    it.  This leads to different constructor and selector\n    functions:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":5,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQEY0oFA4GYCuAdgMYAuAlgPbGgDmpAJgBQCGANKAEYCUoAbxygRoAE4BTcoTF1uoALxLQABlAB+UG1AAuBsxbcu2gKQ9eAbhwBfPETJVaoALZsA1hID6YtuRbEuJn4hUXEpGToABzZKMX9AyxsCEgoaOmJCZwk4gA9g4VFSWgBncgZFfVYACwk2VjyuchiAGxY8xNDJaVlQGrq2-jB6K1t7VKcmCWJqZwHBApEi4lLyhUqWPvreRpaBjtEuiNAmyla80CGRvBBQSLFKYipiemOa8V80tmbQB9BaCVAzQeAMkAEdCLEJMVQMUZgDSvdnjgbq5iJRIoRmh9aHoEQ96JR8ABPY4RaHaDLObjZH6PahaGHkREvZFgNjEJivAHUSLZXzUMSgADUoFI7J4ALYkUiQIknPI9Lxz2h+AFrMZzNFtDF5Cm2OIyQcaVuiPI3l8cxCB3CPSYlGKMrYRJYSoJxP8mWye2FoAARMBfT7XYTnZNprN2olbDglit-p4ql98BVXB5zX4MFwUIkcHcHmafH544nmvhLEA","body":"function make_rat(n, d) {\n    return pair(n, d);\n}\nfunction numer(x) {\n    const g = gcd(head(x), tail(x));\n    return head(x) / g;\n}\nfunction denom(x) {\n    const g = gcd(head(x), tail(x));\n    return tail(x) / g;\n} "},{"body":"\n    The difference between this implementation and the previous one lies in when\n    we compute the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":". If in our typical use of\n    rational numbers we access the numerators and denominators of the same\n    rational numbers many times, it would be preferable to compute the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":" when the rational numbers are constructed.\n    If not, we may be better off waiting until access time to compute the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":".  In any case, when we change from one\n    representation to the other, the\n    functions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_rat"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sub_rat"},{"body":",\n    and so on do not have to be modified at all.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Constraining the dependence on the representation to a few interface\n    functions\n    helps us design programs as well as modify them, because it allows us to\n    maintain the flexibility to consider alternate implementations.  To continue\n    with our simple example, suppose we are designing a rational-number package\n    and we can't decide initially whether to perform the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":" at construction time or at selection time.\n    The data-abstraction methodology gives us a way to defer that decision\n    without losing the ability to make progress on the rest of the system.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.2","id":"#ex-2.2","child":[{"body":"\n    Consider the problem of representing \n    \n    line segments in a plane.  Each segment is represented as a pair of points:\n    a starting point and an ending point.\n    Declare\n    a constructor \n     ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_segment"},{"body":"\n    and selectors \n     ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"start_segment"},{"body":"\n    and \n     ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"end_segment"},{"body":"\n    that define the representation of segments in\n    terms of points.  Furthermore, a point \n    \n    can be represented as a pair\n    of numbers: the ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" coordinate and the\n    ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" coordinate.  Accordingly, specify a\n    constructor \n     ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_point"},{"body":"\n    and selectors\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x_point"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y_point"},{"body":"\n    that define this representation. Finally, using your selectors and\n    constructors,\n    declare a function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"midpoint_segment"},{"body":"\n    that takes a line segment as argument and returns its midpoint (the point\n    whose coordinates are the average of the coordinates of the endpoints).\n    To try your\n    functions,\n    you'll need a way to print points:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"function print_point(p) {\n    return display(\"(\" + stringify(x_point(p)) + \", \"\n                       + stringify(y_point(p)) +        \")\");\n}"}],"solution":[{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":6,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQEY0oFA4GYCuAdgMYAuAlgPbGgAOATpceQPr3UvkAU9AlKADeOUGNCMApuUKM6AE0oBnegBsAhgE8eAIl2gA1KCXlmxAOaV82gB4curPv0FGdAGlA7R4n778+jEzNLax5Ne24nF39Pfh1+AG4cAF88IjIqWlA7TkibQREfKRk5UAALSXV5Hnyk1PSKGjpw3Md84W8xYtk6cnVKVRrElIISRqyAW3UAa0kIto9NAs6JaR6GfsYaxeH6scy6Kdm2JUlzCclHE3VGdlbyD0v5efJlorXS+k2ea9uXx+Iz3uu1GGSaxj6f1O50uvHahXE3VKFSqQzqoPGdCeJzOFzab0RH16-UGtRGDQOoHUADdJIx1OZJDx1B4AEYErpE0DMwygdmgMAodEU8ETShAhzsaF4uEc0CkWgmKmgAC8EJuUtxsLRKwVxCVrNVoGx0u1ZPeJUOMzm92ZtPpjJqL2Z-DcKxiHo9OUlPHZrvdnv8NLpDKZLR96n9gej-nDkT9IJweqVtDmZXUqnwRqOc1NjhzzoADB5C67QAGY4GC7aMB4MM4kkxuM6xRLm3neKm2OnMw2gA","body":"function x_point(x) {\n    return head(x);\n}\nfunction y_point(x) {\n    return tail(x);\n}\nfunction make_point(x, y) {\n    return pair(x, y);\n}\nfunction make_segment(start_point, end_point) {\n    return pair(start_point, end_point);\n}\nfunction start_segment(x) {\n    return head(x);\n}\nfunction end_segment(x) {\n    return tail(x);\n}\nfunction average(a, b) {\n    return (a + b) / 2;\n}\nfunction mid_point_segment(x) {\n    const a = start_segment(x);\n    const b = end_segment(x);\n    return make_point(average(x_point(a),\n                              x_point(b)),\n                      average(y_point(a),\n                              y_point(b)));\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.3","id":"#ex-2.3","child":[{"body":"\n    Implement a representation for\n    \n    rectangles in a plane. (Hint: You may want to\n    make use of exercise ","tag":"#text"},{"tag":"REF","body":"2.2","href":"/sicpjs/2.1.2#ex-2.2"},{"body":".) In terms of your\n    constructors and selectors, create\n    functions\n    that compute the perimeter and the area of a given rectangle.  Now implement\n    a different representation for rectangles.  Can you design your system with\n    suitable abstraction barriers, so that the same perimeter and area\n    functions\n    will work using either representation?\n    ","tag":"#text"}],"solution":[{"body":"\n      First implementation:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQEY0oFA4GYCuAdgMYAuAlgPbGgC2AhgNYCmA+gA7WXHkAUADwA0oAJ4BKAN45Qc0ACdW5QgrqdGlBUNGSA3DgC+BEhRp1BXHnyHTZ8pSrWgAFq0YATWweNEyVWnErXgFBO3lFZVU6ck0AG28jPD8zQKY2diUKfgAjanJyanp2ONZ8clFCzkzKAHMXcnCHKOcNLVz8wuLS8srqaoU6hokfZNMAmP6a+oEsxpkIx2jQWMoEuZGkk39zUDyCoumG-g2F5qc6dI5uEKFgm1X11goJCWF7CM+vz7F7gTdPCdno1XqNtqlJtUerNgU05EtnFc-ncbjYAV4Nm8Pt8cRFfqiBI8gS9QUk5OCJntOodocT5tiEXR0XTNsZySlKYwcgBnWxneEtCygAA8oAADKAAPygAC0oEEoAAXPKwRzdgB3SgecguTLAln8yIXUBc3mWAkdA7dMowkmy0DY3Fyc3WAT7LpHW0g1ljHaBNxDch67KnBmCk080D8fGuy0e2mY+2Op1BC1VEo2lmk4wU3aMJSMYNepqM0Ca7W6uYs0AAKlcrEDRZZqvGu04rEG9GUHaboYFxpQtaj5Z1vdhoAA1PXG1XMWDSLRueRQAA3UAAXgYLA4VaRFrFogwby3GQtKFEAGZSTh253uwomyuRkA","body":"function make_point(x, y){\n    return pair(x, y);\n}\nfunction x_point(x){\n    return head(x);\n}\nfunction y_point(x){\n    return tail(x);\n}\n\nfunction make_rect(bottom_left, top_right){\n    return pair(bottom_left, top_right);\n}\n\nfunction top_right(rect){\n    return tail(rect);\n}\n\nfunction bottom_right(rect){\n    return make_point(x_point(tail(rect)),\n                      y_point(head(rect)));\n}\n\nfunction top_left(rect){\n    return make_point(x_point(head(rect)),\n                      y_point(tail(rect)));\n}\n  \nfunction bottom_left(rect){\n    return head(rect);\n}\n  \nfunction abs(x){\n    return x < 0 ? - x : x;\n}\n\nfunction width_rect(rect){\n    return abs(x_point(bottom_left(rect)) - \n               x_point(bottom_right(rect)));\n}\n\nfunction height_rect(rect){\n    return abs (y_point(bottom_left(rect)) - \n                y_point(top_left(rect)));\n}\n\nfunction area_rect(rect){\n  return width_rect(rect) * height_rect(rect);\n}\n\nfunction perimeter_rect(rect){\n  return 2 * (width_rect(rect) + height_rect(rect));\n} "},{"body":"\n      Second implementation:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQEY0oFA4GYCuAdgMYAuAlgPbGgC2AhgNYCmA+gA7WXHkAUADwA0oAJ4BKAN45Qc0ACdW5QgrqdGlBUNGSA3DgC+eImSq0GLDkor8ARtXLlq9dgBtW+cqIDulACbkABaiQayUAOZB5NKy8koqaqAaWvaOzq4eXqIp2n6BIaBhkdESEgbGBCQUNHTFUeTsNgLNsfKKyqp05Jpu-D2Ufa3lRibV5nT5wU2stq0ycgldRayM-v29-MMVY2a1oIxKjDNzszELHYmTAdPNW2cSoABUKyWNd607VXsWnKwKlHoyn+JxaDwuSySKGeoH4UyCoPuFEeAGpXg1EdtRjhSLQAM7kUAAN1AAF5LGxEUxKdxeAIMKIUBJGYyRjg-gCgeQQXcieUgA","body":"function make_point(x, y){\n    return pair(x, y);\n}\n\nfunction make_rect(bottom_left, width, height){\n    return pair(bottom_left, pair(width, height));\n}\n\nfunction height_rect(rect){\n    return tail(tail(rect));\n}\n\nfunction width_rect(rect){\n  return head(tail(rect));\n}\n\nfunction area_rect(rect){\n  return width_rect(rect) * height_rect(rect);\n}\n\nfunction perimeter_rect(rect){\n  return 2 * (width_rect(rect) + height_rect(rect));\n} "}]}]