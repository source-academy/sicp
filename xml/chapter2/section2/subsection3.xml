<SUBSECTION>
  <NAME>
    Sequences as Conventional Interfaces
  </NAME>

  <LABEL NAME="sec:sequences-conventional-interfaces"/>
  <INDEX>sequence(s)<SUBINDEX>as conventional interface</SUBINDEX><OPEN/></INDEX>
  <INDEX>conventional interface<SUBINDEX>sequence as</SUBINDEX><OPEN/></INDEX>

  <TEXT>
    In working with compound data, we<APOS/>ve stressed how data abstraction
    permits us to design programs without becoming enmeshed in the details
    of data representations, and how abstraction preserves for us the
    flexibility to experiment with alternative representations.  In this
    section, we introduce another powerful design principle for working
    with data structures<EMDASH/>the use of <EM>conventional interfaces</EM>.
  </TEXT>

  <TEXT>
    In section<SPACE/><REF NAME="sec:higher-order-procedures"/> we saw how
    program abstractions, implemented as higher-order
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
    <PYTHON>functions,</PYTHON></SPLITINLINE>
    can capture common patterns in programs that deal with numerical data. Our
    ability to formulate analogous operations for working with compound data
    depends crucially on the style in which we manipulate our data structures.
    Consider, for example, the following
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <PYTHON>function,</PYTHON>
    </SPLITINLINE>
    analogous to the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>count-leaves</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>count_leaves</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    of section<SPACE/><REF NAME="sec:trees"/>, which takes a tree as argument
    and computes the sum of the squares of the leaves that are odd:
    <SNIPPET HIDE="yes">
      <NAME>odd_definition</NAME>
      <SCHEME>
(define (odd? n)
  (= (remainder n 2) 1))
      </SCHEME>
      <PYTHON>
function is_odd(n) {
    return n % 2 === 1;
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>sum_odd_squares</DECLARATION></INDEX> 
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>odd_definition</REQUIRES>
      <EXAMPLE>sum_odd_squares_example</EXAMPLE>
      <EXPECTED>34</EXPECTED>
      <SCHEME>
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)  
        ((not (pair? tree))
          (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
          (sum-odd-squares (cdr tree))))))
      </SCHEME>
      <PYTHON>
function sum_odd_squares(tree) {
    return is_null(tree)
           ? 0
           : ! is_pair(tree)
           ? is_odd(tree) ? square(tree) : 0
           : sum_odd_squares(head(tree)) +
             sum_odd_squares(tail(tree));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>sum_odd_squares_example</NAME>
      <SCHEME>
(sum-odd-squares (list (list 2 3) (list 4 5)))
      </SCHEME>
      <PYTHON>
sum_odd_squares(list(list(2, 3), list(4, 5)));
      </PYTHON>
    </SNIPPET>
    On the surface, this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    is very different from the following one, which constructs a list of all
    the even Fibonacci numbers
    <LATEXINLINE>${\textrm{Fib}}(k)$</LATEXINLINE>, where
    <LATEXINLINE>$k$</LATEXINLINE> is less than or equal to a given integer
    <LATEXINLINE>$n$</LATEXINLINE>:
    <SNIPPET>
      <INDEX><DECLARATION>even_fibs</DECLARATION></INDEX> 
      <REQUIRES>even_definition</REQUIRES>
      <REQUIRES>fib_definition</REQUIRES>
      <EXAMPLE>even_fibs_example</EXAMPLE>
      <EXPECTED>[ 2, [ 8, [ 34, null ] ] ]</EXPECTED>
      <SCHEME>
(define (even-fibs n)
  (define (next k)
    (if (&gt; k n)
      nil
      (let ((f (fib k)))
        (if (even? f)
          (cons f (next (+ k 1)))
          (next (+ k 1))))))
  (next 0))
      </SCHEME>
      <PYTHON>
function even_fibs(n) {
    function next(k) {
        if (k &gt; n) {
            return null;
        } else {
            const f = fib(k);
            return is_even(f)
                   ? pair(f, next(k + 1))
                   : next(k + 1);
        }
    }
    return next(0);
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>even_fibs_example</NAME>
      <SCHEME>
(even-fibs 9)
      </SCHEME>
      <PYTHON>
even_fibs(9);
      </PYTHON>
      <PYTHON_TEST>
tail(even_fibs(9));
      </PYTHON_TEST>
    </SNIPPET>
  </TEXT>
  <TEXT>
    Despite the fact that these two
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    are structurally very different, a more abstract description of the two
    computations reveals a great deal of similarity.  The first program
    <UL>
      <LI>
	enumerates the leaves of a tree;
      </LI>
      <LI>
	filters them, selecting the odd ones;
      </LI>
      <LI>
	squares each of the selected ones; and
      </LI>
      <LI>
	accumulates the results using
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>+</SCHEMEINLINE>,</SCHEME>
	  <PYTHON><PYTHONINLINE>+</PYTHONINLINE>,</PYTHON>
	</SPLITINLINE>
	starting with 0.
      </LI>
    </UL>
    The second program
    <UL>
      <LI>
	enumerates the integers from 0 to <LATEXINLINE>$n$</LATEXINLINE>;
      </LI>
      <LI>
	computes the Fibonacci number for each integer;
      </LI>
      <LI>
	filters them, selecting the even ones; and
      </LI>
      <LI>
	accumulates the results using
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE>,</SCHEME>
	  <PYTHON><PYTHONINLINE>pair</PYTHONINLINE>,</PYTHON>
	</SPLITINLINE>
	starting with the empty list.
      </LI>
    </UL>
  </TEXT>
    <PDF_ONLY>
      <!-- Figure moved here for SICP JS pagination -->
      <!-- Figure code is copy of code below in a WEB_ONLY -->
    <SPLIT>
      <SCHEME>
        <FIGURE src="img_original/ch2-Z-G-17.svg">
          <LABEL NAME="fig:signal-flow-plans_scheme"/>
          <CAPTION>The signal-flow plans for the procedures
          <SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE> (top) and
	  <SCHEMEINLINE>even-fibs</SCHEMEINLINE>
	  (bottom) reveal the commonality between the two programs.
          </CAPTION>
        </FIGURE>
      </SCHEME>
      <PYTHON>
        <FIGURE src="img_javascript/ch2-Z-G-17.svg">
          <LABEL NAME="fig:signal-flow-plans"/>
          <CAPTION>The signal-flow plans for the
          functions
          <PYTHONINLINE>sum_odd_squares</PYTHONINLINE> (top) and
	  <PYTHONINLINE>even_fibs</PYTHONINLINE> (bottom) reveal the
          commonality between the two programs.
          </CAPTION>
        </FIGURE>
      </PYTHON>
    </SPLIT>
    </PDF_ONLY>
    <SHORT_PAGE lines="4"/>
  <TEXT>
    A signal-processing engineer would find it natural to conceptualize these
    processes in terms of
    <INDEX>signal-processing view of computation</INDEX>
    <INDEX>signal-flow diagram</INDEX>
    signals flowing through a cascade of stages, each of
    which implements part of the program plan, as shown in
    <SPLITINLINE>
      <SCHEME>figure<SPACE/><REF NAME="fig:signal-flow-plans_scheme"/>.</SCHEME>
      <PYTHON>figure<SPACE/><REF NAME="fig:signal-flow-plans"/>.
      </PYTHON>
    </SPLITINLINE>
    In
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>sum_odd_squares</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    we begin with an 
    <INDEX>enumerator</INDEX>
    <EM>enumerator</EM>, which generates a <QUOTE>signal</QUOTE> consisting of
    the leaves of a given tree.  This signal is passed through a 
    <INDEX>filter</INDEX>
    <EM>filter</EM>, which eliminates all but the odd elements. The resulting
    signal is in turn passed through a 
    <INDEX>mapping<SUBINDEX><ORDER>trans</ORDER>as a transducer</SUBINDEX></INDEX>
    <EM>map</EM>, which is a <QUOTE>transducer</QUOTE> that applies the
    <SCHEMEINLINE>square</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    to each element.  The output of the map is then fed to an 
    <INDEX>accumulator</INDEX>
    <EM>accumulator</EM>, which combines the elements using
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>+</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>+</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    starting from an initial 0. The plan for
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>even-fibs</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>even_fibs</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    is analogous.
    <WEB_ONLY>
      <!-- Figure code appears earlier in this file in a PDF_ONLY for SICP JS pagination -->
    <SPLIT>
      <SCHEME>
        <FIGURE src="img_original/ch2-Z-G-17.svg">
          <LABEL NAME="fig:signal-flow-plans_scheme"/>
          <CAPTION>The signal-flow plans for the procedures
          <SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE> (top) and
	  <SCHEMEINLINE>even-fibs</SCHEMEINLINE>
	  (bottom) reveal the commonality between the two programs.
          </CAPTION>
        </FIGURE>
      </SCHEME>
      <PYTHON>
        <FIGURE src="img_javascript/ch2-Z-G-17.svg">
          <LABEL NAME="fig:signal-flow-plans"/>
          <CAPTION>The signal-flow plans for the
          functions
          <PYTHONINLINE>sum_odd_squares</PYTHONINLINE> (top) and
	  <PYTHONINLINE>even_fibs</PYTHONINLINE> (bottom) reveal the
          commonality between the two programs.
          </CAPTION>
        </FIGURE>
      </PYTHON>
    </SPLIT>
    </WEB_ONLY>
  </TEXT>
  <TEXT>
    Unfortunately, the two
    <SPLITINLINE>
      <SCHEME>procedure definitions</SCHEME>
      <PYTHON>function declarations</PYTHON>
    </SPLITINLINE>
    above fail to exhibit this signal-flow structure.  For instance, if we
    examine the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>sum_odd_squares</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <PYTHON>function,</PYTHON>
    </SPLITINLINE>
    we find that the enumeration is implemented partly by the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>null?</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>is_null</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pair?</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>is_pair</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    tests and partly by the tree-recursive structure of the
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <PYTHON>function.</PYTHON>
    </SPLITINLINE>
    Similarly, the accumulation is found partly in the tests and partly in the
    addition used in the recursion.  In general, there are no distinct parts of
    either
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    that correspond to the elements in the signal-flow description. Our two
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    decompose the computations in a different way, spreading the enumeration
    over the program and mingling it with the map, the filter, and the
    accumulation.  If we could organize our programs to make the signal-flow
    structure manifest in the
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    we write, this would increase the conceptual clarity of the resulting
    <SPLITINLINE>
      <SCHEME>code.</SCHEME>
      <PYTHON>program.</PYTHON>
    </SPLITINLINE>
  </TEXT>

  <SUBHEADING>
    <NAME>Sequence Operations</NAME>
  </SUBHEADING>

  <LABEL NAME="sec:sequence-operations"/>
  <INDEX>sequence(s)<SUBINDEX>operations on</SUBINDEX><OPEN/></INDEX>

  <LONG_PAGE lines="2"/>
  <TEXT>
    The key to organizing programs so as to more clearly reflect the
    signal-flow structure is to concentrate on the <QUOTE>signals</QUOTE> that
    flow from one stage in the process to the next.  If we represent these
    signals as lists, then we can use list operations to implement the
    processing at each of the stages.  For instance, we can implement the
    mapping stages of the signal-flow diagrams using the
    <SCHEMEINLINE>map</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    from section<SPACE/><REF NAME="sec:sequences"/>:
    <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>map</REQUIRES>
      <EXPECTED>25</EXPECTED>
      <SCHEME>
(map square (list 1 2 3 4 5))
      </SCHEME>
      <SCHEMEOUTPUT>
            (1 4 9 16 25)
      </SCHEMEOUTPUT>
      <PYTHON>
map(square, list(1, 2, 3, 4, 5));
      </PYTHON>
      <PYTHON_TEST>
list_ref(map(square, list(1, 2, 3, 4, 5)), 4);
      </PYTHON_TEST>
      <PYTHON_OUTPUT>      
list(1, 4, 9, 16, 25)
      </PYTHON_OUTPUT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Filtering a sequence to select only those elements that satisfy a given
    predicate is accomplished by
    <SNIPPET>
      <INDEX><DECLARATION>filter</DECLARATION></INDEX> 
      <NAME>filter</NAME>
      <EXAMPLE>filter_odd</EXAMPLE>
      <EXPECTED>[ 1, [ 3, [ 5, null ] ] ]</EXPECTED>
      <SCHEME>
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
          (cons (car sequence)
                (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
      </SCHEME>
      <PYTHON>
function filter(predicate, sequence) {
    return is_null(sequence)
           ? null
           : predicate(head(sequence))
           ? pair(head(sequence), 
                  filter(predicate, tail(sequence)))
           : filter(predicate, tail(sequence));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>filter_odd</NAME>
      <EXPECTED>[ 1, [ 3, [ 5, null ] ] ]</EXPECTED>
      <SCHEME>
(define (odd? n)
  (= (remainder n 2) 1))

(filter odd? (list 1 2 3 4 5))
      </SCHEME>
      <PYTHON>
function is_odd(n) {
    return n % 2 === 1;
}
filter(is_odd, list(1, 2, 3, 4, 5));
      </PYTHON>
    </SNIPPET>
    For example,
    <SNIPPET>
      <REQUIRES>filter</REQUIRES>
      <REQUIRES>odd_definition</REQUIRES>
      <SCHEME>
(filter odd? (list 1 2 3 4 5))
      </SCHEME>
      <SCHEMEOUTPUT>
            (1 3 5)
      </SCHEMEOUTPUT>
      <PYTHON>
filter(is_odd, list(1, 2, 3, 4, 5));
      </PYTHON>
      <PYTHON_OUTPUT>      
list(1, 3, 5)
      </PYTHON_OUTPUT>
    </SNIPPET>
  </TEXT>
  <TEXT>
  Accumulations can be implemented by
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>accumulate</DECLARATION></INDEX>
      <NAME>accumulate</NAME>
      <SCHEME>
(define (accumulate op initial sequence)
  (if (null? sequence)
    initial
    (op (car sequence)
        (accumulate op initial (cdr sequence)))))
      </SCHEME>
      <PYTHON>
function accumulate(op, initial, sequence) {
    return is_null(sequence)
           ? initial
           : op(head(sequence), 
                accumulate(op, initial, tail(sequence)));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>simple_plus</NAME>
      <SCHEME>
;; in Scheme, the operator symbol + is procedure name
      </SCHEME>
      <PYTHON>
function plus(x, y) {
    return x + y;
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <REQUIRES>accumulate</REQUIRES>
      <REQUIRES>simple_plus</REQUIRES>
      <EXPECTED>15</EXPECTED>
      <SCHEME>
(accumulate + 0 (list 1 2 3 4 5))
      </SCHEME>
      <SCHEMEOUTPUT>
15
      </SCHEMEOUTPUT>
      <PYTHON>
accumulate(plus, 0, list(1, 2, 3, 4, 5));
      </PYTHON>
      <PYTHON_OUTPUT>
15
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>simple_times</NAME>
      <SCHEME>
;; in Scheme, the operator symbol * is procedure name
      </SCHEME>
      <PYTHON>
function times(x, y) {
    return x * y;
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <REQUIRES>accumulate</REQUIRES>
      <REQUIRES>simple_times</REQUIRES>
      <EXPECTED>120</EXPECTED>
      <SCHEME>
(accumulate * 1 (list 1 2 3 4 5))
      </SCHEME>
      <SCHEMEOUTPUT>
            120
      </SCHEMEOUTPUT>
      <PYTHON>
accumulate(times, 1, list(1, 2, 3, 4, 5));
      </PYTHON>
      <PYTHON_OUTPUT>
120	
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <REQUIRES>accumulate</REQUIRES>
      <EXPECTED>[ 3, [ 4, [ 5, null ] ] ]</EXPECTED>
      <SCHEME>
(accumulate cons nil (list 1 2 3 4 5))
      </SCHEME>
      <SCHEMEOUTPUT>
(1 2 3 4 5)
      </SCHEMEOUTPUT>
      <PYTHON>
accumulate(pair, null, list(1, 2, 3, 4, 5));
      </PYTHON>
      <PYTHON_TEST>
tail(tail(accumulate(pair, null, list(1, 2, 3, 4, 5))));
      </PYTHON_TEST>
      <PYTHON_OUTPUT>
list(1, 2, 3, 4, 5)
      </PYTHON_OUTPUT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    All that remains to implement signal-flow diagrams is to enumerate the
    sequence of elements to be processed.  For
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>even-fibs</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>even_fibs</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    we need to generate the sequence of integers in a given range, which we
    can do as follows:
    <SNIPPET>
      <INDEX><DECLARATION>enumerate_interval</DECLARATION></INDEX> 
      <NAME>enumerate_interval</NAME>
      <EXAMPLE>enumerate_interval_example</EXAMPLE>
      <EXPECTED>[ 5, [ 6, [ 7, null ] ] ]</EXPECTED>
      <SCHEME>
(define (enumerate-interval low high)
   (if (&gt; low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
      </SCHEME>
      <PYTHON>
function enumerate_interval(low, high) {
    return low &gt; high
           ? null
           : pair(low,
                  enumerate_interval(low + 1, high));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>enumerate_interval_example</NAME>
      <REQUIRES>enumerate_interval</REQUIRES>
      <SCHEME>
(enumerate-interval 2 7)
      </SCHEME>
      <SCHEMEOUTPUT>
(2 3 4 5 6 7)
      </SCHEMEOUTPUT>
      <PYTHON>
enumerate_interval(2, 7);
      </PYTHON>
      <PYTHON_TEST>
tail(tail(tail(enumerate_interval(2, 7))));
      </PYTHON_TEST>
      <PYTHON_OUTPUT>
list(2, 3, 4, 5, 6, 7)
      </PYTHON_OUTPUT>
    </SNIPPET>
    To enumerate the leaves of a tree, we can use<FOOTNOTE>This is, in fact,
    precisely the 
     <INDEX><USE>fringe</USE><SUBINDEX>as a tree enumeration</SUBINDEX></INDEX> 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>fringe</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>fringe</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <PYTHON>function</PYTHON>
    </SPLITINLINE>
    from exercise<SPACE/><REF NAME="ex:fringe"/>.  Here we<APOS/>ve renamed it
    to emphasize that it is part of a family of general sequence-manipulation
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <PYTHON>functions.</PYTHON>
    </SPLITINLINE></FOOTNOTE>
    <SNIPPET>
      <INDEX>tree<SUBINDEX>enumerating leaves of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>enumerate_tree</DECLARATION></INDEX> 
      <NAME>enumerate_tree</NAME>
      <EXAMPLE>enumerate_tree_example</EXAMPLE>
      <EXPECTED>[ 3, [ 4, [ 5, null ] ] ]</EXPECTED>
      <SCHEME>
(define (enumerate-tree tree)
   (cond ((null? tree) nil)
         ((not (pair? tree)) (list tree))
         (else (append (enumerate-tree (car tree))
                       (enumerate-tree (cdr tree))))))
      </SCHEME>
      <PYTHON>
function enumerate_tree(tree) {
    return is_null(tree)
           ? null
           : ! is_pair(tree)
           ? list(tree)
           : append(enumerate_tree(head(tree)),
                    enumerate_tree(tail(tree)));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>enumerate_tree_example</NAME>
      <REQUIRES>enumerate_tree</REQUIRES>
      <SCHEME>
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
      </SCHEME>
      <SCHEMEOUTPUT>
(1 2 3 4 5)
      </SCHEMEOUTPUT>
      <PYTHON>
enumerate_tree(list(1, list(2, list(3, 4)), 5));
      </PYTHON>
      <PYTHON_TEST>
tail(tail(enumerate_tree(list(1, list(2, list(3, 4)), 5))));
      </PYTHON_TEST>
      <PYTHON_OUTPUT>
list(1, 2, 3, 4, 5)
      </PYTHON_OUTPUT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    Now we can reformulate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>sum_odd_squares</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>even-fibs</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>even_fibs</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    as in the signal-flow diagrams.  For
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>sum_odd_squares</PYTHONINLINE>,
    </PYTHON></SPLITINLINE>
    we enumerate the sequence of leaves of the tree, filter this to keep only
    the odd numbers in the sequence, square each element, and sum the results:
    <SNIPPET>
      <INDEX><DECLARATION>sum_odd_squares</DECLARATION></INDEX> 
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>simple_plus</REQUIRES>
      <REQUIRES>odd_definition</REQUIRES>
      <REQUIRES>enumerate_tree</REQUIRES>
      <EXAMPLE>sum_odd_squares_example</EXAMPLE>
      <EXPECTED>34</EXPECTED>
      <SCHEME>
(define (sum-odd-squares tree)
   (accumulate +
               0
               (map square
                 (filter odd?
                  (enumerate-tree tree)))))
      </SCHEME>
      <PYTHON>
function sum_odd_squares(tree) {
    return accumulate(plus, 
                      0, 
                      map(square, 
                          filter(is_odd, 
                                 enumerate_tree(tree))));
}
      </PYTHON>
    </SNIPPET>
    For
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>even-fibs</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>even_fibs</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    we enumerate the integers from 0 to <LATEXINLINE>$n$</LATEXINLINE>, generate
    the Fibonacci number for each of these integers, filter the resulting
    sequence to keep only the even elements, and accumulate the results
    into a list:
    <SNIPPET>
      <INDEX><DECLARATION>even_fibs</DECLARATION></INDEX> 
      <REQUIRES>even_definition</REQUIRES>        
      <REQUIRES>fib_definition</REQUIRES>
      <REQUIRES>enumerate_interval</REQUIRES>
      <EXAMPLE>even_fibs_example</EXAMPLE>
      <EXPECTED>[ 2, [ 8, [ 34, null ] ] ]</EXPECTED>
      <SCHEME>
(define (even-fibs n)
   (accumulate cons
               nil
               (filter even?
                 (map fib
                      (enumerate-interval 0 n)))))
      </SCHEME>
      <PYTHON>
function even_fibs(n) {
    return accumulate(pair, 
                      null, 
                      filter(is_even, 
                             map(fib, 
                                 enumerate_interval(0, n))));
}
      </PYTHON>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The value of expressing programs as sequence operations is that this
    helps us make program designs that are modular, that is, designs that
    are constructed by combining relatively independent pieces.  We can
    encourage modular design by providing a library of standard components
    together with a conventional interface for connecting the components
    in flexible ways.
  </TEXT>

  <TEXT>
    Modular construction
    <INDEX>modularity</INDEX>
    <INDEX>sequence(s)<SUBINDEX>as source of modularity</SUBINDEX></INDEX>
    is a powerful strategy for controlling complexity in
    engineering design.  In real signal-processing applications, for example,
    designers regularly build systems by cascading elements selected from
    standardized families of filters and transducers.  Similarly, sequence
    operations provide a library of standard program elements that we can mix
    and match.  For instance, we can reuse pieces from the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>sum_odd_squares</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>even-fibs</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>even_fibs</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    in a program that constructs a list of the squares of the first
    <LATEXINLINE>$n+1$</LATEXINLINE> Fibonacci numbers:
    <SNIPPET>
      <NAME>list_fib_squares</NAME>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>fib_definition</REQUIRES>
      <REQUIRES>enumerate_interval</REQUIRES>
      <EXAMPLE>list_fib_squares_example</EXAMPLE>
      <EXPECTED>11</EXPECTED>
      <SCHEME>
(define (list-fib-squares n)
  (accumulate cons
              nil
              (map square
                   (map fib
                        (enumerate-interval 0 n)))))
      </SCHEME>
      <PYTHON>
function list_fib_squares(n) {
    return accumulate(pair, 
                      null, 
                      map(square, 
                          map(fib, 
                              enumerate_interval(0, n))));
}                         
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>list_fib_squares_example</NAME>
      <REQUIRES>list_fib_squares</REQUIRES>
      <SCHEME>
(list-fib-squares 10)
      </SCHEME>
      <SCHEMEOUTPUT>
(0 1 1 4 9 25 64 169 441 1156 3025)
      </SCHEMEOUTPUT>
      <PYTHON>
list_fib_squares(10);
      </PYTHON>
      <PYTHON_TEST>
length(list_fib_squares(10));
      </PYTHON_TEST>
      <PYTHON_OUTPUT>
list(0, 1, 1, 4, 9, 25, 64, 169, 441, 1156, 3025)
      </PYTHON_OUTPUT>
    </SNIPPET>
    We can rearrange the pieces and use them in computing the product of the
    squares of the odd integers in a sequence:
    <SNIPPET>
      <NAME>product_of_squares_of_odd_elements</NAME>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>odd_definition</REQUIRES>
      <REQUIRES>simple_times</REQUIRES>
      <EXAMPLE>product_of_squares_of_odd_elements_example</EXAMPLE>
      <EXPECTED>225</EXPECTED>
      <SCHEME>
(define (product-of-squares-of-odd-elements sequence)
  (accumulate *
              1
              (map square
                (filter odd? sequence))))
      </SCHEME>
      <PYTHON>
function product_of_squares_of_odd_elements(sequence) {
    return accumulate(times, 
                      1, 
                      map(square, 
                          filter(is_odd, sequence)));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>product_of_squares_of_odd_elements_example</NAME>
      <REQUIRES>product_of_squares_of_odd_elements</REQUIRES>
      <SCHEME>
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
      </SCHEME>
      <SCHEMEOUTPUT>
225
      </SCHEMEOUTPUT>
      <PYTHON>
product_of_squares_of_odd_elements(list(1, 2, 3, 4, 5));
      </PYTHON>
      <PYTHON_OUTPUT>
225
      </PYTHON_OUTPUT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    We can also formulate conventional data-processing applications in terms of
    sequence operations.  Suppose we have a sequence of personnel records and
    we want to find the salary of the highest-paid programmer. Assume that we
    have a selector <SCHEMEINLINE>salary</SCHEMEINLINE> that returns the salary
    of a record, and a predicate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>programmer?</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>is_programmer</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    that tests if a record is for a programmer.  Then we can write
    <SNIPPET HIDE="yes">
      <NAME>linus</NAME>
      <SCHEME>
      </SCHEME>
      <PYTHON>
const my_records = list(list("Linus", "programmer", 30000),
                        list("Richard", "programmer", 25000),
                        list("Bill", "manager", 2500000));
function is_programmer(record) {
    return head(tail(record)) === "programmer";
}
function salary(record) {
    return head(tail(tail(record)));
}
salary_of_highest_paid_programmer(my_records);
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <EXAMPLE>linus</EXAMPLE>
      <EXPECTED>30000</EXPECTED>
      <SCHEME>
(define (salary-of-highest-paid-programmer records)
  (accumulate max
              0
              (map salary
                   (filter programmer? records))))
      </SCHEME>
      <PYTHON>
function salary_of_highest_paid_programmer(records) {
    return accumulate(math_max, 
                      0, 
                      map(salary, 
                          filter(is_programmer, records)));
}
      </PYTHON>
    </SNIPPET>
    These examples give just a hint of the vast range of operations that
    can be expressed as sequence operations.<FOOTNOTE>
    <INDEX>Waters, Richard C.</INDEX>
    Richard Waters (1979) developed a program that automatically analyzes
    traditional 
    <INDEX>Fortran</INDEX>
    Fortran programs, viewing them in terms of maps, filters, and accumulations.
    He found that fully 90 percent of the code in the Fortran Scientific
    Subroutine Package fits neatly into this paradigm.  One of the reasons
    for the success of Lisp as a programming language is that lists provide a
    standard medium for expressing ordered collections so that they can be
    manipulated using higher-order operations. Many modern languages, such as
    Python, have learned this lesson.</FOOTNOTE>
  </TEXT>
  <TEXT>
    Sequences, implemented here as lists, serve as a conventional interface
    that permits us to combine processing modules.  Additionally, when we
    uniformly represent structures as sequences, we have localized the
    data-structure dependencies in our programs to a small number of sequence
    operations.  By changing these, we can experiment with alternative
    representations of sequences, while leaving the overall design of our
    programs intact.  We will exploit this capability in
    section<SPACE/><REF NAME="sec:streams"/>, when we generalize the
    sequence-processing paradigm to admit infinite sequences.
  </TEXT>

  <EXERCISE>
    Fill in the missing expressions to complete the following definitions of
    some basic list-manipulation operations as accumulations:
    <SNIPPET HIDE="yes">
      <NAME>map_append_length_example</NAME>
      <SCHEME>
      </SCHEME>
      <PYTHON>
map(math_sqrt, list(1, 2, 3, 4));
// append(list(1, 2, 3), list(4, 5, 6));
// length(list(1, 2, 3, 4));
      </PYTHON>
      <PYTHON_TEST>
tail(map(math_sqrt, list(1, 2, 3, 4)));
      </PYTHON_TEST>
    </SNIPPET>
    <SNIPPET LATEX="yes" POSTPADDING="no">
      <INDEX><USE>length</USE><SUBINDEX><ORDER>accumulation</ORDER>as accumulation</SUBINDEX><FRAGILE/></INDEX>
      <INDEX><USE>map</USE><SUBINDEX><ORDER>accumulation</ORDER>as accumulation</SUBINDEX><FRAGILE/></INDEX>
      <INDEX><USE>append</USE><SUBINDEX><ORDER>accumulation</ORDER>as accumulation</SUBINDEX><FRAGILE/></INDEX>
      <EXAMPLE>map_append_length_example</EXAMPLE>
      <SCHEME>
(define (map p sequence)
  (accumulate (lambda (x y) ??) nil sequence))

(define (append seq1 seq2)
  (accumulate cons ?? ??))

(define (length sequence)
  (accumulate ?? 0 sequence))
      </SCHEME>
      <PYTHON>
function map(f, sequence) {
    return accumulate((x, y) => <METAPHRASE>??</METAPHRASE>, 
                      null, sequence);
}
function append(seq1, seq2) {
    return accumulate(pair, <METAPHRASE>??</METAPHRASE>, <METAPHRASE>??</METAPHRASE>);
}
function length(sequence) {
    return accumulate(<METAPHRASE>??</METAPHRASE>, 0, sequence);
}
      </PYTHON>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<EXAMPLE>map_append_length_example</EXAMPLE>
	<EXPECTED>[ 1.4142135623730951, [ 1.7320508075688772, [ 2, null ] ] ]</EXPECTED>
	<PYTHON>
function map(f, sequence) {
    return accumulate((x, y) => pair(f(x), y),
                      null, 
                      sequence);
}
function append(seq1, seq2) {
    return accumulate(pair, seq2, seq1);
}
function length(sequence) {
    return accumulate((x, y) => y + 1,
                      0, 
                      sequence);
}
	</PYTHON>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:2_33"/>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:horner"/>
    Evaluating a
    polynomial in <LATEXINLINE>$x$</LATEXINLINE> at a given value
    of <LATEXINLINE>$x$</LATEXINLINE> can be formulated as an accumulation.
    We evaluate the polynomial
    <LATEX>
      \[ a_{n} x^n +a_{n-1}x^{n-1}+\cdots + a_{1} x+a_{0} \]
    </LATEX>
    using a well-known algorithm called 
    <INDEX>polynomial(s)<SUBINDEX>evaluating with Horner<APOS/>s rule</SUBINDEX></INDEX>
    <INDEX>Horner<APOS/>s rule</INDEX>
    <EM>Horner<APOS/>s rule</EM>, which structures the computation as
    <LATEX>
      \[ \left(\cdots (a_{n}  x+a_{n-1})x+\cdots +a_{1}\right) x+a_{0} \]
    </LATEX>
    In other words, we start with <LATEXINLINE>$a_{n}$</LATEXINLINE>, multiply
    by <LATEXINLINE>$x$</LATEXINLINE>, add <LATEXINLINE>$a_{n-1}$</LATEXINLINE>,
    multiply by <LATEXINLINE>$x$</LATEXINLINE>, and so on, until we reach
    <LATEXINLINE>$a_{0}$</LATEXINLINE>.<FOOTNOTE>According to 
    <INDEX>Knuth, Donald E.</INDEX>
    Knuth (1997b), this rule was formulated by
    <INDEX><ORDER>Horner</ORDER>Horner, W. G.</INDEX>
    W. G. Horner early in the nineteenth century, but the method was actually
    used by Newton over a hundred years earlier.  Horner<APOS/>s rule evaluates
    the polynomial using fewer additions and multiplications than does the
    straightforward method of first computing
    <LATEXINLINE>$a_{n} x^n$</LATEXINLINE>, then adding
    <LATEXINLINE>$a_{n-1}x^{n-1}$</LATEXINLINE>, and so on.  In fact, it is
    possible to prove that any algorithm for evaluating arbitrary polynomials
    must use at least as many additions and multiplications as does
    Horner<APOS/>s rule, and thus Horner<APOS/>s rule is an 
    <INDEX>algorithm<SUBINDEX>optimal</SUBINDEX></INDEX>
    <INDEX>optimality<SUBINDEX>of Horner<APOS/>s rule</SUBINDEX></INDEX>
    optimal algorithm for polynomial evaluation.  This was proved (for the
    number of additions) by
    <INDEX>Ostrowski, A. M.</INDEX>
    A. M. Ostrowski in a 1954 paper that essentially founded the modern study
    of optimal algorithms.  The analogous statement for multiplications was
    proved by 
    <INDEX>Pan, V. Y.</INDEX>
    V. Y. Pan in 1966.  The book by 
    <INDEX>Borodin, Alan</INDEX>
    <INDEX>Munro, Ian</INDEX>
    <CITATION>
      Borodin and Munro (1975)
    </CITATION> 
    provides an overview of these and other results about optimal
    algorithms.</FOOTNOTE>
    Fill in the following template to produce a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    that evaluates a polynomial using Horner<APOS/>s rule. Assume that the
    coefficients of the polynomial are arranged in a sequence, from
    <LATEXINLINE>$a_{0}$</LATEXINLINE> through
    <LATEXINLINE>$a_{n}$</LATEXINLINE>.
    <SNIPPET LATEX="yes">
      <NAME>horner</NAME>
      <EXAMPLE>horner_eval_example</EXAMPLE>
      <SCHEME>
(define (horner-eval x coefficient-sequence)
   (accumulate (lambda (this-coeff higher-terms) ??)
               0
               coefficient-sequence))
      </SCHEME>
      <PYTHON>
function horner_eval(x, coefficient_sequence) {
    return accumulate((this_coeff, higher_terms) => <METAPHRASE>??</METAPHRASE>,
                      0, 
                      coefficient_sequence);
}
      </PYTHON>
    </SNIPPET>
    For example, to compute <LATEXINLINE>$1+3x+5x^3+x^5$</LATEXINLINE> at
    <LATEXINLINE>$x=2$</LATEXINLINE> you would evaluate
    <SNIPPET POSTPADDING="no">
      <NAME>horner_eval_example</NAME>
      <REQUIRES>horner</REQUIRES>
      <SCHEME>
(horner-eval 2 (list 1 3 0 5 0 1))
      </SCHEME>
      <PYTHON>
horner_eval(2, list(1, 3, 0, 5, 0, 1));
      </PYTHON>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>horner_solution</NAME>
	<EXAMPLE>horner_eval_example_2</EXAMPLE>
	<EXPECTED>79</EXPECTED>
	<PYTHON>
function horner_eval(x, coefficient_sequence) {
    return accumulate((this_coeff, higher_terms) => 
                      x * higher_terms + this_coeff,
                      0, 
                      coefficient_sequence);
}
	</PYTHON>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
      <SNIPPET HIDE="yes" POSTPADDING="no">
	<NAME>horner_eval_example_2</NAME>
	<REQUIRES>horner_solution</REQUIRES>
	<EXAMPLE>horner_eval_example</EXAMPLE>
	<SCHEME>
(horner-eval 2 (list 1 3 0 5 0 1))
	</SCHEME>
	<PYTHON>
horner_eval(2, list(1, 3, 0, 5, 0, 1));
	</PYTHON>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:countleaves-as-accumulation"/>
    Redefine
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>count-leaves</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>count_leaves</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    from section<SPACE/><REF NAME="sec:trees"/> as an accumulation:
    <SNIPPET POSTPADDING="no" LATEX="yes">
      <INDEX><USE>count_leaves</USE><SUBINDEX><ORDER>accumulation</ORDER>as accumulation</SUBINDEX><FRAGILE/></INDEX>
      <EXAMPLE>count_leaves_example</EXAMPLE>
      <SCHEME>
(define (count-leaves t)
   (accumulate ?? ?? (map ?? ??)))
          </SCHEME>
          <PYTHON>
function count_leaves(t) {
    return accumulate(<METAPHRASE>??</METAPHRASE>, <METAPHRASE>??</METAPHRASE>, map(<METAPHRASE>??</METAPHRASE>, <METAPHRASE>??</METAPHRASE>));
}
          </PYTHON>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<EXAMPLE>count_leaves_example</EXAMPLE>
	<EXPECTED>4</EXPECTED>
	<PYTHON>
function count_leaves(t) {
    return accumulate((leaves, total) => leaves + total,
                      0, 
		      map(sub_tree => is_pair(sub_tree)
		                      ? count_leaves(sub_tree)
                                      : 1,
			  t));
}
	</PYTHON>
	<SCHEME>
	</SCHEME>
    </SNIPPET></SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:accumulate-n"/>
    The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>accumulate-n</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>accumulate_n</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    is similar to
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>accumulate</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>accumulate</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    except that it takes as its third argument a sequence of sequences, which
    are all assumed to have the same number of elements.  It applies the
    designated accumulation
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    to combine all the first elements of the sequences, all the second elements
    of the sequences, and so on, and returns a sequence of the results.  For
    instance, if <SCHEMEINLINE>s</SCHEMEINLINE> is a sequence containing four
    sequences
    <SNIPPET EVAL="no">
      <SCHEME>
((1 2 3) (4 5 6) (7 8 9) (10 11 12))
      </SCHEME>
      <PYTHON>
list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9), list(10, 11, 12))
      </PYTHON>
    </SNIPPET>
    then the value of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>(accumulate-n + 0 s)</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>accumulate_n(plus, 0, s)</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    should be the sequence
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(22 26 30)</SCHEMEINLINE>.</SCHEME>
      <PYTHON><PYTHONINLINE>list(22, 26, 30)</PYTHONINLINE>.
      </PYTHON>
    </SPLITINLINE>
    Fill in the missing expressions in the following definition of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>accumulate-n</SCHEMEINLINE>:</SCHEME>
      <PYTHON><PYTHONINLINE>accumulate_n</PYTHONINLINE>:
      </PYTHON>
    </SPLITINLINE>
    <SNIPPET LATEX="yes">
      <INDEX><USE>accumulate_n</USE><FRAGILE/></INDEX> 
      <EXAMPLE>example_2.36</EXAMPLE>
      <SCHEME>
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
     nil
     (cons (accumulate op init ??)
           (accumulate-n op init ??))))
      </SCHEME>
      <PYTHON>
function accumulate_n(op, init, seqs) {
    return is_null(head(seqs))
           ? null
           : pair(accumulate(op, init, <METAPHRASE>??</METAPHRASE>), 
                  accumulate_n(op, init, <METAPHRASE>??</METAPHRASE>));
}
      </PYTHON>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET POSTPADDING="no">
	<NAME>accumulate_n</NAME>
	<EXAMPLE>example_2.36</EXAMPLE>
	<EXPECTED>[ 22, [ 26, [ 30, null ] ] ]</EXPECTED>
	<PYTHON>
function accumulate_n(op, init, seqs) {
    return is_null(head(seqs))
           ? null
           : pair(accumulate(op, init, map(x => head(x), seqs)),
                  accumulate_n(op, init, map(x => tail(x), seqs)));
}
	</PYTHON>
	<SCHEME>
	</SCHEME>
    </SNIPPET></SOLUTION>
    <SNIPPET HIDE="yes">
      <NAME>example_2.36</NAME>
      <REQUIRES>simple_plus</REQUIRES>
      <PYTHON>
const seq_seq = list(list(1, 2, 3), list(4, 5, 6), 
                     list(7, 8, 9), list(10, 11, 12));
accumulate_n(plus, 0, seq_seq);
      </PYTHON>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:matrix-ops"/>
    Suppose we represent vectors <LATEXINLINE>$v=(v_{i})$</LATEXINLINE> as
    <INDEX>matrix, represented as sequence</INDEX>
    <INDEX>vector (mathematical)<SUBINDEX>represented as sequence</SUBINDEX></INDEX>
    <INDEX>vector (mathematical)<SUBINDEX>operations on</SUBINDEX></INDEX>
    sequences of numbers, and matrices <LATEXINLINE>$m=(m_{ij})$</LATEXINLINE>
    as sequences of vectors (the rows of the matrix). For example, the matrix
    <LATEX>
      \[ \left[ 
      \begin{array}{llll}
      1 &amp; 2 &amp; 3 &amp; 4\\
      4 &amp; 5 &amp; 6 &amp; 6\\
      6 &amp; 7 &amp; 8 &amp; 9\\
      \end{array}
      \right] \]
    </LATEX>
    <SPLIT>
      <SCHEME>
        is represented as the sequence
	<SCHEMEINLINE>((1 2 3 4) (4 5 6 6) (6 7 8 9))</SCHEMEINLINE>.
      </SCHEME>
      <PYTHON>
	is represented as the following sequence:
	<SNIPPET EVAL="no">
	  <PYTHON>
list(list(1, 2, 3, 4),
     list(4, 5, 6, 6),
     list(6, 7, 8, 9))
	  </PYTHON>
	</SNIPPET>
      </PYTHON>
    </SPLIT>
    With this representation, we can use sequence operations to concisely
    express the basic matrix and vector operations.  These operations
    (which are described in any book on matrix algebra) are the following:
    <TABLE>
      <TR>
	<TD>
        <SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>(dot-product </SCHEMEINLINE>
	    <LATEXINLINE>$v$ $w$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE>
	  </SCHEME>
	  <PYTHON>
	    <PYTHONINLINE>dot_product(</PYTHONINLINE><LATEXINLINE>$v$</LATEXINLINE><PYTHONINLINE>,
	  </PYTHONINLINE><LATEXINLINE>$w$</LATEXINLINE><PYTHONINLINE>)</PYTHONINLINE></PYTHON>
	</SPLITINLINE>
	</TD>
	<TD>
	returns the sum <LATEXINLINE>$\sum_{i}v_{i} w_{i}$</LATEXINLINE>;
	</TD>
      </TR>
      <TR>
	<TD>
        <SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>(matrix-*-vector
	  </SCHEMEINLINE><LATEXINLINE>$m$</LATEXINLINE> <LATEXINLINE>$v$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE></SCHEME>
	  <PYTHON><PYTHONINLINE>matrix_times_vector(</PYTHONINLINE><LATEXINLINE>$m$</LATEXINLINE><PYTHONINLINE>,
	  </PYTHONINLINE><LATEXINLINE>$v$</LATEXINLINE><PYTHONINLINE>)</PYTHONINLINE></PYTHON>
	</SPLITINLINE>
	</TD>
	<TD>
	returns the vector <LATEXINLINE>$t$</LATEXINLINE>, where
	<LATEXINLINE>$t_{i} =\sum_{j}m_{ij}v_{j}$</LATEXINLINE>;
	</TD>
      </TR>
      <TR>
	<TD>
        <SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>(matrix-*-matrix </SCHEMEINLINE>
	    <LATEXINLINE>$m\ n$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE>
	  </SCHEME>
	  <PYTHON>
	    <PYTHONINLINE>matrix_times_matrix(</PYTHONINLINE><LATEXINLINE>$m$</LATEXINLINE><PYTHONINLINE>,
	  </PYTHONINLINE><LATEXINLINE>$n$</LATEXINLINE><PYTHONINLINE>)</PYTHONINLINE></PYTHON>
	</SPLITINLINE>
	</TD>
	<TD>
	returns the matrix <LATEXINLINE>$p$</LATEXINLINE>, where
	<LATEXINLINE>$p_{ij}=\sum_{k} m_{ik}n_{kj}$</LATEXINLINE>;
	</TD>
      </TR>
      <TR>
	<TD>
        <SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>(transpose
	    <LATEXINLINE>$m$</LATEXINLINE>)</SCHEMEINLINE></SCHEME><PYTHON><PYTHONINLINE>transpose(</PYTHONINLINE><LATEXINLINE>$m$</LATEXINLINE><PYTHONINLINE>)</PYTHONINLINE></PYTHON>
	</SPLITINLINE>
	</TD>
	<TD>
	returns the matrix <LATEXINLINE>$n$</LATEXINLINE>, where
	<LATEXINLINE>$n_{ij}=m_{ji}$</LATEXINLINE>.
	</TD>
      </TR>
    </TABLE>
    We can define the dot product as<FOOTNOTE>This definition uses
    <SPLITINLINE>
      <SCHEME>
	the extended version of <SCHEMEINLINE>map</SCHEMEINLINE>
	described in footnote<SPACE/><REF NAME="foot:generalmap"/>.
      </SCHEME>
      <PYTHON>
	the function <PYTHONINLINE>accumulate_n</PYTHONINLINE>
	from exercise<SPACE/><REF NAME="ex:accumulate-n"/>.
      </PYTHON>
    </SPLITINLINE></FOOTNOTE>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>dot_product</DECLARATION><FRAGILE/></INDEX> 
      <NAME>dot_product</NAME>
      <EXAMPLE>dot_product_example</EXAMPLE>
      <EXPECTED>11</EXPECTED>
      <REQUIRES>simple_plus</REQUIRES>
      <REQUIRES>simple_times</REQUIRES>
      <REQUIRES>accumulate_n</REQUIRES>
      <SCHEME>
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
      </SCHEME>
      <PYTHON>
function dot_product(v, w) {
    return accumulate(plus, 0, accumulate_n(times, 1, list(v, w)));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>dot_product_example</NAME>
      <SCHEME>
(dot-product (list 1 2) (list 3 4))
      </SCHEME>
      <PYTHON>
dot_product(list(1, 2), list(3, 4));
      </PYTHON>
    </SNIPPET>
    Fill in the missing expressions in the following
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    for computing the other matrix operations.  (The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>accumulate-n</SCHEMEINLINE>
	is defined in 	
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>accumulate_n</PYTHONINLINE>
	is declared in       
      </PYTHON>
    </SPLITINLINE>
    exercise<SPACE/><REF NAME="ex:accumulate-n"/>.)
    <SNIPPET POSTPADDING="no" LATEX="yes">
      <INDEX><USE>matrix_times_vector</USE><FRAGILE/></INDEX> 
      <INDEX><USE>matrix_times_matrix</USE><FRAGILE/></INDEX> 
      <INDEX><USE>transpose</USE> a matrix<FRAGILE/></INDEX>
      <SCHEME>
(define (matrix-*-vector m v)
  (map ?? m))

(define (transpose mat)
  (accumulate-n ?? ?? mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map ?? m)))
      </SCHEME>
      <PYTHON>
function matrix_times_vector(m, v) {
    return map(<METAPHRASE>??</METAPHRASE>, m);
}
function transpose(mat) {
    return accumulate_n(<METAPHRASE>??</METAPHRASE>, <METAPHRASE>??</METAPHRASE>, mat);
}
function matrix_times_matrix(n, m) {
    const cols = transpose(n);
    return map(<METAPHRASE>??</METAPHRASE>, m);
}
      </PYTHON>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>exercise_2_37_solution</NAME>
	<REQUIRES>accumulate_n</REQUIRES>
	<REQUIRES>dot_product</REQUIRES>
	<EXAMPLE>example_2.37</EXAMPLE>
	<EXPECTED>[ 140, [ 160, [ 60, null ] ] ]</EXPECTED>
	<PYTHON>
function matrix_times_vector(m, v) {
    return map(row => dot_product(row, v), m);
}
function transpose(mat) {
    return accumulate_n(pair, null, mat);
}
function matrix_times_matrix(n, m) {
    const cols = transpose(m);
    return map(x => map(y => dot_product(x, y), cols), n);
}
	</PYTHON>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
    <SNIPPET HIDE="yes">
      <NAME>example_2.37</NAME>
      <PYTHON>
const v = list(10, 20, 30);
const m1 = list(list(1, 2, 3), list(3, 5, 1), list(1, 1, 1));
const m2 = list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9));

matrix_times_vector(m1, v);
// transpose(m1);
// matrix_times_matrix(m1, m2);
      </PYTHON>
      <SCHEME>
      </SCHEME>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:fold-right-left"/>
    The
     <INDEX><USE>accumulate</USE><SUBINDEX><ORDER>same as fold right</ORDER>same as <SCHEMEINLINE>fold_right</SCHEMEINLINE></SUBINDEX></INDEX>
     <INDEX><USE>fold_right</USE></INDEX> 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>accumulate</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>accumulate</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    is also known as
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>fold-right</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>fold_right</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    because it combines the first element of the sequence with the result
    of combining all the elements to the right.  There is also a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>fold-left</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>fold_left</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    which is similar to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>fold-right</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>fold_right</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    except that it combines elements working in the opposite direction:
    <SNIPPET>
      <INDEX><DECLARATION>fold_left</DECLARATION><FRAGILE/></INDEX> 
      <NAME>fold_left</NAME>
      <EXAMPLE>fold_left_example</EXAMPLE>
      <EXPECTED>[ [ [ null, [ 1, null ] ], [ 2, null ] ], [ 3, null ] ]</EXPECTED>
      <SCHEME>
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
      result
      (iter (op result (car rest))
            (cdr rest))))
  (iter initial sequence))
      </SCHEME>
      <PYTHON>
function fold_left(op, initial, sequence) {
    function iter(result, rest) {
        return is_null(rest)
               ? result
               : iter(op(result, head(rest)), 
                      tail(rest));
    }
    return iter(initial, sequence);
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>fold_right</NAME>
      <EXAMPLE>fold_right_example</EXAMPLE>
      <SCHEME>
;; same as accumulate
(define fold_right accumulate)
      </SCHEME>
      <PYTHON>
// same as accumulate
const fold_right = accumulate;
      </PYTHON>
    </SNIPPET>
    What are the values of
    <SNIPPET HIDE="yes">
      <NAME>simple_divide</NAME>
      <SCHEME>
;; in Scheme, the operator symbol * is procedure name
      </SCHEME>
      <PYTHON>
function divide(x, y) {
    return x / y;
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>fold_right_example_1</NAME>
      <REQUIRES>fold_right</REQUIRES>
      <REQUIRES>simple_divide</REQUIRES>
      <SCHEME>
(fold-right / 1 (list 1 2 3))
      </SCHEME>
      <PYTHON>
fold_right(divide, 1, list(1, 2, 3));
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>fold_left_example_1</NAME>
      <REQUIRES>fold_left</REQUIRES>
      <REQUIRES>simple_divide</REQUIRES>
      <SCHEME>
(fold-left / 1 (list 1 2 3))
      </SCHEME>
      <PYTHON>
fold_left(divide, 1, list(1, 2, 3));
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>fold_right_example</NAME>
      <REQUIRES>fold_right</REQUIRES>
      <SCHEME>
(fold-right list nil (list 1 2 3))
      </SCHEME>
      <PYTHON>
fold_right(list, null, list(1, 2, 3));
      </PYTHON>
      <PYTHON_TEST>
length(fold_right(list, null, list(1, 2, 3)));
      </PYTHON_TEST>
    </SNIPPET>
    <SNIPPET>
      <NAME>fold_left_example</NAME>
      <REQUIRES>fold_left</REQUIRES>
      <SCHEME>
(fold-left list nil (list 1 2 3))
      </SCHEME>
      <PYTHON>
fold_left(list, null, list(1, 2, 3));
      </PYTHON>
    </SNIPPET>
    Give a property that
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>op</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>op</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    should satisfy to guarantee that
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>fold-right</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>fold_right</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>fold-left</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>fold_left</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    will produce the same values for any sequence.
    <SOLUTION>
      <OL>
	<LI>
          <SNIPPET>
	    <NAME>fold_right_example_1_solution</NAME>
	    <REQUIRES>fold_right_example_1</REQUIRES>
	    <EXPECTED>1.5</EXPECTED>
            <SCHEME>
            </SCHEME>
            <PYTHON>
1.5
            </PYTHON>
            <PYTHON_RUN>
// result: 1.5
            </PYTHON_RUN>
          </SNIPPET>
	</LI>
	<LI>
          <SNIPPET>
	    <NAME>fold_left_example_1_solution</NAME>
	    <REQUIRES>fold_left_example_1</REQUIRES>
	    <EXPECTED>0.16666666666666666</EXPECTED>
            <SCHEME>
            </SCHEME>
            <PYTHON>
0.16666666666666666
            </PYTHON>
            <PYTHON_RUN>
// result: 0.16666666666666666
            </PYTHON_RUN>
          </SNIPPET>
	</LI>
	<LI>
          <SNIPPET>
	    <NAME>fold_right_example_solution</NAME>
	    <REQUIRES>fold_right_example</REQUIRES>
	    <EXPECTED>2</EXPECTED>
            <SCHEME>
            </SCHEME>
            <PYTHON>
[1, [[2, [[3, [null, null]], null]], null]]
            </PYTHON>
            <PYTHON_RUN>
// result: [1, [[2, [[3, [null, null]], null]], null]]
            </PYTHON_RUN>
          </SNIPPET>
	</LI>
	<LI>
          <SNIPPET>
	    <NAME>fold_left_example_solution</NAME>
	    <REQUIRES>fold_left_example</REQUIRES>
	    <EXPECTED>[ [ [ null, [ 1, null ] ], [ 2, null ] ], [ 3, null ] ]</EXPECTED>
            <SCHEME>
            </SCHEME>
            <PYTHON>
[[[null, [1, null]], [2, null]], [3, null]]
            </PYTHON>
            <PYTHON_RUN>
// result: [[[null, [1, null]], [2, null]], [3, null]]
            </PYTHON_RUN>
          </SNIPPET>
	</LI>
      </OL>
      We can guarantee that <PYTHONINLINE>fold_right</PYTHONINLINE>
      and <PYTHONINLINE>fold_left</PYTHONINLINE> produce
      the same values for any sequence, if we require that
      <PYTHONINLINE>op</PYTHONINLINE> is commutative and associative.
      They also produce the same values, if
      <PYTHONINLINE>op</PYTHONINLINE> is just associative and the
      argument <PYTHONINLINE>initial</PYTHONINLINE> is a left and right
      neutral element with respect to <PYTHONINLINE>op</PYTHONINLINE>.
      <SNIPPET>
	<REQUIRES>simple_plus</REQUIRES>
	<REQUIRES>fold_right</REQUIRES>
	<EXPECTED>6</EXPECTED>
	<PYTHON>
fold_right(plus, 0, list(1, 2, 3));
	</PYTHON>
      </SNIPPET>
      <SNIPPET>
	<REQUIRES>simple_plus</REQUIRES>
	<REQUIRES>fold_left</REQUIRES>
	<EXPECTED>6</EXPECTED>
	<PYTHON>
fold_left(plus, 0, list(1, 2, 3));
	</PYTHON>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    Complete the following definitions of <SCHEMEINLINE>reverse</SCHEMEINLINE>
     <INDEX><USE>reverse</USE><SUBINDEX><ORDER>folding</ORDER>as folding</SUBINDEX></INDEX>
    (exercise<SPACE/><REF NAME="ex:reverse"/>) in terms of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>fold-right</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>fold_right</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>fold-left</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>fold_left</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    from exercise<SPACE/><REF NAME="ex:fold-right-left"/>:
    <SNIPPET LATEX="yes">
      <EXAMPLE>reverse_example</EXAMPLE>
      <SCHEME>
(define (reverse sequence)
  (fold-right (lambda (x y) ??) nil sequence))
      </SCHEME>
      <PYTHON>
function reverse(sequence) {
    return fold_right((x, y) => <METAPHRASE>??</METAPHRASE>, null, sequence);
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET LATEX="yes" POSTPADDING="no">
      <EXAMPLE>reverse_example</EXAMPLE>
      <SCHEME>
(define (reverse sequence)
  (fold-left (lambda (x y) ??) nil sequence))
      </SCHEME>
      <PYTHON>
function reverse(sequence) {
    return fold_left((x, y) => <METAPHRASE>??</METAPHRASE>, null, sequence);
}
      </PYTHON>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>reverse_example_2</NAME>
	<PYTHON>
reverse(list(1, 4, 5, 9, 16, 25));
	</PYTHON>
	<PYTHON_TEST>
head(reverse(list(1, 4, 5, 9, 16, 25)));
	</PYTHON_TEST>
      </SNIPPET>
      <SNIPPET>
	<REQUIRES>fold_right</REQUIRES>
	<EXAMPLE>reverse_example_2</EXAMPLE>
	<EXPECTED>25</EXPECTED>
	<PYTHON>
function reverse(sequence) {
    return fold_right((x, y) => append(y, list(x)), 
                      null, sequence);
}
	</PYTHON>
      </SNIPPET>
      <SNIPPET>
	<REQUIRES>fold_left</REQUIRES>
	<EXAMPLE>reverse_example_2</EXAMPLE>
	<EXPECTED>25</EXPECTED>
	<PYTHON>
function reverse(sequence) {
    return fold_left((x, y) => pair(y, x), null, sequence);
}
	</PYTHON>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:2_39"/>
  </EXERCISE>

  <INDEX>sequence(s)<SUBINDEX>operations on</SUBINDEX><CLOSE/></INDEX>

  <SUBHEADING>
    <NAME>Nested Mappings</NAME>
  </SUBHEADING>

  <LABEL NAME="sec:nested-mappings"/>
  <INDEX>mapping<SUBINDEX>nested</SUBINDEX><OPEN/></INDEX>

  <TEXT>
    We can extend the sequence paradigm to include many computations that are
    commonly expressed using nested loops.<FOOTNOTE>This approach to nested
    mappings was shown to us by 
    <INDEX>Turner, David</INDEX>
    David Turner, whose languages 
    <INDEX>KRC</INDEX>
    KRC and 
    <INDEX>Miranda</INDEX>
    Miranda provide elegant formalisms for dealing with these constructs.  The
    examples in this section (see also
    exercise<SPACE/><REF NAME="ex:8queens"/>) are adapted from Turner 1981.
    In section<SPACE/><REF NAME="sec:exploiting-streams"/>, we<APOS/>ll see
    how this approach generalizes to infinite sequences.</FOOTNOTE>
    Consider this problem: Given a positive integer
    <LATEXINLINE>$n$</LATEXINLINE>, find all ordered pairs of distinct positive
    integers <LATEXINLINE>$i$</LATEXINLINE> and <LATEXINLINE>$j$</LATEXINLINE>,
    where <LATEXINLINE>$1\leq j &lt; i\leq n$</LATEXINLINE>, such that
    <LATEXINLINE>$i +j$</LATEXINLINE> is prime.  For example, if
    <LATEXINLINE>$n$</LATEXINLINE> is 6, then the pairs are the following:
    <LATEX>
      \[
      \begin{array}{c|ccccccc}
      i     &amp; 2 &amp; 3 &amp; 4 &amp; 4 &amp; 5 &amp; 6 &amp; 6 \\
      j     &amp; 1 &amp; 2 &amp; 1 &amp; 3 &amp; 2 &amp; 1 &amp; 5 \\
      \hline
      i+j   &amp; 3 &amp; 5 &amp; 5 &amp; 7 &amp; 7 &amp; 7 &amp; 11
      \end{array}
      \]
    </LATEX>
    A natural way to organize this computation is to generate the sequence
    of all ordered pairs of positive integers less than or equal to
    <LATEXINLINE>$n$</LATEXINLINE>, filter to select those pairs whose sum is
    prime, and then, for each pair <LATEXINLINE>$(i, j)$</LATEXINLINE> that
    passes through the filter, produce the triple
    <LATEXINLINE>$(i, j, i+j)$</LATEXINLINE>.
  </TEXT>

  <TEXT>
    Here is a way to generate the sequence of pairs: For each integer
    <LATEXINLINE>$i\leq n$</LATEXINLINE>, enumerate the integers
    <LATEXINLINE>$j &lt; i$</LATEXINLINE>, and for each such
    <LATEXINLINE>$i$</LATEXINLINE> and <LATEXINLINE>$j$</LATEXINLINE>
    generate the pair <LATEXINLINE>$(i, j)$</LATEXINLINE>.  In terms of
    sequence operations, we map along the sequence
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(enumerate-interval 1 n)</SCHEMEINLINE>.</SCHEME>
      <PYTHON><PYTHONINLINE>enumerate_interval(1, n)</PYTHONINLINE>.
      </PYTHON>
    </SPLITINLINE>
    For each <LATEXINLINE>$i$</LATEXINLINE> in this sequence, we map along the
    sequence
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(enumerate-interval 1 (- i 1))</SCHEMEINLINE>.
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>enumerate_interval(1, i - 1)</PYTHONINLINE>.
      </PYTHON>
    </SPLITINLINE>
    For each <LATEXINLINE>$j$</LATEXINLINE> in this latter sequence, we
    generate the pair
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(list i j)</SCHEMEINLINE>.</SCHEME>
      <PYTHON><PYTHONINLINE>list(i, j)</PYTHONINLINE>.</PYTHON>
    </SPLITINLINE>
    This gives us a sequence of pairs for each <LATEXINLINE>$i$</LATEXINLINE>.
    Combining all the sequences for all the <LATEXINLINE>$i$</LATEXINLINE> (by
    accumulating with <SCHEMEINLINE>append</SCHEMEINLINE>) produces the
    required sequence of pairs:<FOOTNOTE>We<APOS/>re representing a pair here
    as a list of two elements rather than as
    <SPLITINLINE>
      <SCHEME>a Lisp pair.</SCHEME>
    <PYTHON>an ordinary pair.</PYTHON></SPLITINLINE>
    Thus, the <QUOTE>pair</QUOTE> <LATEXINLINE>$(i, j)$</LATEXINLINE> is
    represented as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(list i j)</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>list(i, j)</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    not
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(cons i j)</SCHEMEINLINE>.</SCHEME>
      <PYTHON><PYTHONINLINE>pair(i, j)</PYTHONINLINE>.</PYTHON>
    </SPLITINLINE></FOOTNOTE>
    <SNIPPET HIDE="yes">
      <NAME>enumerate_interval_n</NAME>
      <SCHEME>
      </SCHEME>
      <PYTHON>
const n = 6;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <REQUIRES>enumerate_interval</REQUIRES>
      <REQUIRES>enumerate_interval_n</REQUIRES>
      <EXPECTED>15</EXPECTED>
      <SCHEME>
;; replace n below by the desired number
(accumulate append
  nil
  (map (lambda (i)
         (map (lambda (j) (list i j))
              (enumerate-interval 1 (- i 1))))
       (enumerate-interval 1 n)))
      </SCHEME>
      <PYTHON>
accumulate(append, 
           null, 
           map(i => map(j => list(i, j),
                        enumerate_interval(1, i - 1)),
               enumerate_interval(1, n)));
      </PYTHON>
      <PYTHON_TEST>
length(accumulate(append, 
           null, 
           map(i => map(j => list(i, j),
                        enumerate_interval(1, i - 1)),
               enumerate_interval(1, n))));
      </PYTHON_TEST>
    </SNIPPET>
    The combination of mapping and accumulating with
    <SCHEMEINLINE>append</SCHEMEINLINE> is so common in this sort of program
    that we will isolate it as a separate
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <PYTHON>function:</PYTHON>
      </SPLITINLINE>
    <SNIPPET>
      <INDEX><DECLARATION>flatmap</DECLARATION></INDEX>
      <NAME>flatmap</NAME>
      <EXAMPLE>flatmap_example</EXAMPLE>
      <EXPECTED>8</EXPECTED>
      <SCHEME>
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
          </SCHEME>
          <PYTHON>
function flatmap(f, seq) {
    return accumulate(append, null, map(f, seq));
}
          </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>flatmap_example</NAME>
      <SCHEME>
      </SCHEME>
      <PYTHON>
flatmap(x => list(x, x), list(1, 2, 3, 4));
      </PYTHON>
      <PYTHON_TEST>
length(flatmap(x => list(x, x), list(1, 2, 3, 4)));
      </PYTHON_TEST>
    </SNIPPET>
    Now filter this sequence of pairs to find those whose sum is prime. The
    filter predicate is called for each element of the sequence; its argument
    is a pair and it must extract the integers from the pair. Thus, the
    predicate to apply to each element in the sequence is
    <SNIPPET>
      <NAME>prime_sum</NAME>
      <REQUIRES>prime_definition</REQUIRES>
      <EXAMPLE>prime_sum_example</EXAMPLE>
      <EXPECTED>true</EXPECTED>
      <SCHEME>
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
      </SCHEME>
      <PYTHON>
function is_prime_sum(pair) {
    return is_prime(head(pair) + head(tail(pair)));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>prime_sum_example</NAME>
      <SCHEME>
(prime-sum? (list 8 9))
      </SCHEME>
      <PYTHON>
is_prime_sum(list(8, 9));
      </PYTHON>
    </SNIPPET>
    Finally, generate the sequence of results by mapping over the filtered
    pairs using the following
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <PYTHON>function,</PYTHON>
    </SPLITINLINE>
    which constructs a triple consisting of the two elements of the pair along
    with their sum:
    <SNIPPET>
      <NAME>make_pair_sum</NAME>
      <EXAMPLE>make_pair_sum_example</EXAMPLE>
      <EXPECTED>[ 8, [ 9, [ 17, null ] ] ]</EXPECTED>
      <SCHEME>
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
      </SCHEME>
      <PYTHON>
function make_pair_sum(pair) {
    return list(head(pair), head(tail(pair)), 
                head(pair) + head(tail(pair)));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_pair_sum_example</NAME>
      <SCHEME>
(make-pair-sum (list 8 9))
      </SCHEME>
      <PYTHON>
make_pair_sum(list(8, 9));
      </PYTHON>
    </SNIPPET>
    Combining all these steps yields the complete
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <PYTHON>function:</PYTHON>
    </SPLITINLINE>
    <SNIPPET>
      <INDEX><DECLARATION>prime_sum_pairs</DECLARATION></INDEX> 
      <NAME>prime_sum_pairs</NAME>
      <REQUIRES>make_pair_sum</REQUIRES>
      <REQUIRES>prime_sum</REQUIRES>
      <REQUIRES>flatmap</REQUIRES>
      <REQUIRES>enumerate_interval</REQUIRES>
      <EXAMPLE>prime_sum_pairs_example</EXAMPLE>
      <EXPECTED>7</EXPECTED>
      <SCHEME>
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                 (lambda (i)
                   (map (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))))
      </SCHEME>
      <PYTHON>
function prime_sum_pairs(n) {
    return map(make_pair_sum, 
               filter(is_prime_sum, 
                      flatmap(i => map(j => list(i, j), 
                                       enumerate_interval(1, i - 1)),
                              enumerate_interval(1, n))));
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>prime_sum_pairs_example</NAME>
      <SCHEME>
(prime-sum-pairs 15)
      </SCHEME>
      <PYTHON>
prime_sum_pairs(6);
      </PYTHON>
      <PYTHON_TEST>
length(prime_sum_pairs(6));
      </PYTHON_TEST>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Nested mappings are also useful for sequences other than those that
    enumerate intervals.  Suppose we wish to generate all the 
    <INDEX>set<SUBINDEX>permutations of</SUBINDEX></INDEX>
    <INDEX>permutations of a set</INDEX>
    permutations
    of a set <LATEXINLINE>$S$</LATEXINLINE>; that is, all the ways of ordering
    the items in the set.  For instance, the permutations of
    <LATEXINLINE>$\{1, 2, 3\}$</LATEXINLINE> are
    <LATEXINLINE>$\{1, 2, 3\}$</LATEXINLINE>,
    <LATEXINLINE>$\{ 1, 3, 2\}$</LATEXINLINE>,
    <LATEXINLINE>$\{2, 1, 3\}$</LATEXINLINE>,
    <LATEXINLINE>$\{ 2, 3, 1\}$</LATEXINLINE>,
    <LATEXINLINE>$\{ 3, 1, 2\}$</LATEXINLINE>, and
    <LATEXINLINE>$\{ 3, 2, 1\}$</LATEXINLINE>.  Here is a plan for generating
    the permutations of<SPACE/><LATEXINLINE>$S$</LATEXINLINE>: For each item
    <LATEXINLINE>$x$</LATEXINLINE> in <LATEXINLINE>$S$</LATEXINLINE>,
    recursively generate the sequence of permutations of
    <LATEXINLINE>$S-x$</LATEXINLINE>,<FOOTNOTE>The set
    <LATEXINLINE>$S-x$</LATEXINLINE> is the set of all elements of
    <LATEXINLINE>$S$</LATEXINLINE>, excluding
    <LATEXINLINE>$x$</LATEXINLINE>.</FOOTNOTE> and adjoin
    <LATEXINLINE>$x$</LATEXINLINE> to the front of each one.  This yields, for
    each <LATEXINLINE>$x$</LATEXINLINE> in <LATEXINLINE>$S$</LATEXINLINE>, the
    sequence of permutations of <LATEXINLINE>$S$</LATEXINLINE> that begin
    with<SPACE/><LATEXINLINE>$x$</LATEXINLINE>.  Combining these sequences for
    all <LATEXINLINE>$x$</LATEXINLINE> gives all the permutations
    of<SPACE/><LATEXINLINE>$S$</LATEXINLINE>:<FOOTNOTE>
    <INDEX><ORDER>0a5</ORDER><PYTHONINLINE>//</PYTHONINLINE> (for comments in programs)</INDEX>
    <INDEX>comments in programs</INDEX>
    <INDEX>program<SUBINDEX>comments in</SUBINDEX></INDEX>
    <INDEX>slash (double slash <PYTHONINLINE>//</PYTHONINLINE> for comments in programs)</INDEX>
    <SPLITINLINE>
      <SCHEME>Semicolons in Scheme code are</SCHEME>
      <PYTHON>The character sequence <PYTHONINLINE>//</PYTHONINLINE>
      in JavaScript programs is</PYTHON>
    </SPLITINLINE>
    used to introduce <EM>comments</EM>. Everything from
    <SPLITINLINE>
      <SCHEME>the semicolon</SCHEME>
      <PYTHON><PYTHONINLINE>//</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    to the end of the line is ignored by the interpreter.  In this book we
    don<APOS/>t use many comments; we try to make our programs self-documenting
    by using descriptive names.</FOOTNOTE>
    <INDEX>permutations of a set<SUBINDEX><DECLARATION>permutations</DECLARATION></SUBINDEX></INDEX>
    <SNIPPET>
      <REQUIRES>flatmap</REQUIRES>
      <EXAMPLE>permutations_example</EXAMPLE>
      <EXPECTED>6</EXPECTED>
      <SCHEME>
(define (permutations s)
  (if (null? s)             ; empty set?
    (list nil)              ; sequence containing empty set
    (flatmap (lambda (x)
               (map (lambda (p) (cons x p))
                    (permutations (remove x s))))
             s)))
      </SCHEME>
      <PYTHON>
function permutations(s) {
    return is_null(s)             // empty set?
           ? list(null)           // sequence containing empty set
           : flatmap(x => map(p => pair(x, p),
                              permutations(remove(x, s))),
                     s);
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>permutations_example</NAME>
      <SCHEME>
(permutations (list 1 2 3))
      </SCHEME>
      <PYTHON>
permutations(list(1, 2, 3));
      </PYTHON>
      <PYTHON_TEST>
length(permutations(list(1, 2, 3)));
      </PYTHON_TEST>
    </SNIPPET>
    Notice how this strategy reduces the problem of generating permutations of
    <LATEXINLINE>$S$</LATEXINLINE> to the problem of generating the
    permutations of sets with fewer elements than
    <LATEXINLINE>$S$</LATEXINLINE>.  In the terminal case, we work our way down
    to the empty list, which represents a set of no elements. For this, we
    generate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(list nil)</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>list(null)</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    which is a sequence with one item, namely the set with no elements.  The
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>remove</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>remove</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    used in <SCHEMEINLINE>permutations</SCHEMEINLINE> returns all the items in
    a given sequence except for a given item.  This can be expressed as a
    simple filter:
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>remove</DECLARATION></INDEX> 
      <NAME>remove</NAME>
      <EXAMPLE>remove_example</EXAMPLE>
      <EXPECTED>4</EXPECTED>
      <SCHEME>
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
      </SCHEME>
      <PYTHON>
function remove(item, sequence) {
    return filter(x => ! (x === item),
                  sequence);
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>remove_example</NAME>
      <SCHEME>
	(remove 3 (list 1 2 3 4 5))
      </SCHEME>
      <PYTHON>
length(remove(3, list(1, 2, 3, 4, 5)));
      </PYTHON>
      <PYTHON_TEST>
length(remove(3, list(1, 2, 3, 4, 5)));
      </PYTHON_TEST>
    </SNIPPET>
  </TEXT>

  <EXERCISE>
    Write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
     <INDEX><USE>unique_pairs</USE></INDEX> 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>unique-pairs</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>unique_pairs</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    that, given an integer <LATEXINLINE>$n$</LATEXINLINE>, generates the
    sequence of pairs <LATEXINLINE>$(i, j)$</LATEXINLINE> with
    <LATEXINLINE>$1\leq j &lt; i\leq n$</LATEXINLINE>.  Use
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>unique-pairs</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>unique_pairs</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    to simplify the definition of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>prime-sum-pairs</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>prime_sum_pairs</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    given above.
    <SOLUTION>
      <SNIPPET>
	<NAME>solution_2.40</NAME>
	<REQUIRES>enumerate_interval</REQUIRES>
	<REQUIRES>make_pair_sum</REQUIRES>
	<REQUIRES>prime_sum</REQUIRES>
	<REQUIRES>flatmap</REQUIRES>
	<EXAMPLE>example_2.40</EXAMPLE>
	<EXPECTED>7</EXPECTED>
	<PYTHON>
function unique_pairs(n) {
    return flatmap(i => map(j => list(i, j), 
                            enumerate_interval(1, i - 1)), 
                   enumerate_interval(1, n));
}
function prime_sum_pairs(n) {
    return map(make_pair_sum, 
               filter(is_prime_sum, 
                      unique_pairs(n)));
}
	</PYTHON>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>example_2.40</NAME>
	<PYTHON>
prime_sum_pairs(6);
	</PYTHON>
	<PYTHON_TEST>
length(prime_sum_pairs(6));
	</PYTHON_TEST>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:2_40"/>
  </EXERCISE>

  <EXERCISE>
    Write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    to find all ordered triples of distinct positive integers
    <LATEXINLINE>$i$</LATEXINLINE>, <LATEXINLINE>$j$</LATEXINLINE>,
    and<SPACE/><LATEXINLINE>$k$</LATEXINLINE> less than or equal to a given
    integer <LATEXINLINE>$n$</LATEXINLINE> that sum to a given integer
    <LATEXINLINE>$s$</LATEXINLINE>.
    <SOLUTION>
      <SNIPPET>
	<REQUIRES>enumerate_interval</REQUIRES>
	<REQUIRES>flatmap</REQUIRES>
	<EXAMPLE>example_2.41</EXAMPLE>
	<EXPECTED>3</EXPECTED>
	<PYTHON>
function unique_triples(n) {
    return flatmap(i => flatmap(j => map(k => list(i, j, k),
                                         enumerate_interval(1, j - 1)),
                                enumerate_interval(1, i - 1)),
                   enumerate_interval(1, n));
}
function plus(x, y) {
    return x + y;
}
function triples_that_sum_to(s, n) {
    return filter(items => accumulate(plus, 0, items) === s,
                  unique_triples(n));
}
	</PYTHON>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>example_2.41</NAME>
	<PYTHON>
triples_that_sum_to(10, 6);
	</PYTHON>
	<PYTHON_TEST>
length(triples_that_sum_to(10, 6));
	</PYTHON_TEST>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:2_41"/>
  </EXERCISE>
      <FIGURE  web_scale="0.6" src="img_original/ch2-Z-G-23.svg">
	<LABEL NAME="fig:8queens"/>
	<CAPTION>A solution to the eight-queens puzzle.
	</CAPTION>
      </FIGURE>
  <EXERCISE>
      <LABEL NAME="ex:8queens"/>
      The 
      <INDEX>eight-queens puzzle</INDEX>
      <INDEX>chess, eight-queens puzzle</INDEX>
      <INDEX>puzzles<SUBINDEX>eight-queens puzzle</SUBINDEX></INDEX>
      <QUOTE>eight-queens puzzle</QUOTE> asks how to place eight queens on a
      chessboard so that no queen is in check from any other (i.e., no two
      queens are in the same row, column, or diagonal).  One possible solution
      is shown in figure<SPACE/><REF NAME="fig:8queens"/>.  One way to solve the
      puzzle is to work across the board, placing a queen in each column.
      Once we have placed <LATEXINLINE>$k-1$</LATEXINLINE> queens, we must place
      the <LATEXINLINE>$k$</LATEXINLINE>th queen in a position where it does not
      check any of the queens already on the board.  We can formulate this
      approach recursively: Assume that we have already generated the sequence
      of all possible ways to place <LATEXINLINE>$k-1$</LATEXINLINE> queens in
      the first <LATEXINLINE>$k-1$</LATEXINLINE> columns of the board.  For
      each of these ways, generate an extended set of positions by placing a
      queen in each row of the <LATEXINLINE>$k$</LATEXINLINE>th column.  Now
      filter these, keeping only the positions for which the queen in the
      <LATEXINLINE>$k$</LATEXINLINE>th column is safe with respect to the other
      queens.  This produces the sequence of all ways to place
      <LATEXINLINE>$k$</LATEXINLINE> queens in the first
      <LATEXINLINE>$k$</LATEXINLINE> columns.  By continuing this process, we
      will produce not only one solution, but all solutions to the puzzle.
      <TEXT>
      We implement this solution as a
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON></SPLITINLINE>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>queens</SCHEMEINLINE>,</SCHEME>
	<PYTHON><PYTHONINLINE>queens</PYTHONINLINE>,</PYTHON>
      </SPLITINLINE>
      which returns a sequence of all solutions to the problem of placing
      <LATEXINLINE>$n$</LATEXINLINE> queens on an
      <LATEXINLINE>$n\times n$</LATEXINLINE> chessboard.
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Queens</SCHEMEINLINE></SCHEME>
	<PYTHON>The function <PYTHONINLINE>queens</PYTHONINLINE>
	</PYTHON>
      </SPLITINLINE>
      has an internal
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<PYTHON>function</PYTHON>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>queen-cols</SCHEMEINLINE></SCHEME>
	<PYTHON><PYTHONINLINE>queens_cols</PYTHONINLINE>
	</PYTHON>
      </SPLITINLINE>
      that returns the sequence of all ways to place queens in the first
      <LATEXINLINE>$k$</LATEXINLINE> columns of the board.
    <SNIPPET HIDE="yes">
      <NAME>example_queens</NAME>
      <SCHEME>
      </SCHEME>
      <PYTHON>
queens(8);
      </PYTHON>
      <PYTHON_TEST>
length(queens(8));
      </PYTHON_TEST>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>queens</DECLARATION><FRAGILE/></INDEX> 
      <NAME>queens</NAME>
      <REQUIRES>flatmap</REQUIRES>
      <REQUIRES>enumerate_interval</REQUIRES>
      <EXAMPLE>example_queens</EXAMPLE>
      <SCHEME>
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
      (list empty-board)
      (filter
        (lambda (positions) (safe? k positions))
        (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
      </SCHEME>
      <PYTHON>
function queens(board_size) {
    function queen_cols(k) {
        return k === 0
               ? list(empty_board)
               : filter(positions => is_safe(k, positions),
                        flatmap(rest_of_queens =>
                                  map(new_row =>
                                        adjoin_position(new_row, k,
                                                        rest_of_queens),
                                      enumerate_interval(1, board_size)),
                                queen_cols(k - 1)));
    }
    return queen_cols(board_size);
}
      </PYTHON>
    </SNIPPET>
    In this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>rest-of-queens</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>rest_of_queens</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    is a way to place <LATEXINLINE>$k-1$</LATEXINLINE> queens in the first
    <LATEXINLINE>$k-1$</LATEXINLINE> columns, and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-row</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>new_row</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    is a proposed row in which to place the queen for the
    <LATEXINLINE>$k$</LATEXINLINE>th column.  Complete the program by
    implementing the representation for sets of board positions, including the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>adjoin-position</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>adjoin_position</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    which adjoins a new row-column position to a set of positions, and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>empty-board</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>empty_board</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    which represents an empty set of positions.  You must also write the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>safe?</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>is_safe</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    which determines for a set of positions whether the queen in the
    <LATEXINLINE>$k$</LATEXINLINE>th column is safe with respect to the others.
    (Note that we need only check whether the new queen is safe<EMDASH/>the
    other queens are already guaranteed safe with respect to each other.)
      </TEXT>
    <SOLUTION>
      <SNIPPET>
        <NAME>adjoin_position</NAME>
        <SCHEME>
        </SCHEME>
        <PYTHON>
function adjoin_position(row, col, rest) {
    return pair(pair(row, col), rest);
}
        </PYTHON>
      </SNIPPET>
      <SNIPPET>
        <NAME>empty_board</NAME>
        <SCHEME>
        </SCHEME>
        <PYTHON>
const empty_board = null;
        </PYTHON>
      </SNIPPET>
      <SNIPPET>
        <NAME>is_safe</NAME>
        <SCHEME>
        </SCHEME>
        <PYTHON>
function is_safe(k, positions) {
    const first_row = head(head(positions));
    const first_col = tail(head(positions));
    return accumulate((pos, so_far) => {
                         const row = head(pos);
                         const col = tail(pos);
                         return so_far &amp;&amp;
                                first_row - first_col !==
                                row - col &amp;&amp;
                                first_row + first_col !==
                                row + col &amp;&amp;
                                first_row !== row;
                      },
                      true, 
                      tail(positions));
}   
        </PYTHON>
      </SNIPPET>
      Putting it all together:
      <SNIPPET>
        <NAME>queens_solution</NAME>
	<REQUIRES>adjoin_position</REQUIRES>
	<REQUIRES>empty_board</REQUIRES>
	<REQUIRES>is_safe</REQUIRES>
        <REQUIRES>queens</REQUIRES>
        <REQUIRES>example_queens</REQUIRES>
	<EXPECTED>92</EXPECTED>
        <SCHEME>
        </SCHEME>
        <PYTHON>
// click here to see all solutions
        </PYTHON>
        <PYTHON_RUN>
        </PYTHON_RUN>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    Louis Reasoner is having a terrible time doing
    exercise<SPACE/><REF NAME="ex:8queens"/>.  His
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>queens</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>queens</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    seems to work, but it runs extremely slowly. (Louis never does manage to
    wait long enough for it to solve even the
    <LATEXINLINE>$6\times 6$</LATEXINLINE> case.)  When Louis asks Eva Lu Ator
    for help, she points out that he has interchanged the order of the nested
    mappings in the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>flatmap</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>flatmap</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    writing it as
    <SNIPPET EVAL="no">
      <SCHEME>
(flatmap
  (lambda (new-row)
    (map (lambda (rest-of-queens)
           (adjoin-position new-row k rest-of-queens))
         (queen-cols (- k 1))))
  (enumerate-interval 1 board-size))
      </SCHEME>
      <PYTHON>
flatmap(new_row =>
          map(rest_of_queens => 
                adjoin_position(new_row, k, rest_of_queens), 
              queen_cols(k - 1)), 
        enumerate_interval(1, board_size));
      </PYTHON>
    </SNIPPET>
    Explain why this interchange makes the program run slowly.  Estimate
    how long it will take Louis<APOS/>s program to solve the eight-queens
    puzzle, assuming that the program in
    exercise<SPACE/><REF NAME="ex:8queens"/> solves the puzzle in time
    <LATEXINLINE>$T$</LATEXINLINE>.
    <SOLUTION>
      Louis's program re-evaluates the application
      <PYTHONINLINE>queen_cols(k - 1))</PYTHONINLINE> in each iteration
      of <PYTHONINLINE>flatmap</PYTHONINLINE>, which happens
      <LATEXINLINE>$n$</LATEXINLINE> times for each
      <LATEXINLINE>$k$</LATEXINLINE>. That means overall Louis's program will
      solve the puzzle in a time of about <LATEXINLINE>$n^n T$</LATEXINLINE>
      if the program in exercise<SPACE/><REF NAME="ex:8queens"/> solves the
      puzzle in time <LATEXINLINE>$T$</LATEXINLINE>.
    </SOLUTION>
    <LABEL NAME="ex:2_43"/>
  </EXERCISE>
  <INDEX>sequence(s)<SUBINDEX>as conventional interface</SUBINDEX><CLOSE/></INDEX>
  <INDEX>conventional interface<SUBINDEX>sequence as</SUBINDEX><CLOSE/></INDEX>
  <INDEX>mapping<SUBINDEX>nested</SUBINDEX><CLOSE/></INDEX>
</SUBSECTION>
