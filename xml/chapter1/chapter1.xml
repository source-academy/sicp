  <CHAPTER>
    <NAME>
      Building Abstractions with 
      <SPLITINLINE><SCHEME>Procedures</SCHEME><JAVASCRIPT>Functions</JAVASCRIPT></SPLITINLINE>
    </NAME>

    <HISTORY> 
      % fall '97 Add tex '\label's for manual to reference.
      % 8/26/97  FIX TYPOS FOR THIRD PRINTING -- p.45, p.70
      %
      % 4/15/96 FIX TYPO FOUND BY COMPARING TO BEFORE-INDEXING -- MUST REPRINT P.60
      % 4/13-4/15 Indexing [after final printout of chapters]
      % 4/11 Corrections and adjustments based on <QUOTE>final</QUOTE> check and spell-checking
      % 4/9  trivial fixes based on comparison to before-indexing
      % 4/6-... Julie index fixes (and 4/8 change 'ns')
      % 4/5/96 Hal indexing
      % 3/29/96, 4/3/96 Julie: indexing fixes
      % 3/18/96 rest of pagination, minor other indexing changes
      % 3/14 &amp; 3/16/96 Paginated up to p.64 (look for \pagekludge)
      % 3/10-3/14/96 minor changes/fixes; indexing; Moved exercise
      % 3/9/96  fix spacing in some exercise parts
      % 3/6/96  fix typos
      % 3/5/96  minor typesetting fixes
      % 3/4/96  edit first-class-proc footnote for PSZ; fix minor error
      % 2/26-3/1/96 fix some bad line breaks
      % 2/24/96 flush \noindent after {lisp} by closing up space with %
      % 2/24/96 fix format of GCD-reduction equation
      % 2/23/96 fix typesetting with new smallequation macro
      % 2/22/96 new spec for epigraph
      % 2/21/96 fixed format of absolute-value def
      % 2/20/96 fix how arrows are done
      % 2/19/96 changed exp-iter -> expt-iter, fast-exp -> fast-expt
      % 2/19/96 fixed () in a reference
      % 2/19/96 fixed et al.
    </HISTORY>

    <EPIGRAPH>
      The acts of the mind, wherein it exerts its power over simple ideas,
      are chiefly these three: 1. Combining several simple ideas into one
      compound one, and thus all complex ideas are made.  2. The second is
      bringing two ideas, whether simple or complex, together, and setting
      them by one another so as to take a view of them at once, without
      uniting them into one, by which it gets all its ideas of relations.
      3.  The third is separating them from all other ideas that accompany
      them in their real existence: this is called abstraction, and thus all
      its general ideas are made.
      <ATTRIBUTION>
        <AUTHOR>John Locke</AUTHOR> 
        <TITLE>An Essay Concerning Human Understanding</TITLE>
        <INDEX>Locke, John</INDEX>
        <DATE>1690</DATE>
      </ATTRIBUTION>
    </EPIGRAPH>

    <CHAPTERCONTENT/>

    <TEXT>
      We are about to study the idea of a
      <EM>computational process</EM><INDEX>process</INDEX>.
      Computational processes are abstract beings that inhabit computers.
      As they evolve, processes manipulate other abstract things called
      <EM>data</EM>.
      The evolution of a process is directed by a pattern of rules
      called a
      <EM>program</EM>.
      People create programs to direct processes.
      In effect, we conjure the spirits of the computer with our spells.
    </TEXT>

    <TEXT>
      A computational process is indeed much like a sorcerer<APOS/>s idea of a
      spirit.  It cannot be seen or touched.  It is not composed of matter
      at all.  However, it is very real.  It can perform intellectual work.
      It can answer questions.  It can affect the world by disbursing money
      at a bank or by controlling a robot arm in a factory.  The programs we
      use to conjure processes are like a sorcerer<APOS/>s spells.  They are
      carefully composed from symbolic expressions in arcane and esoteric
      <EM>programming languages</EM><INDEX>programming language</INDEX>
      that prescribe the tasks we want our
      processes to perform.
    </TEXT>

    <TEXT>
      A computational process, in a correctly working computer, executes
      programs precisely and accurately.  Thus, like the sorcerer<APOS/>s
      apprentice, novice programmers must learn to understand and to
      anticipate the consequences of their conjuring.  Even small errors
      (usually called <EM>bugs</EM><INDEX>bug</INDEX>
      or <EM>glitches</EM>) <INDEX>glitch</INDEX>
      in programs can have complex and unanticipated consequences.
    </TEXT>

    <TEXT>
      Fortunately, learning to program is considerably less dangerous than
      learning sorcery, because the spirits we deal with are conveniently
      contained in a secure way.  Real-world programming, however,
      requires care, expertise, and wisdom.  A small bug in a computer-aided
      design program, for example, can lead to the catastrophic collapse of
      an airplane or a dam or the self-destruction of an industrial robot.
    </TEXT>

    <TEXT>
      Master software engineers have the ability to organize programs so
      that they can be reasonably sure that the resulting processes will
      perform the tasks intended.  They can visualize the behavior of their
      systems in advance.  They know how to structure programs so that
      unanticipated problems do not lead to catastrophic consequences, and
      when problems do arise, they can <EM>debug</EM>
      their programs.  Well-designed
      computational systems, like well-designed automobiles or nuclear
      reactors, are designed in a modular manner, so that the parts can be
      constructed, replaced, and debugged separately.
    </TEXT>

    <SPLIT>
      <SCHEME>
        <SUBHEADING> 
          <NAME>Programming in Lisp</NAME>
        </SUBHEADING>
      </SCHEME>
      <JAVASCRIPT>
        <SUBHEADING>
          <NAME>Programming in JavaScript</NAME>
        </SUBHEADING>
      </JAVASCRIPT>
    </SPLIT>

    <SPLIT>
      <SCHEME>
        <TEXT>
          We need an appropriate language for describing processes, and we will
          use for this purpose the programming language Lisp.  Just as our
          everyday thoughts are usually expressed in our natural language (such
          as English, French, or Japanese), and descriptions of quantitative
          phenomena are expressed with mathematical notations, our procedural
          thoughts will be expressed in Lisp. 
          <INDEX>Lisp<SUBINDEX>history of</SUBINDEX></INDEX>
          Lisp was invented in the late
          1950s as a formalism for reasoning about the use of certain kinds of
          logical expressions, called 
          <EM>recursion equations</EM>, as a model for
          computation.  The language was conceived by 
          <INDEX>McCarthy, John</INDEX>
          John McCarthy and is based
          on his paper <QUOTE>Recursive Functions of Symbolic Expressions and Their
            Computation by Machine</QUOTE> (<CITATION>McCarthy 1960</CITATION>).
        </TEXT>
      </SCHEME>
      <JAVASCRIPT>
        <TEXT>
          We need an appropriate language for describing processes, and we will
          use for this purpose the programming language JavaScript.  Just as our
          everyday thoughts are usually expressed in our natural language (such
          as English, French, or Japanese), and descriptions of quantitative
          phenomena are expressed with mathematical notations, our process
          descriptions will be expressed in JavaScript. 
          <INDEX>JavaScript<SUBINDEX>history of</SUBINDEX></INDEX>
          JavaScript was developed in the early
          1990s as a programming language for controlling the behavior 
          of World Wide Web browsers through scripts that are embedded
	  in web pages.
          The language was conceived by 
          <INDEX>Eich, Brendan</INDEX>
          <INDEX>Mocha</INDEX>
          Brendan Eich, originally under the name <EM>Mocha</EM>, which
          <INDEX>LiveScript</INDEX>
          was later renamed to <EM>LiveScript</EM>, and finally to JavaScript.
          <INDEX>Sun Microsystems</INDEX>
          The name <QUOTE>JavaScript</QUOTE> is a trademark
	  of Oracle Corporation.
        </TEXT>
      </JAVASCRIPT>
    </SPLIT>

    <SPLIT>
      <SCHEME>
        <TEXT>
          Despite its inception as a mathematical formalism, Lisp is a practical
          programming language.  A Lisp 
          <EM>interpreter</EM>
          is a machine that
          carries out processes described in the Lisp language.  The first Lisp
          interpreter was implemented by 
          <INDEX>McCarthy, John</INDEX>
          McCarthy with the help of colleagues
          and students in the Artificial Intelligence Group of the
          <INDEX>MIT<SUBINDEX>Research Laboratory of Electronics</SUBINDEX></INDEX>
          MIT Research
          Laboratory of Electronics and in the MIT Computation
          Center.<FOOTNOTE>The 
            <EM_NO_INDEX>Lisp 1 Programmer<APOS/>s Manual</EM_NO_INDEX> 
            appeared in
            1960, and the 
            <EM_NO_INDEX>Lisp 1.5 Programmer<APOS/>s Manual</EM_NO_INDEX>
            <INDEX>McCarthy, John</INDEX>
            (<CITATION>McCarthy 1965</CITATION>)
            was published in 1962.  The early history of Lisp is described in
            <CITATION>McCarthy 1978</CITATION>.
          </FOOTNOTE>
          <INDEX>Lisp<SUBINDEX>acronym for LISt Processing</SUBINDEX></INDEX>
          Lisp, whose name is an acronym for LISt Processing,
          was designed to provide symbol-manipulating capabilities for
          attacking programming problems such as the symbolic differentiation
          and integration of algebraic expressions.  It included for this
          purpose new data objects known as atoms and lists, which most
          strikingly set it apart from all other languages of the period.
        </TEXT>
      </SCHEME>
      <JAVASCRIPT>
        <TEXT>
          Despite its inception as a language for controlling browsers, JavaScript
          <INDEX>interpreter</INDEX>
          is a general-purpose programming language. A JavaScript <EM>interpreter</EM>
          is a machine that carries out processes described in the JavaScript
          <INDEX>Eich, Brendan</INDEX>
          language. The first JavaScript interpreter was implemented by Eich
          <INDEX>Netscape Communications Corporation</INDEX>
          <INDEX>Netscape Navigator</INDEX>
          at Netscape Communications Corporation, for the Netscape Navigator web 
          browser. The main features of JavaScript are inherited from the 
          <INDEX>Self</INDEX>
          <INDEX>Scheme<SUBINDEX>as precursor of JavaScript</SUBINDEX></INDEX>
          Scheme and Self programming languages. Scheme is a dialect of Lisp, and
          <INDEX>Lisp</INDEX>
          was used as programming language for the original version of this book. 
          From Scheme, JavaScript inherited its most fundamental design principles 
          <INDEX>function<SUBINDEX>statically-scoped, first-class</SUBINDEX></INDEX>
          such as statically-scoped first-class 
          <INDEX>dynamic typing</INDEX>
          <INDEX>typing<SUBINDEX>dynamic</SUBINDEX></INDEX>
          functions and dynamic typing, and as a result, it
          was fairly straightforward to translate the
	  programs in this book from Scheme to JavaScript.
        </TEXT>
      </JAVASCRIPT>
    </SPLIT>

    <SPLIT>
      <SCHEME>
        <TEXT>
          Lisp was not the product of a concerted design effort.  Instead, it
          evolved informally in an experimental manner in response to users<APOS/>
          needs and to pragmatic implementation considerations.  Lisp<APOS/>s informal
          evolution has continued through the years, and the community of Lisp
          users has traditionally resisted attempts to promulgate any
          <QUOTE>official</QUOTE> definition of the language.  This evolution, together
          with the flexibility and elegance of the initial conception, has
          enabled Lisp, which is the second oldest language in widespread use
          today (only 
          <INDEX>Fortran</INDEX>
          Fortran is older), to continually adapt to encompass the
          most modern ideas about program design.  Thus, Lisp is by now a family
          of dialects, which, while sharing most of the original features, may
          differ from one another in significant ways.  The dialect of Lisp used
          in this book is called 
          <INDEX>Scheme</INDEX><INDEX>Lisp dialects<SUBINDEX>Scheme</SUBINDEX></INDEX>
          Scheme.<FOOTNOTE>The two dialects in which most
            major Lisp programs of the 1970s were written are 
            <INDEX>MacLisp</INDEX><INDEX>Lisp dialects<SUBINDEX>MacLisp</SUBINDEX></INDEX>
            MacLisp 
            <INDEX>Moon, David A.</INDEX>
            (<CITATION>Moon 1978</CITATION>;
            <INDEX>Pitman, Kent M.</INDEX>
            <CITATION>Pitman 1983</CITATION>), developed at the 
            <INDEX>MIT<SUBINDEX>Project MAC</SUBINDEX></INDEX>
            MIT Project MAC, and 
            <INDEX>Interlisp</INDEX><INDEX>Lisp dialects<SUBINDEX>Interlisp</SUBINDEX></INDEX>
            Interlisp
            <INDEX>Teitelman, Warren</INDEX>
            (<CITATION>Teitelman 1974</CITATION>), developed at 
            <INDEX>Bolt Beranek and Newman Inc.</INDEX>
            Bolt Beranek and Newman Inc.<SPACE/>and the
            <INDEX>Xerox Palo Alto Research Center</INDEX>
            Xerox Palo Alto Research Center.  
            <INDEX>Portable Standard Lisp</INDEX>
            <INDEX>Lisp dialects<SUBINDEX>Portable Standard Lisp</SUBINDEX></INDEX>
            Portable Standard Lisp
            <INDEX>Hearn, Anthony C.</INDEX>
            (<CITATION>Hearn 1969</CITATION>;
            <INDEX>Griss, Martin Lewis</INDEX>
            <CITATION>Griss 1981</CITATION>) 
            was a Lisp dialect designed to be easily portable
            between different machines.  MacLisp spawned a number of subdialects,
            such as 
            <INDEX>Franz Lisp</INDEX>
            <INDEX>Lisp dialects<SUBINDEX>Franz Lisp</SUBINDEX></INDEX>
            Franz Lisp, which was developed at the 
            <INDEX>University of California at Berkeley</INDEX>
            University of
            California at Berkeley, and
            <INDEX>Zetalisp</INDEX>
            <INDEX>Lisp dialects<SUBINDEX>Zetalisp</SUBINDEX></INDEX>
            Zetalisp (<CITATION>Moon 1981</CITATION>), which was based on a
            special-purpose processor designed at the 
            <INDEX>MIT<SUBINDEX>Artificial Intelligence Laboratory</SUBINDEX></INDEX>
            MIT Artificial Intelligence
            Laboratory to run Lisp very efficiently.  The Lisp dialect used in
            this book, called
            <INDEX>Scheme<SUBINDEX>history of</SUBINDEX></INDEX>
            Scheme (<CITATION>Steele 1975</CITATION>), was invented in 1975 by
            <INDEX>Steele, Guy Lewis Jr.</INDEX>
            <INDEX>Sussman, Gerald Jay</INDEX>
            Guy Lewis Steele Jr.<SPACE/>and Gerald Jay Sussman of the MIT Artificial
            Intelligence Laboratory and later reimplemented for instructional use
            at MIT.  Scheme became an IEEE standard in 1990 
            (<CITATION>IEEE 1990</CITATION>).  The
            <INDEX>Common Lisp</INDEX>
            <INDEX>Lisp dialects<SUBINDEX>Common Lisp</SUBINDEX></INDEX>
            Common Lisp dialect (<CITATION>Steele 1982</CITATION>, 
            <CITATION>Steele 1990</CITATION>) was developed by the
            Lisp community to combine features from the earlier Lisp dialects
            to make an industrial standard for Lisp.  Common Lisp became an ANSI
            standard in 1994 (<CITATION>ANSI 1994</CITATION>).
          </FOOTNOTE>
        </TEXT>
      </SCHEME>
      <JAVASCRIPT>
        <TEXT>
          JavaScript bears only superficial resemblance to the language Java, 
          <INDEX>Java</INDEX>
          after which it was
          <INDEX>block structure</INDEX>
          (eventually) named; both Java and JavaScript use the block structure of the language
          <INDEX>C</INDEX>
          C. In contrast with Java and C, which usually
	  employ compilation to lower-level
          languages, JavaScript programs were initially
	  <EM>interpreted</EM>
	  by web browsers.
          <INDEX>Netscape Navigator</INDEX>
          After Netscape Navigator, other web browsers provided interpreters
          <INDEX>Internet Explorer</INDEX>
          <INDEX>Microsoft</INDEX>
          for the language, including Microsoft<APOS/>s Internet Explorer, whose
          JavaScript version is called
          <INDEX>JScript</INDEX>
          <EM>JScript</EM>. The popularity of JavaScript for controlling web
          browsers gave rise to a standardization effort, culminating in 
          <EM>ECMAScript</EM>. The
          first edition of the ECMAScript standard was led by Guy Lewis 
          Steele Jr.<SPACE/>and completed in June 1997 (<CITATION>Ecma 1997</CITATION>).
          The sixth edition, which is used in this book, was led by 
          Allen Wirfs-Brock and adopted by the General Assembly of ECMA in
	  June 2015.
        </TEXT>
      </JAVASCRIPT>
    </SPLIT>

    <SPLIT>
      <SCHEME>
        <TEXT>
          Because of its experimental character and its emphasis on symbol
          manipulation, 
          <INDEX>Lisp<SUBINDEX>Fortran vs.</SUBINDEX></INDEX>
          <INDEX>Lisp<SUBINDEX>efficiency of</SUBINDEX></INDEX>
          <INDEX>efficiency<SUBINDEX>of Lisp</SUBINDEX></INDEX>
          Lisp was at first very inefficient for numerical
          computations, at least in comparison with Fortran.  Over the years,
          however, Lisp compilers have been developed that translate programs
          into machine code that can perform numerical computations reasonably
          efficiently.  And for special applications, Lisp has been used with
          great effectiveness.<FOOTNOTE>One such special application was a
            breakthrough computation of scientific importance<EMDASH/>an integration of
            the motion of the 
            <INDEX>Solar System<APOS/>s chaotic dynamics</INDEX>
            <INDEX>chaos in the Solar System</INDEX>
            Solar System that extended previous results by
            nearly two orders of magnitude, and demonstrated that the dynamics of
            the Solar System is chaotic.  This computation was made possible by
            new integration algorithms, a special-purpose compiler, and a
            special-purpose computer all implemented with the aid of software
            tools written in Lisp
            <INDEX>Abelson, Harold</INDEX>
            (<CITATION>Abelson et al.<SPACE/>1992</CITATION>; 
            <INDEX>Sussman, Gerald Jay</INDEX>
            <INDEX>Wisdom, Jack</INDEX>
            <CITATION>Sussman and Wisdom 1992</CITATION>).
          </FOOTNOTE>
          Although Lisp has not yet overcome its old reputation
          as hopelessly inefficient, Lisp is now used in many applications where
          efficiency is not the central concern.  For example, Lisp has become
          a language of choice for operating-system shell languages and for
          extension languages for editors and computer-aided design systems.
          <INDEX>Lisp<SUBINDEX>history of</SUBINDEX></INDEX>
        </TEXT>
      </SCHEME>
      <JAVASCRIPT>
        <TEXT>
          The practice of embedding JavaScript programs in web pages encouraged
          the developers of web browsers to implement JavaScript interpreters.
          As these programs became more complex,
          the interpreters became more efficient in executing them, eventually
          using sophisticated implementation techniques such as Just-In-Time
          (JIT) compilation.
          The majority of JavaScript programs (as of 2019) is embedded in 
          web pages and interpreted by browsers, but JavaScript is also used
          for scripting dashboard widgets in Apple computers running the OS X 
          operating system, for controlling software systems such as Adobe
          Reader and devices such as universal remote panels, and
	  in server software, using Node.js.
        </TEXT>
      </JAVASCRIPT>
    </SPLIT>

    <SPLIT>
      <SCHEME>
        <TEXT>
          If Lisp is not a mainstream language, why are we using it as the
          framework for our discussion of programming?  Because the language
          possesses 
          <INDEX>Lisp<SUBINDEX>unique features of</SUBINDEX></INDEX>
          unique features that make it an excellent medium for
          studying important programming constructs and data structures and for
          relating them to the linguistic features that support them.  The most
          significant of these features is the fact that Lisp descriptions of
          processes, called 
          <INDEX>procedure</INDEX>
          <INDEX>procedure<SUBINDEX><ORDER>data</ORDER>as data</SUBINDEX></INDEX>
          <EM>procedures</EM>, can    
          themselves be represented and manipulated as Lisp data.  The
          importance of this is that there are powerful program-design
          techniques that rely on the ability to blur the traditional
          distinction between <QUOTE>passive</QUOTE> data and <QUOTE>active</QUOTE> 
          processes.  As we
          shall discover, Lisp<APOS/>s flexibility in handling procedures as data
          makes it one of the most convenient languages in existence for
          exploring these techniques.  The ability to represent procedures as
          data also makes Lisp an excellent language for writing programs that
          must manipulate other programs as data, such as the interpreters and
          compilers that support computer languages.  Above and beyond these
          considerations, programming in Lisp is great fun.
        </TEXT>
      </SCHEME>
      <JAVASCRIPT>
        <TEXT> 
          <INDEX>browser</INDEX>
          However, it is the ability of browsers to execute JavaScript programs
          that makes it an ideal language for an online version of a programming
          textbook. Executing programs by clicking on things on a web page comes
          naturally in JavaScript<EMDASH/>after all that is what JavaScript
	  was designed
          for! More fundamentally, JavaScript
          possesses features that make it an excellent medium for studying
          important programming constructs and data structures and for relating
          them to the linguistic features that support them. JavaScript<APOS/>s 
          <INDEX>function<SUBINDEX>statically-scoped, first-class</SUBINDEX></INDEX>
          statically-scoped first-class functions  
          provide direct and concise access to abstraction mechanisms, and
          <INDEX>dynamic typing</INDEX>
          <INDEX>typing<SUBINDEX>dynamic</SUBINDEX></INDEX>
          dynamic typing removes the need for declaring the types of the data
          being manipulated by the program.
          Above and beyond these
          considerations, programming in JavaScript is great fun.
        </TEXT>
      </JAVASCRIPT> 
    </SPLIT>

    <CHAPTERCONTENT/>

    <!-- Section 1 : The Elements of Programming -->
    &section1.1;

    <!-- Section 2 : Functions and the Processes They Generate -->
    &section1.2;

    <!-- Formulating Abstractions with Higher-Order Functions -->
    &section1.3;

    </CHAPTER>
