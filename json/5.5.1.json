[{"id":"/sicpjs/5.5.1","tag":"TITLE","body":"5.5.1  \n    Structure of the Compiler"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"4.1.7","href":"/sicpjs/4.1.7"},{"body":" we modified our\n    original metacircular interpreter to separate\n    \n    analysis from execution.  We\n    analyzed each\n    \n        component\n      \n    to produce an execution\n    function\n    that took an environment as argument and performed the required operations.\n    In our compiler, we will do essentially the same analysis.  Instead of\n    producing execution\n    functions,\n    however, we will generate sequences of instructions to be run by our\n    register machine.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":" is the top-level dispatch in the\n    compiler. It corresponds to the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":"function\n    of section ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":", the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"analyze"},{"body":"function\n    of section ","tag":"#text"},{"tag":"REF","body":"4.1.7","href":"/sicpjs/4.1.7"},{"body":", and the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":"\n    entry point of the explicit-control-evaluator in\n    section ","tag":"#text"},{"tag":"REF","body":"5.4.1","href":"/sicpjs/5.4.1"},{"body":". The compiler, like the\n    interpreters, uses the\n    component-syntax functions\n    defined in\n    section ","tag":"#text"},{"tag":"REF","body":"4.1.2","href":"/sicpjs/4.1.2"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.5.1#footnote-1"},{"body":"The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":" performs a case analysis on the\n    syntactic type of the\n    \n\tcomponent\n      \n    to be compiled.  For\n    each type of\n    \n\tcomponent,\n      \n    it dispatches to a\n    specialized\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"code generator","tag":"#text"}]},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"function compile(component, target, linkage) {\n    return is_literal(component)\n           ? compile_literal(component, target, linkage)\n           : is_name(component)\n           ? compile_name(component, target, linkage)\n           : is_application(component)\n           ? compile_application(component, target, linkage)\n           : is_operator_combination(component)\n           ? compile(operator_combination_to_application(component),\n                     target, linkage)\n           : is_conditional(component)\n           ? compile_conditional(component, target, linkage)\n           : is_lambda_expression(component)\n           ? compile_lambda_expression(component, target, linkage)\n           : is_sequence(component)\n           ? compile_sequence(sequence_statements(component),\n                              target, linkage)\n           : is_block(component)\n           ? compile_block(component, target, linkage)\n           : is_return_statement(component)\n           ? compile_return_statement(component, target, linkage)\n           : is_function_declaration(component)\n           ? compile(function_decl_to_constant_decl(component),\n                     target, linkage)\n           : is_declaration(component)\n           ? compile_declaration(component, target, linkage)\n           : is_assignment(component)\n           ? compile_assignment(component, target, linkage)\n           : error(component, \"unknown component type -- compile\");\n}"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Targets and linkages","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n\tThe function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":"\n    and the code generators that it calls\n    take two\n    \n    arguments in addition to the\n    \n        component\n      \n    to compile.  There is a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"target","tag":"#text"}]},{"body":", which specifies the register in which the compiled code is\n    to return the value of the\n    \n        component.\n      \n    There is also a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"linkage descriptor","tag":"#text"}]},{"body":", which describes how the code resulting from the\n    compilation of the\n    \n        component\n      \n    should proceed when it has finished its\n    execution.  The linkage descriptor can require the code to do one of\n    the following three things:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tproceed to the next instruction in sequence (this is\n\tspecified by the linkage descriptor\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":"),\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t    jump to the current value of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register\n\t    as part of returning from a function call\n\t  \n\t(this is specified\n\tby the linkage descriptor\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"),\n\t  \n\tor\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tjump to a named entry point (this is specified by using the\n\tdesignated label as the linkage descriptor).\n      ","tag":"#text"}]}]}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    For example, compiling the\n    \n        literal\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5"},{"body":"\n    with a target of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":"\n    register and a linkage of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":"\n    should produce\n    the instruction\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"assign(\"val\", constant(5))"},{"body":"\n    Compiling the same expression with a linkage of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n    should produce the instructions\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"assign(\"val\", constant(5)),\ngo_to(reg(\"continue\"))"},{"body":"\n    In the first case, execution will continue with the next instruction\n    in the sequence. In the second case,\n    we will jump to whatever entry point is stored in the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register.\n    In both cases, the value of the expression will be placed into\n    the target ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" register.\n    \n        Our compiler uses the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":" linkage when compiling\n        the return expression of a return statement. \n        Just as in the explicit-control evaluator, returning from a function call happens in three steps:\n        ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"reverting the stack to the marker and restoring ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" (which holds a continuation set up at the beginning of the function call)","tag":"#text"}]},{"tag":"LI","child":[{"body":"computing the return value and placing it in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"}]},{"tag":"LI","child":[{"body":"jumping to the entry point in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"}]}]},{"body":"\n        Compilation of a return statement explicitly generates code for reverting the stack and restoring ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":".\n        The return expression is compiled with target ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and linkage ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n        so that the generated code for computing the return value places the return value in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and ends by\n        jumping to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":". \n      ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Instruction sequences and stack usage","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Each code generator returns an\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"instruction sequence","tag":"#text"}]},{"body":" containing\n    the object code it has generated for the\n    \n        component.\n      \n    Code generation for a\n    compound component\n    is accomplished by combining the output from simpler code\n    generators for\n    subcomponents,\n    just as evaluation of a\n    compound component\n    is accomplished by evaluating the\n    subcomponents.","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    The simplest method for combining instruction sequences is a\n    function\n    called\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_instruction_sequences"},{"body":",\n      \n\twhich takes as arguments\n\ttwo instruction sequences\n      \n    that are to be\n    executed\n    \n\tsequentially. It\n      \n    appends them and returns the combined sequence.\n    That is, if ","tag":"#text"},{"body":"$seq_1$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$seq_2$","tag":"LATEX"},{"body":" are sequences of instructions, then\n    evaluating\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n      append_instruction_sequences($seq$$_1$, $seq$$_2$)\n      "},{"body":"\n    produces the sequence\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$seq$$_1$\n$seq$$_2$\n      "}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    Whenever registers might need to be saved, the compiler's code\n    generators use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":", which is a more subtle method for\n    combining instruction sequences.\n    \n\tThe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":"\n    takes three arguments: a set of registers and two instruction sequences that\n    are to be executed sequentially.  It appends the sequences in such a way\n    that the contents of each register in the set is preserved over the\n    execution of the first sequence, if this is needed for the execution of the\n    second sequence.  That is, if the first sequence modifies the register\n    and the second sequence actually needs the register's original\n    contents, then ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" wraps a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" and a ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":"\n    of the register around the first sequence before appending the sequences.\n    Otherwise, ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" simply returns the\n    appended instruction sequences.  Thus, for example,\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n      preserving(list($reg$$_1$, $reg$$_2$), $seq$$_1$, $seq$$_2$)\n      "},{"body":"\n    produces one of the following four sequences of instructions, depending on\n    how\n    ","tag":"#text"},{"tag":"META","body":"seq"},{"body":"$_1$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"tag":"META","body":"seq"},{"body":"$_2$","tag":"LATEX"},{"body":" use\n    ","tag":"#text"},{"tag":"META","body":"reg"},{"body":"$_1$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"tag":"META","body":"reg"},{"body":"$_2$","tag":"LATEX"},{"body":":\n  ","tag":"#text"}]},{"body":"\n      \\[\n      \\begin{array}{l|l|l|l}\n        \\textit{seq}_1 & \\texttt{save(}\\textit{reg}_1\\texttt{),}    & \\texttt{save(}\\textit{reg}_2\\texttt{),}     & \\texttt{save(}\\textit{reg}_2\\texttt{),}    \\\\\n        \\textit{seq}_2 & \\textit{seq}_1                             & \\textit{seq}_1                              & \\texttt{save(}\\textit{reg}_1\\texttt{),}    \\\\\n                       & \\texttt{restore(}\\textit{reg}_1\\texttt{),} & \\texttt{restore(}\\textit{reg}_2\\texttt{),}  & \\textit{seq}_1                             \\\\\n                       & \\textit{seq}_2                             & \\textit{seq}_2                              & \\texttt{restore(}\\textit{reg}_1\\texttt{),} \\\\\n                       &                                            &                                             & \\texttt{restore(}\\textit{reg}_2\\texttt{),} \\\\\n                       &                                            &                                             & \\textit{seq}_2\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    By using ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" to combine instruction\n    sequences the compiler avoids unnecessary\n    \n    stack operations.  This also\n    isolates the details of whether or not to generate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":"\n    instructions within the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":"function,\n    separating them from the concerns that arise in writing each of the\n    individual code  generators.\n    In fact no ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" or\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":" instructions are explicitly\n    produced by the code\n    \n\t      generators, except that the code for calling a function saves\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" and the code for returning\n        from a function restores it: These corresponding\n  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":"\n  instructions are explicitly generated \n\tby different calls to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":",\n  not as a matched pair by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":"\n  (as we will see in section ","tag":"#text"},{"tag":"REF","body":"5.5.3","href":"/sicpjs/5.5.3"},{"body":").\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    In principle, we could represent an instruction sequence simply as a\n    list of instructions.\n    \n\tThe function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_instruction_sequences"},{"body":"\n    could then combine instruction sequences by performing an ordinary list\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":".  However,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" would then be a complex operation,\n    because it would have to analyze each instruction sequence to\n    determine how the sequence uses its registers.\n    \n\t      The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":"\n    would be inefficient as well as complex, because it would have to\n    analyze each of its instruction sequence arguments, even though these\n    sequences might themselves have been constructed by calls to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":", in which case their parts would\n    have already been analyzed.  To avoid such repetitious analysis we will\n    associate with each instruction sequence some information about its register\n    use. When we construct a basic instruction sequence we\n    will provide this information explicitly,\n    and the\n    functions\n    that combine instruction sequences will derive\n    register-use information for the combined sequence from the\n    information associated with the sequences being combined.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    An instruction sequence will contain three pieces of information:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"the set of registers that must be initialized before the\n      instructions in the sequence are executed (these registers are said to\n      be ","tag":"#text"},{"tag":"EM","child":[{"body":"needed","tag":"#text"}]},{"body":" by the sequence),\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"the set of registers whose values are modified by the\n      instructions in the sequence, and\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"the actual instructions\n      \n      in the sequence.\n      ","tag":"#text"}]}]},{"body":"\n    We will represent an instruction sequence as a list of its three\n    parts.  The constructor for instruction sequences is thus\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"function make_instruction_sequence(needs, modifies, instructions) {\n    return list(needs, modifies, instructions);\n}"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    For example, the two-instruction\n    sequence that looks up the value of the\n    \n\tsymbol\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"x\""},{"body":"\n    in the current environment,\n    assigns the result to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":",\n    and then proceeds to the continuation,\n    requires registers ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" to have been initialized, and\n    modifies register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":".\n    This sequence would therefore be constructed as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"make_instruction_sequence(list(\"env\", \"continue\"), list(\"val\"),\n    list(assign(\"val\",\n                list(op(\"lookup_symbol_value\"), constant(\"x\"),\n                     reg(\"env\"))),\n         go_to(reg(\"continue\"))));"}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    The\n    functions\n    for combining instruction sequences are shown in\n    section ","tag":"#text"},{"tag":"REF","body":"5.5.4","href":"/sicpjs/5.5.4"},{"body":".\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.31","id":"#ex-5.31","child":[{"body":"\n    In evaluating a\n    function\n    application, the explicit-control evaluator always saves and restores\n    the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register around the evaluation of the\n    function expression,\n    saves and restores ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" around the\n    evaluation of each\n    argument expression\n    (except the final one), saves and restores\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" around the evaluation of each\n    argument expression,\n    and saves and restores\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":"\n    around the\n    evaluation of the\n    argument-expression\n    sequence.  For each of the following\n    applications,\n    say which of these ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":" operations are superfluous and\n    thus could be eliminated by the compiler's\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" mechanism:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"f(\"x\", \"y\")\n\nf()(\"x\", \"y\")\n\nf(g(\"x\"), y)\n\nf(g(\"x\"), \"y\")"}]},{"tag":"EXERCISE","title":"Exercise 5.32","id":"#ex-5.32","child":[{"body":"\n    Using the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" mechanism, the compiler\n    will avoid saving and restoring ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" around the\n    evaluation of the\n    \n\tfunction expression of an application\n      \n    in the case where the\n    \n\tfunction expression is a name.\n      \n    We could also build such optimizations into the evaluator.\n    Indeed, the explicit-control evaluator of\n    section ","tag":"#text"},{"tag":"REF","body":"5.4","href":"/sicpjs/5.4"},{"body":" already performs a similar\n    optimization, by treating\n    \n\tapplications with no arguments\n      \n    as a special case.\n    ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\tExtend the explicit-control evaluator to recognize as a separate class\n\tof\n\t\n\t    components applications whose function expression is a name,\n\t  \n\tand to take\n\tadvantage of this fact in evaluating such\n\t\n\t    components.\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tAlyssa P. Hacker suggests that by extending the evaluator to recognize\n\tmore and more special cases we could incorporate all the compiler's\n\toptimizations, and that this would eliminate the advantage of compilation\n\taltogether.  What do you think of this idea?\n      ","tag":"#text"}]}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.5.1#footnote-link-1","child":[{"body":"Notice,\n    however, that our compiler is a\n    JavaScript\n    program, and the syntax\n    functions\n    that it uses to manipulate expressions are the actual\n    JavaScript functions\n    used with the metacircular evaluator.  For the explicit-control evaluator, in\n    contrast, we assumed that equivalent syntax operations were available\n    as operations for the register machine.  (Of course, when we simulated\n    the register machine in\n    JavaScript,\n    we used the actual\n    JavaScript functions\n    in our register machine simulation.)","tag":"#text"}]}]