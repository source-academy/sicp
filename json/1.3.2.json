[{"id":"/sicpjs/1.3.2","tag":"TITLE","body":"1.3.2  \n    \n      \n      Constructing Functions using Lambda Expressions"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n        In using ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum"},{"body":" as in\n\tsection ","tag":"#text"},{"tag":"REF","body":"1.3.1","href":"/sicpjs/1.3.1"},{"body":", it seems\n\tterribly awkward to have to declare trivial functions such as\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pi_term"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pi_next"},{"body":" just so we can use them as\n\targuments to our higher-order function. Rather than declare\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pi_next"},{"body":" and \n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pi_term"},{"body":", it would be more convenient\n        to have a way to directly specify \"","tag":"#text"},{"body":"the function that returns its\n        input incremented by 4","tag":"#text"},{"body":"\" and \"","tag":"#text"},{"body":"the function that returns the\n        reciprocal of its input times its input plus 2.","tag":"#text"},{"body":"\"  We can do this\n\tby introducing the ","tag":"#text"},{"tag":"EM","child":[{"body":"lambda expression","tag":"#text"}]},{"body":" as a syntactic form for\n\tcreating functions.\n\tUsing lambda expressions, we can describe what we want as\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAPUAXgD5QiBqUAFiA","body":"x => x + 4 "},{"body":"\n        and \n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAPUAXgD5VQwAKIgKlBtAGpRsBKNoA","body":"x => 1 / (x * (x + 2)) "},{"body":"\n\tThen we can express our\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pi_sum"},{"body":"\n\tfunction\n      \n    without \n    declaring any auxiliary functions:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":7,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0AZyIFsAKCgUwCdmAaUAIb8SHAB4V+AIwCUoAN65QS0Fw4UiXegNAA+UJMXKjygPygADIeNGAXKE49WA2QGpGLdtz6gR4p9OExCX1pAG5cAF98YnJqOlAAByoAfSY2IRD5KxU1DXo01lFQAF49FFAwQtAAKlAqt2xpAOzrYyEW1uUi0tAitwAWXg7OkPCo3AAOGsSUgpR+FHMlsKA","body":"function pi_sum(a, b) {\n    return sum(x => 1 / (x * (x + 2)),\n               a,\n               x => x + 4,\n               b);\n} "}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Again using \n    a lambda expression, \n    we can write the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"integral"},{"body":"function\n    without having to \n    declare the auxiliary function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_dx"},{"body":":","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":11,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0AZyIFsAKCgUwCdmAaUAIb8SHAB4V+AIwCUoAN65QS0Fw4UiXegNAA+UJMXKjygPygADIeNGAXKE49WA2QGpGLdtz6gR4p9OExCX1pAG5cAF98YnJqOlAyIkkOVlFZBSNVdU1QUVAAKlyC3PCowlJKWnoqEk4Acy4BABtWAn4hfX4AEzT5KxU1DXomNjb+62NtNx7QMGxecYnlPIBePTzp0QWliZlF43z9ox7S-Br6xpbE5P5zfhRbtHMUMKA","body":"function integral(f, a, b, dx) {\n    return sum(f,\n               a + dx / 2,\n               x => x + dx,\n               b)\n           *\n           dx;\n} "}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n        In general, lambda expressions are used to create functions in the\n\tsame way as function declarations,\n\t\n\texcept that no name is specified for the function and the\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return"},{"body":" keyword and braces are omitted\n\t(if there is only one\n\tparameter, the\n\t\n\tparentheses around the parameter list can also be\n\tomitted, as in the examples we have\n\tseen).","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/1.3.2#footnote-1"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n($parameters$) => $expression$\n\t  "},{"body":"\n\tThe resulting function is just as much a function\n\tas one that is created using a function declaration statement.\n\t\n\tThe only difference is that it has not been associated with any name in the\n\tenvironment. \n    We consider","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0ABwBsiBnAFgAoAPASlADeoXKFGgATgFMKRcfW6gA1KHYBuYQF98zNlwy9VQA","body":"function plus4(x) { \n    return x + 4; \n} "},{"body":"\n\tto be\n\tequivalent to","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/1.3.2#footnote-2"},{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuBjAewDsBnAF1AAcAbAVzIBZQBeUADzYD5PQBqUEwDc+OoyYAKDAEphQA","body":"const plus4 = x => x + 4; "},{"body":"\n        We can read a lambda expression as follows:\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"//                      x         =>                   x    +   4\n//                      ^         ^                    ^    ^   ^\n// the function of an argument x that results in the value plus 4"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Like any expression that has a\n    function\n    as its value, a\n    lambda\n    expression can be used as the function expression in an application\n     such as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0AZwEciBDAJwFMAKADwEpQAb1ygxoLhSLt6vUACpQvANy4Avvm58ANKACeugF6CAvAD4loANT7rjFhx7H+3FLuy6M-ZUA","body":"((x, y, z) => x + y + square(z))(1, 2, 3); ","output":"12"},{"body":"\n    or, more generally, in any context where we would normally use a\n    function\n    name.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/1.3.2#footnote-3"},{"body":"Note that ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"=>"},{"body":"\n  has\n  \n  lower precedence than function application and thus the\n  \n  parentheses around the lambda expression are necessary here.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Using \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"const"},{"body":" to create local names\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Another use of \n    \n\tlambda expressions is in creating local names.\n      \n\tWe often need local names in our functions\n\tother than those that have been bound as parameters.\n      \n    For example, suppose we wish to compute the function\n    ","tag":"#text"},{"body":"\n      \\[\\begin{array}{lll}\n      f(x, y)&=&x(1 + x y)^2 +y (1 - y) + (1 + x y)(1 - y)\n      \\end{array}\\]\n    ","tag":"LATEX"},{"body":"\n    which we could also express as\n    ","tag":"#text"},{"body":"\n      \\[\\begin{array}{rll}\n      a &=& 1+xy\\\\\n      b &=& 1-y\\\\\n      f(x, y) &= &x a^2 +y b + a b\n      \\end{array}\\]\n    ","tag":"LATEX"},{"body":"\n    In writing a\n    function\n    to compute ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":", we would like to include as\n    \n\tlocal names\n      \n    not only ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":"\n    but also the names of intermediate quantities like\n    ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":".  One way\n    to accomplish this is to use an auxiliary\n    function to bind the local names:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0AZwEciBDAJwFMAKADwEpQAb1ygxoLhSLt6vUACpQvANy4AvvmLlqdUAT4AaUAE9BI8XtKVa9AgH0AFpwA2AB07turIwCMzoi3FJaVkFRhYOHlZBAGoTMJ9QONYE1QsNC2CZPUcXd08UJKUw4yNCgFoTflUNQm4MIwAWaqA","body":"function f(x, y) {\n    function f_helper(a, b) {\n        return x * square(a) + y * b + a * b;\n    }\n    return f_helper(1 + x * y, 1 - y);\n} "}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Of course, we could use a \n    lambda\n    expression to specify an anonymous\n    function for binding our local names.\n    The\n    \n\tfunction body\n      \n    then becomes a single call to that\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0AZwEciBDAJwFMAKADwEpQAb1ygxoLhSLt6vUACpQvANy4AvvmLlqdUAQD62PgBpQAT0EjxEzlJmhuD1qYBGggLwA+JQsYsOPKyCANTmvi6goazhotZxoPzcKJE+imamyQC05vyqGoSG3BimACy5QA","body":"function f_2(x, y) {\n    return ( (a, b) => x * square(a) + y * b + a * b\n           )(1 + x * y, 1 - y);\n} "},{"body":"\n        A more convenient way to declare local names is by using constant\n\tdeclarations within the body of the function. Using\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"const"},{"body":", the  function\n\t\n\tcan be written as\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0AZwEciBDAJwFMAKADwEpQAb1ygxoLhSLt6vUACpQvANy4AvvmLlqdUAQD6GPgBpQAT0EjxoMnQYVQrUAF5UoANRKF51ddsl7UAAjFzcAWh9RcUlpWW9mNi5uVkFPM28QzydFINUNQkNuDFMAFn5lIA","body":"function f_3(x, y) {\n    const a = 1 + x * y;\n    const b = 1 - y;\n    return x * square(a) + y * b + a * b;\n} "},{"body":"\n      Names that are declared with\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"const"},{"body":" inside a block have the\n      body of the immediately surrounding block as their scope.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/1.3.2#footnote-4"},{"body":"$^,$","tag":"LATEX"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/1.3.2#footnote-5"}]},{"tag":"TEXT","id":"#p7","child":[{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Conditional statements\n        ","tag":"#text"}]},{"body":"\n      We have seen that it is often useful to declare names that are local to\n      function declarations. When functions become big, we should\n      keep the scope of the names as narrow as possible. \n      Consider for example ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"expmod"},{"body":" in\n      exercise ","tag":"#text"},{"tag":"REF","body":"1.26","href":"/sicpjs/1.2.6#ex-1.26"},{"body":".\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0KgZwH0BTAN1ZIAoSBKUAG9coUaABOrCkXH16AUlDZQAXjWgADAG5cAX3zFy1OqFYAPAA4BbGgBNuAIwCGjVgBpTlj1YHCxEqRl6cwtVdQ0RfyjQAH5USOixAC4GFg4ubhC+BMTY0G5REJt7Z1cPENAwbG9s3OiAKk9rO0cXdybKpRqBRSscxJTW11BGopbS9oqAWlRu0F6dfVwx+wAWDwwPAFY+LSA","body":"function expmod(base, exp, m) {\n    return exp === 0\n           ? 1\n           : is_even(exp)\n           ? (  expmod(base, exp / 2, m)\n              * expmod(base, exp / 2, m)) % m\n           : (base * expmod(base, exp - 1, m)) % m;\n} "},{"body":"\n      This function is unnecessarily inefficient, because it contains two\n      identical calls:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":13,"eval":true,"prependLength":14,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0KgZwH0BTAN1ZIAoSBKUAG9coUaABOrCkXH16AUlDZQAXjWgADAG5cAX3zFy1OqFYAPAA4BbGgBNuAIwCGjVgBpTlj1YHCxEqRl6cwtVdQ0RfyjQAH5USOixAC4GFg4ubhC+BMTY0G5REJt7Z1cPENAwbG9s3OiAKk9rO0cXdybKpRqBRSscxJTW11BGopbS9oqAWlRu0F6dfVwx+wAWDwwPAFY+LSA","body":"expmod(base, exp / 2, m); "},{"body":"\n      While this can be easily fixed in this example using the\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" function, this is not so easy\n      in general. Without using ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":",\n      we would be tempted to introduce a local name for the expression as\n      follows:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":14,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0KgZwH0BTAN1ZIAoSBKUAG9coUaABOrCkXH16AUlDZQAXjWgADAG5cAX3zFy1OqFYAPAA4BbGgBNuAIwCGjVgBpTlj1YHCxoMjpGClAACycAGwI2S1VPaztHF3d40DBsbz4df0lpWVS1FU0Rf1LQAH5UErKxAC4GFg4ubnMLPmqaitBucKiYi1AAKjDI6NaBRSsOmvqk1yH4m3tnVw9W0ABaVEyJ0CsdfVxWpe4AFg8MDwBWLKA","body":"function expmod(base, exp, m) {\n    const half_exp = expmod(base, exp / 2, m);\n    return exp === 0\n           ? 1\n           : is_even(exp)\n           ? (half_exp * half_exp) % m\n           : (base * expmod(base, exp - 1, m)) % m;\n} "},{"body":"\n      This would make the function not just inefficient, but actually\n      nonterminating! The problem is that the constant declaration appears\n      outside the conditional expression, which means that it is executed even\n      when the base case ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"exp === 0"},{"body":" is met.\n      To avoid this situation, we provide for\n      ","tag":"#text"},{"tag":"EM","child":[{"body":"conditional statements","tag":"#text"}]},{"body":", and allow return\n      statements to appear in the branches of the statement. Using a\n      conditional statement, we can write the function\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"expmod"},{"body":" as follows:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":15,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0KgZwH0BTAN1ZIAoSBKUAG9coUaABOrCkXH16AUlDZQAXjWgADAG5cAX3zFy1OqFYAPAA4BbGgBNuAIwCGjVgBpTlj1YHCxDAlBucwtVdQ1fEX8xSWlZVB1-XVMAG1chKOiAoKY2Th4QvkisrLI6RgpQAAsnFII2S1VPaztHF3dm0DBsbz5Ekv9YmXpuGrqG0IAqatr6wtBFK36s5NY01gyBwalhoOd06ZCbe32OkNAAWlRegUXl6P0kgEh-PXwj1oAWDwwPAFY+kA","body":"function expmod(base, exp, m) {\n    if (exp === 0) {\n        return 1;\n    } else {\n        if (is_even(exp)) {\n            const half_exp = expmod(base, exp / 2, m);\n            return (half_exp * half_exp) % m;\n        } else {\n            return (base * expmod(base, exp - 1, m)) % m;\n        }\n    }\t    \n} "}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n      The general form of a conditional statement is\n      ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nif ($predicate$) { $consequent$-$statements$ } else { $alternative$-$statements$ }\n\t"},{"body":"\n      As for a conditional expression, the interpreter first evaluates the\n      ","tag":"#text"},{"tag":"META","body":"predicate"},{"body":". If it evaluates to true,\n      the interpreter evaluates the\n      ","tag":"#text"},{"tag":"META","body":"consequent-statements"},{"body":" in sequence, and if it\n      evaluates to false, the interpreter evaluates\n      \n      the ","tag":"#text"},{"tag":"META","body":"alternative-statements"},{"body":" in sequence. Evaluation of a return\n      statement returns from the surrounding function, ignoring any\n      statements in the sequence\n      \n      after the return statement and any statements after the conditional statement.\n      Note that any constant declarations occurring in either part are local to that\n      part, because each part is enclosed in braces and thus forms its own\n      block.\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 1.34","id":"#ex-1.34","child":[{"body":" \n    Suppose we \n    declare","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":16,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0AgCgHMBKUAb11B4CcBTCkV71mjbKwDcuAL5A","body":"function f(g) {\n   return g(2);\n} "},{"body":"\n    Then we have\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":17,"eval":true,"prependLength":9,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0AgCgHMBKUAb11B4CcBTCkV71mjbKwDcuAL75i5anVABnAI5EAhgMYAPdlx59Bw+rtAAqULulzCjdVoFSgA","body":"f(square); ","output":"4"},{"tag":"SNIPPET","latex":false,"id":18,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuAzAVwDsBjAFwEsB7E0AgCgHMBKUAb11B4CcBTCkV71mjbKwDcuAL74mAL1ABeAHyglAKlCMlAalSspQA","body":"f(z => z * (z + 1)); ","output":"6"},{"body":"\n    What happens if we (perversely) ask the interpreter to evaluate the\n    application ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f(f)"},{"body":"?\n      \n    Explain.\n    ","tag":"#text"}],"solution":[{"tag":"TEXT","id":"#p9","child":[{"body":"\n\tLet's use the substitution model to illustrate what happens:\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":19,"eval":false,"body":"f(f)\nf(2)\n2(2)"},{"body":"\n\tThe application ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"2(2)"},{"body":" leads to an\n\terror, since 2 is neither a primitive nor a compound function. \n      ","tag":"#text"}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/1.3.2#footnote-link-1","child":[{"body":"In section ","tag":"#text"},{"tag":"REF","body":"2.2.4","href":"/sicpjs/2.2.4"},{"body":", we will\n\textend the syntax of\n\tlambda expressions to allow a block as the body rather than just\n\tan expression, as in function declaration\n\tstatements.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/1.3.2#footnote-link-2","child":[{"body":"In\n\tJavaScript, there are subtle differences between the two versions:\n\tA function declaration statement is\n\t\n\tautomatically ``hoisted'' (moved) to the beginning of the surrounding\n\tblock or to the beginning of the program if it occurs\n\toutside of any block, whereas a constant declaration is not moved.\n\tNames declared with function declaration can be reassigned using\n\tassignment (section ","tag":"#text"},{"tag":"REF","body":"3.1.1","href":"/sicpjs/3.1.1"},{"body":"), whereas\n\tnames declared with constant declarations can't. In this\n\tbook, we avoid these features and treat a\n\tfunction declaration as equivalent to the corresponding constant\n\tdeclaration.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/1.3.2#footnote-link-3","child":[{"body":"It would be clearer and less intimidating to people learning\n    JavaScript\n    if a\n    term\n    more obvious than\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"lambda expression","tag":"#text"}]},{"body":", such as ","tag":"#text"},{"tag":"EM","child":[{"body":"function definition","tag":"#text"}]},{"body":",\n      \n    were used. But the convention is\n    \n\tvery firmly entrenched, not just for Lisp and Scheme but also for\n\tJavaScript, Java and other languages, no doubt partly due to the\n\tinfluence of the Scheme editions of this book.\n\t\n    The notation is adopted from the\n    ","tag":"#text"},{"body":"$\\lambda$","tag":"LATEX"},{"body":" calculus, a\n    mathematical formalism introduced by the mathematical logician\n    \n    Alonzo Church (1941).  Church developed the\n    ","tag":"#text"},{"body":"$\\lambda$","tag":"LATEX"},{"body":" calculus to provide a rigorous\n    foundation for studying the notions of\n    function and function application.  The\n    ","tag":"#text"},{"body":"$\\lambda$","tag":"LATEX"},{"body":" calculus has become a basic\n    tool for mathematical investigations of the\n    semantics of programming languages.\n  ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/1.3.2#footnote-link-4","child":[{"body":"\n      Note that a name declared in a block cannot be used before the\n      declaration is fully evaluated, regardless of whether the same name is\n      declared outside the block. Thus in the program below, the\n      attempt to use the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" declared\n      at the top level \n      to provide a value for the calculation of \n      the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" declared in\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":" cannot work.\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":20,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGY0CYBQuBjAewDsBnAF1AENQBeVAblwDMBXEgigS1NBYAUADwCUoAN6gp03NNDFyVAEb0aoANSghzOQspqGAVh3SATgFMKbUyTWalzAL6sBKAAwjGQA","body":"const a = 1;\nfunction f(x) {      \n    const b = a + x;\n    const a = 5;\n    return a + b;\n}\nf(10); "},{"body":"\n      The program\n      leads to an error, because the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" in\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a + x"},{"body":" is used before its declaration\n      is evaluated. We will return to this program in\n      section ","tag":"#text"},{"tag":"REF","body":"4.1.6","href":"/sicpjs/4.1.6"},{"body":"\n      (exercise ","tag":"#text"},{"tag":"REF","body":"4.19","href":"/sicpjs/4.1.6#ex-4.19"},{"body":"), after we learn\n      more about evaluation.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/1.3.2#footnote-link-5","child":[{"body":"The substitution\n      model can be expanded to say that for a constant declaration, the value of the\n      expression after ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"="},{"body":"\n      is substituted for the name before\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"="},{"body":"\n      in the rest of the block body (after the declaration), similar to the\n      substitution of arguments for parameters in the evaluation of a\n      function application.","tag":"#text"}]}]