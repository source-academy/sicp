<SUBSECTION> 
  <NAME>
    <SPLITINLINE><SCHEME>Procedures</SCHEME><JAVASCRIPT>Functions</JAVASCRIPT></SPLITINLINE>
    as Returned Values
  </NAME>

  <LABEL NAME="sec:proc-returned-values"/>
  <INDEX>higher-order
  <SPLITINLINE><SCHEME>procedures</SCHEME>
  <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  <SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  as general method|)</SUBINDEX></INDEX>
  <INDEX><SPLITINLINE><SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SUBINDEX>general@as general method|)</SUBINDEX></INDEX>

  <TEXT>
    The above examples demonstrate how
    the ability to pass
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    as arguments significantly enhances
    the expressive power of our programming language.  We can achieve even
    more expressive power by creating
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    whose returned values are
    themselves
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.
  </TEXT>

  <TEXT>
    We can illustrate this idea by looking again at the fixed-point
    example described at the end of
    section<SPACE/><REF NAME="sec:proc-general-methods"/>.  We formulated a new version
    of the square-root
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    as a fixed-point search, starting with
    the observation that <LATEXINLINE>$\sqrt{x}$</LATEXINLINE> is a fixed-point of the function
    <LATEXINLINE>$y\mapsto x/y$</LATEXINLINE>.  Then we used average damping to make the
    approximations converge.  Average damping is a useful general
    technique in itself.  Namely, given a function<SPACE/><LATEXINLINE>$f$</LATEXINLINE>, we consider the
    function whose value at <LATEXINLINE>$x$</LATEXINLINE> is equal to the average of <LATEXINLINE>$x$</LATEXINLINE> and <LATEXINLINE>$f(x)$</LATEXINLINE>.
  </TEXT>
  
  <TEXT>
    We can express the idea of average damping by means of the
    following
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>:
    <SNIPPET PAGE="72">
      <NAME>average_damp_definition</NAME>
      <REQUIRES>average_definition</REQUIRES>
      <EXAMPLE>average_damp_example</EXAMPLE>
      <SCHEME>
(define (average-damp f)
  (lambda (x) (average x (f x))))
          </SCHEME>
          <JAVASCRIPT>
function average_damp(f) {
    return x => average(x, f(x));
}
          </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>Average-damp</SCHEMEINLINE> 
      </SCHEME>
      <JAVASCRIPT>
        The function
        <JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that takes as its argument a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SCHEMEINLINE>f</SCHEMEINLINE> and returns as its value a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    (produced by the 
    <SPLITINLINE><SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME><JAVASCRIPT>function definition expression</JAVASCRIPT></SPLITINLINE>) that, when applied to a number <SCHEMEINLINE>x</SCHEMEINLINE>, produces the
    average of <SCHEMEINLINE>x</SCHEMEINLINE> and 
    <SPLITINLINE><SCHEME><SCHEMEINLINE>(f x)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>f(x)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  
    For example, applying 
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>average-damp</SCHEMEINLINE> 
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to the <SCHEMEINLINE>square</SCHEMEINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    produces a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    whose
    value at some number <LATEXINLINE>$x$</LATEXINLINE> is the average of 
    <LATEXINLINE>$x$</LATEXINLINE> and <LATEXINLINE>$x^2$</LATEXINLINE>.  
    Applying this resulting
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    to 10 returns the average of 10 and 100, or
    55:<FOOTNOTE>Observe that this is a combination 
    whose operator is itself
    <INDEX>combination<SUBINDEX>combination as operator of</SUBINDEX></INDEX>
    <INDEX>combination<SUBINDEX>operator@as operator of combination</SUBINDEX></INDEX>
    <INDEX>operator of a combination<SUBINDEX>combination as</SUBINDEX></INDEX>
    a combination.  Exercise<SPACE/><REF NAME="ex:a-plus-abs-b"/> already demonstrated
    the ability to form such combinations, but that was only a toy
    example.  Here we begin to see the real need for such
    combinations<EMDASH/>when applying a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that is obtained as the value
    returned by a higher-order
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.</FOOTNOTE>
    <SNIPPET PAGE="73">
      <NAME>average_damp_example</NAME>
      <REQUIRES>average_damp_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
((average-damp square) 10)
      </SCHEME>
      <JAVASCRIPT>
average_damp(square)(10);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>fixed point<SUBINDEX>square root as</SUBINDEX></INDEX>
    Using 
    <SPLITINLINE><SCHEME><SCHEMEINLINE>average-damp</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
    we can reformulate the square-root
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    as follows:

    <SNIPPET PAGE="73">
      <NAME>sqrt_definition4</NAME>
      <REQUIRES>average_damp_definition</REQUIRES>
      <REQUIRES>fixed_definition</REQUIRES>
      <EXAMPLE>sqrt_example3</EXAMPLE>
      <SCHEME>
(define (sqrt x)
  (fixed-point 
    (average-damp 
      (lambda (y) (/ x y)))
      1.0))
      </SCHEME>
      <JAVASCRIPT>
function sqrt(x) {
    return fixed_point(average_damp(y => x / y),
                       1.0);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>sqrt_example3</NAME>
      <REQUIRES>sqrt_definition4</REQUIRES>
      <JAVASCRIPT>
sqrt(6);
      </JAVASCRIPT>
    </SNIPPET>

  </TEXT>

  <TEXT>
    Notice how this formulation makes explicit the three ideas in the
    method: fixed-point search, average damping, and the function
    <LATEXINLINE>$y\mapsto x/y$</LATEXINLINE>.  It is instructive to compare this formulation of the
    square-root method with the original version given in
    section<SPACE/><REF NAME="sec:sqrt"/>.  Bear in mind that these
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    express
    the same process, and notice how much clearer the idea becomes when we
    express the process in terms of these abstractions.  In general, there
    are many ways to formulate a process as a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.  Experienced
    programmers know how to choose <SPLITINLINE><SCHEME>procedural</SCHEME><JAVASCRIPT>process</JAVASCRIPT></SPLITINLINE> formulations that are
    particularly perspicuous, and where useful elements of the process are
    exposed as separate entities that can be reused in other applications.
    As a simple example of reuse, notice that the cube root of <LATEXINLINE>$x$</LATEXINLINE> is a
    fixed point of the function <LATEXINLINE>$y\mapsto x/y^2$</LATEXINLINE>, so we can immediately
    generalize our square-root
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    to one that extracts 
    <INDEX>cube root<SUBINDEX>fixed@as fixed point</SUBINDEX></INDEX>
    <INDEX>fixed point<SUBINDEX>cube root as</SUBINDEX></INDEX>
    cube
    roots:<FOOTNOTE>See exercise<SPACE/><REF NAME="ex:nth-roots"/> 
    for a further generalization.</FOOTNOTE>

    <SNIPPET PAGE="73">
      <NAME>cube_root_definition</NAME>
      <REQUIRES>average_damp_definition</REQUIRES>
      <REQUIRES>fixed_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>cube_root_example</EXAMPLE>
      <SCHEME>
(define (cube-root x)
  (fixed-point 
    (average-damp (lambda (y) (/ x (square y))))
    1.0))
      </SCHEME>
      <JAVASCRIPT>
function cube_root(x) {
    return fixed_point(average_damp(y => x / square(y)),
                       1.0);
}
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET PAGE="24" HIDE="yes">
      <NAME>cube_root_example</NAME>
      <REQUIRES>cube_root_definition</REQUIRES>
      <SCHEME>
(cube-root 27)
      </SCHEME>
      <JAVASCRIPT>
cube_root(27);
      </JAVASCRIPT>
    </SNIPPET>

    <!-- \indcode*{cube-root} -->
  </TEXT>

  <SUBHEADING>
    <NAME>Newton<APOS/>s method</NAME>
  </SUBHEADING>

  <TEXT>
    <INDEX>Newton<APOS/>s method<SUBINDEX>diff@for differentiable functions|(</SUBINDEX></INDEX>
    When we first introduced the square-root
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, in
    section<SPACE/><REF NAME="sec:sqrt"/>, we mentioned that this was a special case of
    <EM>Newton<APOS/>s method</EM>.  
    If <LATEXINLINE>$x\mapsto g(x)$</LATEXINLINE> is a differentiable function, then a solution of
    the equation <LATEXINLINE>$g(x)=0$</LATEXINLINE> is a fixed point of the function <LATEXINLINE>$x\mapsto f(x)$</LATEXINLINE>
    where
    <LATEX>
      \[
      f(x) = x - \frac{g(x)}{Dg(x)}
      \]
    </LATEX>
    and
    <LATEXINLINE>$Dg(x)$</LATEXINLINE> is the derivative of <LATEXINLINE>$g$</LATEXINLINE> evaluated at <LATEXINLINE>$x$</LATEXINLINE>.  
    <INDEX>fixed point<SUBINDEX>Newton@in Newton<APOS/>s method</SUBINDEX></INDEX>
    Newton<APOS/>s
    method is the use of the fixed-point method we saw above to
    approximate a solution of the equation by finding a fixed point of
    the function <LATEXINLINE>$f$</LATEXINLINE>.<FOOTNOTE>Elementary 
    calculus books usually describe Newton<APOS/>s
    method in terms of the sequence of approximations
    <LATEXINLINE>$x_{n+1}=x_n-g(x_n)/Dg(x_n)$</LATEXINLINE>.  Having language for talking about
    processes and using the idea of fixed points simplifies the description
    of the method.</FOOTNOTE>
    For many functions <LATEXINLINE>$g$</LATEXINLINE> and for sufficiently good initial guesses for
    <LATEXINLINE>$x$</LATEXINLINE>, Newton<APOS/>s method converges very rapidly to a solution of
    <LATEXINLINE>$g(x)=0$</LATEXINLINE>.<FOOTNOTE>Newton<APOS/>s 
    method does not always converge to an answer, but
    it can be shown that in favorable cases each iteration doubles the
    number-of-digits accuracy of the approximation to the solution.
    In such cases, 
    <INDEX>Newton<APOS/>s method<SUBINDEX>half-interval method vs.</SUBINDEX></INDEX>
    <INDEX>half-interval method<SUBINDEX>Newton<APOS/>s method vs.</SUBINDEX></INDEX>
    Newton<APOS/>s method will converge much more
    rapidly than the half-interval method.</FOOTNOTE>
  </TEXT>

  <TEXT>
    <INDEX>derivative of a function</INDEX>
    <INDEX>function (mathematical)<SUBINDEX>derivative of</SUBINDEX></INDEX>
    <INDEX>differentiation<SUBINDEX>numerical</SUBINDEX></INDEX>
    In order to implement Newton<APOS/>s method as a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, we must first
    express the idea of derivative.  Note that <QUOTE>derivative,</QUOTE> like
    average damping, is something that transforms a function into another
    function.  For instance, the derivative of the function <LATEXINLINE>$x\mapsto
    x^3$</LATEXINLINE> is the function <LATEXINLINE>$x \mapsto 3x^2$</LATEXINLINE>.  In general, if <LATEXINLINE>$g$</LATEXINLINE> is a
    function and <LATEXINLINE>$dx$</LATEXINLINE> is a small number, then the derivative <LATEXINLINE>$Dg$</LATEXINLINE> of <LATEXINLINE>$g$</LATEXINLINE> is
    the function whose value at any number <LATEXINLINE>$x$</LATEXINLINE> is given (in the limit of
    small <LATEXINLINE>$dx$</LATEXINLINE>) by
    <LATEX>
      \[Dg(x) = \frac {g(x+dx) - g(x)}{dx} \]
    </LATEX>
    Thus, we can express the idea of derivative (taking <LATEXINLINE>$dx$</LATEXINLINE> to be, say,
    0.00001) as the
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>

    <SNIPPET PAGE="74">
      <NAME>deriv_definition</NAME>
      <EXAMPLE>deriv_example</EXAMPLE>
      <SCHEME>
(define (deriv g)
  (lambda (x)
    (/ (- (g (+ x dx)) (g x))
       dx)))
      </SCHEME>
      <JAVASCRIPT>
function deriv(g) {
    return x => (g(x + dx) - g(x)) / dx;
}
      </JAVASCRIPT>
    </SNIPPET>

    along with the
    <SPLITINLINE><SCHEME>definition</SCHEME>
    <JAVASCRIPT>declaration</JAVASCRIPT></SPLITINLINE>

    <SNIPPET>
      <NAME>dx</NAME>
      <SCHEME>
	(define dx 0.00001)
      </SCHEME>
      <JAVASCRIPT>
const dx = 0.00001;
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <!--\indcodeplus*{deriv}{(numerical)}-->
    Like 
    <SPLITINLINE><SCHEME><SCHEMEINLINE>average-damp</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
    <SCHEMEINLINE>deriv</SCHEMEINLINE> is a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that takes a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    as argument and returns a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    as value.  For example,
    to approximate the derivative of <LATEXINLINE>$x \mapsto x^3$</LATEXINLINE> at 5 (whose exact
    value is 75) we can evaluate

    <SNIPPET PAGE="74">
      <NAME>deriv_example</NAME>
      <REQUIRES>dx</REQUIRES>
      <REQUIRES>deriv_definition</REQUIRES>
      <SCHEME>
(define (cube x) (* x x x))

((deriv cube) 5)
      </SCHEME>
      <SCHEMEOUTPUT>
75.00014999664018
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
function cube(x) { return x * x * x; }

deriv(cube)(5);
      </JAVASCRIPT>
    </SNIPPET>
    <!-- \indcode*{cube} -->
  </TEXT>

  <TEXT>
    With the aid of <SCHEMEINLINE>deriv</SCHEMEINLINE>, we can express Newton<APOS/>s method as a
    fixed-point process:

    <SNIPPET PAGE="74-75">
      <NAME>newtons_method_definition</NAME>
      <REQUIRES>fixed_definition</REQUIRES>
      <REQUIRES>dx</REQUIRES>
      <REQUIRES>deriv_definition</REQUIRES>
      <EXAMPLE>sqrt_example4</EXAMPLE>
      <SCHEME>
(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point 
    (newton-transform g) guess))
      </SCHEME>
      <JAVASCRIPT>
function newton_transform(g) {
   return x => x - g(x) / deriv(g)(x);
}
function newtons_method(g, guess) {
   return fixed_point(newton_transform(g), guess);
}
      </JAVASCRIPT>
    </SNIPPET>
    <!-- \indcode*{newton-transform} -->
    <!-- \indcode*{newtons-method} -->
  </TEXT>
  <TEXT>
    The <SPLITINLINE><SCHEME><SCHEMEINLINE>newton-transform</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>newton_transform</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    expresses the formula at the
    beginning of this section, and <SPLITINLINE><SCHEME><SCHEMEINLINE>newtons-method</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>newtons_method</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is readily defined
    in terms of this.  It takes as arguments a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that computes the
    function for which we want to find a zero, together with an initial
    guess.  For instance, to find the 
    <INDEX>Newton<APOS/>s method<SUBINDEX>square@for square roots</SUBINDEX></INDEX>
    square root of <LATEXINLINE>$x$</LATEXINLINE>, we can use
    Newton<APOS/>s method to find a zero of the function <LATEXINLINE>$y\mapsto y^2-x$</LATEXINLINE> starting with
    an initial guess of 1.<FOOTNOTE>For finding square roots, 
    Newton<APOS/>s method converges rapidly to the
    correct solution from any starting point.</FOOTNOTE>
    This provides yet another form of the square-root
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>:

    <SNIPPET PAGE="75">
      <NAME>sqrt_definition5</NAME>
      <REQUIRES>newtons_method_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>sqrt_example4</EXAMPLE>
      <SCHEME>
(define (sqrt x)
  (newtons-method 
    (lambda (y) (- (square y) x))
    1.0))
      </SCHEME>
      <JAVASCRIPT>
function sqrt(x) {
    return newtons_method(y => square(y) - x,
                          1.0);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>sqrt_example4</NAME>
      <REQUIRES>sqrt_definition5</REQUIRES>
      <JAVASCRIPT>
sqrt(6);
      </JAVASCRIPT>
    </SNIPPET>
    <!-- \indcode*{sqrt}[Newton@with Newton<APOS/>s method] -->
    <INDEX>Newton<APOS/>s method<SUBINDEX>diff@for differentiable functions|)</SUBINDEX></INDEX>
  </TEXT>

  <SUBHEADING>
    <NAME>Abstractions and first-class
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE></NAME>
  </SUBHEADING>

  <TEXT>
    We<APOS/>ve seen two ways to express the square-root
    computation as an instance of a more general method, once as a fixed-point
    search and once using Newton<APOS/>s method.  Since Newton<APOS/>s method
    was itself expressed as a fixed-point process,
    we actually saw two ways to compute square roots as fixed points.
    Each method begins with a function and finds a 
    <INDEX>fixed point<SUBINDEX>transform@of transformed function</SUBINDEX></INDEX>
    fixed
    point of some transformation of the function.  We can express this
    general idea itself as a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>:

    <SNIPPET PAGE="75">
      <NAME>fixed_point_of_transform_definition</NAME>
      <REQUIRES>fixed_definition</REQUIRES>
      <EXAMPLE>sqrt_example5</EXAMPLE>
      <SCHEME>
(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))
      </SCHEME>
      <JAVASCRIPT>
function fixed_point_of_transform(g, transform, guess) {
    return fixed_point(transform(g), guess);
}
      </JAVASCRIPT>
    </SNIPPET>
    <!-- \indcode*{fixed-point-of-transform} -->
  </TEXT>

  <TEXT>
    This very general
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    takes as its arguments a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SCHEMEINLINE>g</SCHEMEINLINE>
    that computes some function, a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that transforms <SCHEMEINLINE>g</SCHEMEINLINE>, and
    an initial guess.  The returned result is a fixed point of the
    transformed function.
  </TEXT>

  <TEXT>
    <INDEX>fixed point<SUBINDEX>square root as</SUBINDEX></INDEX>
    Using this abstraction, we can recast the first square-root
    computation from this section (where we look for
    a fixed point of the average-damped version of <LATEXINLINE>$y \mapsto x/y$</LATEXINLINE>)
    as an instance of this general method:

    <SNIPPET PAGE="75">
      <NAME>sqrt_definition6</NAME>
      <REQUIRES>fixed_point_of_transform_definition</REQUIRES>
      <REQUIRES>average_damp_definition</REQUIRES>
      <EXAMPLE>sqrt_example5</EXAMPLE>
      <SCHEME>
(define (sqrt x)
  (fixed-point-of-transform 
    (lambda (y) (/ x y))
    average-damp
    1.0))
      </SCHEME>
      <JAVASCRIPT>
function sqrt(x) {
    return fixed_point_of_transform(
               y => x / y,
               average_damp,
               1.0);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>sqrt_example5</NAME>
      <REQUIRES>sqrt_definition6</REQUIRES>
      <JAVASCRIPT>
sqrt(6);
      </JAVASCRIPT>
    </SNIPPET>
    <!-- \indcode*{sqrt}[fixed@as fixed point] -->
  </TEXT>

  <TEXT>
    <INDEX>Newton<APOS/>s method<SUBINDEX>square@for square roots</SUBINDEX></INDEX>
    Similarly, we can express the second square-root computation from this section
    (an instance
    of Newton<APOS/>s method that finds a fixed point of the
    Newton transform of <LATEXINLINE>$y\mapsto y^2-x$</LATEXINLINE>) as

    <!-- \indcode*{sqrt}[fixed@as fixed point] -->
    <!-- \indcode*{sqrt}[Newton@with Newton<APOS/>s method] -->
    <SNIPPET PAGE="76">
      <NAME>sqrt_definition7</NAME>
      <REQUIRES>fixed_point_of_transform_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>newtons_method_definition</REQUIRES>
      <EXAMPLE>sqrt_example6</EXAMPLE>
      <SCHEME>
(define (sqrt x)
  (fixed-point-of-transform 
    (lambda (y) (- (square y) x))
    newton-transform
    1.0))
      </SCHEME>
      <JAVASCRIPT>
function sqrt(x) {
    return fixed_point_of_transform(
               y => square(y) - x,
               newton_transform,
               1.0);
}
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET HIDE="yes">
      <NAME>sqrt_example6</NAME>
      <REQUIRES>sqrt_definition7</REQUIRES>
      <JAVASCRIPT>
sqrt(6);
      </JAVASCRIPT>
    </SNIPPET>

  </TEXT>

  <TEXT>
    We began section<SPACE/><REF NAME="sec:higher-order-procedures"/> with the observation
    that compound
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    are a crucial abstraction mechanism, because they permit us to
    express general methods of computing as explicit elements in our
    programming language.  Now we<APOS/>ve seen how higher-order
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    permit us to manipulate these general methods
    to create further abstractions.
  </TEXT>
  
  <TEXT>
    As programmers, we should be alert to opportunities to identify the
    underlying abstractions in our programs and to build upon them and
    generalize them to create more powerful abstractions.  This is not to
    say that one should always write programs in the most abstract way
    possible; expert programmers know how to choose the level of
    abstraction appropriate to their task.  But it is important to be able
    to think in terms of these abstractions, so that we can be ready to
    apply them in new contexts.  The significance of higher-order
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    is that they enable us to represent these abstractions
    explicitly as elements in our programming language, so that they can
    be handled just like other computational elements.
  </TEXT>

  <TEXT>
    In general, programming languages impose restrictions on the ways in
    which computational elements can be manipulated.  Elements with the
    fewest restrictions are said to have 
    <INDEX>first-class elements in language</INDEX>
    <EM>first-class</EM> status.  Some
    of the <QUOTE>rights and privileges</QUOTE> of first-class 
    elements are:<FOOTNOTE>The notion of first-class status of 
    programming-language <INDEX>Strachey, Christopher</INDEX>
    elements is due to the British computer scientist Christopher
    Strachey (1916<ENDASH/>1975).</FOOTNOTE>
    <UL>
      <LI>
	<SPLITINLINE>
	  <SCHEME>They may be named by variables.</SCHEME>
	  <JAVASCRIPT>They may be referred to using names.</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>They may be passed as arguments to
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.
      </LI>
      <LI>They may be returned as the results of
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.
      </LI>
      <LI>They may be included in data structures.<FOOTNOTE>We<APOS/>ll see
      examples of this after we introduce data structures in chapter<SPACE/>2.</FOOTNOTE>
      </LI>
    </UL>
  </TEXT>
  
  <TEXT>
    <INDEX>Lisp<SUBINDEX>first-class
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    in</SUBINDEX></INDEX>
    <INDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>first-class in Lisp</SUBINDEX></INDEX>
    <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE>, 
    unlike other common programming languages, awards
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    full first-class status.  This poses challenges for efficient
    implementation, but the resulting gain in expressive power is
    enormous.<FOOTNOTE>The major implementation cost of first-class
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    is that allowing
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    to be returned as values
    requires reserving storage for a
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s free variables</SCHEME>
      <JAVASCRIPT>function<APOS/>s free names</JAVASCRIPT>
    </SPLITINLINE>
    even while the
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    is not executing.  
    <SPLITINLINE>
      <SCHEME>In the Scheme implementation we will
      study in section<SPACE/><REF NAME="sec:mc-eval"/>, these variables are stored in the procedure
      </SCHEME>
      <JAVASCRIPT>In the JavaScript implementation we will
      study in section<SPACE/><REF NAME="sec:mc-eval"/>, these names are stored in the function
      </JAVASCRIPT>
      </SPLITINLINE><APOS/>s environment.</FOOTNOTE>
  </TEXT>

  <EXERCISE>             
    <SPLITINLINE><SCHEME>Define a procedure</SCHEME>
    <JAVASCRIPT>Declare a function</JAVASCRIPT></SPLITINLINE>
    <SCHEMEINLINE>cubic</SCHEMEINLINE> that can be used together with the 
    <SPLITINLINE><SCHEME><SCHEMEINLINE>newtons-method</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>newtons_method</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    in expressions of the form

    <SNIPPET PAGE="77" HIDE="yes">
      <NAME>cubic_definition</NAME>
      <SCHEME>
;; cubic to be written by student; see EXERCISE 1.40
      </SCHEME>
      <JAVASCRIPT>
// cubic to be written by student; see EXERCISE 1.40
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET PAGE="77">
      <NAME>cubic_example</NAME>
      <REQUIRES>newtons_method_definition</REQUIRES>
      <REQUIRES>cubic_definition</REQUIRES>
      <SCHEME>
(newtons-method (cubic a b c) 1)
      </SCHEME>
      <JAVASCRIPT>
newtons_method(cubic(a, b, c), 1);
      </JAVASCRIPT>
    </SNIPPET>

    to approximate zeros of the cubic <LATEXINLINE>$x^3 +ax^2 +bx +c$</LATEXINLINE>.
    <SOLUTION>
      <SNIPPET>
	<REQUIRES>square_definition</REQUIRES>
	<REQUIRES>cube_definition</REQUIRES>
	<EXAMPLE>cubic_example_2</EXAMPLE>
	<JAVASCRIPT>
function cubic(a, b, c) {
    return x => cube(x) + a * square(x) + b * x + c;
}
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>

      <SNIPPET PAGE="77" HIDE="yes">
        <NAME>cubic_example_2</NAME>
        <REQUIRES>newtons_method_definition</REQUIRES>
        <REQUIRES>cubic_definition</REQUIRES>
        <SCHEME>
(newtons-method (cubic a b c) 1)
        </SCHEME>
        <JAVASCRIPT>
newtons_method(cubic(1, -4, 0), 1);
        </JAVASCRIPT>
      </SNIPPET>
      
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <SPLITINLINE><SCHEME>Define a procedure</SCHEME>
    <JAVASCRIPT>Declare a function</JAVASCRIPT></SPLITINLINE>
    <SCHEMEINLINE>double</SCHEMEINLINE> that takes a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    of one
    argument as argument and
    returns a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that applies the original
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    twice.  For
    example, if <SCHEMEINLINE>inc</SCHEMEINLINE> is a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that adds 1 to its argument,
    then
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>(double inc)</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>double(inc)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    should be a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that adds 2.  What
    value is returned by

    <SNIPPET PAGE="77" HIDE="yes">
      <NAME>double_definition</NAME>
      <SCHEME>
;; double to be written by student; see EXERCISE 1.41
      </SCHEME>
      <JAVASCRIPT>
// double to be written by student; see EXERCISE 1.41
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET PAGE="77">
      <NAME>double_example</NAME>
      <REQUIRES>double_definition</REQUIRES>
      <REQUIRES>inc_definition</REQUIRES>
      <SCHEME>
(((double (double double)) inc) 5)
      </SCHEME>
      <JAVASCRIPT>
double(double(double))(inc)(5); // ?
      </JAVASCRIPT>
    </SNIPPET>
    <SOLUTION>       
      <SNIPPET>
	<EXAMPLE>double_example_solution</EXAMPLE>
	<JAVASCRIPT>
function double(f) {
    return x => f(f(x));
}
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>

      <SNIPPET HIDE="yes">
	<NAME>double_example_solution</NAME>
	<REQUIRES>inc_definition</REQUIRES>
	<JAVASCRIPT>
double(double(double))(inc)(5); // returns 21
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
      
    </SOLUTION>
  </EXERCISE>

  <EXERCISE><LABEL NAME="ex:compose"/>
  <INDEX>composition of functions</INDEX>
  <INDEX>function (mathematical)<SUBINDEX>composition of</SUBINDEX></INDEX>
  Let <LATEXINLINE>$f$</LATEXINLINE> and <LATEXINLINE>$g$</LATEXINLINE> be two one-argument functions.  The <EM>composition</EM>
  <LATEXINLINE>$f$</LATEXINLINE> after <LATEXINLINE>$g$</LATEXINLINE> is defined to be the function <LATEXINLINE>$x\mapsto f(g(x))$</LATEXINLINE>.            
  <SPLITINLINE><SCHEME>Define a procedure</SCHEME>
  <JAVASCRIPT>Declare a function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>compose</SCHEMEINLINE> that implements composition.  For
  example, if <SCHEMEINLINE>inc</SCHEMEINLINE> is a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  that adds 1 to its argument,

  <SNIPPET PAGE="77" HIDE="yes">
    <NAME>compose_definition</NAME>
    <SCHEME>
;; compose to be written by student; see EXERCISE 1.42
    </SCHEME>
    <JAVASCRIPT>
// compose to be written by student; see EXERCISE 1.42
    </JAVASCRIPT>
  </SNIPPET>

  <SNIPPET PAGE="77">
    <NAME>compose_example</NAME>
    <REQUIRES>compose_definition</REQUIRES>
    <REQUIRES>square_definition</REQUIRES>
    <REQUIRES>inc_definition</REQUIRES>
    <SCHEME>
((compose square inc) 6)
    </SCHEME>
    <JAVASCRIPT>
compose(square, inc)(6);
    </JAVASCRIPT>
  </SNIPPET>
  <SPLITINLINE><SCHEME></SCHEME><JAVASCRIPT>returns 49.</JAVASCRIPT></SPLITINLINE>
  <SOLUTION>
    <SNIPPET>
      <NAME>compose_definition_solution</NAME>
      <EXAMPLE>compose_example_solution</EXAMPLE>
      <JAVASCRIPT>
function compose(f, g) {
    return x => f(g(x));
}
      </JAVASCRIPT>
      <SCHEME>
      </SCHEME>
    </SNIPPET>

    <SNIPPET HIDE="yes">
      <NAME>compose_example_solution</NAME>
      <REQUIRES>inc_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <JAVASCRIPT>
compose(square, inc)(6); // returns 49
      </JAVASCRIPT>
      <SCHEME>
      </SCHEME>
    </SNIPPET>
    
  </SOLUTION>
  </EXERCISE>

  <EXERCISE> 
    <INDEX>function (mathematical)<SUBINDEX>repeated application of</SUBINDEX></INDEX>
    If <LATEXINLINE>$f$</LATEXINLINE> is a numerical function and <LATEXINLINE>$n$</LATEXINLINE> is a positive integer, then we
    can form the <LATEXINLINE>$n$</LATEXINLINE>th repeated application of <LATEXINLINE>$f$</LATEXINLINE>, which is defined to be
    the function whose value at <LATEXINLINE>$x$</LATEXINLINE> is
    <LATEXINLINE>$f(f(\ldots(f(x))\ldots))$</LATEXINLINE>.  For
    example, if <LATEXINLINE>$f$</LATEXINLINE> is the function
    <LATEXINLINE>$x \mapsto x+1$</LATEXINLINE>,
    then the <LATEXINLINE>$n$</LATEXINLINE>th repeated application of
    <LATEXINLINE>$f$</LATEXINLINE> is
    the function <LATEXINLINE>$x \mapsto x+n$</LATEXINLINE>.
    If <LATEXINLINE>$f$</LATEXINLINE> is the operation of
    squaring a number, then the <LATEXINLINE>$n$</LATEXINLINE>th repeated application of
    <LATEXINLINE>$f$</LATEXINLINE> is the
    function that raises its argument to the <LATEXINLINE>$2^n$</LATEXINLINE>th power.  Write a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that takes as inputs a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that computes <LATEXINLINE>$f$</LATEXINLINE> and a
    positive integer <LATEXINLINE>$n$</LATEXINLINE> and returns the
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that computes the <LATEXINLINE>$n$</LATEXINLINE>th
    repeated application of <LATEXINLINE>$f$</LATEXINLINE>.  Your
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    should be able to be used
    as follows:

    <SNIPPET PAGE="77" HIDE="yes">
      <NAME>repeated_definition</NAME>
      <SCHEME>
;; repeated to be written by student; see EXERCISE 1.43
      </SCHEME>
      <JAVASCRIPT>
// repeated to be written by student; see EXERCISE 1.43
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET PAGE="77">
      <NAME>repeated_example</NAME>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>repeated_definition</REQUIRES>
      <SCHEME>
((repeated square 2) 5)
      </SCHEME>
      <JAVASCRIPT>
repeated(square, 2)(5);
      </JAVASCRIPT>
    </SNIPPET>

    Hint: You may find it convenient to use <SCHEMEINLINE>compose</SCHEMEINLINE> from
    exercise<SPACE/><REF NAME="ex:compose"/>.
    <LABEL NAME="ex:repeated"/>
    <SOLUTION>
      <SNIPPET>
	<NAME>repeated_definition_solution</NAME>
	<REQUIRES>compose_definition_solution</REQUIRES>
        <EXAMPLE>repeated_example_solution</EXAMPLE>
        <JAVASCRIPT>
function repeated(f, n) {
    return n === 0
           ? x => x
           : compose(f, repeated(f, n - 1));
}
	</JAVASCRIPT>
        <SCHEME>
        </SCHEME>
      </SNIPPET>

      <SNIPPET PAGE="77" HIDE="yes">
        <NAME>repeated_example_solution</NAME>
	<REQUIRES>square_definition</REQUIRES>
        <SCHEME>
((repeated square 2) 5)
        </SCHEME>
        <JAVASCRIPT>
repeated(square, 2)(5); // 625
        </JAVASCRIPT>
      </SNIPPET>
      
    </SOLUTION>
  </EXERCISE>

  <EXERCISE><LABEL NAME="ex:smooth"/> 
  <INDEX>function (mathematical)<SUBINDEX>smoothing of</SUBINDEX></INDEX>
  <INDEX>smoothing a function</INDEX>
  <INDEX>signal processing<SUBINDEX>smoothing a function</SUBINDEX></INDEX>
  The idea of <EM>smoothing</EM> a function is an important concept in
  signal processing.  If <LATEXINLINE>$f$</LATEXINLINE> is a function and
  <LATEXINLINE>$dx$</LATEXINLINE> is some small number,
  then the smoothed version of <LATEXINLINE>$f$</LATEXINLINE> is the function whose value at a
  point <LATEXINLINE>$x$</LATEXINLINE> is the average of <LATEXINLINE>$f(x-dx)$</LATEXINLINE>,
  <LATEXINLINE>$f(x)$</LATEXINLINE>, and <LATEXINLINE>$f(x+dx)$</LATEXINLINE>.  Write a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>smooth</SCHEMEINLINE> that takes as input a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  that computes
  <LATEXINLINE>$f$</LATEXINLINE> and returns a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  that computes the smoothed <LATEXINLINE>$f$</LATEXINLINE>.  It is
  sometimes valuable to repeatedly smooth a function (that is, smooth
  the smoothed function, and so on) to obtained the <EM><LATEXINLINE>$n$</LATEXINLINE>-fold
  smoothed function</EM>.  Show how to generate the
  <LATEXINLINE>$n$</LATEXINLINE>-fold smoothed
  function of any given function using <SCHEMEINLINE>smooth</SCHEMEINLINE> and
  <SCHEMEINLINE>repeated</SCHEMEINLINE> from exercise<SPACE/><REF NAME="ex:repeated"/>.
  <SOLUTION>
    <SNIPPET>
      <REQUIRES>cube_definition</REQUIRES>
      <REQUIRES>repeated_definition_solution</REQUIRES>
      <EXAMPLE>example_1.44</EXAMPLE>
      <JAVASCRIPT>
const dx = 0.00001;
function smooth(f) {
    return x => (f(x - dx) + f(x) + f(x + dx)) / 3;
}
function n_fold_smooth(f, n) {
    return repeated(smooth, n)(f);
}
      </JAVASCRIPT>
      <SCHEME>
      </SCHEME>
    </SNIPPET>
  </SOLUTION>
  <SNIPPET HIDE="yes">
    <NAME>example_1.44</NAME>
    <JAVASCRIPT>
n_fold_smooth(cube, 5)(4);
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
  </SNIPPET>
  </EXERCISE>

  <EXERCISE>
    We saw in section<SPACE/><REF NAME="sec:proc-general-methods"/>
    that attempting to compute square roots by naively finding a
    fixed point of <LATEXINLINE>$y\mapsto x/y$</LATEXINLINE> does not converge, and that this can be
    fixed by average damping.  The same method works for finding cube
    roots as fixed points of the average-damped <LATEXINLINE>$y\mapsto x/y^2$</LATEXINLINE>.
    Unfortunately, the process does not work for 
    <INDEX>fourth root, as fixed point</INDEX>
    <INDEX>fixed point<SUBINDEX>fourth root as</SUBINDEX></INDEX>
    fourth roots<EMDASH/>a single
    average damp is not enough to make a fixed-point search for <LATEXINLINE>$y\mapsto
    x/y^3$</LATEXINLINE> converge.  On the other hand, if we average damp twice (i.e.,
    use the average damp of the average damp of <LATEXINLINE>$y\mapsto x/y^3$</LATEXINLINE>) the
    fixed-point search does converge.  Do some experiments to determine
    how many average damps are required to compute 
    <INDEX>nth@<LATEXINLINE>$n$</LATEXINLINE>th root, as fixed point</INDEX>
    <INDEX>fixed point<SUBINDEX>nth@<LATEXINLINE>$n$</LATEXINLINE>th root as</SUBINDEX></INDEX>
    <LATEXINLINE>$n$</LATEXINLINE>th roots as a
    fixed-point search based upon repeated average damping of <LATEXINLINE>$y\mapsto
    x/y^{n-1}$</LATEXINLINE>.  Use this to implement a simple
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    for computing
    <LATEXINLINE>$n$</LATEXINLINE>th roots using 
    <SPLITINLINE><SCHEME><SCHEMEINLINE>fixed-point</SCHEMEINLINE>,</SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>fixed_point</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE> 
    <SPLITINLINE><SCHEME><SCHEMEINLINE>average-damp</SCHEMEINLINE>,</SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE>,</JAVASCRIPT></SPLITINLINE>
    and the <SCHEMEINLINE>repeated</SCHEMEINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    of exercise<SPACE/><REF NAME="ex:repeated"/>.
    Assume that any arithmetic operations you need are available as primitives.
    <LABEL NAME="ex:nth-roots"/>

    <SOLUTION>
      <SNIPPET>
	<REQUIRES>fixed_definition</REQUIRES>
	<REQUIRES>average_damp_definition</REQUIRES>
	<REQUIRES>repeated_definition_solution</REQUIRES>
        <REQUIRES>expt_log_definition</REQUIRES>
	<EXAMPLE>example_1.45</EXAMPLE>
	<JAVASCRIPT>
function nth_root(n, x) {
    return fixed_point(repeated(average_damp, 
                                math_floor(math_log2(n)))
                       (y => x / fast_expt(y, n - 1)),
                       1.0);
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>example_1.45</NAME>
	<JAVASCRIPT>
nth_root(5, 32);
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>

  </EXERCISE>

  <EXERCISE>
    <INDEX>iterative improvement</INDEX>
    <!-- \indcode{sqrt}[iterative@as iterative improvement] -->
    <!-- \indcode{fixed-point}[iterative@as iterative improvement] -->
    <INDEX>fixed point<SUBINDEX>iterative@as iterative improvement</SUBINDEX></INDEX>
    Several of the numerical methods described in this chapter are instances
    of an extremely general computational strategy known as <EM>iterative
    improvement</EM>.  Iterative improvement says that, to compute something,
    we start with an initial guess for the answer, test if the guess is
    good enough, and otherwise improve the guess and continue the process
    using the improved guess as the new guess.  Write a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE><SCHEME><SCHEMEINLINE>iterative-improve</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>iterative_improve</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
    that takes two
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    as arguments: a method
    for telling whether a guess is good enough and a method for improving
    a guess.
    <SPLITINLINE><SCHEME><SCHEMEINLINE>Iterative-improve</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT>The function <JAVASCRIPTINLINE>iterative_improve</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE> should return as its value a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that takes a guess as argument and keeps improving the guess
    until it is good enough.  Rewrite the <SCHEMEINLINE>sqrt</SCHEMEINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    of
    section<SPACE/><REF NAME="sec:sqrt"/> and the 
    <SPLITINLINE><SCHEME><SCHEMEINLINE>fixed-point</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>fixed_point</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    of
    section<SPACE/><REF NAME="sec:proc-general-methods"/> in terms of
    <SPLITINLINE><SCHEME><SCHEMEINLINE>iterative-improve</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>iterative_improve</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>.

    <SOLUTION>
      <SNIPPET>
	<NAME>iterative_improve</NAME>
	<EXAMPLE>example_1.46_1</EXAMPLE>
	<JAVASCRIPT>
function iterative_improve(good_enough, improve) {
    function iterate(guess) {
        return good_enough(guess)
               ? guess
               : iterate(improve(guess));
    }
    return iterate;
}		    
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET>
	<NAME>example_1.46_1</NAME>
	<REQUIRES>square_definition</REQUIRES>
        <REQUIRES>improve</REQUIRES>
        <REQUIRES>good_enough</REQUIRES>
	<REQUIRES>iterative_improve</REQUIRES>
	<JAVASCRIPT>
function sqrt(x) {
    return iterative_improve(y => good_enough(y, x), 
                             y => improve(y, x))(1);
}

sqrt(49);
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>

      <SNIPPET>
	<NAME>example_1.46_2</NAME>
	<REQUIRES>square_definition</REQUIRES>
        <REQUIRES>improve</REQUIRES>
        <REQUIRES>good_enough</REQUIRES>
	<REQUIRES>iterative_improve</REQUIRES>
	<JAVASCRIPT>
const tolerance = 0.00001;	  
function fixed_point(f, first_guess) {
    return iterative_improve(
               guess => abs(guess - f(guess)) &lt; tolerance,
               f)
           (first_guess);
}

fixed_point(math_cos, 1.0);
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
    
  </EXERCISE>
  <INDEX>higher-order
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE><SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  as returned value|)</SUBINDEX></INDEX>
  <INDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>returned@as returned value|)</SUBINDEX></INDEX>
</SUBSECTION>
