<SUBSECTION>
  

  <LABEL NAME="sec:data-directed"></LABEL>
   <INDEX>数据导向编程<OPEN></OPEN></INDEX> 
   <INDEX>可加性<OPEN></OPEN></INDEX> 

   <TEXT>
    检查数据的类型并调用适当的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    称为
    <INDEX>模块性<SUBINDEX>通过类型分派</SUBINDEX></INDEX>
    <INDEX>在类型上分派<SUBINDEX>在类型上</SUBINDEX></INDEX>
    <INDEX>类型<SUBINDEX>分派于</SUBINDEX></INDEX>
    <EM>在类型上分派</EM>。 这是在系统设计中获得模块性的一个强大策略。 另一方面，如章节<SPACE></SPACE><REF NAME="sec:manifest-types"></REF>中所述那样实现分派存在两个显著的缺点。 其中一个缺点是通用接口
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>(<SCHEMEINLINE>real-part</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>(<JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>imag-part</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>imag_part</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>magnitude</SCHEMEINLINE>，以及
    <SCHEMEINLINE>angle</SCHEMEINLINE>) 必须了解所有不同的表示方法。 例如，假设我们想将一种新的复数表示方法引入到我们的复数系统中。 我们需要用一个类型来标识这种新表示方式，然后在每个通用接口
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    中添加一条子句，以检查这种新类型并应用该表示方法的适当选择器。
  </TEXT> 
   <TEXT>
    该技术的另一个弱点在于，尽管各个表示法可以独立设计，我们必须保证整个系统中没有两个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    具有相同的名称。这就是为什么 Ben 和 Alyssa 必须更改他们原来在章节<SPACE></SPACE><REF NAME="sec:representations-complex-numbers"></REF>中使用的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的名称。
  </TEXT> 
   <TEXT>
    这两种弱点背后的问题在于，实现泛型接口的技术并不是 <EM>累加的</EM>。实现泛型选择器
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的人员必须在每次安装一种新的表示法时修改那些
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，而与各个表示法交互的人员也必须修改他们的代码以避免名称冲突。在每种情况下，必须对代码做出的更改虽然是简单明了的，但这些更改仍然是必需的，这会导致不便和错误。对于现有的复数系统来说，这问题不大，但假设针对复数的表示法不止两种而是上百种，再加上在抽象数据接口中需要维护许多泛型选择器，事实上，假设没有哪个程序员能掌握所有接口
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    或者所有的表示法，这个问题便切实存在，并且在像大规模数据库管理系统这样的程序中必须加以解决。
  </TEXT> 
   <TEXT>
    我们需要一种能够进一步模块化系统设计的方法。这正是由一种称为 <EM>数据导向编程</EM> 的编程技术所提供的。要理解数据导向编程的工作原理，可以从这样一个观察开始：每当我们处理一组适用于一系列不同类型的通用操作时，实际上我们是在处理一个二维表——其一轴上列举了可能的操作，另一轴上列举了可能的类型。该表中的各项就是为每种传入参数类型实现各个操作的 
    <SPLITINLINE>
      <SCHEME>程序</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。在前一节中所开发的复数系统中，操作名称、数据类型与实际 
    <SPLITINLINE>
      <SCHEME>程序</SCHEME></SPLITINLINE>
      <JAVASCRIPT>函数</JAVASCRIPT>
    &lt;/SPLITINLINE&gt;
    之间的对应关系分散在通用接口 
    <SPLITINLINE>
      <SCHEME>程序</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的各个条件子句中。但同样的信息也可以组织在一个表中，如下所示：
    <SPLITINLINE>
      <SCHEME>
	figure<SPACE></SPACE><REF NAME="fig:operator-table_scheme"></REF>.
      </SCHEME>
      <JAVASCRIPT>
	figure<SPACE></SPACE><REF NAME="fig:operator-table"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
</TEXT> 
  
   <TEXT>
  数据导向编程是一种设计程序直接使用这样的
  <INDEX>表<SUBINDEX>用于数据导向编程的表</SUBINDEX></INDEX>
  的技术。之前，我们实现了将复数运算代码与这两个表示包接口的机制，该机制是一组在类型上执行显式分派的
  <SPLITINLINE>
    <SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT>
  </SPLITINLINE>
  。这里我们将把接口实现为一个单一的
  <SPLITINLINE>
    <SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT>
  </SPLITINLINE>
  ，它在表中查找操作名称和参数类型的组合以找到正确的
  <SPLITINLINE>
    <SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT>
  </SPLITINLINE>
  进行应用，然后将其应用于参数的内容。如果我们这样做，那么要向系统中添加一个新的表示包，我们不必更改任何现有的
  <SPLITINLINE>
    <SCHEME>过程;</SCHEME>
    <JAVASCRIPT>函数;</JAVASCRIPT>
  </SPLITINLINE>
  ，只需在表中添加新条目。
</TEXT> 
   <TEXT>
    <SPLIT>
      <SCHEME>
        <FIGURE SRC="img_original/ch2-Z-G-63.svg">
          <CAPTION>复数系统的运算表。</CAPTION>
          <LABEL NAME="fig:operator-table_scheme"></LABEL>
	</FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.7" SCALE="0.59" SRC="img_javascript/ch2-Z-G-63.svg">
          <CAPTION>复数系统的运算表。</CAPTION>
          <LABEL NAME="fig:operator-table"></LABEL>
	</FIGURE>
      </JAVASCRIPT>
    </SPLIT>
    为了实现这一计划，假设我们有两个
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>put</SCHEMEINLINE> 和 <SCHEMEINLINE>get</SCHEMEINLINE>，用于操作
    <INDEX>operation-and-type table</INDEX>
    操作与类型表：
    <UL>
      <LI>
       <INDEX><USE>put</USE></INDEX> 
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>(put </SCHEMEINLINE>
	    <LATEXINLINE>$\langle \textit{op} \rangle\ \langle \textit{type}
	    \rangle \ \langle \textit{item} \rangle$
	    </LATEXINLINE>
	    <SCHEMEINLINE>)</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>put(</JAVASCRIPTINLINE>&lt;!-- 
	     --&gt;<META>op</META>&lt;!-- 
	     --&gt;<JAVASCRIPTINLINE>, </JAVASCRIPTINLINE>&lt;!-- 
	     --&gt;<META>type</META>&lt;!-- 
	     --&gt;<JAVASCRIPTINLINE>, </JAVASCRIPTINLINE>&lt;!-- 
	     --&gt;<META>item</META>&lt;!-- 
	     --&gt;<JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	<BR></BR>
	将
	<SPLITINLINE>
	  <SCHEME>
	    <LATEXINLINE>$\langle \textit{item} \rangle$</LATEXINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <META>item</META>
	  </JAVASCRIPT>
	</SPLITINLINE>
	安装到表中，以
	<SPLITINLINE>
	  <SCHEME>
	    <LATEXINLINE>$\langle \textit{op} \rangle$</LATEXINLINE> 和
	    <LATEXINLINE>$\langle \textit{type} \rangle$</LATEXINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <META>op</META> 和 <META>type</META>.
	  </JAVASCRIPT>
	</SPLITINLINE>
	作为索引。
      </LI>
      <LI>
	<INDEX><USE>get</USE></INDEX> 
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>(get </SCHEMEINLINE>
	    <LATEXINLINE>$\langle \textit{op} \rangle\ \langle
	    \textit{type}$</LATEXINLINE>
	    <SCHEMEINLINE>)</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>get(</JAVASCRIPTINLINE>&lt;!-- 
	     --&gt;<META>op</META>&lt;!-- 
	     --&gt;<JAVASCRIPTINLINE>, </JAVASCRIPTINLINE>&lt;!-- 
	     --&gt;<META>type</META>&lt;!-- 
	     --&gt;<JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	<BR></BR>
	查找
	<SPLITINLINE>
	  <SCHEME>
	    <LATEXINLINE>$\langle \textit{op} \rangle$</LATEXINLINE>,
	    <LATEXINLINE>$\langle \textit{type} \rangle$</LATEXINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <META>op</META>,
	    <META>type</META>
	  </JAVASCRIPT>
	</SPLITINLINE>
	在表中的条目，并返回找到的项。
	如果未找到任何项，
	<SCHEMEINLINE>get</SCHEMEINLINE> 返回
	<SPLITINLINE>
	  <SCHEME>false.</SCHEME>
	  <JAVASCRIPT>
	    一个唯一的原始值，该值通过预声明名称
	    <INDEX><USE>undefined</USE> (预声明名称)</INDEX>
	    <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> 来引用，并由原始谓词
	    <INDEX><USE>is_undefined</USE> (原始函数)</INDEX>
	    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>is_undefined</USE></SUBINDEX></INDEX>
	    <JAVASCRIPTINLINE>is_undefined</JAVASCRIPTINLINE> 识别。<FOOTNOTE>
	    名称 <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> 在任何 JavaScript 实现中都是预声明的，除指代该原始值外不应用于其他用途。
	  </FOOTNOTE>
	  </JAVASCRIPT>
	</SPLITINLINE>
      </LI>
    </UL>
    目前，我们可以假设 <SCHEMEINLINE>put</SCHEMEINLINE> 和
    <SCHEMEINLINE>get</SCHEMEINLINE> 已包含在我们的语言中。在<SPACE></SPACE><REF NAME="chap:state"></REF>章（<SPACE></SPACE><REF NAME="sec:tables"></REF>节）中，我们将看到如何实现这些以及其他用于操作表的操作.
  </TEXT> 
   <TEXT>
    下面介绍如何在复数系统中使用数据导向编程。Ben 开发了矩形表示法，并且像最初那样实现了他的代码。他定义了一系列
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    或一个
    <INDEX>包</INDEX>
    <INDEX>包<SUBINDEX>矩形表示法</SUBINDEX></INDEX>
    <INDEX><USE>矩形</USE> 包</INDEX>
    <EM>包</EM>，并通过向表中添加条目来向系统其他部分接口，告诉系统如何对矩形数进行操作。这是通过调用下面的
    <SPLITINLINE>
      <SCHEME>过程:</SCHEME>
      <JAVASCRIPT>函数:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET HIDE="yes">
      <NAME>operation_table_from_chapter_3</NAME>
      <JAVASCRIPT>
// 来自第三章（第 3.3.3 节）的 operation_table、put 和 get
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET CHAP="3" HIDE="yes">
      <NAME>install_rectangular_package_usage</NAME>
      <JAVASCRIPT>
install_rectangular_package();
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="3">
      <INDEX><DECLARATION>install_rectangular_package</DECLARATION></INDEX> 
      <NAME>install_rectangular_package</NAME>
      <REQUIRES>operation_table_from_chapter_3</REQUIRES>
      <REQUIRES>operation_table</REQUIRES>
      <REQUIRES>attach_tag</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <EXAMPLE>install_rectangular_package_usage</EXAMPLE>
      <SCHEME>
(define (install-rectangular-package)
  ;; 内部过程
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))

  ;; 与系统其他部分的接口
  (define (tag x) (attach-tag &apos;rectangular x))
  (put &apos;real-part &apos;(rectangular) real-part)
  (put &apos;imag-part &apos;(rectangular) imag-part)
  (put &apos;magnitude &apos;(rectangular) magnitude)
  (put &apos;angle &apos;(rectangular) angle)
  (put &apos;make-from-real-imag &apos;rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put &apos;make-from-mag-ang &apos;rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  &apos;done)
      </SCHEME>
      <JAVASCRIPT>
function install_rectangular_package() {
    // 内部函数
    function real_part(z) { return head(z); }
    function imag_part(z) { return tail(z); }
    function make_from_real_imag(x, y) { return pair(x, y); }
    function magnitude(z) {
        return math_sqrt(square(real_part(z)) + square(imag_part(z)));
    }
    function angle(z) {
        return math_atan2(imag_part(z), real_part(z));
    }
    function make_from_mag_ang(r, a) {
        return pair(r * math_cos(a), r * math_sin(a));
    }

    // 与系统其他部分的接口
    function tag(x) { return attach_tag(&quot;rectangular&quot;, x); }
    put(&quot;real_part&quot;, list(&quot;rectangular&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;rectangular&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;rectangular&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;rectangular&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;rectangular&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT> 
   <TEXT>
    请注意，此处的内部
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    与 Ben 在独立工作时所编写的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    （参见 <REF NAME="sec:representations-complex-numbers"></REF> 节）是相同的。为了将它们与系统的其他部分接口，无需做任何修改。此外，由于这些
    <SPLITINLINE>
      <SCHEME>过程定义</SCHEME>
      <JAVASCRIPT>函数声明</JAVASCRIPT>
    </SPLITINLINE>
    是内部安装的
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    ，因此 Ben 无需担心与矩形模块之外的其他
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的名称冲突。为了将这些接口化供系统其他部分使用，Ben 将他的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>real-part</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    安装在操作名称
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>real-part</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    下，并安装在类型
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>(rectangular)</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;rectangular&quot;)</JAVASCRIPTINLINE>, 
      </JAVASCRIPT>
    </SPLITINLINE>
    下，其余选择器亦同。<FOOTNOTE>我们使用列表
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(rectangular)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;rectangular&quot;)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    而不是
    <SPLITINLINE>
      <SCHEME>符号 <SCHEMEINLINE>rectangular</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>字符串 <JAVASCRIPTINLINE>&quot;rectangular&quot;</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    ，以便支持具有多个参数且各参数类型不同的操作。</FOOTNOTE> 该接口还定义了供外部系统使用的构造函数。<FOOTNOTE>构造函数安装时所依附的类型不必为列表，因为构造函数始终用于生成特定类型的对象。</FOOTNOTE> 这些构造函数与 Ben 内部定义的构造函数完全相同，只不过它们附加了标签。
  </TEXT> 
   <DO_BREAK_PAGE></DO_BREAK_PAGE> 
   <TEXT>
    Alyssa<APOS></APOS>的
    <INDEX>包<SUBINDEX>极坐标表示</SUBINDEX></INDEX>
    <INDEX><USE>极坐标</USE> 包</INDEX>
    极坐标包类似于:
    <SNIPPET CHAP="4">
      <INDEX><DECLARATION>install_polar_package</DECLARATION></INDEX> 
      <NAME>install_polar_package</NAME>
      <REQUIRES>operation_table_from_chapter_3</REQUIRES>
      <REQUIRES>operation_table</REQUIRES>
      <REQUIRES>附加标签函数</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>install_polar_package_usage</EXAMPLE>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(define (install-polar-package)
  ;; 内部过程
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  
  ;; 系统接口
  (define (tag x) (attach-tag &apos;polar x))
  (put &apos;real-part &apos;(polar) real-part)
  (put &apos;imag-part &apos;(polar) imag-part)
  (put &apos;magnitude &apos;(polar) magnitude)
  (put &apos;angle &apos;(polar) angle)
  (put &apos;make-from-real-imag &apos;polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put &apos;make-from-mag-ang &apos;polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  &apos;done)
      </SCHEME>
      <JAVASCRIPT>
function install_polar_package() {
    // 内部函数
    function magnitude(z) { return head(z); }
    function angle(z) { return tail(z); }
    function make_from_mag_ang(r, a) { return pair(r, a); }
    function real_part(z) {
        return magnitude(z) * math_cos(angle(z));
    }
    function imag_part(z) {
        return magnitude(z) * math_sin(angle(z));
    }
    function make_from_real_imag(x, y) {
        return pair(math_sqrt(square(x) + square(y)),
                    math_atan2(y, x));
    }
  
    // 系统接口
    function tag(x) { return attach_tag(&quot;polar&quot;, x); }
    put(&quot;real_part&quot;, list(&quot;polar&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;polar&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;polar&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;polar&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;polar&quot;, 
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;polar&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4" HIDE="yes">
      <NAME>install_polar_package_usage</NAME>
      <REQUIRES>install_polar_package</REQUIRES>
      <JAVASCRIPT>
install_polar_package();
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT> 
   <TEXT>
    尽管 Ben 和 Alyssa 都仍然使用他们原来定义的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，且名称彼此相同（例如，
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>real-part</SCHEMEINLINE>),</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE>),</JAVASCRIPT>
    </SPLITINLINE>
    这些声明现在分别在不同的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的内部（参见<SPACE></SPACE><REF NAME="sec:block-structure"></REF>部分），因此不会产生命名冲突.
  </TEXT> 
  <TEXT> 
    复杂算术选择器通过一个通用的<QUOTE>操作</QUOTE> 
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    访问该表，该过程被称为 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    它将一个通用操作应用于一些参数。
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Apply-generic</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	函数
	<JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    在表中查找以操作名称及参数类型为依据的条目，并在存在时应用得到的 
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    :<FOOTNOTE>
    <SPLIT>
      <SCHEME>
	<SCHEMEINLINE>Apply-generic</SCHEMEINLINE> 使用练习<SPACE></SPACE><REF NAME="ex:dotted-arglist"></REF>中描述的 
	<INDEX>dotted-tail notation<SUBINDEX><ORDER>过程</ORDER>对于过程参数</SUBINDEX></INDEX> 带省略尾参数记法，
	因为不同的通用操作可能需要不同数量的参数。
	在 
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE>,</SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>,
	  </JAVASCRIPT>
	</SPLITINLINE>
	中，<SCHEMEINLINE>op</SCHEMEINLINE> 的值为传递给 
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	的第一个参数，而 <SCHEMEINLINE>args</SCHEMEINLINE> 的值为其余参数构成的列表。
	<BR></BR>
      </SCHEME>
    </SPLIT>
    <SPLIT>
      <SCHEME>
	<SCHEMEINLINE>Apply-generic</SCHEMEINLINE> 还使用原始过程 
	<SCHEMEINLINE>apply</SCHEMEINLINE>，该过程接受两个参数，即一个过程和一个列表。
	<SCHEMEINLINE>Apply</SCHEMEINLINE>
	利用列表中的元素作为参数来调用该过程。
      </SCHEME>
      <JAVASCRIPT>
	函数 
	<JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
	使用在<SPACE></SPACE><REF NAME="sec:running-eval"></REF>节中给出的函数 
	<INDEX><USE>apply_in_underlying_javascript</USE></INDEX>
	<SCHEMEINLINE>apply_in_underlying_javascript</SCHEMEINLINE>
	<PDF_ONLY>
	  (脚注<SPACE></SPACE><REF NAME="foot:vector-array"></REF>),
	</PDF_ONLY>
	<WEB_ONLY>
	  (脚注<SPACE></SPACE>2),
	</WEB_ONLY>
	该函数接受两个参数，即一个函数和一个列表，并利用列表中的元素作为参数来调用该函数。
      </JAVASCRIPT>
    </SPLIT>
    例如，
    <SNIPPET EVAL="no">
      <SCHEME>
	(apply + (list 1 2 3 4))
      </SCHEME>
      <JAVASCRIPT>
	apply_in_underlying_javascript(sum_of_squares, list(1, 3))
      </JAVASCRIPT>
    </SNIPPET>
    返回 10。</FOOTNOTE>
<SNIPPET HIDE="yes">
      <NAME>apply_definition</NAME>
      <JAVASCRIPT>
// In Source, most functions have a fixed number of arguments.
// (The function list is the only exception, to this so far.)
// The function apply_in_underlying_javascript allows us to
// apply any given function fun to all elements of the argument 
// list args, as if they were separate arguments
function apply(fun, args) {
    return apply_in_underlying_javascript(fun, args);
}	  
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>apply_generic</DECLARATION></INDEX> 
      <NAME>apply_generic</NAME>
      <REQUIRES>apply_definition</REQUIRES>
      <SCHEME>
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
        (apply proc (map contents args))
        (error
          &quot;No method for these types -- APPLY-GENERIC&quot;
          (list op type-tags))))))
      </SCHEME>
      <JAVASCRIPT>
function apply_generic(op, args) {
    const type_tags = map(type_tag, args);
    const fun = get(op, type_tags);
    return ! is_undefined(fun)
           ? apply_in_underlying_javascript(fun, map(contents, args))
           : error(list(op, type_tags),
                   &quot;no method for these types -- apply_generic&quot;);
}
      </JAVASCRIPT>
    </SNIPPET> 
    使用
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    我们可以如下定义我们的通用选择器：
<SNIPPET CHAP="4">
      <INDEX><DECLARATION>real_part</DECLARATION><SUBINDEX>data-directed</SUBINDEX></INDEX>
      <INDEX><DECLARATION>imag_part</DECLARATION><SUBINDEX>data-directed</SUBINDEX></INDEX>
      <INDEX><DECLARATION>magnitude</DECLARATION><SUBINDEX>data-directed</SUBINDEX></INDEX>
      <INDEX><DECLARATION>angle</DECLARATION><SUBINDEX>data-directed</SUBINDEX></INDEX>
      <NAME>generic_selectors</NAME>
      <REQUIRES>apply_generic</REQUIRES>
      <EXAMPLE>generic_selectors_example</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      <SCHEME>
(define (real-part z) (apply-generic &apos;real-part z))
(define (imag-part z) (apply-generic &apos;imag-part z))
(define (magnitude z) (apply-generic &apos;magnitude z))
(define (angle z) (apply-generic &apos;angle z))
      </SCHEME>
      <JAVASCRIPT>
function real_part(z) { return apply_generic(&quot;real_part&quot;, list(z)); }
<SHORT_SPACE></SHORT_SPACE>
function imag_part(z) { return apply_generic(&quot;imag_part&quot;, list(z)); }
<SHORT_SPACE></SHORT_SPACE>
function magnitude(z) { return apply_generic(&quot;magnitude&quot;, list(z)); }
<SHORT_SPACE></SHORT_SPACE>
function angle(z)     { return apply_generic(&quot;angle&quot;, list(z));     }
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>generic_selectors_example</NAME>
      <REQUIRES>install_rectangular_package</REQUIRES>
      <REQUIRES>install_rectangular_package_usage</REQUIRES>
      <REQUIRES>install_polar_package</REQUIRES>
      <REQUIRES>complex_number_calculation</REQUIRES>
      <REQUIRES>generic_constructors</REQUIRES>
      <JAVASCRIPT>
const my_complex_number = 
    make_from_real_imag(1.0, 4.5);

const result = 
    add_complex(my_complex_number,
                my_complex_number);

imag_part(result);		
      </JAVASCRIPT>
    </SNIPPET> 
    请注意，即使向系统中添加新的表示，这些也完全不会发生任何变化。
</TEXT>
  
  <TEXT>
    我们还可以从表格中提取构造函数，这些构造函数供包外的程序在由实部和虚部以及由模长和角度构成复数时使用。正如章节<SPACE></SPACE><REF NAME="sec:manifest-types"></REF>所示，每当我们拥有实部和虚部时，就构造矩形数；而每当我们拥有模长和角度时，就构造极坐标数：
    <SNIPPET CHAP="4" POSTPADDING="no">
      <INDEX><DECLARATION>make_from_real_imag</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_from_mag_ang</DECLARATION></INDEX> 
      <NAME>generic_constructors</NAME>
      <REQUIRES>generic_selectors</REQUIRES>	
      <EXAMPLE>generic_selectors_example</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      <SCHEME>
(define (make-from-real-imag x y)
  ((get &apos;make-from-real-imag &apos;rectangular) x y))

(define (make-from-mag-ang r a)
  ((get &apos;make-from-mag-ang &apos;polar) r a))
      </SCHEME>
      <JAVASCRIPT>
function make_from_real_imag(x, y) {
   return get(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;)(x, y);
}
function make_from_mag_ang(r, a) {
   return get(&quot;make_from_mag_ang&quot;, &quot;polar&quot;)(r, a);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>


  <EXERCISE>
    节<SPACE></SPACE><REF NAME="sec:symbolic-differentiation"></REF>描述了一个执行
    <INDEX>符号求导</INDEX>
    <INDEX>求导<SUBINDEX>符号</SUBINDEX></INDEX>
    符号求导的程序：
<SNIPPET>
      <NAME>deriv_2_4</NAME>
      <REQUIRES>is_variable</REQUIRES>
      <REQUIRES>is_same_variable</REQUIRES>
      <REQUIRES>is_sum</REQUIRES>
      <REQUIRES>make_sum</REQUIRES>
      <REQUIRES>addend</REQUIRES>
      <REQUIRES>augend</REQUIRES>
      <REQUIRES>is_product</REQUIRES>
      <REQUIRES>multiplier</REQUIRES>
      <REQUIRES>multiplicand</REQUIRES>
      <EXAMPLE>xyx4</EXAMPLE>
      <EXPECTED>[ &apos;*&apos;, [ &apos;x&apos;, [ &apos;y&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp)
          (make-sum (deriv (addend exp) var)
                    (deriv (augend exp) var)))
        ((product? exp)
          (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
        ;; more rules can be added here
        (else (error &quot;unknown expression type -- DERIV&quot; exp))))
      </SCHEME>
      <JAVASCRIPT>
function deriv(exp, variable) {
    return is_number(exp)
           ? 0
           : is_variable(exp)
           ? is_same_variable(exp, variable) ? 1 : 0
           : is_sum(exp)
           ? make_sum(deriv(addend(exp), variable), 
                      deriv(augend(exp), variable))
           : is_product(exp)
           ? make_sum(make_product(multiplier(exp), 
                                   deriv(multiplicand(exp), variable)),
                      make_product(deriv(multiplier(exp), variable), 
                                   multiplicand(exp)))
           // more rules can be added here
           : error(exp, &quot;unknown expression type -- deriv&quot;);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>xyx4</NAME>
      <REQUIRES>deriv_2_4</REQUIRES>
      <SCHEME>
(deriv &apos;(* (* x y) (+ x 4)) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
(+ (* (* x y) (+ 1 0))
(* (+ (* x 0) (* 1 y))
(+  x 4)))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 4)), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(tail(head(tail(deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 4)), &quot;x&quot;)))));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(&quot;+&quot;, list(&quot;*&quot;, list(&quot;*&quot;, x, y), list(&quot;+&quot;, 1, 0)),
          list(&quot;*&quot;, list(&quot;+&quot;, list(&quot;*&quot;, x, 0), list(&quot;*&quot;, 1, y)),
                    list(&quot;+&quot;,  x, 4)))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    我们可以将该程序视为对待求导表达式的类型进行分派。在这种情况下，<QUOTE>类型标签</QUOTE>所表示的数据为代数运算符号
    <SPLITINLINE>
      <SCHEME>（例如 <LATEXINLINE>+</LATEXINLINE>）</SCHEME>
      <JAVASCRIPT>（例如 <LATEXINLINE>&quot;+&quot;</LATEXINLINE>）</JAVASCRIPT>
    </SPLITINLINE>
    而被执行的操作是
<SCHEMEINLINE>deriv</SCHEMEINLINE> .  我们可以将该程序转换为数据导向风格，
    通过将基本求导
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    重写为
     <SNIPPET EVAL="no">
      <INDEX><DECLARATION>deriv</DECLARATION> (symbolic)<SUBINDEX>data-directed</SUBINDEX><FRAGILE></FRAGILE></INDEX>
      <NAME>deriv_generic</NAME>
      <REQUIRES>is_variable</REQUIRES>
      <REQUIRES>is_same_variable</REQUIRES>
      <EXAMPLE>deriv_x_example</EXAMPLE>
      <SCHEME>
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get &apos;deriv (operator exp)) (operands exp)
                                           var))))

(define (operator exp) (car exp))

(define (operands exp) (cdr exp))
      </SCHEME>
      <JAVASCRIPT>
function deriv(exp, variable) {
    return is_number(exp)
           ? 0
           : is_variable(exp)
           ? is_same_variable(exp, variable) ? 1 : 0
           : get(&quot;deriv&quot;, operator(exp))(operands(exp), variable);
}
function operator(exp) { return head(exp); }
<SHORT_SPACE></SHORT_SPACE>
function operands(exp) { return tail(exp); }
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>deriv_x_example</NAME>
      <SCHEME>
(deriv &apos;(+ x 3) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
(+ 1 0)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(&quot;x&quot;, &quot;x&quot;);
// 1
      </JAVASCRIPT>
    </SNIPPET>
     
  <OL>
    <LI>
	  解释上面所做的工作。为什么我们不能将谓词 
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>number?</SCHEMEINLINE></SCHEME>
	    <JAVASCRIPT><JAVASCRIPTINLINE>is_number</JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE>
	  和 
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>variable?</SCHEMEINLINE></SCHEME>
	    <JAVASCRIPT><JAVASCRIPTINLINE>is_variable</JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE>
	  合并到数据导向调度中？
	</LI>
	<LI>
	  写出求和与求积的导数的 
	  <SPLITINLINE>
	    <SCHEME>过程</SCHEME>
	    <JAVASCRIPT>函数</JAVASCRIPT>
	  </SPLITINLINE>
	  ，以及将它们安装到上述程序所使用的表中所需的辅助代码。
	</LI>
	<LI>
	  选择一个你喜欢的额外求导规则，例如关于指数的规则
	  (<REF NAME="ex:deriv-exponentiation"></REF>)，并将其安装到该数据导向系统中。
	</LI>
	<LI>
	  在这个简单的代数操纵器中，一个表达式的类型就是将其结合在一起的代数运算符。假设我们以相反的方式对
	  <SPLITINLINE>
	    <SCHEME>过程</SCHEME>
	    <JAVASCRIPT>函数</JAVASCRIPT>
	  </SPLITINLINE>
	  进行索引，以致在 <SCHEMEINLINE>deriv</SCHEMEINLINE> 中的调度行看起来像
	  <SNIPPET EVAL="no">
          <SCHEME>
((get (operator exp) &apos;deriv) (operands exp) var)
          </SCHEME>
          <JAVASCRIPT>
get(operator(exp), &quot;deriv&quot;)(operands(exp), variable);
          </JAVASCRIPT>
	  </SNIPPET>
	  那么，对求导系统需要做哪些相应的修改？
	</LI>
  </OL>
<LABEL NAME="ex:data-directed-differentiation"></LABEL>
    <SOLUTION>
      <OL>
        
  <LI>
    <EM>说明上面所做的工作。为什么我们不能将谓词
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>number?</SCHEMEINLINE></SCHEME>
	    <JAVASCRIPT><JAVASCRIPTINLINE>is_number</JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE>
	  和
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>same-variable?</SCHEMEINLINE></SCHEME>
	    <JAVASCRIPT><JAVASCRIPTINLINE>is_same_variable</JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE>
	  同化到数据导向调度中？ 操作符符号作为 operator table 中的 “type” 键非常有用。对于数字和变量，并没有那么明显的键，尽管如果我们改变表达式作为列表表示的方式，我们也可以为这些类型的表达式引入名称。</EM>
	<P></P>
  </LI>
  <LI>
    <EM>编写求和与求积的导数的
	  <SPLITINLINE>
	    <SCHEME>过程</SCHEME>
	    <JAVASCRIPT>函数</JAVASCRIPT>
	  </SPLITINLINE>
	  ，以及将它们安装到上述程序所使用的表中所需的辅助代码。</EM>
	<P></P>
	<SNIPPET CHAP="4">
	    <NAME>deriv_generic_sum_product</NAME>
	    <REQUIRES>deriv_generic</REQUIRES>
	    <REQUIRES>deriv_generic_data</REQUIRES>
	    <REQUIRES>operation_table_from_chapter_3</REQUIRES>
	    <REQUIRES>operation_table</REQUIRES>
	    <EXAMPLE>deriv_xyx3_generic_example</EXAMPLE>
	    <EXPECTED>[ &apos;&apos;*&apos;, [ &apos;&apos;x&apos;, [ &apos;&apos;y&apos;, null ] ] ]</EXPECTED>
	    <SCHEME>
(define (deriv-sum exp var) 
  (make-sum (deriv (addend exp) var)
            (deriv (augend exp) var)))
 
(define (deriv-product exp var) 
  (make-sum (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
 
(define (install-deriv)
  (put &apos;&apos;deriv &apos;+ deriv-sum)
  (put &apos;&apos;deriv &apos;* deriv-product)
  &apos;&apos;done)
	    </SCHEME>
	    <JAVASCRIPT>
function deriv_sum(operands, variable) {		
    return make_sum(deriv(addend(operands), variable),
                    deriv(augend(operands), variable));
}
function deriv_product(operands, variable) {
    return make_sum(make_product(multiplier(operands),
                        deriv(multiplicand(operands),
                              variable)),
                    make_product(deriv(multiplier(
                                             operands),
                                       variable),
                        multiplicand(operands)));
}
function install_deriv() {
    put(&quot;deriv&quot;, &quot;+&quot;, deriv_sum);
    put(&quot;deriv&quot;, &quot;*&quot;, deriv_product);
    return &quot;done&quot;;
}
install_deriv();    
	    </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET HIDE="yes">
	    <NAME>deriv_generic_data</NAME>
	    <JAVASCRIPT>
function make_sum(a1, a2) {
    return list(&quot;+&quot;, a1, a2);
}
            
function make_product(m1, m2) {
    return list(&quot;*&quot;, m1, m2);
}
            
function addend(operands) {
    return head(operands);
}
            
function augend(operands) {
    return head(tail(operands));
}
            
function multiplier(operands) {
    return head(operands);
}
            
function multiplicand(operands) {
    return head(tail(operands));
}
	    </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET HIDE="yes">
            <NAME>deriv_xyx3_generic_example</NAME>
            <SCHEME>
(deriv &apos;*(* x y) (+ x 3))
            </SCHEME>
            <SCHEMEOUTPUT>
(+ (* (* x y) (+ 1 0))
   (* (+ (* x 0) (* 1 y))
      (+ x 3)))
            </SCHEMEOUTPUT>
            <JAVASCRIPT>
deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;);
// [ &quot;+&quot;,
//   [[&quot;*&quot;, [[&quot;*&quot;, [&quot;x&quot;, [&quot;y&quot;, null]]], [[&quot;+&quot;, [1, [0, null]]], null]]],
//    [[&quot;*&quot;, 
//      [[&quot;+&quot;,
//        [[&quot;*&quot;, [&quot;x&quot;, [0, null]]], [[&quot;*&quot;, [1, [&quot;y&quot;, null]]], null]]],
//         [[&quot;+&quot;, [&quot;x&quot;, [3, null]]], null] ] ],
//     null ]]]
            </JAVASCRIPT>
            <JAVASCRIPT_TEST>
head(tail(head(tail(deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;)))));
	    </JAVASCRIPT_TEST>
	</SNIPPET>
  </LI>

  <LI>
    <EM>
      选择任意你喜欢的额外求导规则，例如指数运算的规则
      (exercise<SPACE></SPACE><REF NAME="ex:deriv-exponentiation"></REF>)，并将其安装到这个数据导向系统中。
    </EM>
    <P></P>
    <SNIPPET HIDE="yes">
      <NAME>deriv_expo_data</NAME>
      <JAVASCRIPT>
function make_exponentiation(base, exp) {
    return list(&quot;**&quot;, base, exp);
}
function base(operands) {
    return head(operands);
}
function exponent(operands) {
    return head(tail(operands));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>example_deriv_expo_generic</NAME>
      <JAVASCRIPT>
deriv(list(&quot;**&quot;, &quot;x&quot;, 4), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(tail(head(tail(head(tail(tail(deriv(list(&quot;**&quot;, &quot;x&quot;, 4), &quot;x&quot;))))))));
      </JAVASCRIPT_TEST>
      <SCHEME>
      </SCHEME>
    </SNIPPET>
    <SNIPPET CHAP="4">
      <NAME>deriv_expo_put_it_all_together</NAME>
      <REQUIRES>deriv_generic</REQUIRES>
      <REQUIRES>deriv_generic_data</REQUIRES>
      <REQUIRES>deriv_expo_data</REQUIRES>
      <REQUIRES>operation_table_from_chapter_3</REQUIRES>
      <REQUIRES>operation_table</REQUIRES>
      <EXAMPLE>example_deriv_expo_generic</EXAMPLE>
      <EXPECTED>&apos;x&apos;</EXPECTED>
      <SCHEME>
(define (deriv-exponentiation expr var)
  (let ((base (base expr))
        (exponent (exponent expr)))
    (make-product exponent
                  (make-product (make-exponentiation base (make-sum exponent -1))
                                (deriv base var)))))
 
(define (install-exponentiation-extension)
  (put &apos;deriv &apos;** deriv-exponentiation)
  &apos;done)
      </SCHEME>
      <JAVASCRIPT>
function deriv_exponentiation(operands, variable) {		
    const bas = base(operands);
    const exp = exponent(operands);
    return make_product(exp,
               make_product(make_exponentiation(bas, make_sum(exp, -1)),
	                    deriv(bas, variable)));
}
function install_exponentiation_extension() {
    put(&quot;deriv&quot;, &quot;**&quot;, deriv_exponentiation);
    return &quot;done&quot;;
}
install_exponentiation_extension();
      </JAVASCRIPT>
    </SNIPPET>
  </LI>
  <LI>
    <EM>
      在这个简单的代数操作器中，一个表达式的类型就是将其组合在一起的代数运算符。然而，假设我们以相反的方式为
      <SPLITINLINE>
        <SCHEME>procedures</SCHEME>
        <JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      建立索引，使得在
      <SCHEMEINLINE>deriv</SCHEMEINLINE>
      中的派遣行看起来如下：
      <SNIPPET EVAL="no">
        <SCHEME>
((get (operator exp) &apos;deriv) (operands exp) var)
        </SCHEME>
        <JAVASCRIPT>
get(operator(exp), &quot;deriv&quot;)(operands(exp), variable);
        </JAVASCRIPT>
      </SNIPPET>
      那么，对求导系统需要做出哪些相应的更改？
    </EM>
    <P></P>
    我们需要改变微分库安装过程中的参数顺序：
    <SNIPPET EVAL="no">
      <SCHEME>
(put &apos;+ &apos;deriv deriv-sum )
(put &apos;* &apos;deriv deriv-product)	    
(put &apos;** &apos;deriv deriv-exponentiation)
      </SCHEME>
      <JAVASCRIPT>
put(&quot;+&quot;, &quot;deriv&quot;, deriv_sum);
put(&quot;*&quot;, &quot;deriv&quot;, deriv_product);
put(&quot;**&quot;, &quot;deriv&quot;, deriv_exponentiation);
      </JAVASCRIPT>
    </SNIPPET>
  </LI>
</OL>
    </SOLUTION>
  </EXERCISE>
  <EXERCISE> 
    贪得无厌
    <INDEX>数据库<SUBINDEX>贪得无厌企业人员</SUBINDEX></INDEX>
    贪得无厌企业公司是一家高度分散的综合企业集团，由遍布全球的大量独立部门组成。该公司<APOS></APOS>的计算机设施刚刚通过一种巧妙的网络接口方案互联，该方案使整个网络对任何用户而言看起来像是一台单独的计算机。
    贪得无厌<APOS></APOS>的总裁在首次尝试利用网络从各部门文件中提取管理信息时感到沮丧，她惊讶地发现，尽管所有部门文件都已实现为数据结构，
    <SPLITINLINE>
      <SCHEME>
	Scheme,
      </SCHEME>
      <JAVASCRIPT>
	JavaScript,
      </JAVASCRIPT>
    </SPLITINLINE>
    但所使用的具体数据结构在各部门之间各不相同。各部门经理紧急召开会议，商讨一种既能满足总部<APOS></APOS>需求又能保持各部门现有自主性的文件整合策略。
    <P></P>
    <DO_BREAK_PAGE></DO_BREAK_PAGE>
    展示如何通过
    <INDEX>数据库<SUBINDEX>数据导向编程和</SUBINDEX></INDEX>
    数据导向编程来实现这种策略。
    举例来说，假设每个部门<APOS></APOS>的人事记录由一个文件组成，该文件包含一组以员工<APOS></APOS>姓名为键的记录。该集合的结构在各部门之间各有不同。此外，每个员工<APOS></APOS>的记录本身也是一个集合（各部门的结构各不相同），其中包含以标识符（例如）为键的信息
<SCHEMEINLINE>address</SCHEMEINLINE>  和
     <SCHEMEINLINE>salary</SCHEMEINLINE>
  <OL>
    <LI>
      为总部实现一个
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>get-record</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>get_record</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
        <SCHEME>procedure</SCHEME>
        <JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      ，该程序用于从指定的人事文件中检索指定员工<APOS></APOS>的记录。此
      <SPLITINLINE>
        <SCHEME>procedure</SCHEME>
        <JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      应适用于任何部门<APOS></APOS>的文件。请解释各个部门<APOS></APOS>的文件应如何构造，特别是必须提供何种类型的信息？
    </LI>
    <LI>
      为总部实现一个
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>get-salary</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
        <SCHEME>procedure</SCHEME>
        <JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      ，该程序用于从任何部门<APOS></APOS>的人事文件中返回给定员工<APOS></APOS>记录的薪资信息。该记录应如何构造以便使此操作正常工作？
    </LI>
    <LI>
      为总部实现一个
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>find-employee-record</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>find_employee_record</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
        <SCHEME>procedure.</SCHEME>
        <JAVASCRIPT>function.</JAVASCRIPT>
      </SPLITINLINE>
      ，该程序应搜索所有部门<APOS></APOS>的文件以查找指定员工的记录并返回该记录。假设此
      <SPLITINLINE>
        <SCHEME>procedure</SCHEME>
        <JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      接受的参数为员工姓名和所有部门<APOS></APOS>文件的列表。
    </LI>
    <LI>
      当 Insatiable 收购一家新公司时，为将新的人事信息纳入中央系统，必须进行哪些更改？
    </LI>
  </OL>
<SOLUTION>
      <OL>
        
  <LI>
    <EM>为总部实现一个
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>get-record</SCHEMEINLINE></SCHEME>
	    <JAVASCRIPT><JAVASCRIPTINLINE>get_record</JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE>
          <SPLITINLINE>
	    <SCHEME>procedure</SCHEME>
	    <JAVASCRIPT>function</JAVASCRIPT>
	  </SPLITINLINE>
          ，该函数用于从指定的人事文件中检索指定员工<APOS></APOS>的记录。该
	  <SPLITINLINE>
	    <SCHEME>procedure</SCHEME>
	    <JAVASCRIPT>function</JAVASCRIPT>
	  </SPLITINLINE>
          应适用于任何部门<APOS></APOS>的文件。请说明各个部门<APOS></APOS>的文件应如何构造，特别是必须提供何种类型的信息？</EM>
	  <P></P>
	  我们使用位于 section<SPACE></SPACE><REF NAME="sec:manifest-types"></REF> 的标记函数，为每个部门的文件标记一个唯一的部门标识符。我们假设每个部门都提供了 
	  <JAVASCRIPTINLINE>get_record</JAVASCRIPTINLINE> 函数的实现，并将其安装在全公司的操作表中。
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
function make_insatiable_file(division, file) {
    return pair(division, file);
}
function insatiable_file_division(insatiable_file) {
    return head(insatiable_file);
}
function insatiable_file_content(insatiable_file) {
    return tail(insatiable_file);
}
function get_record(employee_name, insatiable_file) {
    const the_division 
        = insatiable_file_division(insatiable_file);
    const division_record = get(&quot;get_record&quot;, the_division)
                            (employee_name, 
                             insatiable_file_content(
                                 insatiable_file);
    return ! is_undefined(record)
           ? attach_tag(the_division, division_record)
           : undefined;
}
	    </JAVASCRIPT>
	  </SNIPPET>
  </LI>
  <LI>
    <EM>为总部实现一个
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>get-salary</SCHEMEINLINE></SCHEME>
	    <JAVASCRIPT><JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>
          <SPLITINLINE>
	    <SCHEME>procedure</SCHEME>
	    <JAVASCRIPT>function</JAVASCRIPT>
	  </SPLITINLINE>
          ，该函数用于从任何部门<APOS></APOS>的人事文件中返回给定员工<APOS></APOS>记录的薪资信息。该记录应如何构造才能使此操作正常运行？</EM>
	  <P></P>
	  每个部门都需要实现诸如 <JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE> 之类的函数，并将它们安装在 Insatiable 的操作表中。随后，Insatiable 的函数 <JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE> 可按如下方式实现：
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
function make_insatiable_record(division, record) {
    return pair(division, record);
}
function insatiable_record_division(insatiable_record) {
    return head(insatiable_record);
}
function insatiable_record_content(insatiable_record) {
    return tail(insatiable_record);
}
function get_salary(insatiable_record) {
    const the_division = 
        insatiable_record_division(insatiable_record);
    return get(&quot;get_salary&quot;, the_division)
           (insatiable_record_content);
}
	    </JAVASCRIPT>
	  </SNIPPET>
	  请注意，我们依赖于这样一个事实：任何由 <JAVASCRIPTINLINE>get_record</JAVASCRIPTINLINE> 返回的员工记录，都已使用其所属部门进行标记，而该部门标识用于通用函数
	  <JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE> 从操作表中检索正确的实现。
  </LI>

  <LI>
    <EM>
      为总部实现一个
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>find-employee-record</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>find_employee_record</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
        <SCHEME>procedure.</SCHEME>
        <JAVASCRIPT>function.</JAVASCRIPT>
      </SPLITINLINE>
      这应该搜索所有部门<APOS></APOS>的文件以查找给定员工的记录并返回该记录。假设该
      <SPLITINLINE><SCHEME>procedure</SCHEME>
        <JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      接受一个员工的姓名和所有部门<APOS></APOS>文件的列表作为参数。
    </EM>
    <SNIPPET EVAL="no">
      <JAVASCRIPT>
function find_employee_record(employee_name, 
                              personnel_files) {
    if (is_null(personnel_files)) {
        return undefined;
    } else {
        const insatiable_record 
            = get_record(employee_name,
                         head(personnel_files));
        return ! is_undefined(insatiable_record)
               ? insatiable_record
               : find_employee_record(employee_name, 
                                      tail(personnel_files));
    }
}
      </JAVASCRIPT>
    </SNIPPET>
  </LI>
  <LI>
    <EM>
      当 Insatiable 接管一家新公司时，为了将新的人事信息纳入中央系统，必须做出哪些更改？
    </EM>
    <P></P>
    对于每家新收购的公司，我们需要进行以下操作：
    <UL>
      <LI>
        决定一个名称，用作与新部门相关的任何数据项的标签。
      </LI>
      <LI>
        编写所有部门特定的函数，如 
        <JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE>
        ，并使用该部门标签将它们安装到整个公司的操作表中。
      </LI>
      <LI>
        将员工文件添加到 
        <JAVASCRIPTINLINE>personnel_files</JAVASCRIPTINLINE>
        列表中。注意，这是一个 <QUOTE>破坏性</QUOTE>
        操作<EMDASH></EMDASH>类似于操作表的扩展——因为数据结构将被永久且不可撤销地修改；section<SPACE></SPACE><REF NAME="sec:mutable-data"></REF> 详细解释了这一概念。
      </LI>
    </UL>
  </LI>
</OL>
    </SOLUTION>
    <LABEL NAME="ex:2_74"></LABEL>
  </EXERCISE>
  
  <INDEX>数据导向编程<CLOSE></CLOSE></INDEX>

  
  <INDEX>可加性<CLOSE></CLOSE></INDEX>


  
  <SUBHEADING>
    <NAME>消息传递</NAME>
  </SUBHEADING>


  

  <TEXT>
数据导向编程的关键思想是通过显式处理操作与类型表来处理程序中的通用操作，例如在
<SPLITINLINE>
  <SCHEME>
	figure<SPACE></SPACE><REF NAME="fig:operator-table_scheme"></REF>.
  </SCHEME>
  <JAVASCRIPT>
	figure<SPACE></SPACE><REF NAME="fig:operator-table"></REF>.
  </JAVASCRIPT>
</SPLITINLINE>
中所示的表格。我们在
section<SPACE></SPACE><REF NAME="sec:manifest-types"></REF>
中所采用的编程风格，是通过让每个操作负责其自身的分派来组织所需的基于类型的分派。实际上，这将操作与类型表分解为多行，每个通用操作
<SPLITINLINE>
  <SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT>
</SPLITINLINE>
都表示该表中的一行。
</TEXT>
  <TEXT>另一种实现策略是将表分解为列，并且不使用<QUOTE>智能操作</QUOTE>来进行基于数据类型的分派，而使用<QUOTE>智能数据对象</QUOTE>来进行基于操作名称的分派。我们可以通过这样的安排，使得一个数据对象，例如矩形数，被表示为
<SPLITINLINE>
  <SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT>
</SPLITINLINE>
它将所需的操作名称作为输入，并执行相应的操作。在这种结构中，
<SPLITINLINE>
  <SCHEME><SCHEMEINLINE>make-from-real-imag</SCHEMEINLINE></SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE></JAVASCRIPT>
</SPLITINLINE>
可以写成<SNIPPET CHAP="3">
      <INDEX><DECLARATION>make_from_real_imag</DECLARATION><SUBINDEX>message-passing</SUBINDEX></INDEX>
      <NAME>make_from_real_imag_message_passing</NAME>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>message_passing_example</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      <SCHEME>
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op &apos;real-part) x)
          ((eq? op &apos;imag-part) y)
          ((eq? op &apos;magnitude)
            (sqrt (+ (square x) (square y))))
          ((eq? op &apos;angle) (atan y x))
          (else
            (error &quot;Unknown op -- MAKE-FROM-REAL-IMAG&quot; op))))
  dispatch)
      </SCHEME>
      <JAVASCRIPT>
function make_from_real_imag(x, y) {
    function dispatch(op) {
        return op === &quot;real_part&quot;
               ? x
               : op === &quot;imag_part&quot;
               ? y
               : op === &quot;magnitude&quot;
               ? math_sqrt(square(x) + square(y))
               : op === &quot;angle&quot;
               ? math_atan2(y, x)
               : error(op, &quot;unknown op -- make_from_real_imag&quot;);
    }
    return dispatch;
}
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
function make_from_real_imag(x, y) {
    function dispatch(op) {
        return op === &quot;real_part&quot;
               ? x
               : op === &quot;imag_part&quot;
               ? y
               : op === &quot;magnitude&quot;
               ? math_sqrt(square(x) + square(y))
               : op === &quot;angle&quot;
               ? math_atan2(y, x)
               : error(op, &quot;unknown op -- make_from_real_imag&quot;);
    }
    return dispatch;
}
    
function make_from_mag_ang(r, a) {
    function dispatch(op) {
        return op === &quot;real_part&quot;
               ? r * math_cos(a)
               : op === &quot;imag_part&quot;
               ? r * math_sin(a)
               : op === &quot;magnitude&quot;
               ? r
               : op === &quot;angle&quot;
               ? a
               : error(op, &quot;unknown op -- make_from_real_imag&quot;);
    }
    return dispatch;
}
    
function apply_generic(op, arg) {
    return head(arg)(op);
}
function real_part(z) {
   return apply_generic(&quot;real_part&quot;, list(z));
}
function imag_part(z) {
   return apply_generic(&quot;imag_part&quot;, list(z));
}
function magnitude(z) {
   return apply_generic(&quot;magnitude&quot;, list(z));
}
function angle(z) {
   return apply_generic(&quot;angle&quot;, list(z));
}
function add_complex(z1, z2) {
    return make_from_real_imag(
               real_part(z1) + real_part(z2),
               imag_part(z1) + imag_part(z2));
}
function sub_complex(z1, z2) {
    return make_from_real_imag(
               real_part(z1) - real_part(z2),
               imag_part(z1) - imag_part(z2));
}
function mul_complex(z1, z2) {
    return make_from_mag_ang(
               magnitude(z1) * magnitude(z2),
               angle(z1) + angle(z2));
}
function div_complex(z1, z2) {
    return make_from_mag_ang(
               magnitude(z1) / magnitude(z2),
               angle(z1) - angle(z2));
}
// operation_table, put and get
// from chapter 3 (section 3.3.3)
function assoc(key, records) {
    return is_null(records)
           ? undefined
           : equal(key, head(head(records)))
           ? head(records)
           : assoc(key, tail(records));
}
function make_table() {
    const local_table = list(&quot;*table*&quot;);
    function lookup(key_1, key_2) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            return undefined;
        } else {
            const record = assoc(key_2, tail(subtable));
            return is_undefined(record)
                   ? undefined
                   : tail(record);
        }
    }
    function insert(key_1, key_2, value) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            set_tail(local_table,
                     pair(list(key_1, pair(key_2, value)),
                          tail(local_table)));
        } else {
            const record = assoc(key_2, tail(subtable));
            if (is_undefined(record)) {
      	        set_tail(subtable,
	                       pair(pair(key_2, value),
                              tail(subtable)));
	    } else {
                set_tail(record, value);
            }
        }
    }
    function dispatch(m) {
        return m === &quot;lookup&quot;
               ? lookup
               : m === &quot;insert&quot;
               ? insert
               : &quot;undefined operation -- table&quot;;
    }
    return dispatch;
}
const operation_table = make_table();
const get = operation_table(&quot;lookup&quot;);
const put = operation_table(&quot;insert&quot;);
function attach_tag(type_tag, contents) {
    return pair(type_tag, contents);
}
function type_tag(datum) {
    return is_pair(datum)
           ? head(datum)
           : error(datum, &quot;bad tagged datum -- type_tag&quot;);
}
function contents(datum) {
    return is_pair(datum)
           ? tail(datum)
           : error(datum, &quot;bad tagged datum -- contents&quot;);
}
function install_rectangular_package() {
    function real_part(z) { return head(z); }
    function imag_part(z) { return tail(z); }
    function make_from_real_imag(x, y) { return pair(x, y); }
    function magnitude(z) {
        return math_sqrt(square(real_part(z)) +
                   square(imag_part(z)));
    }
    function angle(z) {
        return math_atan2(imag_part(z), real_part(z));
    }
    function make_from_mag_ang(r, a) {
        return pair(r * math_cos(a), r * math_sin(a));
    }
    // interface to the rest of the system
    function tag(x) {
        return attach_tag(&quot;rectangular&quot;, x);
    }
    put(&quot;real_part&quot;, list(&quot;rectangular&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;rectangular&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;rectangular&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;rectangular&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;rectangular&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}

install_rectangular_package();
function install_polar_package() {
    // internal functions
    function magnitude(z) { return head(z); }
    function angle(z) { return tail(z); }
    function make_from_mag_ang(r, a) { return pair(r, a); }
    function real_part(z) {
       return magnitude(z) * math_cos(angle(z));
    }
    function imag_part(z) {
       return magnitude(z) * math_sin(angle(z));
    }
    function make_from_real_imag(x, y) {
       return pair(math_sqrt(square(x) + square(y)),
                   math_atan2(y, x));
    }

    // interface to the rest of the system
    function tag(x) { return attach_tag(&quot;polar&quot;, x); }
    put(&quot;real_part&quot;, list(&quot;polar&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;polar&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;polar&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;polar&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;polar&quot;, 
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;polar&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}

install_polar_package();	
      </JAVASCRIPT_RUN>
    </SNIPPET>
    对应的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    将通用操作应用于一个参数的过程，现在只需将操作<APOS></APOS>的名称传给数据对象，并让该对象完成工作：<FOOTNOTE>这种组织方式的一项局限是它只允许一个参数的通用<SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    。</FOOTNOTE>
<SNIPPET CHAP="3">
      <INDEX><DECLARATION>apply_generic</DECLARATION><SUBINDEX>with message passing</SUBINDEX></INDEX>
      <NAME>apply_generic_message_passing</NAME>
      <REQUIRES>make_from_real_imag_message_passing</REQUIRES>
      <EXAMPLE>message_passing_example</EXAMPLE>
      <SCHEME>
(define (apply-generic op arg) (arg op))
      </SCHEME>
      <JAVASCRIPT>
function apply_generic(op, arg) { return head(arg)(op); }
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>message_passing_example</NAME>
      <JAVASCRIPT>
const my_complex_number = 
    make_from_real_imag(1.0, 4.5);

const result = 
    add_complex(my_complex_number,
                my_complex_number);

imag_part(result);		
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4" HIDE="yes">
      <NAME>generic_selectors_message_passing</NAME>
      <REQUIRES>apply_generic_message_passing</REQUIRES>
      <EXAMPLE>generic_selectors_example</EXAMPLE>
      <SCHEME>
(define (real-part z) (apply-generic &apos;real-part z))
(define (imag-part z) (apply-generic &apos;imag-part z))
(define (magnitude z) (apply-generic &apos;magnitude z))
(define (angle z) (apply-generic &apos;angle z))
      </SCHEME>
      <JAVASCRIPT>
function real_part(z) {
   return apply_generic(&quot;real_part&quot;, list(z));
}
function imag_part(z) {
   return apply_generic(&quot;imag_part&quot;, list(z));
}
function magnitude(z) {
   return apply_generic(&quot;magnitude&quot;, list(z));
}
function angle(z) {
   return apply_generic(&quot;angle&quot;, list(z));
}
      </JAVASCRIPT>
    </SNIPPET>
    请注意，由
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-from-real-imag</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    返回的值是一个
    <SPLITINLINE>
      <SCHEME>过程<EMDASH></EMDASH>内部的</SCHEME>
      <JAVASCRIPT>函数<EMDASH></EMDASH>内部的</JAVASCRIPT>
    </SPLITINLINE>
<SCHEMEINLINE>dispatch</SCHEMEINLINE>
    
    <SPLITINLINE>
      <SCHEME>过程.</SCHEME>
      <JAVASCRIPT>函数.</JAVASCRIPT>
    </SPLITINLINE>
    这是
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，当
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    请求执行操作时被调用.
</TEXT>
   <TEXT>
    这种编程风格被称为 <EM>消息传递</EM>。 这个名称来源于这样的形象：数据对象是一种实体，它以 <QUOTE>消息</QUOTE> 的形式接收所请求的操作名称。 我们已经在第<SPACE></SPACE><REF NAME="sec:data?"></REF>节中看到过消息传递的一个例子，其中我们看到了
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    可以仅用
    <SPLITINLINE>
      <SCHEME>过程.</SCHEME>
      <JAVASCRIPT>函数.</JAVASCRIPT>
    </SPLITINLINE>
    来定义，而不需要任何数据对象。 这里我们看到，消息传递并不是一种数学技巧，而是一种用于组织具有通用操作的系统的有用技术。 在本章的余下部分，我们将继续使用数据定向编程，而不是消息传递，来讨论通用算术运算。 在第<SPACE></SPACE><REF NAME="chap:state"></REF>章中，我们将回到消息传递，并看到它可以成为构建仿真程序的有力工具。
  </TEXT> 

   <EXERCISE>
    实现构造函数
     <INDEX><USE>make_from_mag_ang</USE><SUBINDEX>message-passing</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-from-mag-ang</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_from_mag_ang</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    以消息传递风格实现。该
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    应与上面给出的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-from-real-imag</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    类似。
    <SOLUTION>
      <SNIPPET CHAP="3">
	<NAME>make_from_mag_ang_message_passing</NAME>
	<REQUIRES>make_from_real_imag_message_passing</REQUIRES>
	<EXAMPLE>message_passing_example_2</EXAMPLE>
	<EXPECTED>4.589053123706931</EXPECTED>
        <SCHEME>
        </SCHEME>
        <JAVASCRIPT>
function make_from_mag_ang(r, a) {
    function dispatch(op) {
        return op === &quot;real_part&quot;
            ? r * math_cos(a)
            : op === &quot;imag_part&quot;
            ? r * math_sin(a)
            : op === &quot;magnitude&quot;
            ? r
            : op === &quot;angle&quot;
            ? a
            : error(op, &quot;unknown op -- make_from_real_imag&quot;);
    }
    return dispatch;
}
        </JAVASCRIPT>
	<JAVASCRIPT_RUN>
	</JAVASCRIPT_RUN>
      </SNIPPET>

      <SNIPPET HIDE="yes">
	<NAME>message_passing_example_2</NAME>
	<JAVASCRIPT>
const my_complex_number = 
    make_from_mag_ang(3.0, 0.7);

const result = 
    add_complex(my_complex_number,
                my_complex_number);

real_part(result);		
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:2_75"></LABEL>
  </EXERCISE> 

   <EXERCISE>
    作为一个具有通用操作的大型系统不断演化，可能需要添加新的数据对象类型或新的操作。对于下列三种策略——具有显式调度的通用操作、数据定向风格和消息传递风格——描述为了添加新类型或新操作，系统必须做出的改变。哪个组织方式对于经常需要添加新类型的系统最为合适？哪个对于经常需要添加新操作的系统最为合适？
    <LABEL NAME="ex:extend-generic"></LABEL>
    <SOLUTION>
      <UL>
	<LI>
	  <EM>具有显式调度的通用操作</EM>：对于每个新类型，我们需要修改每个通用接口函数，并添加新的案例。
	</LI>
	<LI>
	  <EM>数据定向风格</EM>：在这种风格中，通用接口函数的实现可以整齐地打包在每个新类型的<QUOTE>install</QUOTE>库中。我们也可以为新操作配备<QUOTE>install</QUOTE>库。
	</LI>
	<LI>
	  <EM>消息传递风格</EM>：与数据定向风格相似，我们需要为每个新类型编写一个库。在这种情况下，该库由一个包含每个通用接口函数情况的调度函数组成。
	</LI>
      </UL>
      总的来说，当我们需要频繁添加新操作时，数据定向风格可能是最佳选择；而当我们需要频繁添加新类型时，消息传递风格则更为合适。
    </SOLUTION>
  </EXERCISE> 
</SUBSECTION>
