<SUBSECTION>
  <NAME>
    The Machine Model
  </NAME><!-- Error occurred while translating this section -->

  <LABEL NAME="sec:machine-model"></LABEL>

  <TEXT>
    The machine model generated by
    <SPLITINLINE>
      <SCHEME>make-machine</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_machine</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is represented as a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    with local state using the message-passing techniques
    developed in chapter<SPACE></SPACE><REF NAME="chap:state"></REF>.  To build this model,
    <SPLITINLINE>
      <SCHEME>make-machine</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_machine</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    begins by calling the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>make-new-machine</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_new_machine</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to construct
    the parts of the machine model that are common to all register
    machines.  This basic machine model constructed by
    <SPLITINLINE>
      <SCHEME>make-new-machine</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_new_machine</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is essentially a container for some registers and a stack, together with an
    execution mechanism that processes the controller instructions one by one.
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    <SPLITINLINE>
      <SCHEME>Make-machine</SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_machine</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    then extends this basic model (by sending it
    messages) to include the registers, operations, and controller of the
    particular machine being defined.  First it allocates a register in
    the new machine for each of the supplied register names and installs
    the designated operations in the machine.  Then it uses an 
    <INDEX>assembler</INDEX>
    <EM>assembler</EM> (described below in
    section<SPACE></SPACE><REF NAME="sec:assembler"></REF>) to transform the controller list
    into instructions for the new machine and installs these as the
    machine<APOS></APOS>s instruction sequence.
    <SPLITINLINE>
      <SCHEME>Make-machine</SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_machine</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    returns as its value the modified machine model.
    <!-- Error occurred while translating this section --><SNIPPET HIDE="yes">
      <NAME>gcd_machine_complete_example</NAME>
      <REQUIRES>make_machine</REQUIRES>
      <REQUIRES>start</REQUIRES>
      <JAVASCRIPT>
const gcd_machine =
    make_machine(
        list(&quot;a&quot;, &quot;b&quot;, &quot;t&quot;),
        list(list(&quot;rem&quot;, (a, b) =&gt; a % b),
             list(&quot;=&quot;, (a, b) =&gt; a === b)),
        list(
          &quot;test_b&quot;,
            test(list(op(&quot;=&quot;), reg(&quot;b&quot;), constant(0))),
            branch(label(&quot;gcd_done&quot;)),
            assign(&quot;t&quot;, list(op(&quot;rem&quot;), reg(&quot;a&quot;), reg(&quot;b&quot;))),
            assign(&quot;a&quot;, reg(&quot;b&quot;)),
            assign(&quot;b&quot;, reg(&quot;t&quot;)),
            go_to(label(&quot;test_b&quot;)),
          &quot;gcd_done&quot;));
set_register_contents(gcd_machine, &quot;a&quot;, 206);
set_register_contents(gcd_machine, &quot;b&quot;, 40);
start(gcd_machine);
get_register_contents(gcd_machine, &quot;a&quot;);	  
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>make_machine</DECLARATION></INDEX> 
      <NAME>make_machine</NAME>
      <REQUIRES>assemble</REQUIRES>
      <REQUIRES>make_new_machine</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine &apos;allocate-register) register-name))
              register-names)
    ((machine &apos;install-operations) ops)    
    ((machine &apos;install-instruction-sequence)
    (assemble controller-text machine))
    machine))
      </SCHEME>
      <JAVASCRIPT>
function make_machine(register_names, ops, controller) {
    const machine = make_new_machine();
    for_each(register_name =&gt; 
               machine(&quot;allocate_register&quot;)(register_name), 
             register_names);
    machine(&quot;install_operations&quot;)(ops);
    machine(&quot;install_instruction_sequence&quot;)
           (assemble(controller, machine));
    return machine;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Registers</NAME>
  </SUBHEADING><!-- Error occurred while translating this section -->

  <INDEX>register(s)<SUBINDEX>representing</SUBINDEX></INDEX><!-- Error occurred while translating this section -->

  <TEXT>
    We will represent a register as a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    with local state, as in
    chapter<SPACE></SPACE><REF NAME="chap:state"></REF>.  The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>make-register</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_register</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE> creates a register that
    holds a value that can be accessed or changed:
    <!-- Error occurred while translating this section --><SNIPPET>
      <INDEX><DECLARATION>make_register</DECLARATION></INDEX> 
      <NAME>make_register</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-register name)
  (let ((contents &apos;*unassigned*))
    (define (dispatch message)
      (cond ((eq? message &apos;get) contents)
            ((eq? message &apos;set)
             (lambda (value) (set! contents value)))
            (else
             (error &quot;Unknown request - - REGISTER&quot; message))))
    dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_register(name) {
    let contents = &quot;*unassigned*&quot;;
    function dispatch(message) {
        return message === &quot;get&quot;
               ? contents
               : message === &quot;set&quot;
               ? value =&gt; { contents = value; }
               : error(message, &quot;unknown request -- make_register&quot;);
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET>

    The following
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    are used to access registers:
    <!-- Error occurred while translating this section --><SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>get_contents</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_contents</DECLARATION></INDEX> 
      <NAME>get_contents</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (get-contents register)
  (register &apos;get))

(define (set-contents! register value)
  ((register &apos;set) value))
      </SCHEME>
      <JAVASCRIPT>
function get_contents(register) {
    return register(&quot;get&quot;);
}
function set_contents(register, value) {
    return register(&quot;set&quot;)(value);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>The stack</NAME>
  </SUBHEADING><!-- Error occurred while translating this section -->

  <INDEX>stack<SUBINDEX>representing</SUBINDEX></INDEX><!-- Error occurred while translating this section -->

  <TEXT>
    We can also represent a stack as a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    with local state.  The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-stack</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_@stack</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    creates a stack whose local state consists
    of a list of the items on the stack.  A stack accepts requests to
    <!-- Error occurred while translating this section --><SCHEMEINLINE>push</SCHEMEINLINE> an item onto the stack, to
    <!-- Error occurred while translating this section --><SCHEMEINLINE>pop</SCHEMEINLINE> the top item off the stack
    and return it, and to
    <!-- Error occurred while translating this section --><SCHEMEINLINE>initialize</SCHEMEINLINE> the stack to empty.
    <!-- Error occurred while translating this section --><SNIPPET HIDE="yes">
      <NAME>make_stack</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-stack)
  (let ((s &apos;()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error &quot;Empty stack - - POP&quot;)
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s &apos;())
      &apos;done)
    (define (dispatch message)
      (cond ((eq? message &apos;push) push)
            ((eq? message &apos;pop) (pop))
            ((eq? message &apos;initialize) (initialize))
            (else (error &quot;Unknown request - - STACK&quot;
                         message))))
    dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_stack() {
    let stack = null;
    let frame = null;
    function push_marker() {
        frame = pair(stack, frame);
        return &quot;done&quot;;
    }
    function pop_marker() {
        stack = head(frame);
        frame = tail(frame);
        return &quot;done&quot;;
    }
    function push(x) { 
        stack = pair(x, stack); 
        return &quot;done&quot;;
    }
    function pop() {
        if (is_null(stack)) {
            error(&quot;empty stack -- pop&quot;);
        } else {
            const top = head(stack);
            stack = tail(stack);
            return top;
        }
    }
    function initialize() {
        stack = null;
        return &quot;done&quot;;
    }
    function dispatch(message) {
        return message === &quot;push&quot;
               ? push
               : message === &quot;pop&quot;
               ? pop()
               : message === &quot;push_marker&quot;
               ? push_marker()
               : message === &quot;pop_marker&quot;
               ? pop_marker()
               : message === &quot;initialize&quot;
               ? initialize()
               : error(message, &quot;unknown request -- stack&quot;);
    }
    return dispatch;
}

function make_push_marker_to_stack_ef(machine, stack, pc) {
    return () =&gt; {
                   push_marker(stack);
                   advance_pc(pc);
                 };
}
function make_revert_stack_to_marker_ef(machine, stack, pc) {
    return () =&gt; {
                   pop_marker(stack);
                   advance_pc(pc); 
                 };
}

function push_marker_to_stack() { return list(&quot;push_marker_to_stack&quot;); }
function revert_stack_to_marker() { return list(&quot;revert_stack_to_marker&quot;); }

function pop_marker(stack) {
    return stack(&quot;pop_marker&quot;);
}
function push_marker(stack) {
    return stack(&quot;push_marker&quot;);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>make_stack</DECLARATION></INDEX> 
      <SCHEME>
(define (make-stack)
  (let ((s &apos;()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error &quot;Empty stack - - POP&quot;)
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s &apos;())
      &apos;done)
    (define (dispatch message)
      (cond ((eq? message &apos;push) push)
            ((eq? message &apos;pop) (pop))
            ((eq? message &apos;initialize) (initialize))
            (else (error &quot;Unknown request - - STACK&quot;
                         message))))
    dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_stack() {
    let stack = null;
    function push(x) { 
        stack = pair(x, stack); 
        return &quot;done&quot;;
    }
    function pop() {
        if (is_null(stack)) {
            error(&quot;empty stack -- pop&quot;);
        } else {
            const top = head(stack);
            stack = tail(stack);
            return top;
        }
    }
    function initialize() {
        stack = null;
        return &quot;done&quot;;
    }
    function dispatch(message) {
        return message === &quot;push&quot;
               ? push
               : message === &quot;pop&quot;
               ? pop()
               : message === &quot;initialize&quot;
               ? initialize()
               : error(message, &quot;unknown request -- stack&quot;);
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET>

    The following
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    are used to access stacks:
    <!-- Error occurred while translating this section --><SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>pop</DECLARATION></INDEX> 
      <INDEX><DECLARATION>push</DECLARATION></INDEX> 
      <NAME>pop</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (pop stack)
  (stack &apos;pop))

(define (push stack value)
  ((stack &apos;push) value))
      </SCHEME>
      <JAVASCRIPT>
function pop(stack) {
    return stack(&quot;pop&quot;);
}
function push(stack, value) {
    return stack(&quot;push&quot;)(value);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>The basic machine</NAME>
  </SUBHEADING><!-- Error occurred while translating this section -->

  <TEXT>
    The
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-new-machine</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_new_machine</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    shown in figure<SPACE></SPACE><REF NAME="fig:make-new-machine"></REF>, constructs an
    object whose local state consists of a stack, an initially empty instruction
    sequence, a list of operations that initially contains an operation to 
    <INDEX><USE>initialize_stack</USE> operation in register machine</INDEX>
    initialize the stack, and a 
    <INDEX>register table, in simulator</INDEX>
    <EM>register table</EM> that initially contains two
    registers, named
    <INDEX><USE>flag</USE> register</INDEX>
    <SCHEMEINLINE>flag</SCHEMEINLINE> and
    <INDEX><USE>pc</USE> register</INDEX>
    <SCHEMEINLINE>pc</SCHEMEINLINE>
    <INDEX>program counter</INDEX>
    (for <QUOTE>program counter</QUOTE>). The internal
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>allocate-register</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>allocate_register</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    adds new entries to the register table, and the internal
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>lookup-register</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>lookup_register</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    looks up registers in the table.
  </TEXT><!-- Error occurred while translating this section -->
    <SPLIT>
      <SCHEME>
	<SNIPPET EVAL="no">
	  <SCHEME>
(define (make-new-machine)
  (let ((pc (make-register &apos;pc))
        (flag (make-register &apos;flag))
        (stack (make-stack))
        (the-instruction-sequence &apos;()))
    (let ((the-ops
           (list (list &apos;initialize-stack
                       (lambda () (stack &apos;initialize)))))
          (register-table
           (list (list &apos;pc pc) (list &apos;flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error &quot;Multiply defined register: &quot; name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        &apos;register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error &quot;Unknown register:&quot; name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              &apos;done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message &apos;start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message &apos;install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message &apos;allocate-register) allocate-register)
              ((eq? message &apos;get-register) lookup-register)
              ((eq? message &apos;install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message &apos;stack) stack)
              ((eq? message &apos;operations) the-ops)
              (else (error &quot;Unknown request - - MACHINE&quot; message))))
      dispatch)))
	  </SCHEME>
	</SNIPPET>
      </SCHEME>
      <JAVASCRIPT>
	<FIGURE CENTER="no">
	  <SNIPPET SMALL="yes">
	    <NAME>make_new_machine</NAME>
	    <REQUIRES>make_stack</REQUIRES>
	    <REQUIRES>make_register</REQUIRES>
	    <REQUIRES>lookup1</REQUIRES>
	    <REQUIRES>get_contents</REQUIRES>
	    <REQUIRES>make_inst</REQUIRES>
	    <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
	    <JAVASCRIPT>
function make_new_machine() {
    const pc = make_register(&quot;pc&quot;);
    const flag = make_register(&quot;flag&quot;);
    const stack = make_stack();
    let the_instruction_sequence = null;
    let the_ops = list(list(&quot;initialize_stack&quot;, () =&gt; stack(&quot;initialize&quot;)));
    let register_table = list(list(&quot;pc&quot;, pc), list(&quot;flag&quot;, flag));
    function allocate_register(name) {
        if (is_undefined(assoc(name, register_table))) {
            register_table = pair(list(name, make_register(name)),
                                  register_table);
        } else {
            error(name, &quot;multiply defined register&quot;);
        }
        return &quot;register allocated&quot;;
    }
    function lookup_register(name) {
        const val = assoc(name, register_table);
        return is_undefined(val)
               ? error(name, &quot;unknown register&quot;)
               : head(tail(val));
    }
    function execute() {
        const insts = get_contents(pc);
        if (is_null(insts)) {
            return &quot;done&quot;;
        } else {
            inst_execution_fun(head(insts))();
            return execute();
        }
    }
    function dispatch(message) {
        function start() {
            set_contents(pc, the_instruction_sequence);
            return execute();
        }
        return message === &quot;start&quot;
               ? start()
               : message === &quot;install_instruction_sequence&quot;
               ? seq =&gt; { the_instruction_sequence = seq; }
               : message === &quot;allocate_register&quot;
               ? allocate_register
               : message === &quot;get_register&quot;
               ? lookup_register
               : message === &quot;install_operations&quot;
               ? ops =&gt; { the_ops = append(the_ops, ops); }
               : message === &quot;stack&quot;
               ? stack
               : message === &quot;operations&quot;
               ? the_ops
               : error(message, &quot;unknown request -- machine&quot;);
    }
    return dispatch;
}
	    </JAVASCRIPT>
	  </SNIPPET>
	  <CAPTION>
	    The
	    <INDEX><DECLARATION>make_new_machine</DECLARATION></INDEX> 
	    <JAVASCRIPTINLINE>make_new_machine</JAVASCRIPTINLINE>
	    function implements the basic machine model.
	  </CAPTION>
	  <!-- Error occurred while translating this section --><LABEL NAME="fig:make-new-machine"></LABEL>
	</FIGURE>
      </JAVASCRIPT>
    </SPLIT>

  <TEXT>
    The <SCHEMEINLINE>flag</SCHEMEINLINE> register is used to control branching
    in the simulated machine.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Test</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>Our <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    instructions set the contents of
    <SCHEMEINLINE>flag</SCHEMEINLINE> to the result of the test (true or false).
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Branch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>Our <JAVASCRIPTINLINE>branch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    instructions decide whether or not to branch by examining the contents of
    <SCHEMEINLINE>flag</SCHEMEINLINE>.
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    The <SCHEMEINLINE>pc</SCHEMEINLINE> register determines the sequencing of
    instructions as the machine runs.  This sequencing is implemented by the
    internal
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>execute</SCHEMEINLINE>.
    In the simulation model, each machine instruction is a data structure
    that includes a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of no arguments, called the 
    <INDEX>instruction execution <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE></INDEX>
    <INDEX>execution <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>in register-machine simulator</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><EM>instruction execution procedure</EM>,</SCHEME>
      <JAVASCRIPT><EM>instruction execution function</EM>,</JAVASCRIPT>
    </SPLITINLINE>
    such that calling this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    simulates executing the instruction.  As the simulation runs,
    <SCHEMEINLINE>pc</SCHEMEINLINE> points to the place in the instruction
    sequence beginning with the next instruction to be executed.  
    <INDEX><USE>execute</USE></INDEX> 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Execute</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>execute</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    gets that instruction, executes it by calling the instruction execution
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    and repeats this cycle until there are no more instructions to execute
    (i.e., until <SCHEMEINLINE>pc</SCHEMEINLINE> points to the end of the
    instruction sequence).
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    As part of its operation, each instruction execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    modifies
    <SCHEMEINLINE>pc</SCHEMEINLINE> to indicate the next instruction to be
    executed.
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Branch</SCHEMEINLINE> and
	<SCHEMEINLINE>goto</SCHEMEINLINE> instructions
      </SCHEME>
      <JAVASCRIPT>
	The instructions
	<JAVASCRIPTINLINE>branch</JAVASCRIPTINLINE>
	and
	<JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    change <SCHEMEINLINE>pc</SCHEMEINLINE> to point to the new destination.
    All other instructions simply advance <SCHEMEINLINE>pc</SCHEMEINLINE>,
    making it point to the next instruction in the sequence.  Observe that
    each call to <SCHEMEINLINE>execute</SCHEMEINLINE> calls
    <SCHEMEINLINE>execute</SCHEMEINLINE> again, but this does not produce an
    infinite loop because running the instruction execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    changes the contents of <SCHEMEINLINE>pc</SCHEMEINLINE>.
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-new-machine</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_new_machine</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    returns a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>dispatch</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that implements message-passing access to the internal state.  Notice that
    starting the machine is accomplished by setting
    <SCHEMEINLINE>pc</SCHEMEINLINE> to the beginning of the instruction sequence
    and calling <SCHEMEINLINE>execute</SCHEMEINLINE>.
  </TEXT><!-- Error occurred while translating this section -->

  <LONG_PAGE LINES="2"></LONG_PAGE>
  <TEXT>
    For convenience, we provide an alternate
    <SPLITINLINE><SCHEME>procedural</SCHEME><JAVASCRIPT></JAVASCRIPT></SPLITINLINE>
    interface to a machine<APOS></APOS>s
    <!-- Error occurred while translating this section --><SCHEMEINLINE>start</SCHEMEINLINE> operation, as well as
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    to set and examine register contents, as specified at the beginning of
    section<SPACE></SPACE><REF NAME="sec:simulator"></REF>:
    <!-- Error occurred while translating this section --><SNIPPET>
      <INDEX><DECLARATION>start</DECLARATION> register machine</INDEX>
      <INDEX><DECLARATION>get_register_contents</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_register_contents</DECLARATION></INDEX> 
      <NAME>start</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (start machine)
  (machine &apos;start))

(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))

(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  &apos;done)
      </SCHEME>
      <JAVASCRIPT>
function start(machine) {
    return machine(&quot;start&quot;);
}
function get_register_contents(machine, register_name) {
    return get_contents(get_register(machine, register_name));
}
function set_register_contents(machine, register_name, value) {
    set_contents(get_register(machine, register_name), value);
    return &quot;done&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>

    These
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    (and many
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in sections<SPACE></SPACE><REF NAME="sec:assembler"></REF> and <REF NAME="sec:ex-proc"></REF>)
    use the following to look up the register with a given name in a given
    machine:
    <!-- Error occurred while translating this section --><SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>get_register</DECLARATION></INDEX> 
      <NAME>get_register</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (get-register machine reg-name)
  ((machine &apos;get-register) reg-name))
      </SCHEME>
      <JAVASCRIPT>
function get_register(machine, reg_name) {
    return machine(&quot;get_register&quot;)(reg_name);
}
      </JAVASCRIPT>
    </SNIPPET>
</TEXT>
</SUBSECTION>

