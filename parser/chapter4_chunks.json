[
  {
    "source_file": "chapter4.xml",
    "tag_type": "CHAPTER",
    "title": "Metalinguistic Abstraction",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 1,
    "content": "In our study of program design, we have seen that expert programmers control the complexity of their designs with the same general techniques used by designers of all complex systems. They combine primitive elements to form compound objects, they abstract compound objects to form higher-level building blocks, and they preserve modularity by adopting appropriate large-scale views of system structure. In illustrating these techniques, we have used Lisp JavaScript as a language for describing processes and for constructing computational data objects and processes to model complex phenomena in the real world. However, as we confront increasingly complex problems, we will find that Lisp, JavaScript, or indeed any fixed programming language, is not sufficient for our needs. We must constantly turn to new languages in order to express our ideas more effectively. Establishing new languages is a powerful strategy for controlling complexity in engineering design; we can often enhance our ability to deal with a complex problem by adopting a new language that enables us to describe (and hence to think about) the problem in a different way, using primitives, means of combination, and means of abstraction that are particularly well suited to the problem at hand."
  },
  {
    "source_file": "chapter4.xml",
    "tag_type": "CHAPTER",
    "title": "Metalinguistic Abstraction",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 2,
    "content": "Programming is endowed with a multitude of languages. There are physical languages, such as the procedure definition, function declaration, that are appropriate to the larger-scale organization of systems."
  },
  {
    "source_file": "chapter4.xml",
    "tag_type": "CHAPTER",
    "title": "Metalinguistic Abstraction",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 3,
    "content": "Metalinguistic abstraction establishing plays an important role in all branches of engineering design. It is particularly important to computer programming, because in programming not only can we formulate new languages but we can also implement these languages by constructing evaluators. An evaluator (or interpreter ) for a programming language is a procedure function that, when applied to a statement or expression an expression of the language, performs the actions required to evaluate that statement or expression. It is no exaggeration to regard this as the most fundamental idea in programming: The evaluator, which determines the meaning of statements and expressions in a programming language, is just another program. To appreciate this point is to change our images of ourselves as programmers. We come to see ourselves as designers of languages, rather than only users of languages designed by others."
  },
  {
    "source_file": "chapter4.xml",
    "tag_type": "CHAPTER",
    "title": "Metalinguistic Abstraction",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 4,
    "content": "In fact, we can regard almost any program as the evaluator for some language. For instance, the polynomial manipulation system of section embodies the rules of polynomial arithmetic and implements them in terms of operations on list-structured data. If we augment this system with procedures functions to read and print polynomial expressions, we have the core of a special-purpose language for dealing with problems in symbolic mathematics. The digital-logic simulator of section and the constraint propagator of section are legitimate languages in their own right, each with its own primitives, means of combination, and means of abstraction. Seen from this perspective, the technology for coping with large-scale computer systems merges with the technology for building new computer languages, and"
  },
  {
    "source_file": "chapter4.xml",
    "tag_type": "CHAPTER",
    "title": "Metalinguistic Abstraction",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 5,
    "content": "We now embark on a tour of the technology by which languages are established in terms of other languages. In this chapter we shall use Lisp JavaScript as a base, implementing evaluators as Lisp JavaScript procedures. functions. We will take the first step in understanding how languages are implemented by building an evaluator for Lisp JavaScript itself. The language implemented by our evaluator will be a subset of the Scheme dialect of Lisp that we use in this book. JavaScript. Although the evaluator described in this chapter is written for a particular dialect of Lisp, subset of JavaScript, it contains the essential structure of an evaluator for any expression-oriented language designed for writing programs for a sequential machine. (In fact, most language processors contain, deep within them, a little Lisp evaluator.) The evaluator has been simplified for the purposes of illustration and discussion, and some features have been left out that would be important to include in a production-quality Lisp JavaScript system. Nevertheless, this simple evaluator is adequate to execute most of the programs in this book."
  },
  {
    "source_file": "chapter4.xml",
    "tag_type": "CHAPTER",
    "title": "Metalinguistic Abstraction",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 6,
    "content": "An important advantage of making the evaluator accessible as a Lisp JavaScript program is that we can implement alternative evaluation rules by describing these as modifications to the evaluator program. One place where we can use this power to good effect is to gain extra control over the ways in which computational models embody the notion of time, which was so central to the discussion in chapter . There, we mitigated some of the complexities of state and assignment by using streams to decouple the representation of time in the world from time in the computer. Our stream programs, however, were sometimes cumbersome, because they were constrained by the applicative-order evaluation of Scheme. JavaScript. In section , we ll change the underlying language to provide for a more elegant approach, by modifying the evaluator to provide for normal-order evaluation ."
  },
  {
    "source_file": "chapter4.xml",
    "tag_type": "CHAPTER",
    "title": "Metalinguistic Abstraction",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 7,
    "content": "Section implements a more ambitious linguistic change, whereby statements and expressions have many values, rather than just a single value. In this language of nondeterministic computing , it is natural to express processes that generate all possible values for statements and expressions and then search for those values that satisfy certain constraints. In terms of models of computation and time, this is like having time branch into a set of possible futures and then searching for appropriate time lines. With our nondeterministic evaluator, keeping track of multiple values and performing searches are handled automatically by the underlying mechanism of the language."
  },
  {
    "source_file": "chapter4.xml",
    "tag_type": "CHAPTER",
    "title": "Metalinguistic Abstraction",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 8,
    "content": "In section we implement a logic-programming language in which knowledge is expressed in terms of relations, rather than in terms of computations with inputs and outputs. Even though this makes the language drastically different from Lisp, JavaScript, or indeed from any conventional language, we will see that the logic-programming evaluator shares the essential structure of the Lisp JavaScript evaluator."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 1,
    "content": "In chapter we stressed that computer science deals with"
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 2,
    "content": "Most programming languages, including Lisp, JavaScript, are organized around computing the values of mathematical functions. Expression-oriented languages (such as Lisp, Fortran, Algol and JavaScript) (such as Lisp, C, Python, and JavaScript) capitalize on the pun that an expression that describes the value of a function may also be interpreted as a means of computing that value. Because of this, most programming languages are strongly biased toward unidirectional computations (computations with well-defined inputs and outputs). There are, however, radically different programming languages that relax this bias. We saw one such example in section , where the objects of computation were arithmetic constraints. In a constraint system the direction and the order of computation are not so well specified; in carrying out a computation the system must therefore provide more detailed how to knowledge than would be the case with an ordinary arithmetic computation. This does not mean, however, that the user is released altogether from the responsibility of providing imperative knowledge. There are many constraint networks that implement the same set of constraints, and the user must choose from the set of mathematically equivalent networks a suitable network to specify a particular computation."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 3,
    "content": "The nondeterministic program evaluator of section also moves away from the view that programming is about constructing algorithms for computing unidirectional functions. In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with unification ."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 4,
    "content": "This approach, when it works, can be a very what is fact can be used to solve a number of different problems that would have different how to components. As an example, consider the append operation, which takes two lists as arguments and combines their elements to form a single list. In a procedural language such as Lisp, JavaScript, we could define append in terms of the basic list constructor cons , pair , as we did in section : (define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y)))) function append(x, y) { return is_null(x) ? y : pair(head(x), append(tail(x), y)); } This procedure function can be regarded as a translation into Lisp JavaScript of the following two rules, the first of which covers the case where the first list is empty and the second of which handles the case of a nonempty list, which is a cons pair of two parts: For any list y , the empty list and y append to form y . For any u , v , y , and z , (cons u v) pair(u, v) and y append to form (cons u z) pair(u, z) if v and y append to form z . Using the append procedure, function, we can answer questions such as Find the append of (a b) list(\"a\", \"b\") and (c d) . list(\"c\", \"d\") . But the same two rules are also sufficient for answering the following sorts of questions, which the procedure function can t answer: Find a list y that append s with (a b) list(\"a\", \"b\") to produce (a b c d) . list(\"a\", \"b\", \"c\", \"d\") . Find all x and y that append to form (a b c d) . list(\"a\", \"b\", \"c\", \"d\") . In a append procedure function by stating the two rules about append given above. How to knowledge is provided automatically by the interpreter to allow this single pair of rules to be used to answer all three types of questions about append ."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 5,
    "content": "Contemporary logic programming languages (including the one we implement here) have substantial deficiencies, in that their general how to methods can lead them into spurious infinite loops or other undesirable behavior. Logic programming is an active field of research in computer science."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 6,
    "content": "Earlier in this chapter we explored the technology of implementing interpreters and described the elements that are essential to an interpreter for a Lisp-like JavaScript-like language (indeed, to an interpreter for any conventional language). Now we will apply these ideas to discuss an interpreter for a logic programming language. We call this language the query language , because it is very useful for retrieving information from data bases by formulating queries , or questions, expressed in the language. Even though the query language is very different from Lisp, JavaScript, we will find it convenient to describe the language in terms of the same general framework we have been using all along: as a collection of primitive elements, together with means of combination that enable us to combine simple elements to create more complex elements and means of abstraction that enable us to regard complex elements as single conceptual units. An interpreter for a logic programming language is considerably more complex than an interpreter for a language like Lisp. JavaScript. Nevertheless, we will see that our . In particular, there will be an evaluate part that classifies expressions according to type and an apply part that implements the language s abstraction mechanism (procedures (functions in the case of Lisp, JavaScript, and rules in the case of logic programming). Also, a central role is played in the implementation by a frame data structure, which determines the correspondence between symbols and their associated values. One additional interesting aspect of our query-language implementation is that we make substantial use of streams, which were introduced in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 1,
    "content": "In chapter we stressed that computer science deals with"
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 2,
    "content": "Most programming languages, including Lisp, JavaScript, are organized around computing the values of mathematical functions. Expression-oriented languages (such as Lisp, Fortran, Algol and JavaScript) (such as Lisp, C, Python, and JavaScript) capitalize on the pun that an expression that describes the value of a function may also be interpreted as a means of computing that value. Because of this, most programming languages are strongly biased toward unidirectional computations (computations with well-defined inputs and outputs). There are, however, radically different programming languages that relax this bias. We saw one such example in section , where the objects of computation were arithmetic constraints. In a constraint system the direction and the order of computation are not so well specified; in carrying out a computation the system must therefore provide more detailed how to knowledge than would be the case with an ordinary arithmetic computation. This does not mean, however, that the user is released altogether from the responsibility of providing imperative knowledge. There are many constraint networks that implement the same set of constraints, and the user must choose from the set of mathematically equivalent networks a suitable network to specify a particular computation."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 3,
    "content": "The nondeterministic program evaluator of section also moves away from the view that programming is about constructing algorithms for computing unidirectional functions. In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with unification ."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 4,
    "content": "This approach, when it works, can be a very what is fact can be used to solve a number of different problems that would have different how to components. As an example, consider the append operation, which takes two lists as arguments and combines their elements to form a single list. In a procedural language such as Lisp, JavaScript, we could define append in terms of the basic list constructor cons , pair , as we did in section : (define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y)))) function append(x, y) { return is_null(x) ? y : pair(head(x), append(tail(x), y)); } This procedure function can be regarded as a translation into Lisp JavaScript of the following two rules, the first of which covers the case where the first list is empty and the second of which handles the case of a nonempty list, which is a cons pair of two parts: For any list y , the empty list and y append to form y . For any u , v , y , and z , (cons u v) pair(u, v) and y append to form (cons u z) pair(u, z) if v and y append to form z . Using the append procedure, function, we can answer questions such as Find the append of (a b) list(\"a\", \"b\") and (c d) . list(\"c\", \"d\") . But the same two rules are also sufficient for answering the following sorts of questions, which the procedure function can t answer: Find a list y that append s with (a b) list(\"a\", \"b\") to produce (a b c d) . list(\"a\", \"b\", \"c\", \"d\") . Find all x and y that append to form (a b c d) . list(\"a\", \"b\", \"c\", \"d\") . In a append procedure function by stating the two rules about append given above. How to knowledge is provided automatically by the interpreter to allow this single pair of rules to be used to answer all three types of questions about append ."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 5,
    "content": "Contemporary logic programming languages (including the one we implement here) have substantial deficiencies, in that their general how to methods can lead them into spurious infinite loops or other undesirable behavior. Logic programming is an active field of research in computer science."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 6,
    "content": "Earlier in this chapter we explored the technology of implementing interpreters and described the elements that are essential to an interpreter for a Lisp-like JavaScript-like language (indeed, to an interpreter for any conventional language). Now we will apply these ideas to discuss an interpreter for a logic programming language. We call this language the query language , because it is very useful for retrieving information from data bases by formulating queries , or questions, expressed in the language. Even though the query language is very different from Lisp, JavaScript, we will find it convenient to describe the language in terms of the same general framework we have been using all along: as a collection of primitive elements, together with means of combination that enable us to combine simple elements to create more complex elements and means of abstraction that enable us to regard complex elements as single conceptual units. An interpreter for a logic programming language is considerably more complex than an interpreter for a language like Lisp. JavaScript. Nevertheless, we will see that our . In particular, there will be an evaluate part that classifies expressions according to type and an apply part that implements the language s abstraction mechanism (procedures (functions in the case of Lisp, JavaScript, and rules in the case of logic programming). Also, a central role is played in the implementation by a frame data structure, which determines the correspondence between symbols and their associated values. One additional interesting aspect of our query-language implementation is that we make substantial use of streams, which were introduced in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 1,
    "content": "In chapter we stressed that computer science deals with"
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 2,
    "content": "Most programming languages, including Lisp, JavaScript, are organized around computing the values of mathematical functions. Expression-oriented languages (such as Lisp, Fortran, Algol and JavaScript) (such as Lisp, C, Python, and JavaScript) capitalize on the pun that an expression that describes the value of a function may also be interpreted as a means of computing that value. Because of this, most programming languages are strongly biased toward unidirectional computations (computations with well-defined inputs and outputs). There are, however, radically different programming languages that relax this bias. We saw one such example in section , where the objects of computation were arithmetic constraints. In a constraint system the direction and the order of computation are not so well specified; in carrying out a computation the system must therefore provide more detailed how to knowledge than would be the case with an ordinary arithmetic computation. This does not mean, however, that the user is released altogether from the responsibility of providing imperative knowledge. There are many constraint networks that implement the same set of constraints, and the user must choose from the set of mathematically equivalent networks a suitable network to specify a particular computation."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 3,
    "content": "The nondeterministic program evaluator of section also moves away from the view that programming is about constructing algorithms for computing unidirectional functions. In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with unification ."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 4,
    "content": "This approach, when it works, can be a very what is fact can be used to solve a number of different problems that would have different how to components. As an example, consider the append operation, which takes two lists as arguments and combines their elements to form a single list. In a procedural language such as Lisp, JavaScript, we could define append in terms of the basic list constructor cons , pair , as we did in section : (define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y)))) function append(x, y) { return is_null(x) ? y : pair(head(x), append(tail(x), y)); } This procedure function can be regarded as a translation into Lisp JavaScript of the following two rules, the first of which covers the case where the first list is empty and the second of which handles the case of a nonempty list, which is a cons pair of two parts: For any list y , the empty list and y append to form y . For any u , v , y , and z , (cons u v) pair(u, v) and y append to form (cons u z) pair(u, z) if v and y append to form z . Using the append procedure, function, we can answer questions such as Find the append of (a b) list(\"a\", \"b\") and (c d) . list(\"c\", \"d\") . But the same two rules are also sufficient for answering the following sorts of questions, which the procedure function can t answer: Find a list y that append s with (a b) list(\"a\", \"b\") to produce (a b c d) . list(\"a\", \"b\", \"c\", \"d\") . Find all x and y that append to form (a b c d) . list(\"a\", \"b\", \"c\", \"d\") . In a append procedure function by stating the two rules about append given above. How to knowledge is provided automatically by the interpreter to allow this single pair of rules to be used to answer all three types of questions about append ."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 5,
    "content": "Contemporary logic programming languages (including the one we implement here) have substantial deficiencies, in that their general how to methods can lead them into spurious infinite loops or other undesirable behavior. Logic programming is an active field of research in computer science."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 6,
    "content": "Earlier in this chapter we explored the technology of implementing interpreters and described the elements that are essential to an interpreter for a Lisp-like JavaScript-like language (indeed, to an interpreter for any conventional language). Now we will apply these ideas to discuss an interpreter for a logic programming language. We call this language the query language , because it is very useful for retrieving information from data bases by formulating queries , or questions, expressed in the language. Even though the query language is very different from Lisp, JavaScript, we will find it convenient to describe the language in terms of the same general framework we have been using all along: as a collection of primitive elements, together with means of combination that enable us to combine simple elements to create more complex elements and means of abstraction that enable us to regard complex elements as single conceptual units. An interpreter for a logic programming language is considerably more complex than an interpreter for a language like Lisp. JavaScript. Nevertheless, we will see that our . In particular, there will be an evaluate part that classifies expressions according to type and an apply part that implements the language s abstraction mechanism (procedures (functions in the case of Lisp, JavaScript, and rules in the case of logic programming). Also, a central role is played in the implementation by a frame data structure, which determines the correspondence between symbols and their associated values. One additional interesting aspect of our query-language implementation is that we make substantial use of streams, which were introduced in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 1,
    "content": "In chapter we stressed that computer science deals with"
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 2,
    "content": "Most programming languages, including Lisp, JavaScript, are organized around computing the values of mathematical functions. Expression-oriented languages (such as Lisp, Fortran, Algol and JavaScript) (such as Lisp, C, Python, and JavaScript) capitalize on the pun that an expression that describes the value of a function may also be interpreted as a means of computing that value. Because of this, most programming languages are strongly biased toward unidirectional computations (computations with well-defined inputs and outputs). There are, however, radically different programming languages that relax this bias. We saw one such example in section , where the objects of computation were arithmetic constraints. In a constraint system the direction and the order of computation are not so well specified; in carrying out a computation the system must therefore provide more detailed how to knowledge than would be the case with an ordinary arithmetic computation. This does not mean, however, that the user is released altogether from the responsibility of providing imperative knowledge. There are many constraint networks that implement the same set of constraints, and the user must choose from the set of mathematically equivalent networks a suitable network to specify a particular computation."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 3,
    "content": "The nondeterministic program evaluator of section also moves away from the view that programming is about constructing algorithms for computing unidirectional functions. In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with unification ."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 4,
    "content": "This approach, when it works, can be a very what is fact can be used to solve a number of different problems that would have different how to components. As an example, consider the append operation, which takes two lists as arguments and combines their elements to form a single list. In a procedural language such as Lisp, JavaScript, we could define append in terms of the basic list constructor cons , pair , as we did in section : (define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y)))) function append(x, y) { return is_null(x) ? y : pair(head(x), append(tail(x), y)); } This procedure function can be regarded as a translation into Lisp JavaScript of the following two rules, the first of which covers the case where the first list is empty and the second of which handles the case of a nonempty list, which is a cons pair of two parts: For any list y , the empty list and y append to form y . For any u , v , y , and z , (cons u v) pair(u, v) and y append to form (cons u z) pair(u, z) if v and y append to form z . Using the append procedure, function, we can answer questions such as Find the append of (a b) list(\"a\", \"b\") and (c d) . list(\"c\", \"d\") . But the same two rules are also sufficient for answering the following sorts of questions, which the procedure function can t answer: Find a list y that append s with (a b) list(\"a\", \"b\") to produce (a b c d) . list(\"a\", \"b\", \"c\", \"d\") . Find all x and y that append to form (a b c d) . list(\"a\", \"b\", \"c\", \"d\") . In a append procedure function by stating the two rules about append given above. How to knowledge is provided automatically by the interpreter to allow this single pair of rules to be used to answer all three types of questions about append ."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 5,
    "content": "Contemporary logic programming languages (including the one we implement here) have substantial deficiencies, in that their general how to methods can lead them into spurious infinite loops or other undesirable behavior. Logic programming is an active field of research in computer science."
  },
  {
    "source_file": "section4.xml",
    "tag_type": "SECTION",
    "title": "Logic Programming",
    "parent_title": "Metalinguistic Abstraction",
    "depth": 1,
    "paragraph_index": 6,
    "content": "Earlier in this chapter we explored the technology of implementing interpreters and described the elements that are essential to an interpreter for a Lisp-like JavaScript-like language (indeed, to an interpreter for any conventional language). Now we will apply these ideas to discuss an interpreter for a logic programming language. We call this language the query language , because it is very useful for retrieving information from data bases by formulating queries , or questions, expressed in the language. Even though the query language is very different from Lisp, JavaScript, we will find it convenient to describe the language in terms of the same general framework we have been using all along: as a collection of primitive elements, together with means of combination that enable us to combine simple elements to create more complex elements and means of abstraction that enable us to regard complex elements as single conceptual units. An interpreter for a logic programming language is considerably more complex than an interpreter for a language like Lisp. JavaScript. Nevertheless, we will see that our . In particular, there will be an evaluate part that classifies expressions according to type and an apply part that implements the language s abstraction mechanism (procedures (functions in the case of Lisp, JavaScript, and rules in the case of logic programming). Also, a central role is played in the implementation by a frame data structure, which determines the correspondence between symbols and their associated values. One additional interesting aspect of our query-language implementation is that we make substantial use of streams, which were introduced in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Section described how the query system works. Now we fill in the details by presenting a complete implementation of the system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 2,
    "content": "The the evaluator qeval evaluate_query together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal: displayed: lp_header // functions from SICP JS 4.4.4 query_driver_loop functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 lp_header is_assertion instantiate evaluate_query singleton_stream add_rule_or_assertion put_and disjoin negate javascript_predicate display_stream always_true is_variable_2 is_variable_4 convert_to_query_syntax unparse user_read query_driver_loop_example (define input-prompt \";;; Query input:\") (define output-prompt \";;; Query results:\") (define (query-driver-loop) (prompt-for-input input-prompt) (let ((q (query-syntax-process (read)))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (newline) (display \"Assertion added to data base.\") (query-driver-loop)) (else (newline) (display output-prompt) (display-stream (stream-map (lambda (frame) (instantiate q frame (lambda (v f) (contract-question-mark v)))) (qeval q (singleton-stream '())))) (query-driver-loop))))) const input_prompt = \"Query input:\"; const output_prompt = \"Query results:\"; function query_driver_loop() { const input = user_read(input_prompt) + \";\"; if (is_null(input)) { display(\"evaluator terminated\"); } else { const expression = parse(input); const query = convert_to_query_syntax(expression); if (is_assertion(query)) { add_rule_or_assertion(assertion_body(query)); display(\"Assertion added to data base.\"); } else { display(output_prompt); display_stream( stream_map( frame => unparse(instantiate_expression(expression, frame)), evaluate_query(query, singleton_stream(null)))); } return query_driver_loop(); } } const input_prompt = \"Query input:\"; function query_driver_loop() { const input = user_read(input_prompt); if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } return query_driver_loop(); } } query_driver_loop_example append_to_form query_driver_loop(); // enter: append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\")) process_query_example_1 parse_query_verbose('assert(son(\"Adam\", \"Cain\"))'); parse_query_verbose('son(\"Adam\", x)'); process_query query_driver_loop process_query_example_1 function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); display(\"---- driver loop input -----\"); display(unparse(exp)); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); display(\"Assertion added to data base.\"); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } function process_query(input) { if (is_null(input)) { display(\"--- evaluator terminated ---\"); } else { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); if (is_assertion(q)) { add_rule_or_assertion(assertion_body(q)); } else { display(\"------ query results -------\", \"\"); display_stream( stream_map( frame => unparse(instantiate_expression(exp, frame)), evaluate_query(q, singleton_stream(null)))); } } } function first_answer(input) { const exp = parse(input + \";\"); const q = convert_to_query_syntax(exp); const frames = evaluate_query(q, singleton_stream(null)); return is_null(frames) ? \"no matching data\" : unparse(instantiate_expression(exp, head(frames))); } Here, as in the other evaluators in this chapter, we use an assertion-to-be-added? and the selector add-assertion-body , is given in section . Add-rule-or-assertion! is defined in section . Here, as in the other evaluators in this chapter, we use parse to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because parse expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using convert_to_query_syntax , which is declared in section along with the predicate is_assertion and the selector assertion_body . The function add_rule_or_assertion is declared in section . The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions instantiate_expression and unparse are declared in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient. This involves changing the query-syntax-process and contract-question-mark (section )."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To ?x in exp is bound to ?y as the result of unification and ?y is in turn bound to 5). The action to take if a variable cannot be instantiated is given by a procedural argument to instantiate . instantiate make_binding variable express append_to_form_example_5 (define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp)) The procedures that manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The qeval evaluate_query procedure, function, called by the query-driver-loop , query_driver_loop , is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies special syntactic forms by a get and put , just as we did in implementing generic operations in chapter . Any query that is not identified as a special syntactic form is assumed to be a simple query, to be processed by simple-query . simple_query . evaluate_query operation_table_from_chapter_3 operation_table simple_query type append_to_form_example_5 (define (qeval query frame-stream) (let ((qproc (get (type query) 'qeval))) (if qproc (qproc (contents query) frame-stream) (simple-query query frame-stream)))) function evaluate_query(query, frame_stream) { const qfun = get(type(query), \"evaluate_query\"); return is_undefined(qfun) ? simple_query(query, frame_stream) : qfun(contents(query), frame_stream); } Type The functions type and contents , defined in section , implement the abstract syntax of the special forms. the abstract syntax of the syntactic forms."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The simple-query simple_query procedure function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query. simple_query stream_flatmap find_assertions apply_rules append_to_form_example_5 (define (simple-query query-pattern frame-stream) (stream-flatmap (lambda (frame) (stream-append-delayed (find-assertions query-pattern frame) (delay (apply-rules query-pattern frame)))) frame-stream)) function simple_query(query_pattern, frame_stream) { return stream_flatmap( frame => stream_append_delayed( find_assertions(query_pattern, frame), () => apply_rules(query_pattern, frame)), frame_stream); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "For each frame in the input stream, we use find-assertions find_assertions (section ) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use apply-rules apply_rules (section ) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using stream-append-delayed , stream_append_delayed , section ) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise ). The streams for the individual input frames are combined using stream-flatmap stream_flatmap (section ) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "And by the We handle and queries as illustrated in figure with the conjoin procedure. Conjoin function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, conjoin processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies conjoin to the rest of the queries. conjoin is_empty_conjunction operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (conjoin conjuncts frame-stream) (if (empty-conjunction? conjuncts) frame-stream (conjoin (rest-conjuncts conjuncts) (qeval (first-conjunct conjuncts) frame-stream)))) function conjoin(conjuncts, frame_stream) { return is_empty_conjunction(conjuncts) ? frame_stream : conjoin(rest_conjuncts(conjuncts), evaluate_query(first_conjunct(conjuncts), frame_stream)); } The expression statement put_and conjoin append_to_form_example_5 (put 'and 'qeval conjoin) put(\"and\", \"evaluate_query\", conjoin); sets up qeval evaluate_query to dispatch to conjoin when an and form is encountered."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "Or We handle or queries similarly, as shown in figure . figure . The output streams for the various disjuncts of the or are computed separately and merged using the interleave-delayed interleave_delayed procedure function from section . (See exercises and .) disjoin operation_table_from_chapter_3 operation_table is_empty_conjunction stream_append_delayed append_to_form_example_5 (define (disjoin disjuncts frame-stream) (if (empty-disjunction? disjuncts) the-empty-stream (interleave-delayed (qeval (first-disjunct disjuncts) frame-stream) (delay (disjoin (rest-disjuncts disjuncts) frame-stream))))) (put 'or 'qeval disjoin) function disjoin(disjuncts, frame_stream) { return is_empty_disjunction(disjuncts) ? null : interleave_delayed( evaluate_query(first_disjunct(disjuncts), frame_stream), () => disjoin(rest_disjuncts(disjuncts), frame_stream)); } put(\"or\", \"evaluate_query\", disjoin);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The predicates and selectors for the syntax representation of conjuncts and disjuncts are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "Not The not syntactic form is handled by the method outlined in section . We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended. negate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream append_to_form_example_5 (define (negate operands frame-stream) (stream-flatmap (lambda (frame) (if (stream-null? (qeval (negated-query operands) (singleton-stream frame))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'not 'qeval negate) function negate(exps, frame_stream) { return stream_flatmap( frame => is_null(evaluate_query(negated_query(exps), singleton_stream(frame))) ? singleton_stream(frame) : null, frame_stream); } put(\"not\", \"evaluate_query\", negate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "Lisp-value The javascript_predicate syntactic form is a filter similar to not . Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream. An error results if there are unbound pattern variables. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using evaluate from section with the_global_environment and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation. compound_queries_5_example compound_queries_4 process_query first_answer('and(salary(person, amount), javascript_predicate(amount > 50000))'); // parse_query_verbose('and(salary(person, amount), javascript_predicate(amount > 50000))', \"verbose\"); javascript_predicate operation_table_from_chapter_3 operation_table stream_flatmap singleton_stream compound_queries_5_example (define (lisp-value call frame-stream) (stream-flatmap (lambda (frame) (if (execute (instantiate call frame (lambda (v f) (error \"Unknown pat var - - LISP-VALUE\" v)))) (singleton-stream frame) the-empty-stream)) frame-stream)) (put 'lisp-value 'qeval lisp-value) function javascript_predicate(exps, frame_stream) { return stream_flatmap( frame => evaluate(instantiate_expression( javascript_predicate_expression(exps), frame), the_global_environment) ? singleton_stream(frame) : null, frame_stream); } put(\"javascript_predicate\", \"evaluate_query\", javascript_predicate);"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Execute , which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply. However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments. Note that execute is implemented using eval and apply from the underlying Lisp system. execute functions_4_1_1 functions_4_1_2 functions_4_1_3 functions_4_1_4 is_empty_conjunction compound_queries_5_example (define (execute exp) (apply (eval (predicate exp) user-initial-environment) (args exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 14,
    "content": "The always-true special form always_true syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. Always-true is used by the rule-body selector (section ) The rule_body selector (section ) uses always_true always_true operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (always-true ignore frame-stream) frame-stream) (put 'always-true 'qeval always-true) function always_true(ignore, frame_stream) { return frame_stream; } put(\"always_true\", \"evaluate_query\", always_true); The selectors that define the syntax of not and lisp-value javascript_predicate are given in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 15,
    "content": "Find-assertions , The function find_assertions , simple-query simple_query (section ), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses fetch-assertions fetch_assertions (section ) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for fetch-assertions fetch_@assertions here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated fetch-assertions fetch_assertions and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher. find_assertions stream_flatmap check_an_assertion fetch_assertions append_to_form_example_5 (define (find-assertions pattern frame) (stream-flatmap (lambda (datum) (check-an-assertion datum pattern frame)) (fetch-assertions pattern frame))) function find_assertions(pattern, frame) { return stream_flatmap( datum => check_an_assertion(datum, pattern, frame), fetch_assertions(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 16,
    "content": "Check-an-assertion The function check_an_assertion takes as arguments a data object (assertion), (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or the-empty-stream null if the match fails. check_an_assertion pattern_match singleton_stream append_to_form_example_5 (define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result 'failed) the-empty-stream (singleton-stream match-result)))) function check_an_assertion(assertion, query_pat, query_frame) { const match_result = pattern_match(query_pat, assertion, query_frame); return match_result === \"failed\" ? null : singleton_stream(match_result); } The basic pattern matcher returns either the symbol failed string \"failed\" or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function is_variable declared in section ) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the car head of the pattern against the car head of the data to produce a frame; in this frame we then match the cdr tail of the pattern against the cdr tail of the data. If none of these cases are applicable, the match fails and we return the symbol failed . string \"failed\" . pattern_match extend_if_consistent variable append_to_form_example_5 (define (pattern-match pat dat frame) (cond ((eq? frame 'failed) 'failed) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else 'failed))) function pattern_match(pattern, data, frame) { return frame === \"failed\" ? \"failed\" : equal(pattern, data) ? frame : is_variable(pattern) ? extend_if_consistent(pattern, data, frame) : is_pair(pattern) && is_pair(data) ? pattern_match(tail(pattern), tail(data), pattern_match(head(pattern), head(data), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 17,
    "content": "Here is the procedure function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame: extend_if_consistent make_binding append_to_form_example_5 (define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame)))) function extend_if_consistent(variable, data, frame) { const binding = binding_in_frame(variable, frame); return is_undefined(binding) ? extend(variable, data, frame) : pattern_match(binding_value(binding), data, frame); } If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by extend-if-consistent , extend_if_consistent , then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section ). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which ?x $x is bound to (f ?y) list(\"f\", $y) and ?y $y is unbound, and we wish to augment this frame by a binding of ?x $x to (f b) . list(\"f\", \"b\") . We look up ?x $x and find that it is bound to (f ?y) . list(\"f\", $y) . This leads us to match (f ?y) list(\"f\", $y) against the proposed new value (f b) list(\"f\", \"b\") in the same frame. Eventually this match extends the frame by adding a binding of ?y $y to b . \"b\" . ?X The variable $x remains bound to (f ?y) . list(\"f\", $y) . We never modify a stored binding and we never store more than one binding for a given variable."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 18,
    "content": "The procedures functions used by extend-if-consistent extend_if_consistent to manipulate bindings are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 19,
    "content": "If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the . Although the pattern matcher we have just implemented doesn t look for dots, it does behave as we want. This is because the Lisp read primitive, which is used by query-driver-loop to read the query and represent it as a list structure, treats dots in a special way."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 20,
    "content": "When read sees a car of a cons whose cdr will be the rest of the list) it makes the next item be the cdr of the list structure. For example, the list structure produced by read for the pattern (computer ?type) could be constructed by evaluating the expression (cons 'computer (cons '?type '())) , and that for (computer ?type) could be constructed by evaluating the expression (cons 'computer '?type) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 21,
    "content": "Thus, as pattern-match recursively compares car s and cdr s of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a cdr of the pattern) against a sublist of the data list, binding the variable to that list. For example, matching the pattern (computer ?type) against (computer programmer trainee) will match ?type against the list (programmer trainee) ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 22,
    "content": "Apply-rules The function apply_rules is the rule analog of find-assertions find_assertions (section ). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. Stream-flatmap The function stream_flatmap maps apply-a-rule apply_a_@rule down the stream of possibly applicable rules (selected by fetch-rules , fetch_rules , section ) and combines the resulting streams of frames. apply_rules stream_flatmap apply_a_rule fetch_rules append_to_form_example_5 (define (apply-rules pattern frame) (stream-flatmap (lambda (rule) (apply-a-rule rule pattern frame)) (fetch-rules pattern frame))) function apply_rules(pattern, frame) { return stream_flatmap(rule => apply_a_rule(rule, pattern, frame), fetch_rules(pattern, frame)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 23,
    "content": "Apply-a-rule applies rules The function apply_a_rule applies a rule using the method outlined in section . It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 24,
    "content": "Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named ?x , named $x , then each one may add a binding for ?x $x to the frame when it is applied. These two ?x s $x s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise .) Here is the apply-a-rule apply_a_rule procedure: function: apply_a_rule rename_variables_in unify_match singleton_stream is_rule append_to_form_example_5 (define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result 'failed) the-empty-stream (qeval (rule-body clean-rule) (singleton-stream unify-result)))))) function apply_a_rule(rule, query_pattern, query_frame) { const clean_rule = rename_variables_in(rule); const unify_result = unify_match(query_pattern, conclusion(clean_rule), query_frame); return unify_result === \"failed\" ? null : evaluate_query(rule_body(clean_rule), singleton_stream(unify_result)); } The selectors rule-body rule_body and conclusion that extract parts of a rule are defined in section ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 25,
    "content": "We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each ?x $x in the rule to ?x-7 $x_7 and each ?y $y in the rule to ?y-7 . $y_7 . ( Make-new-variable (The functions make_new_variable and new-rule-application-id new_rule_application_id are included with the syntax procedures functions in section .) rename_variables_in is_variable_4 append_to_form_example_5 (define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule))) function rename_variables_in(rule) { const rule_application_id = new_rule_application_id(); function tree_walk(exp) { return is_variable(exp) ? make_new_variable(exp, rule_application_id) : is_pair(exp) ? pair(tree_walk(head(exp)), tree_walk(tail(exp))) : exp; } return tree_walk(rule); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 26,
    "content": "The procedure function that takes as inputs two patterns and a frame and returns either the extended frame or the symbol failed . string \"failed\" . The unifier is like the pattern matcher except that it is symmetrical variables are allowed on both sides of the match. Unify-match The function unify_match is basically the same as pattern-match , pattern_match , except that there is extra code an extra clause (marked *** below) to handle the case where the object on the right side of the match is a variable. unify_match extend_if_possible variable append_to_form_example_5 (define (unify-match p1 p2 frame) (cond ((eq? frame 'failed) 'failed) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ; *** ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else 'failed))) function unify_match(p1, p2, frame) { return frame === \"failed\" ? \"failed\" : equal(p1, p2) ? frame : is_variable(p1) ? extend_if_possible(p1, p2, frame) : is_variable(p2) // *** ? extend_if_possible(p2, p1, frame) // *** : is_pair(p1) && is_pair(p2) ? unify_match(tail(p1), tail(p2), unify_match(head(p1), head(p2), frame)) : \"failed\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 27,
    "content": "In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The procedure function extend-if-possible extend_if_possible used in unification is the same as the extend-if-consistent function extend_if_consistent used in pattern matching except for two special checks, marked *** in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 28,
    "content": "The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns (?x ?x) list($x, $x) and (?y $\\langle expression$ $involving$ ?y $\\rangle$ ) list($y, $\\langle$ expression involving $y $\\rangle$ ) in a frame where both ?x $x and ?y $y are unbound. First ?x $x is matched against ?y , $y , making a binding of ?x $x to ?y . $y . Next, the same ?x $x is matched against the given expression involving ?y . $y . Since ?x $x is already bound to ?y , $y , this results in matching ?y $y against the expression. expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ?y $y such that ?y $y is equal to the expression involving ?y . $y . There is no general method for solving such equations, so we We reject such bindings; these cases are recognized by the predicate depends-on? depends_on . (?x ?x) list($x, $x) and (?y ?y) . list($y, $y) . The second attempt to bind ?x $x to ?y $y matches ?y $y (the stored value of ?x (the stored value of $x ) against ?y $y (the new value of ?x ). (the new value of $x ). This is taken care of by the equal? equal clause of unify-match . unify_match . extend_if_possible make_binding depends_on variable append_to_form_example_5 (define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) ; *** (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) ; *** 'failed) (else (extend var val frame))))) function extend_if_possible(variable, value, frame) { const binding = binding_in_frame(variable, frame); if (! is_undefined(binding)) { return unify_match(binding_value(binding), value, frame); } else if (is_variable(value)) { // *** const binding = binding_in_frame(value, frame); return ! is_undefined(binding) ? unify_match(variable, binding_value(binding), frame) : extend(variable, value, frame); } else if (depends_on(value, variable, frame)) { // *** return \"failed\"; } else { return extend(variable, value, frame); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 29,
    "content": "Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using rational trees"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 30,
    "content": "Depends-on? The function depends_on is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of depends-on? depends_on is a simple recursive tree walk in which we substitute for the values of variables whenever necessary. depends_on variable make_binding append_to_form_example_5 (define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp)) function depends_on(expression, variable, frame) { function tree_walk(e) { if (is_variable(e)) { if (equal(variable, e)) { return true; } else { const b = binding_in_frame(e, frame); return is_undefined(b) ? false : tree_walk(binding_value(b)); } } else { return is_pair(e) ? tree_walk(head(e)) || tree_walk(tail(e)) : false; } } return tree_walk(expression); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 31,
    "content": "One important problem in designing logic programming languages is that of arranging things so that as few irrelevant Then, in addition to storing all assertions in one big stream, we store all assertions whose car s are constant symbols in separate streams, in a table indexed by the symbol. To fetch an assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol. If so, we return (to be tested using the matcher) all the stored assertions that have the same car . If the pattern s car is not a constant symbol, we return all the stored assertions. Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the car of the pattern is not a constant symbol. We avoid building our criteria for indexing (using the car , handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria. fetch_assertions get_stream index_key_of append_to_form_example_5 (define THE-ASSERTIONS the-empty-stream) (define (fetch-assertions pattern frame) (if (use-index? pattern) (get-indexed-assertions pattern) (get-all-assertions))) (define (get-all-assertions) THE-ASSERTIONS) (define (get-indexed-assertions pattern) (get-stream (index-key-of pattern) 'assertion-stream)) function fetch_assertions(pattern, frame) { return get_indexed_assertions(pattern); } function get_indexed_assertions(pattern) { return get_stream(index_key_of(pattern), \"assertion-stream\"); } Get-stream The function get_stream looks up a stream in the table and returns an empty stream if nothing is stored there. get_stream operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (get-stream key1 key2) (let ((s (get key1 key2))) (if s s the-empty-stream))) function get_stream(key1, key2) { const s = get(key1, key2); return is_undefined(s) ? null : s; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 32,
    "content": "Rules are stored similarly, using the car of the rule conclusion. Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables. A pattern whose car is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same car . Thus, when fetching rules that might match a pattern whose car is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same car as the pattern. For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ? . Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern. fetch_rules get_stream index_key_of append_to_form_example_5 (define THE-RULES the-empty-stream) (define (fetch-rules pattern frame) (if (use-index? pattern) (get-indexed-rules pattern) (get-all-rules))) (define (get-all-rules) THE-RULES) (define (get-indexed-rules pattern) (stream-append (get-stream (index-key-of pattern) 'rule-stream) (get-stream '? 'rule-stream))) function fetch_rules(pattern, frame) { return get_indexed_rules(pattern); } function get_indexed_rules(pattern) { return get_stream(index_key_of(pattern), \"rule-stream\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 33,
    "content": "Add-rule-or-assertion! The function add_rule_or_assertion is used by query-driver-loop query_driver_loop to add assertions and rules to the data base. Each item is stored in the index. add_rule_or_assertion is_rule store_assertion_in_index fetch_assertions fetch_rules append_to_form_example_5 (define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion))) (define (add-assertion! assertion) (store-assertion-in-index assertion) (let ((old-assertions THE-ASSERTIONS)) (set! THE-ASSERTIONS (cons-stream assertion old-assertions)) 'ok)) (define (add-rule! rule) (store-rule-in-index rule) (let ((old-rules THE-RULES)) (set! THE-RULES (cons-stream rule old-rules)) 'ok)) function add_rule_or_assertion(assertion) { return is_rule(assertion) ? add_rule(assertion) : add_assertion(assertion); } function add_assertion(assertion) { store_assertion_in_index(assertion); return \"ok\"; } function add_rule(rule) { store_rule_in_index(rule); return \"ok\"; }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 34,
    "content": "To actually store an assertion or a rule, we store it in the appropriate stream. store_assertion_in_index operation_table_from_chapter_3 operation_table index_key_of get_stream is_rule append_to_form_example_5 (define (store-assertion-in-index assertion) (if (indexable? assertion) (let ((key (index-key-of assertion))) (let ((current-assertion-stream (get-stream key 'assertion-stream))) (put key 'assertion-stream (cons-stream assertion current-assertion-stream)))))) (define (store-rule-in-index rule) (let ((pattern (conclusion rule))) (if (indexable? pattern) (let ((key (index-key-of pattern))) (let ((current-rule-stream (get-stream key 'rule-stream))) (put key 'rule-stream (cons-stream rule current-rule-stream))))))) function store_assertion_in_index(assertion) { const key = index_key_of(assertion); const current_assertion_stream = get_stream(key, \"assertion-stream\"); put(key, \"assertion-stream\", pair(assertion, () => current_assertion_stream)); } function store_rule_in_index(rule) { const pattern = conclusion(rule); const key = index_key_of(pattern); const current_rule_stream = get_stream(key, \"rule-stream\"); put(key, \"rule-stream\", pair(rule, () => current_rule_stream)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 35,
    "content": "The following procedures define how the data-base index is used. A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol. is_indexable variable append_to_form_example_5 (define (indexable? pat) (or (constant-symbol? (car pat)) (var? (car pat)))) The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which it starts. The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with. index_key_of variable append_to_form_example_5 (define (index-key-of pat) (let ((key (car pat))) (if (var? key) '? key))) function index_key_of(pattern) { return head(pattern); } The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol. use_index append_to_form_example_5 (define (use-index? pat) (constant-symbol? (car pat)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 36,
    "content": "The query system uses a few stream operations that were not presented in chapter ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 37,
    "content": "Stream-append-delayed The functions stream_append_delayed and interleave-delayed interleave_delayed are just like stream-append stream_append and interleave (section ), except that they take a delayed argument (like the integral procedure function in section ). This postpones looping in some cases (see exercise ). stream_append_delayed append_to_form_example_5 (define (stream-append-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (stream-append-delayed (stream-cdr s1) delayed-s2)))) (define (interleave-delayed s1 delayed-s2) (if (stream-null? s1) (force delayed-s2) (cons-stream (stream-car s1) (interleave-delayed (force delayed-s2) (delay (stream-cdr s1)))))) function stream_append_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => stream_append_delayed(stream_tail(s1), delayed_s2)); } function interleave_delayed(s1, delayed_s2) { return is_null(s1) ? delayed_s2() : pair(head(s1), () => interleave_delayed(delayed_s2(), () => stream_tail(s1))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 38,
    "content": "Stream-flatmap , The function stream_flatmap , which is used throughout the query evaluator to map a procedure function over a stream of frames and combine the resulting streams of frames, is the stream analog of the flatmap procedure function introduced for ordinary lists in section . Unlike ordinary flatmap , however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises and ). stream_flatmap stream_append_delayed append_to_form_example_5 (define (stream-flatmap proc s) (flatten-stream (stream-map proc s))) (define (flatten-stream stream) (if (stream-null? stream) the-empty-stream (interleave-delayed (stream-car stream) (delay (flatten-stream (stream-cdr stream)))))) function stream_flatmap(fun, s) { return flatten_stream(stream_map(fun, s)); } function flatten_stream(stream) { return is_null(stream) ? null : interleave_delayed( head(stream), () => flatten_stream(stream_tail(stream))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 39,
    "content": "The evaluator also uses the following simple procedure function to generate a stream consisting of a single element: singleton_stream append_to_form_example_5 (define (singleton-stream x) (cons-stream x the-empty-stream)) function singleton_stream(x) { return pair(x, () => null); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 40,
    "content": "We saw in section that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the parse function from section and also to support JavaScript notation in javascript_predicate . For example, parse('job($x, list(\"computer\", \"wizard\"));'); yields list(\"application\", list(\"name\", \"job\"), list(list(\"name\", \"$x\"), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The tag \"application\" indicates that syntactically, the query would be treated as a function application in JavaScipt. The function unparse transforms the syntax back into a string: unparse(parse('job($x, list(\"computer\", \"wizard\"));')); 'job($x, list(\"computer\", \"wizard\"))' In the query processor, we assumed a more appropriate, query-language-specific, query-language-specific representation of assertions, rules, and queries. The function convert_@to_@query_@syntax transforms the syntax representation into that representation. Using the same example, convert_to_query_syntax(parse('job($x, list(\"computer\", \"wizard\"));')); yields list(\"job\", list(\"name\", \"$x\"), list(\"computer\", \"wizard\")) Query-system functions such as add_rule_or_assertion in section and evaluate_query in section operate on the query-language-specific representation using selectors and predicates such as type , contents , is_rule , and first_conjunct declared below. Figure depicts the three parse , unparse , and convert_to_query_syntax bridge them. Syntax abstraction in the query system."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 41,
    "content": "The predicate is_variable is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. char_at that returns a string containing only the character of the given string at the given position. is_variable_2 function is_variable(exp) { return is_name(exp) && char_at(symbol_of_name(exp), 0) === \"$\"; } const is_variable = is_name;"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 42,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. is_variable_4 let rule_counter = 0; function new_rule_application_id() { rule_counter = rule_counter + 1; return rule_counter; } function make_new_variable(variable, rule_application_id) { return make_name(symbol_of_name(variable) + \"_\" + stringify(rule_application_id)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 43,
    "content": "The function convert_to_query_syntax recursively \"pair\" or \"list\" , an (untagged) JavaScript pair or list is built. This means that convert_@to_@query_@syntax interprets applications of the constructors pair and list during the transformation, and processing functions such as pattern_match of section and unify_match of section can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) argument list of javascript_predicate remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains. convert_to_query_syntax functions_4_1_2 append_to_form_example_5 function convert_to_query_syntax(exp) { if (is_application(exp)) { const function_symbol = symbol_of_name(function_expression(exp)); if (function_symbol === \"javascript_predicate\") { return pair(function_symbol, arg_expressions(exp)); } else { const processed_args = map(convert_to_query_syntax, arg_expressions(exp)); return function_symbol === \"pair\" ? pair(head(processed_args), head(tail(processed_args))) : function_symbol === \"list\" ? processed_args : pair(function_symbol, processed_args); } } else if (is_variable(exp)) { return exp; } else { // exp is literal return literal_value(exp); } }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 44,
    "content": "An exception to this processing is javascript_predicate . Since the instantiated JavaScript syntax representation of its predicate expression is passed to evaluate of section , the original syntax representation coming from parse needs to remain intact in the query-language-specific representation of the expression. In this example of section and(salary($person, $amount), javascript_predicate($amount > 50000)) convert_to_query_syntax produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation: list(\"and\", list(\"salary\", list(\"name\", \"$person\"), list(\"name\", \"$amount\")), list(\"javascript_predicate\", list(\"binary_operator_combination\", \">\", list(\"name\", \"$amount\"), list(\"literal\", 50000)))) In order to evaluate the javascript_predicate subexpression of that processed query, the function javascript_@predicate in section calls the function instantiate_@expression (below) on the embedded JavaScript syntax representation of $amount > 50000 to replace the variable list(\"name\", \"$amount\") by a literal, for example list(\"literal\", 70000) , that represents the primitive value to which $amount is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents 70000 > 50000 ."
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 45,
    "content": "The function javascript_predicate of section and the driver loop of section call instantiate_@expression on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation. instantiate make_binding variable express convert append_to_form_example_5 function instantiate_expression(expression, frame) { return is_variable(expression) ? convert(instantiate_term(expression, frame)) : is_pair(expression) ? pair(instantiate_expression(head(expression), frame), instantiate_expression(tail(expression), frame)) : expression; } The function instantiate_term takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if $x is bound to the pair $[\\texttt{\\$y}, 5]$ in a frame $f$ as the result of unification, and $y is in turn bound to 3, the result of applying instantiate_term to list(\"name\", \"$x\") and $f$ is the pair $[3, 5]$ . express function instantiate_term(term, frame) { if (is_variable(term)) { const binding = binding_in_frame(term, frame); return is_undefined(binding) ? term // leave unbound variable as is : instantiate_term(binding_value(binding), frame); } else if (is_pair(term)) { return pair(instantiate_term(head(term), frame), instantiate_term(tail(term), frame)); } else { // $\\texttt{term}$ is a primitive value return term; } } The function convert constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by instantiate_term . A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal. convert function convert(term) { return is_variable(term) ? term : is_pair(term) ? make_application(make_name(\"pair\"), list(convert(head(term)), convert(tail(term)))) : // $\\texttt{term}$ is a primitive value make_literal(term); } append_to_form_example_5 append_to_form process_query(`assert( rule(append_to_form(null, $y, $y)))`); process_query(`assert( rule(append_to_form(pair($u, $v), $y, pair($u, $z)), append_to_form($v, $y, $z)))`); process_query(`append_to_form($x, $y, list(\"a\", \"b\", \"c\", \"d\"))`); To illustrate these three functions, consider what happens when the query job($x, list(\"computer\", \"wizard\")) whose JavaScript syntax representation is given at the beginning of section , is processed by the driver loop. Let's say a frame $g$ of the result stream binds the variable $x to the pair $[\\texttt{\"Bitdiddle\"}, \\texttt{\\$y}]$ and the variable $y to the pair $[\\texttt{\"Ben\"}, \\texttt{null}]$ . Then instantiate_term(list(\"name\", \"$\\$$x\"), $g$) returns the list list(\"Bitdiddle\", \"Ben\") which convert transforms into list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))) The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame $g$ is: list(\"application\", list(\"name\", \"job\"), list(list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Bitdiddle\"), list(\"application\", list(\"name\", \"pair\"), list(list(\"literal\", \"Ben\"), list(\"literal\", null))))), list(\"application\", list(\"name\", \"list\"), list(list(\"literal\", \"computer\"), list(\"literal\", \"wizard\"))))) The driver loop unparses this representation and displays it as: 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))'"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 46,
    "content": "The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section . We describe unparse only for those kinds of expressions that appear in the examples of section , leaving statements and the remaining kinds of expressions as exercise . A literal is transformed by stringify ing its value, and a name is transformed into its unparse is_list_construction element_expressions comma_separated function unparse(exp) { return is_literal(exp) ? stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" unparsing other kinds of JavaScript components : error(exp, \"unknown syntax -- unparse\"); } function has_char(x, c) { let found = false; let i = 0; while (char_at(x, i) !== undefined) { found = found || char_at(x, i) === c; i = i + 1; } return found; } function better_stringify(x) { return is_string(x) && ! has_char(x, \"'\") ? \"'\" + x + \"'\" : stringify(x); } function unparse(exp) { return is_literal(exp) ? better_stringify(literal_value(exp)) : is_name(exp) ? symbol_of_name(exp) : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) : is_application(exp) && is_name(function_expression(exp)) ? symbol_of_name(function_expression(exp)) + \"(\" + comma_separated(map(unparse, arg_expressions(exp))) + \")\" : is_binary_operator_combination(exp) ? \"(\" + unparse(first_operand(exp)) + \" \" + operator_symbol(exp) + \" \" + unparse(second_operand(exp)) + \")\" : error(exp, \"unknown syntax -- unparse\"); } comma_separated function comma_separated(strings) { return accumulate((s, acc) => s + (acc === \"\" ? \"\" : \", \" + acc), \"\", strings); } The function unparse would work fine without the clause : is_list_construction(exp) ? unparse(make_application(make_name(\"list\"), element_expressions(exp))) but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query job($x, list(\"computer\", \"wizard\")) yields a frame that binds $x to $[\\texttt{\"Bitdiddle\"}, [\\texttt{\"Ben\"}, \\texttt{null}]]$ , unparse produces 'job(list(\"Bitdiddle\", \"Ben\"), list(\"computer\", \"wizard\"))' However, without the clause it would produce 'job(pair(\"Bitdiddle\", pair(\"Ben\", null)), list(\"computer\", \"wizard\"))' which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section , we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of list to the list of element expressions that we extract from the expression. A list construction is the literal null or an application of pair whose second argument is itself a list construction. is_list_construction function is_list_construction(exp) { return (is_literal(exp) && is_null(literal_value(exp))) || (is_application(exp) && is_name(function_expression(exp)) && symbol_of_name(function_expression(exp)) === \"pair\" && is_list_construction(head(tail(arg_expressions(exp))))); } Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of pair until the literal null is reached. element_expressions function element_expressions(list_constr) { return is_literal(list_constr) ? null // $\\texttt{list\\char`_constr}$ is literal $\\texttt{null}$ : // $\\texttt{list\\char`_constr}$ is application of $\\texttt{pair}$ pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); } function element_expressions(list_constr) { return is_literal(list_constr) ? null // list_constr is literal null : // list_constr is application of pair pair(head(arg_expressions(list_constr)), element_expressions( head(tail(arg_expressions(list_constr))))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 47,
    "content": "The functions type and contents , used by evaluate_query (section ), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the type_tag and contents functions in section , except for the error message. type append_to_form_example_5 functions_4_1_2 function type(exp) { return is_pair(exp) ? head(exp) : error(exp, \"unknown expression type\"); } function contents(exp) { return is_pair(exp) ? tail(exp) : error(exp, \"unknown expression contents\"); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 48,
    "content": "The following functions, used by query_driver_loop (in section ), specify that rules and assertions are added to the data base by an assert command, which the function convert_to_query_syntax transforms into a pair of the form [\"assert\", rule-or-assertion ] : is_assertion type append_to_form_example_5 function is_assertion(exp) { return type(exp) === \"assert\"; } function assertion_body(exp) { return head(contents(exp)); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 49,
    "content": "Here are the declarations of the predicates and selectors for the and , or , not , and javascript_predicate syntactic forms (section ): is_empty_conjunction append_to_form_example_5 function is_empty_conjunction(exps) { return is_null(exps); } function first_conjunct(exps) { return head(exps); } function rest_conjuncts(exps) { return tail(exps); } function is_empty_disjunction(exps) { return is_null(exps); } function first_disjunct(exps) { return head(exps); } function rest_disjuncts(exps) { return tail(exps); } function negated_query(exps) { return head(exps); } function javascript_predicate_expression(exps) { return head(exps); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 50,
    "content": "The following three functions define the query-language-specific representation of rules: is_rule functions_4_1_2 append_to_form_example_5 function is_rule(assertion) { return is_tagged_list(assertion, \"rule\"); } function conclusion(rule) { return head(tail(rule)); } function rule_body(rule) { return is_null(tail(tail(rule))) ? list(\"always_true\") : head(tail(tail(rule))); }"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 51,
    "content": "Type and contents , used by qeval (section ), specify that a special form is identified by the symbol in its car . They are the same as the type-tag and contents procedures in section , except for the error message. type_scheme append_to_form_example_5 functions_4_1_2 (define (type exp) (if (pair? exp) (car exp) (error \"Unknown expression TYPE\" exp))) (define (contents exp) (if (pair? exp) (cdr exp) (error \"Unknown expression CONTENTS\" exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 52,
    "content": "The following procedures, used by query-driver-loop (in section ), specify that rules and assertions are added to the data base by expressions of the form (assert! rule-or-assertion) : is_assertion_scheme type append_to_form_example_5 (define (assertion-to-be-added? exp) (eq? (type exp) 'assert!)) (define (add-assertion-body exp) (car (contents exp)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 53,
    "content": "Here are the syntax definitions for the and , or , not , and lisp-value special forms (section ): is_empty_conjunction_scheme append_to_form_example_5 (define (empty-conjunction? exps) (null? exps)) (define (first-conjunct exps) (car exps)) (define (rest-conjuncts exps) (cdr exps)) (define (empty-disjunction? exps) (null? exps)) (define (first-disjunct exps) (car exps)) (define (rest-disjuncts exps) (cdr exps)) (define (negated-query exps) (car exps)) (define (predicate exps) (car exps)) (define (args exps) (cdr exps))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 54,
    "content": "The following three procedures define the syntax of rules: is_rule_scheme functions_4_1_2 append_to_form_example_5 (define (rule? statement) (tagged-list? statement 'rule)) (define (conclusion rule) (cadr rule)) (define (rule-body rule) (if (null? (cddr rule)) '(always-true) (caddr rule)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 55,
    "content": "Query-driver-loop (section ) calls query-syntax-process to transform pattern variables in the expression, which have the form ?symbol , into the internal format (? symbol) . That is to say, a pattern such as (job ?x ?y) is actually represented internally by the system as (job (? x) (? y)) . This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the car of the expression is the symbol ? , rather than having to extract characters from the symbol. The syntax transformation is accomplished by the following procedure: query_process_scheme (define (query-syntax-process exp) (map-over-symbols expand-question-mark exp)) (define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp))) (define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) \"?\") (list '? (string->symbol (substring chars 1 (string-length chars)))) symbol)))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 56,
    "content": "Once the variables are transformed in this way, the variables in a pattern are lists starting with ? , and the constant symbols (which need to be recognized for data-base indexing, section ) are just the symbols. is_var_scheme functions_4_1_2 append_to_form_example_5 (define (var? exp) (tagged-list? exp '?)) (define (constant-symbol? exp) (symbol? exp))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 57,
    "content": "Unique variables are constructed during rule application (in section ) by means of the following procedures. The unique identifier for a rule application is a number, which is incremented each time a rule is applied. new_rule_application_id append_to_form_example_5 (define rule-counter 0) (define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter) (define (make-new-variable var rule-application-id) (cons '? (cons rule-application-id (cdr var))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 58,
    "content": "When query-driver-loop instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using contract_question_mark_scheme (define (contract-question-mark variable) (string->symbol (string-append \"?\" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) \"-\" (number->string (cadr variable))) (symbol->string (cadr variable))))))"
  },
  {
    "source_file": "subsection4.xml",
    "tag_type": "SUBSECTION",
    "title": "Implementing the Query System",
    "parent_title": "Logic Programming",
    "depth": 2,
    "paragraph_index": 59,
    "content": "Frames are represented as lists of bindings, which are variable-value pairs: make_binding operation_table_from_chapter_3 operation_table append_to_form_example_5 (define (make-binding variable value) (cons variable value)) (define (binding-variable binding) (car binding)) (define (binding-value binding) (cdr binding)) (define (binding-in-frame variable frame) (assoc variable frame)) (define (extend variable value frame) (cons (make-binding variable value) frame)) function make_binding(variable, value) { return pair(variable, value); } function binding_variable(binding) { return head(binding); } function binding_value(binding) { return tail(binding); } function binding_in_frame(variable, frame) { return assoc(variable, frame); } function extend(variable, value, frame) { return pair(make_binding(variable, value), frame); }"
  }
]