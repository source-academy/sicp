[{"id":"/sicpjs/4.3","tag":"TITLE","body":"4.3  \n    \n      \n    \n    Nondeterministic Computing"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In this section, we extend the\n    JavaScript\n    evaluator to support a\n    programming paradigm called ","tag":"#text"},{"tag":"EM","child":[{"body":"nondeterministic computing","tag":"#text"}]},{"body":" by\n    building into the evaluator a facility to support\n    \n    automatic search.\n    This is a much more profound change to the language than the\n    introduction of lazy evaluation in\n    section ","tag":"#text"},{"tag":"REF","body":"4.2","href":"/sicpjs/4.2"},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Nondeterministic computing, like stream processing, is useful for\n    \"","tag":"#text"},{"body":"generate and test","tag":"#text"},{"body":"\" applications.  Consider the task of\n    starting with two lists of positive integers and finding a pair of\n    integers—one from the first list and one from the second\n    list—whose sum is prime. We saw how to handle this with finite\n    sequence operations in section ","tag":"#text"},{"tag":"REF","body":"2.2.3","href":"/sicpjs/2.2.3"},{"body":" and\n    with infinite streams in section ","tag":"#text"},{"tag":"REF","body":"3.5.3","href":"/sicpjs/3.5.3"},{"body":".\n    Our approach was to generate the sequence of all possible pairs and filter\n    these to select the pairs whose sum is prime.  Whether we actually generate\n    the entire sequence of pairs first as in chapter ","tag":"#text"},{"tag":"REF","body":"2","href":"/sicpjs/2"},{"body":", or interleave the\n    generating and filtering as in chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":", is immaterial to the\n    essential image of how the computation is organized.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    The nondeterministic approach evokes a different image.  Imagine simply\n    that we choose (in some way) a number from the first list and a number\n    from the second list and require (using some mechanism) that their\n    \n    sum be prime.  This is expressed by the following\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":27,"program":"chap=3&variant=non-det&prgrm=PTAEGUEkGEAVQFLlAFgHQGYBQWBmBXAOwGMAXASwHtDQBnAR3wEMAnAUwAoAPASlAG8soYaHal8LGl1AAqUFwDcWAL44CJCtVDlaAfQAm5AG47yAIwA2nLgBpQATz79RbcZPmgApA9ABef6AADAqgqnhEZFQ05ISkbADmbCx6tKSsFITxurgslAC2HIROQiJiEjQADkzkLIV2HHy+AHzasQlJKWksGVk5+YWgANSgAIw8PEph6pFaOroVLOR5nEUCJcLTmtFxtRW0xSKHLm40DMzsHAAWbEz6HHvjoC2E60dvoAD8oKQs+Gyv70OAC5tHpDCZaOYrHVQNdbvd9jwAYDhF9cEwLLR-ii3iDyDsOKl2Ew8ro0uQLAjxkpDqpDmV3PikvdFst9pMsMRqKlQAslmxaH5edVagAmGzInGHBp+FpEm6k3AUgmSqVquZ85Z2VVqnExOKJZK6VLpGK9XIFDDjHU4iZqCJbXmstjG-Ckqo1DgWHSkEZ2b2pUVOQ6vLmEHlMIVMQi6NhWZaxXSUXBen1jGkiMM8sxRmNxtgJ0hJlMB0hBjPCdiMGqcDXOjiR4ZmamvBk0UsNuzNjlYTUu2hu+Yi1OpDh+0AYOwAVjsAA4eP6fRxRYE7BgZ6MRoEWyBQLB2LRBQAiABKRCPoFwlBY32ul5qPNolAs+C2aFAABV7BV-ruxCx7CwXcYlvNhQBPABRWAABlQC0Ug70WeJLlIOwrxvPJrzAp8Xy2WggA","body":"function prime_sum_pair(list1, list2) {    \n    const a = an_element_of(list1);\n    const b = an_element_of(list2);\n    require(is_prime(a + b));\n    return list(a, b);\n} "},{"body":"\n    It might seem as if this\n    function\n    merely restates the problem,\n    rather than specifying a way to solve it.  Nevertheless, this is a\n    legitimate nondeterministic program.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/4.3#footnote-1"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    The key idea here is that\n    components\n    in a nondeterministic language\n    can have more than one possible value.  For instance,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"an_element_of"},{"body":"\n    might return any element of the given list.  Our nondeterministic program\n    evaluator will work by automatically choosing a possible value and keeping\n    track of the choice.  If a subsequent requirement is not met, the evaluator\n    will try a different choice, and it will keep trying new choices until the\n    evaluation succeeds, or until we run out of choices.  Just as the lazy\n    evaluator freed the programmer from the details of how values are delayed\n    and forced, the nondeterministic program evaluator will free the programmer\n    from the details of how choices are made.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    It is instructive to contrast the different images of\n    \n    time evoked by\n    nondeterministic evaluation and stream processing.  Stream processing\n    uses lazy evaluation to decouple the time when the stream of possible\n    answers is assembled from the time when the actual stream elements are\n    produced.  The evaluator supports the illusion that all the possible\n    answers are laid out before us in a timeless sequence.  With\n    nondeterministic evaluation,\n    a component\n    represents the exploration\n    of a set of possible worlds, each determined by a set of choices.\n    Some of the possible worlds lead to dead ends, while others have\n    useful values.  The nondeterministic program evaluator supports the\n    illusion that time branches, and that our programs have different\n    possible execution histories.  When we reach a dead end, we can\n    revisit a previous choice point and proceed along a different branch.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    The nondeterministic program evaluator implemented below is called the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"amb"},{"body":" evaluator because it is based on \n    a new syntactic form\n    called ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"amb"},{"body":".  We can type the above\n    declaration\n    of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"prime_sum_pair"},{"body":"\n    at the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"amb"},{"body":" evaluator driver loop (along with\n    declarations\n    of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_prime"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"an_element_of"},{"body":",\n      \n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"require"},{"body":") and run the\n    function\n    as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"body":"prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110)); ","prependLength":34,"program":"chap=3&variant=non-det&prgrm=PTAEGUEkGEAVQFLlAFgHQGYBQWBmBXAOwGMAXASwHtDQBnAR3wEMAnAUwAoAPASlAG8soYaHal8LGl1AAqUFwDcWAL44CJCtVDlaAfQAm5AG47yAIwA2nLgBpQATz79RbcZPmgApA9ABef6AADAqgqnhEZFQ05ISkbADmbCx6tKSsFITxurgslAC2HIROQiJiEjQADkzkLIV2HHy+AHzasQlJKWksGVk5+YWgANSgAIw8PEph6pFaOroVLOR5nEUCJcLTmtFxtRW0xSKHLm40DMzsHAAWbEz6HHvjoC2E60dvoAD8oKQs+Gyv70OAC5tHpDCZaOYrHVQNdbvd9jwAYDhF9cEwLLR-ii3iDyDsOKl2Ew8ro0uQLAjxkpDqpDmV3PikvdFst9pMsMRqKlQAslmxaH5edVagAmGzInGHBp+FpEm6k3AUgmSqVquZ85Z2VVqnExOKJZK6VLpGK9XIFDDjHU4iZqCJbXmstjG-Ckqo1DgWHSkEZ2b2pUVOQ6vLmEHlMIVMQi6NhWZaxXSUXBen1jGkiMM8sxRmNxtgJ0hJlMB0hBjPCdiMGqcDXOjiR4ZmamvBk0UsNuzNjlYTUu2hu+Yi1OpDh+0AYOwAVjsAA4eP6fRxRYE7BgZ6MRoEWyBQLB2LRBQAiABKRCPoFwlBY32ul5qPNolAs+C2aFAABV7BV-ruxCx7CwXcYlvNhQBPABRWAABlQC0Ug70WeJLlIOwrxvPJrzAp8Xy2WggA","output":"Starting a new problem\namb-evaluate value:\n[3, [20, null]]"},{"body":"\n    The value returned was obtained after the evaluator repeatedly chose\n    elements from each of the lists, until a successful choice was made.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    Section ","tag":"#text"},{"tag":"REF","body":"4.3.1","href":"/sicpjs/4.3.1"},{"body":" introduces\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"amb"},{"body":" and explains how it supports nondeterminism\n    through the evaluator's automatic search mechanism.\n    Section ","tag":"#text"},{"tag":"REF","body":"4.3.2","href":"/sicpjs/4.3.2"},{"body":" presents examples of\n    nondeterministic programs, and\n    section ","tag":"#text"},{"tag":"REF","body":"4.3.3","href":"/sicpjs/4.3.3"},{"body":" gives the details of how\n    to implement the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"amb"},{"body":" evaluator by modifying the\n    ordinary\n    JavaScript\n    evaluator.\n  ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/4.3#footnote-link-1","child":[{"body":"We assume that we have\n    previously defined a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_prime"},{"body":"\n    that tests whether numbers are prime.  Even with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_prime"},{"body":"\n    defined, the \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"prime_sum_pair"},{"body":"function\n    may look suspiciously like the unhelpful\n    \"","tag":"#text"},{"body":"pseudo-JavaScript","tag":"#text"},{"body":"\"\n    attempt to define the square-root function, which we described at the\n    beginning of section ","tag":"#text"},{"tag":"REF","body":"1.1.7","href":"/sicpjs/1.1.7"},{"body":".  In fact, a square-root\n    function\n    along those lines can actually be formulated as a nondeterministic program.\n    By incorporating a search mechanism into the evaluator, we are eroding the \n    \n    distinction between purely declarative descriptions and imperative\n    specifications of how to compute answers.  We'll go even farther in\n    this direction in\n    section ","tag":"#text"},{"tag":"REF","body":"4.4","href":"/sicpjs/4.4"},{"body":".","tag":"#text"}]}]