<SUBSECTION> 
   <NAME>
    数字电路模拟器
  </NAME> 

  <LABEL NAME="sec:circuit-simulator"></LABEL>
   <INDEX>数字电路模拟<OPEN></OPEN></INDEX> 

   <TEXT>
    设计复杂的数字系统，例如计算机，是一项重要的工程活动。 数字系统通过连接简单元素构建。 尽管这些单个元素的行为很简单，但它们的网络可以表现出非常复杂的行为。 对拟议电路设计进行计算机模拟是数字系统工程师使用的重要工具。 在本节中，我们设计了一个用于执行数字逻辑模拟的系统。 该系统是称为<INDEX>事件驱动模拟</INDEX><INDEX>模拟<SUBINDEX>事件驱动</SUBINDEX></INDEX><EM>事件驱动模拟</EM>的程序类型的典型代表，其中的动作 (<QUOTE>事件</QUOTE>) 触发稍后发生的更多事件，进而触发更多事件，以此类推。
  </TEXT> 

  <TEXT> 
    我们的电路计算模型将由对象组成，这些对象对应于构建该电路的基本组件。 有 
<INDEX> 导线 (在数字电路中) </INDEX>
    <EM> 导线 </EM> ，其承载 <INDEX> 信号 (数字) </INDEX>
    <INDEX> 数字信号 </INDEX>
    <EM> 数字信号 </EM> 。 一个 <SPACE></SPACE> 数字信号在任何时候只能有两个可能的值之一，0 和 1。 还有各种类型的数字 <INDEX> 函数盒 (在数字电路中) </INDEX>
    <EM> 函数盒 </EM> ，其连接承载输入信号的导线到其他输出导线。 这些盒子产生的输出信号是从其输入信号计算得出的。 输出信号是 <INDEX> <ORDER>延迟</ORDER>延迟 (在数字电路中) </INDEX> 
    由函数盒的类型决定的时间延迟。 例如，一个
<INDEX> 反相器 </INDEX>
    <EM> 反相器 </EM> 
    是一个
    原语函数盒，其输入反转。 如果输入信号变为反相器的输入信号改变为0，那么一个 
<EM> 
    是一个反相器，其输入反转。 如果
    输入信号变为0，
</EM> 
    稍后反相器将把其输出信号改变为 1。 如果反相器的输入信号变为 1，那么一个
<EM> 反相器延迟 </EM> 
    稍后反相器将改变其输出信号为 0。 我们以图形象征性地绘制一个反相器
<SPACE></SPACE><REF NAME="fig:logic-gates"></REF> 。 一个 
<INDEX> 与门 </INDEX>
    <EM> 与门 </EM> ，
    也如图所示 
<SPACE></SPACE><REF NAME="fig:logic-gates"></REF> ，是一个原语
    函数盒，具有两个输入和一个输出。 它将其输出信号驱动到一个
<INDEX> 逻辑与 (数字逻辑) </INDEX>
    <EM> 逻辑与 </EM> 
    输入的。 也就是说，如果
    两个输入信号都变为
<SPACE></SPACE> 1，那么一个 <EM> 与门延迟 </EM> 
    时间
    之后，与门将强制其输出信号变为 1；否则输出将为 0。 一个
<INDEX> 或门 </INDEX>
    <EM> 或门 </EM> 
    是一个类似的二输入原语函数
    盒，将其输出信号驱动到一个
 <INDEX>逻辑或 (数字逻辑)</INDEX>
    <EM>逻辑或</EM> 的输入。 也就是说，如果至少一个输入信号为 1，则输出将变为 1；否则输出将变为<SPACE></SPACE>0。
   </TEXT>

     <FIGURE>
      <FIGURE SRC="img_original/ch3-Z-G-24.svg"></FIGURE>
      <CAPTION>数字逻辑模拟器中的原语函数。
      </CAPTION>
      
    </FIGURE> 

   <TEXT>
    我们可以将原语函数连接在一起以构建更复杂的函数。 为此，我们将一些
    函数盒的输出连接到其他函数盒的输入。 例如，
    <INDEX>半加器</INDEX>
    <INDEX>加法器<SUBINDEX>半</SUBINDEX></INDEX>
    <EM>半加器</EM>电路如图
    <SPACE></SPACE><REF NAME="fig:half-adder"></REF> 所示，由一个
    或门、两个与门和一个反相器组成。 它接受两个输入信号，
    $A$ 和 $B$，并有
    两个输出信号，$S$ 和 $C$。
    当<EM>且仅当</EM>$A$ 和 $B$
    中正好有一个为<SPACE></SPACE>1 时，$S$ 将变为 1，
    当<EM>且仅当</EM>$A$ 和 $B$ 都为 1 时，$C$ 将变为 1。 从图中我们可以看到，由于涉及的
    延迟，输出可能在不同时间产生。
    数字电路设计中的许多困难源于这一事实。
    <FIGURE>
      <FIGURE SPLIT_SCALE="0.5" WEB_SCALE="0.8" SRC="img_original/ch3-Z-G-25.svg"></FIGURE>
      <CAPTION>半加器电路。
      </CAPTION>
      
    </FIGURE>
  </TEXT> 

   <TEXT>
    现在我们将构建一个程序来对我们希望研究的数字逻辑电路进行建模。 该程序将构造计算对象以模拟导线，这些对象将<QUOTE>保持</QUOTE>信号。 函数
    盒将由
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    模拟，以确保信号之间的正确关系。
  </TEXT> 

  <TEXT> 
    我们模拟的一个基本元素将是一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>make_wire</USE></INDEX> 
    <SPLITINLINE>
      make-wire,
      <JAVASCRIPT><JAVASCRIPTINLINE>make_wire</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    其用于创建导线。例如，我们可以如下创建六根导线：
<SNIPPET>
      <NAME>make_wire_usage</NAME>
      <REQUIRES>make_wire</REQUIRES>
      <SCHEME>
(define a (make-wire))
(define b (make-wire))
(define c (make-wire))
(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
      </SCHEME>
      <JAVASCRIPT>
const a = make_wire();
const b = make_wire();
const c = make_wire();
const d = make_wire();
const e = make_wire();
const s = make_wire();
      </JAVASCRIPT>
    </SNIPPET> 
    我们通过调用一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    将函数盒附加到一组导线上，该函数构造该类型的盒子。 构造函数的
    参数
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    是要附加到盒子的导线。 例如，给定
    我们可以构造与门、或门和反相器，我们可以将
    <SPACE></SPACE><REF NAME="fig:half-adder"></REF>中显示的半加器连接在一起：
<SNIPPET>
      <NAME>or_gate_example</NAME>
      <REQUIRES>or_gate</REQUIRES>
      <REQUIRES>make_wire_usage</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(or-gate a b d)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
or_gate(a, b, d);   
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>and_gate_example</NAME>
      <REQUIRES>and_gate</REQUIRES>
      <REQUIRES>make_wire_usage</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(and-gate a b c)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
and_gate(a, b, c);  
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>inverter_example</NAME>
      <REQUIRES>inverter</REQUIRES>
      <REQUIRES>make_wire_usage</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(inverter c e)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
inverter(c, e);     
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>and_gate_example_2</NAME>
      <REQUIRES>and_gate</REQUIRES>
      <REQUIRES>make_wire_usage</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(and-gate d e s)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
and_gate(d, e, s);  
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>

  <TEXT> 
    更好的是，我们可以通过定义一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      half-adder
      <JAVASCRIPT><JAVASCRIPTINLINE>half_@adder</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    显式地命名此操作，该函数构建此电路，给定要附加到半加器的四个外部导线：
<SNIPPET HIDE="yes">
      <NAME>half_adder_example</NAME>
      <REQUIRES>half_adder</REQUIRES>
      <JAVASCRIPT>
const a = make_wire();
const b = make_wire();
const s = make_wire();	
const c = make_wire();
half_adder(a, b, s, c);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX>half-adder<SUBINDEX><DECLARATION>half_adder</DECLARATION></SUBINDEX></INDEX>
      <NAME>half_adder</NAME>
      <REQUIRES>make_wire</REQUIRES>
      <REQUIRES>or_gate</REQUIRES>
      <REQUIRES>and_gate</REQUIRES>
      <REQUIRES>inverter</REQUIRES>
      <EXAMPLE>half_adder_example</EXAMPLE>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    &apos;ok))
      </SCHEME>
      <JAVASCRIPT>
function half_adder(a, b, s, c) {
    const d = make_wire();
    const e = make_wire();
    or_gate(a, b, d);
    and_gate(a, b, c);
    inverter(c, e);
    and_gate(d, e, s);
    return &quot;ok&quot;;
}
      </JAVASCRIPT>
    </SNIPPET> 
    定义这个操作的好处是我们可以使用 
    <SPLITINLINE>
    half-adder
    <JAVASCRIPT><JAVASCRIPTINLINE>half_adder</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    本身作为构建块来创建更复杂的
    电路。 例如，图<SPACE></SPACE><REF NAME="fig:full-adder"></REF>显示了一个
    <INDEX>全加器</INDEX>
    <INDEX>加法器<SUBINDEX>全</SUBINDEX></INDEX>
    <EM>全加器</EM>由两个半加器和一个或门组成。<FOOTNOTE>
      全加器是用于加两个二进制数字的基本电路元素。 这里 $A$ 和 $B$
      是两个数中对应位置的位，$C_{\mathit{in}}$ 是
      从右边一位的加法进位位。 该电路生成
      $\mathit{SUM}$，即对应位置的和位，以及
      $C_{\mathit{out}}$，即
      需要向左传播的进位位。</FOOTNOTE> 我们可以如下构建一个
      全加器：
<SNIPPET HIDE="yes">
      <NAME>full_adder_example</NAME>
      <REQUIRES>full_adder</REQUIRES>
      <JAVASCRIPT>
const a     = make_wire();
const b     = make_wire();
const c_in  = make_wire();
const sum   = make_wire();	
const c_out = make_wire();
full_adder(a, b, c_in, sum, c_out);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX>full-adder<SUBINDEX><DECLARATION>full_adder</DECLARATION></SUBINDEX></INDEX>
      <NAME>full_adder</NAME>
      <REQUIRES>make_wire</REQUIRES>
      <REQUIRES>half_adder</REQUIRES>
      <REQUIRES>or_gate</REQUIRES>
      <EXAMPLE>full_adder_example</EXAMPLE>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    &apos;ok))
      </SCHEME>
      <JAVASCRIPT>
function full_adder(a, b, c_in, sum, c_out) {
    const s = make_wire();
    const c1 = make_wire();
    const c2 = make_wire();
    half_adder(b, c_in, s, c1);
    half_adder(a, s, sum, c2);
    or_gate(c1, c2, c_out);
    return &quot;ok&quot;;
}
      </JAVASCRIPT>
    </SNIPPET> 
    已经定义了
    <SPLITINLINE>
    full-adder
    <JAVASCRIPT><JAVASCRIPTINLINE>full_adder</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    作为一个
    <SPLITINLINE>
      过程,
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    我们现在可以将其用作构建块来创建更复杂的
    电路。 （例如，请参见练习<SPACE></SPACE><REF NAME="ex:ripple-carry"></REF>。）
  <WEB_ONLY>
    &lt;!--   图形因 SICP JS 分页而移动   --&gt;
    &lt;!--   图形代码在该文件后文的 PDF_ONLY 中重复   --&gt;
    <FIGURE>
      <FIGURE SPLIT_SCALE="0.5" WEB_SCALE="0.8" SRC="img_original/ch3-Z-G-26.svg"></FIGURE>
      <CAPTION>全加器电路。
      </CAPTION>
      
    </FIGURE>
  </WEB_ONLY>
   </TEXT>

   <TEXT>
    从本质上讲，我们的模拟器为我们提供了构造
    电路语言的工具。 如果我们采用我们在
    <SPLITINLINE>
      Lisp
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    中研究语言的总体视角，如章节<SPACE></SPACE><REF NAME="sec:elements-of-programming"></REF>所述，
    我们可以说原语函数盒构成了语言的基本
    元素，将盒子连接在一起提供了一种
    组合的方法，而将布线模式指定为
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    则作为一种抽象的方法。
  </TEXT> 

   <SUBHEADING> 
    <NAME>原语函数盒</NAME>
  </SUBHEADING> 


  <TEXT> <TEXT>
    原语函数盒
    <INDEX>数字电路模拟<SUBINDEX>原语函数盒<OPEN></OPEN></SUBINDEX></INDEX>
    实现了<QUOTE>作用力</QUOTE>，使得一个导线信号的变化影响其他
    导线上的信号。 为了构建函数盒，我们使用以下导线操作：
</TEXT> <UL>
      <LI>
	<SPLITINLINE>
	  (get-signal wire):
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>get_signal(</JAVASCRIPTINLINE><META>wire</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	<INDEX><USE>get_signal</USE></INDEX> 
	<BR></BR>
	返回导线上信号的当前值。
      </LI>
      <LI>
        <SPLITINLINE>
	  (set-signal! wire new-value):
	  
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>set_signal(</JAVASCRIPTINLINE><META>wire</META><JAVASCRIPTINLINE>,</JAVASCRIPTINLINE> <META>new-value</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>:
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>set_signal</USE></INDEX> 
	<BR></BR>
	将导线上信号的值更改为新值。
      </LI>
      <LI>
        <SPLITINLINE>
	  
	    (add-action! wire procedure-of-no-arguments):
	  
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>add_action(</JAVASCRIPTINLINE><META>wire</META><JAVASCRIPTINLINE>,</JAVASCRIPTINLINE> <META>function-of-no-arguments</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>:
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>add_action</USE></INDEX> 
	<BR></BR>
	声明指定的
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	应该在导线上的信号值改变时运行。这样
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	便是将导线信号值的变化传递到其他导线的方式。
      </LI>
    </UL>
    此外，我们将使用一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>after_delay</USE></INDEX> 
 <SPLITINLINE>
      
	after-delay
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>after_delay</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    接受一个时间延迟和一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    来执行，并在指定的
    时间延迟后执行给定的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>【4:4†cn.txt】。
</TEXT>

  <TEXT> 
    使用这些
    <SPLITINLINE>
      过程,
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    我们可以定义原语数字逻辑函数。 要通过反相器将输入连接到输出，我们使用
    <SPLITINLINE>
      add-action!
      <JAVASCRIPT><JAVASCRIPTINLINE>add_action</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    以将一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    与输入导线相关联，该函数将在输入导线的信号值变化时运行。
    该
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    计算输入信号的
    <SPLITINLINE>
      逻辑非
      <JAVASCRIPT><JAVASCRIPTINLINE>logical_not</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    ，然后在一个
    <SPLITINLINE>
      反相器延迟
      <JAVASCRIPT><JAVASCRIPTINLINE>inverter_delay</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    之后，将输出信号设置为此新值：
<SNIPPET>
      <INDEX>inverter<SUBINDEX><DECLARATION>inverter</DECLARATION></SUBINDEX></INDEX>
      <INDEX><DECLARATION>logical_not</DECLARATION></INDEX> 
      <NAME>inverter</NAME>
      <REQUIRES>get_signal</REQUIRES>
      <REQUIRES>after_delay</REQUIRES>
      <EXAMPLE>inverter_example</EXAMPLE>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input)
  &apos;ok)
                
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error &quot;Invalid signal&quot; s))))
      </SCHEME>
      <JAVASCRIPT>
function inverter(input, output) {
    function invert_input() {
        const new_value = logical_not(get_signal(input));
        after_delay(inverter_delay, 
                    () =&gt; set_signal(output, new_value));
    }
    add_action(input, invert_input);
    return &quot;ok&quot;;
}
function logical_not(s) {
    return s === 0
           ? 1
           : s === 1
           ? 0
           : error(s, &quot;invalid signal&quot;);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SNIPPET HIDE="yes">
    <NAME>logical_and</NAME>
    <JAVASCRIPT>
function logical_and(s1, s2) {
    return s1 === 1 &amp;&amp; s2 === 1
           ? 1
           : s1 === 0 || s1 === 1
           ? s2 === 0 || s2 === 1
             ? 0
             : error(s2, &quot;invalid signal&quot;)
           : error(s1, &quot;invalid signal&quot;);
}
    </JAVASCRIPT>
  </SNIPPET>
   <PDF_ONLY>
    &lt;!--  图形因 SICP JS 分页而移动  --&gt;
    &lt;!--  图形代码是该文件之前 WEB_ONLY 中代码的副本  --&gt;
    <FIGURE>
      <FIGURE SPLIT_SCALE="0.5" WEB_SCALE="0.8" SRC="img_original/ch3-Z-G-26.svg"></FIGURE>
      <CAPTION>全加器电路。
      </CAPTION>
      
    </FIGURE>
  </PDF_ONLY>


  <TEXT> 
    与门稍微复杂些。 操作
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    必须在门的任一输入发生变化时运行。它计算输入导线信号值的
    <SPLITINLINE>
      逻辑与
      （使用类似于
      逻辑非的过程）
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>logical_and</JAVASCRIPTINLINE>
	（使用类似于
	<JAVASCRIPTINLINE>logical_not</JAVASCRIPTINLINE>的函数）
      </JAVASCRIPT>
    </SPLITINLINE>
    ，并在一个
    <SPLITINLINE>
      与门延迟
      <JAVASCRIPT><JAVASCRIPTINLINE>and_gate_delay</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    之后，将新值出现在输出导线上。【192:6†cn.txt】
<SNIPPET POSTPADDING="no">
      <INDEX>and-gate<SUBINDEX><DECLARATION>and_gate</DECLARATION></SUBINDEX></INDEX>
      <NAME>and_gate</NAME>
      <REQUIRES>get_signal</REQUIRES>
      <REQUIRES>after_delay</REQUIRES>
      <REQUIRES>logical_and</REQUIRES>
      <EXAMPLE>and_gate_example</EXAMPLE>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
          (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  &apos;ok)
      </SCHEME>
      <JAVASCRIPT>
function and_gate(a1, a2, output) {
    function and_action_function() {
        const new_value = logical_and(get_signal(a1),
                                      get_signal(a2));
        after_delay(and_gate_delay, 
                    () =&gt; set_signal(output, new_value));
    }
    add_action(a1, and_action_function);
    add_action(a2, and_action_function);
    return &quot;ok&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

   <EXERCISE>
    定义一个
    <INDEX>or-gate<SUBINDEX><ORDER>或门</ORDER><SPLITINLINE>or-gate<JAVASCRIPT><JAVASCRIPTINLINE>or_gate</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    或门作为一个原语函数盒。 你的
    <SPLITINLINE>
      or-gate
      <JAVASCRIPT><JAVASCRIPTINLINE>or_gate</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    构造器应与
    <SPLITINLINE>
      and-gate.
      <JAVASCRIPT><JAVASCRIPTINLINE>and_gate</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    类似。
    
    <SOLUTION>
      
	<NAME>logical_or</NAME>
	<JAVASCRIPT>
// 由 GitHub 用户 clean99 提供

function logical_or(s1, s2) {
    return s1 === 0 &amp;&amp; s2 === 0
           ? 0
           : s1 === 0 || s1 === 1
           ? s2 === 0 || s2 === 1
             ? 1
             : error(s2, &quot;invalid signal&quot;)
           : error(s1, &quot;invalid signal&quot;);
}
	</JAVASCRIPT>
      
      
	<NAME>or_gate</NAME>
	<REQUIRES>get_signal</REQUIRES>
	<REQUIRES>after_delay</REQUIRES>
	<REQUIRES>logical_or</REQUIRES>
	<JAVASCRIPT>
// 由 GitHub 用户 clean99 提供

function or_gate(a1, a2, output) {
    function or_action_function() {
        const new_value = logical_or(get_signal(a1),
                                     get_signal(a2));
        after_delay(or_gate_delay, 
                    () =&gt; set_signal(output, new_value));
    }
    add_action(a1, or_action_function);
    add_action(a2, or_action_function);
    return &quot;ok&quot;;
}
	</JAVASCRIPT>
      
    </SOLUTION>
  </EXERCISE> 
  
  <EXERCISE> 
    另一种构造
    <INDEX>or-gate<SUBINDEX><ORDER>或门</ORDER><SPLITINLINE>or-gate<JAVASCRIPT><JAVASCRIPTINLINE>or_gate</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    或门的方法是作为一种由与门和反相器构建的复合数字逻辑
    设备。 定义一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      or-gate
      <JAVASCRIPT><JAVASCRIPTINLINE>or_gate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    来完成此任务。 在
    <SPLITINLINE>
      与门延迟
      <JAVASCRIPT><JAVASCRIPTINLINE>and_gate_delay</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      反相器延迟?
      <JAVASCRIPT><JAVASCRIPTINLINE>inverter_delay</JAVASCRIPTINLINE>?
      </JAVASCRIPT>
    </SPLITINLINE>
    下计算或门的延迟时间。
 <SOLUTION>
      （由 GitHub 用户 <LINK ADDRESS="https://github.com/taimoon">taimoon</LINK> 提供）
      <BREAK></BREAK>
      思路：~(~a &amp; ~b) = nand(~a, ~b) = ~~a | ~~b = a | b
      
	<JAVASCRIPT>
function nand_gate(a1, a2, out){
    const tmp = make_wire();
    and_gate(a1, a2, tmp);
    inverter(tmp, out);
}

function or_gate(a1, a2, out){
    const not_a1 = make_wire();
    const not_a2 = make_wire();
    inverter(a1, not_a1);
    inverter(a2, not_a2);
    nand_gate(not_a1, not_a2, out);
}
	</JAVASCRIPT>
      
      nand门的延迟时间为
      <JAVASCRIPTINLINE>nand_gate_delay = and_gate_delay + inverter_delay</JAVASCRIPTINLINE>，上述或门的延迟时间为
      <JAVASCRIPTINLINE>or_gate_delay = nand_gate_delay + inverter_delay = and_gate_delay + 2 * inverter_delay</JAVASCRIPTINLINE>。
    </SOLUTION>
<LABEL NAME="ex:3_29"></LABEL>
  </EXERCISE>
   <SHORT_PAGE LINES="1"></SHORT_PAGE> 
  <EXERCISE> 
    图<SPACE></SPACE><REF NAME="fig:ripple-carry"></REF>显示了一个
    <INDEX>行波进位加法器</INDEX>
    <INDEX>加法器<SUBINDEX>行波进位</SUBINDEX></INDEX>
    <EM>行波进位加法器</EM>通过串接形成
<LATEXINLINE>$n$</LATEXINLINE>
    图<SPACE></SPACE><REF NAME="fig:ripple-carry"></REF>显示了一个
    <INDEX>行波进位加法器</INDEX>
    <INDEX>加法器<SUBINDEX>行波进位</SUBINDEX></INDEX>
    <EM>行波进位加法器</EM>通过串接多个
    全加器构成。
    这是用于加两个二进制数的最简单的并行加法器形式。
<LATEXINLINE>$n$</LATEXINLINE> 
    图<SPACE></SPACE><REF NAME="fig:ripple-carry"></REF>显示了一个
    <INDEX>行波进位加法器</INDEX>
    <INDEX>加法器<SUBINDEX>行波进位</SUBINDEX></INDEX>
    <EM>行波进位加法器</EM>通过串接多个全加器构成。
    这是用于加两个-bit二进制数的最简单的并行加法器形式。
    输入
<LATEXINLINE>$A_{1}$</LATEXINLINE>,
    <LATEXINLINE>$A_{2}$</LATEXINLINE>,
    <LATEXINLINE>$A_{3}$</LATEXINLINE>,  <ELLIPSIS></ELLIPSIS>, 
<LATEXINLINE>$A_{n}$</LATEXINLINE> 和 
<LATEXINLINE>$B_{1}$</LATEXINLINE>,
    <LATEXINLINE>$B_{2}$</LATEXINLINE>,
    <LATEXINLINE>$B_{3}$</LATEXINLINE>,  <ELLIPSIS></ELLIPSIS>, 
<LATEXINLINE>$B_{n}$</LATEXINLINE> 
    是要相加的两个二进制数（每个
<LATEXINLINE>$A_{k}$</LATEXINLINE> 和 
<LATEXINLINE>$B_{k}$</LATEXINLINE> 
    是0或1）。电路生成
<LATEXINLINE>$S_{1}$</LATEXINLINE>,
    <LATEXINLINE>$S_{2}$</LATEXINLINE>,
    <LATEXINLINE>$S_{3}$</LATEXINLINE>,
     <ELLIPSIS></ELLIPSIS>, 
<LATEXINLINE>$S_{n}$</LATEXINLINE> ，
    这个 
<LATEXINLINE>$n$</LATEXINLINE> 
    ，
    这个
    总和的位数，和
<LATEXINLINE>$C$</LATEXINLINE> ，从加法进位。编写一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      ripple-carry-adder
      <JAVASCRIPT><JAVASCRIPTINLINE>ripple_carry_adder</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    来生成这个电路。该
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    应接受三个列表作为参数
<LATEXINLINE>$n$</LATEXINLINE> 
    导线，每个<EMDASH></EMDASH>这个
<LATEXINLINE>$A_{k}$</LATEXINLINE> ，这个 
<LATEXINLINE>$B_{k}$</LATEXINLINE> ，和这个 
<LATEXINLINE>$S_{k}$</LATEXINLINE> <EMDASH></EMDASH>并且
    也有另一根导线
<LATEXINLINE>$C$</LATEXINLINE> 
。行波进位加法器的主要缺点是需要等待进位信号传播。获取完整输出所需的延迟为 
<LATEXINLINE>$n$</LATEXINLINE> -位行波进位加法器的完整输出所需的延迟，用于与门、或门和反相器的延迟来表示。 
<LABEL NAME="ex:ripple-carry"></LABEL>
  </EXERCISE>

   <FIGURE>
    <FIGURE SPLIT_SCALE="0.5" WEB_SCALE="0.8" SRC="img_original/ch3-Z-G-27.svg"></FIGURE>
    <CAPTION>
      $n$-位数的行波进位加法器。
    </CAPTION>
    
  </FIGURE> 

   <INDEX>数字电路模拟<SUBINDEX>原语函数盒<CLOSE></CLOSE></SUBINDEX></INDEX> 

   <SUBHEADING> 
    <NAME>表示导线</NAME>
  </SUBHEADING> 
  <TEXT> 
    在我们的模拟中
    <INDEX>数字电路模拟<SUBINDEX>表示导线<OPEN></OPEN></SUBINDEX></INDEX>
    ，导线将是一个具有两个局部
    状态变量的计算对象：
    <SPLITINLINE>
      a<SPACE></SPACE>信号值，
      <JAVASCRIPT>a<SPACE></SPACE><JAVASCRIPTINLINE>signal_value</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    （初始值为0）和一组
    <SPLITINLINE>
      操作过程，
      <JAVASCRIPT><JAVASCRIPTINLINE>action_functions</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    ，当信号值变化时会运行。我们采用
    <INDEX>消息传递<SUBINDEX>在数字电路模拟中</SUBINDEX></INDEX>
    的消息传递风格
    实现导线，作为一系列局部
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的集合
<SCHEMEINLINE>dispatch</SCHEMEINLINE>
     <SPLITINLINE>过程
    <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，用于选择适当的局部操作，就像我们
    在章节<SPACE></SPACE><REF NAME="sec:local-state-variables"></REF>中处理简单的银行账户对象那样：
<SNIPPET>
      <INDEX><DECLARATION>make_wire</DECLARATION></INDEX> 
      <NAME>make_wire</NAME>
      <REQUIRES>call_each</REQUIRES>
      <EXAMPLE>make_wire_usage</EXAMPLE>
      <SCHEME>
(define (make-wire)
  (let ((signal-value 0) (action-procedures &apos;()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
            (call-each action-procedures))
            &apos;done))
                
(define (accept-action-procedure! proc)
  (set! action-procedures (cons proc action-procedures))
  (proc))
               
(define (dispatch m)
  (cond ((eq? m &apos;get-signal) signal-value)
        ((eq? m &apos;set-signal!) set-my-signal!)
        ((eq? m &apos;add-action!) accept-action-procedure!)
        (else (error &quot;Unknown operation -- WIRE&quot; m))))
  dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_wire() {
    let signal_value = 0;
    let action_functions = null;
    function set_my_signal(new_value) {
        if (signal_value !== new_value) {
            signal_value = new_value;
            return call_each(action_functions);
        } else {
            return &quot;done&quot;;
        }
    }
    function accept_action_function(fun) {
        action_functions = pair(fun, action_functions);
        fun();
    }
    function dispatch(m) {
        return m === &quot;get_signal&quot;
               ? signal_value
               : m === &quot;set_signal&quot;
               ? set_my_signal
               : m === &quot;add_action&quot;
               ? accept_action_function
               : error(m, &quot;unknown operation -- wire&quot;);
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET> 
局部的
<SPLITINLINE>
   过程
   <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
<SPLITINLINE>
   set-my-signal
   <JAVASCRIPT><JAVASCRIPTINLINE>set_my_signal</JAVASCRIPTINLINE>
   </JAVASCRIPT>
</SPLITINLINE>
测试新信号值是否改变了导线上信号。 如果是这样，它则运行每一个
<SPLITINLINE>
   过程
   <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
使用以下
<SPLITINLINE>
   过程
   <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
<SPLITINLINE>
   call-each，
   <JAVASCRIPT><JAVASCRIPTINLINE>call_each</JAVASCRIPTINLINE>，</JAVASCRIPT>
</SPLITINLINE>
用于调用不带参数的过程列表中的每一项：
<SPLITINLINE>
   过程：
   <JAVASCRIPT>函数：</JAVASCRIPT>
</SPLITINLINE>
<SNIPPET>
      <INDEX><DECLARATION>call_each</DECLARATION></INDEX> 
      <NAME>call_each</NAME>
      <SCHEME>
(define (call-each procedures)
  (if (null? procedures)
      &apos;done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))
      </SCHEME>
      <JAVASCRIPT>
function call_each(functions) {
    if (is_null(functions)) {
        return &quot;done&quot;;
    } else {
        head(functions)();
        return call_each(tail(functions));
    }
}
      </JAVASCRIPT>
    </SNIPPET> 
局部
<SPLITINLINE>
   过程
   <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
<SPLITINLINE>
   接受-操作-过程，
   <JAVASCRIPT><JAVASCRIPTINLINE>accept_action_function</JAVASCRIPTINLINE>
   </JAVASCRIPT>
</SPLITINLINE>
将给定的
<SPLITINLINE>
   过程
   <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
添加到要执行的
<SPLITINLINE>
   过程列表中，
   <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
然后运行新的
<SPLITINLINE>
   过程
   <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
一次。 （参见练习<SPACE><REF NAME="ex:accept-action"></REF>。）
</SPACE></TEXT>

  <TEXT> 
    使用局部 
<SCHEMEINLINE>dispatch</SCHEMEINLINE>
     <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    设置为指定，可以提供以下
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    以访问
    导线上的局部操作：
<FOOTNOTE> 这些
<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
只是语法糖，允许我们使用普通的
<SPLITINLINE>
  
    过程性
  
  <JAVASCRIPT>
    函数式
  </JAVASCRIPT>
</SPLITINLINE> 
语法访问对象的局部
<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>。令人惊讶的是，我们可以如此简单地交换
<SPLITINLINE><QUOTE>过程</QUOTE>
<JAVASCRIPT><QUOTE>函数</QUOTE></JAVASCRIPT>
</SPLITINLINE>
和
<QUOTE>数据</QUOTE>的角色。 例如，如果我们写
<SPLITINLINE>
  (wire &apos;get-signal)
  <JAVASCRIPT><JAVASCRIPTINLINE>wire(&quot;get_signal&quot;)</JAVASCRIPTINLINE>
  </JAVASCRIPT>
</SPLITINLINE>
我们认为
 <SCHEMEINLINE>wire</SCHEMEINLINE> 作为一个
<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
，用消息
<SPLITINLINE>
  get-signal
  <JAVASCRIPT><JAVASCRIPTINLINE>&quot;get_signal&quot;</JAVASCRIPTINLINE>
  </JAVASCRIPT>
</SPLITINLINE>
作为输入进行调用。或者，编写
<SPLITINLINE>
  (get-signal wire)
  <JAVASCRIPT><JAVASCRIPTINLINE>get_signal(wire)</JAVASCRIPTINLINE>
  </JAVASCRIPT>
</SPLITINLINE>
鼓励我们思考
<SCHEMEINLINE>wire</SCHEMEINLINE> 作为一个数据
对象，它是
<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
的输入
<SPLITINLINE>
  获取信号
  <JAVASCRIPT><JAVASCRIPTINLINE>get_signal</JAVASCRIPTINLINE>
  </JAVASCRIPT>
</SPLITINLINE>
。 问题的本质在于，在一个可以将
<SPLITINLINE>过程
<JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
视为对象的语言中，
<SPLITINLINE><QUOTE>过程</QUOTE>
<JAVASCRIPT><QUOTE>函数</QUOTE></JAVASCRIPT>
</SPLITINLINE>
和<QUOTE>数据</QUOTE>之间没有根本区别，我们可以选择我们的语法糖使我们能以我们选择的风格进行编程。
<LABEL NAME="foot:object-syntax"></LABEL></FOOTNOTE>
    <SNIPPET>
      <INDEX><DECLARATION>get_signal</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_signal</DECLARATION></INDEX> 
      <INDEX><DECLARATION>add_action</DECLARATION></INDEX> 
      <NAME>get_signal</NAME>
      <SCHEME>
(define (get-signal wire)
  (wire &apos;get-signal))
                
(define (set-signal! wire new-value)
  ((wire &apos;set-signal!) new-value))
                

(define (add-action! wire action-procedure)
  ((wire &apos;add-action!) action-procedure))
      </SCHEME>
      <JAVASCRIPT>
function get_signal(wire) {
    return wire(&quot;get_signal&quot;);
}
function set_signal(wire, new_value) {
    return wire(&quot;set_signal&quot;)(new_value);
}
function add_action(wire, action_function) {
    return wire(&quot;add_action&quot;)(action_function);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

   <TEXT>
导线，其中包含随时间变化的信号，可能逐步连接到设备上，是可变对象的典型代表。我们将它们建模为具有局部状态变量的
<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
，通过赋值进行修改。当创建新导线时，会分配一组新的状态变量（通过
<SPLITINLINE>
  let 表达式在
  <JAVASCRIPT>
	<JAVASCRIPTINLINE>let</JAVASCRIPTINLINE> 语句在
  </JAVASCRIPT>
</SPLITINLINE>
<SPLITINLINE>
  make-wire)
  <JAVASCRIPT><JAVASCRIPTINLINE>make_wire</JAVASCRIPTINLINE>)</JAVASCRIPT>
</SPLITINLINE>
中）并构造和返回一个新的 dispatch
<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
，捕获具有新状态变量的环境。
</TEXT> 

   <TEXT>
导线是在已连接的各种设备之间共享的。因此，通过与一个设备的交互所做的更改将影响所有附加到该导线的其他设备。导线通过调用在建立连接时提供给它的动作
<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
来与其邻居通信更改。
</TEXT> 

   <INDEX>数字电路模拟<SUBINDEX>表示导线<CLOSE></CLOSE></SUBINDEX></INDEX> 
  
   <SUBHEADING> 
    <NAME>议程</NAME>
  </SUBHEADING> 

   <INDEX>数字电路模拟<SUBINDEX>议程<OPEN></OPEN></SUBINDEX></INDEX> 

  <TEXT> 
    完成模拟器所需的唯一元素是
    <SPLITINLINE>
      after-delay.
      <JAVASCRIPT><JAVASCRIPTINLINE>after_delay</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    这里的想法是我们维护一个数据结构，称为
    <EM>议程</EM>，它包含待办事项的计划。
    为议程定义了以下操作：
<UL>
       <LI>
        <SPLITINLINE>
	  (make-agenda):
	  <JAVASCRIPT><JAVASCRIPTINLINE>make_agenda()</JAVASCRIPTINLINE>:
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>make_agenda</USE></INDEX> 
	<BR></BR>
	返回一个新的空议程。
      </LI>
      <LI>
        <SPLITINLINE>
	  (empty-agenda? agenda):
	  
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>is_empty_agenda(</JAVASCRIPTINLINE><META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>is_empty_agenda</USE></INDEX> 
	<BR></BR>
	如果指定的议程为空，则为 true。
      </LI>
      <LI>
        <SPLITINLINE>
	  (first-agenda-item agenda):
	  
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>first_agenda_item(</JAVASCRIPTINLINE><META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>first_agenda_item</USE></INDEX> 
	<BR></BR>
	返回议程上的第一个项目。
      </LI>
      <LI>
        <SPLITINLINE>
	  
	    (remove-first-agenda-item! agenda):
	  
	  <JAVASCRIPT>
            <JAVASCRIPTINLINE>remove_first_agenda_item(</JAVASCRIPTINLINE><META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>remove_first_agenda_item</USE></INDEX> 
	<BR></BR>
        通过移除第一个项目来修改议程。
      </LI>
 <LI>
        <SPLITINLINE>
	  
	    (add-to-agenda! time action agenda):
	  
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>add_to_agenda(</JAVASCRIPTINLINE><META>time</META><JAVASCRIPTINLINE>,</JAVASCRIPTINLINE> <META>action</META><JAVASCRIPTINLINE>,</JAVASCRIPTINLINE> <META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>add_to_agenda</USE></INDEX> 
	<BR></BR>
        通过添加指定的动作
        <SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
        来修改议程，以便在指定的时间运行。
      </LI>
      <LI>
        <SPLITINLINE>
	  (current-time agenda):
	  
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>current_time(</JAVASCRIPTINLINE><META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>current_time</USE></INDEX> 
	<BR></BR>
        返回当前的模拟时间。
      </LI>
</UL>
  </TEXT>

   <TEXT>
    我们使用的特定议程表示为
    <SPLITINLINE>
      议程.
      <JAVASCRIPT><JAVASCRIPTINLINE>议程</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    该
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      延迟后
      <JAVASCRIPT><JAVASCRIPTINLINE>after_delay</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    向
    <SPLITINLINE>
      议程中添加新元素：
      <JAVASCRIPT><JAVASCRIPTINLINE>议程</JAVASCRIPTINLINE>中添加新元素：</JAVASCRIPT>
    </SPLITINLINE>
    
      <INDEX><DECLARATION>after_delay</DECLARATION></INDEX> 
      <NAME>after_delay</NAME>
      <REQUIRES>添加到议程中</REQUIRES>
      <REQUIRES>创建议程</REQUIRES>
      <REQUIRES>议程</REQUIRES>
      
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
      
      <JAVASCRIPT>
function after_delay(delay, action) {
    add_to_agenda(delay + current_time(the_agenda),
                  action,
                  the_agenda);
}
      </JAVASCRIPT>
    
  </TEXT> 

   <TEXT>
    <SPLIT>
      
	模拟由过程驱动
	propagate，它在
	the-agenda上运行，
	顺序执行议程中的每个过程。
      
      <JAVASCRIPT>
	模拟由函数驱动
	<JAVASCRIPTINLINE>propagate</JAVASCRIPTINLINE>，它顺序执行
	<JAVASCRIPTINLINE>the_agenda</JAVASCRIPTINLINE>
	上的每个函数。
      </JAVASCRIPT>
    </SPLIT>
    一般来说，随着模拟运行，新的项目
    将被添加到议程中，propagate
    将继续模拟，只要议程上还有项目：
    
      <INDEX><DECLARATION>propagate</DECLARATION></INDEX> 
      <NAME>propagate</NAME>
      <REQUIRES>删除第一个议程项目</REQUIRES>
      <REQUIRES>第一个议程项目</REQUIRES>
      <REQUIRES>议程</REQUIRES>
      
(define (propagate)
  (if (empty-agenda? the-agenda)
      &apos;done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
      
      <JAVASCRIPT>
function propagate() {
    if (is_empty_agenda(the_agenda)) {
        return &quot;done&quot;;
    } else {
        const first_item = first_agenda_item(the_agenda);
        first_item();
        remove_first_agenda_item(the_agenda);
        return propagate();
    }
}
      </JAVASCRIPT>
    
  </TEXT> 

   <INDEX>数字电路模拟<SUBINDEX>议程<CLOSE></CLOSE></SUBINDEX></INDEX> 
  
  <LONG_PAGE LINES="1"></LONG_PAGE>
   <SUBHEADING> 
    <NAME>模拟示例</NAME>
  </SUBHEADING> 

   <INDEX>数字电路模拟<SUBINDEX>模拟示例<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>数字电路模拟<SUBINDEX>模拟示例<OPEN></OPEN></SUBINDEX></INDEX> 

   <INDEX>半加器<SUBINDEX>模拟<OPEN></OPEN></SUBINDEX></INDEX> 

  <TEXT> 
    我们首先通过初始化议程并为
    原语函数盒指定延迟：
<SNIPPET>
      <NAME>the_agenda</NAME>
      <REQUIRES>make_agenda</REQUIRES>
      <SCHEME>
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
      </SCHEME>
      <JAVASCRIPT>
const the_agenda = make_agenda();
const inverter_delay = 2;
const and_gate_delay = 3;
const or_gate_delay = 5;
      </JAVASCRIPT>
    </SNIPPET> 
    现在我们定义四根导线，并在其中两根上放置探测器：
<SNIPPET>
      <NAME>probing_two_wires</NAME>
      <REQUIRES>make_wire</REQUIRES>
      <REQUIRES>probe</REQUIRES>
      <SCHEME>
(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))
    
(probe &apos;sum sum)
      </SCHEME>
      <SCHEMEOUTPUT>
    sum 0  New-value = 0
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
const input_1 = make_wire();
const input_2 = make_wire();
const sum = make_wire();
const carry = make_wire();

probe(&quot;sum&quot;, sum);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;sum 0, new value = 0&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>probe_carry</NAME>
      <REQUIRES>probing_two_wires</REQUIRES>
      <SCHEME>
(probe &apos;carry carry)
      </SCHEME>
      <SCHEMEOUTPUT>
carry 0  New-value = 0
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
probe(&quot;carry&quot;, carry);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;carry 0, new value = 0&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> <TEXT>
    <SPLIT>
      过程,
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLIT>
    一个在导线上放置<QUOTE>探测器</QUOTE>的过程/函数，展示了模拟器的
    一种用法。探测器指示导线每当其信号改变时，需打印新信号值，连同
    当前时间和识别<SPLIT>
      导线：
      <JAVASCRIPT>导线：</JAVASCRIPT>
    </SPLIT>
    
      <INDEX><DECLARATION>probe</DECLARATION><SUBINDEX>在数字电路模拟器中</SUBINDEX></INDEX>
      <NAME>探测器</NAME>
      <REQUIRES>议程</REQUIRES>
      <REQUIRES>get_signal</REQUIRES>
      
(define (探测器 名称 导线)
  (add-action! 导线
               (lambda ()
                 (newline)
                 (display 名称)
                 (display &quot; &quot;)
                 (display (current-time 议程))
                 (display &quot;  新值 = &quot;)
                 (display (get-signal 导线)))))
      
      <JAVASCRIPT>
function probe(name, wire) {
    add_action(wire, 
               () =&gt; display(name + &quot; &quot; +
                             stringify(current_time(the_agenda)) + 
                             &quot;, new value = &quot; + 
                             stringify(get_signal(wire))));
}
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
function probe(name, wire) {
    add_action(wire, 
               () =&gt; name + &quot; &quot; +
                     stringify(current_time(the_agenda)) + 
                     &quot;, new value = &quot; + 
                     stringify(get_signal(wire)));
}
      </JAVASCRIPT_TEST>
    
  </TEXT> <SNIPPET>
      <NAME>half_adder_example_2</NAME>
      <REQUIRES>half_adder</REQUIRES>
      <REQUIRES>probe_carry</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(half-adder input-1 input-2 sum carry)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
half_adder(input_1, input_2, sum, carry);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>set_signal_example</NAME>
      <REQUIRES>half_adder_example_2</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(set-signal! input-1 1)
      </SCHEME>
      <SCHEMEOUTPUT>
done
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_signal(input_1, 1);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;done&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>propagate_example_1</NAME>
      <REQUIRES>set_signal_example</REQUIRES>
      <REQUIRES>propagate</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(propagate)
      </SCHEME>
      <SCHEMEOUTPUT>
sum 8  New-value = 1
done
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
propagate();
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;sum 8, new value = 1&quot;
&quot;done&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    这个 
<SCHEMEINLINE>sum</SCHEMEINLINE> 
    信号在时间8变为1。
    我们现在距离模拟开始时已有八个时间单位。
    在此时，我们可以设置
    <SPLITINLINE>
      输入-2
      <JAVASCRIPT><JAVASCRIPTINLINE>input_2</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    的信号为1，并让值传播：
<SNIPPET>
      <NAME>set_signal_example_2</NAME>
      <REQUIRES>propagate_example_1</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(set-signal! input-2 1)
      </SCHEME>
      <SCHEMEOUTPUT>
                done
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_signal(input_2, 1);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;done&quot;	
      </JAVASCRIPT_OUTPUT>
      </SNIPPET>
    <SNIPPET>
      <NAME>propagate_example_2</NAME>
      <REQUIRES>set_signal_example_2</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(propagate)
      </SCHEME>
      <SCHEMEOUTPUT>
carry 11  New value = 1
sum 16  New value = 0
done
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
propagate();
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;carry 11, new value = 1&quot;
&quot;sum 16, new value = 0&quot;
&quot;done&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <LONG_PAGE LINES="2"></LONG_PAGE>The <!-- Error occurred while translating this section --><SCHEMEINLINE>carry</SCHEMEINLINE> changes to 1 at time 11 and the
    <!-- Error occurred while translating this section --><SCHEMEINLINE>sum</SCHEMEINLINE> changes to 0 at time 16.
  <!-- Error occurred while translating this section --></TEXT>

  <INDEX>digital-circuit simulation<SUBINDEX>sample simulation<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>half-adder<SUBINDEX>simulation of<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->

  <EXERCISE>
    <LABEL NAME="ex:accept-action"></LABEL>
    The internal
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>accept-action-procedure!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>accept_action_function</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    defined in
    <INDEX><USE>make_wire</USE></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-wire</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_wire</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    specifies that when a new action
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is added to
    a wire, the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is immediately run.  Explain why this initialization
    is necessary.  In particular, trace through the half-adder example in
    the paragraphs above and say how the system<APOS></APOS>s response would differ
    if we had defined
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>accept-action-procedure!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>accept_action_function</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    as
    <SNIPPET EVAL="no" POSTPADDING="no">
      <SCHEME>
(define (accept-action-procedure! proc)
  (set! action-procedures (cons proc action-procedures)))
      </SCHEME>
      <JAVASCRIPT>
function accept_action_function(fun) {
   action_functions = pair(fun, action_functions);
}
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE><!-- Error occurred while translating this section -->
      
  <SUBHEADING> 
    <NAME>Implementing the agenda</NAME>
  </SUBHEADING><!-- Error occurred while translating this section -->

  <INDEX>digital-circuit simulation<SUBINDEX>agenda implementation<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->

  <TEXT>
    Finally, we give details of the agenda data structure, which holds the
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    that are scheduled for future execution.
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    The agenda is made up of 
    <INDEX>time segment, in agenda</INDEX>
    <EM>time segments</EM>.  Each time segment is a
    pair consisting of a number (the time) and a 
    <INDEX>queue<SUBINDEX><ORDER>simulation</ORDER>in simulation agenda</SUBINDEX></INDEX>
    queue (see
    exercise<SPACE></SPACE><REF NAME="ex:agenda-list"></REF>) that holds the
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    that are scheduled to be run during that time segment.
    <SNIPPET>
      <INDEX><DECLARATION>make_time_segment</DECLARATION></INDEX> 
      <INDEX><DECLARATION>segment_time</DECLARATION></INDEX> 
      <INDEX><DECLARATION>segment_queue</DECLARATION></INDEX> 
      <NAME>make_time_segment</NAME>
      <SCHEME>
(define (make-time-segment time queue)
  (cons time queue))
                
(define (segment-time s) (car s))
                
(define (segment-queue s) (cdr s))
      </SCHEME>
      <JAVASCRIPT>
function make_time_segment(time, queue) {
   return pair(time, queue);
}
function segment_time(s) { return head(s); }
<SHORT_SPACE></SHORT_SPACE>
function segment_queue(s) { return tail(s); }
      </JAVASCRIPT>
    </SNIPPET>
    We will operate on the time-segment queues using the queue operations
    described in section<SPACE></SPACE><REF NAME="sec:queues"></REF>.
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    The agenda itself is a one-dimensional
    <INDEX>table<SUBINDEX>used in simulation agenda</SUBINDEX></INDEX>
    table of time segments.  It
    differs from the tables described in section<SPACE></SPACE><REF NAME="sec:tables"></REF>
    in that the segments will be sorted in order of increasing time.  In
    addition, we store the 
    <INDEX>current time, for simulation agenda</INDEX>
    <EM>current time</EM> (i.e., the time of the last action
    that was processed) at the head of the agenda.  A newly constructed
    agenda has no time segments and has a current time of 0:<FOOTNOTE>The
    agenda is a 
    <INDEX>headed list</INDEX>
    <INDEX>list(s)<SUBINDEX>headed</SUBINDEX></INDEX>
    headed list, like the tables in section<SPACE></SPACE><REF NAME="sec:tables"></REF>,
    but since the list is headed by the time, we do not need an additional
    dummy header (such as the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>*table*</SCHEMEINLINE> symbol
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>&quot;*table*&quot;</JAVASCRIPTINLINE> string
      </JAVASCRIPT>
    </SPLITINLINE>
    used
    with tables).</FOOTNOTE>
    <!-- Error occurred while translating this section --><SNIPPET>
      <INDEX><DECLARATION>make_agenda</DECLARATION></INDEX> 
      <INDEX><DECLARATION>current_time</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_current_time</DECLARATION></INDEX> 
      <INDEX><DECLARATION>segments</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_segments</DECLARATION></INDEX> 
      <INDEX><DECLARATION>first_segment</DECLARATION></INDEX> 
      <INDEX><DECLARATION>rest_segments</DECLARATION></INDEX> 
      <NAME>make_agenda</NAME>
      <SCHEME>
(define (make-agenda) (list 0))
                
(define (current-time agenda) (car agenda))
                
(define (set-current-time! agenda time)
  (set-car! agenda time))
                
(define (segments agenda) (cdr agenda))
                
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
                
(define (first-segment agenda) (car (segments agenda)))
                
(define (rest-segments agenda) (cdr (segments agenda)))
      </SCHEME>
      <JAVASCRIPT>
function make_agenda() { return list(0); }
<SHORT_SPACE></SHORT_SPACE>
function current_time(agenda) { return head(agenda); }
<SHORT_SPACE></SHORT_SPACE>
function set_current_time(agenda, time) {
   set_head(agenda, time);
}
function segments(agenda) { return tail(agenda); }
<SHORT_SPACE></SHORT_SPACE>
function set_segments(agenda, segs) {
   set_tail(agenda, segs);
}
function first_segment(agenda) { return head(segments(agenda)); }
<SHORT_SPACE></SHORT_SPACE>
function rest_segments(agenda) { return tail(segments(agenda)); }
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    An agenda is empty if it has no time segments:
    <SNIPPET>
      <INDEX><DECLARATION>is_empty_agenda</DECLARATION></INDEX> 
      <NAME>is_empty_agenda</NAME>
      <REQUIRES>make_agenda</REQUIRES>
      <SCHEME>
(define (empty-agenda? agenda)
  (null? (segments agenda)))
      </SCHEME>
      <JAVASCRIPT>
function is_empty_agenda(agenda) {
   return is_null(segments(agenda));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    To add an action to an agenda, we first check if the agenda is empty.
    If so, we create a time segment for the action and install this in
    the agenda.  Otherwise, we scan the agenda, examining the time of each
    segment.  If we find a segment for our appointed time, we add the
    action to the associated queue.  If we reach a time later than the one
    to which we are appointed, we insert a new time segment into the
    agenda just before it.  If we reach the end of the agenda, we must
    create a new time segment at the end.
    <!-- Error occurred while translating this section --><SNIPPET>
      <INDEX><DECLARATION>add_to_agenda</DECLARATION></INDEX> 
      <NAME>add_to_agenda</NAME>
      <REQUIRES>make_time_segment</REQUIRES>
      <REQUIRES>make_queue</REQUIRES>
      <REQUIRES>insert_queue</REQUIRES>
      <REQUIRES>make_time_segment</REQUIRES>
      <REQUIRES>make_agenda</REQUIRES>
      <SCHEME>
(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (&lt; time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
     (if (= (segment-time (car segments)) time)
         (insert-queue! (segment-queue (car segments))
                        action)
         (let ((rest (cdr segments)))
           (if (belongs-before? rest)
               (set-cdr!
                segments
                (cons (make-new-time-segment time action)
                      (cdr segments)))
               (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
      </SCHEME>
      <JAVASCRIPT>
function add_to_agenda(time, action, agenda) {
   function belongs_before(segs) {
      return is_null(segs) || time &lt; segment_time(head(segs));
   }
   function make_new_time_segment(time, action) {
      const q = make_queue();
      insert_queue(q, action);
      return make_time_segment(time, q);
   }
   function add_to_segments(segs) {
      if (segment_time(head(segs)) === time) {
          insert_queue(segment_queue(head(segs)), action);
      } else {
          const rest = tail(segs);
          if (belongs_before(rest)) {
              set_tail(segs, pair(make_new_time_segment(time, action),
                                  tail(segs)));
          } else {
              add_to_segments(rest);
          }
      }
   }
   const segs = segments(agenda);
   if (belongs_before(segs)) {
       set_segments(agenda,
                    pair(make_new_time_segment(time, action), segs));
   } else {
       add_to_segments(segs);
   }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that removes the first item from the agenda deletes the
    item at the front of the queue in the first time segment.  If this
    deletion makes the time segment empty, we remove it from the list of
    segments:<FOOTNOTE>Observe that the
    <LABEL NAME="foot:one-armed"></LABEL>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE>
	expression in this
	procedure
	has no alternative expression.
      </SCHEME>
      <JAVASCRIPT>
	conditional statement in this
	function has an
	<INDEX>block<SUBINDEX>empty</SUBINDEX></INDEX>
	empty block as its alternative statement.
      </JAVASCRIPT>
    </SPLITINLINE>
    Such a
    <INDEX>conditional statement<SUBINDEX>one-armed (without alternative)</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>one-armed <SCHEMEINLINE>if</SCHEMEINLINE> expression</QUOTE>
      </SCHEME>
      <JAVASCRIPT>
	<QUOTE>one-armed conditional statement</QUOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is used to decide whether to do something, rather than to select between two
    <SPLITINLINE>
      <SCHEME>
	expressions.
	An <SCHEMEINLINE>if</SCHEMEINLINE> expression returns an
	unspecified value if the predicate is false and there is no
	<LATEXINLINE>alternative</LATEXINLINE>.
      </SCHEME>
      <JAVASCRIPT>statements.</JAVASCRIPT>
    </SPLITINLINE>
  </FOOTNOTE>
    <!-- Error occurred while translating this section --><SNIPPET>
      <INDEX><DECLARATION>remove_first_agenda_item</DECLARATION></INDEX> 
      <NAME>remove_first_agenda_item</NAME>
      <REQUIRES>make_agenda</REQUIRES>
      <REQUIRES>is_empty_queue</REQUIRES>
      <REQUIRES>delete_queue</REQUIRES>
      <REQUIRES>make_time_segment</REQUIRES>
      <SCHEME>
(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
      </SCHEME>
      <JAVASCRIPT>
function remove_first_agenda_item(agenda) {
   const q = segment_queue(first_segment(agenda));
   delete_queue(q);
   if (is_empty_queue(q)) {
       set_segments(agenda, rest_segments(agenda));
   } else {}
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The first agenda item is found at the head of the queue in the first
    time segment.  Whenever we extract an item, we also update the current
    time:<FOOTNOTE>In this way, the current time will always be the time
    of the action most recently processed.  Storing this time at the head
    of the agenda ensures that it will still be available even if the
    associated time segment has been deleted.</FOOTNOTE>
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>first_agenda_item</DECLARATION></INDEX> 
      <NAME>first_agenda_item</NAME>
      <REQUIRES>is_empty_agenda</REQUIRES>
      <REQUIRES>make_time_segment</REQUIRES>
      <REQUIRES>front_queue</REQUIRES>
      <SCHEME>
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error &quot;Agenda is empty -- FIRST-AGENDA-ITEM&quot;)
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
      </SCHEME>
      <JAVASCRIPT>
function first_agenda_item(agenda) {
    if (is_empty_agenda(agenda)) {
        error(&quot;agenda is empty -- first_agenda_item&quot;);
    } else {
        const first_seg = first_segment(agenda);
        set_current_time(agenda, segment_time(first_seg));
        return front_queue(segment_queue(first_seg));
    }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT><!-- Error occurred while translating this section -->

  <EXERCISE>
    The
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    to be run during each time segment of the agenda are kept in a queue.
    Thus, the
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for each segment are called in the order in which they were added to the
    agenda (first in, first out).  Explain why this order must be used.  In
    particular, trace the behavior of an and-gate whose inputs change from
    0,1 to 1,0 in the same segment and say how the behavior would differ if
    we stored a segment<APOS></APOS>s
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in an ordinary list, adding and removing
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    only at the front (last in, first out).
    <LABEL NAME="ex:agenda-list"></LABEL>
  </EXERCISE><!-- Error occurred while translating this section -->

  <INDEX>digital-circuit simulation<CLOSE></CLOSE></INDEX><!-- Error occurred while translating this section -->
  <INDEX>digital-circuit simulation<SUBINDEX>agenda implementation<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->

</SUBSECTION>
