      <SUBSECTION>
        <NAME>Example: Square Roots by Newton<APOS/>s Method</NAME>
        <LABEL NAME="sec:sqrt"/>

        <TEXT>
              <INDEX>procedure<SUBINDEX>mathematical function vs.|(</SUBINDEX></INDEX>
              <INDEX>function (mathematical)<SUBINDEX>procedure vs.|(</SUBINDEX></INDEX>
                <SPLITINLINE><SCHEME>Procedures</SCHEME><JAVASCRIPT>Functions</JAVASCRIPT></SPLITINLINE>,
              as introduced above, are much like ordinary mathematical
              functions.  They specify a value that is determined by one or more
              parameters.  But there is an important difference between
              mathematical functions and computer
                <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.
                <SPLITINLINE>
                  <SCHEME>
                    Procedures
                  </SCHEME>
                  <JAVASCRIPT>
                    Computer functions
                  </JAVASCRIPT>
                </SPLITINLINE>
                must be effective.
        </TEXT>

            <TEXT>
              As a case in point, consider the problem of computing square
              roots.  We can define the square-root function as
              <LATEX>
                \[
                \sqrt{x} =\text{ the }y\text{ such that }y \geq 0\text{ and }
                y^2 = x
                \]
              </LATEX>
              This describes a perfectly legitimate mathematical function.  We could
              use it to recognize whether one number is the square root of another, or
              to derive facts about square roots in general.  On the other hand, the
              definition does not describe a
              <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>computer function</JAVASCRIPT></SPLITINLINE>.
                Indeed, it tells us almost
              nothing about how to actually find the square root of a given number.  It
              will not help matters to rephrase this definition in <SPLITINLINE><SCHEME>pseudo-Scheme</SCHEME><JAVASCRIPT>pseudo-JavaScript</JAVASCRIPT></SPLITINLINE>:
                <SNIPPET EVAL="no">
                <SCHEME>
(define (sqrt x)
  (the y (and (>= y 0)
              (= (square y) x))))
                </SCHEME>
                <JAVASCRIPT>
function sqrt(x) {
    return the y with y &gt;= 0 &amp;&amp;
                      square(y) === x;
}
                </JAVASCRIPT>
              </SNIPPET>
              This only begs the question.
            </TEXT>

            <TEXT>
              The contrast between
                <SPLITINLINE>
                  <SCHEME>
                    function and procedure
                  </SCHEME>
                  <JAVASCRIPT>
                    mathematical function and computer function
                  </JAVASCRIPT>
                </SPLITINLINE>
              is a reflection of the
              general distinction between describing properties of things and
              describing how to do things, or, as it is sometimes referred to, the
              distinction between
              <INDEX>declarative vs.<SPACE/>imperative knowledge</INDEX>
              <INDEX>imperative vs.<SPACE/>declarative knowledge</INDEX>
              declarative knowledge and imperative knowledge.
              In
              <INDEX>mathematics<SUBINDEX>computer science vs.</SUBINDEX></INDEX>
              <INDEX>computer science<SUBINDEX>mathematics vs.</SUBINDEX></INDEX>
              mathematics we are usually concerned with declarative (what is)
              descriptions, whereas in computer science we are usually concerned
              with imperative (how to) descriptions.<FOOTNOTE>Declarative and
                imperative descriptions are intimately related, as indeed are
                mathematics and computer science.  For instance, to say that the
                answer produced by a program is
                <INDEX>correctness of a program</INDEX>
                <QUOTE>correct</QUOTE> is to make a declarative
                statement about the program.  There is a large amount of research
                aimed at establishing techniques for
                <INDEX>proving programs correct</INDEX>
                proving that programs are
                correct, and much of the technical difficulty of this subject has to
                do with negotiating the transition between imperative statements (from
                which programs are constructed) and declarative statements (which can
                be used to deduce things).  In a related vein, an important current
                area in programming-language design is the exploration of so-called
                <INDEX>programming language<SUBINDEX>very high-level</SUBINDEX></INDEX>
                <INDEX>very high-level language</INDEX>
                very high-level languages, in which one actually programs in terms of
                declarative statements.  The idea is to make interpreters
                sophisticated enough so that, given <QUOTE>what is</QUOTE> knowledge
                specified by
                the programmer, they can generate <QUOTE>how to</QUOTE> knowledge automatically.
                This cannot be done in general, but there are important areas where
                progress has been made.  We shall revisit this idea in chapter<SPACE/>4.</FOOTNOTE>
              <INDEX>procedure<SUBINDEX>mathematical function vs.|)</SUBINDEX></INDEX>
              <INDEX>function (mathematical)<SUBINDEX>procedure vs.|)</SUBINDEX></INDEX>
            </TEXT>

        <TEXT>
          <INDEX>square root|(</INDEX>
          <INDEX>Newton<APOS/>s method<SUBINDEX>square@for square roots|(</SUBINDEX></INDEX>
          How does one compute square roots?  The most common way is to use
          Newton<APOS/>s method of successive approximations, which says that whenever
          we have a guess <LATEXINLINE>$y$</LATEXINLINE> for the value of the square root of a
          number <LATEXINLINE>$x$</LATEXINLINE>,
          we can perform a simple manipulation to get a better guess (one closer
          to the actual square root) by averaging <LATEXINLINE>$y$</LATEXINLINE> with
          <LATEXINLINE>$x/y$</LATEXINLINE>.<FOOTNOTE>This square-root algorithm is actually
            a special case
            of Newton<APOS/>s method, which is a general technique for finding roots of
            equations.  The square-root algorithm itself was developed by Heron of
            <INDEX>Heron of Alexandria</INDEX>
            Alexandria in the first century <SC>a.d</SC>.  We will see how to express
            the general Newton<APOS/>s method as a
                <SPLITINLINE>
                  <SCHEME>
                    Lisp procedure
                  </SCHEME>
                  <JAVASCRIPT>
                    JavaScript function
                  </JAVASCRIPT>
                </SPLITINLINE>
                in
            section<SPACE/><REF NAME="sec:proc-returned-values"/>.</FOOTNOTE>
          For example, we can compute
          the square root of 2 as follows.  Suppose our initial guess is<SPACE/>1:
          <TABLE>
            <FIGURE src="img_tex/ch1_1_7-1.png"></FIGURE>
          </TABLE>
          Continuing this process, we obtain better and better
          approximations to the square root.
        </TEXT>

        <TEXT>
              Now let<APOS/>s formalize the process in terms of functions.  We start with
              a value for the
              <INDEX>radicand</INDEX>
              radicand (the number whose square root we are trying
              to compute) and a value for the guess.  If the guess is good enough
              for our purposes, we are done; if not, we must repeat the process with an
              improved guess.  We write this basic strategy as a
                <SPLITINLINE>
                  <SCHEME>
                    procedure:
                  </SCHEME>
                  <JAVASCRIPT>
                   function:
                  </JAVASCRIPT>
                </SPLITINLINE>

              <SNIPPET>
                <NAME>sqrt_iter</NAME>
                <REQUIRES>good_enough</REQUIRES>
                <REQUIRES>improve</REQUIRES>
                <EXAMPLE>sqrt_iter_example</EXAMPLE>
                <SCHEME>
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
       guess
      (sqrt-iter (improve guess x) x)))
                </SCHEME>
                <JAVASCRIPT>
function sqrt_iter(guess, x) {
    return good_enough(guess, x)
           ? guess
           : sqrt_iter(improve(guess, x), x);
}
                </JAVASCRIPT>
              </SNIPPET>
              <SNIPPET HIDE="yes">
                <NAME>sqrt_iter_example</NAME>
                <SCHEME>
(sqrt-iter 3 25)
                </SCHEME>
                <JAVASCRIPT>
sqrt_iter(3,25);
                </JAVASCRIPT>
              </SNIPPET>
        </TEXT>

        <TEXT>
          A guess is improved by averaging
          it with the quotient of the radicand and the old guess:
          <SNIPPET>
            <NAME>improve</NAME>
            <REQUIRES>average_definition</REQUIRES>
            <EXAMPLE>improve_example</EXAMPLE>
            <SCHEME>
(define (improve guess x)
   (average guess (/ x guess)))
            </SCHEME>
            <JAVASCRIPT>
function improve(guess, x) {
    return average(guess, x / guess);
}
          </JAVASCRIPT>
          </SNIPPET>
          <SNIPPET HIDE="yes">
            <NAME>improve_example</NAME>
            <SCHEME>
(improve 3 25)
            </SCHEME>
            <JAVASCRIPT>
improve(3, 25);
          </JAVASCRIPT>
          </SNIPPET>
            where
            <!-- \indcode*{average} -->
            <SNIPPET>
              <NAME>average_definition</NAME>
              <EXAMPLE>average_example</EXAMPLE>
              <SCHEME>
(define (average x y)
   (/ (+ x y) 2))
              </SCHEME>
              <JAVASCRIPT>
function average(x,y) {
    return (x + y) / 2;
}
              </JAVASCRIPT>
            </SNIPPET>
            <SNIPPET HIDE="yes">
              <NAME>average_example</NAME>
              <SCHEME>
(average 3 6)
              </SCHEME>
              <JAVASCRIPT>
average(3, 6);
              </JAVASCRIPT>
            </SNIPPET>
          </TEXT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              We also have to say what we mean by <QUOTE>good enough.</QUOTE>  The
              following will do for illustration, but it is not really a very good
              test.  (See exercise<SPACE/><REF NAME="ex:ex-sqrt-end-test"/>.)
              The idea is to improve the answer until it is close enough so that its
              square differs from the radicand by less than a predetermined
              tolerance (here 0.001):<FOOTNOTE>We will usually give
                <INDEX>predicate<SUBINDEX>naming convention for</SUBINDEX></INDEX>
                <INDEX>naming conventions<SUBINDEX>?@<SCHEMEINLINE>?</SCHEMEINLINE> for predicates</SUBINDEX></INDEX>
                <INDEX>question mark, in predicate names</INDEX>
                <!-- \indcodeplus{?}{, in predicate names} -->
                predicates names ending with question marks, to help us
                remember that they are predicates.  This
                is just a stylistic convention.  As far as the interpreter is
                concerned, the question mark is just an ordinary character.</FOOTNOTE>
              <SNIPPET>
                <NAME>good_enough</NAME>
                <REQUIRES>abs_definition</REQUIRES>
                <REQUIRES>square_definition</REQUIRES>
                <EXAMPLE>good_enough_example</EXAMPLE>
                <SCHEME>
(define (good-enough? guess x)
   (&lt; (abs (- (square guess) x)) 0.001))
                </SCHEME>
              </SNIPPET>
              <SNIPPET HIDE="yes">
                <NAME>good_enough_example</NAME>
                <SCHEME>
(good-enough? 1.41 2)
                </SCHEME>
              </SNIPPET>
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              We also have to say what we mean by <QUOTE>good enough.</QUOTE>  The
              following will do for illustration, but it is not really a very good
              test.  (See exercise<SPACE/><REF NAME="ex:ex-sqrt-end-test"/>.)
              The idea is to improve the answer until it is close enough so that its
              square differs from the radicand by less than a predetermined
              tolerance (here 0.001):
              <COMMENT>footnote removed; does not apply; unfortunately
                we cannot use ? in identifiers
                in JavaScript.</COMMENT>
              <SNIPPET>
                <NAME>good_enough</NAME>
                <REQUIRES>abs_definition</REQUIRES>
                <REQUIRES>square_definition</REQUIRES>
                <EXAMPLE>good_enough_example</EXAMPLE>
                <JAVASCRIPT>
function good_enough(guess, x) {
    return abs(square(guess) - x) &lt; 0.001;
}
                </JAVASCRIPT>
              </SNIPPET>
              <SNIPPET HIDE="yes">
                <NAME>good_enough_example</NAME>
                <JAVASCRIPT>
good_enough(1.41, 2);
                </JAVASCRIPT>
              </SNIPPET>
            </TEXT>
          </JAVASCRIPT>
        </SPLIT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              Finally, we need a way to get started.  For instance, we can
                always guess that the square root of any number
              is 1:<FOOTNOTE>Observe that we express our initial guess as 1.0 rather than
                1.  This would not make any difference in many Lisp implementations.
                <INDEX>rational number(s)<SUBINDEX>MIT@in MIT Scheme</SUBINDEX></INDEX>
                <INDEX>exact integer</INDEX><INDEX>integer(s)<SUBINDEX>exact</SUBINDEX></INDEX>
                <INDEX>division of integers</INDEX><INDEX>integer(s)<SUBINDEX>dividing</SUBINDEX></INDEX>
                <INDEX>number(s)<SUBINDEX>rational number</SUBINDEX></INDEX>
                <INDEX>number(s)<SUBINDEX>integer, exact</SUBINDEX></INDEX>
                <INDEX>number(s)<SUBINDEX>decimal point in</SUBINDEX></INDEX>
                <INDEX>decimal point in numbers</INDEX>
                <INDEX>MIT Scheme<SUBINDEX>numbers</SUBINDEX></INDEX>
                <INDEX>implementation dependencies<SUBINDEX>numbers</SUBINDEX></INDEX>
                <INDEX>number(s)<SUBINDEX>implementation dependencies</SUBINDEX></INDEX>
                MIT Scheme, however, distinguishes between exact integers and decimal
                values, and dividing two integers produces a rational number rather
                than a decimal.  For example, dividing 10 by 6 yields 5/3, while
                dividing 10.0 by 6.0 yields 1.6666666666666667.  (We will learn how to
                implement arithmetic on rational numbers in
                section<SPACE/><REF NAME="sec:rationals"/>.)  If we start with an initial guess of 1
                in our square-root program, and <LATEXINLINE>$x$</LATEXINLINE> is an exact integer, all
                subsequent values produced in the square-root computation will be
                rational numbers rather than decimals.  Mixed operations on rational
                numbers and decimals always yield decimals, so starting with an
                initial guess of 1.0 forces all subsequent values to be decimals.</FOOTNOTE>
              <SNIPPET>
                <NAME>sqrt</NAME>
                <REQUIRES>sqrt_iter</REQUIRES>
                <EXAMPLE>sqrt_example2</EXAMPLE>
                <SCHEME>
(define (sqrt x)
   (sqrt-iter 1.0 x))
                </SCHEME>
              </SNIPPET>
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              Finally, we need a way to get started.  For instance, we can
              always guess that the square root of any number is 1:<COMMENT>Footnote removed</COMMENT>
              <!-- \indcode*{sqrt} -->
              <SNIPPET>
                <NAME>sqrt_definition</NAME>
                <REQUIRES>sqrt_iter</REQUIRES>
                <EXAMPLE>sqrt_example</EXAMPLE>
                <JAVASCRIPT>
function sqrt(x) {
    return sqrt_iter(1, x);
}
                </JAVASCRIPT>
              </SNIPPET>
            </TEXT>
          </JAVASCRIPT>

        </SPLIT>

        <TEXT>
          If we type these
          <SPLITINLINE>
            <SCHEME>
	      definitions
	    </SCHEME>
            <JAVASCRIPT>
	      declarations
	    </JAVASCRIPT>
	  </SPLITINLINE>
	  to the interpreter, we can use <SCHEMEINLINE>sqrt</SCHEMEINLINE>
              just as we can use any
                <SPLITINLINE>
                  <SCHEME>
                    procedure:
                  </SCHEME>
                  <JAVASCRIPT>
                   function:
                  </JAVASCRIPT>
                </SPLITINLINE>

                <SNIPPET PAGE="24">
                  <NAME>sqrt_example</NAME>
                  <REQUIRES>sqrt_definition</REQUIRES>
                  <SCHEME>
(sqrt 9)
                  </SCHEME>
                  <SCHEMEOUTPUT>
3.00009155413138
                  </SCHEMEOUTPUT>
                  <JAVASCRIPT>
sqrt(9);
                  </JAVASCRIPT>
                </SNIPPET>

                <SNIPPET PAGE="24" HIDE="yes">
                  <NAME>sqrt_example2</NAME>
                  <SCHEME>
(sqrt 5)
                  </SCHEME>
                  <JAVASCRIPT>
sqrt(5);
                  </JAVASCRIPT>
                </SNIPPET>

              <SNIPPET>
                <REQUIRES>sqrt_definition</REQUIRES>
                <SCHEME>
(sqrt (+ 100 37))
                </SCHEME>
                <SCHEMEOUTPUT>
11.704699917758145
                </SCHEMEOUTPUT>
                <JAVASCRIPT>
sqrt(100 + 37);
                </JAVASCRIPT>
              </SNIPPET>

              <SNIPPET>
                <REQUIRES>sqrt_definition</REQUIRES>
                <SCHEME>
(sqrt (+ (sqrt 2) (sqrt 3)))
                </SCHEME>
                <SCHEMEOUTPUT>
1.7739279023207892
                </SCHEMEOUTPUT>
                <JAVASCRIPT>
sqrt(sqrt(2) + sqrt(3));
                </JAVASCRIPT>
              </SNIPPET>

              <SNIPPET>
                <REQUIRES>sqrt_definition</REQUIRES>
                <SCHEME>
(square (sqrt 1000))
                </SCHEME>
                <SCHEMEOUTPUT>
1000.000369924366
                </SCHEMEOUTPUT>
                <JAVASCRIPT>
square(sqrt(1000));
                </JAVASCRIPT>
              </SNIPPET>

              <INDEX>square root|)</INDEX>
              <INDEX>Newton<APOS/>s method<SUBINDEX>square@for square roots|)</SUBINDEX></INDEX>
        </TEXT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              <INDEX>iterative process<SUBINDEX>implemented by procedure call|(</SUBINDEX></INDEX>
              The <SCHEMEINLINE>sqrt</SCHEMEINLINE> program also illustrates that the simple procedural
              language we have introduced so far is sufficient for writing any
              purely numerical program that one could write in, say, C or
              Pascal.  This might seem surprising, since we have not included in
              our language any iterative
              <INDEX>looping constructs</INDEX>
              (looping) constructs that direct the
              computer to do something over and over again.  <SCHEMEINLINE>Sqrt-iter</SCHEMEINLINE>, on the
              other hand, demonstrates how iteration can be accomplished using no
              special construct other than the ordinary ability to call a
              procedure.<FOOTNOTE>Readers who are worried about the efficiency
                issues involved in using procedure calls to implement iteration should
                note the remarks on <QUOTE>tail recursion</QUOTE> in
                section<SPACE/><REF NAME="sec:recursion-and-iteration"/>.</FOOTNOTE>
              <INDEX>iterative process<SUBINDEX>implemented by procedure call|)</SUBINDEX></INDEX>
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              <INDEX>iterative process<SUBINDEX>implemented by procedure call|(</SUBINDEX></INDEX>
              The <JAVASCRIPTINLINE>sqrt</JAVASCRIPTINLINE> program also illustrates that the simple functional
              language we have introduced so far is sufficient for writing any
              purely numerical program that one could write in, say, C or
              Pascal.  This might seem surprising, since we have not
              yet introduced
              any iterative
              <INDEX>looping constructs</INDEX>
              (looping) constructs that direct the
              computer to do something over and over again. The function
              <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>, on the
              other hand, demonstrates how iteration can be accomplished using no
              special construct other than the ordinary ability to call a
              function.<FOOTNOTE>Readers who are worried about the efficiency
                issues involved in using function calls to implement iteration should
                note the remarks on <QUOTE>tail recursion</QUOTE> in
                section<SPACE/><REF NAME="sec:recursion-and-iteration"/>.</FOOTNOTE>
              <INDEX>iterative process<SUBINDEX>implemented by function call|)</SUBINDEX></INDEX>
            </TEXT>
          </JAVASCRIPT>
        </SPLIT>
        <EXERCISE>
        <SPLIT>
          <SCHEME>
                <!-- \indsf{if}[why a special form] -->
                <INDEX>special form<SUBINDEX>need for</SUBINDEX></INDEX>
                Alyssa P. Hacker doesn<APOS/>t see why <SCHEMEINLINE>if</SCHEMEINLINE> needs
                to be provided as a special form.  <QUOTE>Why can<APOS/>t I just define it as an
                  ordinary procedure in terms of
                  <NOBR><SCHEMEINLINE>cond</SCHEMEINLINE>?</NOBR></QUOTE> she asks.
                Alyssa<APOS/>s friend Eva Lu Ator claims this can indeed be done, and
                she defines a new version of <SCHEMEINLINE>if</SCHEMEINLINE>:
                <SNIPPET>
                  <NAME>new_if</NAME>
                  <SCHEME>
(define (new-if predicate then-clause else-clause)
   (cond (predicate then-clause)
   (else else-clause)))
                  </SCHEME>
                </SNIPPET>
                Eva demonstrates the program for Alyssa:
                <SNIPPET>
                  <REQUIRES>new_if</REQUIRES>
                  <SCHEME>
(new-if (= 2 3) 0 5)
                  </SCHEME>
                  <SCHEMEOUTPUT>
5
                  </SCHEMEOUTPUT>
                </SNIPPET>
                <SNIPPET>
                  <REQUIRES>new_if</REQUIRES>
                  <SCHEME>
(new-if (= 1 1) 0 5)
                  </SCHEME>
                  <SCHEMEOUTPUT>
0
                  </SCHEMEOUTPUT>
                </SNIPPET>
                Delighted, Alyssa uses <SCHEMEINLINE>new-if</SCHEMEINLINE> to rewrite the square-root
                program:
                <SNIPPET>
                  <REQUIRES>new_if</REQUIRES>
                  <REQUIRES>good_enough</REQUIRES>
                  <REQUIRES>improve</REQUIRES>
                  <EXAMPLE>sqrt_iter_example</EXAMPLE>
                  <SCHEME>
(define (sqrt-iter guess x)
   (new-if (good-enough? guess x)
           guess
           (sqrt-iter (improve guess x)
                      x)))
                  </SCHEME>
                </SNIPPET>
                What happens when Alyssa attempts to use this to compute square roots?
                Explain.
                <LABEL NAME="ex:new-if"/>
          </SCHEME>
          <JAVASCRIPT>
            <!-- \indsf{if}[why a special form] -->
            <INDEX>special form<SUBINDEX>need for</SUBINDEX></INDEX>
            Alyssa P. Hacker doesn<APOS/>t like the syntax of conditional
	    expressions, involving the characters <SCHEMEINLINE>?</SCHEMEINLINE>
	    and <SCHEMEINLINE>:</SCHEMEINLINE>.
	    <QUOTE>Why can<APOS/>t I just declare an
            ordinary conditional function whose application 
	    works just like conditional expressions?</QUOTE> she asks.
            Alyssa<APOS/>s friend Eva Lu Ator claims this can indeed be done, and
            she declares a <JAVASCRIPTINLINE>conditional</JAVASCRIPTINLINE>
	    function as follows:
                <SNIPPET>
                  <NAME>conditional</NAME>
                  <JAVASCRIPT>
function conditional(predicate, then_clause, else_clause) {		    
    return predicate ? then_clause : else_clause;
}
		  </JAVASCRIPT>
                </SNIPPET>
                Eva demonstrates the program for Alyssa:
                <SNIPPET>
                  <REQUIRES>conditional</REQUIRES>
                  <JAVASCRIPT>
conditional(2 === 3, 0, 5);
		  </JAVASCRIPT>
                </SNIPPET>
		evaluates as expected to 5, and
                <SNIPPET>
                  <REQUIRES>conditional</REQUIRES>
                  <JAVASCRIPT>
conditional(1 === 1, 0, 5);
		  </JAVASCRIPT>
                </SNIPPET>
		evaluates as expected to 0.
                Delighted, Alyssa uses
		<SCHEMEINLINE>conditional</SCHEMEINLINE> to rewrite the square-root
                program:
                <SNIPPET>
                  <REQUIRES>conditional</REQUIRES>
                  <REQUIRES>good_enough</REQUIRES>
                  <REQUIRES>improve</REQUIRES>
                  <EXAMPLE>sqrt_iter_example</EXAMPLE>
                  <JAVASCRIPT>
function sqrt_iter(guess, x) {
    return conditional(good_enough(guess, x),
                       guess,
                       sqrt_iter(improve(guess, x),
                                 x));
}
		  </JAVASCRIPT>
                </SNIPPET>
                What happens when Alyssa attempts to use this to compute square roots?
                Explain.
                <LABEL NAME="ex:new-if"/>
		<SOLUTION>
		  Any call of
		  <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>
		  leads immediately to an infinite loop. The reason
		  for this is our applicative-order evaluation. The
		  evaluation of the return expression of
		  <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>
		  needs to evaluate its arguments first, including
		  the recursive call of
		  <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>,
		  regardless whether the predicate evaluates to
		  <EM>true</EM> or <EM>false</EM>. The same of course
		  happens with the recursive call, and thus the
		  function
		  <JAVASCRIPTINLINE>conditional</JAVASCRIPTINLINE>
		  never actually gets applied.
		</SOLUTION>
          </JAVASCRIPT>
        </SPLIT>
        </EXERCISE>

        <EXERCISE>
                <LABEL NAME="ex:ex-sqrt-end-test"/>
                The
                <SPLITINLINE>
                  <SCHEME>
                    <SCHEMEINLINE>good-enough?</SCHEMEINLINE>
                  </SCHEME>
                  <JAVASCRIPT>
                    <JAVASCRIPTINLINE>good_enough</JAVASCRIPTINLINE>
                  </JAVASCRIPT>
                </SPLITINLINE>
                test used in computing square roots will not be
                very effective for finding the square roots of very small numbers.
                Also, in real computers, arithmetic operations are almost always
                performed with limited precision.  This makes our test inadequate for
                very large numbers.  Explain these statements, with examples showing
                how the test fails for small and large numbers.  An alternative
                strategy for implementing
                <SPLITINLINE>
                  <SCHEME>
                    <SCHEMEINLINE>good-enough?</SCHEMEINLINE>
                  </SCHEME>
                  <JAVASCRIPT>
                    <JAVASCRIPTINLINE>good_enough</JAVASCRIPTINLINE>
                  </JAVASCRIPT>
                </SPLITINLINE>
                  is to watch how
                <SCHEMEINLINE>guess</SCHEMEINLINE>
                changes from one iteration to the next and to stop when the
                change is a very small fraction of the guess.  Design a square-root
                <SPLITINLINE>
                  <SCHEME>
                    procedure
                  </SCHEME>
                  <JAVASCRIPT>
                    function
                  </JAVASCRIPT>
                </SPLITINLINE>
                that uses this kind of end test.  Does this work better for
                small and large numbers?
    <SOLUTION>
      The absolute tolerance of 0.001 is too large when computing the square
      root of a small value.
      For example, <JAVASCRIPTINLINE>sqrt(0.0001)</JAVASCRIPTINLINE>
      results in 0.03230844833048122 instead of the expected value 0.01,
      an error of over 200%.
      <P/>
      On the other hand, for very large values, rounding errors might make
      the algorithm fail to ever get close enough to the square root, in which
      case it will not terminate terminates. 
      <P/>
      The following program alleviates the problem by replacing an absolute
      tolerance with a relative tolerance.
      <SNIPPET>
        <REQUIRES>abs_definition</REQUIRES>
        <REQUIRES>average_definition</REQUIRES>
        <REQUIRES>sqrt_definition</REQUIRES>
        <REQUIRES>improve</REQUIRES>
        <REQUIRES>sqrt_iter</REQUIRES>	
	<EXAMPLE>example_1.8</EXAMPLE>
      <JAVASCRIPT>
const error_threshold = 0.01;
function good_enough(guess,x) {
    return relative_error(guess, improve(guess, x))
           &lt; error_threshold;
}
function relative_error(estimate, reference) {
    return abs(estimate - reference) / reference;
}
</JAVASCRIPT>
</SNIPPET>
    </SOLUTION>
      <SNIPPET HIDE="yes">
      <NAME>example_1.8</NAME>
      <JAVASCRIPT>
sqrt(3);
      </JAVASCRIPT>
      <SCHEME>
      </SCHEME>
      </SNIPPET>
        </EXERCISE>

        <EXERCISE><LABEL NAME="ex:cube-root-newton"/>
                <INDEX>cube root<SUBINDEX>Newton@by Newton<APOS/>s method</SUBINDEX></INDEX>
                <INDEX>Newton<APOS/>s method<SUBINDEX>cube@for cube roots</SUBINDEX></INDEX>
                Newton<APOS/>s method for cube roots is based on the fact that if
                <LATEXINLINE>$y$</LATEXINLINE> is an
                approximation to the cube root of <LATEXINLINE>$x$</LATEXINLINE>, then a better approximation is
                given by the value
                <LATEX>
                    \[ \frac{x/y^{2}+2y} {3} \]
                </LATEX>
                Use this formula to implement a cube-root
                <SPLITINLINE>
                  <SCHEME>
                    procedure
                  </SCHEME>
                  <JAVASCRIPT>
                    function
                  </JAVASCRIPT>
                </SPLITINLINE>
                analogous to the
                square-root
                <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.
                (In section<SPACE/><REF NAME="sec:proc-returned-values"/> we
                will see how to implement Newton<APOS/>s method in general as an abstraction
                of these square-root and cube-root
                <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.)
<SOLUTION>
<SNIPPET>
<EXAMPLE>example_1.9</EXAMPLE>
<REQUIRES>abs_definition</REQUIRES>
<REQUIRES>cube_definition</REQUIRES>
<JAVASCRIPT>
function good_enough(guess, x) {
    return abs(cube(guess) - x) &lt; 0.001;
}
function div3(x, y) {
     return (x + y) / 3;
}
function improve(guess, x) {
    return div3(x / (guess * guess), 2 * guess);
}
function cube_root(guess, x) {
    return good_enough(guess, x)
               ? guess
               : cuberoot(improve(guess, x), x);
}
</JAVASCRIPT>
<SCHEME>
</SCHEME>
</SNIPPET>
</SOLUTION>
<SNIPPET HIDE="yes">
<NAME>example_1.9</NAME>
<JAVASCRIPT>
cube_root(3,27);
</JAVASCRIPT>
</SNIPPET>
</EXERCISE>

      </SUBSECTION>
