    <SUBSECTION> 
      <NAME>
        Propagation of Constraints
      </NAME>

      <LABEL NAME="sec:constraints"/>
      <INDEX>propagation of constraints|(</INDEX>
      <INDEX>constraint(s)<SUBINDEX>propagation of|(</SUBINDEX></INDEX>


      <TEXT>
        Computer programs are traditionally organized as
        one-directional computations, which perform operations on prespecified
        arguments to produce desired outputs.  On the other hand, we often
        model systems in terms of relations among quantities.  For example, a
        mathematical model of a mechanical structure might include the
        information that the deflection <LATEXINLINE>$d$</LATEXINLINE> of a metal rod is related to the
        force <LATEXINLINE>$F$</LATEXINLINE> on the rod, the length <LATEXINLINE>$L$</LATEXINLINE> of the rod, the cross-sectional
        area <LATEXINLINE>$A$</LATEXINLINE>, and the elastic modulus <LATEXINLINE>$E$</LATEXINLINE> via the equation
        <LATEX>
          \[ d A E = F L \]
        </LATEX>
        Such an equation is not one-directional.  Given any four of the
        quantities, we can use it to compute the fifth.  Yet translating the
        equation into a traditional computer language would force us to choose
        one of the quantities to be computed in terms of the other four.
        Thus, a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        for computing the area <LATEXINLINE>$A$</LATEXINLINE> could not be used to
        compute the deflection <LATEXINLINE>$d$</LATEXINLINE>, even though the computations of <LATEXINLINE>$A$</LATEXINLINE> and
        <LATEXINLINE>$d$</LATEXINLINE> arise from the same equation.<FOOTNOTE>Constraint propagation
          first appeared in the incredibly forward-looking 
          <INDEX>SKETCHPAD</INDEX>
          SKETCHPAD system of
          <INDEX>Sutherland, Ivan</INDEX>
          Ivan Sutherland (1963).  A beautiful constraint-propagation system
          based on the 
          <INDEX>Smalltalk</INDEX>
          Smalltalk language was developed by 
          <INDEX>Borning, Alan</INDEX>
          Alan Borning (1977)
          at 
          <INDEX>Xerox Palo Alto Research Center</INDEX>
          Xerox Palo Alto Research Center.  Sussman, Stallman, and Steele
          <INDEX>Sussman, Gerald Jay</INDEX>
          <INDEX>Stallman, Richard M.</INDEX>
          <INDEX>Steele, Guy Lewis Jr.</INDEX>
          <INDEX>TK!Solver</INDEX>
          <INDEX>Konopasek, Milos</INDEX>
          <INDEX>Jayaraman, Sundaresan</INDEX>
          applied constraint propagation to electrical circuit analysis 
          (<CITATION>Sussman and Stallman 1975</CITATION>; 
          <CITATION>Sussman and Steele 1980</CITATION>). 
          TK!Solver (<CITATION>Konopasek and Jayaraman 1984</CITATION>) 
          is an extensive modeling environment based on constraints.</FOOTNOTE>
      </TEXT>

      <TEXT>
        <INDEX>relations, computing in terms of</INDEX>
        In this section, we sketch the design of a language that enables us to
        work in terms of relations themselves.  The primitive elements of the
        language are 
        <INDEX>primitive constraints</INDEX>
        <INDEX>constraint(s)<SUBINDEX>primitive</SUBINDEX></INDEX>
        <EM>primitive constraints</EM>, which state that certain
        relations hold between quantities.  For example, <SPLITINLINE><SCHEME><SCHEMEINLINE>(adder a b c)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>adder(a, b, c)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        specifies that the quantities <LATEXINLINE>$a$</LATEXINLINE>, <LATEXINLINE>$b$</LATEXINLINE>, and <LATEXINLINE>$c$</LATEXINLINE> must be related by the
        equation <LATEXINLINE>$a+b=c$</LATEXINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>(multiplier x y z)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>multiplier(x, y, z)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> expresses the constraint
        <LATEXINLINE>$xy = z$</LATEXINLINE>, and <SPLITINLINE><SCHEME><SCHEMEINLINE>(constant 3.14 x)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>constant(3.14, x)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> says that the value of <LATEXINLINE>$x$</LATEXINLINE> must
        be 3.14.
      </TEXT>

      <TEXT>
        Our language provides a means of combining primitive constraints in
        order to express more complex relations.  We combine constraints by
        constructing 
        <INDEX>constraint network</INDEX>
        <EM>constraint networks</EM>, in which constraints are
        joined by 
        <INDEX>connector(s), in constraint system</INDEX>
        <EM>connectors</EM>.  A connector is an object that <QUOTE>holds</QUOTE> a
        value that may participate in one or more constraints.  For example,
        we know that the relationship between Fahrenheit and Celsius
        temperatures is

        <LATEX>
          \[ 9C = 5(F - 32) \]
        </LATEX>
      </TEXT>

      <TEXT>
        Such a constraint can be thought of as a network consisting of
        primitive adder, multiplier, and constant constraints
        (figure<SPACE/><REF NAME="fig:constraint"/>).  In the figure, we see on the left a
        multiplier box with three terminals, labeled <LATEXINLINE>$m1$</LATEXINLINE>, <LATEXINLINE>$m2$</LATEXINLINE>, and <LATEXINLINE>$p$</LATEXINLINE>.
        These connect the multiplier to the rest of the network as follows:
        The <LATEXINLINE>$m1$</LATEXINLINE> terminal is linked to a connector <LATEXINLINE>$C$</LATEXINLINE>, which will hold the
        Celsius temperature.  The <LATEXINLINE>$m2$</LATEXINLINE> terminal is linked to a connector
        <LATEXINLINE>$w$</LATEXINLINE>, which is also linked to a constant box that holds 9.  The <LATEXINLINE>$p$</LATEXINLINE>
        terminal, which the multiplier box constrains to be the product of
        <LATEXINLINE>$m1$</LATEXINLINE> and <LATEXINLINE>$m2$</LATEXINLINE>, is linked to the <LATEXINLINE>$p$</LATEXINLINE> terminal
        of another multiplier box, whose <LATEXINLINE>$m2$</LATEXINLINE> is connected to a constant 5 and
        whose <LATEXINLINE>$m1$</LATEXINLINE> is connected to one of the terms in a sum.

        <FIGURE>
          <FIGURE src="img_original/ch3-Z-G-30.svg"></FIGURE>
            <CAPTION>The relation <LATEXINLINE>$9C = 5(F - 32)$</LATEXINLINE>
                expressed as a constraint network.
            </CAPTION>
        <LABEL NAME="fig:constraint"/>
        </FIGURE>
      </TEXT>

      <TEXT>
        Computation by such a network proceeds as follows: When a connector is
        given a value (by the user or by a constraint box to which it is
        linked), it awakens all of its associated constraints (except for the
        constraint that just awakened it) to inform them that it has a value.
        Each awakened constraint box then polls its connectors to see if there
        is enough information to determine a value for a connector.  If so,
        the box sets that connector, which then awakens all of its associated
        constraints, and so on.  For instance, in conversion between
        Celsius and Fahrenheit, <LATEXINLINE>$w$</LATEXINLINE>, <LATEXINLINE>$x$</LATEXINLINE>, and <LATEXINLINE>$y$</LATEXINLINE> are immediately set by
        the constant boxes to 9, 5, and 32, respectively.  The connectors
        awaken the multipliers and the adder, which determine that there is
        not enough information to proceed.  If the user (or some other part of
        the network) sets <LATEXINLINE>$C$</LATEXINLINE> to a value (say 25), the leftmost multiplier
        will be awakened, and it will set <LATEXINLINE>$u$</LATEXINLINE> to <LATEXINLINE>$25\cdot 9=225$</LATEXINLINE>.  Then <LATEXINLINE>$u$</LATEXINLINE>
        awakens the second multiplier, which sets <LATEXINLINE>$v$</LATEXINLINE> to 45, and <LATEXINLINE>$v$</LATEXINLINE> awakens
        the adder, which sets <LATEXINLINE>$F$</LATEXINLINE> to 77.
      </TEXT>

      <SUBHEADING> 
        <NAME>Using the constraint system</NAME>
      </SUBHEADING>

      <TEXT>
        To use the constraint system to carry out the temperature computation
        outlined above, we first create two connectors, <SCHEMEINLINE>C</SCHEMEINLINE> and <SCHEMEINLINE>F</SCHEMEINLINE>,
        by calling the constructor <SPLITINLINE><SCHEME><SCHEMEINLINE>make-connector</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_connector</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and link <SCHEMEINLINE>C</SCHEMEINLINE> and
        <SCHEMEINLINE>F</SCHEMEINLINE> in an appropriate network:

        <SNIPPET EVAL="no">
          <SCHEME>
            (define C (make-connector))
            (define F (make-connector))
            (celsius-fahrenheit-converter C F)
          </SCHEME>
          <JAVASCRIPT>
const C = make_connector();
const F = make_connector();
celsius_fahrenheit_converter(C, F);
          </JAVASCRIPT>
          <SCHEMEOUTPUT>
            ok
          </SCHEMEOUTPUT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        The
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        that creates the network is defined as follows:

        <SNIPPET EVAL="no">
          <SCHEME>
            <!--  \indcode*{celsius-fahrenheit-converter} -->
            (define (celsius-fahrenheit-converter c f)
            (let ((u (make-connector))
            (v (make-connector))
            (w (make-connector))
            (x (make-connector))
            (y (make-connector)))
            (multiplier c w u)
            (multiplier v x u)
            (adder v y f)
            (constant 9 w)
            (constant 5 x)
            (constant 32 y)
            'ok))
          </SCHEME>
          <JAVASCRIPT>
function celsius_fahrenheit_converter(c, f) {
    const u = make_connector();
    const v = make_connector();
    const w = make_connector();
    const x = make_connector();
    const y = make_connector();
    multiplier(c, w, u);
    multiplier(v, x, u);
    adder(v, y, f);
    constant(9, w);
    constant(5, x);
    constant(32, y);
    return "ok";
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        This
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        creates the internal connectors <SCHEMEINLINE>u</SCHEMEINLINE>, <SCHEMEINLINE>v</SCHEMEINLINE>, <SCHEMEINLINE>w</SCHEMEINLINE>, <SCHEMEINLINE>x</SCHEMEINLINE>, and <SCHEMEINLINE>y</SCHEMEINLINE>, and links them as shown in
        Figure<SPACE/><REF NAME="fig:constraint"/> using the primitive constraint
        constructors <SCHEMEINLINE>adder</SCHEMEINLINE>, <SCHEMEINLINE>multiplier</SCHEMEINLINE>, and <SCHEMEINLINE>constant</SCHEMEINLINE>.  Just
        as with the digital-circuit simulator of
        section<SPACE/><REF NAME="sec:circuit-simulator"/>, expressing these combinations of
        primitive elements in terms of
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        automatically provides our
        language with a means of abstraction for compound objects.
      </TEXT>

      <TEXT>
        To watch the network in action, we can place probes on the connectors
        <SCHEMEINLINE>C</SCHEMEINLINE> and <SCHEMEINLINE>F</SCHEMEINLINE>, using a <SCHEMEINLINE>probe</SCHEMEINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        similar to the one
        we used to monitor wires in section<SPACE/><REF NAME="sec:circuit-simulator"/>.
        Placing a probe on a connector will cause a message to be printed
        whenever the connector is given a value:

        <SNIPPET EVAL="no">
          <SCHEME>
            (probe "Celsius temp" C)
            (probe "Fahrenheit temp" F)
          </SCHEME>
          <JAVASCRIPT>
probe("Celsius Temp", C);
probe("Fahrenheit Temp", F);
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Next we set the value of <SCHEMEINLINE>C</SCHEMEINLINE> to 25.  (The third argument to <SPLITINLINE><SCHEME><SCHEMEINLINE>set-value!</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>set_value</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> tells <SCHEMEINLINE>C</SCHEMEINLINE> that this directive comes from the <SCHEMEINLINE>user</SCHEMEINLINE>.)

        <SNIPPET EVAL="no">
          <SCHEME>
            (set-value! C 25 'user)
          </SCHEME>
          <JAVASCRIPT>
set_value(C, 25, "user");
// Probe: Celsius Temp = 25
// Probe: Fahrenheit Temp = 77
          </JAVASCRIPT>
          <SCHEMEOUTPUT>
            Probe: Celsius temp = 25
            Probe: Fahrenheit temp = 77
            done
          </SCHEMEOUTPUT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        The probe on <SCHEMEINLINE>C</SCHEMEINLINE> awakens and reports the value.  <SCHEMEINLINE>C</SCHEMEINLINE> also
        propagates its value through the network as described above.  This
        sets <SCHEMEINLINE>F</SCHEMEINLINE> to 77, which is reported by the probe on <SCHEMEINLINE>F</SCHEMEINLINE>.
      </TEXT>

      <TEXT>
        Now we can try to set <SCHEMEINLINE>F</SCHEMEINLINE> to a new value, say 212:

        <SNIPPET EVAL="no">
          <SCHEME>
            (set-value! F 212 'user)
          </SCHEME>
          <JAVASCRIPT>
set_value(F, 212, "user");
// Error! Contradiction (77 212)
          </JAVASCRIPT>
          <SCHEMEOUTPUT>
            Error! Contradiction (77 212)
          </SCHEMEOUTPUT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        The connector complains that it has sensed a contradiction: Its value
        is 77, and someone is trying to set it to 212.  If we really want to
        reuse the network with new values, we can tell <SCHEMEINLINE>C</SCHEMEINLINE> to forget its
        old value:

        <SNIPPET EVAL="no">
          <SCHEME>
            (forget-value! C 'user)
          </SCHEME>
          <JAVASCRIPT>
forget_value(C, "user");
// Probe: Celsius Temp = ?
// Probe: Fahrenheit Temp = ?
          </JAVASCRIPT>
          <SCHEMEOUTPUT>
            Probe: Celsius temp = ?
            Probe: Fahrenheit temp = ?
            done
          </SCHEMEOUTPUT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>C</SCHEMEINLINE> finds that the
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>user</SCHEMEINLINE>,
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>"user"</JAVASCRIPTINLINE>,
	  </JAVASCRIPT>
	</SPLITINLINE>
	who set its value originally, is
        now retracting that value, so <SCHEMEINLINE>C</SCHEMEINLINE>
	agrees to lose its value, as shown by the probe, and informs the
	rest of the network of this fact. This information eventually
	propagates to <SCHEMEINLINE>F</SCHEMEINLINE>, which now finds
        that it has no reason for continuing to believe that its own
	value is<SPACE/>77.  Thus, <SCHEMEINLINE>F</SCHEMEINLINE> also
	gives up its value, as shown by the probe.
      </TEXT>

      <TEXT>
        Now that <SCHEMEINLINE>F</SCHEMEINLINE> has no value, we are free to set it to 212:

        <SNIPPET EVAL="no">
          <SCHEME>
            (set-value! F 212 'user)
          </SCHEME>
          <JAVASCRIPT>
set_value(F, 212, "user");
// Probe: Fahrenheit Temp = 212
// Probe: Celsius Temp = 100
          </JAVASCRIPT>
          <SCHEMEOUTPUT>
            Probe: Fahrenheit temp = 212
            Probe: Celsius temp = 100
            done
          </SCHEMEOUTPUT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        This new value, when propagated through the network, forces
	<SCHEMEINLINE>C</SCHEMEINLINE> to
        have a value of 100, and this is registered by the probe on
	<SCHEMEINLINE>C</SCHEMEINLINE>.
        Notice that the very same network is being used to compute
	<SCHEMEINLINE>C</SCHEMEINLINE>
        given <SCHEMEINLINE>F</SCHEMEINLINE> and to compute
	<SCHEMEINLINE>F</SCHEMEINLINE>
	given<SPACE/><SCHEMEINLINE>C</SCHEMEINLINE>.  This
        nondirectionality of computation is the distinguishing feature of
        constraint-based systems.
      </TEXT>

      <SUBHEADING> 
        <NAME>Implementing the constraint system</NAME>
      </SUBHEADING>

      <TEXT>
        The constraint system is implemented via procedural objects with local
        state, in a manner very similar to the digital-circuit simulator of
        section<SPACE/><REF NAME="sec:circuit-simulator"/>.  Although the primitive objects
        of the constraint system are somewhat more complex, the overall system
        is simpler, since there is no concern about agendas and logic delays.
      </TEXT>

      <TEXT>
        <INDEX>connector(s), in constraint system<SUBINDEX>operations on</SUBINDEX></INDEX>
        The basic operations on connectors are the following:
        <UL>
          <LI>
            <!--  \indcode{has-value?} -->
            <SPLITINLINE><SCHEME><SCHEMEINLINE>(has-value? ^connector^)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>has_value(connector)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:
            tells whether the connector has a value.

          </LI>
          <LI>
            <!--  \indcode{get-value} -->
            <SPLITINLINE><SCHEME><SCHEMEINLINE>(get-value ^connector^)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>get_value(connector)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:
            returns the connector<APOS/>s current value.
          </LI>
          <LI>
            <!--  \indcode{set-value!} -->
            <SPLITINLINE><SCHEME><SCHEMEINLINE>(set-value! ^connector^ ^new-value^ ^informant^)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>set_value(connector, new_value, informant)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:
            indicates that the informant is requesting the connector to set its
            value to the new value.
          </LI>
          <LI>
            <!--  \indcode{forget-value!} -->
            <SPLITINLINE><SCHEME><SCHEMEINLINE>(forget-value! ^connector^ ^retractor^)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>forget_value(connector, retractor)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:
            tells the connector that the retractor is requesting it to forget its value.
          </LI>
          <LI>
            <!--  \indcode{connect} -->
            <SPLITINLINE><SCHEME><SCHEMEINLINE>(connect ^connector^ ^new-constraint^)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>connect(connector, new_constraint)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:
            tells the connector to participate in the new constraint.
          </LI>
        </UL>
      </TEXT>

      <TEXT>
        The connectors communicate with the constraints by means of the
        <SPLITINLINE>
	  <SCHEME>procedures</SCHEME>
	  <JAVASCRIPT>functions</JAVASCRIPT>
	</SPLITINLINE>
        <SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>inform-about-value</SCHEMEINLINE>,
	  </SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>inform_about_value</JAVASCRIPTINLINE>,
	  </JAVASCRIPT>
	</SPLITINLINE>
	which tells the given constraint that the connector has a value, and
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>forget-value</SCHEMEINLINE>,</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>forget_value</JAVASCRIPTINLINE>,
	  </JAVASCRIPT>
	</SPLITINLINE>
	which tells the constraint that the connector has lost its value.
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Adder</SCHEMEINLINE> constructs an adder constraint among summand connectors
        <SCHEMEINLINE>a1</SCHEMEINLINE> and <SCHEMEINLINE>a2</SCHEMEINLINE> and a <SCHEMEINLINE>sum</SCHEMEINLINE> connector.  An adder is
        implemented as a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        with local state (the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SCHEMEINLINE>me</SCHEMEINLINE>
        below):

        <SNIPPET EVAL="no">
          <REQUIRES>Error</REQUIRES>
          <SCHEME>
            <!-- \indcodeplus*{adder}{(primitive constraint)}-->
            (define (adder a1 a2 sum)
            (define (process-new-value)
            (cond ((and (has-value? a1) (has-value? a2))
            (set-value! sum
            (+ (get-value a1) (get-value a2))
            me))
            ((and (has-value? a1) (has-value? sum))
            (set-value! a2
            (- (get-value sum) (get-value a1))
            me))
            ((and (has-value? a2) (has-value? sum))
            (set-value! a1
            (- (get-value sum) (get-value a2))
            me))))
            (define (process-forget-value)
            (forget-value! sum me)
            (forget-value! a1 me)
            (forget-value! a2 me)
            (process-new-value))
            (define (me request)
            (cond ((eq? request 'I-have-a-value)  
            (process-new-value))
            ((eq? request 'I-lost-my-value) 
            (process-forget-value))
            (else 
            (error "Unknown request - - ADDER" request))))
            (connect a1 me)
            (connect a2 me)
            (connect sum me)
            me)
          </SCHEME>
          <JAVASCRIPT>
function adder(a1, a2, sum) {
    function process_new_value() {
        if (has_value(a1) &amp;&amp; has_value(a2)) {
            set_value(sum, get_value(a1) + get_value(a2), me);
        } else if (has_value(a1) &amp;&amp; has_value(sum)) {
            set_value(a2, get_value(sum) - get_value(a1), me);
        } else if (has_value(a2) &amp;&amp; has_value(sum)) {
            set_value(a1, get_value(sum) - get_value(a2), me);
        } else {
        }
    }
    function process_forget_value() {
        forget_value(sum, me);
        forget_value(a1, me);
        forget_value(a2, me);
        process_new_value();
    }
    function me(request) {
        if (request === "I-have-a-value") {
            process_new_value();
        } else if (request === "I-lost-my-value") {
            process_forget_value();
        } else {
            Error("Unknown request in adder", request);
        }
    }
    connect(a1, me);
    connect(a2, me);
    connect(sum, me);
    return me;
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Adder</SCHEMEINLINE> connects the new adder to the designated connectors and
        returns it as its value.  The
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SCHEMEINLINE>me</SCHEMEINLINE>, which represents the
        adder, acts as a dispatch to the local
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.  The following
        <QUOTE>syntax interfaces</QUOTE> (see footnote<SPACE/><REF NAME="foot:object-syntax"/> in
        section<SPACE/><REF NAME="sec:circuit-simulator"/>) are used in conjunction with the
        dispatch:

        <SNIPPET EVAL="no">
          <SCHEME>
            <!--  \indcode*{inform-about-value} -->
            (define (inform-about-value constraint)
            (constraint 'I-have-a-value))

            <!--  \indcode*{inform-about-no-value} -->
            (define (inform-about-no-value constraint)
            (constraint 'I-lost-my-value))
          </SCHEME>
          <JAVASCRIPT>
function inform_about_value(constraint) {
    return constraint("I-have-a-value");
}

function inform_about_no_value(constraint) {
    return constraint("I-lost-my-value");
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        The adder<APOS/>s local
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>process-new-value</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>process_new_value</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is called when the
        adder is informed that one of its connectors has a value. The adder
        first checks to see if both <SCHEMEINLINE>a1</SCHEMEINLINE> and <SCHEMEINLINE>a2</SCHEMEINLINE> have values. If so,
        it tells <SCHEMEINLINE>sum</SCHEMEINLINE> to set its value to the sum of the two addends.
        The <SCHEMEINLINE>informant</SCHEMEINLINE> argument to <SPLITINLINE><SCHEME><SCHEMEINLINE>set-value!</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>set_value</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is <SCHEMEINLINE>me</SCHEMEINLINE>, which is
        the adder object itself.  If <SCHEMEINLINE>a1</SCHEMEINLINE> and <SCHEMEINLINE>a2</SCHEMEINLINE> do not both have
        values, then the adder checks to see if perhaps <SCHEMEINLINE>a1</SCHEMEINLINE> and <SCHEMEINLINE>sum</SCHEMEINLINE>
        have values.  If so, it sets <SCHEMEINLINE>a2</SCHEMEINLINE> to the difference of these two.
        Finally, if <SCHEMEINLINE>a2</SCHEMEINLINE> and <SCHEMEINLINE>sum</SCHEMEINLINE> have values, this gives the adder
        enough information to set <SCHEMEINLINE>a1</SCHEMEINLINE>.  If the adder is told that one of
        its connectors has lost a value, it requests that all of its
        connectors now lose their values.  (Only those values that were set by
        this adder are actually lost.)  Then it runs <SPLITINLINE><SCHEME><SCHEMEINLINE>process-new-value</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>process_new_value</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.
        The reason for this last step is that one or more connectors may still
        have a value (that is, a connector may have had a value that was not
        originally set by the adder), and these values may need to be
        propagated back through the adder.
      </TEXT>

      <TEXT>
        A multiplier is very similar to an adder. It will set its <SCHEMEINLINE>product</SCHEMEINLINE> to 0 if either of the factors is 0, even if the other factor
        is not known.

        <SNIPPET EVAL="no">
          <REQUIRES>Error</REQUIRES>
          <SCHEME>
            <!--  \indcode*{multiplier}[primitive constraint] -->
            (define (multiplier m1 m2 product)
            (define (process-new-value)
            (cond ((or (and (has-value? m1) (= (get-value m1) 0))
            (and (has-value? m2) (= (get-value m2) 0)))
            (set-value! product 0 me))
            ((and (has-value? m1) (has-value? m2))
            (set-value! product
            (* (get-value m1) (get-value m2))
            me))
            ((and (has-value? product) (has-value? m1))
            (set-value! m2
            (/ (get-value product) (get-value m1))
            me))
            ((and (has-value? product) (has-value? m2))
            (set-value! m1
            (/ (get-value product) (get-value m2))
            me))))
            (define (process-forget-value)
            (forget-value! product me)
            (forget-value! m1 me)
            (forget-value! m2 me)
            (process-new-value))
            (define (me request)
            (cond ((eq? request 'I-have-a-value)
            (process-new-value))
            ((eq? request 'I-lost-my-value)
            (process-forget-value))
            (else
            (error "Unknown request - - MULTIPLIER" request))))
            (connect m1 me)
            (connect m2 me)
            (connect product me)
            me)
          </SCHEME>
          <JAVASCRIPT>
function multiplier(m1, m2, product) {
    function process_new_value() {
        if ((has_value(m1) &amp;&amp; get_value(m1) === 0)
         || (has_value(m2) &amp;&amp; get_value(m2) === 0)) {
            set_value(product, 0, me);
        } else if (has_value(m1) &amp;&amp; has_value(m2)) {
            set_value(product, 
                      get_value(m1) * get_value(m2), 
		      me);
        } else if (has_value(product) &amp;&amp; has_value(m1)) {
            set_value(m2, 
                      get_value(product) / get_value(m1), 
                      me);
        } else if (has_value(product) &amp;&amp; has_value(m2)) {
            set_value(m1, 
	              get_value(product) / get_value(m2),
	              me);
        } else {
        }
    }
    function process_forget_value() {
        forget_value(product, me);
        forget_value(m1, me);
        forget_value(m2, me);
        process_new_value();
    }
    function me(request) {
        if (request === "I-have-a-value") {
            process_new_value();
        } else if (request === "I-lost-my-value") {
            process_forget_value();
        } else {
            Error("Unknown request in multiplier", request);
        }
    }
    connect(m1, me);
    connect(m2, me);
    connect(product, me);
    return me;
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        A <SCHEMEINLINE>constant</SCHEMEINLINE> constructor simply sets the value of the designated
        connector.  Any
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>I-have-a-value</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>"I-have-a-value"</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	or
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>I-lost-my-value</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>"I-lost-my-value"</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	message sent to the constant box will produce an error.

        <SNIPPET EVAL="no">
          <REQUIRES>Error</REQUIRES>
          <SCHEME>
            <!-- \indcodeplus*{constant}{(primitive constraint)}-->
            (define (constant value connector)
            (define (me request)
            (error "Unknown request - - CONSTANT" request))
            (connect connector me)
            (set-value! connector value me)
            me)
          </SCHEME>
          <JAVASCRIPT>
function constant(value, connector) {
    function me(request) {
        Error("Unknown request in constant", request);
    }
    connect(connector, me);
    set_value(connector, value, me);
    return me;
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Finally, a probe prints a message about the setting or unsetting of
        the designated connector:

        <SNIPPET EVAL="no">
          <REQUIRES>Error</REQUIRES>
          <SCHEME>
            <!--  \indcode*{probe}[in constraint system] -->
            (define (probe name connector)
            (define (print-probe value)
            (newline)
            (display "Probe: ")
            (display name)
            (display " = ")
            (display value))
            (define (process-new-value)
            (print-probe (get-value connector)))
            (define (process-forget-value)
            (print-probe "?"))
            (define (me request)
            (cond ((eq? request 'I-have-a-value)
            (process-new-value))
            ((eq? request 'I-lost-my-value)
            (process-forget-value))
            (else
            (error "Unknown request - - PROBE" request))))
            (connect connector me)
            me)
          </SCHEME>
          <JAVASCRIPT>
function probe(name, connector) {
    function print_probe(value) {
        display("Probe: " + name + " = " + value);
    }
    function process_new_value() {
        print_probe(get_value(connector));
    }
    function process_forget_value() {
        print_probe("?");
    }
    function me(request) {
        return request === "I-have-a-value"
               ? process_new_value()
               : request === "I-lost-my-value"
                 ? process_forget_value()
                 : Error("Unknown request in probe", 
                         request);
    }
    connect(connector, me);
    return me;
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <SUBHEADING> 
        <NAME>Representing connectors</NAME>
      </SUBHEADING>

      <INDEX>connector(s), in constraint system<SUBINDEX>representing</SUBINDEX></INDEX>

      <TEXT>
        A connector is represented as a procedural object with local state
        variables <SCHEMEINLINE>value</SCHEMEINLINE>, the current value of the connector; <SCHEMEINLINE>informant</SCHEMEINLINE>, the object that set the connector<APOS/>s value; and <SCHEMEINLINE>constraints</SCHEMEINLINE>, a list of the constraints in which the connector
        participates.

        <SNIPPET EVAL="no">
          <REQUIRES>Error</REQUIRES>
          <SCHEME>
            <!--  \indcode*{make-connector} -->
            (define (make-connector)
            (let ((value false) (informant false) (constraints '()))
            (define (set-my-value newval setter)
            (cond ((not (has-value? me))
            (set! value newval)
            (set! informant setter)
            (for-each-except setter
            inform-about-value
            constraints))
            ((not (= value newval))
            (error "Contradiction" (list value newval)))
            (else 'ignored)))
            (define (forget-my-value retractor)
            (if (eq? retractor informant)
            (begin (set! informant false)
            (for-each-except retractor
            inform-about-no-value
            constraints))
            'ignored))
            (define (connect new-constraint)
            (if (not (memq new-constraint constraints))
            (set! constraints 
            (cons new-constraint constraints)))
            (if (has-value? me)
            (inform-about-value new-constraint))
            'done)
            (define (me request)
            (cond ((eq? request 'has-value?)
            (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error "Unknown operation - - CONNECTOR"
            request))))
            me))
          </SCHEME>
          <JAVASCRIPT>
function make_connector() {
    let value = false;
    let informant = false;
    let constraints = null;
    function set_my_value(newval, setter) {
        if (!has_value(me)) {
            value = newval;
            informant = setter;
            for_each_except(setter,
                            inform_about_value,
                            constraints);
        } else if (value !== newval) {
            error("Contradiction " +
                  "(" + stringify(value) + ", " + 
                      + stringify(newval) + ")");
        } else {
            return "ignored";
        }
    }
    function forget_my_value(retractor) {
        if (retractor === informant) {
            informant = false;
            for_each_except(retractor,
                            inform_about_no_value,
                            constraints);
        } else {
            return "ignored";
        }
    }
    function connect(new_contraint) {
        if (is_null(member(new_contraint,
                                 constraints))) {
            constraints = pair(new_contraint, constraints);
        } else {
        }
        if (has_value(me)) {
            inform_about_value(new_contraint);
        } else {
        }

        return "done";
    }
    function me(request) {
        if (request === "has_value") {
            return informant !== false;
        } else if (request === "value") {
            return value;
        } else if (request === "set_value") {
            return set_my_value;
        } else if (request === "forget") {
            return forget_my_value;
        } else if (request === "connect") {
            return connect;
        } else {
            Error("Unknown operation in connector", request);
        }
    }
    return me;
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        The connector<APOS/>s local
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>set-my-value</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>set_my_value</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is called when
        there is a request to set the connector<APOS/>s value.  If the connector
        does not currently have a value, it will set its value and remember as
        <SCHEMEINLINE>informant</SCHEMEINLINE> the constraint that requested the value to be
        set.<FOOTNOTE>The <SCHEMEINLINE>setter</SCHEMEINLINE> might not be a constraint.  In our
          temperature example, we used <SCHEMEINLINE>user</SCHEMEINLINE> as the <SCHEMEINLINE>setter</SCHEMEINLINE>.</FOOTNOTE>
        Then the connector will notify all of its participating
        constraints except the constraint that requested the value to be set.
        This is accomplished using the following iterator, which applies a
        designated
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        to all items in a list except a given one:

        <SNIPPET EVAL="no">
          <SCHEME>
            <!--  \indcode*{for-each-except} -->
            (define (for-each-except exception
            procedure
            list)
            (define (loop items)
            (cond ((null? items) 'done)
            ((eq? (car items) exception) (loop (cdr items)))
            (else (procedure
            (car items))
            (loop (cdr items)))))
            (loop list))
          </SCHEME>
          <JAVASCRIPT>
function for_each_except(exception, fun, list) {
    function loop(items) {
        if (is_null(items)) {
            return "done";
        } else if (head(items) === exception) {
            return loop(tail(items));
        } else {
            fun(head(items));
            return loop(tail(items));
        }
    }
    return loop(list);
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        If a connector is asked to forget its value, it runs the local
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>forget-my-value</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>forget_my_value</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, which first checks to make sure that
        the request is coming from the same object that set the value
        originally.  If so, the connector informs its associated constraints
        about the loss of the value.
      </TEXT>

      <TEXT>
        The local
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SCHEMEINLINE>connect</SCHEMEINLINE> adds the designated new constraint
        to the list of constraints if it is not already in that list.  Then,
        if the connector has a value, it informs the new constraint of this
        fact.
      </TEXT>

      <TEXT>
        The connector<APOS/>s
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SCHEMEINLINE>me</SCHEMEINLINE> serves as a dispatch to the other
        internal
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        and also represents the connector as an object.
        The following
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        provide a syntax interface for the dispatch:

        <SNIPPET EVAL="no">
          <SCHEME>
            <!--  \indcode*{has-value?} -->
            (define (has-value? connector)
            (connector 'has-value?))

            <!--  \indcode*{get-value} -->
            (define (get-value connector)
            (connector 'value))

            <!--  \indcode*{set-value!} -->
            (define (set-value! connector new-value informant)
            ((connector 'set-value!) new-value informant))

            <!--  \indcode*{forget-value!} -->
            (define (forget-value! connector retractor)
            ((connector 'forget) retractor))

            <!--  \indcode*{connect} -->
            (define (connect connector new-constraint)
            ((connector 'connect) new-constraint))
          </SCHEME>
          <JAVASCRIPT>
function has_value(connector) {
    return connector("has_value");
}

function get_value(connector) {
    return connector("value");
}

function set_value(connector, new_value, informant) {
    return (connector("set_value"))(new_value, informant);
}

function forget_value(connector, retractor) {
    return (connector("forget"))(retractor);
}

function connect(connector, new_constraint) {
    return (connector("connect"))(new_constraint);
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <EXERCISE>
        Using primitive multiplier, adder, and constant constraints, define a
        <SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>

        <!-- \indcodeplus{averager}{(constraint)}-->
        <SCHEMEINLINE>averager</SCHEMEINLINE> that takes three connectors
	<SCHEMEINLINE>a</SCHEMEINLINE>, <SCHEMEINLINE>b</SCHEMEINLINE>,
        and <SCHEMEINLINE>c</SCHEMEINLINE> as inputs and establishes the
	constraint that the value of
        <SCHEMEINLINE>c</SCHEMEINLINE> is the average of the values of
	<SCHEMEINLINE>a</SCHEMEINLINE> and <SCHEMEINLINE>b</SCHEMEINLINE>.
      </EXERCISE>

      <EXERCISE>
        <!-- \indcodeplus{squarer}{(constraint)}-->
        Louis Reasoner wants to build a squarer, a constraint device with two
        terminals such that the value of connector
	<SCHEMEINLINE>b</SCHEMEINLINE> on the second
        terminal will always be the square of the value
	<SCHEMEINLINE>a</SCHEMEINLINE> on the first
        terminal.  He proposes the following simple device made from a
        multiplier:

        <SNIPPET EVAL="no">
          <SCHEME>
            (define (squarer a b)
            (multiplier a a b))
          </SCHEME>
          <JAVASCRIPT>
function squarer(a, b) {
    return multiplier(a, a, b);
}
          </JAVASCRIPT>
        </SNIPPET>

        There is a serious flaw in this idea.  Explain.
        <LABEL NAME="ex:squarer-constraint"/>
      </EXERCISE>

      <EXERCISE>
        <!-- \indcodeplus{squarer}{(constraint)}-->
        Ben Bitdiddle tells Louis that one way to avoid the trouble in
        exercise<SPACE/><REF NAME="ex:squarer-constraint"/> is to define a
	squarer as a new primitive constraint.  Fill in the missing
	portions in Ben<APOS/>s outline for a
        <SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
        to implement such a constraint:

        <SNIPPET EVAL="no">
          <REQUIRES>Error</REQUIRES>
          <SCHEME>
            (define (squarer a b)
            (define (process-new-value)
            (if (has-value? b)
            (if (&lt; (get-value b) 0)
            (error "square less than 0 - - SQUARER" (get-value b))
            ^alternative1^)
            ^alternative2^))
            (define (process-forget-value) ^body1^)
            (define (me request) ^body2^)
            ^rest of definition^
            me)
          </SCHEME>
          <JAVASCRIPT>
function squarer(a, b) {
    function process_new_value() {
        if (has_value(b)) {
            if (get_value(b) &lt; 0) {
                Error("Square less than 0 in squarer",
                      get_value(b));
            } else {
                // alternative1...
            } else {
                // alternative2...
            }
        }
    }
    function process_forget_value() {
        // body1...
    }
    function me(request) {
        // body2...
    }
    // rest of definition
    return me;
}
          </JAVASCRIPT>
        </SNIPPET>
      </EXERCISE>

      <EXERCISE>
        Suppose we evaluate the following sequence of expressions in the
        <SPLITINLINE><SCHEME>global</SCHEME><JAVASCRIPT>program</JAVASCRIPT></SPLITINLINE> environment:

        <SNIPPET EVAL="no">
          <SCHEME>
            (define a (make-connector))
            (define b (make-connector))
            (set-value! a 10 'user)
          </SCHEME>
          <JAVASCRIPT>
const a = make_connector();
const b = make_connector();
set_value(a, 10, "user");
          </JAVASCRIPT>
        </SNIPPET>

        At some time during evaluation of the
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>set-value!</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>set_value</JAVASCRIPTINLINE>,</JAVASCRIPT>
	</SPLITINLINE>
	the following expression from the connector<APOS/>s local
        <SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
        is evaluated:

        <SNIPPET EVAL="no">
          <SCHEME>
            (for-each-except setter inform-about-value constraints)
          </SCHEME>
          <JAVASCRIPT>
for_each_except(setter, inform_about_value, constraints);
          </JAVASCRIPT>
        </SNIPPET>

        Draw an environment diagram showing the environment in which the above
        expression is evaluated.
      </EXERCISE>

      <EXERCISE>
        The
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>celsius-fahrenheit-converter</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>celsius_fahrenheit_converter</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
        <SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
        is cumbersome when
        compared with a more expression-oriented style of definition, such as

        <SNIPPET EVAL="no">
          <SCHEME>
            <!--  \indcode*{celsius-fahrenheit-converter}[expression-oriented] -->
            (define (celsius-fahrenheit-converter x)
            (c+ (c* (c/ (cv 9) (cv 5))
            x)
            (cv 32)))

            (define C (make-connector))
            (define F (celsius-fahrenheit-converter C))
          </SCHEME>
          <JAVASCRIPT>
function celsius_fahrenheit_converter(x) {
    return cplus(cmul(cdiv(cv(9), cv(5)), x), cv(32));
}
          </JAVASCRIPT>
        </SNIPPET>

        Here
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>c+</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>cplus</JAVASCRIPTINLINE></JAVASCRIPT>
        </SPLITINLINE>,
        <SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>c*</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>cmul</JAVASCRIPTINLINE></JAVASCRIPT>
        </SPLITINLINE>, etc. are the <QUOTE>constraint</QUOTE>
        versions of the  arithmetic operations.  For example,
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>c+</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>cplus</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	takes two connectors as arguments and returns a connector that is
	related to these by an adder constraint:
        
        <SNIPPET EVAL="no">
          <SCHEME>
            (define (c+ x y)
            (let ((z (make-connector)))
            (adder x y z)
            z))
          </SCHEME>
          <JAVASCRIPT>
function cplus(x, y) {
    const z = make_connector();
    adder(x, y, z);
    return z;
}
          </JAVASCRIPT>
        </SNIPPET>

        Define analogous
        <SPLITINLINE>
	  <SCHEME>procedures</SCHEME>
	  <JAVASCRIPT>functions</JAVASCRIPT>
	</SPLITINLINE>
        <SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>c-</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>cminus</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>,
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>c*</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>cmul</JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE>,
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>c/</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>cdiv</JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE>, and
	<SCHEMEINLINE>cv</SCHEMEINLINE>
        (constant value) that enable us to define compound constraints as in
        the converter example above.<FOOTNOTE>The expression-oriented format
          is convenient because it avoids the need to name the intermediate
          expressions in a computation.  Our original formulation of the
          <INDEX>Algol<SUBINDEX>weakness in handling compound objects</SUBINDEX></INDEX>
          <INDEX>Basic<SUBINDEX>weakness in handling compound objects</SUBINDEX></INDEX>
          <INDEX>Pascal<SUBINDEX>weakness in handling compound objects</SUBINDEX></INDEX>
          <INDEX>expression-oriented vs.<SPACE/>imperative programming style</INDEX>
          <INDEX>imperative vs.<SPACE/>expression-oriented programming style</INDEX>
          constraint language is cumbersome in the same way that many languages
          are cumbersome when dealing with operations on compound data.  For
          example, if we wanted to compute the product
	  <LATEXINLINE>${(a+b)}\cdot{(c+d)}$</LATEXINLINE>, where the
          variables represent vectors, we could work in
	  <QUOTE>imperative style,</QUOTE>
          using
          <SPLITINLINE>
	    <SCHEME>procedures</SCHEME>
	    <JAVASCRIPT>functions</JAVASCRIPT>
	  </SPLITINLINE>
          that set the values of designated vector arguments
          but do not themselves return vectors as values:
          <SNIPPET EVAL="no">
            <SCHEME>
              (v-sum a b temp1)
              (v-sum c d temp2)
              (v-prod temp1 temp2 answer)
            </SCHEME>
            <JAVASCRIPT>
v_sum('a', 'b', temp1);
v_sum('c', 'd', temp2);
v_prod(temp1, temp2, answer);
            </JAVASCRIPT>
          </SNIPPET>
          Alternatively, we could deal with expressions, using
          <SPLITINLINE>
	    <SCHEME>procedures</SCHEME>
	    <JAVASCRIPT>functions</JAVASCRIPT>
	  </SPLITINLINE>
          that return vectors as values, and thus avoid
          explicitly mentioning <SCHEMEINLINE>temp1</SCHEMEINLINE> and
	  <SCHEMEINLINE>temp2</SCHEMEINLINE>:
          <SNIPPET EVAL="no">
            <SCHEME>
              (define answer (v-prod (v-sum a b) (v-sum c d)))
            </SCHEME>
            <JAVASCRIPT>
const answer = v_prod(v_sum('a', 'b'), v_sum('c', 'd'));
            </JAVASCRIPT>
          </SNIPPET>
          Since
	  <SPLITINLINE>
	    <SCHEME>Lisp</SCHEME>
	    <JAVASCRIPT>JavaScript</JAVASCRIPT>
	  </SPLITINLINE>
	  allows us to return compound objects as values of
          <SPLITINLINE>
	    <SCHEME>procedures,</SCHEME>
	    <JAVASCRIPT>functions,</JAVASCRIPT>
	  </SPLITINLINE>
	  we can transform our imperative-style constraint language
          into an expression-oriented style as shown in this exercise.  In
          languages that are impoverished in handling compound objects, such as
          Algol, Basic, and Pascal (unless one explicitly uses Pascal pointer
          variables), one is usually stuck with the imperative style when
          manipulating compound objects.  Given the advantage of the
          expression-oriented format, one might ask if there is any reason to
          have implemented the system in imperative style, as we did in this
          section.  One reason is that the non-expression-oriented constraint
          language provides a handle on constraint objects (e.g., the value of
          the <SCHEMEINLINE>adder</SCHEMEINLINE>
          <SPLITINLINE>
	    <SCHEME>procedure)</SCHEME>
	    <JAVASCRIPT>function)</JAVASCRIPT>
	  </SPLITINLINE>
	  as well as on connector objects.  This is
          useful if we wish to extend the system with new operations that
          communicate with constraints directly rather than only indirectly via
          operations on connectors.  Although it is easy to implement the
          expression-oriented style in terms of the imperative implementation,
          it is very difficult to do the converse.</FOOTNOTE>
      </EXERCISE>
      <INDEX>propagation of constraints|)</INDEX>
      <INDEX>constraint(s)<SUBINDEX>propagation of|)</SUBINDEX></INDEX>

    </SUBSECTION>
