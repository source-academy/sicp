[{"id":"/sicpjs/5.4.2","tag":"TITLE","body":"5.4.2  \n    \n      \n      \n        Evaluating Function Applications"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n        A function application is specified by a combination containing a function\n        expression and argument expressions. The function expression is a subexpression\n        whose value is a function, and the argument expressions are subexpressions whose\n        values are the arguments to which the function should be applied. The metacircular\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":" handles applications by calling\n        itself recursively to evaluate each element of the combination, and then passing\n        the results to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply"},{"body":", which performs the\n        actual function application. The explicit-control evaluator does the same thing;\n        these recursive calls are implemented by\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"go_to"},{"body":" instructions, together with use of the\n        stack to save registers that will be restored after the recursive call returns.\n        Before each call we will be\n\t\n\tcareful to identify which registers must be saved\n        (because their values will be needed later).","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.4.2#footnote-1"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n        As in the metacircular evaluator, operator combinations are transformed into\n        applications of primitive functions corresponding to the operators. This takes\n        place at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_operator_combination"},{"body":", which\n        performs this transformation in place in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":"\n        and falls through to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_application"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.4.2#footnote-2"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n        We begin the evaluation of an application by evaluating the function expression to\n        produce a function, which will later be applied to the evaluated argument\n        expressions. To evaluate the function expression, we move it to the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":" register and go to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":". The environment in the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register is already the correct one in\n        which to evaluate the function expression. However, we save\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" because we will need it later to evaluate\n        the argument expressions. We also extract the argument expressions into\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":" and save this on the stack. We set up\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" so that\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" will resume at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_appl_did_function_expression"},{"body":" after the\n        function expression has been evaluated. First, however, we save the old value of\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":", which tells the controller where to\n        continue after the application.\n\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"\"ev_operator_combination\",\n  assign(\"comp\", list(op(\"operator_combination_to_application\"),\n                      reg(\"comp\"), reg(\"env\"))),\n\"ev_application\",\n  save(\"continue\"),\n  save(\"env\"),\n  assign(\"unev\", list(op(\"arg_expressions\"), reg(\"comp\"))),\n  save(\"unev\"),\n  assign(\"comp\", list(op(\"function_expression\"), reg(\"comp\"))),\n  assign(\"continue\", label(\"ev_appl_did_function_expression\")),\n  go_to(label(\"eval_dispatch\")),"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n        Upon returning from evaluating the function expression, we proceed to evaluate the\n        argument expressions of the application and to accumulate the resulting arguments\n        in a list, held in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":". (This is like the\n        evaluation of a sequence of statements, except that we collect the values.) First\n        we restore the unevaluated argument expressions and the environment. We initialize\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" to an empty list. Then we assign to the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":" register the function that was produced\n        by evaluating the function expression. If there are no argument expressions, we go\n        directly to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_dispatch"},{"body":". Otherwise we save\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":" on the stack and start the\n        argument-evaluation loop:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/5.4.2#footnote-3"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"\"ev_appl_did_function_expression\",\n  restore(\"unev\"), // the argument expressions\n  restore(\"env\"),\n  assign(\"argl\", list(op(\"empty_arglist\"))),\n  assign(\"fun\", reg(\"val\")), // the function\n  test(list(op(\"is_null\"), reg(\"unev\"))),\n  branch(label(\"apply_dispatch\")),\n  save(\"fun\"),"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n        Each cycle of the argument-evaluation loop evaluates an argument expression from\n        the list in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":" and accumulates the result\n        into ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":". To evaluate an argument\n        expression, we place it in the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":" register\n        and go to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":", after setting\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" so that execution will resume with\n        the argument-accumulation phase. But first we save the arguments accumulated so\n        far (held in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":"), the environment (held in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":"), and the remaining argument expressions\n        to be evaluated (held in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":"). A special\n        case is made for the evaluation of the last argument expression, which is handled\n        at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_appl_last_arg"},{"body":".\n\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"\"ev_appl_argument_expression_loop\",\n  save(\"argl\"),\n  assign(\"comp\", list(op(\"head\"), reg(\"unev\"))),\n  test(list(op(\"is_last_argument_expression\"), reg(\"unev\"))),\n  branch(label(\"ev_appl_last_arg\")),\n  save(\"env\"),\n  save(\"unev\"),\n  assign(\"continue\", label(\"ev_appl_accumulate_arg\")),\n  go_to(label(\"eval_dispatch\")),"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n        When an argument expression has been evaluated, the value is accumulated into the\n        list held in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":". The argument expression is\n        then removed from the list of unevaluated argument expressions in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":", and the argument-evaluation loop\n        continues.\n\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"\"ev_appl_accumulate_arg\",\n  restore(\"unev\"),\n  restore(\"env\"),\n  restore(\"argl\"),\n  assign(\"argl\", list(op(\"adjoin_arg\"), reg(\"val\"), reg(\"argl\"))),\n  assign(\"unev\", list(op(\"tail\"), reg(\"unev\"))),\n  go_to(label(\"ev_appl_argument_expression_loop\")),"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n        Evaluation of the last argument expression is handled differently, as is the last\n        statement in a sequence. There is no need to save the environment or the list of\n        unevaluated argument expressions before going to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":", since they will not be\n        required after the last argument expression is evaluated. Thus, we return from the\n        evaluation to a special entry point\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_appl_accum_last_arg"},{"body":", which restores the\n        argument list, accumulates the new argument, restores the saved function, and goes\n        off to perform the application.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/5.4.2#footnote-4"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"\"ev_appl_last_arg\",\n  assign(\"continue\", label(\"ev_appl_accum_last_arg\")),\n  go_to(label(\"eval_dispatch\")),\n\"ev_appl_accum_last_arg\",\n  restore(\"argl\"),\n  assign(\"argl\", list(op(\"adjoin_arg\"), reg(\"val\"), reg(\"argl\"))),\n  restore(\"fun\"),\n  go_to(label(\"apply_dispatch\")),"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n        The details of the argument-evaluation loop determine the\n        \n\torder in which the\n        interpreter evaluates the argument expressions of a combination (e.g., left to\n        right or right to left—see exercise ).\n        This order is not determined by the metacircular evaluator, which inherits its\n        control structure from the underlying JavaScript in which it is implemented.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/5.4.2#footnote-5"},{"body":"\n\n        Because we use ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":" in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_appl_argument_expression_loop"},{"body":"\n        to extract successive argument expressions from ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":"\n        and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":" at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_appl_accumulate_arg"},{"body":" to extract the rest of the argument expressions,\n        the explicit-control evaluator will\n\t      evaluate the argument expressions of a combination in left-to-right order,\n        as required by the ECMAScript specification.\n      ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"\n          Function Application\n        ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n        The entry point ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_dispatch"},{"body":" corresponds to\n        the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply"},{"body":" function of the metacircular\n        evaluator. By the time we get to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_dispatch"},{"body":", the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":" register contains the function to apply\n        and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" contains the list of evaluated\n        arguments to which it must be applied. The saved value of\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" (originally passed to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" and saved at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_application"},{"body":"), which tells where to return\n        with the result of the function application, is on the stack. When the application\n        is complete, the controller transfers to the entry point specified by the saved\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":", with the result of the application\n        in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":". As with the metacircular\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply"},{"body":", there are two cases to consider.\n        Either the function to be applied is a primitive or it is a compound function.\n\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"\"apply_dispatch\",\n  test(list(op(\"is_primitive_function\"), reg(\"fun\"))),\n  branch(label(\"primitive_apply\")),\n  test(list(op(\"is_compound_function\"), reg(\"fun\"))),\n  branch(label(\"compound_apply\")),\n  go_to(label(\"unknown_function_type\")),"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n        We assume that each\n        \n\tprimitive is implemented so as to obtain its arguments from\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" and place its result in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":". To specify how the machine handles\n        primitives, we would have to provide a sequence of controller instructions to\n        implement each primitive and arrange for\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"primitive_apply"},{"body":" to dispatch to the\n        instructions for the primitive identified by the contents of\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":". Since we are interested in the structure\n        of the evaluation process rather than the details of the primitives, we will\n        instead just use an ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_primitive_function"},{"body":"\n        operation that applies the function in fun to the arguments in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":". For the purpose of simulating the\n        evaluator with the simulator of section ","tag":"#text"},{"tag":"REF","body":"5.2","href":"/sicpjs/5.2"},{"body":" we use\n        the function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_primitive_function"},{"body":", which\n        calls on the underlying JavaScript system to perform the application, just as we\n        did for the metacircular evaluator in section ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":". After computing the value of the primitive\n        application, we restore ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" and go to\n        the designated entry point.\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"\"primitive_apply\",\n  assign(\"val\", list(op(\"apply_primitive_function\"),\n                     reg(\"fun\"), reg(\"argl\"))),\n  restore(\"continue\"),\n  go_to(reg(\"continue\")),"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n        The sequence of instructions labeled\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compound_apply"},{"body":" specifies the application of\n        \n        compound functions. To apply a compound function, we proceed in a way similar to\n        what we did in the metacircular evaluator. We construct a frame that binds the\n        function's parameters to the arguments, use this frame to extend the environment\n        carried by the function, and evaluate in this extended environment the body of the\n        function.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n        At this point the compound function is in register\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":" and its arguments are in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":". We extract the function's parameters\n        into ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":" and its environment into\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":". We then replace the environment in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" with the environment constructed by\n        extending it with bindings of the parameters to the given arguments. We then\n        extract the body of the function into ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":".\n        The natural next step would be to restore the saved\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" and proceed to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" to evaluate the body and go to\n        the restored continuation with the result in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":", as is done for the last statement of a\n        sequence. But there is a complication!\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n\tThe complication has two aspects. One is that\n        at any point in the evaluation of the body, a\n        \n\treturn statement may require the\n        function to return the value of the return expression as the value of the body.\n        But a return statement may be nested arbitrarily deeply in the body; so the stack\n        at the moment the return statement is encountered is not necessarily the stack\n        that is needed for a return from the function. One way to make it possible to\n        adjust the stack for the return is to put a \\emph{marker} on the stack that can be\n        found by the return code. This is implemented by the\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"push_marker_to_stack"},{"body":" instruction. The return\n        code can then use the\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"revert_stack_to_marker"},{"body":"\n        instruction to restore the stack to the place indicated by the marker before\n        evaluating the return expression.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-6","body":"6","href":"/sicpjs/5.4.2#footnote-6"}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n        The other aspect of the complication is that if the evaluation of the body\n        terminates without executing a return statement, the value of the body must be\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":". To handle this, we set up the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register to point to the entry point\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return_undefined"},{"body":" before going off to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" to evaluate the body. If a\n        return statement is not encountered during evaluation of the body, evaluation of\n        the body will continue at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return_undefined"},{"body":".\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":false,"body":"\"compound_apply\",\n  assign(\"unev\", list(op(\"function_parameters\"), reg(\"fun\"))),\n  assign(\"env\", list(op(\"function_environment\"), reg(\"fun\"))),\n  assign(\"env\", list(op(\"extend_environment\"), \n                     reg(\"unev\"), reg(\"argl\"), reg(\"env\"))),\n  assign(\"comp\", list(op(\"function_body\"), reg(\"fun\"))),\n  push_marker_to_stack(),\n  assign(\"continue\", label(\"return_undefined\")),\n  go_to(label(\"eval_dispatch\")),"}]},{"tag":"TEXT","id":"#p15","child":[{"body":"\n        The only places in the interpreter where the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register is assigned a new value are\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compound_apply"},{"body":" and\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_block"},{"body":" (section ","tag":"#text"},{"tag":"REF","body":"5.4.3","href":"/sicpjs/5.4.3"},{"body":"). Just as in the metacircular evaluator,\n        the new environment for evaluation of a function body is constructed from the\n        environment carried by the function, together with the argument list and the\n        corresponding list of names to be bound.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p16","child":[{"body":"\n        When a return statement is evaluated at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_return"},{"body":", we use the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"revert_stack_to_marker"},{"body":" instruction to restore\n        the stack to its state at the beginning of the function call by removing all\n        values from the stack down to and including the marker. As a consequence,\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore(\"continue\")"},{"body":" will restore the\n        continuation of the function call, which was saved at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_application"},{"body":". We then proceed to evaluate\n        the return expression, whose result will be placed in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and thus be the value returned from the\n        function when we continue after the evaluation of the return expression.\n\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":false,"body":"\"ev_return\",\n  revert_stack_to_marker(),\n  restore(\"continue\"),\n  assign(\"comp\", list(op(\"return_expression\"), reg(\"comp\"))),\n  go_to(label(\"eval_dispatch\")),"}]},{"tag":"TEXT","id":"#p17","child":[{"body":"\n        If no return statement is encountered during evaluation of the function body,\n \t\n\tevaluation continues at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return_undefined"},{"body":", the\n        continuation that was set up at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compound_apply"},{"body":". To return\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":" from the function, we put\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":" into\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and go to the entry point that was put\n        onto the stack at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_application"},{"body":". Before we\n        can restore that continuation from the stack, however, we must remove the marker\n        that was saved at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compound_apply"},{"body":".\n\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":false,"body":"\"return_undefined\",\n  revert_stack_to_marker(),\n  restore(\"continue\"),\n  assign(\"val\", constant(undefined)),\n  go_to(reg(\"continue\")),"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"\n          Return Statements and \n        \n      Tail Recursion\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p18","child":[{"body":"\n    In chapter ","tag":"#text"},{"tag":"REF","body":"1","href":"/sicpjs/1"},{"body":" we said that the process described by a\n    function\n    such as\n        \n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":false,"body":"function sqrt_iter(guess, x) {\n    return is_good_enough(guess, x)\n           ? guess\n           : sqrt_iter(improve(guess, x), x);\n}"},{"body":"\n\n    is an iterative process.  Even though the\n    function\n    is syntactically recursive (defined in terms of itself), it is not logically\n    necessary for an evaluator to save information in passing from one call to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":"\n    to the next.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-7","body":"7","href":"/sicpjs/5.4.2#footnote-7"},{"body":" An\n    evaluator that can execute a\n    function\n    such as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":"\n    without requiring increasing storage as the\n    function\n    continues to call itself is called a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"tail-recursive","tag":"#text"}]},{"body":" evaluator.  \n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p19","child":[{"body":"\n        The metacircular implementation of the evaluator in chapter ","tag":"#text"},{"tag":"REF","body":"4","href":"/sicpjs/4"},{"body":" isn't\n        tail-recursive. It implements a return statement as a\n        constructor of a return value object containing the value to be\n        returned and inspects the result of a function call to see whether it is\n        such an object. If the evaluation of a function body produces a return value\n        object, the return value of the function is the contents of that object;\n        otherwise, the return value is\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":". Both the construction of the\n        return value object and the eventual inspection of the result of the\n        function call are deferred operations, which lead to an accumulation of\n        information on the stack.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p20","child":[{"body":"\n        Our explicit-control evaluator ","tag":"#text"},{"tag":"EM","child":[{"body":"is","tag":"#text"}]},{"body":" tail-recursive, because it does not need to wrap up\n        return values for inspection and thus avoids the buildup of stack from deferred operations.\n        At ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_return"},{"body":", in order to evaluate the expression that\n        computes the return value of a function, we transfer directly to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" with nothing more on the stack\n        than right before the function call. We accomplish this by undoing any saves to\n        the stack by the function (which are useless because we are returning) using\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"revert_stack_to_marker"},{"body":". Then, rather than arranging\n        for ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" to come back here and ","tag":"#text"},{"tag":"EM","child":[{"body":"then","tag":"#text"}]},{"body":"\n        restoring ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" from the stack and\n        continuing at that entry point, we restore\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" from the stack ","tag":"#text"},{"tag":"EM","child":[{"body":"before","tag":"#text"}]},{"body":" going to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" so that\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" will continue at that entry\n        point after evaluating the expression. Finally, we transfer to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" without saving any information\n        on the stack. Thus, when we proceed to evaluate a return expression, the stack is\n        the same as just before the call to the function whose return value we are about\n        to compute. Hence, evaluating a return expression—even if it is a function call\n        (as in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":", where the conditional\n        expression reduces to a call to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":")—will not cause any information to\n        accumulate on the stack.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-8","body":"8","href":"/sicpjs/5.4.2#footnote-8"}]},{"tag":"TEXT","id":"#p21","child":[{"body":"\n        If we did not think to take advantage of the fact that it is unnecessary to\n        hold on to the useless information on the stack while evaluating a return\n        expression, we might have taken the straightforward approach of evaluating\n\tthe return expression, coming back to restore the stack, and finally\n\tcontinuing at\n        the entry point that is waiting for the result of the function call:\n\n        ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n\"ev_return\",  // alternative implementation: not tail-recursive\n  assign(\"comp\", list(op(\"return_expression\"), reg(\"comp\"))),\n  assign(\"continue\", label(\"ev_restore_stack\")),\n  go_to(label(\"eval_dispatch\")),\n\"ev_restore_stack\",\n  revert_stack_to_marker(),    // undo saves in current function\n  restore(\"continue\"),         // undo save at $\\texttt{ev\\char`_application}$\n  go_to(reg(\"continue\")),\n          "}]},{"tag":"TEXT","id":"#p22","child":[{"body":"\n    This may seem like a minor change to our previous code for evaluation of \n    return statements:\n    \n    The only difference is that we delay undoing any register saves to the stack until\n    after the evaluation of the return expression.\n\n    The interpreter will still give the same value for any expression. But this change\n    is fatal to the tail-recursive implementation, because we must now come back after\n    evaluating the return expression in order\n    to undo the (useless) register saves.\n\n    These extra saves will accumulate during a nest of\n    function\n    calls.\n\n    Consequently, processes such as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":"\n    will require space proportional to the number of iterations rather than requiring\n    constant space.\n\n    This difference can be significant. For example,\n    \n    with tail recursion, an infinite loop can be expressed using only the\n    function-call and return mechanisms:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":false,"body":"function count(n) {\n    display(n);\n    return count(n + 1);\n}"},{"body":"\n\n    Without tail recursion, such a\n    function\n    would eventually run out of stack space, and expressing a true iteration\n    would require some control mechanism other than\n    function\n    call.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p23","child":[{"body":"\n        Note that our JavaScript implementation requires the use of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return"},{"body":" in order to be tail-recursive.\n        Because the undoing of the register saves takes place at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_return"},{"body":", removing\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return"},{"body":" from the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"count"},{"body":" function above will cause it to\n        eventually run out of stack space. This explains the use of\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return"},{"body":" in the infinite driver loops in\n        chapter ","tag":"#text"},{"tag":"REF","body":"4","href":"/sicpjs/4"},{"body":".\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.22","id":"#ex-5.22","child":[{"body":"\n        Explain how the\n        \n\tstack builds up if ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return"},{"body":" is\n        removed from ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"count"},{"body":":\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":13,"eval":false,"body":"function count(n) {\n    display(n);\n    count(n + 1);\n}"}]},{"tag":"EXERCISE","title":"Exercise 5.23","id":"#ex-5.23","child":[{"body":"\n        Implement the equivalent of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"push_marker_to_stack"},{"body":" by\n        using ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compound_apply"},{"body":" to store a special marker\n        value on the stack. Implement the equivalent of\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"revert_stack_to_marker"},{"body":" at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_return"},{"body":" and\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return_undefined"},{"body":" as a loop that repeatedly\n        performs a ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":" until it hits the\n        marker. Note that this will require restoring a value to a register other than the one it\n        was saved from. (Although we are careful to avoid that in our evaluator, our stack\n        implementation actually allows it. See exercise ","tag":"#text"},{"tag":"REF","body":"5.10","href":"/sicpjs/5.2.3#ex-5.10"},{"body":".)\n        This is necessary because the only way to pop from the stack is by\n        restoring to a register.\n\n        Hint: You will need to create a unique constant to serve as the marker, for\n        example with ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"const marker = list(\"marker\")"},{"body":".\n        Because ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list"},{"body":" creates a new pair, it cannot be\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"==="},{"body":" to anything else on the stack.\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.24","id":"#ex-5.24","child":[{"body":"\n        Implement\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"push_marker_to_stack"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"revert_stack_to_marker"},{"body":" as register-machine\n        instructions, following the implementation of\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" and\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":" in section ","tag":"#text"},{"tag":"REF","body":"5.2.3","href":"/sicpjs/5.2.3"},{"body":". Add functions\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"push_marker"},{"body":" and\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pop_marker"},{"body":" to access stacks, mirroring the\n        implementation of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"push"},{"body":" and\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pop"},{"body":" in section ","tag":"#text"},{"tag":"REF","body":"5.2.1","href":"/sicpjs/5.2.1"},{"body":". Note that you do not\n        need to actually insert a marker into the stack. Instead, you can add a local\n        state variable to the stack model to keep track of the position of the last ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":"\n        before each ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"push_marker_to_stack"},{"body":".\n        If you choose to put a marker on the stack, see the hint in\n        exercise ","tag":"#text"},{"tag":"REF","body":"5.23","href":"/sicpjs/5.4.2#ex-5.23"},{"body":".\n      ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.4.2#footnote-link-1","child":[{"body":"This is an important but\n        subtle point in translating algorithms from a procedural language, such as\n        JavaScript, to a register-machine language. As an alternative to saving only what\n        is needed, we could save all the registers (except\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":") before each recursive call. This is\n        called a\n\t","tag":"#text"},{"tag":"EM","child":[{"body":"framed-stack","tag":"#text"}]},{"body":" discipline.\n        This would work but might save more registers than necessary; this could be an\n        important consideration in a system where stack operations are expensive. Saving\n        registers whose contents will not be needed later may also hold on to useless data\n        that could otherwise be garbage-collected, freeing space to be reused.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.4.2#footnote-link-2","child":[{"body":"\n        We assume that the syntax transformer\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"operator_combination_to_application"},{"body":" is\n        available as a machine operation. In an actual implementation built from\n        scratch, we would use our explicit-control evaluator to interpret a JavaScript\n        program that performs source-level transformations like this one and\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"function_decl_to_constant_decl"},{"body":"\n\tin a syntax phase that runs before execution.\n        ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/5.4.2#footnote-link-3","child":[{"body":"We add to the evaluator data-structure\n        functions in section ","tag":"#text"},{"tag":"REF","body":"4.1.3","href":"/sicpjs/4.1.3"},{"body":" the following\n        two functions for manipulating argument lists:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":14,"eval":false,"body":"function empty_arglist() { return null; }\n\nfunction adjoin_arg(arg, arglist) {\n    return append(arglist, list(arg));\n}"},{"body":"\n        We also make use of an additional syntax function to test for the last argument expression\n        in an application:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":15,"eval":false,"body":"function is_last_argument_expression(arg_expression) {\n    return is_null(tail(arg_expression));\n}"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/5.4.2#footnote-link-4","child":[{"body":"The optimization of treating the last\n        argument expression specially is known as\n\t","tag":"#text"},{"tag":"EM","child":[{"body":"evlis tail recursion","tag":"#text"}]},{"body":" (see\n\tWand 1980).\n        We could be somewhat more efficient in the argument evaluation loop if we made\n        evaluation of the first argument expression a special case too. This would permit\n        us to postpone initializing ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" until after\n        evaluating the first argument expression, so as to avoid saving\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" in this case. The compiler in\n        section ","tag":"#text"},{"tag":"REF","body":"5.5","href":"/sicpjs/5.5"},{"body":" performs this optimization. (Compare\n        the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"construct_arglist"},{"body":" function of\n        section ","tag":"#text"},{"tag":"REF","body":"5.5.3","href":"/sicpjs/5.5.3"},{"body":".)","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/5.4.2#footnote-link-5","child":[{"body":"\n        The order of argument-expression evaluation by the function\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list_of_values"},{"body":" in the metacircular\n        evaluator is determined by the order of evaluation of the arguments to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":", which is used to construct the\n        argument list.\n\t\n\tThe version of\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list_of_values"},{"body":" in footnote ","tag":"#text"},{"tag":"REF","body":3,"href":"/sicpjs/4.1.1#footnote-3"},{"body":" of section ","tag":"#text"},{"tag":"REF","body":"4.1","href":"/sicpjs/4.1"},{"body":"\n        calls ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":" directly; the version in the\n        text uses ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"map"},{"body":", which calls\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":". (See exercise ","tag":"#text"},{"tag":"REF","body":"4.1","href":"/sicpjs/4.1.1#ex-4.1"},{"body":".)","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-6","count":6,"href":"/sicpjs/5.4.2#footnote-link-6","child":[{"body":"The special instructions\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"push_marker_to_stack"},{"body":" and\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"revert_stack_to_marker"},{"body":" are not strictly\n        necessary and could be implemented by explicitly pushing and popping a marker\n        value onto and off the stack. Anything that could not be confused with a value in\n        the program can be used as a marker. See exercise ","tag":"#text"},{"tag":"REF","body":"5.23","href":"/sicpjs/5.4.2#ex-5.23"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-7","count":7,"href":"/sicpjs/5.4.2#footnote-link-7","child":[{"body":"We saw in\n    section ","tag":"#text"},{"tag":"REF","body":"5.1","href":"/sicpjs/5.1"},{"body":" how to\n    implement such a process with a register machine that had no stack; the\n    state of the process was stored in a fixed set of registers.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-8","count":8,"href":"/sicpjs/5.4.2#footnote-link-8","child":[{"body":"This implementation of tail recursion is one\n        variety of a well-known optimization technique used by many compilers. In\n        compiling a function that ends with a function call, one can replace the call by a\n        jump to the called function's entry point. Building this strategy into the\n        interpreter, as we have done in this section, provides the optimization uniformly\n        throughout the language.","tag":"#text"}]}]