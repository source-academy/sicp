  <SECTION WIP="yes">
    <NAME>Modeling with Mutable Data</NAME>
    <LABEL NAME="sec:mutable-data"/>
    <INDEX>mutable data objects|(</INDEX>

    <SECTIONCONTENT/>

    <TEXT>
      Chapter<SPACE/>2 dealt with compound data as a means for constructing
      computational objects that have several parts, in order to model
      real-world objects that have several aspects.  In that chapter we
      introduced the discipline of data abstraction, according to which data
      structures are specified in terms of constructors, which create data
      objects, and selectors, which access the parts of compound data
      objects.  But we now know that there is another aspect of data that
      chapter<SPACE/>2 did not address.  The desire to model systems composed of
      objects that have changing state leads us to the need to modify
      compound data objects, as well as to construct and select from them.
      In order to model compound objects with changing state, we will design
      data abstractions to include, in addition to selectors and
      constructors, operations called 
      <INDEX>mutator</INDEX>
      <EM>mutators</EM>, which modify data
      objects.  For instance, modeling a banking system requires us to
      change account balances.  Thus, a data structure for representing bank
      accounts might admit an operation

      <SNIPPET EVAL="no" LATEX="yes">
        <SCHEME>
          (set-balance! ^account^ ^new-value^)
        </SCHEME>
        <JAVASCRIPT>
set_balance($\textit{account}$, $\textit{new-value}$)
  </JAVASCRIPT>
      </SNIPPET>
      that changes the balance of the designated account to the designated
      new value.  Data objects for which mutators are defined are known as
      <EM>mutable data objects</EM>.
    </TEXT>

    <TEXT>
      Chapter<SPACE/>2 introduced pairs as a general-purpose <QUOTE>glue</QUOTE> for
      synthesizing compound data.  We begin this section by defining basic
      mutators for pairs, so that pairs can serve as building blocks for
      constructing mutable data objects.  These mutators greatly enhance the
      representational power of pairs, enabling us to build data structures
      other than the sequences and trees that we worked with in
      section<SPACE/><REF NAME="sec:hierarchical-data"/>.  We also present some examples of
      simulations in which complex systems are modeled as collections of
      objects with local state.
    </TEXT>

    <!-- Subsection 1 : Mutable List Structure -->
    &subsection3.3.1;

    <!-- Subsection 2 : Representing Queues -->
    &subsection3.3.2;

    <!-- Subsection 3 : Representing Tables -->
    &subsection3.3.3;
        
    <!-- Subsection 4 : A Simulator for Digital Circuits -->
    &subsection3.3.4;

    <!-- Subsection 5 : Propagation of Constraints -->
    &subsection3.3.5;

  </SECTION>
