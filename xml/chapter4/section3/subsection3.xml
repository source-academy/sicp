<SUBSECTION>
  <NAME>
    Implementing the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Amb</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    Evaluator
  </NAME>

  <LABEL NAME="sec:amb-implementation"/>
  <INDEX>nondeterministic evaluator|(</INDEX>

  <TEXT>
    The evaluation of an ordinary
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    expression may return a value, may never terminate, or may signal an error.
    In nondeterministic
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    the evaluation of an expression may in addition result in the discovery of
    a dead end, in which case evaluation must backtrack to a previous choice
    point.  The interpretation of nondeterministic
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    is complicated by this extra case.
  </TEXT>

  <TEXT>
    <INDEX>analyzing evaluator
    <SUBINDEX>as basis for nondeterministic evaluator</SUBINDEX></INDEX>
    We will construct the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator for
    nondeterministic
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    by modifying the analyzing evaluator of
    section<SPACE/><REF NAME="sec:separating-analysis"/>.<FOOTNOTE>We chose to
    implement the lazy evaluator in
    section<SPACE/><REF NAME="sec:lazy-evaluation"/> as a modification of the
    ordinary metacircular evaluator of
    section<SPACE/><REF NAME="sec:core-of-evaluator"/>.  In contrast, we will
    base the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator on the analyzing
    evaluator of section<SPACE/><REF NAME="sec:separating-analysis"/>, because
    the execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in that evaluator provide a convenient framework for implementing
    backtracking.</FOOTNOTE> As in the analyzing evaluator, evaluation of an
    expression is accomplished by calling an 
    <INDEX>execution
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    produced by analysis of
    that expression.  The difference between the interpretation of ordinary
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    and the interpretation of nondeterministic
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    will be entirely
    in the execution
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <SUBHEADING>
    <NAME>
      Execution
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      and continuations
    </NAME>
  </SUBHEADING>

  <INDEX>continuation<SUBINDEX>in nondeterministic evaluator|(</SUBINDEX></INDEX>
  <TEXT>
    <INDEX>execution
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    Recall that the execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for the ordinary evaluator take one argument: the environment of execution.
    In contrast, the execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator take three arguments:
    the environment, and two
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    called
    <SPLITINLINE>
      <SCHEME><EM>continuation procedures</EM>.</SCHEME>
      <JAVASCRIPT><EM>continuation functions</EM>.</JAVASCRIPT>
    </SPLITINLINE>
    The evaluation of an expression will finish by calling one of these two
    continuations: If the evaluation results in a value, the 
    <INDEX>success continuation (nondeterministic evaluator)</INDEX>
    <EM>success continuation</EM> is called with that value; if the evaluation
    results in the discovery of a dead end, the 
    <INDEX>failure continuation (nondeterministic evaluator)</INDEX>
    <EM>failure continuation</EM> is called.  Constructing and calling
    appropriate continuations is the mechanism by which the nondeterministic
    evaluator implements backtracking.
  </TEXT>

  <TEXT>
    It is the job of the success continuation to receive a value and proceed
    with the computation.  Along with that value, the success continuation is
    passed another failure continuation, which is to be called subsequently if
    the use of that value leads to a dead end.
  </TEXT>

  <TEXT>
    It is the job of the failure continuation to try another branch of the
    nondeterministic process.  The essence of the nondeterministic
    language is in the fact that expressions may represent choices among
    alternatives.  The evaluation of such an expression must proceed with
    one of the indicated alternative choices, even though it is not known
    in advance which choices will lead to acceptable results.  To deal
    with this, the evaluator picks one of the alternatives and passes this
    value to the success continuation.  Together with this value, the
    evaluator constructs and passes along a failure continuation that can
    be called later to choose a different alternative.
  </TEXT>

  <TEXT>
    A failure is triggered during evaluation (that is, a failure
    continuation is called) when a user program explicitly rejects the
    current line of attack (for example, a call to
    <SCHEMEINLINE>require</SCHEMEINLINE> may result in execution of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(amb)</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>amb()</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    an expression that always
    fails<EMDASH/>see section<SPACE/><REF NAME="sec:amb"/>).  The failure
    continuation in hand at that point will cause the most recent choice point
    to choose another alternative.  If there are no more alternatives to be
    considered at that choice point, a failure at an earlier choice point
    is triggered, and so on.  Failure continuations are also invoked by
    the driver loop in response to a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<LATEXINLINE>$\texttt{try again}$</LATEXINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    request, to find another value of the expression.
  </TEXT>

  <TEXT>
    In addition, if a side-effect operation (such as assignment to a
    variable) occurs on a branch of the process resulting from a choice,
    it may be necessary, when the process finds a dead end, to undo the
    side effect before making a new choice.  This is accomplished by
    having the side-effect operation produce a failure continuation that
    undoes the side effect and propagates the failure.
  </TEXT>

  <TEXT>
    In summary, failure continuations are constructed by
    <UL>
      <LI>
	<SCHEMEINLINE>amb</SCHEMEINLINE> expressions<EMDASH/>to provide a
	mechanism to make alternative choices if the current choice made by the
	<SCHEMEINLINE>amb</SCHEMEINLINE> expression leads to a dead end;
      </LI>
      <LI>
	the top-level driver<EMDASH/>to provide a mechanism to report failure
	when the choices are exhausted;
      </LI>
      <LI>
	assignments<EMDASH/>to intercept failures and undo assignments
	during backtracking.
      </LI>
    </UL>
  </TEXT>

  <TEXT>
    Failures are initiated only when a dead end is encountered. This occurs
    <UL>
      <LI>
	if the user program executes
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(amb)</SCHEMEINLINE>;</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>amb()</JAVASCRIPTINLINE>;</JAVASCRIPT>
	  </SPLITINLINE>
      </LI>
      <LI>
	if the user types
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>try-again</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <LATEXINLINE>$\texttt{try again}$</LATEXINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	at the top-level driver.
      </LI>

    </UL>
  </TEXT>

  <TEXT>
    Failure continuations are also called during processing of a failure:
    <UL>
      <LI>When the failure continuation created by an assignment finishes
      undoing a side effect, it calls the failure continuation it intercepted,
      in order to propagate the failure back to the choice point that
      led to this assignment or to the top level.

      </LI>
      <LI>When the failure continuation for an <SCHEMEINLINE>amb</SCHEMEINLINE>
      runs out of choices, it calls the failure continuation that was originally
      given to the <SCHEMEINLINE>amb</SCHEMEINLINE>, in order to propagate the
      failure back to the previous choice point or to the top level.
      </LI>
    </UL>
    <INDEX>continuation
    <SUBINDEX>in nondeterministic evaluator|)</SUBINDEX></INDEX>
  </TEXT>

  <SUBHEADING>
    <NAME>Structure of the evaluator</NAME>
  </SUBHEADING>

  <TEXT>
    <!--  \indcode{analyze}[nondeterministic] -->
    The syntax- and data-representation
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator, and also the basic
    <SCHEMEINLINE>analyze</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    are identical to those in the evaluator of
    section<SPACE/><REF NAME="sec:separating-analysis"/>, except for the fact
    that we need additional syntax
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    to recognize
    <SPLITINLINE>
      <SCHEME>
	the <SCHEMEINLINE>amb</SCHEMEINLINE> special
	form:<FOOTNOTE>We
	assume that the evaluator supports <SCHEMEINLINE>let</SCHEMEINLINE>
	(see exercise<SPACE/><REF NAME="ex:implement-analyze-let"/>),
	which we have used in our nondeterministic programs.</FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	the <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> syntactic form:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <NAME>is_amb_amb</NAME>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <SCHEME>
(define (amb? exp) (tagged-list? exp 'amb))

(define (amb-choices exp) (cdr exp))
      </SCHEME>
      <JAVASCRIPT>
function is_amb(stmt) {      
    return is_tagged_list(stmt, "application") &amp;&amp; 
           is_name(function_expression(stmt)) &amp;&amp; 
           symbol_of_name(function_expression(stmt)) === "amb";
}
function amb_choices(stmt) {
    return args(stmt);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
      </SCHEME>
      <JAVASCRIPT>
	The symbol <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> here is no longer
	a name with proper scoping. Whenever the symbol
	<JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> appears as the function
	expression of an application, the evaluator treats the application as
	a nondeterministic choice point.<FOOTNOTE>To avoid confusion, we shall
	refrain from declaring <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> as a
	name in our nondeterministic programs.</FOOTNOTE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    We must also add to the dispatch in <SCHEMEINLINE>analyze</SCHEMEINLINE> a
    clause that will recognize
    <SPLITINLINE>
      <SCHEME>this special form and generate an appropriate execution procedure:
      </SCHEME>
      <JAVASCRIPT>such expressions and generate an appropriate execution
      function:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <NAME>is_amb_case_amb</NAME>
      <EXAMPLE>all_solutions_test_5</EXAMPLE>
      <SCHEME>
((amb? exp) (analyze-amb exp))
      </SCHEME>
      <JAVASCRIPT>
: is_amb(stmt)
? analyze_amb(stmt)
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
      </JAVASCRIPT_RUN>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The top-level
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>ambeval</SCHEMEINLINE> (similar to the version of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    given in section<SPACE/><REF NAME="sec:separating-analysis"/>) analyzes the
    given expression and applies the resulting execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to the given environment, together with two given continuations:
    <SNIPPET HIDE="yes">
      <NAME>analyze_amb_headline</NAME>
      <JAVASCRIPT>
// functions from SICP JS 4.3.3	
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>analyze_amb</NAME>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_3</REQUIRES>
      <REQUIRES>functions_4_1_4</REQUIRES>
      <REQUIRES>analyze_amb_headline</REQUIRES>
      <REQUIRES>is_amb_amb</REQUIRES>
      <REQUIRES>analyze_self_evaluating_amb</REQUIRES>
      <REQUIRES>analyze_variable_amb</REQUIRES>
      <REQUIRES>analyze_lambda_amb</REQUIRES>
      <REQUIRES>analyze_sequence_amb</REQUIRES>
      <REQUIRES>analyze_variable_declaration_amb</REQUIRES>
      <REQUIRES>analyze_assignment_amb</REQUIRES>
      <REQUIRES>analyze_if_amb</REQUIRES>
      <REQUIRES>scan_out_declarations</REQUIRES>
      <REQUIRES>analyze_block_amb</REQUIRES>
      <REQUIRES>analyze_return_statement_amb</REQUIRES>
      <REQUIRES>analyze_application_amb</REQUIRES>
      <REQUIRES>analyze_amb_amb</REQUIRES>
      <SCHEME>
      <!--  \indcode*{analyze}[metacircular] -->
      (define (analyze exp)
      (cond ((self-evaluating? exp) 
            (analyze-self-evaluating exp))
            ((quoted? exp) (analyze-quoted exp))
            ((variable? exp) (analyze-variable exp))
            ((assignment? exp) (analyze-assignment exp))
            ((definition? exp) (analyze-definition exp))
            ((if? exp) (analyze-if exp))
            ((lambda? exp) (analyze-lambda exp))
            ((begin? exp) (analyze-sequence (begin-actions exp)))
            ((cond? exp) (analyze (cond-&gt;if exp)))
            ((application? exp) (analyze-application exp))
            (else
            (error "Unknown expression type - - ANALYZE" exp))))
      </SCHEME>
      <JAVASCRIPT>
function analyze(stmt) {
    return is_self_evaluating(stmt)
           ? analyze_self_evaluating(stmt)
         : is_name(stmt)
           ? analyze_name(stmt)
         : is_constant_declaration(stmt)
           ? analyze_constant_declaration(stmt)
         : is_variable_declaration(stmt)
           ? analyze_variable_declaration(stmt)
         : is_assignment(stmt)
           ? analyze_assignment(stmt)
         : is_conditional_expression(stmt)
           ? analyze_conditional_expression(stmt)
         : is_lambda_expression(stmt)
           ? analyze_lambda_expression(stmt)
         : is_sequence(stmt)
           ? analyze_sequence(sequence_statements(stmt))
         : is_block(stmt)
           ? analyze_block(stmt)
         : is_return_statement(stmt)
           ? analyze_return_statement(stmt)
         : is_amb(stmt)
           ? analyze_amb(stmt)
         : is_application(stmt)
           ? analyze_application(stmt)
         : error(stmt, "Unknown syntax -- analyze");
}
      </JAVASCRIPT>
    </SNIPPET>
      <!--  \indcode*{ambeval} -->
    <SNIPPET>
      <NAME>ambeval</NAME>
      <REQUIRES>analyze_amb</REQUIRES>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
      </SCHEME>
      <JAVASCRIPT>
function ambeval(exp, env, succeed, fail) {      
    return analyze(exp)(env, succeed, fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>success continuation (nondeterministic evaluator)</INDEX>
    <INDEX>failure continuation (nondeterministic evaluator)</INDEX>
    <INDEX>continuation<SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    A success continuation is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of two arguments: the value just obtained and another failure continuation to
    be used if that value leads to a subsequent failure. A failure continuation
    is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of no arguments.  So 
    <INDEX>execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    the general form of an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is
    <SNIPPET EVAL="no">
      <SCHEME>
(lambda (env succeed fail)
  ;; succeed is (lambda (value fail) ^$\ldots$^)
  ;; fail is (lambda () ^$\ldots$^)
  ^$\ldots$^)
      </SCHEME>
      <JAVASCRIPT>
(env, succeed, fail) => {      
    // succeed $is$ (value, fail) => $\ldots$
    // fail $is$ () => $\ldots$
}
      </JAVASCRIPT>
    </SNIPPET>
    For example, executing
    <SPLIT>
      <SCHEME>
	<SNIPPET EVAL="no">
	  <SCHEME>
(ambeval exp
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
	  </SCHEME>
	</SNIPPET>
      </SCHEME>
      <JAVASCRIPT>
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
ambeval($\textit{exp}$,      
    the_global_environment,
    (value, fail) => value,
    () => "failed");
	  </JAVASCRIPT>
	</SNIPPET>
      </JAVASCRIPT>
    </SPLIT>
    will attempt to evaluate the given expression and will return either the
    expression<APOS/>s value (if the evaluation succeeds) or the
    <SPLITINLINE>
      <SCHEME>
	symbol <SCHEMEINLINE>failed</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	string <JAVASCRIPTINLINE>"failed"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    (if the evaluation fails).
    The call to <SCHEMEINLINE>ambeval</SCHEMEINLINE> in the driver loop shown below uses
    much more complicated continuation
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <JAVASCRIPT>functions,</JAVASCRIPT>
    </SPLITINLINE>
    which continue the loop and support the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>try-again</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<LATEXINLINE>$\texttt{try again}$</LATEXINLINE>	
      </JAVASCRIPT>
    </SPLITINLINE>
    request.
  </TEXT>

  <TEXT>
    Most of the complexity of the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator
    results from the mechanics of passing the continuations around as the
    execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    call each other.  In going through the following code, you should compare
    each of the execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    with the corresponding
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for the ordinary evaluator given in
    section<SPACE/><REF NAME="sec:separating-analysis"/>.
  </TEXT>

  <SUBHEADING>
    <NAME>Simple expressions</NAME>
  </SUBHEADING>

  <TEXT>
    The execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for the simplest kinds of expressions are
    essentially the same as those for the ordinary evaluator, except for the
    need to manage the continuations.  The execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    simply succeed with the value of the expression, passing along the failure
    continuation that was passed to them.
    <!--  \indcode{analyze-...}[nondeterministic|(] -->
    <SNIPPET>
      <NAME>analyze_self_evaluating_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
      </SCHEME>
      <JAVASCRIPT>
function analyze_self_evaluating(stmt) {
    return (env, succeed, fail) => succeed(stmt, fail);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>analyze_variable_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
      </SCHEME>
      <JAVASCRIPT>
function analyze_name(stmt) {
    return (env, succeed, fail) =>
           succeed(lookup_symbol_value(symbol_of_name(stmt), env),
                   fail);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>analyze_lambda_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_lambda_expression(stmt) {
    const parameters = lambda_parameters(stmt);
    const body = lambda_body(stmt);
    const bfun = analyze(body);
    return (env, succeed, fail) =>
           succeed(make_function(parameters, bfun, env),
                   fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>failure, in nondeterministic computation
    <SUBINDEX>bug vs.</SUBINDEX></INDEX>
    Notice that looking up a
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>name</JAVASCRIPT>
    </SPLITINLINE>
    always <QUOTE>succeeds.</QUOTE>  If
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>lookup\?variable\?value</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>lookup_name_value</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    fails to find the
    <SPLITINLINE>
      <SCHEME>variable,</SCHEME>
      <JAVASCRIPT>name,</JAVASCRIPT>
    </SPLITINLINE>
    it signals an
    error, as usual.  Such a <QUOTE>failure</QUOTE> indicates a program
    bug<EMDASH/>a reference to an unbound variable; it is not an indication
    that we should try another nondeterministic choice instead of the one that
    is currently being tried.
  </TEXT>

  <SUBHEADING>
    <NAME>Conditionals and sequences</NAME>
  </SUBHEADING>

  <TEXT>
    Conditionals are also handled in a similar way as in the ordinary
    evaluator.  The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    generated by
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>analyze-if</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_conditional_expression</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    invokes the predicate execution
    <SPLITINLINE>
      <SCHEME>procedure
      <SCHEMEINLINE>pproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>function
      <JAVASCRIPTINLINE>pfun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    with a success continuation that checks whether the predicate value is true
    and goes on to execute either the consequent or the alternative.  If the
    execution of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>pproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>pfun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    fails, the original failure continuation for
    the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	conditional
      </JAVASCRIPT>
    </SPLITINLINE>
    expression is called.
    <SNIPPET>
      <NAME>analyze_if_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
   (lambda (env succeed fail)
           (pproc env
                  <EM>;; success continuation for evaluating the predicate</EM>
                  <EM>;; to obtain <SCHEMEINLINE>pred-value</SCHEMEINLINE></EM>
                  (lambda (pred-value fail2)
                    (if (true? pred-value)
                        (cproc env succeed fail2)
                        (aproc env succeed fail2)))
                  <EM>;; failure continuation for evaluating the predicate</EM>
                  fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_conditional_expression(stmt) {      
    const pfun = analyze(cond_expr_pred(stmt));
    const cfun = analyze(cond_expr_cons(stmt));
    const afun = analyze(cond_expr_alt(stmt));
    return (env, succeed, fail) =>
           pfun(env,
                // success continuation for evaluating 
                // the predicate to obtain pred_value
                (pred_value, fail2) =>
                    is_true(pred_value) 
                    ? cfun(env, succeed, fail2)
                    : afun(env, succeed, fail2),
                // failure continuation for evaluating 
                // the predicate		    
                fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Sequences are also handled in the same way as in the previous
    evaluator, except for the machinations in the
    <SPLITINLINE>
      <SCHEME>subprocedure</SCHEME>
      <JAVASCRIPT>subfunction</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>sequentially</SCHEMEINLINE> that are required for passing the
    continuations. Namely, to sequentially execute <SCHEMEINLINE>a</SCHEMEINLINE>
    and then <SCHEMEINLINE>b</SCHEMEINLINE>, we call
    <SCHEMEINLINE>a</SCHEMEINLINE> with a success continuation that calls
    <SCHEMEINLINE>b</SCHEMEINLINE>.
    <SNIPPET>
      <NAME>analyze_sequence_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         ;; success continuation for calling a
         (lambda (a-value fail2)
           (b env succeed fail2))
         ;; failure continuation for calling a
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence - - ANALYZE"))
    (loop (car procs) (cdr procs))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_sequence(stmts) {
    function sequentially(a, b) {
        return (env, succeed, fail) => 
                   a(env, 
                     (a_value, fail2) =>
                        is_return_value(a_value)
                        ? succeed(a_value, fail2)
                        : b(env, succeed, fail2),
                     fail);
    }
    function loop(first_fun, rest_funs) {
        return is_null(rest_funs)
               ? first_fun
               : loop(sequentially(first_fun,
                          head(rest_funs)),
                      tail(rest_funs));
    }
    const funs = map(analyze, stmts);
    return is_null(funs) 
           ? env => undefined
           : loop(head(funs), tail(funs));
}      
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME>Definitions</SCHEME>
	<JAVASCRIPT>Declarations</JAVASCRIPT>
      </SPLITINLINE>
      and assignments
    </NAME>
  </SUBHEADING>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>Definitions</SCHEME>
      <JAVASCRIPT>Declarations</JAVASCRIPT>
    </SPLITINLINE>
    are another case where we must go to some trouble to
    manage the continuations, because it is necessary to evaluate the
    definition-value expression before actually defining the new variable.
    To accomplish this, the
    <SPLITINLINE>
      <SCHEME>definition-value</SCHEME>
      <JAVASCRIPT>declaration-value</JAVASCRIPT>
    </SPLITINLINE>
    execution
    <SPLITINLINE>
      <SCHEME>procedure
      <SCHEMEINLINE>vproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>function
      <SCHEMEINLINE>vfun</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is called with the environment, a success continuation, and the
    failure continuation.  If the execution of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>vproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>vfun</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    succeeds, obtaining a value <SCHEMEINLINE>val</SCHEMEINLINE> for the
    <SPLITINLINE>
      <SCHEME>
	defined variable, the variable is defined and the success is propagated:
      </SCHEME>
      <JAVASCRIPT>
	declared name, the name is declared and the success is propagated:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <NAME>analyze_variable_declaration_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env                        
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_variable_declaration(stmt) {
    const symbol = variable_declaration_symbol(stmt);
    const vfun = analyze(variable_declaration_value(stmt));
    return (env, succeed, fail) => 
              vfun(env,
                   (val, fail2) => {
                       assign_symbol_value(symbol, val, env);
                       return succeed(undefined, fail2);
                   },
                   fail);
}
function analyze_constant_declaration(stmt) {
    const symbol = 
        constant_declaration_symbol(stmt);
    const vfun = analyze(constant_declaration_value(stmt));
    return (env, succeed, fail) => 
              vfun(env,
                   (val, fail2) => {
                       assign_symbol_value(symbol, val, env);
                       return succeed(undefined, fail2);
                   },
                   fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>failure continuation (nondeterministic evaluator)
    <SUBINDEX>constructed by assignment</SUBINDEX></INDEX>
    Assignments are more interesting.  This is the first place where we
    really use the continuations, rather than just passing them around.
    The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for assignments starts out like the one for definitions.  It first attempts
    to obtain the new value to be assigned to the variable. If this evaluation of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>vproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>vfun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>  
    fails, the assignment fails.
  </TEXT>

  <TEXT>
    If
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>vproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>vfun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>  
    succeeds, however, and we go on to make the assignment, we must consider the
    possibility that this branch of the computation might later fail, which will
    require us to backtrack out of the assignment.  Thus, we must arrange to
    undo the assignment as part of the backtracking  process.<FOOTNOTE>We
    didn<APOS/>t worry about undoing
    <SPLITINLINE>
      <SCHEME>definitions,</SCHEME>
      <JAVASCRIPT>declarations,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	since we can
	<INDEX>internal definition
	<SUBINDEX>nondeterministic@in nondeterministic evaluator</SUBINDEX>
	</INDEX>
	assume that internal
	<SPLITINLINE>
	  <SCHEME>definitions</SCHEME>
	  <JAVASCRIPT>declarations</JAVASCRIPT>
	</SPLITINLINE>
	are scanned out
	(section<SPACE/><REF NAME="sec:internal-definitions"/>).
      </SCHEME>
      <JAVASCRIPT>
	since we
	<INDEX>internal definition
	<SUBINDEX>nondeterministic@in nondeterministic evaluator</SUBINDEX>
	</INDEX>
	assume that names are not used prior to the evaluation of their
	declaration, see exercise<SPACE/><REF NAME="ex:internal-defs"/>.
	<SPLITINLINE>
	  <SCHEME>definitions</SCHEME>
	  <JAVASCRIPT>declarations</JAVASCRIPT>
	</SPLITINLINE>
	are scanned out
	(section<SPACE/><REF NAME="sec:internal-definitions"/>).
      </JAVASCRIPT>
    </SPLITINLINE></FOOTNOTE>
  </TEXT>

  <TEXT>
    This is accomplished by giving
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>vproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>vfun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>  
    a success continuation (marked with the comment <QUOTE>*1*</QUOTE> below)
    that saves the old value of the variable before assigning the new value to
    the variable and proceeding from the assignment.  The failure continuation
    that is passed along with the value of the assignment (marked with the
    comment <QUOTE>*2*</QUOTE> below) restores the old value of the variable
    before continuing the failure. That is, a successful assignment provides a
    failure continuation that will intercept a subsequent failure; whatever
    failure would otherwise have called <SCHEMEINLINE>fail2</SCHEMEINLINE> calls
    this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    instead, to undo the assignment before actually calling
    <SCHEMEINLINE>fail2</SCHEMEINLINE>.
    <SNIPPET>
      <NAME>analyze_assignment_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        <EM>; *1*</EM>
               (let ((old-value
                     (lookup-variable-value var env))) 
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    <EM>; *2*</EM>
                            (set-variable-value! var
                                                 old-value
                                                 env)
                            (fail2)))))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_assignment(stmt) {
    const symbol = assignment_symbol(stmt);
    const vfun = analyze(assignment_value(stmt));
    return (env, succeed, fail) =>
        vfun(env,
             (val, fail2) => {              // *1*
                 const old_value = lookup_symbol_value(symbol, env);
                 assign_symbol_value(symbol, val, env);
                 return succeed(val,
                                () => {     // *2*
                                    assign_symbol_value(symbol,
                                                        old_value, 
                                                        env);
                                    return fail2();
                                });
             },
             fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SPLIT>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
      <SUBHEADING>
	<NAME>Return statements and blocks</NAME>
      </SUBHEADING>

      <TEXT>
	Analyzing return statements is straightforward. The execution
	function applies the execution function that results from
	analyzing the return expression to a success continuation that
	calls the original success continuation with the return value
	wrapped in a return value object.
	<SNIPPET>
	  <NAME>analyze_return_statement_amb</NAME>
	  <EXAMPLE>all_solutions_test_4</EXAMPLE>
	  <JAVASCRIPT>
function analyze_return_statement(stmt) {
    const rfun = analyze(return_expression(stmt));
    return (env, succeed, fail) =>
           rfun(env,
                (val, fail2) => succeed(make_return_value(val), fail2),
                fail);
}
	  </JAVASCRIPT>
	</SNIPPET>
	The execution function for blocks calls the body<APOS/>s execution
	function on an extended environment, without changing success or
	failure continuations.
	<SNIPPET>
	  <NAME>analyze_block_amb</NAME>
	  <REQUIRES>list_of_unassigned</REQUIRES>
	  <EXAMPLE>all_solutions_test_4</EXAMPLE>
	  <JAVASCRIPT>
function analyze_block(stmt) {
    const body = block_body(stmt);
    const locals = scan_out_declarations(body);
    const unassigneds = list_of_unassigned(locals);
    const bfun = analyze(body);
    return (env, succeed, fail) =>
           bfun(extend_environment(locals, unassigneds, env),
                succeed, fail);             
}
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>
  
  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME>Procedure</SCHEME>
	<JAVASCRIPT>Function</JAVASCRIPT>
      </SPLITINLINE>
      applications
    </NAME>
  </SUBHEADING>

  <TEXT>
    The execution function 
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for applications contains no new ideas except for the technical complexity
    of managing the continuations.  This complexity arises in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>analyze-application</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>analyze_application</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>  
    due to the need to keep track of the success and failure continuations as
    we evaluate the operands.  We use a
    <SPLITINLINE>
      <SCHEME>procedure <SCHEMEINLINE>get-args</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>function <JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>  
    to evaluate the list of operands, rather than a simple
    <SCHEMEINLINE>map</SCHEMEINLINE> as in the ordinary evaluator.
    <SNIPPET>
      <NAME>analyze_application_amb</NAME>
      <REQUIRES>get_args_amb</REQUIRES>
      <REQUIRES>execute_application_amb</REQUIRES>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_application(stmt) {
    const ffun = analyze(function_expression(stmt));
    const afuns = map(analyze, args(stmt));
    return (env, succeed, fail) =>
               ffun(env,
                    (fun, fail2) =>
                        get_args(afuns, 
                                 env,
                                 (args, fail3) =>
                                     execute_application(fun,
                                         args, succeed, fail3),
                                 fail2),
                    fail); 
}      
      </JAVASCRIPT>
    </SNIPPET>
    <!--  \indcode{analyze-...}[nondeterministic|)] -->
  </TEXT>

  <TEXT>
    In
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-args</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>  
    notice how
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>ing</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>ing</JAVASCRIPT>
    </SPLITINLINE>
    down the list of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>aproc</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>afun</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>  
    execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE>ing</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>ing</JAVASCRIPT>
    </SPLITINLINE>
    up the resulting list of
    <SCHEMEINLINE>args</SCHEMEINLINE> is accomplished by calling each
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>aproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>afun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>  
    in the list with a success continuation that recursively calls
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-args</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>  
    Each of these recursive calls to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-args</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>  
    has a success continuation whose value is the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the newly obtained argument onto the list of accumulated arguments:
    <SNIPPET>
      <NAME>get_args_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
                    <EM>;; success continuation for this <SCHEMEINLINE>aproc</SCHEMEINLINE></EM>
                    (lambda (arg fail2)
                      (get-args (cdr aprocs)
                                env
                                <EM>;; success continuation for recursive</EM>
                                <EM>;; call to <SCHEMEINLINE>get-args</SCHEMEINLINE></EM>
                                (lambda (args fail3)
                                  (succeed (cons arg args)
                                           fail3))
                                fail2))
                    fail)))
      </SCHEME>
      <JAVASCRIPT>
function get_args(afuns, env, succeed, fail) {      
    return is_null(afuns)
        ? succeed(null, fail)
        : head(afuns)(env,
                      // success continuation for this afun
                      (arg, fail2) =>
                          get_args(tail(afuns),
                                   env,
                                   // success continuation for
                                   // recursive call to get_args
                                   (args, fail3) =>
                                       succeed(pair(arg, args),
                                               fail3),
                                   fail2),
                      fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application, which is performed by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>execute\?application</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>execute_application</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>  
    is accomplished in the same way as for the ordinary evaluator, except for
    the need to manage the continuations.
      <!--  \indcode*{execute-application}[nondeterministic] -->
    <SNIPPET>
      <NAME>execute_application_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error
          "Unknown procedure type - - EXECUTE-APPLICATION"
          proc))))
      </SCHEME>
      <JAVASCRIPT>
function execute_application(fun, args, succeed, fail) {
    return is_primitive_function(fun)
        ? succeed(apply_primitive_function(fun, args),
                  fail)
        : is_compound_function(fun) 
        ? function_body(fun)(
              extend_environment(
                  function_parameters(fun),
                  args,
                  function_environment(fun)),
              (body_result, fail2) => 
                 succeed(is_return_value(body_result) 
                         ? return_value_content(body_result)
                         : undefined,
                         fail2),
              fail)
        : error(fun, "unknown function type -- " +
                     "execute_application");
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Evaluating <SCHEMEINLINE>amb</SCHEMEINLINE> expressions</NAME>
  </SUBHEADING>

  <TEXT>
    <INDEX>failure continuation (nondeterministic evaluator)
    <SUBINDEX>constructed by amb@constructed by <SCHEMEINLINE>amb</SCHEMEINLINE>
    </SUBINDEX></INDEX>
    The <SCHEMEINLINE>amb</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>syntactic</JAVASCRIPT>
    </SPLITINLINE>
    form is the key element in the nondeterministic language.  Here we see the
    essence of the interpretation process and the reason for keeping track of
    the continuations.  The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for <SCHEMEINLINE>amb</SCHEMEINLINE> defines a loop
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-next</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>try_next</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    that cycles through the execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for all the possible values of the <SCHEMEINLINE>amb</SCHEMEINLINE>
    expression.  Each execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is called with a failure continuation that will try the next one.  When
    there are no more alternatives to try, the entire
    <SCHEMEINLINE>amb</SCHEMEINLINE> expression fails.
      <!--  \indcode*{analyze-amb} -->
    <SNIPPET>
      <NAME>analyze_amb_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
             succeed
             (lambda ()
               (try-next (cdr choices))))))
      (try-next cprocs))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_amb(exp) {
    const cfuns = map(analyze, amb_choices(exp));
    return (env, succeed, fail) => {
        function try_next(choices) {
            return is_null(choices)
                ? fail()
                : head(choices)(env,
                                succeed,
                                () => try_next(tail(choices)));
        }
        return try_next(cfuns);
    };
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Driver loop</NAME>
  </SUBHEADING>

  <INDEX>driver loop
  <SUBINDEX>nondeterministic@in nondeterministic evaluator</SUBINDEX></INDEX>
  <TEXT>
    <INDEX>failure continuation (nondeterministic evaluator)
    <SUBINDEX>constructed by driver loop</SUBINDEX></INDEX>
    The driver loop for the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator is
    complex, due to the mechanism that permits the user to try again in
    evaluating an expression.  The driver uses a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    called
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>internal-loop</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>internal_loop</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which takes as argument a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>  
	<SCHEMEINLINE>try-again</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>try_again</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The intent is that calling
    <SPLITINLINE><SCHEME>  
      <SCHEMEINLINE>try-again</SCHEMEINLINE>
    </SCHEME>
    <JAVASCRIPT>
      <JAVASCRIPTINLINE>try_again</JAVASCRIPTINLINE>
    </JAVASCRIPT></SPLITINLINE>
    should go on to the next untried alternative in the nondeterministic
    evaluation.
    <SPLITINLINE><SCHEME>  
      <SCHEMEINLINE>Internal-loop</SCHEMEINLINE>
    </SCHEME>
    <JAVASCRIPT>The function
    <JAVASCRIPTINLINE>internal_loop</JAVASCRIPTINLINE>
    </JAVASCRIPT></SPLITINLINE>
    either calls
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>try_again</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in response to the user typing
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<LATEXINLINE>$\texttt{try again}$</LATEXINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    at the driver loop, or else starts a new evaluation by calling
    <SCHEMEINLINE>ambeval</SCHEMEINLINE>.  
  </TEXT>

  <TEXT>
    The failure continuation for this call to
    <SCHEMEINLINE>ambeval</SCHEMEINLINE>
    <!-- %(marked <QUOTE>*2*</QUOTE> below)-->
    informs the user that there are no more values and re-invokes the driver
    loop.
  </TEXT>

  <TEXT>
    The success continuation for the call to <SCHEMEINLINE>ambeval</SCHEMEINLINE>
    <!-- %(marked <QUOTE>*1*</QUOTE> below)-->
    is more subtle.  We print the obtained value and then invoke the internal
    loop again with a
    <SPLITINLINE>
      <SCHEME>  
	<SCHEMEINLINE>try-again</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>try_again</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that will be able to try the next alternative.  This
    <SPLITINLINE>
      <SCHEME>  
	<SCHEMEINLINE>next-alternative</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>next_alternative</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is the second argument that was passed to the success continuation.
    Ordinarily, we think of this second argument as a failure continuation to
    be used if the current evaluation branch later fails.  In this case,
    however, we have completed a successful evaluation, so we can invoke the
    <QUOTE>failure</QUOTE> alternative branch in order to search for additional
    successful evaluations.
    <SNIPPET HIDE="yes">
      <NAME>driver_loop_amb_example</NAME>
      <SCHEME>
(driver-loop)
      </SCHEME>
      <JAVASCRIPT>
driver_loop();
      </JAVASCRIPT>
    </SNIPPET>
    <INDEX>prompts<SUBINDEX>nondeterministic evaluator</SUBINDEX></INDEX>
    <!--  \indcode*{driver-loop}[for nondeterministic evaluator] -->
    <SNIPPET>
      <NAME>driver_loop_amb</NAME>
      <REQUIRES>ambeval</REQUIRES>      
      <REQUIRES>user_print</REQUIRES>
      <REQUIRES>user_read</REQUIRES>
      <EXAMPLE>driver_loop_amb_example</EXAMPLE>
      <SCHEME>
(define input-prompt ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")

(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (ambeval input
                     the-global-environment
                     <EM>;; <SCHEMEINLINE>ambeval</SCHEMEINLINE> success</EM>
                     (lambda (val next-alternative)
                       (announce-output output-prompt)
                       (user-print val)
                       (internal-loop next-alternative))
                    <EM>;; <SCHEMEINLINE>ambeval</SCHEMEINLINE> failure</EM>
                    (lambda ()
                      (announce-output
                       ";;; There are no more values of")
                      (user-print input)
                      (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (driver-loop))))
      </SCHEME>
      <JAVASCRIPT>
const input_prompt = "amb-evaluate input:";
const output_prompt =  "amb-evaluate value:";

function driver_loop() {
    function internal_loop(try_again) {
        const input = user_read(input_prompt);
        if (input === "try again") {
            try_again();
        } else {
            display("Starting a new problem");
            ambeval(parse(input),
                the_global_environment,
                // ambeval success
                (val, next_alternative) => {
                    user_print(output_prompt, val);
                    return internal_loop(next_alternative);
                },
                // ambeval failure
                () => {
                    display("There are no more values of");
                    display(input);
                    return driver_loop();
                });
        }
    }
    return internal_loop(
               () => {
                   display("There is no current problem");
                   return driver_loop();
               });
}
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
const input_prompt = "amb-evaluate input:";
const output_prompt =  "amb-evaluate value:";
function driver_loop() {
    function internal_loop(try_again) {
        const input = user_read(input_prompt);
        if (input === null) {
        display("--- evaluator terminated ---", "");
        } else if (input === "try again") {
            display("----------------------------",
                    input_prompt + "\n" + input + "\n");
            try_again();
        } else {
            display("--- starting new problem ---",
                    input_prompt + "\n" + input + "\n");
            ambeval(parse("{ " + input + " }"),
                the_global_environment,
                // ambeval success
                (val, next_alternative) => {
                    user_print(output_prompt, val);
                    return internal_loop(next_alternative);
                },
                // ambeval failure
                () => {
                    display("----------------------------",
                            "no more values of:\n" + input + "\n");
                    return driver_loop();
                });
        }
    }
    return internal_loop(
               () => {
                   display("---  no current problem  ---", "");
                   return driver_loop();
               });
}
      </JAVASCRIPT_RUN>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The initial call to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>internal-loop</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>internal_loop</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    uses a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>try_again</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that complains that there is no current problem and restarts the driver loop.
    This is the behavior that will happen if the user types
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<LATEXINLINE>$\texttt{try again}$</LATEXINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    when there is no evaluation in progress.
  </TEXT>

  <EXERCISE>
    Implement a new
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>syntactic</JAVASCRIPT>
    </SPLITINLINE>
    form <SCHEMEINLINE>ramb</SCHEMEINLINE> that is like
    <SCHEMEINLINE>amb</SCHEMEINLINE> except that it searches alternatives in a
    random order, rather than from left to right.  Show how this can help with
    Alyssa<APOS/>s problem in exercise<SPACE/><REF NAME="ex:sentence-generate"/>.
    <LABEL NAME="ex:ramb"/>
  </EXERCISE>


  <EXERCISE>
    <SPLITINLINE>
      <SCHEME>
	Implement a new kind of assignment called
	<SCHEMEINLINE>permanent-set!</SCHEMEINLINE> that
      </SCHEME>
      <JAVASCRIPT>
	Implement assignment such that 
      </JAVASCRIPT>
    </SPLITINLINE>
    is not undone upon failure. For example, we can choose two distinct
    elements from a list and count the number of trials required to make a
    successful choice as follows:
    <SNIPPET EVAL="no">
      <SCHEME>
(define count 0)

(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
(a b 2)

;;; Amb-Eval input:
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
let count = 0;

let x = an_element_of("a", "b", "c");
let y = an_element_of("a", "b", "c");
count = count + 1;
require(! x === y);
list(x, y, count);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
Starting a $new$ problem
amb-evaluate value:
["a", ["b", [2, null]]]

amb-evaluate input:
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <SCHEME>
try-again
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Amb-Eval value:
(a c 3)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
try again
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
amb-evaluate value:
["a", ["c", [3, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
	What values would have been displayed if we had used
	<SCHEMEINLINE>set!</SCHEMEINLINE> here rather than
	<SCHEMEINLINE>permanent-set!</SCHEMEINLINE>?
      </SCHEME>
      <JAVASCRIPT>
	What values would have been displayed if we had used
	the original meaning of assignment rather than
	permanent assignment?
      </JAVASCRIPT>
    </SPLIT>
    <LABEL NAME="ex:permanent-set"/>
  </EXERCISE>

  <SPLIT>
    <SCHEME>
      <EXERCISE>
	<LABEL NAME="ex:if-fail_scheme"/>
	Implement a new construct called <SCHEMEINLINE>if-fail</SCHEMEINLINE>
	that permits the user to catch the failure of an expression.
	<SCHEMEINLINE>If-fail</SCHEMEINLINE> takes two expressions. It evaluates
	the first expression as usual and returns as usual if the evaluation
	succeeds. If the evaluation fails, however, the value of the second
	expression is returned, as in the following example:
	<SNIPPET EVAL="no">
	  <SCHEME>
	  </SCHEME>
	  <SCHEMEOUTPUT>
;;; Amb-Eval input:
	  </SCHEMEOUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <SCHEME>
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
	  </SCHEME>
	  <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
all-odd

;;; Amb-Eval input:
	  </SCHEMEOUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <SCHEME>
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
	  </SCHEME>
	  <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
8
	  </SCHEMEOUTPUT>
	</SNIPPET>
      </EXERCISE>
    </SCHEME>
    <JAVASCRIPT>
      <EXERCISE>
	<LABEL NAME="ex:if-fail"/>
	We shall horribly abuse the syntax for conditional statements, by
	implementing a construct of the following form: 
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
if (evaluation_succeeds_take) { $statement$ } else { $alternative$ }
	  </JAVASCRIPT>
	</SNIPPET>
	The construct permits the user to catch the failure of a
	<LATEXINLINE>$\textit{statement}$</LATEXINLINE>. It evaluates the
	<LATEXINLINE>$\textit{statement}$</LATEXINLINE> as usual and returns
	as usual if the evaluation succeeds. If the evaluation fails,
	however, the <LATEXINLINE>$\textit{alternative}$</LATEXINLINE>
	is evaluated, as in the following example:
	<SNIPPET EVAL="no">
	  <JAVASCRIPT>
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
amb-evaluate input:
	  </JAVASCRIPT_OUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <JAVASCRIPT>
if (evaluation_succeeds_take) {
    const x = an_element_of(list(1, 3, 5));
    require(is_even(x));
} else {
    "all odd";
}
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
Starting a $new$ problem
amb-evaluate value:
"all odd"

amb-evaluate input:
	  </JAVASCRIPT_OUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <JAVASCRIPT>
if (evaluation_succeeds_take) {
    const x = an_element_of(list(1, 3, 5, 8));
    require(is_even(x));
    x;
} else {
    "all odd";
}
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
Starting a $new$ problem
amb-evaluate value:
8
	  </JAVASCRIPT_OUTPUT>
	</SNIPPET>
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>

  <EXERCISE>
    <LABEL NAME="ex:combine_permanent_if_fail"/>
    With
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>permanent-set!</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	the new kind of assignment
      </JAVASCRIPT>
    </SPLITINLINE>
    as described in exercise<SPACE/><REF NAME="ex:permanent-set"/> and
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if-fail</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	the construct
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
if (evaluation_succeeds_take) { $\ldots$ } else { $\ldots$ }
      </JAVASCRIPT>
	</SNIPPET>
      </JAVASCRIPT>
    </SPLITINLINE>
    as in exercise<SPACE/><REF NAME="ex:if-fail"/>, what will be the result of
    evaluating
    <SNIPPET EVAL="no">
      <SCHEME>
(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))
      </SCHEME>
      <JAVASCRIPT>
let pairs = null;      
if (evaluation_succeeds_take) {
    const p = prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));
    pairs = pair(p, pairs); // using permanent assignment
    amb();
} else {
    pairs;
}
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:require_special"/>
    <!--  \indcode{require}[as a special form] -->
    If we had not realized that <SCHEMEINLINE>require</SCHEMEINLINE> could be
    implemented as an ordinary
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that uses <SCHEMEINLINE>amb</SCHEMEINLINE>, to be defined by the user as
    part of a nondeterministic program, we would have had to implement it
    as a 
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>syntactic</JAVASCRIPT>
    </SPLITINLINE>
    form. This would require syntax
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
(define (require? exp) (tagged-list? exp 'require))

(define (require-predicate exp) (cadr exp))
      </SCHEME>
      <JAVASCRIPT>
function is_require(stmt) {
    return is_tagged_list(stmt, "require");
}
function require_predicate(stmt) {
    return head(tail(stmt));
}
      </JAVASCRIPT>
    </SNIPPET>
    and a new clause in the dispatch in <SCHEMEINLINE>analyze</SCHEMEINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      ((require? exp) (analyze-require exp))
      </SCHEME>
      <JAVASCRIPT>
: is_require(stmt)
? analyze_require(stmt)
      </JAVASCRIPT>
    </SNIPPET>
    as well the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>analyze-require</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_require</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    that handles <SCHEMEINLINE>require</SCHEMEINLINE>
    expressions.  Complete the following definition of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>analyze-require</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_require</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if ^??^
                   ^??^
                   (succeed 'ok fail2)))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_require(stmt) {
    const pfun = analyze(require_predicate(stmt));
    return (env, succeed, fail) =>
        pfun(env,
             (pred_value, fail2) =>
                 $\langle ?? \rangle$
                 ? $\langle ?? \rangle$
                 : succeed("ok", fail2),
             fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>
  <INDEX>nondeterministic evaluator|)</INDEX>

  <SNIPPET HIDE="yes">
    <NAME>all_solutions</NAME>
    <REQUIRES>ambeval</REQUIRES>
      <JAVASCRIPT>
function all_solutions(input) {
    let solutions = null;	
    function internal_loop(input, try_again) {
        if (input === "try again") {
            try_again();
        } else {
            ambeval(parse("{ " + input + " }"),
                the_global_environment,
                // ambeval success
                (val, next_alternative) => {
                    solutions = pair(val, solutions);
                    return internal_loop("try again", next_alternative);
                },
                // ambeval failure
                () => undefined
                );
        }
    }
    internal_loop(
               input,
               () => {
                   display("// internal error");
               });
    return reverse(solutions);
}
      </JAVASCRIPT>
    </SNIPPET>
  <SNIPPET HIDE="yes">
    <NAME>first_solution</NAME>
    <REQUIRES>ambeval</REQUIRES>
      <JAVASCRIPT>
function first_solution(input) {
    return ambeval(parse("{ " + input + " }"),
                   the_global_environment,
                   (val, next_alternative) => val,
                   () => undefined);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_1</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <EXPECTED>[ 'apple', [ 'banana', [ 'cranberry', null ] ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions("                                            \
function require(p) {                                      \
    return ! p ? amb() : 'Satisfied require';              \
    }                                                      \
function an_element_of(items) {                            \
    require(! is_null(items));                             \
    return amb(head(items), an_element_of(tail(items)));   \
}                                                          \
const xs = list('apple', 'banana', 'cranberry');           \
an_element_of(xs);	                                   ");
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_2</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <EXPECTED>[ 8, [ 35, null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions("                                            \
function require(p) {                                      \
    return ! p ? amb() : 'Satisfied require';              \
    }                                                      \
function an_element_of(items) {                            \
    require(! is_null(items));                             \
    return amb(head(items), an_element_of(tail(items)));   \
}                                                          \
function square(x) {                                       \
    return x * x;                                          \
}                                                          \
function is_divisible(x, y) {                              \
    return x % y === 0;                                    \
}                                                          \
function integers_starting_from(n) {                       \
    return pair(n,                                         \
                () => integers_starting_from(n + 1)        \
               );                                          \
}                                                          \
function is_prime(n) {                                     \
    function iter(ps) {                                    \
        return square(head(ps)) &gt; n                        \
               ? true                                      \
               : is_divisible(n, head(ps))                 \
                 ? false                                   \
                 : iter(stream_tail(ps));                  \
    }                                                      \
    return iter(primes);                                   \
}                                                          \
function stream_tail(xs) {                                 \
    return tail(xs)();                                     \
}                                                          \
function stream_filter(pred, s) {                          \
    return is_null(s)                                      \
           ? null                                          \
           : pred(head(s))                                 \
             ? pair(head(s),                               \
                    () => stream_filter(pred,              \
                                        stream_tail(s)))   \
             : stream_filter(pred,                         \
                             stream_tail(s));              \
}                                                          \
const primes = pair(2,                                     \
                    () => stream_filter(                   \
                              is_prime,                    \
                              integers_starting_from(3))   \
                   );                                      \
function prime_sum_pair(list1, list2) {                    \
    const a = an_element_of(list1);                        \
    const b = an_element_of(list2);                        \
    require(is_prime(a + b));                              \
    return list(a, b);                                     \
}                                                          \
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));       ");
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list_ref(all_solutions("                                            \
function require(p) {                                      \
    return ! p ? amb() : 'Satisfied require';              \
    }                                                      \
function an_element_of(items) {                            \
    require(! is_null(items));                             \
    return amb(head(items), an_element_of(tail(items)));   \
}                                                          \
function square(x) {                                       \
    return x * x;                                          \
}                                                          \
function is_divisible(x, y) {                              \
    return x % y === 0;                                    \
}                                                          \
function integers_starting_from(n) {                       \
    return pair(n,                                         \
                () => integers_starting_from(n + 1)        \
               );                                          \
}                                                          \
function is_prime(n) {                                     \
    function iter(ps) {                                    \
        return square(head(ps)) &gt; n                        \
               ? true                                      \
               : is_divisible(n, head(ps))                 \
                 ? false                                   \
                 : iter(stream_tail(ps));                  \
    }                                                      \
    return iter(primes);                                   \
}                                                          \
function stream_tail(xs) {                                 \
    return tail(xs)();                                     \
}                                                          \
function stream_filter(pred, s) {                          \
    return is_null(s)                                      \
           ? null                                          \
           : pred(head(s))                                 \
             ? pair(head(s),                               \
                    () => stream_filter(pred,              \
                                        stream_tail(s)))   \
             : stream_filter(pred,                         \
                             stream_tail(s));              \
}                                                          \
const primes = pair(2,                                     \
                    () => stream_filter(                   \
                              is_prime,                    \
                              integers_starting_from(3))   \
                   );                                      \
function prime_sum_pair(list1, list2) {                    \
    const a = an_element_of(list1);                        \
    const b = an_element_of(list2);                        \
    require(is_prime(a + b));                              \
    return list(a, b);                                     \
}                                                          \
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));       "),
      4);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_3</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <EXPECTED>[ 'verb', [ 'eats', null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions("                                                      \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
let unparsed = null;                                                 \
const nouns = list('noun', 'student', 'professor', 'cat', 'class');  \
const verbs = list('verb', 'studies', 'lectures', 'eats', 'sleeps'); \
const articles = list('article', 'the', 'a');                        \
function parse_word(word_list) {                                     \
    require(! is_null(unparsed));                                    \
    require(member(head(unparsed), tail(word_list)) !== null);       \
    const found_word = head(unparsed);                               \
    unparsed = tail(unparsed);                                       \
    return list(head(word_list), found_word);                        \
}                                                                    \
function parse_noun_phrase() {                                       \
    return list('noun-phrase',                                       \
                parse_word(articles),                                \
                parse_word(nouns));                                  \
}                                                                    \
function parse_sentence() {                                          \
    return list('sentence',                                          \
                parse_noun_phrase(),                                 \
                parse_word(verbs));                                  \
}                                                                    \
function parse_input(input) {                                        \
    unparsed = input;                                                \
    const sent = parse_sentence();                                   \
    require(is_null(unparsed));                                      \
    return sent;                                                     \
}                                                                    \
parse_input(list('the',  'cat',  'eats'));                           ");
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list_ref(list_ref(all_solutions("                                                      \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
let unparsed = null;                                                 \
const nouns = list('noun', 'student', 'professor', 'cat', 'class');  \
const verbs = list('verb', 'studies', 'lectures', 'eats', 'sleeps'); \
const articles = list('article', 'the', 'a');                        \
function parse_word(word_list) {                                     \
    require(! is_null(unparsed));                                    \
    require(member(head(unparsed), tail(word_list)) !== null);       \
    const found_word = head(unparsed);                               \
    unparsed = tail(unparsed);                                       \
    return list(head(word_list), found_word);                        \
}                                                                    \
function parse_noun_phrase() {                                       \
    return list('noun-phrase',                                       \
                parse_word(articles),                                \
                parse_word(nouns));                                  \
}                                                                    \
function parse_sentence() {                                          \
    return list('sentence',                                          \
                parse_noun_phrase(),                                 \
                parse_word(verbs));                                  \
}                                                                    \
function parse_input(input) {                                        \
    unparsed = input;                                                \
    const sent = parse_sentence();                                   \
    require(is_null(unparsed));                                      \
    return sent;                                                     \
}                                                                    \
parse_input(list('the',  'cat',  'eats'));                           "),
                 0),
        2);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>full_parser</NAME>
      <JAVASCRIPT>
const full_parser = "                                                \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
let unparsed = null;                                                 \
function parse_word(word_list) {                                     \
    require(! is_null(unparsed));                                    \
    require(member(head(unparsed), tail(word_list)) !== null);       \
    const found_word = head(unparsed);                               \
    unparsed = tail(unparsed);                                       \
    return list(head(word_list), found_word);                        \
}                                                                    \
const prepositions = list('prep', 'for', 'to',  'in', 'by', 'with'); \
function parse_prepositional_phrase() {                              \
    return list('prep-phrase',                                       \
                parse_word(prepositions),                            \
                parse_noun_phrase());                                \
}                                                                    \
const nouns = list('noun', 'student', 'professor', 'cat', 'class');  \
const verbs = list('verb', 'studies', 'lectures', 'eats', 'sleeps'); \
                                                                     \
const articles = list('article', 'the', 'a');                        \
function parse_simple_noun_phrase() {                                \
    return list('simple-noun-phrase',                                \
                parse_word(articles),                                \
                parse_word(nouns));                                  \
}                                                                    \
function parse_noun_phrase() {                                       \
    function maybe_extend(noun_phrase) {                             \
        return amb(noun_phrase,                                      \
                   maybe_extend(list('noun-phrase',                  \
                                 noun_phrase,                        \
                                 parse_prepositional_phrase())));    \
    }                                                                \
    return maybe_extend(parse_simple_noun_phrase());                 \
}                                                                    \
function parse_sentence() {                                          \
    return list('sentence',                                          \
                parse_noun_phrase(),                                 \
                parse_verb_phrase());                                \
}                                                                    \
function parse_verb_phrase() {                                       \
    function maybe_extend(verb_phrase) {                             \
        return amb(verb_phrase,                                      \
                   maybe_extend(list('verb-phrase',                  \
                                 verb_phrase,                        \
                                 parse_prepositional_phrase())));    \
    }		                                                     \
    return maybe_extend(parse_word(verbs));                          \
}                                                                    \
function parse_input(input) {                                        \
    unparsed = input;                                                \
    const sent = parse_sentence();                                   \
    require(is_null(unparsed));                                      \
    return sent;                                                     \
}                                                                    ";
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_4</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <REQUIRES>full_parser</REQUIRES>
      <EXPECTED>[ 'article', [ 'the', null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions(full_parser + 
"                                                                   \
parse_input(list('the', 'student', 'with', 'the', 'cat',            \
'sleeps', 'in', 'the', 'class'));                                   ");
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list_ref(list_ref(list_ref(list_ref(list_ref(all_solutions(full_parser + 
"                                                                   \
parse_input(list('the', 'student', 'with', 'the', 'cat',            \
'sleeps', 'in', 'the', 'class'));                                   "),
                                             0),
                                    2),
                           2),
                  2),
         1);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_5</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <REQUIRES>full_parser</REQUIRES>
      <EXPECTED>[ 'prep', [ 'with', null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions(full_parser + 
"                                                                   \
parse_input(list('the', 'professor', 'lectures',                    \
                 'to', 'the', 'student', 'with', 'the', 'cat'));    ");
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
list_ref(list_ref(list_ref(list_ref(list_ref(list_ref(all_solutions(full_parser + 
"                                                                   \
parse_input(list('the', 'professor', 'lectures',                    \
                 'to', 'the', 'student', 'with', 'the', 'cat'));    "),
                                                      1),
                                             2),
                                    2),
                           2),
                  2),
         1);
      </JAVASCRIPT_TEST>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>first_solutions_test_1</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <!-- No test case: command line version seems 
	   too slow for this puzzle                 
      <EXPECTED>what</EXPECTED>                         -->
      <JAVASCRIPT>
first_solution("                                                     \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function distinct(items) {                                           \
    return is_null(items)                                            \
        ? true                                                       \
        : is_null(tail(items))                                       \
          ? true                                                     \
          : is_null(member(head(items), tail(items)))                \
            ? distinct(tail(items))                                  \
            : false;                                                 \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
function multiple_dwelling() {                                       \
    const baker = amb(1, 2, 3, 4, 5);                                \
    const cooper = amb(1, 2, 3, 4, 5);                               \
    const fletcher = amb(1, 2, 3, 4, 5);                             \
    const miller = amb(1, 2, 3, 4, 5);                               \
    const smith = amb(1, 2, 3, 4, 5);                                \
    require(distinct(list(baker, cooper, fletcher, miller, smith))); \
    require(! (baker === 5));                                        \
    require(! (cooper === 1));                                       \
    require(! (fletcher === 5));                                     \
    require(! (fletcher === 1));                                     \
    require(miller &gt; cooper);                                        \
    require(! (math_abs(smith - fletcher) === 1));                   \
    require(! (math_abs(fletcher - cooper) === 1));                  \
    return list(list('baker', baker),                                \
                list('cooper', cooper),                              \
                list('fletcher', fletcher),                          \
                list('miller', miller),                              \
                list('smith', smith));                               \
}                                                                    \
multiple_dwelling();                                                 ");
      </JAVASCRIPT>
    </SNIPPET>
</SUBSECTION>
