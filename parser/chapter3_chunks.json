[
  {
    "source_file": "chapter3.xml",
    "tag_type": "CHAPTER",
    "title": "Modularity, Objects, and State",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 1,
    "content": "The preceding chapters introduced the basic elements from which programs are made. We saw how primitive procedures functions and primitive data are combined to construct compound entities, and we learned that abstraction is vital in helping us to cope with the complexity of large systems. But these tools are not sufficient for designing programs. Effective program synthesis also requires organizational principles that can guide us in formulating the overall design of a program. In particular, we need strategies to help us structure large systems so that they will be modular , that is, so that they can be divided naturally into coherent parts that can be separately developed and maintained."
  },
  {
    "source_file": "chapter3.xml",
    "tag_type": "CHAPTER",
    "title": "Modularity, Objects, and State",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 2,
    "content": "One powerful design strategy, which is particularly appropriate to the construction of programs for"
  },
  {
    "source_file": "chapter3.xml",
    "tag_type": "CHAPTER",
    "title": "Modularity, Objects, and State",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 3,
    "content": "To a large extent, then, the way we organize a large program is dictated by our perception of the system to be modeled. In this chapter we will investigate two prominent organizational strategies arising from two rather different world views of the structure of systems. The first organizational strategy concentrates on objects , viewing a large system as a collection of distinct objects whose behaviors may change over time. An alternative organizational strategy concentrates on the streams of information that flow in the system, much as an electrical engineer views a signal-processing system."
  },
  {
    "source_file": "chapter3.xml",
    "tag_type": "CHAPTER",
    "title": "Modularity, Objects, and State",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 4,
    "content": "Both the object-based approach and the stream-processing approach raise significant linguistic issues in programming. With objects, we must be concerned with how a computational object can change and yet maintain its identity. This will force us to abandon our old substitution model of computation (section ) in favor of a more mechanistic but less theoretically tractable environment model of computation. The difficulties of dealing with objects, change, and identity are a fundamental consequence of the need to grapple with time in our computational models. These difficulties become even greater when we allow the possibility of concurrent execution of programs. The stream approach can be most fully exploited when we decouple simulated time in our model from the order of the events that take place in the computer during evaluation. We will accomplish this using a technique known as delayed evaluation ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 1,
    "content": "Chapter dealt with compound data as a means for constructing computational objects that have several parts, in order to model real-world objects that have several aspects. In that chapter we introduced the discipline of data abstraction, according to which data structures are specified in terms of constructors, which create data objects, and selectors, which access the parts of compound data objects. But we now know that there is another aspect of data that chapter did not address. The desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects, as well as to construct and select from them. In order to model compound objects with changing state, we will design data abstractions to include, in addition to selectors and constructors, operations called mutators , which modify data objects. For instance, modeling a banking system requires us to change account balances. Thus, a data structure for representing bank accounts might admit an operation (set-balance! $account$ $new$-$value$) set_balance( account , new-value ) that changes the balance of the designated account to the designated new value. Data objects for which mutators are defined are known as mutable data objects ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 2,
    "content": "Chapter introduced pairs as a general-purpose glue for synthesizing compound data. We begin this section by defining basic mutators for pairs, so that pairs can serve as building blocks for constructing mutable data objects. These mutators greatly enhance the representational power of pairs, enabling us to build data structures other than the sequences and trees that we worked with in section . We also present some examples of simulations in which complex systems are modeled as collections of objects with local state."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 1,
    "content": "Chapter dealt with compound data as a means for constructing computational objects that have several parts, in order to model real-world objects that have several aspects. In that chapter we introduced the discipline of data abstraction, according to which data structures are specified in terms of constructors, which create data objects, and selectors, which access the parts of compound data objects. But we now know that there is another aspect of data that chapter did not address. The desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects, as well as to construct and select from them. In order to model compound objects with changing state, we will design data abstractions to include, in addition to selectors and constructors, operations called mutators , which modify data objects. For instance, modeling a banking system requires us to change account balances. Thus, a data structure for representing bank accounts might admit an operation (set-balance! $account$ $new$-$value$) set_balance( account , new-value ) that changes the balance of the designated account to the designated new value. Data objects for which mutators are defined are known as mutable data objects ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 2,
    "content": "Chapter introduced pairs as a general-purpose glue for synthesizing compound data. We begin this section by defining basic mutators for pairs, so that pairs can serve as building blocks for constructing mutable data objects. These mutators greatly enhance the representational power of pairs, enabling us to build data structures other than the sequences and trees that we worked with in section . We also present some examples of simulations in which complex systems are modeled as collections of objects with local state."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 1,
    "content": "Chapter dealt with compound data as a means for constructing computational objects that have several parts, in order to model real-world objects that have several aspects. In that chapter we introduced the discipline of data abstraction, according to which data structures are specified in terms of constructors, which create data objects, and selectors, which access the parts of compound data objects. But we now know that there is another aspect of data that chapter did not address. The desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects, as well as to construct and select from them. In order to model compound objects with changing state, we will design data abstractions to include, in addition to selectors and constructors, operations called mutators , which modify data objects. For instance, modeling a banking system requires us to change account balances. Thus, a data structure for representing bank accounts might admit an operation (set-balance! $account$ $new$-$value$) set_balance( account , new-value ) that changes the balance of the designated account to the designated new value. Data objects for which mutators are defined are known as mutable data objects ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 2,
    "content": "Chapter introduced pairs as a general-purpose glue for synthesizing compound data. We begin this section by defining basic mutators for pairs, so that pairs can serve as building blocks for constructing mutable data objects. These mutators greatly enhance the representational power of pairs, enabling us to build data structures other than the sequences and trees that we worked with in section . We also present some examples of simulations in which complex systems are modeled as collections of objects with local state."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 1,
    "content": "Chapter dealt with compound data as a means for constructing computational objects that have several parts, in order to model real-world objects that have several aspects. In that chapter we introduced the discipline of data abstraction, according to which data structures are specified in terms of constructors, which create data objects, and selectors, which access the parts of compound data objects. But we now know that there is another aspect of data that chapter did not address. The desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects, as well as to construct and select from them. In order to model compound objects with changing state, we will design data abstractions to include, in addition to selectors and constructors, operations called mutators , which modify data objects. For instance, modeling a banking system requires us to change account balances. Thus, a data structure for representing bank accounts might admit an operation (set-balance! $account$ $new$-$value$) set_balance( account , new-value ) that changes the balance of the designated account to the designated new value. Data objects for which mutators are defined are known as mutable data objects ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 2,
    "content": "Chapter introduced pairs as a general-purpose glue for synthesizing compound data. We begin this section by defining basic mutators for pairs, so that pairs can serve as building blocks for constructing mutable data objects. These mutators greatly enhance the representational power of pairs, enabling us to build data structures other than the sequences and trees that we worked with in section . We also present some examples of simulations in which complex systems are modeled as collections of objects with local state."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 1,
    "content": "Chapter dealt with compound data as a means for constructing computational objects that have several parts, in order to model real-world objects that have several aspects. In that chapter we introduced the discipline of data abstraction, according to which data structures are specified in terms of constructors, which create data objects, and selectors, which access the parts of compound data objects. But we now know that there is another aspect of data that chapter did not address. The desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects, as well as to construct and select from them. In order to model compound objects with changing state, we will design data abstractions to include, in addition to selectors and constructors, operations called mutators , which modify data objects. For instance, modeling a banking system requires us to change account balances. Thus, a data structure for representing bank accounts might admit an operation (set-balance! $account$ $new$-$value$) set_balance( account , new-value ) that changes the balance of the designated account to the designated new value. Data objects for which mutators are defined are known as mutable data objects ."
  },
  {
    "source_file": "section3.xml",
    "tag_type": "SECTION",
    "title": "Modeling with Mutable Data",
    "parent_title": "Modularity, Objects, and State",
    "depth": 1,
    "paragraph_index": 2,
    "content": "Chapter introduced pairs as a general-purpose glue for synthesizing compound data. We begin this section by defining basic mutators for pairs, so that pairs can serve as building blocks for constructing mutable data objects. These mutators greatly enhance the representational power of pairs, enabling us to build data structures other than the sequences and trees that we worked with in section . We also present some examples of simulations in which complex systems are modeled as collections of objects with local state."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 1,
    "content": "When we studied various ways of representing sets in chapter , we mentioned in section the task of maintaining a table of records , we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 2,
    "content": "We first consider a car s head s point to successive records. These gluing pairs are called the backbone of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a headed list . A headed list has a special backbone pair at the beginning, which holds a dummy record in this case the arbitrarily chosen symbol *table* . string \"*table*\" . Figure Figure shows the box-and-pointer diagram for the table a: 1 b: 2 c: 3 a: 1 b: 2 c: 3 A table represented as a headed list. A table represented as a headed list."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 3,
    "content": "To extract information from a table we use the lookup procedure, function, which takes a key as argument and returns the associated value (or false undefined if there is no value stored under that key). Lookup The function lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. Note that assoc never sees the dummy record. Assoc The function assoc returns the record that has the given key as its car head . Lookup The function lookup then checks to see that the resulting record returned by assoc is not false, undefined , and returns the value (the cdr ) tail ) of the record. lookup1_example make_table1 insert_into_table1 const t = make_table(); insert(\"a\", 10, t); lookup(\"a\", t); lookup1 lookup1_example 10 (define (lookup key table) (let ((record (assoc key (cdr table)))) (if record (cdr record) false))) (define (assoc key records) (cond ((null? records) false) ((equal? key (caar records)) (car records)) (else (assoc key (cdr records))))) function lookup(key, table) { const record = assoc(key, tail(table)); return is_undefined(record) ? undefined : tail(record); } function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by cons ing pair ing the key with the value, and insert this at the head of the table s list of records, after the dummy record. If there already is a record with this key, we set the cdr tail of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record. lookup1 insert_into_table1 (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table))))) 'ok) function insert(key, value, table) { const record = assoc(key, tail(table)); if (is_undefined(record)) { set_tail(table, pair(pair(key, value), tail(table))); } else { set_tail(record, value); } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 5,
    "content": "To construct a new table, we simply create a list containing the symbol *table* : just the string \"*table*\" : make_table1 (define (make-table) (list '*table*)) function make_table() { return list(\"*table*\"); }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 6,
    "content": "In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. Figure Figure shows the box-and-pointer diagram for the table math: +: 43 -: 45 *: 42 letters: a: 97 b: 98 \"math\": \"+\": 43 \"-\": 45 \"*\": 42 \"letters\": \"a\": 97 \"b\": 98 which has two subtables. (The subtables don t need a special header symbol, string, since the key that identifies the subtable serves this purpose.) A two-dimensional table. A two-dimensional table."
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 7,
    "content": "When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. lookup2_example make_table2 insert_into_table2 const t = list(\"*table*\"); insert(\"a\", \"b\", 10, t); lookup(\"a\", \"b\", t); just_assoc function assoc(key, records) { return is_null(records) ? undefined : equal(key, head(head(records))) ? head(records) : assoc(key, tail(records)); } lookup2 just_assoc lookup2_example 10 (define (lookup key-1 key-2 table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) function lookup(key_1, key_2, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 8,
    "content": "To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record ( key-2 , ( key_2 , value ) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above: just_assoc insert_into_table2 (define (insert! key-1 key-2 value table) (let ((subtable (assoc key-1 (cdr table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table))))) 'ok) function insert(key_1, key_2, value, table) { const subtable = assoc(key_1, tail(table)); if (is_undefined(subtable)) { set_tail(table, pair(list(key_1, pair(key_2, value)), tail(table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } return \"ok\"; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 9,
    "content": "The lookup and insert! insert operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate lookup and insert! insert procedures functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion: make_table2 just_assoc (define (make-table) (let ((local-table (list '*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) 'ok) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error \"Unknown operation - - TABLE\" m)))) dispatch)) function make_table() { const local_table = list(\"*table*\"); function lookup(key_1, key_2) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { return undefined; } else { const record = assoc(key_2, tail(subtable)); return is_undefined(record) ? undefined : tail(record); } } function insert(key_1, key_2, value) { const subtable = assoc(key_1, tail(local_table)); if (is_undefined(subtable)) { set_tail(local_table, pair(list(key_1, pair(key_2, value)), tail(local_table))); } else { const record = assoc(key_2, tail(subtable)); if (is_undefined(record)) { set_tail(subtable, pair(pair(key_2, value), tail(subtable))); } else { set_tail(record, value); } } } function dispatch(m) { return m === \"lookup\" ? lookup : m === \"insert\" ? insert : error(m, \"unknown operation -- table\"); } return dispatch; }"
  },
  {
    "source_file": "subsection3.xml",
    "tag_type": "SUBSECTION",
    "title": "Representing Tables",
    "parent_title": "Modeling with Mutable Data",
    "depth": 2,
    "paragraph_index": 10,
    "content": "Using make-table , make_table , we could get and put operations used in section for data-directed programming, as follows: operation_table_example put(\"a\", \"b\", 10); get(\"a\", \"b\"); operation_table make_table2 operation_table_example 10 const operation_table = make_table(); const get = operation_table(\"lookup\"); const put = operation_table(\"insert\"); Get The function get takes as arguments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table . make_table ."
  }
]