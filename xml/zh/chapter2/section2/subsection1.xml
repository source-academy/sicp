<SUBSECTION>
  <NAME>
    Representing Sequences
  </NAME>

  <LABEL NAME="sec:sequences"></LABEL>
  <TEXT>

    One of the useful structures we can build with pairs is a 
    <INDEX>sequence(s)</INDEX>
    <INDEX>sequence(s)<SUBINDEX>represented by pairs</SUBINDEX></INDEX>
    <INDEX>pair(s)<SUBINDEX>used to represent sequence</SUBINDEX></INDEX>
    <EM>sequence</EM><EMDASH></EMDASH>an ordered collection of data objects.  There
    are, of course, many ways to represent sequences in terms of pairs.  One
    particularly straightforward representation is illustrated in
    <SPLITINLINE>
      figure<SPACE></SPACE><REF NAME="fig:sequence-of-pairs_scheme"></REF>,
      <JAVASCRIPT>figure<SPACE></SPACE><REF NAME="fig:sequence-of-pairs"></REF>,
      </JAVASCRIPT>
    </SPLITINLINE>
    where the sequence 1, 2, 3, 4 is represented as a chain of pairs.  The
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of each pair is the
    corresponding item in the chain, and the
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the pair is the next pair in the chain.  The
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the final pair signals the end of the
    <SPLITINLINE>
      
	sequence by pointing to a
	distinguished value that is not a pair,
      
      <JAVASCRIPT>
	sequence,
      </JAVASCRIPT>
    </SPLITINLINE>
    represented in box-and-pointer
    diagrams as a diagonal line
    <INDEX>box-and-pointer notation<SUBINDEX>end-of-list marker</SUBINDEX></INDEX>
    and in programs as
    <INDEX>keywords<SUBINDEX><ORDER>null</ORDER><USE>null</USE></SUBINDEX></INDEX>    
    <INDEX><USE>null</USE> (keyword)<SUBINDEX><ORDER>end</ORDER>as end-of-list marker</SUBINDEX></INDEX>
    <INDEX>end-of-list marker</INDEX>
    <SPLITINLINE>
      the value of the variable nil.
      <JAVASCRIPT>
	JavaScript<APOS></APOS>s primitive value
	<JAVASCRIPTINLINE>null</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The entire sequence is constructed by nested
    <SPLITINLINE>
      cons
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operations:
    <SNIPPET PAGE="99">
      <NAME>cons_example</NAME>
      
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
      
      <JAVASCRIPT>
pair(1, 
     pair(2, 
          pair(3, 
               pair(4, null))));
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch2-Z-G-13.svg"></FIGURE>
          <CAPTION>The sequence 1, 2, 3, 4 represented as a chain of pairs.
	  </CAPTION>
          <LABEL NAME="fig:sequence-of-pairs_scheme"></LABEL>
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch2-Z-G-13.svg"></FIGURE>
          <CAPTION>The sequence 1, 2, 3, 4 represented as a chain of pairs.
	  </CAPTION>
          <LABEL NAME="fig:sequence-of-pairs"></LABEL>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  
  <TEXT>
    Such a sequence of pairs, formed by nested
    <SPLITINLINE>
      
	conses,
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE> applications,
      </JAVASCRIPT>
    </SPLITINLINE>
    is called a
    <INDEX>list(s)</INDEX>
    <EM>list</EM>, and
    <SPLITINLINE>
      Scheme
      <JAVASCRIPT>our JavaScript environment</JAVASCRIPT>
    </SPLITINLINE>
    provides a primitive called 
    <INDEX><USE>list</USE> (primitive function)</INDEX>
    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>list</USE> (\textit{ns})</SUBINDEX></INDEX>
    list to help in constructing 
    lists.<FOOTNOTE>In this book, we use <EM>list</EM> to mean a chain of
    pairs terminated by the end-of-list marker.  In contrast, the term
    <INDEX>list structure<SUBINDEX>list vs.</SUBINDEX></INDEX>
    <INDEX>list(s)<SUBINDEX>list structure vs.</SUBINDEX></INDEX>
    <EM>list structure</EM> refers to any data structure made out of pairs, 
    not just to lists.</FOOTNOTE>
    The above sequence could be produced by
    <INDEX><USE>list</USE> (primitive function)</INDEX>
    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>list</USE> (\textit{ns})</SUBINDEX></INDEX>
    <SPLITINLINE>
      
      (list 1 2 3 4).
      <JAVASCRIPT><JAVASCRIPTINLINE>list(1, 2, 3, 4)</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    In general, 
    <SNIPPET EVAL="no" LATEX="yes">
      
(list a$_{1}$ a$_{2}$ $\ldots$ a$_{n}$)
      
      <JAVASCRIPT>
list(<META>a</META>$_{1}$, <META>a</META>$_{2}$, $\ldots$, <META>a</META>$_{n}$)
      </JAVASCRIPT>
    </SNIPPET>
    is equivalent to
    <SNIPPET EVAL="no" LATEX="yes">
      
(cons a$_{1}$ (cons a$_{2}$ (cons $\ldots$ (cons a$_{n}$ nil) $\ldots$)))
      
      <JAVASCRIPT>
pair(<META>a</META>$_{1}$, pair(<META>a</META>$_{2}$, pair($\ldots$, pair(<META>a</META>$_{n}$, null)$\ldots$)))
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      
        Lisp systems conventionally print lists by printing the sequence of
        elements, enclosed in parentheses.  Thus, the data object in
        figure<SPACE></SPACE><REF NAME="fig:sequence-of-pairs_scheme"></REF>
	is printed as
	(1 2 3 4):
      
      <JAVASCRIPT>
        Our interpreter prints pairs using a textual representation of
	box-and-pointer diagrams that we call <EM>box notation</EM>.
        <INDEX>list(s)<SUBINDEX>printed representation of</SUBINDEX></INDEX>
	<INDEX><JAVASCRIPTINLINE>[</JAVASCRIPTINLINE><SPACE></SPACE><JAVASCRIPTINLINE>,</JAVASCRIPTINLINE><SPACE></SPACE><JAVASCRIPTINLINE>]</JAVASCRIPTINLINE> (box notation for pairs)<ORDER>0a21</ORDER></INDEX>
	<INDEX>box notation for pairs</INDEX>
	<INDEX>pair(s)<SUBINDEX>box notation for</SUBINDEX></INDEX>
	<INDEX>notation in this book<SUBINDEX>box notation for data</SUBINDEX></INDEX>
	The result of <JAVASCRIPTINLINE>pair(1, 2)</JAVASCRIPTINLINE>
        is printed as <JAVASCRIPTINLINE>[1, 2]</JAVASCRIPTINLINE>, and
	the data object in figure<SPACE></SPACE><REF NAME="fig:sequence-of-pairs"></REF> 
        is printed as 
        <JAVASCRIPTINLINE>[1, [2, [3, [4, null]]]]</JAVASCRIPTINLINE>:
      </JAVASCRIPT>
    </SPLIT>
    <SNIPPET PAGE="100">
      <NAME>one_four</NAME>
      <EXAMPLE>one_four_example</EXAMPLE>
      <EXPECTED>[ 2, [ 3, [ 4, null ] ] ]</EXPECTED>
      
(define one-through-four (list 1 2 3 4))
      
      <JAVASCRIPT>
const one_through_four = list(1, 2, 3, 4);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="100">
      <REQUIRES>one_four</REQUIRES>
      <NAME>one_four_example</NAME>
      
one-through-four	    
      
      <SCHEMEOUTPUT>
(1 2 3 4)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
one_through_four;
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
tail(one_through_four);
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
[1, [2, [3, [4, null]]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  <!--  Nice in Scheme is the convention to put question marks behind test 
      functions. This syntax does not work in JavaScript. I use <TT>list</TT>
      for the test, and <TT>list</TT> for the constructor. Note the JavaScript 
      feature of functions with variable numbers of parameters (accessed in the
      function body using <TT>arguments[i]</TT>, see <TT>js/javascript.js</TT>
      for the implementation of <TT>list</TT>).
    -->
  <SPLIT>
    
        Be careful not to confuse the expression
	(list 1 2 3 4) with the list
	(1 2 3 4), which is the result obtained
	when the expression is evaluated.  Attempting to evaluate the
	expression (1 2 3 4) will signal an error
	when the interpreter tries to apply the procedure
        1 to arguments 
        2, 3, 
        and 4.
    
  </SPLIT>
  </TEXT>
  <TEXT>
    We can think of 
    <INDEX>list(s)<SUBINDEX>manipulation with <SPLITINLINE>car<JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE>cdr<JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and <SPLITINLINE>cons<JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    <INDEX><USE>head</USE> (primitive function)<SUBINDEX><ORDER>list</ORDER>as list operation</SUBINDEX></INDEX>
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    as selecting the first item in the list, and of 
    <INDEX><USE>tail</USE> (primitive function)<SUBINDEX><ORDER>list</ORDER>as list operation</SUBINDEX></INDEX>
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    as selecting the sublist consisting of all but the first item.  Nested
    applications of
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    can be used to extract the second, third, and subsequent items in the
    list.<SPLITINLINE><FOOTNOTE>Since nested applications of
    car and cdr are
    cumbersome to write, Lisp dialects provide abbreviations for
    them<EMDASH></EMDASH>for instance, 
    <INDEX>nested applications of car and cdr</INDEX>
     <INDEX><USE>cadr</USE></INDEX> 
     <SNIPPET LATEX="yes">
       
(cadr $\langle arg \rangle$) = (car (cdr $\langle arg \rangle$))
       
     </SNIPPET>
    The names of all such procedures start with c
    and end with r.  Each
    a between them stands for a 
    <INDEX><USE>ca<ELLIPSIS></ELLIPSIS>r</USE></INDEX>
    <INDEX><USE>cd<ELLIPSIS></ELLIPSIS> r</USE></INDEX> 
    car operation and each
    d for a cdr
    operation, to be applied in the same order in which they appear in the
    name.  The names car and 
    cdr persist because simple combinations like
    cadr are
    pronounceable.</FOOTNOTE></SPLITINLINE>
    The constructor 
    <INDEX><USE>pair</USE> (primitive function)<SUBINDEX><ORDER>list</ORDER>as list operation</SUBINDEX></INDEX>
    <SPLITINLINE>
      cons
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    makes a list like the original one, but with an additional item at the
    beginning.
    <SNIPPET PAGE="100">
      <NAME>car_one_four</NAME>
      <REQUIRES>one_four</REQUIRES>
      <EXPECTED>1</EXPECTED>
      
(car one-through-four)
      
      <SCHEMEOUTPUT>
1
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
head(one_through_four);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
1
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET PAGE="100">
      <NAME>cdr_one_four</NAME>
      <REQUIRES>one_four</REQUIRES>
      <EXPECTED>[ 2, [ 3, [ 4, null ] ] ]</EXPECTED>
      
(cdr one-through-four)
      
      <SCHEMEOUTPUT>
(2 3 4)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
tail(one_through_four);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[2, [3, [4, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET PAGE="101">
      <NAME>car_cdr_one_four</NAME>
      <REQUIRES>one_four</REQUIRES>
      <EXPECTED>2</EXPECTED>
      
(car (cdr one-through-four))
      
      <SCHEMEOUTPUT>
2
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
head(tail(one_through_four));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
2
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET PAGE="101">
      <NAME>cons_one_four</NAME>
      <REQUIRES>one_four</REQUIRES>
      <EXPECTED>[ 2, [ 3, [ 4, null ] ] ]</EXPECTED>
      
(cons 10 one-through-four)
      
      <SCHEMEOUTPUT>
(10 1 2 3 4)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
pair(10, one_through_four);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
tail(tail(pair(10, one_through_four)));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
[10, [1, [2, [3, [4, null]]]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET PAGE="101">
      <NAME>cons5_one_four</NAME>
      <REQUIRES>one_four</REQUIRES>
      <EXPECTED>[ 2, [ 3, [ 4, null ] ] ]</EXPECTED>
      
(cons 5 one-through-four)
      
      <SCHEMEOUTPUT>
(5 1 2 3 4)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
pair(5, one_through_four);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
tail(tail(pair(5, one_through_four)));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
[5, [1, [2, [3, [4, null]]]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SPLIT>
    
        The value of nil, used to terminate the
	chain of pairs, can be thought of as a sequence of no elements, the 
        <INDEX>empty list</INDEX>
         <INDEX><USE>nil</USE></INDEX>
        <EM>empty list</EM>.  The word <EM>nil</EM> is a contraction of the
	Latin word <EM>nihil</EM>, which means
	<QUOTE>nothing.</QUOTE><FOOTNOTE>It<APOS></APOS>s remarkable how much energy
	in the standardization of Lisp dialects has been dissipated in
	arguments that are literally over nothing: Should
	nil be an ordinary name? Should the value
	of nil be a symbol?  Should it be a list?
        Should it be a pair?  
         <INDEX><USE>nil</USE><SUBINDEX><ORDER>ordinary</ORDER>as ordinary variable in Scheme</SUBINDEX></INDEX>
        In Scheme, nil is an ordinary name, which
	we use in this section as a variable whose value is the end-of-list
	marker (just as true is an ordinary
	variable that has a true value).  Other dialects of Lisp, including
	Common Lisp, treat nil as a special
	symbol.  The
        <INDEX>Common Lisp<SUBINDEX>treatment of nil</SUBINDEX></INDEX>
        authors of this book, who have endured too many language
	standardization brawls, would like to avoid the entire issue.  Once we
        have introduced quotation in
	section<SPACE></SPACE><REF NAME="sec:symbolic-data"></REF>, we will denote the
	empty list as &apos;() and dispense with the
        variable nil entirely.</FOOTNOTE>
     
    <JAVASCRIPT>
        The value <JAVASCRIPTINLINE>null</JAVASCRIPTINLINE>, used to terminate
	the chain of pairs, can be thought of as a sequence of no elements, the 
        <INDEX>empty list</INDEX>
        <INDEX><USE>null</USE> (keyword)<SUBINDEX><ORDER>empty</ORDER>as empty list</SUBINDEX></INDEX> 
        <EM>empty list</EM>.<FOOTNOTE>The value
	<JAVASCRIPTINLINE>null</JAVASCRIPTINLINE> is used in JavaScript for
	various purposes, but in this book we shall only use it to
	represent the empty list.</FOOTNOTE>
    </JAVASCRIPT>
  </SPLIT>
</TEXT>
<SPLIT>
  <JAVASCRIPT>
    <TEXT>
      Box notation is sometimes difficult to read. In this book, when we want to
      indicate the list nature of a data structure, we will employ the
      alternative
      <INDEX>notation in this book<SUBINDEX>list notation for data</SUBINDEX></INDEX>
      <INDEX>list notation for data</INDEX>
      <EM>list notation</EM>: Whenever possible, list notation uses
      applications
      of list whose evaluation would result in the
      desired structure. For example, instead of the box notation
      <SNIPPET EVAL="no">
	<JAVASCRIPT_OUTPUT>
[1, [[2, 3], [[4, [5, null]], [6, null]]]]
	</JAVASCRIPT_OUTPUT>
      </SNIPPET>
      we write <!--  <PDF_ONLY>\enlargethispage{13pt}</PDF_ONLY>  -->
      <SNIPPET EVAL="no">
	<JAVASCRIPT_OUTPUT>
list(1, [2, 3], list(4, 5), 6)
	</JAVASCRIPT_OUTPUT>
      </SNIPPET>
      in list notation.<FOOTNOTE>Our JavaScript environment provides
      a primitive function
      <JAVASCRIPTINLINE>display_list</JAVASCRIPTINLINE>
      that works like the primitive function
      <JAVASCRIPTINLINE>display</JAVASCRIPTINLINE>, except that
      it uses list notation instead of box notation.
    </FOOTNOTE>
    </TEXT>
  </JAVASCRIPT>
</SPLIT>
  <SUBHEADING>
    <NAME>List operations</NAME>
  </SUBHEADING>

  <INDEX>list(s)<SUBINDEX>operations on</SUBINDEX><OPEN></OPEN></INDEX>
  <INDEX>list(s)<SUBINDEX>techniques for manipulating</SUBINDEX><OPEN></OPEN></INDEX>
  <TEXT>
    The use of pairs to represent sequences of elements as lists is accompanied
    by conventional programming techniques for manipulating lists by
    successively 
    <SPLITINLINE>
      
	<INDEX><USE>cdr</USE> down a list</INDEX>
	<INDEX>list(s)<SUBINDEX><ORDER>cdring</ORDER>cdring down</SUBINDEX></INDEX>
	<QUOTE>cdring down</QUOTE>
	the lists.
      
      <JAVASCRIPT>
	<INDEX>walking down a list with <JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></INDEX>
	<INDEX>list(s)<SUBINDEX>walking down with <JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></SUBINDEX></INDEX>
	using <JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE> to walk down the lists.
      </JAVASCRIPT>
    </SPLITINLINE>
    For example, the
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>list(s)<SUBINDEX><ORDER>nth</ORDER><LATEXINLINE>$n$</LATEXINLINE>th element of</SUBINDEX></INDEX>
    <SPLITINLINE>
      list-ref
      <JAVASCRIPT><JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    takes as arguments a list and a number <LATEXINLINE>$n$</LATEXINLINE> and
    returns the <LATEXINLINE>$n$</LATEXINLINE>th item of the list.  It is
    customary to number the elements of the list beginning with 0.  The method
    for computing
    <SPLITINLINE>
      list-ref
      <JAVASCRIPT><JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is the following:
    <UL>
      <LI>
	For <LATEXINLINE>$n=0$</LATEXINLINE>,
	<SPLITINLINE>
	  list-ref
	  <JAVASCRIPT><JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	should return the
	<SPLITINLINE>
	  car
	  <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	of the list.
      </LI>
      <LI>
	Otherwise,
	<SPLITINLINE>
	  list-ref
	  <JAVASCRIPT><JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	should return  the <LATEXINLINE>$(n-1)$</LATEXINLINE>st item of the
	<SPLITINLINE>
	  cdr
	  <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	of the list.
      </LI>
    </UL>
    <SNIPPET PAGE="101">
      <INDEX><DECLARATION>list_ref</DECLARATION></INDEX>
      <NAME>list_ref</NAME>
      <EXAMPLE>list_ref_example</EXAMPLE>
      
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
      
      <JAVASCRIPT>
function list_ref(items, n) {
    return n === 0
           ? head(items)
           : list_ref(tail(items), n - 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="101">
      <NAME>list_ref_example</NAME>
      <REQUIRES>list_ref</REQUIRES>
      <EXPECTED>16</EXPECTED>
      
(define squares (list 1 4 9 16 25))
(list-ref squares 3)
      
      <SCHEMEOUTPUT>
16
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
const squares = list(1, 4, 9, 16, 25);

list_ref(squares, 3);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
16
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET PAGE="101" HIDE="yes">
      <NAME>manual_squares</NAME>
      
(define squares (list 1 4 9 16 25))
      
      <JAVASCRIPT>
const squares = list(1, 4, 9, 16, 25);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="101" HIDE="yes">
      <NAME>manual_odds</NAME>
      
(define odds (list 1 3 5 7))
      
      <JAVASCRIPT>
const odds = list(1, 3, 5, 7);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    Often we
    <SPLITINLINE>
      
	cdr down the whole list.
      
      <JAVASCRIPT>
	walk down the whole list.
      </JAVASCRIPT>
    </SPLITINLINE>
    To aid in this,
    <SPLITINLINE>
      Scheme
      <JAVASCRIPT>our JavaScript environment</JAVASCRIPT>
    </SPLITINLINE>
    includes a primitive
    predicate
    <INDEX><USE>is_null</USE> (primitive function)</INDEX>
    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>is_null</USE> (\textit{ns})</SUBINDEX></INDEX>
    <INDEX>empty list<SUBINDEX>recognizing with <JAVASCRIPTINLINE>is_null</JAVASCRIPTINLINE></SUBINDEX></INDEX>
    <INDEX><USE>null</USE> (keyword)<SUBINDEX>recognizing with <JAVASCRIPTINLINE>is_null</JAVASCRIPTINLINE></SUBINDEX></INDEX>
    <SPLITINLINE>
      
      null?,
      <JAVASCRIPT><JAVASCRIPTINLINE>is_null</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    which tests whether its argument is the empty list.  The
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>length</USE></INDEX>
    <INDEX>list(s)<SUBINDEX>length of</SUBINDEX></INDEX>
    length, which returns the number of items in
    a list, illustrates this typical pattern of use:
    <SNIPPET PAGE="102">
      <INDEX><DECLARATION>length</DECLARATION><SUBINDEX>recursive version</SUBINDEX></INDEX>
      <NAME>length</NAME>
      <EXAMPLE>length_example</EXAMPLE>
      <EXPECTED>4</EXPECTED>
      
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
      
      <JAVASCRIPT>
function length(items) {
    return is_null(items)
           ? 0
           : 1 + length(tail(items));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="102">
      <NAME>length_example</NAME>
      
(define odds (list 1 3 5 7))
(length odds)
      
      <JAVASCRIPT>
const odds = list(1, 3, 5, 7);

length(odds);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
4
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    The length
    <SPLITINLINE>procedure
    <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    implements a simple recursive plan. The reduction step is:
    <UL>
      <LI>
	The length of any list is 1 plus the
	length of the
	<SPLITINLINE>
	  cdr
	  <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	of the list.
      </LI>
    </UL>
    This is applied successively until we reach the base case:
    <UL>
      <LI>
	The length of the empty list is 0.
      </LI>
    </UL>
    We could also compute length in an iterative
    style:
    <SNIPPET PAGE="102">
      <INDEX><DECLARATION>length</DECLARATION><SUBINDEX>iterative version</SUBINDEX></INDEX>
      <NAME>length_iter</NAME>
      <EXAMPLE>length_example</EXAMPLE>
      <EXPECTED>4</EXPECTED>
      
(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
      
      <JAVASCRIPT>
function length(items) {
    function length_iter(a, count) {
        return is_null(a)
               ? count
               : length_iter(tail(a), count + 1);
    }
    return length_iter(items, 0);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    Another conventional programming technique is to 
    <SPLITINLINE>
      
	<INDEX><USE>cons</USE> up a list</INDEX>
	<INDEX>list(s)<SUBINDEX><ORDER>consing</ORDER>consing up</SUBINDEX></INDEX>
	<QUOTE>cons up</QUOTE>
	the heads and tails of an answer list while
      cdring down a list,
      
      <JAVASCRIPT>
	<INDEX>constructing a list with <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></INDEX>
	<INDEX>list(s)<SUBINDEX>constructing with <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></SUBINDEX></INDEX>
	<INDEX>adjoining to a list with <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></INDEX>
	<INDEX>list(s)<SUBINDEX>adjoining to with <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></SUBINDEX></INDEX>
	construct an answer list by adjoining elements to
	the front of the list with
	pair
	while walking down a list using
	<JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    as in the
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>list(s)<SUBINDEX>combining with append</SUBINDEX></INDEX>
    append, which takes two lists as arguments and
    combines their elements to make a new list:
    <SNIPPET PAGE="102">
      <NAME>append_example</NAME>
      <REQUIRES>append</REQUIRES>
      <REQUIRES>manual_squares</REQUIRES>
      <REQUIRES>manual_odds</REQUIRES>
      <EXPECTED>9</EXPECTED>
      
(append squares odds)
      
      <SCHEMEOUTPUT>
(1 4 9 16 25 1 3 5 7)	
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
append(squares, odds);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
length(append(squares, odds));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(1, 4, 9, 16, 25, 1, 3, 5, 7)
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET PAGE="102">
      <NAME>append_example2</NAME>
      <REQUIRES>append</REQUIRES>
      <REQUIRES>manual_squares</REQUIRES>
      <REQUIRES>manual_odds</REQUIRES>
      <EXPECTED>9</EXPECTED>
      
(append odds squares)
      
      <SCHEMEOUTPUT>
(1 3 5 7 1 4 9 16 25)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
append(odds, squares);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
length(append(odds, squares));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(1, 3, 5, 7, 1, 4, 9, 16, 25)
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SPLITINLINE>
      Append
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>append</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is also implemented using a recursive plan. To
    append lists
    list1 and list2,
    do the following:
    <UL>
      <LI>
	If list1 is the empty list, then the
      result is just list2.
      </LI>
      <LI>
	Otherwise, append the
	<SPLITINLINE>
	  cdr
	  <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	of list1 and 
	list2, and
	<SPLITINLINE>
	  cons
	  <JAVASCRIPT>adjoin</JAVASCRIPT>
	</SPLITINLINE>
	the
	<SPLITINLINE>
	  car
	  <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	of list1
	<SPLITINLINE>
	  
	    onto the result:
	  
	  <JAVASCRIPT>
	    to the result:
	  </JAVASCRIPT>
	</SPLITINLINE>
      </LI>
    </UL>
    <SNIPPET PAGE="103" POSTPADDING="no">
      <INDEX><DECLARATION>append</DECLARATION></INDEX>
      <NAME>append</NAME>
      <EXAMPLE>append_example</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
      
      <JAVASCRIPT>
function append(list1, list2) {
    return is_null(list1)
           ? list2
           : pair(head(list1), append(tail(list1), list2));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <EXERCISE>
    <LABEL NAME="ex:last"></LABEL> 
    Define a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>last_pair</USE></INDEX> 
    <INDEX>list(s)<SUBINDEX>last pair of</SUBINDEX></INDEX>
    <SPLITINLINE>
      last-pair
      <JAVASCRIPT><JAVASCRIPTINLINE>last_pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    that returns the list that contains only the last element of a given
    (nonempty) list:
    <SNIPPET PAGE="104" HIDE="yes">
      <NAME>last_pair_by_student</NAME>
      
;; last-pair to be given by student
      
      <JAVASCRIPT>
// last_pair to be given by student
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="103" POSTPADDING="no">
      <NAME>last_pair_example</NAME>
      <REQUIRES>last_pair_by_student</REQUIRES>
      
(last-pair (list 23 72 149 34))
      
      <SCHEMEOUTPUT>
(34)	
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
last_pair(list(23, 72, 149, 34));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
list(34)
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>last_pair_definition</NAME>
	<EXAMPLE>last_pair_example</EXAMPLE>
	<EXPECTED>[ 34, null ]</EXPECTED>
	<JAVASCRIPT>
function last_pair(items) {
    return is_null(tail(items))
           ? items
           : last_pair(tail(items));
}
	</JAVASCRIPT>
	
	
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:reverse"></LABEL>
    Define a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
     <INDEX><USE>reverse</USE></INDEX> 
    <INDEX>list(s)<SUBINDEX>reversing</SUBINDEX></INDEX>
    reverse that takes a list as argument and
    returns a list of the same elements in reverse order:
    <SNIPPET PAGE="103" POSTPADDING="no">
      <NAME>reverse_example</NAME>
      
(reverse (list 1 4 9 16 25))
      
      <SCHEMEOUTPUT>
(25 16 9 4 1)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
	reverse(list(1, 4, 9, 16, 25));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
list(25, 16, 9, 4, 1)
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      Naive reverse (what is the run time?):
      <SNIPPET>
	<NAME>naive_reverse_definition</NAME>
	<EXAMPLE>reverse_example_2</EXAMPLE>
	<EXPECTED>25</EXPECTED>
	<JAVASCRIPT>
function reverse(items) {
    return is_null(items)
           ? null
           : append(reverse(tail(items)),
	            pair(head(items), null));
}
	</JAVASCRIPT>
      </SNIPPET>
      A better version:
      <SNIPPET>
	<NAME>reverse</NAME>
	<EXAMPLE>reverse_example_2</EXAMPLE>
	<EXPECTED>25</EXPECTED>
	<JAVASCRIPT>   
function reverse(items) {
    function reverse_iter(items, result) {
        return is_null(items)
               ? result
               : reverse_iter(tail(items),
	                      pair(head(items), result));
    }
    return reverse_iter(items, null);
}
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
      Consider the 
      <INDEX>counting change</INDEX>
      change-counting program of
      section<SPACE></SPACE><REF NAME="sec:tree-recursion"></REF>.  It would be nice to be
      able to easily change the currency used by the program, so that we could
      compute the number of ways to change a British pound, for example.  As
      the program is written, the knowledge of the currency is distributed
      partly into the
      <SPLITINLINE>
	procedure
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	first-denomination
	<JAVASCRIPT><JAVASCRIPTINLINE>first_denomination</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and partly into the
      <SPLITINLINE>
	procedure
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	count-change
	<JAVASCRIPT><JAVASCRIPTINLINE>count_change</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      (which knows
      that there are five kinds of U.S. coins).
      It would be nicer
      to be able to supply a list of coins to be used for making change.
    <TEXT>
      We want to rewrite the
      <SPLITINLINE>
	procedure
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      cc so that its second argument is a list of
      the values of the coins to use rather than an integer specifying which
      coins to use.  We could then have lists that defined each kind of
      currency:
      <SNIPPET PAGE="103">
        <NAME>us_coins</NAME>
        
(define us-coins (list 50 25 10 5 1))

(define uk-coins (list 100 50 20 10 5 2 1))
        
        <JAVASCRIPT>
const us_coins = list(50, 25, 10, 5, 1);
const uk_coins = list(100, 50, 20, 10, 5, 2, 1);
        </JAVASCRIPT>
      </SNIPPET>
      We could then call cc as follows:
      <SNIPPET PAGE="103">
        <NAME>cc_example</NAME>
        <REQUIRES>cc</REQUIRES>
        <REQUIRES>us_coins</REQUIRES>
        
(cc 100 us-coins)
        
        <SCHEMEOUTPUT>
292
        </SCHEMEOUTPUT>
        <JAVASCRIPT>
cc(100, us_coins);
        </JAVASCRIPT>
	<JAVASCRIPT_OUTPUT>
292
	</JAVASCRIPT_OUTPUT>
      </SNIPPET>
      To do this will require changing the program
      cc somewhat.  It will still have the same
      form, but it will access its second argument differently, as follows:
      <SNIPPET PAGE="104" HIDE="yes">
        <NAME>cc_helpers</NAME>
        
;; first-denomination, except-first-denomination
;; and no-more? to be given by student
        
        <JAVASCRIPT>
// first_denomination, except_first_denomination
// and no_more to be given by student
        </JAVASCRIPT>
      </SNIPPET>
      <SNIPPET PAGE="104">
        <NAME>cc</NAME>
        <REQUIRES>cc_helpers</REQUIRES>
	<EXAMPLE>cc_example</EXAMPLE>
        
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
        
        <JAVASCRIPT>
function cc(amount, coin_values) {
    return amount === 0
           ? 1
           : amount &lt; 0 || no_more(coin_values)
           ? 0
           : cc(amount, except_first_denomination(coin_values)) +
             cc(amount - first_denomination(coin_values), coin_values);
}
        </JAVASCRIPT>
      </SNIPPET>
      Define the
      <SPLITINLINE>
	procedures
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	first-denomination,
	<JAVASCRIPT><JAVASCRIPTINLINE>first_denomination</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	except-first-denomination,
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>except_first_denomination</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      and
      <SPLITINLINE>
	no-more?
	<JAVASCRIPT><JAVASCRIPTINLINE>no_more</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      in terms of primitive operations on list structures.  Does the order of
      the list
      <SPLITINLINE>
	coin-values
	<JAVASCRIPT><JAVASCRIPTINLINE>coin_values</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      affect the answer produced by cc?
      Why or why not?
    </TEXT>
    <SOLUTION>
      <SNIPPET>
	<NAME>exercise_2_19_solution</NAME>
	<REQUIRES>cc</REQUIRES>
	<EXAMPLE>cc_example</EXAMPLE>
	<EXPECTED>292</EXPECTED>
	<JAVASCRIPT>
function first_denomination(coin_values) {
    return head(coin_values);
}
function except_first_denomination(coin_values) {
    return tail(coin_values);
}
function no_more(coin_values) {
    return is_null(coin_values);
}
	</JAVASCRIPT>
	
	
      </SNIPPET>
      The order of the list <JAVASCRIPTINLINE>coin_values</JAVASCRIPTINLINE>
      does not affect the answer given by any correct solution of the problem,
      because the given list represents an unordered collection of
      denominations.
    </SOLUTION>
    <LABEL NAME="ex:2_19"></LABEL>
  </EXERCISE>

  <SPLIT>
    
      <EXERCISE>
	<LABEL NAME="ex:dotted-arglist"></LABEL>
        <INDEX>dotted-tail notation<SUBINDEX><ORDER>procedure</ORDER>for procedure parameters</SUBINDEX></INDEX>
        <INDEX><DECLARATION>define</DECLARATION><SUBINDEX><ORDER>dotted</ORDER>with dotted-tail notation</SUBINDEX></INDEX>
        <INDEX>argument(s)<SUBINDEX>arbitrary number of</SUBINDEX></INDEX>
        <INDEX>procedure<SUBINDEX>arbitrary number of arguments</SUBINDEX></INDEX>
        The procedures
        +, *, and
	list take arbitrary numbers of arguments.
	One way to define such procedures is to use
	define with <EM>dotted-tail notation</EM>.
	In a procedure definition, a parameter list that has a dot before the
	last parameter name indicates that, when the procedure is called, the
	initial parameters (if any) will have as values the initial arguments, 
        as usual, but the final parameter<APOS></APOS>s value will be a <EM>list</EM>
	of any remaining arguments. For instance, given the definition
        <SNIPPET>
          
            (define (f x y . z) $\langle \textit{body} \rangle$)
          
        </SNIPPET>
        the procedure f can be called with two or
	more arguments. If we evaluate
        <SNIPPET>
          
            (f 1 2 3 4 5 6)
          
        </SNIPPET>
        then in the body of f,
	x will be 1,
	y will be 2, and
	z will be the list
	(3 4 5 6). Given the definition
        <SNIPPET>
          
(define (g . w) $\langle \textit{body} \rangle$)
          
        </SNIPPET>
        the procedure g can be called with zero or
	more arguments. If we evaluate
        <SNIPPET>
          
            (g 1 2 3 4 5 6)
          
        </SNIPPET>
        then in the body of g,
	w will be the list
	(1 2 3 4 5 6).<FOOTNOTE>To define
	f and g using
        <INDEX><DECLARATION>lambda</DECLARATION><SUBINDEX><ORDER>dotted</ORDER>with dotted-tail notation</SUBINDEX></INDEX>
        lambda we would write
        <SNIPPET EVAL="no">
          
(define f (lambda (x y . z) body))
(define g (lambda w body))
          
        </SNIPPET></FOOTNOTE>
        Use this notation to write a procedure
	same-parity that takes one or more integers
        and returns a list of all the arguments that have the same even-odd
        parity as the first argument.  For example, 
        <SNIPPET PAGE="104">
          <NAME>same_parity</NAME>
          
	    ;; same-parity to be given by student
          
        </SNIPPET>
        <SNIPPET PAGE="104">
          <NAME>same_parity_example</NAME>
          <REQUIRES>same_parity</REQUIRES>
          
(same-parity 1 2 3 4 5 6 7)
          
          <SCHEMEOUTPUT>
(1 3 5 7)
          </SCHEMEOUTPUT>
        </SNIPPET>
        <SNIPPET PAGE="104">
          <NAME>same_parity_example2</NAME>
          <REQUIRES>same_parity</REQUIRES>
          
(same-parity 2 3 4 5 6 7)
          
          <SCHEMEOUTPUT>
(2 4 6)
          </SCHEMEOUTPUT>
        </SNIPPET>
      </EXERCISE>
      <INDEX>list(s)<SUBINDEX>operations on</SUBINDEX><CLOSE></CLOSE></INDEX>
      <INDEX>list(s)<SUBINDEX>techniques for manipulating</SUBINDEX><CLOSE></CLOSE></INDEX>
    
    <JAVASCRIPT>
      <EXERCISE>
	In the presence of higher-order functions, it is not strictly necessary
	for functions to have multiple parameters; one would
	suffice. If we have a function such as
	<JAVASCRIPTINLINE>plus</JAVASCRIPTINLINE> that naturally requires two
	arguments, we could write a variant of the function to which we pass
	the arguments one at a time. An application of the variant to the
	first argument could return a function that we can then apply to the
	second argument, and so on. This practice<EMDASH></EMDASH>called
	<INDEX>currying</INDEX>
	<EM>currying</EM> and named after the American mathematician and
	logician
	<INDEX>Curry, Haskell Brooks</INDEX>
	Haskell Brooks Curry<EMDASH></EMDASH>is quite common in programming
	languages such as
	<INDEX>Haskell</INDEX>
	Haskell and
	<INDEX>Ocaml</INDEX>
	OCaml. In JavaScript, a curried
	version of <JAVASCRIPTINLINE>plus</JAVASCRIPTINLINE> looks as follows.
	<SNIPPET>
	  <NAME>currying_plus</NAME>
	  <EXAMPLE>curry_example</EXAMPLE>
	  <EXPECTED>7</EXPECTED>
	  <JAVASCRIPT>
function plus_curried(x) {	    
    return y =&gt; x + y;
}
	  </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET HIDE="yes">
	  <NAME>curry_example</NAME>
	  <JAVASCRIPT>
plus_curried(3)(4);
	  </JAVASCRIPT>
	</SNIPPET>
	Write a function <JAVASCRIPTINLINE>brooks</JAVASCRIPTINLINE> that
	takes a curried function as first argument and as second argument a list
	of arguments to which the curried function is then applied, one by one,
	in the given order. For example, the following application of
	<JAVASCRIPTINLINE>brooks</JAVASCRIPTINLINE> should have the
	same effect as
	<JAVASCRIPTINLINE>plus_curried(3)(4)</JAVASCRIPTINLINE>:
	<SNIPPET HIDE="yes">
	  <NAME>currying</NAME>
	  <JAVASCRIPT>
// brooks to be written by the student
	  </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET>
	  <NAME>currying_example</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>currying</REQUIRES>
	  <JAVASCRIPT>
brooks(plus_curried, list(3, 4));
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
7
	  </JAVASCRIPT_OUTPUT>
	</SNIPPET>
	While we are at it, we might as well curry the function
	<JAVASCRIPTINLINE>brooks</JAVASCRIPTINLINE>! Write a function 
	<JAVASCRIPTINLINE>brooks_curried</JAVASCRIPTINLINE> that can be applied
	as follows:
	<SNIPPET HIDE="yes">
	  <NAME>currying_currying</NAME>
	  <JAVASCRIPT>
	    // brooks_curried to be written by the student
	  </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET>
	  <NAME>currying_currying_example</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>currying_currying</REQUIRES>
	  <JAVASCRIPT>
brooks_curried(list(plus_curried, 3, 4));
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
7
	  </JAVASCRIPT_OUTPUT>
	</SNIPPET>
	With this function <JAVASCRIPTINLINE>brooks_curried</JAVASCRIPTINLINE>,
	what are the results of evaluating the following two statements?
	<SNIPPET>
	  <NAME>currying_currying_example_2</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>currying_currying</REQUIRES>
	  <JAVASCRIPT>
brooks_curried(list(brooks_curried,
                    list(plus_curried, 3, 4)));
	  </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET POSTPADDING="no">
	  <NAME>currying_currying_example_3</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>currying_currying</REQUIRES>
	  <JAVASCRIPT>
brooks_curried(list(brooks_curried,
                    list(brooks_curried, 
                         list(plus_curried, 3, 4))));
	  </JAVASCRIPT>
	</SNIPPET>
	<SOLUTION>
	  <OL>
	    <LI>
	      <SNIPPET>
		<NAME>brooks_solution</NAME>
		<REQUIRES>currying_plus</REQUIRES>
		<EXAMPLE>currying_example</EXAMPLE>
		<EXPECTED>7</EXPECTED>
		<JAVASCRIPT>
function brooks(f, items) {
    return is_null(items)
           ? f
           : brooks(f(head(items)), tail(items));
}	   
		</JAVASCRIPT>
	      </SNIPPET>
	    </LI>
	    <LI>
	      <SNIPPET>
		<NAME>brooks_curried_solution</NAME>
		<REQUIRES>brooks_solution</REQUIRES>
		<EXAMPLE>currying_currying_example</EXAMPLE>
		<EXPECTED>7</EXPECTED>
		<JAVASCRIPT>
function brooks_curried(items) {
    return brooks(head(items), tail(items));
}	   
		</JAVASCRIPT>
	      </SNIPPET>
	    </LI>
	    <LI>
	      The statement 
	      <SNIPPET>
		<NAME>currying_currying_example_4</NAME>
		<REQUIRES>currying_plus</REQUIRES>
		<REQUIRES>brooks_curried_solution</REQUIRES>
		<EXPECTED>7</EXPECTED>
		<JAVASCRIPT>
brooks_curried(list(brooks_curried,
                    list(plus_curried, 3, 4)));
		</JAVASCRIPT>
	      </SNIPPET>
	      of course evaluates to 7, as does
	    </LI>
	    <LI>
	      <SNIPPET>
		<NAME>currying_currying_example_5</NAME>
		<REQUIRES>currying_plus</REQUIRES>
		<REQUIRES>brooks_curried_solution</REQUIRES>
		<EXPECTED>7</EXPECTED>
		<JAVASCRIPT>
brooks_curried(list(brooks_curried,
                    list(brooks_curried, 
                         list(plus_curried, 3, 4))));
		</JAVASCRIPT>
	      </SNIPPET>
	    </LI>
	  </OL>
	</SOLUTION>
	<LABEL NAME="ex:2_20"></LABEL>
      </EXERCISE>
      <INDEX>list(s)<SUBINDEX>operations on</SUBINDEX><CLOSE></CLOSE></INDEX>
      <INDEX>list(s)<SUBINDEX>techniques for manipulating</SUBINDEX><CLOSE></CLOSE></INDEX>
    </JAVASCRIPT>
  </SPLIT>

  <SUBHEADING>
    <NAME>Mapping over lists</NAME>
  </SUBHEADING>

  <INDEX>list(s)<SUBINDEX>mapping over</SUBINDEX><OPEN></OPEN></INDEX>
  <INDEX>mapping<SUBINDEX><ORDER>list</ORDER>over lists</SUBINDEX><OPEN></OPEN></INDEX>
  <TEXT>
    One extremely useful operation is to apply some transformation to each
    element in a list and generate the list of results. For instance, the
    following
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    scales each number in a list by a given factor:
    <SNIPPET PAGE="105">
      <INDEX><DECLARATION>scale_list</DECLARATION></INDEX>
      <NAME>scale_list</NAME>
      <EXAMPLE>scale_list_example</EXAMPLE>
      <EXPECTED>[ 30, [ 40, [ 50, null ] ] ]</EXPECTED>
      
(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))
      
      <JAVASCRIPT>
function scale_list(items, factor) {
    return is_null(items)
           ? null
           : pair(head(items) * factor, 
                  scale_list(tail(items), factor));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="105">
      <NAME>scale_list_example</NAME>
      
(scale-list (list 1 2 3 4 5) 10)
      
      <SCHEMEOUTPUT>
(10 20 30 40 50)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
scale_list(list(1, 2, 3, 4, 5), 10);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[10, [20, [30, [40, [50, null]]]]]
      </JAVASCRIPT_OUTPUT>
      <JAVASCRIPT_TEST>
tail(tail(scale_list(list(1, 2, 3, 4, 5), 10)));
      </JAVASCRIPT_TEST>
    </SNIPPET>
  </TEXT>
  <TEXT>
    We can abstract this general idea and capture it as a common pattern
    expressed as a higher-order
    <SPLITINLINE>
      procedure,
    <JAVASCRIPT>function,</JAVASCRIPT></SPLITINLINE>
    just as in section<SPACE></SPACE><REF NAME="sec:higher-order-procedures"></REF>.  The
    higher-order
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    here is called map.
    <SPLITINLINE>
      Map
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>map</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    takes as arguments a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of one argument and a list, and returns a list of the results produced by
    applying the
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to each element in the list:<SPLITINLINE><FOOTNOTE>
    <LABEL NAME="foot:generalmap"></LABEL>	  
    Scheme standardly provides a 
     <INDEX><USE>map</USE><SUBINDEX>with multiple arguments</SUBINDEX></INDEX> 
    map
    procedure that is more general than the one described here. This more
    general map takes a procedure of
    <LATEXINLINE>$n$</LATEXINLINE> arguments, together with
    <LATEXINLINE>$n$</LATEXINLINE> lists, and applies the procedure to all the
    first elements of the lists, all the second elements of the lists, and so
    on, returning a list of the results.  For example:
    <SNIPPET PAGE="105">
      <NAME>general_map_example</NAME>
      <REQUIRES>general_map</REQUIRES>
      <REQUIRES>plus</REQUIRES>
      
(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
        
        <SCHEMEOUTPUT>
(741 852 963)
        </SCHEMEOUTPUT>
      </SNIPPET>
      <SNIPPET PAGE="105">
        <NAME>general_map_example2</NAME>
        <REQUIRES>general_map</REQUIRES>
        
(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
        
      </SNIPPET>
    </FOOTNOTE></SPLITINLINE>
    <SNIPPET PAGE="105">
      <INDEX><DECLARATION>map</DECLARATION></INDEX> 
      <NAME>map</NAME>
      <EXAMPLE>map_example</EXAMPLE>
      <EXPECTED>[ 2.5, [ 11.6, [ 17, null ] ] ]</EXPECTED>
      
(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
      
      <JAVASCRIPT>
function map(fun, items) {
    return is_null(items)
           ? null
           : pair(fun(head(items)), 
                  map(fun, tail(items)));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="105">
      <NAME>map_example</NAME>
      <REQUIRES>abs_definition</REQUIRES>
      <REQUIRES>map</REQUIRES>
      <EXPECTED>[ 2.5, [ 11.6, [ 17, null ] ] ]</EXPECTED>
      
(map abs (list -10 2.5 -11.6 17))
      
      <SCHEMEOUTPUT>
(10 2.5 11.6 17)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
map(abs, list(-10, 2.5, -11.6, 17));
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
tail(map(abs, list(-10, 2.5, -11.6, 17)));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
[10, [2.5, [11.6, [17, null]]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET PAGE="105">
      <NAME>map_example2</NAME>
      <REQUIRES>map</REQUIRES>
      <EXPECTED>[ 4, [ 9, [ 16, null ] ] ]</EXPECTED>
      
(map (lambda (x) (* x x))
     (list 1 2 3 4))
      
      <SCHEMEOUTPUT>
(1 4 9 16)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
map(x =&gt; x * x, list(1, 2, 3, 4));
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
tail(map(x =&gt; x * x, list(1, 2, 3, 4)));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
[1, [4, [9, [16, null]]]]
      </JAVASCRIPT_OUTPUT>
</SNIPPET>
    Now we can give a new definition of
    <SPLITINLINE>
      scale-list
      <JAVASCRIPT><JAVASCRIPTINLINE>scale_list</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in terms of map:
    <SNIPPET PAGE="106">
      <INDEX><DECLARATION>scale_list</DECLARATION></INDEX>
      <NAME>scale_list2</NAME>
      <EXAMPLE>scale_list_example</EXAMPLE>
      <EXPECTED>[ 30, [ 40, [ 50, null ] ] ]</EXPECTED>
      
(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
      
      <JAVASCRIPT>
function scale_list(items, factor) {
    return map(x =&gt; x * factor, items);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      Map
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>map</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is an important construct, not only because it captures a common pattern,
    but because it establishes a higher level of abstraction in dealing with
    lists.  In the original definition of
    <SPLITINLINE>
      scale-list,
      <JAVASCRIPT><JAVASCRIPTINLINE>scale_list</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    the recursive structure of the program draws attention to the
    element-by-element processing of the list.  Defining
    <SPLITINLINE>
      scale-list
      <JAVASCRIPT><JAVASCRIPTINLINE>scale_list</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in terms of map suppresses that level of
    detail and emphasizes that scaling transforms a list of elements to a list
    of results.  The difference between the two definitions is not that the
    computer is performing a different process (it isn<APOS></APOS>t) but that we
    think about the process differently.  In effect,
    map helps establish an abstraction barrier
    that isolates the implementation of
    <SPLITINLINE>
      procedures
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    that transform lists from the details of how the elements of the list are
    extracted and combined.  Like the barriers shown in
    <SPLITINLINE>
      
	figure<SPACE></SPACE><REF NAME="fig:abstraction-barriers_scheme"></REF>,
      
      <JAVASCRIPT>
	figure<SPACE></SPACE><REF NAME="fig:abstraction-barriers"></REF>,
      </JAVASCRIPT>
    </SPLITINLINE>
    this abstraction gives us the flexibility to change the low-level details
    of how sequences are implemented, while preserving the conceptual framework
    of operations that transform sequences to sequences.
    Section<SPACE></SPACE><REF NAME="sec:sequences-conventional-interfaces"></REF> expands
    on this use of sequences as a framework for organizing programs.
  </TEXT>

  <EXERCISE>
    <LABEL NAME="ex:square-list"></LABEL>
    The
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      square-list
      <JAVASCRIPT><JAVASCRIPTINLINE>square_list</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    takes a list of numbers as argument and returns a list of the squares of
    those numbers.
    <SNIPPET PAGE="106">
      <NAME>square_list_example</NAME>
      
;; square-list to be given by student
(square-list (list 1 2 3 4))
      
      <SCHEMEOUTPUT>
(1 4 9 16)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square_list(list(1, 2, 3, 4));
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
tail(square_list(list(1, 2, 3, 4)));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
[1, [4, [9, [16, null]]]]	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    Here are two different definitions of
    <SPLITINLINE>
      square-list.
      <JAVASCRIPT><JAVASCRIPTINLINE>square_list</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    Complete both of them by filling in the missing expressions:
    <SNIPPET LATEX="yes">
      <EXAMPLE>square_list_example</EXAMPLE>
      
(define (square-list items)
  (if (null? items)
      nil
      (cons ?? ??)))
      
      <JAVASCRIPT>
function square_list(items) {
    return is_null(items) 
           ? null
           : pair(<METAPHRASE>??</METAPHRASE>, <METAPHRASE>??</METAPHRASE>);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET LATEX="yes" POSTPADDING="no">
      <EXAMPLE>square_list_example</EXAMPLE>
      
(define (square-list items)
  (map ?? ??))
      
      <JAVASCRIPT>
function square_list(items) {
   return map(<METAPHRASE>??</METAPHRASE>, <METAPHRASE>??</METAPHRASE>);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET POSTPADDING="no">
	<NAME>square_list_pedestrian</NAME>
	<REQUIRES>square_definition</REQUIRES>
	<EXAMPLE>square_list_example</EXAMPLE>
	<EXPECTED>[ 4, [ 9, [ 16, null ] ] ]</EXPECTED>
	<JAVASCRIPT>
function square_list(items) {
    return is_null(items)
           ? null
           : pair(square(head(items)),
	          square_list(tail(items)));
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET>
	<NAME>square_list_with_map</NAME>
	<REQUIRES>square_definition</REQUIRES>
	<EXPECTED>[ 4, [ 9, [ 16, null ] ] ]</EXPECTED>
	<EXAMPLE>square_list_example</EXAMPLE>
	<JAVASCRIPT>  
function square_list(items) {
    return map(square, items);
}
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE> 
    Louis Reasoner tries to rewrite the first
    <SPLITINLINE>square-list
    <JAVASCRIPT><JAVASCRIPTINLINE>square_list</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of exercise<SPACE></SPACE><REF NAME="ex:square-list"></REF> so that it evolves an
    iterative process:
    <SNIPPET PAGE="106" HIDE="yes">
      <NAME>square_list_warning</NAME>
      <JAVASCRIPT>
// THIS IS NOT A CORRECT SOLUTION	    
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="106">
      <NAME>square_list2</NAME>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>square_list_warning</REQUIRES>
      <EXAMPLE>square_list_example</EXAMPLE>
      <EXPECTED>[ 9, [ 4, [ 1, null ] ] ]</EXPECTED>
      
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things) 
              (cons (square (car things))
                    answer))))
  (iter items nil))
      
      <JAVASCRIPT>
function square_list(items) {
    function iter(things, answer) {
        return is_null(things) 
               ? answer
               : iter(tail(things), 
                      pair(square(head(things)), 
                           answer));
    }
    return iter(items, null);
}
      </JAVASCRIPT>
    </SNIPPET>
    Unfortunately, defining
    <SPLITINLINE>
      square-list
      <JAVASCRIPT><JAVASCRIPTINLINE>square_list</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    this way produces the answer list in the reverse order of the one desired.
    Why?
    <TEXT>
      Louis then tries to fix his bug by interchanging the arguments to
    <SPLITINLINE>
      cons:
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET PAGE="106">
      <NAME>square_list3</NAME>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>square_list_warning</REQUIRES>
      <EXAMPLE>square_list_example</EXAMPLE>
      <EXPECTED>16</EXPECTED>
      
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
      
      <JAVASCRIPT>
function square_list(items) {
    function iter(things, answer) {
        return is_null(things)
               ? answer
               : iter(tail(things), 
                      pair(answer, 
                           square(head(things))));
    }
    return iter(items, null);
}
      </JAVASCRIPT>
    </SNIPPET>
    This doesn<APOS></APOS>t work either.  Explain.
    </TEXT>
    <LABEL NAME="ex:iter-square-list"></LABEL>
    <SOLUTION>
      <OL>
	<LI>
	  The result list is reversed in the first program because the argument
	  list is traversed in the given order, from first to last, but squares
	  are added successively to the front of the answer list via
	  <SPLITINLINE>cons.
	  <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>.</JAVASCRIPT>
	  </SPLITINLINE>
	  The last element of the list is the last one to be added to the answer
	  and thus ends up as the first element of the result list.
	</LI>
	<LI>
	  The second program makes things worse! The result is not even a list
	  any longer, because the elements occupy the tail position of the
	  result list and not the head position.
	</LI>
      </OL>
    </SOLUTION>
  </EXERCISE>

  <LONG_PAGE LINES="2"></LONG_PAGE>
  <EXERCISE>
    <LABEL NAME="ex:for-each"></LABEL>
    The
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
     <INDEX><USE>for_each</USE></INDEX> 
    <SPLITINLINE>
      for-each
      <JAVASCRIPT><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is similar to map.  It takes as arguments a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    and a list of elements.  However, rather than forming a list of the
    results,
    <SPLITINLINE>
      for-each
      <JAVASCRIPT><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    just applies the
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to each of the elements in turn, from left to right. The values returned by
    applying the
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to the elements are not used
    <SPLITINLINE>
      at all<EMDASH></EMDASH>for-each
      <JAVASCRIPT>at all<EMDASH></EMDASH><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is used with
    <SPLITINLINE>
      procedures
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    that perform an action, such as printing.  For example, 
    <SNIPPET PAGE="104" HIDE="yes">
      <NAME>for_each_by_student</NAME>
      
;; for_each to be given by student
      
      <JAVASCRIPT>
// for_each to be given by student
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <REQUIRES>for_each_by_student</REQUIRES>
      <NAME>for_each_example</NAME>
      
(for-each 
   (lambda (x) (newline) (display x))
   (list 57 321 88))
      
      <SCHEMEOUTPUT>
57
321
88
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
for_each(x =&gt; display(x), list(57, 321, 88));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
57
321
88
      </JAVASCRIPT_OUTPUT>
      <JAVASCRIPT_TEST>
for_each(x =&gt; x, 
         list(57, 321, 88));
      </JAVASCRIPT_TEST>
    </SNIPPET>
    The value returned by the call to
    <SPLITINLINE>
      for-each
      <JAVASCRIPT><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    (not illustrated above) can be something arbitrary, such as true.  Give an
    implementation of
    <SPLITINLINE>
      for-each.
      <JAVASCRIPT><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    <SOLUTION>
      <SNIPPET>
	<NAME>for_each</NAME>
	<EXAMPLE>for_each_example</EXAMPLE>
	<EXPECTED>undefined</EXPECTED>
	<JAVASCRIPT>
function for_each(fun, items) {
    if (is_null(items)){
        return undefined;
    } else {
        fun(head(items));
        for_each(fun, tail(items));
    }
}     
	</JAVASCRIPT>
	
	
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>
  <INDEX>list(s)<SUBINDEX>mapping over</SUBINDEX><CLOSE></CLOSE></INDEX>
  <INDEX>mapping<SUBINDEX><ORDER>list</ORDER>over lists</SUBINDEX><CLOSE></CLOSE></INDEX>
</SUBSECTION>
