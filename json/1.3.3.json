[{"id":"/sicpjs/1.3.3","tag":"TITLE","body":"1.3.3  \n    \n      \n    Functions\n    as General Methods"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    We introduced compound\n    functions\n    in section ","tag":"#text"},{"tag":"REF","body":"1.1.4","href":"/sicpjs/1.1.4"},{"body":" as a mechanism for\n    abstracting patterns of numerical operations so as to make them independent\n    of the particular numbers involved.  With higher-order\n    functions,\n    such as\n    the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"integral"},{"body":"function\n    of section ","tag":"#text"},{"tag":"REF","body":"1.3.1","href":"/sicpjs/1.3.1"},{"body":", we began to\n    see a more powerful kind of abstraction:\n    functions\n    used to express general methods of computation, independent of the\n    particular functions involved.  In this section we discuss two more elaborate\n    examples—general methods for finding zeros and fixed points of\n    functions—and show how these methods can be expressed directly as\n    functions.","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Finding roots of equations by the half-interval method","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"half-interval method","tag":"#text"}]},{"body":" is a simple but powerful technique for\n    finding roots of an equation ","tag":"#text"},{"body":"$f(x)=0$","tag":"LATEX"},{"body":", where\n    ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" is a continuous function.  The idea is that,\n    if we are given points ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":" such that\n    ","tag":"#text"},{"body":"$f(a) < 0 < f(b)$","tag":"LATEX"},{"body":", then\n    ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" must have at least one zero between\n    ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":". To locate\n    a zero, let ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" be the average of\n    ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":" and\n    compute ","tag":"#text"},{"body":"$f(x)$","tag":"LATEX"},{"body":".  If\n    ","tag":"#text"},{"body":"$f(x) > 0$","tag":"LATEX"},{"body":", then\n    ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" must have a zero between\n    ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":". If\n    ","tag":"#text"},{"body":"$f(x) < 0$","tag":"LATEX"},{"body":", then\n    ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" must have a zero between\n    ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":".\n    Continuing in this way, we can identify smaller and smaller intervals on\n    which ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" must have a zero.  When we reach a\n    point where the interval is small enough, the process stops.  Since the\n    interval of uncertainty is reduced by half at each step of the process, the\n    maximal number of steps required grows as\n    ","tag":"#text"},{"body":"$\\Theta(\\log( L/T))$","tag":"LATEX"},{"body":", where\n    ","tag":"#text"},{"body":"$L$","tag":"LATEX"},{"body":" is the length of the original interval and\n    ","tag":"#text"},{"body":"$T$","tag":"LATEX"},{"body":" is the error tolerance (that is, the size of\n    the interval we will consider \"","tag":"#text"},{"body":"small enough","tag":"#text"},{"body":"\").\n    Here is a\n    function that implements this strategy:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":16,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDANwFMAnOgcyYAoAPAGlABPAJSgA3tlBTQLJmQItavUAGohosACYA3NgC+uQqUo1QAByoBnCpWa9RYmXIW0eoAHygADNtAGj5NS0REzsdLbcPA5O8oqgbgA83r4G+MSBpnQARpb24pLSsrGuHgC83qAA-PGgAFygALTxuqkBJrQkADZWTAD6TERUBOwAFrwCIvnSMS70OcpNk0leaF5eKC2G6e2glkx0LCRjeAIh7L0WFERkAhaWF1RXZA4FUiQ0lmSgALYUACaXa6gcqMVgcbhnB5PW5WKHXYS6aYUPCgLhdHr9QbDMaQwE3cywvHCF7TaZFWa-AGPa6I6R6UBMTp7Kakt4fL5kJifXoMOidAhMYGgPBcSlE2ms8lxO42Ch2Tnc3n8pjCV6s1nVPYHI5cE6gXHU-Fiw2q9Vm+pncJy7gKsg8vkC01mjW7faHY4CY3Qgn3Ilq51SepemlqgypLXu5SlTxuABUNSaKAEXgEmgRQA","body":"function search(f, neg_point, pos_point) {\n    const midpoint = average(neg_point, pos_point);\n    if (close_enough(neg_point, pos_point)) {\n        return midpoint;\n    } else {\n        const test_value = f(midpoint);\n        return positive(test_value)\n               ? search(f, neg_point, midpoint)\n               : negative(test_value)\n               ? search(f, midpoint, pos_point)\n               : midpoint;\n    }\n} "}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    We assume that we are initially given the function\n    ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" together with points at which its values are\n    negative and positive.  We first compute the midpoint of the two given\n    points.  Next we check to see if the given interval is small enough, and if\n    so we simply return the midpoint as our answer.  Otherwise, we compute as a\n    test value the value of ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" at the midpoint.  If\n    the test value is positive, then we continue the process with a new interval\n    running from the original negative point to the midpoint.  If the test value\n    is negative, we continue with the interval from the midpoint to the positive\n    point. Finally, there is the possibility that the test value is 0, in\n    which case the midpoint is itself the root we are searching for.\n\n    To test whether the endpoints are \"","tag":"#text"},{"body":"close enough","tag":"#text"},{"body":"\" we can use a\n    function\n    similar to the one used in section ","tag":"#text"},{"tag":"REF","body":"1.1.7","href":"/sicpjs/1.1.7"},{"body":" for\n    computing square roots:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/1.3.3#footnote-1"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqBIAbKk2EB9YUSoEA5gAt2AGlABPLrwEhUXFaRlYpHT9QAB5FNAUFFH0jbCsbe0dndxYAdjQcgDYAVgAWbzzCgoKOXSA","body":"function close_enough(x, y) {\n    return abs(x - y) < 0.001;\n} "}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n\tThe function \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"search"},{"body":"\n    is awkward to use directly, because we can accidentally give it points at\n    which ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":"'s values do not have the required\n    sign, in which case we get a wrong answer. Instead we will use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"search"},{"body":" via the following\n    function,\n    which checks to see which of the endpoints has a negative function value and\n    which has a positive value, and calls the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"search"},{"body":"function\n    accordingly.  If the function has the same sign on the two given points, the\n    half-interval method cannot be used, in which case the\n    function\n    signals an error.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/1.3.3#footnote-2"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":30,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDANwFMAnOgcyYAoAPAGlABPAJSgA3tlBTQLJmQItavUAGohosACYA3NgC+uQqUo1QAByoBnCpWa9RYmXIW0eoAHygADNtAGj5NS0REzsdLbcPA5O8oqgbgA83r4G+MSBpnQARpb24pLSsrGuHgC83qAA-PGgAFygALTxuqkBJrQkADZWTAD6TERUBOwAFrwCIvnSMS70OcpNk0leaF5eKC2G6e2glkx0LCRjeAIh7L0WFERkAhaWF1RXZA4FUiQ0lmSgALYUACaXa6gcqMVgcbhnB5PW5WKHXYS6aYUPCgLhdHr9QbDMaQwE3cywvHCF7TaZFWa-AGPa6I6R6UBMTp7Kakt4fL5kJifXoMOidAhMYGgPBcSlE2ms8lxO42Ch2Tnc3n8pjCV6s1nVPYHI5cE6gXHU-Fiw2q9Vm+pncJy7gKsg8vkC01mjW7faHY4CY3Qgn3Ilq51SepemlqgytbZBUAjPl4XpPVhK3rfOQjKh-XUCOgCLIk6TvIifej25VCkV0BFq-OFrLFgWlrg5iUzOKWiJcOi1lWgABk3Z9srsNaVjv9Lq17oz9GzTudFtCVsHndEvf7bY7w5Vo9JmrdOr1WUzM-NDJYLCoLC4ACIN5Z6LJ9VQvlQUVQzDLObsKOwiJeK6lo50sbxiwibJmQqbpt84QjL01hEAImgCAALAiQA","body":"function half_interval_method(f, a, b) {\n    const a_value = f(a);\n    const b_value = f(b);\n    return negative(a_value) && positive(b_value)\n           ? search(f, a, b)\n           : negative(b_value) && positive(a_value)\n           ? search(f, b, a)\n           : error(\"values are not of opposite sign\");\n} "}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    The following example uses the\n    \n    half-interval method to approximate\n    ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":" as the root between 2 and 4 of\n    ","tag":"#text"},{"body":"$\\sin\\, x = 0$","tag":"LATEX"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":40,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDANwFMAnOgcyYAoAPAGlABPAJSgA3tlBTQLJmQItavUAGohosACYA3NgC+uQqUo1QAByoBnCpWa9RYmXIW0eoAHygADNtAGj5NS0REzsdLbcPA5O8oqgbgA83r4G+MSBpnQARpb24pLSsrGuHgC83qAA-PGgAFygALTxuqkBJrQkADZWTAD6TERUBOwAFrwCIvnSMS70OcpNk0leaF5eKC2G6e2glkx0LCRjeAIh7L0WFERkAhaWF1RXZA4FUiQ0lmSgALYUACaXa6gcqMVgcbhnB5PW5WKHXYS6aYUPCgLhdHr9QbDMaQwE3cywvHCF7TaZFWa-AGPa6I6R6UBMTp7Kakt4fL5kJifXoMOidAhMYGgPBcSlE2ms8lxO42Ch2Tnc3n8pjCV6s1nVPYHI5cE6gXHU-Fiw2q9Vm+pncJy7gKsg8vkC01mjW7faHY4CY3Qgn3Ilq51SepemlqgytbZBUAjPl4XpPVhK3rfOQjKh-XUCOgCLIk6TvIifej25VCkV0BFq-OFrLFgWlrg5iUzOKWiJcOi1lWgABk3Z9srsNaVjv9Lq17oz9GzTudFtCVsHndEvf7bY7w5Vo9JmrdOr1WUzM-NDJYLCoLC4ACIN5Z6LJ9VQvlQUVQzDLObsKOwiJeK6lo50sbxiwibJmQqbpt84QjL01hEAImgCAALAiQA","body":"half_interval_method(math_sin, 2, 4); ","output":"3.14111328125"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Here is another example, using the half-interval method to search for a root\n    of the equation ","tag":"#text"},{"body":"$x^3 - 2x - 3 = 0$","tag":"LATEX"},{"body":" between 1\n    and 2:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":40,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDANwFMAnOgcyYAoAPAGlABPAJSgA3tlBTQLJmQItavUAGohosACYA3NgC+uQqUo1QAByoBnCpWa9RYmXIW0eoAHygADNtAGj5NS0REzsdLbcPA5O8oqgbgA83r4G+MSBpnQARpb24pLSsrGuHgC83qAA-PGgAFygALTxuqkBJrQkADZWTAD6TERUBOwAFrwCIvnSMS70OcpNk0leaF5eKC2G6e2glkx0LCRjeAIh7L0WFERkAhaWF1RXZA4FUiQ0lmSgALYUACaXa6gcqMVgcbhnB5PW5WKHXYS6aYUPCgLhdHr9QbDMaQwE3cywvHCF7TaZFWa-AGPa6I6R6UBMTp7Kakt4fL5kJifXoMOidAhMYGgPBcSlE2ms8lxO42Ch2Tnc3n8pjCV6s1nVPYHI5cE6gXHU-Fiw2q9Vm+pncJy7gKsg8vkC01mjW7faHY4CY3Qgn3Ilq51SepemlqgytbZBUAjPl4XpPVhK3rfOQjKh-XUCOgCLIk6TvIifej25VCkV0BFq-OFrLFgWlrg5iUzOKWiJcOi1lWgABk3Z9srsNaVjv9Lq17oz9GzTudFtCVsHndEvf7bY7w5Vo9JmrdOr1WUzM-NDJYLCoLC4ACIN5Z6LJ9VQvlQUVQzDLObsKOwiJeK6lo50sbxiwibJmQqbpm4pSeG4ABUNTwW4TSaKAiGNKAGACCgAiaAiQA","body":"half_interval_method(x => x * x * x - 2 * x - 3, 1, 2); ","output":"1.89306640625"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Finding fixed points of functions","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    A number ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" is called a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"fixed point","tag":"#text"}]},{"body":" of a\n    function ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" if ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":"\n    satisfies the equation ","tag":"#text"},{"body":"$f(x)=x$","tag":"LATEX"},{"body":". For some\n    functions ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" we can locate a fixed point by\n    beginning with an initial guess and applying ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":"\n    repeatedly,\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{l}\n      f(x), \\ f(f(x)), \\ f(f(f(x))), \\ \\ldots\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    until the value does not change very much.  Using this idea, we can devise a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fixed_point"},{"body":"\n    that takes as inputs a function and an initial guess and produces an\n    approximation to a fixed point of the function.  We apply the function\n    repeatedly until we find two successive values whose difference is less\n    than some prescribed tolerance:\n\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1wkaTMqDJUANsMF1Sw0PIVoFbhSn2FSlGqDwUbMIAJgD6AA5UFERkLHgANP4UgmahAOYEwkxMXLwC-sTk1LQkVlRMwqHCRFQEaQAW7IkAnrl8+QIiYhL0zOzaoK2gADwW1rb2JML6+Ub53kV+ZILNoQDuFGSNGVk5PO0doCZEZqBEwmzm8ngsO9kcM4dCouIlZRVVNXXbmdmJ55cOAcnh1VACyMCQQJNMtVhstixwQ9gXNOi8erD1ptGgEUmR0r8cvojPhAiEIlEYiwALZ0LahExMRIoB5AA","body":"const tolerance = 0.00001;\nfunction fixed_point(f, first_guess) {\n    function close_enough(x, y) {\n        return abs(x - y) < tolerance;\n    }\n    function try_with(guess) {\n        const next = f(guess);\n        return close_enough(guess, next)\n               ? next\n               : try_with(next);\n    }\n    return try_with(first_guess);\n} "},{"body":"\n    For example, we can use this method to approximate the fixed point of the\n    \n    cosine function, starting with 1 as an initial approximation:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/1.3.3#footnote-3"},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":19,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1wkaTMqDJUANsMF1Sw0PIVoFbhSn2FSlGqDwUbMIAJgD6AA5UFERkLHgANP4UgmahAOYEwkxMXLwC-sTk1LQkVlRMwqHCRFQEaQAW7IkAnrl8+QIiYhL0zOzaoK2gADwW1rb2JML6+Ub53kV+ZILNoQDuFGSNGVk5PO0doCZEZqBEwmzm8ngsO9kcM4dCouIlZRVVNXXbmdmJ55cOAcnh1VACyMCQQJNMtVhstixwQ9gXNOi8erD1ptGgEUmR0r8cvojPhAiEIlEYiwALZ0LahExMRIoB5AA","body":"fixed_point(math_cos, 1); ","output":"0.7390822985224023"},{"body":"\n    Similarly, we can find a solution to the equation\n    ","tag":"#text"},{"body":"$y=\\sin y + \\cos y$","tag":"LATEX"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":19,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1wkaTMqDJUANsMF1Sw0PIVoFbhSn2FSlGqDwUbMIAJgD6AA5UFERkLHgANP4UgmahAOYEwkxMXLwC-sTk1LQkVlRMwqHCRFQEaQAW7IkAnrl8+QIiYhL0zOzaoK2gADwW1rb2JML6+Ub53kV+ZILNoQDuFGSNGVk5PO0doCZEZqBEwmzm8ngsO9kcM4dCouIlZRVVNXXbmdmJ55cOAcnh1VACyMCQQJNMtVhstixwQ9gXNOi8erD1ptGgEUmR0r8cvojPhAiEIlEYixmk5pKAALZ0LahJjRalcADUDKZ9VCJlYrUSKAeQA","body":"fixed_point(y => math_sin(y) + math_cos(y), 1); ","output":"1.2587315962971173"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    The fixed-point process is reminiscent of the process we used for finding\n    square roots in section ","tag":"#text"},{"tag":"REF","body":"1.1.7","href":"/sicpjs/1.1.7"},{"body":".  Both are based on\n    the idea of repeatedly improving a guess until the result satisfies some\n    criterion.  In fact, we can readily formulate the\n    \n    square-root computation as a fixed-point search.  Computing the square root\n    of some number ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" requires finding a\n    ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" such that\n    ","tag":"#text"},{"body":"$y^2 = x$","tag":"LATEX"},{"body":".  Putting this equation into the\n    equivalent form ","tag":"#text"},{"body":"$y = x/y$","tag":"LATEX"},{"body":", we recognize that we\n    are looking for a fixed point of the function","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/1.3.3#footnote-4"},{"body":"$y \\mapsto x/y$","tag":"LATEX"},{"body":", and we can therefore try to\n    compute square roots as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":19,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1wkaTMqDJUANsMF1Sw0PIVoFbhSn2FSlGqDwUbMIAJgD6AA5UFERkLHgANP4UgmahAOYEwkxMXLwC-sTk1LQkVlRMwqHCRFQEaQAW7IkAnrl8+QIiYhL0zOzaoK2gADwW1rb2JML6+Ub53kV+ZILNoQDuFGSNGVk5PO0doCZEZqBEwmzm8ngsO9kcM4dCouIlZRVVNXXbmdmJ55cOAcnh1VACyMCQQJNMtVhstixwQ9gXNOi8erD1ptGgEUmR0r8cvojPhCr5aEwAI6CWKcfb5LqvJJBMKRaKxZpOaRqUBgZqJFDIklUmksACsDyAA","body":"function sqrt(x) {\n    return fixed_point(y => x / y, 1);\n} "},{"body":"              \n    Unfortunately, this fixed-point search does not converge.  Consider an\n    initial guess ","tag":"#text"},{"body":"$y_1$","tag":"LATEX"},{"body":".  The next guess is\n    ","tag":"#text"},{"body":"$y_2 = x/y_1$","tag":"LATEX"},{"body":" and the next guess is\n    ","tag":"#text"},{"body":"$y_3 = x/y_2 = x/(x/y_1) = y_1$","tag":"LATEX"},{"body":".  This results\n    in an infinite loop in which the two guesses\n    ","tag":"#text"},{"body":"$y_1$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$y_2$","tag":"LATEX"},{"body":" repeat\n    over and over, oscillating about the answer.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    One way to control such oscillations is to prevent the guesses from changing\n    so much. Since the answer is always between our guess\n    ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":"\n    and ","tag":"#text"},{"body":"$x/y$","tag":"LATEX"},{"body":", we can make a new guess that is not as\n    far from ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" as ","tag":"#text"},{"body":"$x/y$","tag":"LATEX"},{"body":"\n    by averaging ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" with\n    ","tag":"#text"},{"body":"$x/y$","tag":"LATEX"},{"body":", so that the next guess after\n    ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" is\n    ","tag":"#text"},{"body":"$\\frac{1}{2}(y+x/y)$","tag":"LATEX"},{"body":" instead of\n    ","tag":"#text"},{"body":"$x/y$","tag":"LATEX"},{"body":". The process of making such a sequence of\n    guesses is simply the process of looking for a fixed point of\n    ","tag":"#text"},{"body":"$y \\mapsto \\frac{1}{2}(y+x/y)$","tag":"LATEX"},{"body":":\n\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":true,"prependLength":23,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1wkaTMqDJUANsMF1Sw0PIVoFbhSn2FSlGqDwUbMIAJgD6AA5UFERkLHgANP4UgmahAOYEwkxMXLwC-sTk1LQkVlRMwqHCRFQEaQAW7IkAnrl8+QIiYhL0zOzaoK2gADwW1rb2JML6+Ub53kV+ZILNoQDuFGSNGVk5PO0doCZEZqBEwmzm8ngsO9kcM4dCouIlZRVVNXXbmdmJ55cOAcnh1VACyMCQQJNMtVhstixwQ9gXNOi8erD1ptGgEUmR0r8cvojPhCr5aHQAG4TNLCJqDNr5LqvUD9ADUDNAYAATMTcAtyaAmABHQSxTj7Jno2gBIJhSLRWLNJzSejUuy0ljNRJSMCtRIoZEkkVilgAVgeQA","body":"function sqrt(x) {\n    return fixed_point(y => average(y, x / y), 1);\n} "},{"body":"\n    (Note that ","tag":"#text"},{"body":"$y=\\frac{1}{2}(y+x/y)$","tag":"LATEX"},{"body":" is a simple\n    transformation of the equation ","tag":"#text"},{"body":"$y=x/y$","tag":"LATEX"},{"body":"; to derive\n    it, add ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" to both sides of the equation and\n    divide by 2.)\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    With this modification, the square-root\n    function\n    works.  In fact, if we unravel the definitions, we can see that the sequence\n    of approximations to the square root generated here is precisely the same as\n    the one generated by our original square-root\n    function\n    of section ","tag":"#text"},{"tag":"REF","body":"1.1.7","href":"/sicpjs/1.1.7"},{"body":".  This approach of averaging\n    successive approximations to a solution, a technique we call\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"average damping","tag":"#text"}]},{"body":", often aids the convergence of fixed-point searches.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 1.35","id":"#ex-1.35","child":[{"body":"\n    Show that the\n    \n    golden ratio ","tag":"#text"},{"body":"$\\phi$","tag":"LATEX"},{"body":"\n    (section ","tag":"#text"},{"tag":"REF","body":"1.2.2","href":"/sicpjs/1.2.2"},{"body":") is a fixed point of the\n    transformation ","tag":"#text"},{"body":"$x \\mapsto 1 + 1/x$","tag":"LATEX"},{"body":", and use this\n    fact to compute ","tag":"#text"},{"body":"$\\phi$","tag":"LATEX"},{"body":" by means of the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fixed_point"},{"body":" function.\n      ","tag":"#text"}],"solution":[{"body":"\n      The fixed point of the function is\n      ","tag":"#text"},{"body":"\\[ 1 + 1 / x = x \\]","tag":"LATEX"},{"body":"\n      Solving for x, we get\n      ","tag":"#text"},{"body":"\\[ x^2 = x + 1 \\]","tag":"LATEX"},{"body":"\\[ x^2 - x - 1 = 0 \\]","tag":"LATEX"},{"body":"\n      Using the quadratic equation to solve for ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":",\n      we find that one of the roots of this equation is the golden ratio\n      ","tag":"#text"},{"body":"$(1+\\sqrt{5})/2$","tag":"LATEX"},{"body":".\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":true,"prependLength":19,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1wkaTMqDJUANsMF1Sw0PIVoFbhSn2FSlGqDwUbMIAJgD6AA5UFERkLHgANP4UgmahAOYEwkxMXLwC-sTk1LQkVlRMwqHCRFQEaQAW7IkAnrl8+QIiYhL0zOzaoK2gADwW1rb2JML6+Ub53kV+ZILNoQDuFGSNGVk5PO0doCZEZqBEwmzm8ngsO9kcM4dCouIlZRVVNXXbmdmJ55cOAcnh1VACyMCQQJNMtVhstixwQ9gXNOi8erD1ptGgEUmR0r8cvojPhAiEIlEYv1ZNJUKAANSgFgoUBgTiJFAPIA","body":"fixed_point(x => 1 + (1 / x), 1); "}]},{"tag":"EXERCISE","title":"Exercise 1.36","id":"#ex-1.36","child":[{"body":"\n    Modify\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fixed_point"},{"body":"\n    so that it prints the sequence of approximations it generates, using the\n    primitive function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"display"},{"body":" shown in\n    exercise ","tag":"#text"},{"tag":"REF","body":"1.22","href":"/sicpjs/1.2.6#ex-1.22"},{"body":". Then find a solution to\n    ","tag":"#text"},{"body":"$x^x = 1000$","tag":"LATEX"},{"body":" by finding a fixed point of\n    ","tag":"#text"},{"body":"$x \\mapsto \\log(1000)/\\log(x)$","tag":"LATEX"},{"body":".  \n    \n\t(Use the primitive function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"math_log"},{"body":",\n        which computes natural logarithms.)\n      \n    Compare the number of steps this takes with and without average damping.\n    (Note that you cannot start\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fixed_point"},{"body":" with a guess of 1, as this would cause division by\n      ","tag":"#text"},{"body":"$\\log(1)=0$","tag":"LATEX"},{"body":".)\n    ","tag":"#text"}],"solution":[{"body":"\n      We modify the function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fixed_point"},{"body":"\n      as follows:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1wkaTMqDJUANsMF1Sw0PIVoFbhSn2FSlGqDwUbMIAJgD6AA5UFERkLHgANP4UgmahAOYEwkxMXLwC-sTk1LQkVlRMwqHCRFQEaQAW7IkAnrl8+QIiYhL0zOzaoK2gADwW1rb2JML6+Ub53kV+ZILNoQDuFGSNGVk5PO0doMEUTOFWdM0sO9kcM4egJkRmoETCbObyeFeZN3eHXeISmUKlUanVtj8mIlXu8OAd7h1VDCyPCEQJNMtVhstixkbd4XNOqJARYVutNo0AikyOlIfijPhAiEIlEYv1ZNJQABbOhbUJlNIsFDuLhgHl8gXsDiJABMrluQA","body":"const tolerance = 0.00001;\nfunction fixed_point(f, first_guess) {\n    function close_enough(x, y) {\n        return abs(x - y) < tolerance;\n    }\n    function try_with(guess) {\n        display(guess);\n        const next = f(guess);\n        return close_enough(guess, next)\n               ? next\n               : try_with(next);\n    }\n    return try_with(first_guess);\n} "},{"body":"\n      Here is a version with average dampening built-in:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":13,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqDwU2wgCYB9AA5UKRMnYDuFMgAs7dAG7CgnQA5sJ2NnQAtg7CRC4hLHgANBYUgkxuIQTCTExcvAIWxOTUtCQANlRM4XFUBCHe7KkAngV8RQIiYhL0zOzaoG2gADygZFQVQXSkwvpFRkUmpeZkgi0eXk3Zufk8HZ2gNhRMDhV0LSw7eRzzh6AkNJmgRMJsZKDyVzl5oADUFm+uw4XDAACY7oduuJylUanY6g1tj8mKlXu8OAd7p1VOiyFjsQJNGsNp4fCw8bcsYsuqIYeN1ptyZYMlkUVSjPgrLZHM5XEzfAFpmEItFYvEiIkpLJpKAonQfHYqokUAo1aC5QrfMr2BxUmC0ApbkA","body":"function fixed_point_with_average_dampening(f, first_guess) {\n    function close_enough(x, y) {\n        return abs(x - y) < tolerance;\n    }\n    function try_with(guess) {\n        display(guess);\n        const next = (guess + f(guess)) / 2;\n        return close_enough(guess, next)\n               ? next\n               : try_with(next);\n    }\n    return try_with(first_guess);\n} "}]},{"tag":"EXERCISE","title":"Exercise 1.37","id":"#ex-1.37","child":[{"body":"\n    An infinite\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"continued fraction","tag":"#text"}]},{"body":" is an expression of the form\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      f & = & {\\dfrac{N_1}{D_1+\n      \\dfrac{N_2}{D_2+\n      \\dfrac{N_3}{D_3+\\cdots }}}}\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    As an example, one can show that the infinite continued fraction\n    expansion with the ","tag":"#text"},{"body":"$N_i$","tag":"LATEX"},{"body":" and the\n    ","tag":"#text"},{"body":"$D_i$","tag":"LATEX"},{"body":" all equal to 1 produces\n    ","tag":"#text"},{"body":"$1/\\phi$","tag":"LATEX"},{"body":", where\n    ","tag":"#text"},{"body":"$\\phi$","tag":"LATEX"},{"body":" is the\n    \n    golden ratio (described in\n    section ","tag":"#text"},{"tag":"REF","body":"1.2.2","href":"/sicpjs/1.2.2"},{"body":"). One way to approximate\n    an infinite continued fraction is to truncate the expansion after a given\n    number of terms.  Such a truncation—a so-called\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"$k$","tag":"LATEX"},{"body":"-term finite continued\n    fraction","tag":"#text"}]},{"body":"—has the form\n    ","tag":"#text"},{"body":"\n      \\[\n      {\\dfrac{N_1}{D_1 +\n      \\dfrac{N_2}{\\ddots +\n      \\dfrac{N_K}{D_K}}}}\n      \\]\n    ","tag":"LATEX"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n        Suppose that ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"d"},{"body":" are\n        functions\n        of one argument (the term index ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":") that\n\treturn the ","tag":"#text"},{"body":"$N_i$","tag":"LATEX"},{"body":" and\n\t","tag":"#text"},{"body":"$D_i$","tag":"LATEX"},{"body":" of the terms of the continued fraction.\n        Declare a function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"cont_frac"},{"body":"\n        such that evaluating\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"cont_frac(n, d, k)"},{"body":"\n        computes the value of the ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":"-term finite\n        continued fraction.  Check your\n        function\n        by approximating ","tag":"#text"},{"body":"$1/\\phi$","tag":"LATEX"},{"body":" using\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":14,"eval":true,"prependLength":3,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChslAMYD2AdgC4D6AZgE4CGBoZRoARgKagDuNAlmWXYk2AT1ABnMgFcAJkLIBuCe07sAHuxoFe4zugwB2XMXLV6BABS9QAXgB8qADShr9p6ADWASgVA","body":"cont_frac(i => 1, i => 1, k); "},{"body":"\n        for successive values of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"k"},{"body":". How large must\n\tyou make ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"k"},{"body":" in order to get an approximation\n\tthat is accurate to 4 decimal places?\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        If your\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"cont_frac"},{"body":"function\n        generates a recursive process, write one that generates an iterative\n\tprocess. If it generates an iterative process, write one that generates\n        a recursive process.\n      ","tag":"#text"}]}]}],"solution":[{"tag":"SNIPPET","latex":false,"id":15,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsgE4CmAxgK74DOAlgG6GgAO+A9sYRRdgGakB2xAFyrNeoYiIEB9LvgCGxABS8ANKAAmqgNYBKUAG9soI6B78hIk3MHDeCqroPGnoIgPKiqoAHyhNh5wHGAPygAAz+gQEAXKC29qBgCmp2ugDUlvLmcaDpKNraANwRoAC+xa7uGdYiCnlFZdjivFIy8nagALw+KKqeXaiqAEyhhUA","body":"//recursive process\nfunction cont_frac(n, d, k) {\n    function fraction(i) {\n        return i > k\n               ? 0\n               : n(i) / (d(i) + fraction(i + 1));\n    }\n    return fraction(1);\n} "},{"tag":"SNIPPET","latex":false,"id":16,"eval":true,"prependLength":3,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChslAMYD2AdgC4D6AZgE4CGBoZRoARgKagDuNAlmWXYk2AT1ABnMgFcAJkLIBuCe07sAHuxoFe4zugwB2XCH6a6ZXgDdOABxpEC7ceOxUpJAhdKFSlWgwAKEgAaUBlQgGsASlAAb2xQRNA3Dy9hf09eUgDeUIIpGhp5GPikstAi6RphXlAAXgbQAAYE8rakgH5CAqLyVva2gC5k+kzs2oBaVFCSHJiwAJk50ABqbsLiqIV+0ABfHcqC9NG0gIjQpq3sfexicmpRnPqAPmnQWrrXlFCAJkuFIA","body":"//iterative process\nfunction cont_frac(n, d, k) {\n    function fraction(i, current) {\n        return i === 0\n               ? current\n               : fraction(i - 1, n(i) / (d(i) + current));\n    }\n    return fraction(k, 0);\n} "}]},{"tag":"EXERCISE","title":"Exercise 1.38","id":"#ex-1.38","child":[{"body":"\n    In 1737, the Swiss mathematician\n    \n    Leonhard Euler published a memoir\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"De Fractionibus Continuis","tag":"#text"}]},{"body":", which included a\n    \n    continued fraction expansion for ","tag":"#text"},{"body":"$e-2$","tag":"LATEX"},{"body":", where\n    ","tag":"#text"},{"body":"$e$","tag":"LATEX"},{"body":" is the base of the natural logarithms. In\n    this fraction, the ","tag":"#text"},{"body":"$N_i$","tag":"LATEX"},{"body":" are all 1, and the\n    ","tag":"#text"},{"body":"$D_i$","tag":"LATEX"},{"body":" are successively\n    1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ….  Write a program that uses your\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"cont_frac"},{"body":" function\n    from exercise ","tag":"#text"},{"tag":"REF","body":"1.37","href":"/sicpjs/1.3.3#ex-1.37"},{"body":" to approximate\n    ","tag":"#text"},{"body":"$e$","tag":"LATEX"},{"body":", based on Euler's expansion.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":17,"eval":true,"prependLength":11,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsgJYAuApgE4CGh+AbsaAA6kD2AxsQM7vYBmArgHYsqTfqBYjCAfW4UWACn4AaUABNlAawCUoAN7ZQB0H0HDRM8kPwi5+ZS16lSxfoW17DH0E8IPR+UAC8QaAADPqeEYYA-GIOTi7hkREAXEaypjagALSoyvw22mByKgWgANSxjs6umgDciaAAvg3evmkWGerKIXXYzdgATOViEtKymQEAfLkGDUkG-lOgmRUo2gCkoBigADyooDFDAFTL-quFW6CpKIpz8wM9tUA","body":"2 + cont_frac(i => 1,  \n              i => (i + 1) % 3 < 1 ? 2 * (i + 1) / 3 : 1,\n              20); "}]},{"tag":"EXERCISE","title":"Exercise 1.39","id":"#ex-1.39","child":[{"body":"\n    A continued fraction representation of the tangent function was\n    published in 1770 by the German mathematician\n    \n    J.H. Lambert:\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      \\tan x & = & {\\dfrac{x}{1-\n      \\dfrac{x^2}{3-\n      \\dfrac{x^2}{5-\n      \\dfrac{x^2}{ \\ddots }}}}}\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    where ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" is in radians.\n    Declare a function\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tan_cf(x, k)"},{"body":"\n    that computes an approximation to the tangent function based on\n    Lambert's formula.\n    \n\tAs in exercise ","tag":"#text"},{"tag":"REF","body":"1.37","href":"/sicpjs/1.3.3#ex-1.37"},{"body":", \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"k"},{"body":" specifies the number of terms\n\tto compute.\n      ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":18,"eval":true,"prependLength":11,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGZMChsgJYAuApgE4CGh+AbsaAA6kD2AxsQM7vYBmArgHYsqTfqBYjCAfW4UWACn4AaUABNlAawCUoAN7ZQB0H0HDRM8kPwi5+ZS16lSxfoW17DH0E8IPR+UAC8QaAADPqeEYYA-GIOTi7hkREAXEaypjagALSoyvw22mByKgWgANSxjs6umgDciaAAvg3evmkWGerKIXXYzTwCliKghOT8kizccgAeGm4txD6kouIu0rKZAQB8oP5BAaigMdOgqTknAFSgswYNSfd7OwBMoFf+OSiKd-eRWvX9o3GkzkAFtKAALSSwSDKFAAFl6IFAYMIkMBoIhUMgdSAA","body":"function tan_cf(x, k) {\n    return cont_frac(i => i === 1 ? x : - x * x,  \n                     i => 2 * i - 1,\n                     k);\n} "}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/1.3.3#footnote-link-1","child":[{"body":"We have used 0.001 as a representative\n    \"","tag":"#text"},{"body":"small","tag":"#text"},{"body":"\" number to indicate a tolerance for the acceptable error\n    in a calculation. The appropriate tolerance for a real calculation depends\n    upon the problem to be solved and the limitations of the computer and the\n    algorithm.  This is often\n    a very subtle consideration, requiring help from a\n    \n    numerical analyst or some\n    other kind of magician.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/1.3.3#footnote-link-2","child":[{"body":"This\n    can be accomplished using\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"error"},{"body":",\n    \n\twhich takes as\n\targument a string that is printed as error message along\n\twith the number of the program line that gave rise to the call of\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"error"},{"body":".\n      ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/1.3.3#footnote-link-3","child":[{"body":"\n\tTo obtain a \n\t\n\tfixed point of cosine on a calculator, \t\n\tset it to radians mode and then repeatedly press the\n\t","tag":"#text"},{"body":"$\\cos$","tag":"LATEX"},{"body":"\n\tbutton until the value does not change any longer.\n      ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/1.3.3#footnote-link-4","child":[{"body":"$\\mapsto$","tag":"LATEX"},{"body":"\n    (pronounced \"","tag":"#text"},{"body":"maps to","tag":"#text"},{"body":"\") is the mathematician's way of\n    writing\n    lambda expressions.","tag":"#text"},{"body":"$y \\mapsto x/y$","tag":"LATEX"},{"body":" means\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y => x / y"},{"body":",\n    that is, the function whose value at ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" is\n    ","tag":"#text"},{"body":"$x/y$","tag":"LATEX"},{"body":".","tag":"#text"}]}]