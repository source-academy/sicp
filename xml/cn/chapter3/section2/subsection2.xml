<SUBSECTION> 
   <NAME> 应用简单 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> </NAME> 

  <LABEL NAME="sec:env-apply-proc"></LABEL>
   <INDEX>求值的环境模型<SUBINDEX><SPLITINLINE>过程<JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>-应用示例<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>函数应用<SUBINDEX>环境模型<OPEN></OPEN></SUBINDEX></INDEX> 

  <TEXT>
     <INDEX><USE>sum_of_squares</USE><SUBINDEX><ORDER>环境</ORDER>在环境模型<SUBINDEX></SUBINDEX></SUBINDEX></INDEX> 当我们在<REF NAME="sec:substitution-model"></REF>部分引入代换模型时，我们展示了 <SPLITINLINE> 组合 (f 5) <JAVASCRIPT>函数应用 <JAVASCRIPTINLINE>f(5)</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 在给定以下<SPLITINLINE> 过程定义: <JAVASCRIPT>函数声明:</JAVASCRIPT> </SPLITINLINE>的情况下计算结果为136【16:0†source】<SNIPPET EVAL="yes">
      <EXAMPLE>f_example</EXAMPLE>
      <EXPECTED>136</EXPECTED>
      <SCHEME>
(define (square x)
  (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
      </SCHEME>
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
function sum_of_squares(x, y) {
    return square(x) + square(y);
}
function f(a) {
    return sum_of_squares(a + 1, a * 2);
}
      </JAVASCRIPT>
    </SNIPPET> 我们可以使用环境模型分析相同的示例。 图<SPACE></SPACE><REF NAME="fig:sum-squares"></REF>显示了通过求值定义创建的三个 <SPLITINLINE>过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE>对象【16:2†source】<SCHEMEINLINE>f</SCHEMEINLINE>, <SCHEMEINLINE>square</SCHEMEINLINE> ，和 <SPLITINLINE> sum-of-squares <JAVASCRIPT><JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 在 <SPLITINLINE> 全局 <JAVASCRIPT>程序</JAVASCRIPT> </SPLITINLINE> 环境中。每个 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 对象由一些代码以及指向 <SPLITINLINE> 全局 <JAVASCRIPT>程序</JAVASCRIPT> </SPLITINLINE> 环境的指针组成。 <SPLIT>  <FIGURE> <FIGURE SPLIT_SCALE="0.9" SRC="img_original/ch3-Z-G-5.svg"></FIGURE>  <CAPTION>全局框架中的过程对象。</CAPTION> </FIGURE>  <JAVASCRIPT> <FIGURE> <FIGURE SRC="img_javascript/ch3-Z-G-5.svg"></FIGURE>  <CAPTION>程序框架中的函数对象。</CAPTION> </FIGURE> </JAVASCRIPT> </SPLIT> </TEXT>

  <TEXT>
   <WEB_ONLY> &lt;!-- 图像稍后为 SICP JS 分页而更改 --&gt; &lt;!-- 图像代码在本文件的 PDF_ONLY 中重复 --&gt; <SPLIT>  <FIGURE> <FIGURE SRC="img_original/ch3-Z-G-6.svg"></FIGURE>  <CAPTION> 通过图<SPACE></SPACE><REF NAME="fig:sum-squares_scheme"></REF>中的过程计算 (f 5) 所创建的环境。 </CAPTION> </FIGURE>  <JAVASCRIPT> <FIGURE> <FIGURE SRC="img_javascript/ch3-Z-G-6.svg"></FIGURE>  <CAPTION> 通过图<SPACE></SPACE><REF NAME="fig:sum-squares"></REF>中的函数计算 <JAVASCRIPTINLINE>f(5)</JAVASCRIPTINLINE> 所创建的环境。 </CAPTION> </FIGURE> </JAVASCRIPT> </SPLIT> </WEB_ONLY> 在 <SPLITINLINE> 图<SPACE></SPACE><REF NAME="fig:f5-eval_scheme"></REF> <JAVASCRIPT>图<SPACE></SPACE><REF NAME="fig:f5-eval"></REF></JAVASCRIPT> </SPLITINLINE> 中，我们看到通过求值表达式 <SPLITINLINE> (f 5). <JAVASCRIPT><JAVASCRIPTINLINE>f(5)</JAVASCRIPTINLINE>.</JAVASCRIPT> </SPLITINLINE> 所创建的环境结构。对 <SCHEMEINLINE>f</SCHEMEINLINE> 创建了一个新环境，E1，始于一个帧 <SCHEMEINLINE>a</SCHEMEINLINE> ，<SPLITINLINE>形式参数</SPLITINLINE> <SCHEMEINLINE>f</SCHEMEINLINE> ，被绑定到参数 5。在 E1 中，我们 评估的主体【40:1†source】 <SCHEMEINLINE>f</SCHEMEINLINE> ： <SNIPPET EVAL="no">
      <SCHEME>
(sum-of-squares (+ a 1) (* a 2))
      </SCHEME>
      <JAVASCRIPT>
return sum_of_squares(a + 1, a * 2);
      </JAVASCRIPT>
    </SNIPPET>
     <SHORT_PAGE LINES="2"></SHORT_PAGE>为了求值 <SPLITINLINE> 这个组合，我们首先对子表达式进行求值。 <JAVASCRIPT>返回语句，我们首先对返回表达式的子表达式进行求值。</JAVASCRIPT> </SPLITINLINE> 第一个子表达式， <SPLITINLINE> sum-of-squares, <JAVASCRIPT><JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>, </JAVASCRIPT> </SPLITINLINE> 的值是一个 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 对象。（注意如何找到这个值：我们先在 E1 的第一个帧中查找，其中不包含 <SPLITINLINE> sum-of-squares 的绑定。 <JAVASCRIPT><JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>的绑定。</JAVASCRIPT> </SPLITINLINE> 然后我们转到封闭环境，即 <SPLITINLINE> 全局 <JAVASCRIPT>程序</JAVASCRIPT> </SPLITINLINE> 环境，并找到在 <SPLITINLINE> 图<SPACE></SPACE><REF NAME="fig:sum-squares_scheme"></REF> 中显示的绑定。） <JAVASCRIPT>图<SPACE></SPACE><REF NAME="fig:sum-squares"></REF>中的绑定。）</JAVASCRIPT> </SPLITINLINE> 另外两个子表达式通过应用原始运算进行求值【16:0†source】 <SCHEMEINLINE>+</SCHEMEINLINE> 和 <SCHEMEINLINE>*</SCHEMEINLINE> 为了对两个组合进行求值 <SPLITINLINE> (+ a 1) <JAVASCRIPT><JAVASCRIPTINLINE>a + 1</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 和 <SPLITINLINE> (* a 2) <JAVASCRIPT><JAVASCRIPTINLINE>a * 2</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 分别得到6和10。 </TEXT>

  <TEXT> 现在我们应用 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 对象 <SPLITINLINE> sum-of-squares <JAVASCRIPT><JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 到参数6和10。这会产生一个新环境，E2，其中 <SPLITINLINE>形式参数</SPLITINLINE> <SCHEMEINLINE>x</SCHEMEINLINE> 和 <SCHEMEINLINE>y</SCHEMEINLINE> 被绑定到参数。在 E2 中我们求值 <SPLITINLINE>  组合式 (+ (square x) (square y))。 <JAVASCRIPT> 语句  <JAVASCRIPT>return square(x) + square(y); </JAVASCRIPT>  </JAVASCRIPT> </SPLITINLINE> 这导致我们求值 <SPLITINLINE> (square x), <JAVASCRIPT><JAVASCRIPTINLINE>square(x)</JAVASCRIPTINLINE>,</JAVASCRIPT> </SPLITINLINE> 其中 【16:5†source】 <SCHEMEINLINE>square</SCHEMEINLINE>  在 <SPLITINLINE> 全局 <JAVASCRIPT>程序</JAVASCRIPT> </SPLITINLINE> 帧中找到和 <SCHEMEINLINE>x</SCHEMEINLINE> 是 6。再一次，我们设置一个新环境，E3，其中 【70:0†source】 <SCHEMEINLINE>x</SCHEMEINLINE> 被绑定到 6，并在其中我们评估的函数体 【74:12†cn.txt】 <SCHEMEINLINE>square</SCHEMEINLINE> ，它是 <SPLITINLINE> (* x x). <JAVASCRIPT><JAVASCRIPTINLINE>return x * x;</JAVASCRIPTINLINE>.</JAVASCRIPT> </SPLITINLINE> 同时在应用 <SPLITINLINE> sum-of-squares, <JAVASCRIPT><JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>, </JAVASCRIPT> </SPLITINLINE> 时，我们必须对子表达式求值 <SPLITINLINE>(square y), <JAVASCRIPT><JAVASCRIPTINLINE>square(y)</JAVASCRIPTINLINE>,</JAVASCRIPT> </SPLITINLINE> 其中 【16:0†source】 <SCHEMEINLINE>y</SCHEMEINLINE> 是 10。第二次调用 【16:1†source】<SCHEMEINLINE>square</SCHEMEINLINE>  创建了另一个环境，E4，其中  <SCHEMEINLINE>x</SCHEMEINLINE> ，<SPLITINLINE>形式参数</SPLITINLINE> 被绑定到 参数 6，并在我们评估的函数体中 【90:15†source】 <SCHEMEINLINE>square</SCHEMEINLINE> ，被绑定到 10。并且在 E4 中，我们必须 求值 <SPLITINLINE> (* x x). <JAVASCRIPT><JAVASCRIPTINLINE>return x * x;</JAVASCRIPTINLINE>.</JAVASCRIPT> </SPLITINLINE> 【74:12†cn.txt】</TEXT>

   <TEXT> 需要注意的重要一点是，每次调用 square 都会创建一个包含 x 绑定的新环境。我们可以在这里看到，不同的帧如何用来分开所有命名为 x 的不同局部变量。注意，由 square 创建的每个帧都指向 <SPLITINLINE> 全局 <JAVASCRIPT>程序</JAVASCRIPT> </SPLITINLINE> 环境，因为这是由 square <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 对象指示的环境。 </TEXT> 

   <TEXT> 在子表达式求值后，结果会被返回。通过两次调用square生成的值被 <SPLITINLINE> sum-of-squares, <JAVASCRIPT><JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>, </JAVASCRIPT> </SPLITINLINE>相加并返回给 f。因为我们这里的重点是环境结构，所以我们不会详细讨论这些返回值是如何从一次调用传递到另一次调用的；然而，这也是求值过程中的一个重要方面，我们将在<SPACE></SPACE><REF NAME="chap:reg"></REF>章中详细讨论。 <INDEX><USE>sum_of_squares</USE><SUBINDEX><ORDER>环境</ORDER>在环境模型<CLOSE></CLOSE></SUBINDEX></INDEX> </TEXT> 

  <EXERCISE>
    <LABEL NAME="ex:factorial-env-model"></LABEL> 在章节<SPACE></SPACE><REF NAME="sec:recursion-and-iteration"></REF>中，我们使用代换模型来分析两个 <INDEX>递归过程<SUBINDEX>与迭代过程比较</SUBINDEX></INDEX> <INDEX>迭代过程<SUBINDEX>与递归过程比较</SUBINDEX></INDEX> <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 用于计算 <INDEX><USE>factorial</USE><SUBINDEX>评估中的环境结构</SUBINDEX></INDEX> 阶乘，一个递归版本 【106:3†cn.txt】<SNIPPET EVAL="yes">
      <EXAMPLE>factorial_example</EXAMPLE>
      <EXPECTED>120</EXPECTED>
      <SCHEME>
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
      </SCHEME>
      <JAVASCRIPT>
function factorial(n) {
    return n === 1
           ? 1
           : n * factorial(n - 1);
}
      </JAVASCRIPT>
    </SNIPPET> 和一个迭代版本【110:6†cn.txt】 <SNIPPET EVAL="yes">
      <EXAMPLE>factorial_example</EXAMPLE>
      <EXPECTED>120</EXPECTED>
      <SCHEME>
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (&gt; counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
      </SCHEME>
      <JAVASCRIPT>
function factorial(n) {
    return fact_iter(1, 1, n);
}
function fact_iter(product, counter, max_count) {
    return counter &gt; max_count
           ? product
           : fact_iter(counter * product, 
                       counter + 1, 
                       max_count);
}
      </JAVASCRIPT>
    </SNIPPET> 显示由评估 <SPLITINLINE> (factorial 6) <JAVASCRIPT><JAVASCRIPTINLINE>factorial(6)</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 使用每个版本 【114:0†cn.txt】 <SCHEMEINLINE>factorial</SCHEMEINLINE>
     <SPLITINLINE>过程<JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>。<FOOTNOTE> 使用环境模型无法明确我们在章节<SPACE></SPACE><REF NAME="sec:recursion-and-iteration"></REF>中关于解释器可以在有限空间内通过尾递归执行类似 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 的 <SPLITINLINE> fact-iter <JAVASCRIPT><JAVASCRIPTINLINE>fact_iter</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 的说法。我们将在章节<SPACE></SPACE><REF NAME="sec:eceval"></REF>中处理解释器的控制结构时讨论 <INDEX>求值的环境模型<SUBINDEX>尾递归与</SUBINDEX></INDEX> <INDEX>尾递归<SUBINDEX>求值的环境模型与</SUBINDEX></INDEX> 尾递归。</FOOTNOTE> </EXERCISE>

   <INDEX>求值的环境模型<SUBINDEX><SPLITINLINE>过程<JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>-应用示例<CLOSE></CLOSE></SUBINDEX></INDEX> 
   <INDEX>函数应用<SUBINDEX>环境模型<CLOSE></CLOSE></SUBINDEX></INDEX> 

   <PDF_ONLY> &lt;!-- 图像从之前的位置移到这里以便于 SICP JS 排版 --&gt; &lt;!-- 图像代码是本文件中 WEB_ONLY 之前代码的复制 --&gt; <SPLIT>  <FIGURE> <FIGURE SRC="img_original/ch3-Z-G-6.svg"></FIGURE>  <CAPTION> 通过求值 (f 5) 以及图<SPACE></SPACE><REF NAME="fig:sum-squares_scheme"></REF>中的过程创建的环境。 </CAPTION> </FIGURE>  <JAVASCRIPT> <FIGURE> <FIGURE SRC="img_javascript/ch3-Z-G-6.svg"></FIGURE>  <CAPTION> 通过求值 <JAVASCRIPTINLINE>f(5)</JAVASCRIPTINLINE> 以及图<SPACE></SPACE><REF NAME="fig:sum-squares"></REF>中的函数创建的环境。 </CAPTION> </FIGURE> </JAVASCRIPT> </SPLIT> </PDF_ONLY> 

</SUBSECTION>
