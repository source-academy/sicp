[
  {
    "source_file": "chapter5.xml",
    "tag_type": "CHAPTER",
    "title": "Computing with Register Machines",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 1,
    "content": "We began this book by studying processes and by describing processes in terms of procedures functions written in Lisp. JavaScript. To explain the meanings of these procedures, functions, we used a succession of models of evaluation: the substitution model of chapter , the environment model of chapter , and the metacircular evaluator of chapter . Our examination of the metacircular evaluator, in particular, dispelled much of the mystery of how Lisp-like languages are interpreted. JavaScript-like languages are interpreted. But even the metacircular evaluator leaves important questions unanswered, because it fails to elucidate the mechanisms of control in a Lisp JavaScript system. For instance, the evaluator does not explain how the evaluation of a subexpression manages to return a value to the expression that uses this value , nor does the evaluator explain how some recursive procedures generate iterative processes (that is, are evaluated using constant space) whereas other recursive procedures generate recursive processes . These questions remain unanswered because the metacircular evaluator is itself a Lisp program and hence inherits the control structure of the underlying Lisp system. In order to provide a more complete description of the control structure of the Lisp evaluator, we must work at a more primitive level than Lisp itself. Also, the evaluator does not explain how some recursive functions can generate iterative processes (that is, be evaluated using constant space) whereas other recursive functions will generate recursive processes."
  },
  {
    "source_file": "chapter5.xml",
    "tag_type": "CHAPTER",
    "title": "Computing with Register Machines",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 2,
    "content": "In this chapter we We will describe processes in terms of the step-by-step operation of a traditional computer. Such a computer, or register machine , sequentially executes instructions that manipulate the contents of a fixed set of storage elements called registers . A typical register-machine instruction applies a primitive operation to the contents of some registers and assigns the result to another register. Our descriptions of processes executed by register machines will look very much like machine-language programs for traditional computers. However, instead of focusing on the machine language of any particular computer, we will examine several Lisp JavaScript procedures functions and design a specific register machine to execute each procedure. function. Thus, we will approach our task from the perspective of a hardware architect rather than that of a machine-language computer programmer. In designing register machines, we will develop mechanisms for implementing important programming constructs such as recursion. We will also present a language for describing designs for register machines. In section we will implement a Lisp JavaScript program that uses these descriptions to simulate the machines we design."
  },
  {
    "source_file": "chapter5.xml",
    "tag_type": "CHAPTER",
    "title": "Computing with Register Machines",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 3,
    "content": "Most of the primitive operations of our register machines are very simple. For example, an operation might add the numbers fetched from two registers, producing a result to be stored into a third register. Such an operation can be performed by easily described hardware. In order to deal with list structure, however, we will also use the memory operations car , head , cdr , tail , and cons , pair , which require an elaborate storage-allocation mechanism. In section we study their implementation in terms of more elementary operations."
  },
  {
    "source_file": "chapter5.xml",
    "tag_type": "CHAPTER",
    "title": "Computing with Register Machines",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 4,
    "content": "In section , after we have accumulated experience formulating simple procedures functions as register machines, we will design a machine that carries out the algorithm described by the metacircular evaluator of section . This will fill in the gap in our understanding of how Scheme expressions JavaScript programs are interpreted, by providing an explicit model for the mechanisms of control in the evaluator. In section we will study a simple compiler that translates Scheme JavaScript programs into sequences of instructions that can be executed directly with the registers and operations of the evaluator register machine."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 1,
    "content": "The explicit-control evaluator of section is a register machine whose controller interprets Scheme JavaScript programs. In this section we will see how to run Scheme JavaScript programs on a register machine whose controller is not a Scheme JavaScript interpreter."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 2,
    "content": "The explicit-control evaluator machine is it can carry out any computational process that can be described in Scheme. JavaScript. The evaluator s controller orchestrates the use of its data paths to perform the desired computation. Thus, the evaluator s data paths are universal: They are sufficient to perform any computation we desire, given an appropriate controller."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 3,
    "content": "Commercial native language of the machine, or simply machine language . Programs written in machine language are sequences of instructions that use the machine s data paths. For example, the s instruction sequence can be thought of as a machine-language program for a general-purpose computer rather than as the controller for a specialized interpreter machine."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 4,
    "content": "There are two common strategies for bridging the gap between higher-level languages and register-machine languages. The explicit-control evaluator illustrates the strategy of interpretation. An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the source language ) that may differ from the native language of the machine performing the evaluation. The primitive procedures functions of the source language are implemented as a library of subroutines written in the native language of the given machine. A program to be interpreted (called the source program ) is represented as a data structure. The interpreter traverses this data structure, analyzing the source program. As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 5,
    "content": "In this section, we explore the alternative strategy of compilation . A compiler for a given source language and machine translates a source program into an equivalent program (called the object program ) written in the machine s native language. The compiler that we implement in this section translates programs written in Scheme JavaScript into sequences of instructions to be executed using the explicit-control evaluator machine s data paths."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 6,
    "content": "Compared with interpretation, compilation can provide a great increase in the efficiency of program execution, as we will explain below in the overview of the compiler. On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified. In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 7,
    "content": "In view of the complementary advantages of compilation and interpretation, modern program-development environments pursue a mixed strategy. Lisp interpreters These systems are generally organized so that interpreted procedures functions and compiled procedures functions can call each other. This enables a programmer to compile those parts of a program that are assumed to be debugged, thus gaining the efficiency advantage of compilation, while retaining the interpretive mode of execution for those parts of the program that are in the flux of interactive development and debugging. In section , after we have implemented the compiler, we will show how to interface it with our interpreter to produce an integrated interpreter-compiler development system."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 8,
    "content": "Our compiler is much like our interpreter, both in its structure and in the function it performs. Accordingly, the mechanisms used by the compiler for analyzing expressions components will be similar to those used by the interpreter. Moreover, to make it easy to interface compiled and interpreted code, we will design the compiler to generate code that obeys the same conventions of env register, argument lists will be accumulated in argl , a procedure function to be applied will be in proc , fun , procedures functions will return their answers in val , and the location to which a procedure function should return will be kept in continue . In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 9,
    "content": "This description suggests a strategy for implementing a rudimentary compiler: We traverse the expression component in the same way the interpreter does. When we encounter a register instruction that the interpreter would perform in evaluating the expression, component, we do not execute the instruction but instead accumulate it into a sequence. The resulting sequence of instructions will be the object code. Observe the an expression for example, a component for example, (f 84 96) it f(96, 22) it performs the work of classifying the expression component (discovering that this is a procedure function application) and testing for the end of the operand list (discovering that there are two operands). list of argument expressions (discovering that there are two argument expressions). With a compiler, the expression component is analyzed only once, when the instruction sequence is generated at compile time. The object code produced by the compiler contains only the instructions that evaluate the operator and the two operands, function expression and the two argument expressions, assemble the argument list, and apply the procedure (in proc ) function (in fun ) to the arguments (in argl )."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 10,
    "content": "This is the same kind of optimization we implemented in the . But there are further opportunities to gain efficiency in compiled code. As the interpreter runs, it follows a process that must be applicable to any expression component in the language. In contrast, a given segment of compiled code is meant to execute some particular expression. component. This can make a big difference, for example in the use of the stack to save registers. When the interpreter evaluates an expression, a component, it must be prepared for any contingency. Before evaluating a subexpression, subcomponent, the interpreter saves all registers that will be needed later, because the subexpression subcomponent might require an arbitrary evaluation. A compiler, on the other hand, can exploit the structure of the particular expression component it is processing to generate code that avoids unnecessary stack operations."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 11,
    "content": "As a case in point, consider the combination (f 84 96) . application f(96, 22) . Before the interpreter evaluates the operator of the combination, function expression of the application, it prepares for this evaluation by saving the registers containing the operands argument expressions and the environment, whose values will be needed later. The interpreter then evaluates the operator function expression to obtain the result in val , restores the saved registers, and finally moves the result from val to proc . fun . However, in the particular expression we are dealing with, the operator function expression is the symbol name f , whose evaluation is accomplished by the machine operation lookup-variable-value , lookup_symbol_value , which does not alter any registers. The compiler that we implement in this section will take advantage of this fact and generate code that evaluates the operator function expression using the instruction (assign proc (op lookup-variable-value) (const f) (reg env)) assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"f\"), reg(\"env\"))) where the argument to lookup_symbol_value is extracted at compile time from the parser's representation of f(96, 22) . This code not only avoids the unnecessary saves and restores but also assigns the value of the lookup directly to proc , fun , whereas the interpreter would obtain the result in val and then move this to proc . fun ."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 12,
    "content": "A compiler can also optimize access to the environment. Having analyzed the code, the compiler can in many cases know in which frame a particular variable the value of a particular name will be located and access that frame directly, rather than performing the lookup-variable-value lookup_@symbol_@value search. We will discuss how to implement such variable access lexical addressing in section . Until then, however, we will focus on the kind of register and stack optimizations described above. There are many other optimizations that can be performed by a compiler, such as coding primitive operations in line instead of using a general apply mechanism (see exercise ); but we will not emphasize these here. Our main goal in this section is to illustrate the compilation process in a simplified (but still interesting) context."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 1,
    "content": "The explicit-control evaluator of section is a register machine whose controller interprets Scheme JavaScript programs. In this section we will see how to run Scheme JavaScript programs on a register machine whose controller is not a Scheme JavaScript interpreter."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 2,
    "content": "The explicit-control evaluator machine is it can carry out any computational process that can be described in Scheme. JavaScript. The evaluator s controller orchestrates the use of its data paths to perform the desired computation. Thus, the evaluator s data paths are universal: They are sufficient to perform any computation we desire, given an appropriate controller."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 3,
    "content": "Commercial native language of the machine, or simply machine language . Programs written in machine language are sequences of instructions that use the machine s data paths. For example, the s instruction sequence can be thought of as a machine-language program for a general-purpose computer rather than as the controller for a specialized interpreter machine."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 4,
    "content": "There are two common strategies for bridging the gap between higher-level languages and register-machine languages. The explicit-control evaluator illustrates the strategy of interpretation. An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the source language ) that may differ from the native language of the machine performing the evaluation. The primitive procedures functions of the source language are implemented as a library of subroutines written in the native language of the given machine. A program to be interpreted (called the source program ) is represented as a data structure. The interpreter traverses this data structure, analyzing the source program. As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 5,
    "content": "In this section, we explore the alternative strategy of compilation . A compiler for a given source language and machine translates a source program into an equivalent program (called the object program ) written in the machine s native language. The compiler that we implement in this section translates programs written in Scheme JavaScript into sequences of instructions to be executed using the explicit-control evaluator machine s data paths."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 6,
    "content": "Compared with interpretation, compilation can provide a great increase in the efficiency of program execution, as we will explain below in the overview of the compiler. On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified. In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 7,
    "content": "In view of the complementary advantages of compilation and interpretation, modern program-development environments pursue a mixed strategy. Lisp interpreters These systems are generally organized so that interpreted procedures functions and compiled procedures functions can call each other. This enables a programmer to compile those parts of a program that are assumed to be debugged, thus gaining the efficiency advantage of compilation, while retaining the interpretive mode of execution for those parts of the program that are in the flux of interactive development and debugging. In section , after we have implemented the compiler, we will show how to interface it with our interpreter to produce an integrated interpreter-compiler development system."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 8,
    "content": "Our compiler is much like our interpreter, both in its structure and in the function it performs. Accordingly, the mechanisms used by the compiler for analyzing expressions components will be similar to those used by the interpreter. Moreover, to make it easy to interface compiled and interpreted code, we will design the compiler to generate code that obeys the same conventions of env register, argument lists will be accumulated in argl , a procedure function to be applied will be in proc , fun , procedures functions will return their answers in val , and the location to which a procedure function should return will be kept in continue . In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 9,
    "content": "This description suggests a strategy for implementing a rudimentary compiler: We traverse the expression component in the same way the interpreter does. When we encounter a register instruction that the interpreter would perform in evaluating the expression, component, we do not execute the instruction but instead accumulate it into a sequence. The resulting sequence of instructions will be the object code. Observe the an expression for example, a component for example, (f 84 96) it f(96, 22) it performs the work of classifying the expression component (discovering that this is a procedure function application) and testing for the end of the operand list (discovering that there are two operands). list of argument expressions (discovering that there are two argument expressions). With a compiler, the expression component is analyzed only once, when the instruction sequence is generated at compile time. The object code produced by the compiler contains only the instructions that evaluate the operator and the two operands, function expression and the two argument expressions, assemble the argument list, and apply the procedure (in proc ) function (in fun ) to the arguments (in argl )."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 10,
    "content": "This is the same kind of optimization we implemented in the . But there are further opportunities to gain efficiency in compiled code. As the interpreter runs, it follows a process that must be applicable to any expression component in the language. In contrast, a given segment of compiled code is meant to execute some particular expression. component. This can make a big difference, for example in the use of the stack to save registers. When the interpreter evaluates an expression, a component, it must be prepared for any contingency. Before evaluating a subexpression, subcomponent, the interpreter saves all registers that will be needed later, because the subexpression subcomponent might require an arbitrary evaluation. A compiler, on the other hand, can exploit the structure of the particular expression component it is processing to generate code that avoids unnecessary stack operations."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 11,
    "content": "As a case in point, consider the combination (f 84 96) . application f(96, 22) . Before the interpreter evaluates the operator of the combination, function expression of the application, it prepares for this evaluation by saving the registers containing the operands argument expressions and the environment, whose values will be needed later. The interpreter then evaluates the operator function expression to obtain the result in val , restores the saved registers, and finally moves the result from val to proc . fun . However, in the particular expression we are dealing with, the operator function expression is the symbol name f , whose evaluation is accomplished by the machine operation lookup-variable-value , lookup_symbol_value , which does not alter any registers. The compiler that we implement in this section will take advantage of this fact and generate code that evaluates the operator function expression using the instruction (assign proc (op lookup-variable-value) (const f) (reg env)) assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"f\"), reg(\"env\"))) where the argument to lookup_symbol_value is extracted at compile time from the parser's representation of f(96, 22) . This code not only avoids the unnecessary saves and restores but also assigns the value of the lookup directly to proc , fun , whereas the interpreter would obtain the result in val and then move this to proc . fun ."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 12,
    "content": "A compiler can also optimize access to the environment. Having analyzed the code, the compiler can in many cases know in which frame a particular variable the value of a particular name will be located and access that frame directly, rather than performing the lookup-variable-value lookup_@symbol_@value search. We will discuss how to implement such variable access lexical addressing in section . Until then, however, we will focus on the kind of register and stack optimizations described above. There are many other optimizations that can be performed by a compiler, such as coding primitive operations in line instead of using a general apply mechanism (see exercise ); but we will not emphasize these here. Our main goal in this section is to illustrate the compilation process in a simplified (but still interesting) context."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 1,
    "content": "The explicit-control evaluator of section is a register machine whose controller interprets Scheme JavaScript programs. In this section we will see how to run Scheme JavaScript programs on a register machine whose controller is not a Scheme JavaScript interpreter."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 2,
    "content": "The explicit-control evaluator machine is it can carry out any computational process that can be described in Scheme. JavaScript. The evaluator s controller orchestrates the use of its data paths to perform the desired computation. Thus, the evaluator s data paths are universal: They are sufficient to perform any computation we desire, given an appropriate controller."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 3,
    "content": "Commercial native language of the machine, or simply machine language . Programs written in machine language are sequences of instructions that use the machine s data paths. For example, the s instruction sequence can be thought of as a machine-language program for a general-purpose computer rather than as the controller for a specialized interpreter machine."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 4,
    "content": "There are two common strategies for bridging the gap between higher-level languages and register-machine languages. The explicit-control evaluator illustrates the strategy of interpretation. An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the source language ) that may differ from the native language of the machine performing the evaluation. The primitive procedures functions of the source language are implemented as a library of subroutines written in the native language of the given machine. A program to be interpreted (called the source program ) is represented as a data structure. The interpreter traverses this data structure, analyzing the source program. As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 5,
    "content": "In this section, we explore the alternative strategy of compilation . A compiler for a given source language and machine translates a source program into an equivalent program (called the object program ) written in the machine s native language. The compiler that we implement in this section translates programs written in Scheme JavaScript into sequences of instructions to be executed using the explicit-control evaluator machine s data paths."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 6,
    "content": "Compared with interpretation, compilation can provide a great increase in the efficiency of program execution, as we will explain below in the overview of the compiler. On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified. In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 7,
    "content": "In view of the complementary advantages of compilation and interpretation, modern program-development environments pursue a mixed strategy. Lisp interpreters These systems are generally organized so that interpreted procedures functions and compiled procedures functions can call each other. This enables a programmer to compile those parts of a program that are assumed to be debugged, thus gaining the efficiency advantage of compilation, while retaining the interpretive mode of execution for those parts of the program that are in the flux of interactive development and debugging. In section , after we have implemented the compiler, we will show how to interface it with our interpreter to produce an integrated interpreter-compiler development system."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 8,
    "content": "Our compiler is much like our interpreter, both in its structure and in the function it performs. Accordingly, the mechanisms used by the compiler for analyzing expressions components will be similar to those used by the interpreter. Moreover, to make it easy to interface compiled and interpreted code, we will design the compiler to generate code that obeys the same conventions of env register, argument lists will be accumulated in argl , a procedure function to be applied will be in proc , fun , procedures functions will return their answers in val , and the location to which a procedure function should return will be kept in continue . In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 9,
    "content": "This description suggests a strategy for implementing a rudimentary compiler: We traverse the expression component in the same way the interpreter does. When we encounter a register instruction that the interpreter would perform in evaluating the expression, component, we do not execute the instruction but instead accumulate it into a sequence. The resulting sequence of instructions will be the object code. Observe the an expression for example, a component for example, (f 84 96) it f(96, 22) it performs the work of classifying the expression component (discovering that this is a procedure function application) and testing for the end of the operand list (discovering that there are two operands). list of argument expressions (discovering that there are two argument expressions). With a compiler, the expression component is analyzed only once, when the instruction sequence is generated at compile time. The object code produced by the compiler contains only the instructions that evaluate the operator and the two operands, function expression and the two argument expressions, assemble the argument list, and apply the procedure (in proc ) function (in fun ) to the arguments (in argl )."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 10,
    "content": "This is the same kind of optimization we implemented in the . But there are further opportunities to gain efficiency in compiled code. As the interpreter runs, it follows a process that must be applicable to any expression component in the language. In contrast, a given segment of compiled code is meant to execute some particular expression. component. This can make a big difference, for example in the use of the stack to save registers. When the interpreter evaluates an expression, a component, it must be prepared for any contingency. Before evaluating a subexpression, subcomponent, the interpreter saves all registers that will be needed later, because the subexpression subcomponent might require an arbitrary evaluation. A compiler, on the other hand, can exploit the structure of the particular expression component it is processing to generate code that avoids unnecessary stack operations."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 11,
    "content": "As a case in point, consider the combination (f 84 96) . application f(96, 22) . Before the interpreter evaluates the operator of the combination, function expression of the application, it prepares for this evaluation by saving the registers containing the operands argument expressions and the environment, whose values will be needed later. The interpreter then evaluates the operator function expression to obtain the result in val , restores the saved registers, and finally moves the result from val to proc . fun . However, in the particular expression we are dealing with, the operator function expression is the symbol name f , whose evaluation is accomplished by the machine operation lookup-variable-value , lookup_symbol_value , which does not alter any registers. The compiler that we implement in this section will take advantage of this fact and generate code that evaluates the operator function expression using the instruction (assign proc (op lookup-variable-value) (const f) (reg env)) assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"f\"), reg(\"env\"))) where the argument to lookup_symbol_value is extracted at compile time from the parser's representation of f(96, 22) . This code not only avoids the unnecessary saves and restores but also assigns the value of the lookup directly to proc , fun , whereas the interpreter would obtain the result in val and then move this to proc . fun ."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 12,
    "content": "A compiler can also optimize access to the environment. Having analyzed the code, the compiler can in many cases know in which frame a particular variable the value of a particular name will be located and access that frame directly, rather than performing the lookup-variable-value lookup_@symbol_@value search. We will discuss how to implement such variable access lexical addressing in section . Until then, however, we will focus on the kind of register and stack optimizations described above. There are many other optimizations that can be performed by a compiler, such as coding primitive operations in line instead of using a general apply mechanism (see exercise ); but we will not emphasize these here. Our main goal in this section is to illustrate the compilation process in a simplified (but still interesting) context."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 1,
    "content": "The explicit-control evaluator of section is a register machine whose controller interprets Scheme JavaScript programs. In this section we will see how to run Scheme JavaScript programs on a register machine whose controller is not a Scheme JavaScript interpreter."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 2,
    "content": "The explicit-control evaluator machine is it can carry out any computational process that can be described in Scheme. JavaScript. The evaluator s controller orchestrates the use of its data paths to perform the desired computation. Thus, the evaluator s data paths are universal: They are sufficient to perform any computation we desire, given an appropriate controller."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 3,
    "content": "Commercial native language of the machine, or simply machine language . Programs written in machine language are sequences of instructions that use the machine s data paths. For example, the s instruction sequence can be thought of as a machine-language program for a general-purpose computer rather than as the controller for a specialized interpreter machine."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 4,
    "content": "There are two common strategies for bridging the gap between higher-level languages and register-machine languages. The explicit-control evaluator illustrates the strategy of interpretation. An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the source language ) that may differ from the native language of the machine performing the evaluation. The primitive procedures functions of the source language are implemented as a library of subroutines written in the native language of the given machine. A program to be interpreted (called the source program ) is represented as a data structure. The interpreter traverses this data structure, analyzing the source program. As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 5,
    "content": "In this section, we explore the alternative strategy of compilation . A compiler for a given source language and machine translates a source program into an equivalent program (called the object program ) written in the machine s native language. The compiler that we implement in this section translates programs written in Scheme JavaScript into sequences of instructions to be executed using the explicit-control evaluator machine s data paths."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 6,
    "content": "Compared with interpretation, compilation can provide a great increase in the efficiency of program execution, as we will explain below in the overview of the compiler. On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified. In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 7,
    "content": "In view of the complementary advantages of compilation and interpretation, modern program-development environments pursue a mixed strategy. Lisp interpreters These systems are generally organized so that interpreted procedures functions and compiled procedures functions can call each other. This enables a programmer to compile those parts of a program that are assumed to be debugged, thus gaining the efficiency advantage of compilation, while retaining the interpretive mode of execution for those parts of the program that are in the flux of interactive development and debugging. In section , after we have implemented the compiler, we will show how to interface it with our interpreter to produce an integrated interpreter-compiler development system."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 8,
    "content": "Our compiler is much like our interpreter, both in its structure and in the function it performs. Accordingly, the mechanisms used by the compiler for analyzing expressions components will be similar to those used by the interpreter. Moreover, to make it easy to interface compiled and interpreted code, we will design the compiler to generate code that obeys the same conventions of env register, argument lists will be accumulated in argl , a procedure function to be applied will be in proc , fun , procedures functions will return their answers in val , and the location to which a procedure function should return will be kept in continue . In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 9,
    "content": "This description suggests a strategy for implementing a rudimentary compiler: We traverse the expression component in the same way the interpreter does. When we encounter a register instruction that the interpreter would perform in evaluating the expression, component, we do not execute the instruction but instead accumulate it into a sequence. The resulting sequence of instructions will be the object code. Observe the an expression for example, a component for example, (f 84 96) it f(96, 22) it performs the work of classifying the expression component (discovering that this is a procedure function application) and testing for the end of the operand list (discovering that there are two operands). list of argument expressions (discovering that there are two argument expressions). With a compiler, the expression component is analyzed only once, when the instruction sequence is generated at compile time. The object code produced by the compiler contains only the instructions that evaluate the operator and the two operands, function expression and the two argument expressions, assemble the argument list, and apply the procedure (in proc ) function (in fun ) to the arguments (in argl )."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 10,
    "content": "This is the same kind of optimization we implemented in the . But there are further opportunities to gain efficiency in compiled code. As the interpreter runs, it follows a process that must be applicable to any expression component in the language. In contrast, a given segment of compiled code is meant to execute some particular expression. component. This can make a big difference, for example in the use of the stack to save registers. When the interpreter evaluates an expression, a component, it must be prepared for any contingency. Before evaluating a subexpression, subcomponent, the interpreter saves all registers that will be needed later, because the subexpression subcomponent might require an arbitrary evaluation. A compiler, on the other hand, can exploit the structure of the particular expression component it is processing to generate code that avoids unnecessary stack operations."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 11,
    "content": "As a case in point, consider the combination (f 84 96) . application f(96, 22) . Before the interpreter evaluates the operator of the combination, function expression of the application, it prepares for this evaluation by saving the registers containing the operands argument expressions and the environment, whose values will be needed later. The interpreter then evaluates the operator function expression to obtain the result in val , restores the saved registers, and finally moves the result from val to proc . fun . However, in the particular expression we are dealing with, the operator function expression is the symbol name f , whose evaluation is accomplished by the machine operation lookup-variable-value , lookup_symbol_value , which does not alter any registers. The compiler that we implement in this section will take advantage of this fact and generate code that evaluates the operator function expression using the instruction (assign proc (op lookup-variable-value) (const f) (reg env)) assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"f\"), reg(\"env\"))) where the argument to lookup_symbol_value is extracted at compile time from the parser's representation of f(96, 22) . This code not only avoids the unnecessary saves and restores but also assigns the value of the lookup directly to proc , fun , whereas the interpreter would obtain the result in val and then move this to proc . fun ."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 12,
    "content": "A compiler can also optimize access to the environment. Having analyzed the code, the compiler can in many cases know in which frame a particular variable the value of a particular name will be located and access that frame directly, rather than performing the lookup-variable-value lookup_@symbol_@value search. We will discuss how to implement such variable access lexical addressing in section . Until then, however, we will focus on the kind of register and stack optimizations described above. There are many other optimizations that can be performed by a compiler, such as coding primitive operations in line instead of using a general apply mechanism (see exercise ); but we will not emphasize these here. Our main goal in this section is to illustrate the compilation process in a simplified (but still interesting) context."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 1,
    "content": "The explicit-control evaluator of section is a register machine whose controller interprets Scheme JavaScript programs. In this section we will see how to run Scheme JavaScript programs on a register machine whose controller is not a Scheme JavaScript interpreter."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 2,
    "content": "The explicit-control evaluator machine is it can carry out any computational process that can be described in Scheme. JavaScript. The evaluator s controller orchestrates the use of its data paths to perform the desired computation. Thus, the evaluator s data paths are universal: They are sufficient to perform any computation we desire, given an appropriate controller."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 3,
    "content": "Commercial native language of the machine, or simply machine language . Programs written in machine language are sequences of instructions that use the machine s data paths. For example, the s instruction sequence can be thought of as a machine-language program for a general-purpose computer rather than as the controller for a specialized interpreter machine."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 4,
    "content": "There are two common strategies for bridging the gap between higher-level languages and register-machine languages. The explicit-control evaluator illustrates the strategy of interpretation. An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the source language ) that may differ from the native language of the machine performing the evaluation. The primitive procedures functions of the source language are implemented as a library of subroutines written in the native language of the given machine. A program to be interpreted (called the source program ) is represented as a data structure. The interpreter traverses this data structure, analyzing the source program. As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 5,
    "content": "In this section, we explore the alternative strategy of compilation . A compiler for a given source language and machine translates a source program into an equivalent program (called the object program ) written in the machine s native language. The compiler that we implement in this section translates programs written in Scheme JavaScript into sequences of instructions to be executed using the explicit-control evaluator machine s data paths."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 6,
    "content": "Compared with interpretation, compilation can provide a great increase in the efficiency of program execution, as we will explain below in the overview of the compiler. On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified. In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 7,
    "content": "In view of the complementary advantages of compilation and interpretation, modern program-development environments pursue a mixed strategy. Lisp interpreters These systems are generally organized so that interpreted procedures functions and compiled procedures functions can call each other. This enables a programmer to compile those parts of a program that are assumed to be debugged, thus gaining the efficiency advantage of compilation, while retaining the interpretive mode of execution for those parts of the program that are in the flux of interactive development and debugging. In section , after we have implemented the compiler, we will show how to interface it with our interpreter to produce an integrated interpreter-compiler development system."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 8,
    "content": "Our compiler is much like our interpreter, both in its structure and in the function it performs. Accordingly, the mechanisms used by the compiler for analyzing expressions components will be similar to those used by the interpreter. Moreover, to make it easy to interface compiled and interpreted code, we will design the compiler to generate code that obeys the same conventions of env register, argument lists will be accumulated in argl , a procedure function to be applied will be in proc , fun , procedures functions will return their answers in val , and the location to which a procedure function should return will be kept in continue . In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 9,
    "content": "This description suggests a strategy for implementing a rudimentary compiler: We traverse the expression component in the same way the interpreter does. When we encounter a register instruction that the interpreter would perform in evaluating the expression, component, we do not execute the instruction but instead accumulate it into a sequence. The resulting sequence of instructions will be the object code. Observe the an expression for example, a component for example, (f 84 96) it f(96, 22) it performs the work of classifying the expression component (discovering that this is a procedure function application) and testing for the end of the operand list (discovering that there are two operands). list of argument expressions (discovering that there are two argument expressions). With a compiler, the expression component is analyzed only once, when the instruction sequence is generated at compile time. The object code produced by the compiler contains only the instructions that evaluate the operator and the two operands, function expression and the two argument expressions, assemble the argument list, and apply the procedure (in proc ) function (in fun ) to the arguments (in argl )."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 10,
    "content": "This is the same kind of optimization we implemented in the . But there are further opportunities to gain efficiency in compiled code. As the interpreter runs, it follows a process that must be applicable to any expression component in the language. In contrast, a given segment of compiled code is meant to execute some particular expression. component. This can make a big difference, for example in the use of the stack to save registers. When the interpreter evaluates an expression, a component, it must be prepared for any contingency. Before evaluating a subexpression, subcomponent, the interpreter saves all registers that will be needed later, because the subexpression subcomponent might require an arbitrary evaluation. A compiler, on the other hand, can exploit the structure of the particular expression component it is processing to generate code that avoids unnecessary stack operations."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 11,
    "content": "As a case in point, consider the combination (f 84 96) . application f(96, 22) . Before the interpreter evaluates the operator of the combination, function expression of the application, it prepares for this evaluation by saving the registers containing the operands argument expressions and the environment, whose values will be needed later. The interpreter then evaluates the operator function expression to obtain the result in val , restores the saved registers, and finally moves the result from val to proc . fun . However, in the particular expression we are dealing with, the operator function expression is the symbol name f , whose evaluation is accomplished by the machine operation lookup-variable-value , lookup_symbol_value , which does not alter any registers. The compiler that we implement in this section will take advantage of this fact and generate code that evaluates the operator function expression using the instruction (assign proc (op lookup-variable-value) (const f) (reg env)) assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"f\"), reg(\"env\"))) where the argument to lookup_symbol_value is extracted at compile time from the parser's representation of f(96, 22) . This code not only avoids the unnecessary saves and restores but also assigns the value of the lookup directly to proc , fun , whereas the interpreter would obtain the result in val and then move this to proc . fun ."
  },
  {
    "source_file": "section5.xml",
    "tag_type": "SECTION",
    "title": "Compilation",
    "parent_title": "Computing with Register Machines",
    "depth": 1,
    "paragraph_index": 12,
    "content": "A compiler can also optimize access to the environment. Having analyzed the code, the compiler can in many cases know in which frame a particular variable the value of a particular name will be located and access that frame directly, rather than performing the lookup-variable-value lookup_@symbol_@value search. We will discuss how to implement such variable access lexical addressing in section . Until then, however, we will focus on the kind of register and stack optimizations described above. There are many other optimizations that can be performed by a compiler, such as coding primitive operations in line instead of using a general apply mechanism (see exercise ); but we will not emphasize these here. Our main goal in this section is to illustrate the compilation process in a simplified (but still interesting) context."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 1,
    "content": "Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the definition declaration of a recursive factorial factorial procedure function by calling compile : by passing as first argument to compile the result of applying parse to a string representation of the program (here using ` $\\ldots$ ` , which work like single and double quotation marks but allow the string to span multiple lines): (compile '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))) 'val 'next) compile(parse(` function factorial(n) { return n === 1 ? 1 : factorial(n - 1) * n; } `), \"val\", \"next\"); We have specified that the value of the define expression declaration should be placed in the val register. We don t care what the compiled code does after executing the define , declaration, so our choice of next \"next\" as the linkage descriptor is arbitrary."
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Compile determines that the expression is a definition, so it The function compile determines that it was given a function declaration, so it transforms it to a constant declaration and then calls compile-definition to compile compile_declaration . This compiles code to compute the value to be assigned (targeted to val ), followed by code to install the definition, declaration, followed by code to put the value of the define (which is the symbol ok ) declaration (which is the value undefined ) into the target register, followed finally by the linkage code. Env The env register is preserved around the computation of the value, because it is needed in order to install the definition. declaration. Because the linkage is next , \"next\" , there is no linkage code in this case. The skeleton of the compiled code is thus $\\langle save$ env $if\\ modified\\ by\\ code\\ to\\ compute\\ value\\rangle$ $\\langle compilation\\ of\\ definition\\ value, target$ val$, linkage$ next$\\rangle$ $\\langle restore$ env $if\\ saved\\ above\\rangle$ (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) save env if modified by code to compute value compilation of declaration value, target val , linkage \"next\" restore env if saved above perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 3,
    "content": "The expression that is to be compiled to produce the value for the variable name factorial is a lambda lambda expression whose value is the procedure function that computes factorials. Compile The function compile handles this by calling compile-lambda , compile_lambda_expression , which compiles the procedure function body, labels it as a new entry point, and generates the instruction that will combine the procedure function body at the new entry point with the runtime environment and assign the result to val . The sequence then skips around the compiled procedure function code, which is inserted at this point. The procedure function code itself begins by extending the procedure s definition function s declaration environment by a frame that binds the formal parameter n to the procedure function argument. Then comes the actual procedure function body. Since this code for the value of the variable name doesn t modify the env register, the optional save and restore shown above aren t generated. (The procedure function code at entry2 entry1 isn t executed at this point, so its use of env is irrelevant.) Therefore, the skeleton for the compiled code becomes (assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (n)) (reg argl) (reg env)) $\\langle compilation\\ of\\ procedure\\ body\\rangle$ after-lambda1 (perform (op define-variable!) (const factorial) (reg val) (reg env)) (assign val (const ok)) $\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), label(\"entry1\"), reg(\"env\"))), go_to(label(\"after_lambda2\")), \"entry1\", assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))), assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), reg(\"argl\"), reg(\"env\"))), compilation of function body \"after_lambda2\", perform(list(op(\"assign_symbol_value\"), constant(\"factorial\"), reg(\"val\"), reg(\"env\"))), assign(\"val\", constant(undefined))"
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 4,
    "content": "A procedure function body is always compiled (by compile-lambda-body ) compile_lambda_body ) as a sequence with target val and linkage return . \"next\" . The sequence body in this case consists of a single if expression: return statement: (if (= n 1) 1 (* (factorial (- n 1)) n)) return n === 1 ? 1 : factorial(n - 1) * n; The function compile_return_statement generates code to revert the stack using the marker and to restore the continue register, and then compiles the return expression with target val and linkage \"return\" , because its value is to be returned from the function. Compile-if The return expression is a conditional expression, for which compile_conditional generates code that first computes the predicate (targeted to val ), then checks the result and branches around the true branch if the predicate is false. Env Registers env and continue are preserved around the predicate code, since they may be needed for the rest of the if conditional expression. Since the if expression is the final expression (and only expression) in the sequence making up the procedure body, its target is val and its linkage is return , so the The true and false branches are both compiled with target val and linkage return . \"return\" . (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the procedure.) function.) $\\langle save$ continue, env $if\\ modified\\ by\\ predicate\\ and\\ needed\\ by\\ branches\\rangle$ $\\langle compilation\\ of\\ predicate, target$ val$,\\ linkage$ next$\\rangle$ $\\langle restore$ continue, env $if\\ saved\\ above\\rangle$ (test (op false?) (reg val)) (branch (label false-branch4)) true-branch5 $\\langle compilation\\ of\\ true\\ branch, target$ val$,\\ linkage$ return$\\rangle$ false-branch4 $\\langle compilation\\ of\\ false\\ branch, target$ val$,\\ linkage$ return$\\rangle$ after-if3 $\\texttt{ }\\texttt{ }$revert_stack_to_marker(), restore(\"continue\"), save continue , env if modified by predicate and needed by branches compilation of predicate, target val , linkage \"next\" restore continue , env if saved above test(list(op(\"is_falsy\"), reg(\"val\"))), branch(label(\"false_branch4\")), \"true_branch3\", compilation of true branch, target val , linkage \"return\" \"false_branch4\", compilation of false branch, target val , linkage \"return\" \"after_cond5\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 5,
    "content": "The predicate (= n 1) n === 1 is a procedure call. function application (after transformation of the operator combination). This looks up the operator (the symbol = ) function expression (the symbol \"===\" ) and places this value in proc . fun . It then assembles the arguments 1 and the value of n into argl . Then it tests whether proc fun contains a primitive or a compound procedure, function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the after-call after_call label. The compound branch must set up continue to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the operator and operands function and argument expressions don t result in any saving of registers, because in this case those evaluations don t modify the registers in question. (assign proc (op lookup-variable-value) (const =) (reg env)) (assign val (const 1)) (assign argl (op list) (reg val)) (assign val (op lookup-variable-value) (const n) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch17)) compiled-branch16 (assign continue (label after-call15)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch17 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call15 $\\texttt{ }\\texttt{ }$assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))), assign(\"val\", constant(1)), assign(\"argl\", list(op(\"list\"), reg(\"val\"))), assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))), assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))), test(list(op(\"is_primitive_function\"), reg(\"fun\"))), branch(label(\"primitive_branch6\")), \"compiled_branch7\", assign(\"continue\", label(\"after_call8\")), save(\"continue\"), push_marker_to_stack(), assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))), go_to(reg(\"val\")), \"primitive_branch6\", assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))), \"after_call8\","
  },
  {
    "source_file": "subsection5.xml",
    "tag_type": "SUBSECTION",
    "title": "An Example of Compiled Code",
    "parent_title": "Compilation",
    "depth": 2,
    "paragraph_index": 6,
    "content": "The true branch, which is the constant 1, compiles (with target val and linkage return ) \"return\" ) to (assign val (const 1)) (goto (reg continue)) $\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)), go_to(reg(\"continue\")), The code for the false branch is another procedure function call, where the procedure function is the value of the symbol * , \"*\" , and the arguments are n and the result of another procedure function call (a call to factorial ). Each of these calls sets up proc fun and argl and its own primitive and compound branches. Figure shows the complete compilation of the definition declaration of the factorial procedure. function. Notice that the possible save and restore of continue and env around the predicate, shown above, are in fact generated, because these registers are modified by the procedure function call in the predicate and needed for the procedure function call and the return \"return\" linkage in the branches."
  }
]