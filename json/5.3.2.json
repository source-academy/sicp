[{"id":"/sicpjs/5.3.2","tag":"TITLE","body":"5.3.2  \n    Maintaining the Illusion of Infinite Memory"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    The representation method outlined in\n    section ","tag":"#text"},{"tag":"REF","body":"5.3.1","href":"/sicpjs/5.3.1"},{"body":" solves the problem of\n    implementing list structure, provided that we have an infinite amount of\n    memory. With a real computer we will eventually run out of free space in\n    which to construct new pairs.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.3.2#footnote-1"},{"body":" However, most of the pairs\n    generated in a typical computation are used only to hold intermediate\n    results.  After these\n    results are accessed, the pairs are no longer needed—they are ","tag":"#text"},{"tag":"EM","child":[{"body":"\n    garbage","tag":"#text"}]},{"body":".  For instance, the computation\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"accumulate((x, y) => x + y,\n           0,\n           filter(is_odd, enumerate_interval(0, n)))"},{"body":"\n    constructs two lists: the enumeration and the result of filtering\n    the enumeration.  When the accumulation is complete, these lists are\n    no longer needed, and the allocated memory can be reclaimed.  If we\n    can arrange to collect all the garbage periodically, and if this turns\n    out to recycle memory at about the same rate at which we construct new\n    pairs, we will have preserved the illusion that there is an infinite\n    amount of memory.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    In order to recycle pairs, we must have a way to determine which\n    allocated pairs are not needed (in the sense that their contents can\n    no longer influence the future of the computation).  The method we\n    shall examine for accomplishing this is known as ","tag":"#text"},{"tag":"EM","child":[{"body":"garbage\n    collection","tag":"#text"}]},{"body":".  Garbage collection is based on the observation that, at\n    any moment in \n    an interpretation based on list-structured memory,\n    the only objects that can\n    affect the future of the computation are those that can be reached by\n    some succession of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    operations starting from the pointers that are currently in the machine\n    registers.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.3.2#footnote-2"},{"body":"  Any memory cell that is not so accessible may be\n    recycled.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    There are many ways to perform garbage collection.  The method we\n    shall examine here is called \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"stop-and-copy","tag":"#text"}]},{"body":".  The basic idea is to divide memory into two\n    halves: \"","tag":"#text"},{"body":"working memory","tag":"#text"},{"body":"\" and \"","tag":"#text"},{"body":"free memory.","tag":"#text"},{"body":"\"  When\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    constructs pairs, it allocates these in working memory.  When working memory\n    is full, we perform garbage collection by locating all the useful pairs in\n    working memory and copying these into consecutive locations in free memory.\n    (The useful pairs are located by tracing all the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n     and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    pointers, starting with the machine registers.)  Since we do not copy the\n    garbage, there will presumably be additional free memory that we can\n    use to allocate new pairs.  In addition, nothing in the working memory\n    is needed, since all the useful pairs in it have been copied.  Thus,\n    if we interchange the roles of working memory and free memory, we can\n    continue processing; new pairs will be allocated in the new working\n    memory (which was the old free memory).  When this is full, we can\n    copy the useful pairs into the new free memory (which was the old\n    working memory).","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/5.3.2#footnote-3"},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Implementation of a stop-and-copy garbage collector","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    We now use our register-machine language to describe the stop-and-copy\n    algorithm in more detail.  We will assume that there is a register\n    called \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":" that contains a pointer to a structure\n    that eventually points at all accessible data.  This can be arranged by\n    storing the contents of all the machine registers in a preallocated list\n    pointed at by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":" just before starting\n    garbage collection.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/5.3.2#footnote-4"},{"body":"\n    We also assume that, in addition to the current working memory, there is\n    free memory available into which we can copy the useful data.  The current\n    working memory consists of vectors whose base addresses are in \n    registers called\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_heads"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_tails"},{"body":",\n    and the free memory is in registers called \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"new_heads"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"new_tails"},{"body":".","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Garbage collection is triggered when we exhaust the free cells in the\n    current working memory, that is, when a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    operation attempts to increment the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":"\n    pointer beyond the end of the memory vector.  When the garbage-collection\n    process is complete, the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":" pointer will\n    point into the new memory, all objects accessible from the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":" will have been moved to the new memory,\n    and the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":" pointer will indicate the next\n    place in the new memory where a new pair can be allocated.  In addition,\n    the roles of working memory and new memory will have been\n    interchanged—new pairs will be constructed in the new memory,\n    beginning at the place indicated by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":", and\n    the (previous) working memory will be available as the new memory for the\n    next garbage collection.\n    Figure ","tag":"#text"},{"tag":"REF","body":"5.15","href":"/sicpjs/5.3.2#fig-5.15"},{"body":"\n    shows the arrangement of memory just before and just after garbage\n    collection.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"90%","src":"img_javascript/Fig5.15c.std.svg","id":"#fig-5.15","captionHref":"/sicpjs/5.3.2#fig-5.15","captionName":"Figure 5.15 ","captionBody":[{"body":"\n\t    Reconfiguration of memory by the garbage-collection process.\n\t  ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    The state of the garbage-collection process is controlled by\n    maintaining two pointers:\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"scan"},{"body":".  These are initialized to point to the\n    beginning of the new memory.  The algorithm begins by relocating the pair\n    pointed at by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":" to the beginning of the new\n    memory.  The pair is copied, the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":" pointer\n    is adjusted to point to the new location, and the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":" pointer is incremented.  In addition, the\n    old location of the pair is marked to show that its contents have been\n    moved.  This marking is done as follows: In the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    position, we place a special tag that signals that this is an already-moved\n    object.  (Such an object is traditionally called a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"broken heart","tag":"#text"}]},{"body":".)","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/5.3.2#footnote-5"},{"body":"\n    In the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    position we place a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"forwarding address","tag":"#text"}]},{"body":" that points at the location to which the object\n    has been moved.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    After relocating the root, the garbage collector enters its basic\n    cycle.  At each step in the algorithm, the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"scan"},{"body":" pointer\n    (initially pointing at the relocated root) points at a pair that has\n    been moved to the new memory but whose\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    pointers still refer to objects in the old memory.  These objects are each\n    relocated, and the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"scan"},{"body":" pointer is incremented.\n    To relocate an object (for example, the object indicated by the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    pointer of the pair we are scanning) we check to see if the object has\n    already been moved (as indicated by the presence of a broken-heart tag\n    in the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    position of the object).  If the object has not\n    already been moved, we copy it to the place indicated by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":",\n    update ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":", set up a broken heart at the\n    object's old location, and update the pointer to the object (in this\n    example, the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    pointer of the pair we are scanning) to point\n    to the new location.  If the object has already been moved, its\n    forwarding address (found in the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    position of the broken heart) is substituted for the pointer in the pair\n    being scanned. Eventually, all accessible objects will have been moved and\n    scanned, at which point the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"scan"},{"body":" pointer will\n    overtake the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":" pointer and the process will\n    terminate.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    We can specify the stop-and-copy algorithm as a sequence of instructions for\n    a register machine.  The basic step of relocating an object is accomplished\n    by a subroutine called\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"relocate_old_result_in_new"},{"body":".\n      \n    This subroutine gets its argument, a pointer to the object to be relocated,\n    from a register named \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"old"},{"body":".  It relocates the designated object\n    (incrementing ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":" in the process),\n    puts a pointer to the relocated object into a register called \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"new"},{"body":", and returns by branching to the entry\n    point stored in the register\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"relocate_continue"},{"body":".\n      \n    To begin garbage collection, we invoke this subroutine to relocate the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":" pointer, after initializing\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"scan"},{"body":".\n    When the relocation of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":" has been\n    accomplished, we install the new pointer as the new\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":" and enter the main loop of the garbage\n    collector.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"\"begin_garbage_collection\",\n  assign(\"free\", constant(0)),\n  assign(\"scan\", constant(0)),\n  assign(\"old\", reg(\"root\")),\n  assign(\"relocate_continue\", label(\"reassign_root\")),\n  go_to(label(\"relocate_old_result_in_new\")),\n\"reassign_root\",\n  assign(\"root\", reg(\"new\")),\n  go_to(label(\"gc_loop\")),"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    In the main loop of the garbage collector we must determine whether\n    there are any more objects to be scanned.  We do this by testing\n    whether the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"scan"},{"body":" pointer is coincident with\n    the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":" pointer.  If the pointers are equal,\n    then all accessible objects have been relocated, and we branch to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gc_flip"},{"body":",\n    which cleans things up so that we can continue the interrupted computation.\n    If there are still pairs to be scanned, we call the relocate subroutine to\n    relocate the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    of the next pair (by placing the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    pointer in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"old"},{"body":").  The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"relocate_continue"},{"body":"\n    register is set up so that the subroutine will return to update the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    pointer.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"\"gc_loop\",\n  test(list(op(\"===\"), reg(\"scan\"), reg(\"free\"))),\n  branch(label(\"gc_flip\")),\n  assign(\"old\", list(op(\"vector_ref\"), reg(\"new_heads\"), reg(\"scan\"))),\n  assign(\"relocate_continue\", label(\"update_head\")),\n  go_to(label(\"relocate_old_result_in_new\")),"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    At\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"update_head"},{"body":",\n    we modify the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    pointer of the pair being scanned, then proceed to relocate the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    of the pair.  We return to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"update_tail"},{"body":"\n    when that relocation has been accomplished. After relocating and updating\n    the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":",\n    we are finished scanning that pair, so we continue with the main loop.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"\"update_head\",\n  perform(list(op(\"vector_set\"), \n               reg(\"new_heads\"), reg(\"scan\"), reg(\"new\"))),\n  assign(\"old\", list(op(\"vector_ref\"), \n                     reg(\"new_tails\"), reg(\"scan\"))),\n  assign(\"relocate_continue\", label(\"update_tail\")),\n  go_to(label(\"relocate_old_result_in_new\")),\n\n\"update_tail\",\n  perform(list(op(\"vector_set\"), \n               reg(\"new_tails\"), reg(\"scan\"), reg(\"new\"))),\n  assign(\"scan\", list(op(\"+\"), reg(\"scan\"), constant(1))),\n  go_to(label(\"gc_loop\")),"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    The subroutine\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"relocate_old_result_in_new"},{"body":"\n    relocates objects as follows: If the object to be relocated (pointed at by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"old"},{"body":") is not a pair, then we return the same\n    pointer to the object unchanged (in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"new"},{"body":").\n    (For example, we may be scanning a pair whose\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    is the number 4.  If we represent the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n4"},{"body":", as described in\n    section ","tag":"#text"},{"tag":"REF","body":"5.3.1","href":"/sicpjs/5.3.1"},{"body":", then we want the\n    \"","tag":"#text"},{"body":"relocated","tag":"#text"},{"body":"\"","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    pointer to still be ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n4"},{"body":".)  Otherwise, we\n    must perform the relocation.  If the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    position of the pair to be relocated contains a broken-heart tag, then the\n    pair has in fact already been moved, so we retrieve the forwarding address\n    (from the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    position of the broken heart) and return this in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"new"},{"body":". If the pointer in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"old"},{"body":" points at a yet-unmoved pair, then we move\n    the pair to the first free cell in new memory (pointed at by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":") and set up the broken heart by storing a\n    broken-heart tag and forwarding address at the old location.\n    The subroutine\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"relocate_old_result_in_new"},{"body":"\n    uses a register \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"oldht"},{"body":"\n    to hold the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    or the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    of the object pointed at by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"old"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-6","body":"6","href":"/sicpjs/5.3.2#footnote-6"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n\"relocate_old_result_in_new\",\n  test(list(op(\"is_pointer_to_pair\"), reg(\"old\"))),\n  branch(label(\"pair\")),\n  assign(\"new\", reg(\"old\")),\n  go_to(reg(\"relocate_continue\")),\n\"pair\",\n  assign(\"oldht\", list(op(\"vector_ref\"), \n                       reg(\"the_heads\"), reg(\"old\"))),\n  test(list(op(\"is_broken_heart\"), reg(\"oldht\"))),\n  branch(label(\"already_moved\")),\n  assign(\"new\", reg(\"free\")),     // new location for pair\n  // Update $\\texttt{free}$ pointer\n  assign(\"free\", list(op(\"+\"), reg(\"free\"), constant(1))),\n  // Copy the head and tail to new memory\n  perform(list(op(\"vector_set\"),\n               reg(\"new_heads\"), reg(\"new\"),\n               reg(\"oldht\"))),\n  assign(\"oldht\", list(op(\"vector_ref\"), \n                       reg(\"the_tails\"), reg(\"old\"))),\n  perform(list(op(\"vector_set\"),\n               reg(\"new_tails\"), reg(\"new\"),\n               reg(\"oldht\"))),\n  // Construct the broken heart\n  perform(list(op(\"vector_set\"),\n               reg(\"the_heads\"), reg(\"old\"),\n               constant(\"broken_heart\"))),\n  perform(list(op(\"vector_set\"),\n               reg(\"the_tails\"), reg(\"old\"),\n               reg(\"new\"))),\n  go_to(reg(\"relocate_continue\")),\n\"already_moved\",\n  assign(\"new\", list(op(\"vector_ref\"), \n                     reg(\"the_tails\"), reg(\"old\"))),\n  go_to(reg(\"relocate_continue\")),\n      "}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    At the very end of the garbage collection process, we interchange the\n    role of old and new memories by interchanging pointers: interchanging\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_heads"},{"body":"\n    with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"new_heads"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_tails"},{"body":"\n    with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"new_tails"},{"body":".\n    We will then be ready to perform another garbage\n    collection the next time memory runs out.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":87,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQGY0CYBQuAzAVwDsBjAFwEsB7E0KgZwH0KBDAcw4FMATZgDZMKACjI0AtgAc63EhQA0oCgAturTgEpQAb1ygDoAE7cKRI-SbMpbKkbGSZJORW0AyN6DVteD6bPltAF4Q5TUNDgBuXABffGJyajpjbg4REjYJbm0dFLMLUCFGUQAiEw4SpQyszUjQOMJSSlpLFnLhbiNmbgAPKRFeqRy881aInn4i0UGlMtSS2vr4pqT6duLO7r7mcoG+4ZN8+m9fdioBPaHFhoTm5PESYrZ5EQA3NgEibN0RgqmREoPJ7ySqgd6fbJ1G4rFoMFhA9jyLb9QY5fSGQ6jOHjPiCYSXWYI54UBbRaGJWFEpGDZjgr6XA6mLEnERnC6o67LCnJARsABG3Au1W+uUxf3xJV5AoEoOFnMa3LGUsFyIZPzFY3YXFx-xmoEl-MFpKWCru9GVAmRgkN7P26qZBRZbIZ8tuq1ANH6cvtR0KEs9ssykJNbthVk9nTYq1VqN06IMGuxNjsao82K1EzxxRELNRswDtViXLNHqkkejNM9Ik9yMZvqdtguLJrHNdMOSEaMUZaVs7z14jGrUlrPqxzpb+yhxfdEjYAGt1BwaKxl9wCCIqI9FKBZ2QVJvuEoLYwlFIyGjDKAEaBeNxiqAgqAlyvmLfs5vioXL1QCKANywLVVN9XAvS9DGvD8KEYB9ChoGg5yIYcLREY8jxtK1kOAzQvzAhMHXoERggAPlARhTGYB4KBcQczyUSDGBwgwYlAQUyIYX9-x2VIOi6QYRCw0DcOvcoYJ4CguI4HiRF3fdnCUdYqN47ZdgE6JcLw31CIfEiyPEyjqJEWin3I-T5EHcpsLUwxmNY7g43UlijCMGh7Eg2Y+R8J9lwoGgGC3IwiBLABaILQDYRgyIkPkBG4Ul4yWckSxkfonjIOdBN+ehUrnAFkriuJQ2SKQiEYFQRGypQ6RFeLE2y3KSpUBY3g+L5C0S90BDghD+gXABPJR2Gi6rL2E7hxCMXgYPCxgaDIEQ+oGxtWX5GLLJq-DsVIW8CAPXwTHG3hNHi9SAH5QC2tdduO3CAC5lCW-aXMOslTXdabZvm7h+pSA6GPsjENqsEgiAEC5HomhjrrAs6Lp25xeChy87u4ABHIgPk+76WRZcGB2wo6HMMM6cbGp7IcJgw7veuaFvu84RFxhi2unWFnx8lCbTrLF-hKNmaFBC020VLyX2AkQ+eYSCArNYZ1vrbgfGW+mJalwLVks0Ai1e2FZwXCSpO9PRLxiigrzoKizJgkoACpSGmqgOHh62SisgxCvoXgmBsCg92ku9GE4Yb1MTLIIsDh9Ql50wSkR06zfkajY9und-fDkJHxKXSY4p6GwRauyghI3JTKgmCqqnHOkcc5z7FDgOeFmUg5xIGgAHc1lRr57xCnd53UBTOjiy84kvRNPcYb29xe3AQFAAAVABNWAAFEABFQFgAB5SAADk5+XgAlcB8GvHeAFUAFkACFD+YReV6t4GosH6JryvzfN4AGTvpfl6tvk4IylfnQe84A54H13gAcR-g-DOxQjCbgqMArcG9wEwL-hnKQFAjAu1wNeWAB9N7QPvhg-UUhnJILwSA0259P7fxIY-EGQCqEoLPjvVey8ABiu817oKtrDXauDT6b2YAANQAIKfzPsvZgC9l5zz4RnW2GQIoOydkI6hoAr6EIANLLx3swAAEsvcRB8FEMIznyZyC4SDMG8EYEk0RtbJF1uoLBXR3Ebl4D0DKiZkz2FgGgkhdFvHM2cfQVxzBgag2sNgrSRsAa+n8SIWh9Df5VCYWE92vc9Yt1pPnZgvVyKeN8RtZJO8RESKkTIuR5j0mgGiQILJ7YIl92sBQ2JrlQn-Q0liZJBCiHoJCT46e2TIlWPgnIOxCsHGdPiXLPpth7DaM3nogxxjTF1JXhk0GzThZiW6DFCQrBeplgGEc0pvogZEGfvYQU3AJDaDOufa+t8GE3URlYABNAYrPHOQ8p5WiP5pIfh8hyVh4GIP+Y80AZ0wEQJ3sQ3+oAwXqWuaDaFgLUl8NRbhKwAj4aYthaANhHDuE714e8xGnQa7QtmJucEVBJoUFOXwFiRz8os2SK3Lsw5PH3JhQk3pBRkkHIFScs5ArNBKClaMlp50SA8rYHyuJ7jLljiWmquVwsrCeLVT0zKSYlmGWwe4NwiMACEurjUsjVWay11qUzOjtaADwiMcwK18Pq9OoAXk3wPnwgAPoGxGtrTUR0fO-L+QaQ0OTDUYYIoR4VQJjaGz1JqE0RtQQGhhwa02K29aEbFubY3qXjYmx8pKuE8NXqmuN6bC2PgGUih+eb60FvDT6ipYjJHSNkfIutZaG2dtCCstZRiTFmPQXsks1zblzP1UKw1urVXhrTOWrNfq3m-21bOlg3zLR6vDUuxMK77D6vXcOzNPqo0guXru90ELsGIIXcehZBQz0ZrNV4K9FaIDgJTSQh9YYWDuNfZmk9gNQOrszZejt17QiBJzTurW2T0WHpg+qj90Hz1rs8BurtZ86HoOA8kfFJBtq7XA1hsYR7YP4d-Vmqt5LKUofaiB9pNAODUYNaenDX7XUMfg3+5tJHUPyqBsuKqhTimYd41BnjcGvUjsfN2qpfbalifY2R-d1ipn2PEnRmjSY5NKYEze3R+iJ2bK0-gWesAEESCoNQV4dl3bQX7PHYEUET6aPIVQJzLn1DuyiUGFgbAEHUDvDBf4UNkklHHlIXkvVQQAEZpVxeNSUGlLk0sZfUvFgA1KCbA+XcLxaCiVsrYF4vOyUKVhQmWUwlGAFVxrBWssAFI2tNfsCUdOPWOvNYtSEQb5WssAB4xs1cm0Eabl54tEXm4YRbc36vVYW1li1eX2vjea8G5bBh4seCq7gQsLD7z+cC1QVzFFqHEmgo+WL6keYEr4KCN7h1dtgR5rOVQzBYCQBKAYJQf2VAA8gATMCjFLzhJyW4xzzmbvBZaRuaQTT5O+h5ldpHrnQQBaSzO90ulELdBIK8OwdAsgvAyteHHQXmAheFI9xGs5+gnFPIjhnTOwvMAi0ju8MO6dc+R4zlp+SIQs4cmz9IQZtKgGSZE+nov3ay5qEoAgHwyIbYcsr27PPQ5C78yL27VJxLM4fKz5VHqfCc4C7j9QZuGKuy86bPXjv7tIiqlL9SMvfyFwVza9NzoCDYQ11r7I33Cbu7u1uB7MO-HGuSUnMCyqywUcMiblHipQuhyUCnnOMeze58F1HnOae5Beqz2LnP3v8+VwpkXz34lvdh4L4YRpRPYQEF5BQC2WZxI+VpGNHyRhByqHUCcE8YR1BsmnwIYoZeG-L-h50xnJAlBPAcS+zct4fEGpNqAAgJgC6kXYNvkg3Hd+9Bd9ktQAgyz2AX64A134OJWtA8a5-2FX-Bw2kqlVJ-T8F3YedlNiJdByCCCjXoGCY-bgbgEA9SOA0-ZA0AQrUAVLRAoSTRAVGCFkb-LAsCCfaZHwRgAAbWvx6AAF08DBRH9MVCDLxiC58KDoDqDaCH9OglYLhv8YcHIQ42kwMCASANw2C+DrJ4oR5DB796CCD316BkDp5Z4L5xFoBDEeE4cDkS5zJuINgIN5CUhJI9CAQxJOU4ddJY8LYoIGZdDFJKp85jMB4+ss5NBmoIQu8XE2k6oMpD9soYJGknFLxslipSoRB99chEY-DHxkkehN92A0pFhEZEwEtZBcFh58Agj5Vkp5lwUOJ0Nyp4j0oMoHIcs+sHksFeoz82A0pQAe48pzsHIbIF87IID1JrwfIpBaDFZspxDcIoi6YLgejGDEkxxPRCCpCmIMjDA0MSAkcPgqAAAvbgHI9SfogIpIjaFI5wNIiQ+KbJRLKMX2OuQOYokYgoY4ngLNEoEIxqdvAwM6G4u4lFFOMOS4n1a4gMJ4h4qsKHBvO6C4guSOTcOYoQJY7OZfM6YE6geYpYwiJ4-41ON4yObKcEhvM6bKeE6uFyP2V4w8fUJuFuduFINGO8U2HuFEmHBoUeDaA4n2FQUjVpXJbgVuZgGSA8FYgwa8KAAALVIUiScIBB5OXiHnAj8zIBgn5NsK4OuLIBFM5M0R704AlLaQFJKEVIqCNxQX6MiW8Jd2vGyi4ntkdk43FMfElKMMUgBANJMCNNsXIVmjlNdyPxP2VL1lVOQMdOEjglNjNJVKlL62choBJE1PvEDMM09BBijAR1mldP7n9IBDDOsAjN72jNlJDNNkTJMGKBclTNjP1mMLKG9K4mzJMBNM9M0Q4DIHzMUkez9GzERh5g9I1xPx10MB5kYDIGeFBHNKkkzk7JIAWFbIMB5h+V4G7L9ItOlNHMHKX2HIlGcFbnHLdPjJKAXJnIbIlBME6k7KoksM3C+CXLjMnIDMFFmijL3OBlijbwch5iomkEPOrOlLvKkHXJvP9AEF4BUBJFBwnN7NHK-MHPinTJYj6DzNVMGHLJQTkFeDApXOgsgvvG4DpCjBckfLHxi3xA3OzGyz6FBDzCwtKHgplXJyHLrNKHBAfNVIouvJewlEon3Nih-OXOPIBHosvNfNouwoSEopXO4potwh5giw4BlCYqPN7KEplH4p+wlFICQp4pYpKFkteA4oEolG4tErQoBD4t+NAGArYCIB6DQtrOe04tKCzPkt7OotIp5hpQsoLNsqkuNglDYDsstJKBcscrbIlD5FculJ8s8rnOwtlI0tVLTOsolDHJCpXLHICrIoBEYtX3ApUukq4t8r6wIEAsvGAuIKn1goUpys9UYAQtNmYMbFrJ7ILNKvOCKphwsO0NZHCCnw0tc0oGxLWkvDqvNgMiqoX2apHzauAoXJIIHDyt7KGqn2KoaWZI0GqtGoLKGrn0dM6oTjMnSGmqatXxatH0IlqpMi6tWoWrKr6tavsHatFJQXtO41yt9OYt7MuuGpqr1ONy4xmoXzmrcvusWph0P2INVjNGYDIhJPIFP3WONlMBn2YE9GMvxB5ihKoBhPUBRNnJX1wi0gDzqhKDhoRsHJh2IKhqmikHT1OHCChsqn6q6Chu+vBqcI0CGktwpn+B5iFNBCFNItMtymCoV3PGRvZrVN5AqA135rZtUuwrDNBDDOFpSrMqLOSkjN3PtM5sTNlpTJNMlqctFqLKzNH1TPFs1tJJzNVp5pFtKGtIVlUWNIVtBFNttMNqeNvMasKtBAKtILVq8uwp6qKoGnCDn1dsCtKHGsdqqHWsKt9ritXOmsWqDpZJ9qNqltyg6Qms5xeqn1Duxw6UjoV3TrKrOrwmPNppigJqJpsLzsGhiiUErKMoT39PztPwrwzxptLrxKQpahQq6CcOd3WhLpWlrsJsr2Lp4hrqUH0sMvboaOmPlS31EFOPlJQUzP9NrKeLCl7oz2HqMplWQtH0rsIOWqsJojIC9vUD+ujEBq+GBt6NIj2pWusOQNjopiV2wTmUVL7ymSmBfC2pckHEXpRqYIdtIJMOjlDu-p-tnzKv-uDNvqAb6KZGHGgspxIGpynvr0gZRvvo8WwQgeQbbLkA4FUAZj1uPKZhzrAh3oMmgo0rA08Rikv1wbnoIfxkIOySVuTPPIVvXw5MJi9KDM6VgJPzAcdP4O9KtIAbwa4a1QL0PxpqmBgloZ4kYGGIMFbn3ALpEA-yiSYX7r0IHx-1aIpmvBLi6NOCWhJjzqmHxj4fPsgM0UoJglIAAMft4ajmDIsfUmdoHHMdYL3xoMfC-vjisKuOUVtL4Gdh8bOkiUaTmW0DuhLnkbAmQKEeDOkkEIfs8WsfQPS2cdwg9vccoK8edPgPMZiepJMeEBgmdEkeEAyaWEriyccYWDINsd5XsfydqZ-1ClSy8buLCaYQifGMRkYb1pLNTLYenp+2ppluwWkcEZaZiYkerqkcfBkb0LkYL0UfODshUfyPKc-BGcsZQWscfAaeVTmSVtNUKfOvvCqlKd-rcZaY8d6CoLOYMAbHpmMYHtMewniaaiqkqdHnGaMCuZAequybYIecXq2Z9IGI0cUi0ZiYmLAjhcyOFmtvNrtOcirOEPYZvPBu3I+ABsKJggxopJidWeUdUcaRQjPMtB6J2baM0UucfHwMpbxeqPSkefYj-DPTmW+Zpd0asbYJscVUac8W+bZZGk0SGvcQBdesHFuZydFcMAsMZc7KpcKKjs6R+esjAJaIRZzhxZVZZdKaWj1eZYSNhcRh1YMBIdWqYeKhVoVvkhluYflrRfX3PqtesLnsGZNIda4a1oNtYeELdcvt3oKJZcNJRe9aqLSnDcYDURNNdcIMTF6DGiICokIjqE1lAL2PlQ+Bxd3IFMNk+TyJYE+xEGpjVzxIbu7vxl-1zoHsbpgmSX+GFCipYrlEAeXyraGnPqaPAIL1KIrdmAkBBmoCS0qMo3hkMJ4n4YkP4M2KcLClBjPKojHJdzheyU6nglJwLaDBGevHBCmgig+hbanc0cbvPr42YFLfBB0pzjOgHZPcUpIGbjbg7mPIWExOeYuBvcpOzeFmTbIFTeWL3b5eKFrK0P2usLPHPp-A5ZYHJfom0YL2SN4FSPGK1drbAmFxjMfEgi2BTejASBt18EQ8qYVvTczZziTZ6AI+A96fSMRZLFpKOMRKDlwhDlY6uMntRMrnRPPwoExIBKuMglzcln8jVh7BPrkDIFii+IvpRnl1yF+vE-+qk+BoJdRgrmXwRNxKuNzeXbEr0J47vcXbzcM8UkE84-eIOScOM4pjOk3e6jQss90-eJE5iT7FWCKrk-xoDyU5JqkFrLruJvUFJtLGdyqe05ePrkBLgUKLs8Jj45ZZc5i6uM85aG85XzOjxsC8xIHYBMbmfcJI7hJO7lCjZO2N-epN9GY-pPE2FkiQq+WJpuZyUDC8omclBk6Fp00Sa7zKGqa-TamIMBl3KBL3l0G-cqXZ3PM8HlcLG7lHkmruZxh0m-c8tHS5ASakppdzW7jxiSPsk87mk6vLLYigeSGgcHkE65iiMB-L3APDWgMKa4ZKqIcUSYe+cGM0m+49cI8PoBs+rvqqa6W7zsLeq6xAg6vsHEB5YpB9Pehfbde4sJpuB+qNkkreW6DHsPcINXdZh-IgFPh5a93Zx9ahdxQ7Q-q5LFh6kmJ9SBL2+-R-ZMcbQqagW93enhnjAHEXAHAGXmvk-kPi5XoGmgu5iiu+wR+Vu-u4x4ykYbGm4GR1ELA7QmlD+h0fOikF4HPPohV6gjV9Yll8e8TcBi3GWYY8MAMN6GwWqPEmPEl5u86CW5k+R3+5Att8oGtHV9ZBt5d6V9c3l-lRkK4PokN4X1ll2fvGcB6HEkggMd99j7HvY4U0hUvzWtj7E8-Dk-2gD+WLD8DxTEiUAhcCMF6gz7j63DonN+lUKBtCZkxNz+V8VzaUggr6z9cGr7A9r+PF-YMPIwnb4ET5f2DWxHJaoiT5TzOib9c3SCYR2SaRT2Rlj67C94d+dAn875-U4ITVe8Qh193L14L9Ql7k+7Y6dLPFEkJ-jPh5lMmvVKv-EiJ+Z7kn1HVMmu1Jf+WMzni+At89P4x4AhNujwOKPFH1LkQqA3AToo+AsJ4cAOqbHsAkCeooJIkUAvMvAMI4tIKeG0GXFQHlywCoBG4DBsvlQH9A8OHXaXpsEO50ANwHbSBqhB8ZAMQejA7+rRBYEo11SxAzBhVHYEr5KaodRDq90iRt9yB5sJ3l0GoEkBjMySUQdd0oESCVOqwBfu71kFS8uuCg+BBJxoGQRjMLIHQa9zgE0dAOmAkQjoMxwap6Y+g6nsTggFbh8OxgxAaQH14a5SAGUCws6DchH5XBQgtpCX2u7l9AIJ7RDuYJFRf50IQQmvq90c6k5kIJ-QIbuwNT7sPgh7GaHNHiFZBw+HdfviW2gJwwh+N7KfliSfzhDse+JXIbtDr7ShaioUMXlFBigfsc4d0Z0Dex8F6wMBjgxUM4MqFG8ABB4U8PvSPz804iLLNroFx64oIegCfKwQYUmHvFbSCXS8KEzaQ201wXQ+HifzC7Qcl+oAWYZHCojFAFhRMVfPsPEirDPB6w+vqMOnycCuat7ZOLsMsRdhyAtxEzuMieF7hug64c4V-0yGC1OA-Qu4WBDugPD9QfMQ4fcVXwSwzhVfXoa-xP5bDGhOwrjmwDxyFCdSKI9QNCMXywi8SFUW4dsJBFzBBm4I4lJKS9ZYjtw8PPEQiIpjAirij+AgC5AkAkilhesBkUyM+FrCfh3Q3quFwBEEirivAG5MOCyASAXIKWUALPHES8BbwzKXyPp1biZ1Nw1AS-DPhThiiy+YIcmowEKFo0i4TxRLMlgKIIJL8P4cvrT00Zo8z+swVxjVSIY5xDRbAcvmn0kgEBzR1-POlaIx42jvaZVHGo8x8DvBga1gOaNB3kYWsq4A7TwU+xfZElJBygVlNULCjnc6hV5VoeoBWFfCYRFw9XqMPLAZcARiQzROfjEiP9NK8PG2hzyyD68iGSQiEMiBSFxtpMfEKwWKxQTSYEgMEcMI-m7B0BVQzY-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-Aqw-WUbLX12BqkT8gmwwoKUgC8kcaUeBmchByncRbEHACLB5B4B3YuuZoDipxrsB85pNmwWTVHiAWsV+N7FDbF4oU39ASg79LoC4VB4AgmJKmp2WpvgIabVNHlKSh5vxCKafNANABv5sYm+jqqYW4LR6SC1pAGN+MITSiwTJ3hsFWldTVJWE1Nk4qimzcFWXcQpaMtaWqSnzGLoubRNbmo6OdjhwXQjAtyl9AACt7lHZBBFggoidQ61j8wNtAqEqPYSIaeW5WJyvbQF2tvULrT1rIB9bRAwhIekYA4Ad1CZgUvnOtv8k9Sd1Y2+XBixlzbb3Ea2jbXTPjl2MNQEuekCNoO27b5cfKuJBizG2Xa4cMeVXPdoMLXb8It25YttrG0iA2tHWy-MwG63vBetVAfrWQEG3mBligbd7bPHQAYBQAF8AXpvAPgLw0d4iHeOIkgQC99Ec8eObFpMDrgfNwyYzD5vqaCsjmKTUJKC0JmxbdIbwcmsMhx4ZRqdp2uJEyh8S5NwQI0nzZRI2hkFGd8c8rTxh3WoM5k3O3DJmjSZhJ925NBddDXY1u1yKyusnR9lm2g7uMEO8KEtuh16Q4dj80nWuCko8xmd0cJQCDvm1g79dUOmHSbuWJW6QIUeWGuQE6Ta7bwc2hbZDsN1O6aAQ2-Pp7rtRnYnEyhVQuoQpQQB5EZ8WABdjdwP1fO6IEyn7QBDS7KtPNW3X7oN3LaBtQe+HYkzZHJNTUG2X7G0nCZZ7Y4Oe+3Ytvz2w7C9j8rpjEjtTu6JQYTKTAUiKSGZsE3GwmLXr1316jdBe4PcXvUB5JpMPe9VuXo70riXqWehVD7t13g7h9gesfb6oX1l7292FN4ZMlsQGYvd2enXXbqH3+6G9zu8faNL0wH6ZkvehNLPuwpzoBQaDHBDzV+1HB-twOk-bnsd3G6m9+feDjchf0z7H9pQL5IAiP2xwP9owL-YPtX3n6R9jesfRAZ+SgGd94BlgC6KgOEwYDFgOAz-rr2IH19Rep9DqvQPxRYaOGHAw5DwO2JUl8Bh3QHv-0oHqDdqMAwCHQw0H1IdBgg8vtP0IG89SBy-VwfYMYHODOQwfvwGr24HGmN2hg4QbP1CGSDj8gfpdHhgUH1amBzjNxhkO0G5Df2hQ-wd-3MHR9pB0DB0jEOUGJQkmf7TJnv3979DRzeQ-nG-3GGiDyhlg+YaiRd76x0+qw1oYkPX799JBWZHoZ4MGHP9RhzoCvqYMX6ADnECZDYlCP378Y4e3zBdWrz-809YdR0SljtzXZ9cqOPIxbolClFQQn21HKUVKPYVisBRh3DXi4VhElAvUd2ZMPQKtGODJQSrPUe5yo5mjoAVo-LkmGhROj4hm2BUeryq4BjQxgPJMMLVjHrD2FVrL0ZVz9HYigxto5KM2NdHusqxoo50JmNbHOsOx8YwNn2PZ4mjGx2YyRBBGLHAjJQEbGtiVGFHLjqwEQEceGOgAnjpxpY6UCmwXHGj7xz43MdAATZfjDxibM8cqOHHrjWxqExCfV0AglsgJ6Y3Ca+MkR7jSJkoERGhNTH1jLRrY7icRPp7HjkxkJWsc6GzCSIFqHxF0YOyomCTmxr46PyxOkmTsjJ2E4Sa+NphOj6RxPU+CrLZHMKDx5VoejRbe6YjAhuI8IYSMK15c5HNI+dmvAV0KB6gtjaIHRCGbJIxm0zYHAs0xQrNUeKLdmEU1imyy6WhMo61tYsMJTWW+KMVvU1HhotXmzPX3tr7sqAADPacvDCaOyXZZ06addNJNX9Gmr0z6cMDCbpyCWsWkVpy1zAzOF5A8uJrmCVjvSyVOrQZq3IGdIaH5YsiO2m1rkaKqZiNmLWy3-iRChZIMvlvDqLlat+cqpRcF5hVlN2s6srM2cEBwQXyUeeTS6YBADZLTfZLsoOZq0bZ9Np0jsz3mh3JUozH5AWH2e82a61wVWgEAHVIIrmhzA5CMwYGE3ZmZuSZhKgZv37nkTgGZhs1mdPL7nRy+ZgQJXyiTMlrNx53cqeeNN3yUIC513RubXMDgNz-prcwlqLNxmKzQAuc4GdEAxalzGVQc4dWS2Dm-zumh0-Gb3Pnk2KyZnkQCCfOAtJKG2TMxOeQu7lrzWZAs5uHvN1n2zmF16o4aOxvnPNAIT89BYjp+i4L-ZL8w+e3PJjgLm5+c0Gc4Oh73TCW+C+xdwuVKOzrZ6zfhdC55miLt5wsw+Z7NeTaLmNNg-xc00lBpy7F8cyJYrr+IZz8ZtcglvUs4WGzqmiSwees3aWuN5ZtRCBc-LflStXms3VBYS2BaDLc59i72Z4tKXgjyRw-ZVsHP-knGY51mY2YBAfAbSvAXqKyRoCuYYqG2YTfpdUs1ao8s8BcrBB3Ld4XIhfIwPFFnhnxteUZPJnZBkDKjOgiFziyVsUsS6-LCW0c8lbADQBPQlRCfJRs8xshlAvkVK6KPFHxQTT4Fhy8rr81f1VN35mqgBbYuuXbLCF30-GYCvcW+rdFyCxuZYn+W3LkWmix+YGvxahrwWmCwvlYt1mJrAFdi7PAauKC1RSRuQDAocRlXrLalj8gBTAtDgM9bSC67foiwOH2LvVp64uZOpxbwG21jLS5dUvqXDrgV187GoPHvnPL9F4NapuWsTX9rU1wwHVpMuXmULrmg8sWbCuepIrlayKjdcdirm5L9lha79a12Dn4bwN1a0ZZXD1aEzOZ1C1eXbMV0pz3Znq+tc8vmnLacFs+TaQjbc2gLt158jWeWtxX4zLEsa9HSYti3OLu1z2qpeFuC3CbjE8oiLeuZ2irLytpiZLYeq6XZbwddc85dVtrWIbEgKG-NcBCidubMZgZtrQtP1nabqmxm4BWVM4EzFLG+QRqZEDxRssZiqiwrg5sW3yjg58yoOYcoO32YBmyvN0A3otAXbTia8AKB1Me31Tj4OKlqZ2jcYUAzAVLAABZHDNmowPnc1uVmaNruYkCIFztK3KzPlR64ppb0YYcE7F4Tc7ZTMmajAZm7gKljPO02DNOlqSiADABzw1AR+aXm3EQRXgbS+wsKE+D1M8Acrs8fxH+AACcq95e0oDXvL3tAqzPcKAFbjnABAC9sAC3FNhSaCAI+P0GcpoB8hOtF98QKQFPsCdLwg9tUZXg9C-hmrl1LsBIDQCgAF4NAIgFeGeBH2tRCCN0UTLuUyiJ7GouyO3c7sgPMrJy6K1Wv3DQQhAzgX+5vGyvP3Z4TQSQAgzVElQ7INAAgCA5olkSNR5fbQNKDbhKABQSUuyP2BAdSbFIoASBNADQBam4HgcbuyXdCuDTm8IgTe9XYBC13y7LwYRzLduut30Lhd7AD3cjsTn+77Z-xPI74fuUBHBK0QBgBEcMaYzeW3RzI4M3cOeA8jiOwXL7tcaw8iil+8Pbcxj397qopbQrGntsBZ7HdwOCA6XtCO17G9te9vf3C7397oMEByfbCgEBz7lAS+8Q5vt32AH8gMKE-cMAv3mrb9kh2qK-uZBf7-9wB-2RAeuYwHlRPkJA89iqiYH7j+Bzg7ACIPyJZy1QEwD9AYO8N2D5J7g-ID4OXAhDtiCQ7IfCiKHFE6h6eVbh0O1wOZMKBRmYf2b-m7DzhxxpMfcA1HBN0u5o+8w+PV7ujsR+yskfqOjHSjpZAAHYFHFjvZ3YGs3+JDn6j4W-o41tLP+HSgdlaVikfK2xHilhu17ubvxndnIl-xCgCOchXC7ZzpZL8-Udl32V6TdR2I9Rs3PprnFr53UsLvd3zH-z5R7tgRf+3hNZdqF3rduuQvgtitp55WbhdNnUOlXGm4o++dWP2zJLxigvZvB9OurZfQiEoDafiAJABD8OaWLcc0T37TKjzBRgGLQQfNOomF9I4xuHmJzLDhzWFSjzCX4XSdki-M4NMj447WNqZ8wEc20vyHDLqh8y7AB4O2XnTjl+DS5fCieXuVVq2VS1EnVhXyN88xOejvN1Pg76-0RkcQoUYU7t3L2z7Ydex26AMcV2ygn-7VFAOw7FMmW2Xq8AF+j1+KLFtJo9Xk9gXGV0KcTc9WsjuXJ7nozEGe2f1ZAEN3LWWLBco36dy8PK9sRqmZePV5jeW+d7xRVTWb9QVHlKIeua3l4aO9W+ytPcxkbSR1+jE3qDdY2SxT9SxA3qoU+uUi1kl-zn6gwrh9z+t7d12pP8gefkgYCO66C39maSgZ7fYAHfZAq6voHt63Qndn9p414A9326-7oDV3R7wAalk9N3vvTTiFHku-1lnvR33IjR5u6FZxJsAnpgAGxrQn3no5d6+7XfvuxHW7yu96fOyT0V3Ldc92f0LAWjoW9VED9e76Fv9Ct0QWeGQVAAABydxLh6UC3uAAHKABoJ2OGkwBzoDy6EBX3YnlAaCJuAycUJv7iT5QJ0CcwZBVgQAA","body":"\"gc_flip\",\n  assign(\"temp\", reg(\"the_tails\")),\n  assign(\"the_tails\", reg(\"new_tails\")),\n  assign(\"new_tails\", reg(\"temp\")),\n  assign(\"temp\", reg(\"the_heads\")),\n  assign(\"the_heads\", reg(\"new_heads\")),\n  assign(\"new_heads\", reg(\"temp\")) "}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.3.2#footnote-link-1","child":[{"body":"This may not be true eventually,\n    because memories may get large enough so that it would be impossible\n    to run out of free memory in the lifetime of the computer.  For\n    example, there are about\n    ","tag":"#text"},{"body":"$3\\times 10^{16}$ nanoseconds","tag":"LATEX"},{"body":"\n    in a year, so if we were to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    once per\n    ","tag":"#text"},{"body":"nanosecond","tag":"LATEX"},{"body":"\n    we would need about\n    ","tag":"#text"},{"body":"$10^{18}$","tag":"LATEX"},{"body":"\n    cells of memory to build a machine\n    that could operate for 30 years without running out of memory.  That much\n    memory seems absurdly large by today's standards, but it is not\n    physically impossible.  On the other hand, processors are getting faster and \n    \n        modern computers have increasingly\n      \n    large numbers of processors operating in\n    parallel on a single memory, so it may be possible to use up memory much\n    faster than we have postulated.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.3.2#footnote-link-2","child":[{"body":"We assume here that the stack is represented as a list\n    as described in section ","tag":"#text"},{"tag":"REF","body":"5.3.1","href":"/sicpjs/5.3.1"},{"body":", so that\n    items on the stack are accessible via the pointer in the stack\n    register.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/5.3.2#footnote-link-3","child":[{"body":"This idea was invented and first implemented\n    by\n    \n    Minsky, as part of the implementation of \n    \n    Lisp for the PDP-1 at the\n    \n    MIT Research Laboratory of Electronics.  It was further developed by\n    \n    Fenichel and Yochelson (1969) for use in the Lisp implementation for the\n    \n    Multics time-sharing system.  Later, \n    \n    Baker (1978) developed a \"","tag":"#text"},{"body":"real-time","tag":"#text"},{"body":"\" version of the method,\n    which does not require the computation to stop during garbage collection.\n    Baker's idea was extended by \n    \n    Hewitt,\n    \n    Lieberman, and\n    \n    Moon (see Lieberman and Hewitt 1983) to take\n    advantage of the fact that some structure is more volatile\n    and other structure is more permanent.  \n    \n    An alternative commonly used garbage-collection technique is the \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"mark-sweep","tag":"#text"}]},{"body":" method. This consists of tracing all the structure\n    accessible from the machine registers and marking each pair we reach.\n    We then scan all of memory, and any location that is unmarked is\n    \"","tag":"#text"},{"body":"swept up","tag":"#text"},{"body":"\" as garbage and made available for reuse.  A full\n    discussion of the mark-sweep method can be found in \n    Allen 1978.\n    \n    The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in\n    use for large-memory systems because it examines only the useful part\n    of memory.  This is in contrast to mark-sweep, in which the sweep\n    phase must check all of memory.  A second advantage of stop-and-copy\n    is that it is a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"compacting","tag":"#text"}]},{"body":" garbage collector.  That is, at the\n    end of the garbage-collection phase the useful data will have been\n    moved to consecutive memory locations, with all garbage pairs\n    compressed out.  This can be an extremely important performance\n    consideration in machines with virtual memory, in which accesses to\n    widely separated memory addresses may require extra paging\n    operations.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/5.3.2#footnote-link-4","child":[{"body":"This list of\n    registers does not\n    include\n    the registers used by the storage-allocation\n    \n\tsystem: ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"root"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_heads"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_tails"},{"body":",\n    and the other registers that will be introduced in this section.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/5.3.2#footnote-link-5","child":[{"body":"The term \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"broken heart","tag":"#text"}]},{"body":" was coined by\n    \n    David Cressey, who wrote a garbage collector\n    for \n    \n    MDL, a dialect of Lisp developed at MIT during the early 1970s.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-6","count":6,"href":"/sicpjs/5.3.2#footnote-link-6","child":[{"body":"The\n    garbage collector uses the low-level predicate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_pointer_to_pair"},{"body":"\n    instead of the list-structure\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_pair"},{"body":"\n    operation because in a real system there might be various things\n    that are treated as pairs for garbage-collection purposes.\n    For example,\n    \n    a\n    \n\t      function\n      \n    object may be implemented as a special kind of\n    \"","tag":"#text"},{"body":"pair","tag":"#text"},{"body":"\" that doesn't satisfy the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_pair"},{"body":"\n    predicate.\n    For simulation purposes,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_pointer_to_pair"},{"body":"\n    can be implemented as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_pair"},{"body":".","tag":"#text"}]}]