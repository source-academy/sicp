[
  {
    "content": "We concentrated in chapter on computational processes and on the\nrole of\nfunctions\nin program design.\n\nWe saw how to use primitive data (numbers) and primitive\noperations (arithmetic operations), how to combine\nfunctions\nto form compound\nfunctions\nthrough composition, conditionals, and the use of parameters, and how to\nabstract\nprocesses\nby using\nfunction declarations.\n\nWe saw that a\nfunction\ncan be regarded as a pattern for the local evolution of a process, and we\nclassified, reasoned about, and performed simple algorithmic analyses of\nsome common patterns for processes as embodied in\nfunctions.\n\nWe also saw that higher-order\nfunctions\nenhance the power of our language by enabling us to manipulate, and thereby\nto reason in terms of, general methods of computation.\n\nThis is much of the\nessence of programming.\n\nIn this chapter we are going to look at more complex data.\n\nAll the\nfunctions\nin chapter operate on simple numerical data, and simple data are\nnot sufficient for many of the problems we wish to address using\ncomputation.\n\nPrograms are typically designed to model complex phenomena,\nand more often than not one must construct computational objects that have\nseveral parts in order to model real-world phenomena that have several\naspects.\n\nThus, whereas our focus in chapter was on building\nabstractions by combining\nfunctions\nto form compound\nfunctions,\nwe turn in this chapter to another key aspect of any programming language:\nthe means it provides for building abstractions by combining data objects\nto form compound data.\n\nWhy do we want compound data in a programming language?\n\nFor the same\nreasons that we want compound\nfunctions:\nto elevate the conceptual level at which we can design our programs, to\nincrease the modularity of our designs, and to enhance the expressive power\nof our language.",
    "token_count": 291,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": null,
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Building_Abstractions_with_Data_1"
  },
  {
    "content": "For the same\nreasons that we want compound\nfunctions:\nto elevate the conceptual level at which we can design our programs, to\nincrease the modularity of our designs, and to enhance the expressive power\nof our language.\n\nJust as the ability to\ndeclare functions\nenables us to deal with processes at a higher conceptual level than that of\nthe primitive operations of the language, the ability to construct compound\ndata objects enables us to deal with data at a higher conceptual level than\nthat of the primitive data objects of the language.\n\nConsider the task of designing a system to perform\nadd_rat\nthat takes two rational numbers and produces their sum.\n\nIn terms of\nsimple data, a rational number can be thought of as two integers: a\nnumerator and a denominator.\n\nThus, we could design a program in which\neach rational number would be represented by two integers (a numerator\nand a denominator) and where\nadd_rat\nwould be implemented by two\nfunctions\n(one producing the numerator of the sum and one producing\nthe denominator).\n\nBut this would be awkward, because we would then\nneed to explicitly keep track of which numerators corresponded to\nwhich denominators.\n\nIn a system intended to perform many operations\non many rational numbers, such bookkeeping details would clutter the\nprograms substantially, to say nothing of what they would do to our\nminds.\n\nIt would be much better if we could glue together\na numerator and denominator to form a pair a compound data\nobject that our programs could manipulate in a way that would\nbe consistent with regarding a rational number as a single conceptual\nunit.\n\nThe use of compound data also enables us to increase the modularity of\nour programs.",
    "token_count": 285,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": null,
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Building_Abstractions_with_Data_2"
  },
  {
    "content": "The use of compound data also enables us to increase the modularity of\nour programs.\n\nIf we can manipulate rational numbers directly as\nobjects in their own right, then we can separate the part of our\nprogram that deals with rational numbers per se from the details of\nhow rational numbers may be represented as pairs of integers.\n\nThe\ngeneral technique of isolating the parts of a program that deal with\nhow data objects are represented from the parts of a program that deal\nwith how data objects are used is a powerful design methodology called\ndata abstraction.\n\nWe will see how data abstraction makes\nprograms much easier to design, maintain, and modify.\n\nThe use of compound data leads to a real increase in the expressive power\nof our programming language.\n\nConsider the idea of forming a\nlinear combination $ax+by$.\n\nWe\nmight like to write a\nfunction\nthat would accept $a$ ,\n$b$ , $x$ , and\n$y$ as arguments and return the value of\n$ax+by$.\n\nThis presents no difficulty if the\narguments are to be numbers, because we can readily\ndeclare the function\n\n```javascript\nlinear_combination_example\n\nfunction linear_combination(a, b, x, y) {\n    return a * x + b * y;\n}\n```\n\n```javascript\nlinear_combination_example\n\n\tlinear_combination(1, 2, 3, 4);\n```\n\nBut suppose we are not concerned only with numbers.\n\nSuppose we would like to\ndescribe a process that forms\nlinear combinations whenever addition and multiplication are\ndefined for rational numbers, complex numbers, polynomials, or\nwhatever.\n\nWe could express this as a\nfunction\nof the form\n\n```javascript\nfunction linear_combination(a, b, x, y) {\n    return add(mul(a, x), mul(b, y));\n}\n```\n\nwhere functions linear_combination should need to know about functions function linear_combination, it is irrelevant what function such as linear_combination to pass its arguments along to\n\nWe begin this chapter by implementing the rational-number arithmetic system\nmentioned above.",
    "token_count": 305,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": null,
    "subsection": null,
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Building_Abstractions_with_Data_3"
  },
  {
    "content": "We begin this chapter by implementing the rational-number arithmetic system\nmentioned above.\n\nThis will form the background for our discussion of\ncompound data and data abstraction.\n\nAs with compound\nfunctions,\nthe main issue to be addressed is that of abstraction as a technique for\ncoping with complexity, and we will see how data abstraction enables us to\nerect suitable\nabstraction barriers\nbetween different parts of a program.\n\nWe will see that the key to forming compound data is that a programming\nlanguage should provide some kind of glue so that data\nobjects can be combined to form more complex data objects.\n\nThere are\nmany possible kinds of glue.\n\nIndeed, we will discover how to form compound\ndata using no special data operations at all, only\nfunctions.\n\nThis will further blur the distinction between\nfunction\nand data, which was already becoming tenuous toward the end\nof chapter.\n\nWe will also explore some conventional techniques for\nrepresenting sequences and trees.\n\nOne key idea in dealing with compound\ndata is the notion of\nclosure that the\nglue we use for combining data objects should allow us to combine not only\nprimitive data objects, but compound data objects as well.\n\nAnother key idea\nis that compound data objects can serve as\nconventional interfaces for combining program modules in\nmix-and-match ways.\n\nWe illustrate some of these ideas by presenting a\nsimple graphics language that exploits closure.\n\nWe will then augment the representational power of our language by\nintroducing\nsymbolic expressions data whose elementary parts\ncan be arbitrary symbols rather than only numbers.\n\nWe explore various\nalternatives for representing sets of objects.",
    "token_count": 266,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": null,
    "subsection": null,
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Building_Abstractions_with_Data_4"
  },
  {
    "content": "We explore various\nalternatives for representing sets of objects.\n\nWe will find that,\njust as a given numerical function can be computed by many different\ncomputational processes, there are many ways in which a given data\nstructure can be represented in terms of simpler objects, and the\nchoice of representation can have significant impact on the time and\nspace requirements of processes that manipulate the data.\n\nWe will\ninvestigate these ideas in the context of symbolic differentiation,\nthe representation of sets, and the encoding of information.\n\nNext we will take up the problem of working with data that may be\nrepresented differently by different parts of a program.\n\nThis leads\nto the need to implement\ngeneric operations , which must handle many different types of data.\n\nMaintaining modularity in the presence of generic operations requires more\npowerful abstraction barriers than can be erected with simple data\nabstraction alone.\n\nIn particular, we introduce data-directed\nprogramming as a technique that allows individual data representations\nto be designed in isolation and then combined\nadditively (i.e., without modification).\n\nTo illustrate the power\nof this approach to system design, we close the chapter by applying what we\nhave learned to the implementation of a package for performing symbolic\narithmetic on polynomials, in which the coefficients of the polynomials can\nbe integers, rational numbers, complex numbers, and even other polynomials.",
    "token_count": 224,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": null,
    "subsection": null,
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Data_Building_Abstractions_with_Data_5"
  },
  {
    "content": "As we have seen, pairs provide a primitive glue that we can\nuse to construct compound data objects.\n\nFigure\nshows a standard way to visualize a\nin this case, the pair formed by\npair(1, 2).\n\n```javascript\nIn this representation, which is called\n\tbox-and-pointer\n        notation, each compound object is shown as a\n\tpointer to a box.  The box for a pair\n\thas two parts, the left part containing the head of the pair and the\n\tright part containing the tail.\n```\n\nWe have already seen that\npair\ncan be used to combine not only numbers but pairs as well.\n\n(You made use\nof this fact, or should have, in doing\nexercises\nand.) As a consequence, pairs provide\na universal building block from which we can construct all sorts of data\nstructures.\n\nFigure\nshows two ways to use pairs to combine the numbers 1, 2, 3, and 4.\n\nTwo ways to combine 1, 2, 3, and 4 using pairs.\n\nThe ability to create pairs whose elements are pairs is the essence of\nlist structure s importance as a representational tool.\n\nWe refer to\nthis ability as the\nclosure property of\npair.\n\nIn general, an operation for combining data objects satisfies the closure\nproperty if the results of combining things with that operation can\nthemselves be combined using the same operation. hierarchical structures structures made up of parts, which\nthemselves are made up of parts, and so on.\n\nFrom the outset of chapter , we ve made essential use of\nclosure in dealing with\nfunctions,\nbecause all but the very simplest programs rely on the fact that the\nelements of a combination can themselves be combinations.\n\nIn this section,\nwe take up the consequences of closure for compound data.",
    "token_count": 286,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Hierarchical_Data_and_the_Closure_Property_1"
  },
  {
    "content": "In this section,\nwe take up the consequences of closure for compound data.\n\nWe describe some\nconventional techniques for using pairs to represent sequences and trees,\nand we exhibit a graphics language that illustrates closure in a vivid\nway.",
    "token_count": 39,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Hierarchical_Data_and_the_Closure_Property_2"
  },
  {
    "content": "This section presents a simple language for drawing pictures that\nillustrates the power of data abstraction and closure, and also exploits\nhigher-order\nfunctions\nin an essential way.\n\nThe language is designed to make it easy to\nexperiment with patterns such as the ones in\nfigure , which are composed of\nrepeated elements that are shifted and scaled.\nfunctions\nrather than as list structure.\n\nJust as\npair,\nwhich satisfies the\nDesigns generated with the picture language.\n\nWhen we began our study of programming in\nsection , we emphasized the\nimportance of describing a language by focusing on the language s\nprimitives, its means of combination, and its means of abstraction.\n\nWe ll follow that framework here.\n\nPart of the elegance of this picture language is that there is only one\nkind of element, called a\npainter.\n\nA painter draws an image that is shifted and scaled to\nfit within a designated\ns a primitive painter\nwe ll call.\n\nImages produced by the\nThe actual shape of the drawing depends on the frame all four\nimages in figure are produced by the same\ns founder, William Barton Rogers, as shown in\nfigure.\nare drawn with respect to the same four frames\nas the.\n\nImages of William Barton Rogers, founder and first\npresident of MIT, painted with respect to the same four frames as in\nfigure (original image courtesy MIT Museum).\n\nTo combine images, we use various\ns image\nin the left half of the frame and the second painter s image in the\nright half of the frame.\n\nSimilarly,\ns image below the\nsecond painter s image.\n\nSome operations transform a single painter\nto produce a new painter.",
    "token_count": 276,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_1"
  },
  {
    "content": "Some operations transform a single painter\nto produce a new painter.\n\nFor example,\nflip_vert\ntakes a painter and produces a painter that draws its image upside-down, and\nflip_horiz\nproduces a painter that draws the original painter s image\nleft-to-right reversed.\n\nFigure shows the drawing of a painter called\n\n```javascript\nwave2\n      wave2_example\n\nconst wave2 = beside(wave, flip_vert(wave));\nconst wave4 = below(wave2, wave2);\n\nconst heart2 = beside(heart, flip_vert(heart));\n// const heart4 = stack(heart2, heart2);\n```\n\n```javascript\nwave2_example\n\nwave2;\n\nshow(heart2);\n// show(heart4);\n```\n\nIn building up a complex image in this manner we are exploiting the fact\nthat painters are\ns means of combination.\n\nThe\npair,\nthe closure of our data under the means of combination is crucial to the\nability to create complex structures while using only a few operations.\n\nOnce we can combine painters, we would like to be able to abstract typical\npatterns of combining painters.\n\nWe will implement the painter operations as\nJavaScript functions.\n\nThis means that we don t need a special abstraction mechanism in the\npicture language: Since the means of combination are ordinary\nJavaScript functions,\nwe automatically have the capability to do anything with painter operations\nthat we can do with\nfunctions.\n\nFor example, we can abstract the pattern in\n\n```javascript\nflipped_pairs\n      wave4_2\n\nfunction flipped_pairs(painter) {\n    const painter2 = beside(painter, flip_vert(painter));\n    return below(painter2, painter2);\n}\n\nfunction flipped_pairs(painter) {\n    const painter2 = beside(painter, flip_vert(painter));\n    return stack(painter2, painter2);\n}\n```\n\nand declare\n\n```javascript\nwave4_2\n      flipped_pairs\n\nconst wave4 = flipped_pairs(wave);\n\nconst heart4 = flipped_pairs(heart);\nshow(heart4);\n```\n\n```javascript\nRecursive plans for\n\t  right_split and\n\t  corner_split.\n```\n\nWe can also define recursive operations.\n\nHere s one that makes\npainters split and branch towards the right as shown in\nfigures\nand\n:",
    "token_count": 279,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_2"
  },
  {
    "content": "Here s one that makes\npainters split and branch towards the right as shown in\nfigures\nand\n:\n\n```javascript\nright_split\n      right_split_example_1\n\nfunction right_split(painter, n) {\n    if (n === 0) {\n        return painter;\n    } else {\n        const smaller = right_split(painter, n - 1);\n        return beside(painter, below(smaller, smaller));\n    }\n}\n\nfunction right_split(painter, n) {\n    if (n === 0) {\n        return painter;\n    } else {\n        const smaller = right_split(painter, n - 1);\n        return beside(painter, stack(smaller, smaller));\n    }\n}\n```\n\nWe can produce balanced patterns by branching upwards as well as towards the right (see exercise and figures and ):\n\n```javascript\ncorner_split\n      right_split\n      up_split\n      corner_split_example_1\n\nfunction corner_split(painter, n) {\n    if (n === 0) {\n        return painter;\n    } else {\n        const up = up_split(painter, n - 1);\n        const right = right_split(painter, n - 1);\n        const top_left = beside(up, up);\n        const bottom_right = below(right, right);\n        const corner = corner_split(painter, n - 1);\n        return beside(below(painter, top_left),\n                      below(bottom_right, corner));\n    }\n}\n\nfunction corner_split(painter, n) {\n    if (n === 0) {\n        return painter;\n    } else {\n        const up = up_split(painter, n - 1);\n        const right = right_split(painter, n - 1);\n        const top_left = beside(up, up);\n        const bottom_right = stack(right, right);\n        const corner = corner_split(painter, n - 1);\n        return stack(beside(top_left, corner),\n                     beside(painter, bottom_right));\n    }\n}\n```\n\n```javascript\ncorner_split_example_1\n      corner_split_example_1\n\nshow(corner_split(heart, 4));\n```\n\n```javascript\nright_split_example_1\n    right_split\n\n      right_split(wave, 4);    // (a)\n      right_split(rogers, 4);  // (b)\n      corner_split(wave, 4);   // (c)\n      corner_split(rogers, 4); // (d)\n\n      show(right_split(heart, 4));\n```\n\n```javascript\nThe recursive operation\n          right_split applied to the\n\t  painters wave and\n          rogers.\n          Combining four\n          corner_split figures\n\t  produces symmetric\n\t  square_limit\n          as shown in figure.\n```\n\nBy placing four copies of a corner_split appropriately, we obtain a pattern called square_limit, whose application to :",
    "token_count": 276,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_3"
  },
  {
    "content": "By placing four copies of a corner_split appropriately, we obtain a pattern called square_limit, whose application to :\n\n```javascript\nsquare_limit\n      corner_split\n      square_limit_example\n\nfunction square_limit(painter, n) {\n    const quarter = corner_split(painter, n);\n    const half = beside(flip_horiz(quarter), quarter);\n    return below(flip_vert(half), half);\n}\n\nfunction square_limit(painter, n) {\n    const quarter = corner_split(painter, n);\n    const upper_half = beside(flip_horiz(quarter), quarter);\n    const lower_half = beside(turn_upside_down(quarter),\n                              flip_vert(quarter));\n    return stack(upper_half, lower_half);\n}\n```\n\n```javascript\nsquare_limit_example\n\nsquare_limit(rogers, 4);\n\nshow(square_limit(heart, 4));\n```\n\nIn addition to abstracting patterns of combining painters, we can work at a\nhigher level, abstracting patterns of combining painter operations.\n\nThat\nis, we can view the painter operations as elements to manipulate and can\nwrite means of combination for these\nelementsfunctions\nthat take painter operations as arguments and create new painter operations.\n\nFor example,\nflipped_pairs\nand\nsquare_limit\neach arrange four copies of a painter s image in a square pattern;\nthey differ only in how they orient the copies.\n\nOne way to abstract this\npattern of painter combination is with the following\nfunction,\nwhich takes four one-argument painter operations and produces a painter\noperation that transforms a given painter with those four operations and\narranges the results in a square.\n\nThe functions tl,\n\n```javascript\nsquare_of_four\n      square_of_four_example\n\nfunction square_of_four(tl, tr, bl, br) {\n    return painter => {\n        const top = beside(tl(painter), tr(painter));\n        const bottom = beside(bl(painter), br(painter));\n        return below(bottom, top);\n    };\n}\n\nfunction square_of_four(tl, tr, bl, br) {\n    return painter => stack(beside(tl(painter), tr(painter)),\n                            beside(bl(painter), br(painter)));\n}\n```\n\n```javascript\nsquare_of_four_example\n      identity\n\nsquare_of_four(flip_vert, identity,\n     quarter_turn_right, quarter_turn_left)(rogers);\n\nshow(square_of_four(turn_upside_down, identity,\n                    quarter_turn_right, quarter_turn_left)\n     (heart)\n    );\n```\n\nThen\n\n```javascript\nflipped_pairs\n      can be defined in terms of\n```\n\nsquare_of_four as follows:\n\n```javascript\nflipped_pairs_2\n      square_of_four\n      identity\n      flipped_pairs_example\n\nfunction flipped_pairs(painter) {\n    const combine4 = square_of_four(identity, flip_vert,\n                                    identity, flip_vert);\n    return combine4(painter);\n}\n\nfunction flipped_pairs(painter) {\n    const combine4 = square_of_four(turn_upside_down, flip_vert,\n                                    flip_horiz, identity);\n    return combine4(painter);\n}\n```\n\n```javascript\nflipped_pairs_example\n\nflipped_pairs(rogers);\n\nshow(flipped_pairs(heart));\n```\n\nand square_limit can be expressed as",
    "token_count": 308,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_4"
  },
  {
    "content": "and square_limit can be expressed as\n\n```javascript\nsquare_limit_2\n      square_of_four\n      identity\n      corner_split\n      square_limit_example_2\n\nfunction square_limit(painter, n) {\n    const combine4 = square_of_four(flip_horiz, identity,\n                                    rotate180, flip_vert);\n    return combine4(corner_split(painter, n));\n}\n\nfunction square_limit(painter, n) {\n    const combine4 = square_of_four(flip_horiz, identity,\n                                    turn_upside_down, flip_vert);\n    return combine4(corner_split(painter, n));\n}\n```\n\n```javascript\nsquare_limit_example_2\n\nsquare_limit(rogers, 4)(full_frame);\n\nshow(square_limit(heart, 4));\n```\n\nBefore we can show how to implement painters and their means of\ncombination, we must first consider\nan origin vector\nand two edge vectors.\n\nThe origin vector specifies the offset of the\nframe s origin from some absolute origin in the plane, and the edge\nvectors specify the offsets of the frame s corners from its origin.\n\nIf the edges are perpendicular, the frame will be rectangular.\n\nOtherwise the frame will be a more general parallelogram.\n\nFigure shows a frame and its associated\nvectors.\n\nIn accordance with data abstraction, we need not be specific yet\nabout how frames are represented, other than to say that there is a\nconstructor\nmake_frame,\nwhich takes three vectors and produces a frame, and three corresponding\nselectors\norigin_frame,\nedge1_frame,\nand\nedge2_frame\n(see exercise ).\n\nA frame is described by three vectors an origin and two edges.\n\nWe will use coordinates in the\n$0\\leq x, y\\leq 1$ ) to specify images.\n\nWith\neach frame, we associate a\nframe coordinate map , which will be used to shift and scale images\nto fit the frame.\n\nThe map transforms the unit square into the frame by\nmapping the vector $\\mathbf{v}=(x, y)$ to the\nvector sum\n\\[\n\\text{Origin(Frame)} + x\\cdot \\text{ Edge}_1\\text{ (Frame)}\n+ y\\cdot \\text{ Edge}_2\\text{ (Frame)}\n\\]\nFor example, $(0, 0)$ is mapped to the origin of\nthe frame, $(1, 1)$ to the vertex diagonally\nopposite the origin, and $(0.5, 0.5)$ to the\ncenter of the frame.\n\nWe can create a frame s coordinate map with\nthe following\nfunction :",
    "token_count": 303,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_5"
  },
  {
    "content": "We can create a frame s coordinate map with\nthe following\nfunction :\n\n```javascript\nframe_coord_map\n      frame_coord_map_example\n      [ 14, 18 ]\n      frame_functions\n      vector_functions\n\nfunction frame_coord_map(frame) {\n    return v => add_vect(origin_frame(frame),\n                         add_vect(scale_vect(xcor_vect(v),\n                                             edge1_frame(frame)),\n                                  scale_vect(ycor_vect(v),\n                                             edge2_frame(frame))));\n}\n```\n\n```javascript\nframe_coord_map_example\n\nconst my_origin = make_vect(1, 2);\nconst my_edge_1 = make_vect(3, 4);\nconst my_edge_2 = make_vect(5, 6);\nconst my_frame = make_frame(my_origin, my_edge_1, my_edge_2);\nconst my_coord_map = frame_coord_map(my_frame);\nconst my_vector = make_vect(1, 2);\nconst my_mapped_vector = my_coord_map(my_vector);\nmy_mapped_vector;\n```\n\nObserve that applying\nframe_coord_map\nto a frame returns a\nfunction\nthat, given a vector, returns a vector.\n\nIf the argument vector is in the\nunit square, the result vector will be in the frame.\n\nFor example,\n\n```javascript\nvector_example\n      frame_functions\n      vector_functions\n      frame_coord_map\n      [ 1, 2 ]\n\nframe_coord_map(a_frame)(make_vect(0, 0));\n\nconst a_frame = make_frame(make_vect(1, 2),\n                           make_vect(3, 4),\n                           make_vect(5, 5));\nframe_coord_map(a_frame)(make_vect(0, 0));\n```\n\nreturns the same vector as\n\n```javascript\nvector_example_2\n      frame_functions\n      [ 1, 2 ]\n\norigin_frame(a_frame);\n\nconst a_frame = make_frame(make_vect(1, 2),\n                           make_vect(3, 4),\n                           make_vect(5, 5));\norigin_frame(a_frame);\n```\n\nA painter is represented as a\nfunction\nthat, given a frame as argument, draws a particular image shifted and\nscaled to fit the frame.\n\nThat is to say, if\ns image in\n\nThe details of how primitive painters are implemented depend on the\nparticular characteristics of the graphics system and the type of image to\nbe drawn.\n\nFor instance, suppose we have a\nfunction\ndraw_line\nthat draws a line on the screen between two specified points.\n\nThen we can\ncreate painters for line drawings, such as the\nwave\npainter in figure , from lists of line\nsegments as follows:\n\n```javascript\ndraw_line\n\n// \"drawing a line\" here simulated\n// by printing the coordinates of\n// the start and end of the line\nfunction draw_line(v_start, v_end) {\n    display(\"line starting at\");\n    display(v_start);\n    display(\"line ending at\");\n    display(v_end);\n}\n```",
    "token_count": 291,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 6,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_6"
  },
  {
    "content": "Then we can\ncreate painters for line drawings, such as the\nwave\npainter in figure , from lists of line\nsegments as follows:\n\n```javascript\nsegments_to_painter\n      frame_coord_map\n      segment_functions\n      draw_line\n      segments_to_painter_example\n\nfunction segments_to_painter(segment_list) {\n    return frame =>\n             for_each(segment =>\n                        draw_line(\n                            frame_coord_map(frame)\n                                (start_segment(segment)),\n                            frame_coord_map(frame)\n                                (end_segment(segment))),\n                      segment_list);\n}\n```\n\n```javascript\nsegments_to_painter_example\n\nconst my_origin = make_vect(1, 2);\nconst my_edge_1 = make_vect(3, 4);\nconst my_edge_2 = make_vect(5, 6);\nconst my_frame = make_frame(my_origin, my_edge_1, my_edge_2);\n\nconst my_start_1 = make_vect(0, 1);\nconst my_end_1 = make_vect(1, 1);\nconst my_segment_1 = make_segment(my_start_1, my_end_1);\n\nconst my_start_2 = make_vect(0, 2);\nconst my_end_2 = make_vect(2, 2);\nconst my_segment_2 = make_segment(my_start_2, my_end_2);\n\nconst my_painter = segments_to_painter(\n                       list(my_segment_1, my_segment_2));\n\nmy_painter(my_frame);\n```\n\nThe segments are given using coordinates with respect to the unit square.\n\nFor each segment in the list, the painter transforms the segment endpoints\nwith the frame coordinate map and draws a line between the transformed\npoints.\n\nRepresenting painters as\nfunctions\nerects a powerful abstraction barrier in the picture language.\n\nWe can\ncreate and intermix all sorts of primitive painters, based on a variety of\ngraphics capabilities.\n\nThe details of their implementation do not matter.\n\nAny\nfunction\ncan serve as a painter, provided that it takes a frame as argument and\ndraws something scaled to fit the frame.\n\nAn operation on painters (such as flip_vert or flip_vert doesn t have to know how a painter works in order to flip it it just\n\nhas to know how to turn a frame upside down: The flipped painter just uses the original painter, but in the inverted frame.\n\nPainter operations are based on the\nfunction\ntransform_painter,\nwhich takes as arguments a painter and information on how to transform a\nframe and produces a new painter.\n\nThe transformed painter, when called on\na frame, transforms the frame and calls the original painter on the\ntransformed frame.",
    "token_count": 299,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 7,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_7"
  },
  {
    "content": "The transformed painter, when called on\na frame, transforms the frame and calls the original painter on the\ntransformed frame.\n\nThe arguments to\ntransform_painter\nare points (represented as vectors) that specify the corners of the new\nframe: When mapped into the frame, the first point specifies the new\nframe s origin and the other two specify the ends of its edge vectors.\n\nThus, arguments within the unit square specify a frame contained within the\noriginal frame.\n\n```javascript\ntransform_painter\n      frame_functions\n      vector_functions\n      frame_coord_map\n      flip_vert_example\n\nfunction transform_painter(painter, origin, corner1, corner2) {\n    return frame => {\n             const m = frame_coord_map(frame);\n             const new_origin = m(origin);\n             return painter(make_frame(\n                                new_origin,\n                                sub_vect(m(corner1), new_origin),\n                                sub_vect(m(corner2), new_origin)));\n           };\n}\n```\n\nHere s how to flip painter images vertically:\n\n```javascript\nflip_vert\n      transform_painter\n      flip_vert_example\n\nfunction flip_vert(painter) {\n    return transform_painter(painter,\n                             make_vect(0, 1),  // new origin\n                             make_vect(1, 1),  // new end of edge1\n                             make_vect(0, 0)); // new end of edge2\n}\n```\n\n```javascript\nflip_vert_example\n      outline_painter\n      unit_frame\n      flip_vert\n\nconst flipped_outline_painter =\n          flip_vert(outline_painter);\n\nflipped_outline_painter(unit_frame);\n```\n\nUsing\n\n```javascript\ntransform_painter,\n      we can easily define new transformations.\n      For example, we can declare a\n      painter that shrinks its image to the upper-right quarter of the frame\n      it is given:\n```\n\n```javascript\nshrink_to_upper_right\n      transform_painter\n      shrink_to_upper_right_example\n\nfunction shrink_to_upper_right(painter) {\n    return transform_painter(painter,\n                             make_vect(0.5, 0.5),\n                             make_vect(1, 0.5),\n                             make_vect(0.5, 1));\n}\n```\n\n```javascript\nshrink_to_upper_right_example\n      outline_painter\n      unit_frame\n\nconst shrunk_outline_painter =\n          shrink_to_upper_right(outline_painter);\n\nshrunk_outline_painter(unit_frame);\n```\n\nOther transformations rotate images counterclockwise by 90 degrees\n\n```javascript\nrotate90\n      transform_painter\n      rotate90_example\n\nfunction rotate90(painter) {\n    return transform_painter(painter,\n                             make_vect(1, 0),\n                             make_vect(1, 1),\n                             make_vect(0, 0));\n}\n```\n\n```javascript\nrotate90_example\n      outline_painter\n      unit_frame\n\nconst rotated_outline_painter =\n          rotate90(outline_painter);\n\nrotated_outline_painter(unit_frame);\n```\n\nor squash images towards the center of the frame:\n\n```javascript\nsquash_inwards\n      transform_painter\n      squash_inwards_example\n\nfunction squash_inwards(painter) {\n    return transform_painter(painter,\n                             make_vect(0, 0),\n                             make_vect(0.65, 0.35),\n                             make_vect(0.35, 0.65));\n}\n```\n\n```javascript\nsquash_inwards_example\n      outline_painter\n      unit_frame\n\nconst squashed_outline_painter =\n          squash_inwards(outline_painter);\n\nsquashed_outline_painter(unit_frame);\n```\n\nFrame transformation is also the key to\ndefining means of combining two or more painters.",
    "token_count": 303,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 8,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_8"
  },
  {
    "content": "Frame transformation is also the key to\ndefining means of combining two or more painters.\n\nThe\nfunction,\nfor example, takes two painters, transforms them to paint in the left and\nright halves of an argument frame respectively, and produces a new,\ncompound painter.\n\nWhen the compound painter is given a frame, it calls the\nfirst transformed painter to paint in the left half of the frame and calls\nthe second transformed painter to paint in the right half of the frame:\n\n```javascript\nbeside\n      transform_painter\n      beside_example\n\nfunction beside(painter1, painter2) {\n    const split_point = make_vect(0.5, 0);\n    const paint_left  = transform_painter(painter1,\n                                          make_vect(0, 0),\n                                          split_point,\n                                          make_vect(0, 1));\n    const paint_right = transform_painter(painter2,\n                                          split_point,\n                                          make_vect(1, 0),\n                                          make_vect(0.5, 1));\n    return frame => {\n               paint_left(frame);\n               paint_right(frame);\n           };\n}\n```\n\n```javascript\nbeside_example\n      x_painter_example\n\nbeside(x_painter, x_painter)(unit_frame);\n```\n\nObserve how the painter data abstraction, and in particular the representation of painters as functions, makes function need not know anything about the details of\n\nthe component painters other than that each painter will draw something in its designated frame.\n\nThe picture language exploits some of the critical ideas we ve\nintroduced about abstraction with\nfunctions\nand data.\n\nThe fundamental data abstractions, painters, are implemented\nusing\nfunctional\nrepresentations, which enables the language to handle different basic\ndrawing capabilities in a uniform way.\n\nThe means of combination satisfy\nthe closure property, which permits us to easily build up complex designs.\n\nFinally, all the tools for abstracting\nfunctions\nare available to us for abstracting means of combination for painters.\n\nWe have also obtained a glimpse of another crucial idea about languages and\nprogram design.\n\nThis is the approach of\nstratified design , the notion that a complex system should be\nstructured as a sequence of levels that are described using a sequence of\nlanguages.",
    "token_count": 289,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 9,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_9"
  },
  {
    "content": "This is the approach of\nstratified design , the notion that a complex system should be\nstructured as a sequence of levels that are described using a sequence of\nlanguages.\n\nEach level is constructed by combining parts that are regarded\nas primitive at that level, and the parts constructed at each level are\nused as primitives at the next level.\n\nThe language used at each level\nof a stratified design has primitives, means of combination, and means\nof abstraction appropriate to that level of detail.\n\nStratified design pervades the engineering of complex systems.\n\nFor\nexample, in computer engineering, resistors and transistors are\ncombined (and described using a language of analog circuits) to\nproduce parts such as and-gates and or-gates, which form the\nprimitives of a language for digital-circuit design.\n\nAs a tiny example of stratification, our picture language uses primitive elements (primitive painters) that specify points and lines to provide the shapes of a\n\npainter like square_of_four, capture common patterns of combining geometric combiners.\n\nStratified design helps make programs\nrobust , that is, it makes\nit likely that small changes in a specification will require\ncorrespondingly small changes in the program.\n\nFor instance, suppose we\nwanted to change the image based on.\n\nWe could work\nat the lowest level to change the detailed appearance of the\ncorner_split\nreplicates the\nsquare_limit\narranges the four copies of the corner.\n\nIn general, each level of a\nstratified design provides a different vocabulary for expressing the\ncharacteristics of the system, and a different kind of ability to change it.",
    "token_count": 255,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Example: A Picture Language",
    "chunk_index": 10,
    "chunk_id": "Building_Abstractions_with_Data_Example_A_Picture_Language_10"
  },
  {
    "content": "The representation of sequences in terms of lists generalizes naturally to\nrepresent sequences whose elements may themselves be sequences.\n\nFor\nexample, we can regard the object\n[[1, [2, null]], [3, [4, null]]]\nconstructed by\n\n```javascript\npair(list(1, 2), list(3, 4));\n```\n\nas a list of three items, the first of which is itself a list,\n[1, [2, null]].\n\nFigure\nshows the representation of this structure in terms of pairs.\n\n```javascript\nStructure formed by\n\t  pair(list(1, 2), list(3, 4)).\n```\n\nAnother way to think of sequences whose elements are sequences is as\ntrees.\n\nThe elements of the sequence are the branches of the\ntree, and elements that are themselves sequences are subtrees.\n\nFigure\nshows the structure in\nfigure\nviewed as a tree.\n\n```javascript\nThe list structure in\n\t  figure viewed as a tree.\n```\n\nRecursion length function of section with the count_leaves function, which returns the total number of leaves of a tree:\n\n```javascript\ntree_x\n\nconst x = pair(list(1, 2), list(3, 4));\n```\n\n```javascript\nlength_tree_x\n      tree_x\n      3\n\nlength(x);\n```\n\n```javascript\ncount_leaves_tree_x\n      tree_x\n      count_leaves\n      4\n\ncount_leaves(x);\n```\n\n```javascript\nlist_x_x\n      tree_x\n      3\n\nlist(x, x);\n\nlength(head(tail(list(x, x))));\n```\n\n```javascript\nlength_list_x_x\n      tree_x\n      2\n\nlength(list(x, x));\n```\n\n```javascript\ncount_leaves_list_x_x\n      tree_x\n      count_leaves\n      8\n\ncount_leaves(list(x, x));\n```\n\nTo implement count_leaves, recall the recursive plan for computing length: - - The length of a list the length of the tail of - -\n\nThe length of the empty list is 0.\n\n```javascript\nThe function\n      count_leaves\n```\n\nis similar.\n\nThe value for the empty list is the same:\n-\n-\ncount_leaves\nof the empty list is 0.\n\nBut in the reduction step, where we strip off the\nhead\nof the list, we must take into account that the\nhead\nmay itself be a tree whose leaves we need to count.",
    "token_count": 287,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Hierarchical Structures",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Hierarchical_Structures_1"
  },
  {
    "content": "But in the reduction step, where we strip off the\nhead\nof the list, we must take into account that the\nhead\nmay itself be a tree whose leaves we need to count.\n\nThus, the appropriate\nreduction step is\n-\n-\ncount_leaves\nof a tree\ncount_leaves\nof the\nhead\nof\ncount_leaves\nof the\ntail\nof\nFinally, by taking\nheads\nwe reach actual leaves, so we need another base case:\n-\n-\ncount_leaves\nof a leaf is 1.\n\nTo aid in writing recursive\nfunctions\non trees,\nour JavaScript environment\nprovides the primitive predicate\nis_pair,\nwhich tests whether its argument is a pair.\n\nHere is the complete\nfunction:\n\n```javascript\ncount_leaves\n      count_leaves_example\n      4\n\nfunction count_leaves(x) {\n    return is_null(x)\n           ? 0\n           : ! is_pair(x)\n           ? 1\n           : count_leaves(head(x)) + count_leaves(tail(x));\n}\n```\n\n```javascript\ncount_leaves_example\n\ncount_leaves(pair(list(1, 2), list(3, 4)));\n```\n\nJust as\nscale_tree\nfunction,\nanalogous to\nscale_list\nof section , takes as arguments a numeric\nfactor and a tree whose leaves are numbers.\n\nIt returns a tree of the same\nshape, where each number is multiplied by the factor.\n\nThe recursive plan\nfor\nscale_tree\nis similar to the one for\ncount_leaves:\n\n```javascript\nscale_tree\n      scale_tree_example\n      10\n\nfunction scale_tree(tree, factor) {\n    return is_null(tree)\n           ? null\n           : ! is_pair(tree)\n           ? tree * factor\n           : pair(scale_tree(head(tree), factor),\n                  scale_tree(tail(tree), factor));\n}\n```\n\n```javascript\nscale_tree_example\n      scale_tree\n\nscale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),\n           10);\n\nhead(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),\n           10));\n```\n\nAnother way to implement\nscale_tree\nis to regard the tree as a sequence of sub-trees and use\nmap.\n\nWe map over the sequence, scaling each sub-tree in turn, and return the\nlist of results.\n\nIn the base case, where the tree is a leaf, we simply\nmultiply by the factor:\n\n```javascript\nscale_tree_example_2\n\nscale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),\n           10);\n\nhead(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),\n           10));\n```",
    "token_count": 301,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Hierarchical Structures",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Hierarchical_Structures_2"
  },
  {
    "content": "In the base case, where the tree is a leaf, we simply\nmultiply by the factor:\n\n```javascript\nscale_tree_with_map\n      scale_tree_example_2\n      10\n\nfunction scale_tree(tree, factor) {\n    return map(sub_tree => is_pair(sub_tree)\n                           ? scale_tree(sub_tree, factor)\n                           : sub_tree * factor,\n               tree);\n}\n```\n\nMany tree operations can be implemented by similar combinations of sequence operations and recursion.",
    "token_count": 52,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Hierarchical Structures",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Hierarchical_Structures_3"
  },
  {
    "content": "One of the useful structures we can build with pairs is a\nsequence an ordered collection of data objects.\n\nThere\nare, of course, many ways to represent sequences in terms of pairs.\n\nOne\nparticularly straightforward representation is illustrated in\nfigure,\nwhere the sequence 1, 2, 3, 4 is represented as a chain of pairs.\n\nThe\nhead\nof each pair is the\ncorresponding item in the chain, and the\ntail\nof the pair is the next pair in the chain.\n\nThe\ntail\nof the final pair signals the end of the\nsequence,\nrepresented in box-and-pointer\ndiagrams as a diagonal line\n\n```javascript\nJavaScripts primitive value\n\tnull.\n```\n\nThe entire sequence is constructed by nested pair operations:\n\n```javascript\ncons_example\n\npair(1,\n     pair(2,\n          pair(3,\n               pair(4, null))));\n```\n\nSuch a sequence of pairs, formed by nested\npair applications,\nis called a\nlist , and\nour JavaScript environment\nprovides a primitive called\nlist(1, 2, 3, 4).\n\nIn general,\n\n```javascript\nlist(a$_{1}$, a$_{2}$, $\\ldots$, a$_{n}$)\n```\n\nis equivalent to\n\n```javascript\npair(a$_{1}$, pair(a$_{2}$, pair($\\ldots$, pair(a$_{n}$, null)$\\ldots$)))\n```\n\n```javascript\nOur interpreter prints pairs using a textual representation of\n\tbox-and-pointer diagrams that we call box notation.\n        pair(1, 2)\n        is printed as [1, 2], and\n\tthe data object in figure\n        is printed as\n        [1, [2, [3, [4, null]]]]:\n```\n\n```javascript\none_four\n      one_four_example\n      [ 2, [ 3, [ 4, null ] ] ]\n\nconst one_through_four = list(1, 2, 3, 4);\n```\n\n```javascript\none_four\n      one_four_example\n\none_through_four;\n\ntail(one_through_four);\n```\n\nWe can think of\nhead\nas selecting the first item in the list, and of\ntail\nas selecting the sublist consisting of all but the first item.\n\nNested\napplications of\nhead\nand\ntail\ncan be used to extract the second, third, and subsequent items in the\nlist.\n\nThe constructor\npair\nmakes a list like the original one, but with an additional item at the\nbeginning.\n\n```javascript\ncar_one_four\n      one_four\n      1\n\nhead(one_through_four);\n```",
    "token_count": 304,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Representing Sequences",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Representing_Sequences_1"
  },
  {
    "content": "The constructor\npair\nmakes a list like the original one, but with an additional item at the\nbeginning.\n\n```javascript\ncdr_one_four\n      one_four\n      [ 2, [ 3, [ 4, null ] ] ]\n\ntail(one_through_four);\n```\n\n```javascript\ncar_cdr_one_four\n      one_four\n      2\n\nhead(tail(one_through_four));\n```\n\n```javascript\ncons_one_four\n      one_four\n      [ 2, [ 3, [ 4, null ] ] ]\n\npair(10, one_through_four);\n\ntail(tail(pair(10, one_through_four)));\n```\n\n```javascript\ncons5_one_four\n      one_four\n      [ 2, [ 3, [ 4, null ] ] ]\n\npair(5, one_through_four);\n\ntail(tail(pair(5, one_through_four)));\n```\n\n```javascript\nThe value null, used to terminate\n\tthe chain of pairs, can be thought of as a sequence of no elements, the\n        empty list.\n```\n\nBox notation is sometimes difficult to read.\n\nIn this book, when we want to\nindicate the list nature of a data structure, we will employ the\nalternative\nlist notation : Whenever possible, list notation uses\napplications\nof\n\nwe write\n\nin list notation.\n\nThe use of pairs to represent sequences of elements as lists is accompanied\nby conventional programming techniques for manipulating lists by\nsuccessively\ntail to walk down the lists.\n\nFor example, the\nfunction\nlist_ref\ntakes as arguments a list and a number $n$ and\nreturns the $n$ th item of the list.\n\nIt is\ncustomary to number the elements of the list beginning with 0.\n\nThe method\nfor computing\nlist_ref\nis the following:\n-\n-\nFor $n=0$ ,\nlist_ref\nshould return the\nhead\nof the list.\n-\n-\nOtherwise,\nlist_ref\nshould return the $(n-1)$ st item of the\ntail\nof the list.\n\n```javascript\nlist_ref\n      list_ref_example\n\nfunction list_ref(items, n) {\n    return n === 0\n           ? head(items)\n           : list_ref(tail(items), n - 1);\n}\n```\n\n```javascript\nlist_ref_example\n      list_ref\n      16\n\nconst squares = list(1, 4, 9, 16, 25);\n\nlist_ref(squares, 3);\n```\n\n```javascript\nmanual_squares\n\nconst squares = list(1, 4, 9, 16, 25);\n```\n\n```javascript\nmanual_odds\n\nconst odds = list(1, 3, 5, 7);\n```\n\nOften we\nwalk down the whole list.",
    "token_count": 306,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Representing Sequences",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Representing_Sequences_2"
  },
  {
    "content": "Often we\nwalk down the whole list.\n\nTo aid in this,\nour JavaScript environment\nincludes a primitive\npredicate\nis_null,\nwhich tests whether its argument is the empty list.\n\nThe\nfunction\n\n```javascript\nlength\n      length_example\n      4\n\nfunction length(items) {\n    return is_null(items)\n           ? 0\n           : 1 + length(tail(items));\n}\n```\n\n```javascript\nlength_example\n\nconst odds = list(1, 3, 5, 7);\n\nlength(odds);\n```\n\nThe function\nimplements a simple recursive plan.\n\nThe reduction step is:\n-\n-\nThe\ntail\nof the list.\n\nThis is applied successively until we reach the base case:\n-\n-\nThe\nWe could also compute\n\n```javascript\nlength_iter\n      length_example\n      4\n\nfunction length(items) {\n    function length_iter(a, count) {\n        return is_null(a)\n               ? count\n               : length_iter(tail(a), count + 1);\n    }\n    return length_iter(items, 0);\n}\n```\n\nAnother conventional programming technique is to tail, as in the function\n\n```javascript\nappend_example\n      append\n      manual_squares\n      manual_odds\n      9\n\nappend(squares, odds);\n\nlength(append(squares, odds));\n```\n\n```javascript\nappend_example2\n      append\n      manual_squares\n      manual_odds\n      9\n\nappend(odds, squares);\n\nlength(append(odds, squares));\n```\n\nThe function append\nis also implemented using a recursive plan.\n\nTo\n-\n-\nIf\n-\n-\nOtherwise,\ntail\nof\nadjoin\nthe\nhead\nof\nto the result:\n\n```javascript\nappend\n      append_example\n      9\n\nfunction append(list1, list2) {\n    return is_null(list1)\n           ? list2\n           : pair(head(list1), append(tail(list1), list2));\n}\n```\n\nWe want to rewrite the function\n\n```javascript\nus_coins\n\nconst us_coins = list(50, 25, 10, 5, 1);\nconst uk_coins = list(100, 50, 20, 10, 5, 2, 1);\n```\n\nWe could then call\n\n```javascript\ncc_example\n        cc\n        us_coins\n\ncc(100, us_coins);\n```\n\nTo do this will require changing the program\n\n```javascript\ncc_helpers\n\n// first_denomination, except_first_denomination\n// and no_more to be given by student\n```\n\n```javascript\ncc\n        cc_helpers\n\tcc_example\n\nfunction cc(amount, coin_values) {\n    return amount === 0\n           ? 1\n           : amount < 0 || no_more(coin_values)\n           ? 0\n           : cc(amount, except_first_denomination(coin_values)) +\n             cc(amount - first_denomination(coin_values), coin_values);\n}\n```\n\nDefine the\nfunctions\nfirst_denomination,\nexcept_first_denomination,\nand\nno_more\nin terms of primitive operations on list structures.\n\nDoes the order of\nthe list\ncoin_values\naffect the answer produced by",
    "token_count": 315,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Representing Sequences",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Representing_Sequences_3"
  },
  {
    "content": "Does the order of\nthe list\ncoin_values\naffect the answer produced by\n\nOne extremely useful operation is to apply some transformation to each\nelement in a list and generate the list of results.\n\nFor instance, the\nfollowing\nfunction\nscales each number in a list by a given factor:\n\n```javascript\nscale_list\n      scale_list_example\n      [ 30, [ 40, [ 50, null ] ] ]\n\nfunction scale_list(items, factor) {\n    return is_null(items)\n           ? null\n           : pair(head(items) * factor,\n                  scale_list(tail(items), factor));\n}\n```\n\n```javascript\nscale_list_example\n\nscale_list(list(1, 2, 3, 4, 5), 10);\n\ntail(tail(scale_list(list(1, 2, 3, 4, 5), 10)));\n```\n\nWe can abstract this general idea and capture it as a common pattern\nexpressed as a higher-order\nfunction,\njust as in section.\n\nThe\nhigher-order\nfunction\nhere is called\nThe function map\ntakes as arguments a\nfunction\nof one argument and a list, and returns a list of the results produced by\napplying the\nfunction\nto each element in the list:\n\n```javascript\nmap\n      map_example\n      [ 2.5, [ 11.6, [ 17, null ] ] ]\n\nfunction map(fun, items) {\n    return is_null(items)\n           ? null\n           : pair(fun(head(items)),\n                  map(fun, tail(items)));\n}\n```\n\n```javascript\nmap_example\n      abs_definition\n      map\n      [ 2.5, [ 11.6, [ 17, null ] ] ]\n\nmap(abs, list(-10, 2.5, -11.6, 17));\n\ntail(map(abs, list(-10, 2.5, -11.6, 17)));\n```\n\n```javascript\nmap_example2\n      map\n      [ 4, [ 9, [ 16, null ] ] ]\n\nmap(x => x * x, list(1, 2, 3, 4));\n\ntail(map(x => x * x, list(1, 2, 3, 4)));\n```\n\nNow we can give a new definition of scale_list in terms of\n\n```javascript\nscale_list2\n      scale_list_example\n      [ 30, [ 40, [ 50, null ] ] ]\n\nfunction scale_list(items, factor) {\n    return map(x => x * factor, items);\n}\n```\n\nThe function map\nis an important construct, not only because it captures a common pattern,\nbut because it establishes a higher level of abstraction in dealing with\nlists.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Representing Sequences",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Representing_Sequences_4"
  },
  {
    "content": "The function map\nis an important construct, not only because it captures a common pattern,\nbut because it establishes a higher level of abstraction in dealing with\nlists.\n\nIn the original definition of\nscale_list,\nthe recursive structure of the program draws attention to the\nelement-by-element processing of the list.\n\nDefining\nscale_list\nin terms of t) but that we\nthink about the process differently.\n\nIn effect,\nfunctions\nthat transform lists from the details of how the elements of the list are\nextracted and combined.\n\nLike the barriers shown in\nfigure,\nthis abstraction gives us the flexibility to change the low-level details\nof how sequences are implemented, while preserving the conceptual framework\nof operations that transform sequences to sequences.\n\nSection expands\non this use of sequences as a framework for organizing programs.\n\nLouis then tries to fix his bug by interchanging the arguments to pair:\n\n```javascript\nsquare_list3\n      square_definition\n      square_list_warning\n      square_list_example\n      16\n\nfunction square_list(items) {\n    function iter(things, answer) {\n        return is_null(things)\n               ? answer\n               : iter(tail(things),\n                      pair(answer,\n                           square(head(things))));\n    }\n    return iter(items, null);\n}\n```\n\nThis doesn t work either.\n\nExplain.",
    "token_count": 176,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Representing Sequences",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Data_Representing_Sequences_5"
  },
  {
    "content": "In working with compound data, we ve stressed how data abstraction\npermits us to design programs without becoming enmeshed in the details\nof data representations, and how abstraction preserves for us the\nflexibility to experiment with alternative representations.\n\nIn this\nsection, we introduce another powerful design principle for working\nwith data structures the use of conventional interfaces.\n\nIn section we saw how\nprogram abstractions, implemented as higher-order\nfunctions,\ncan capture common patterns in programs that deal with numerical data.\n\nOur\nability to formulate analogous operations for working with compound data\ndepends crucially on the style in which we manipulate our data structures.\n\nConsider, for example, the following\nfunction,\nanalogous to the\ncount_leaves\nfunction\nof section , which takes a tree as argument\nand computes the sum of the squares of the leaves that are odd:\n\n```javascript\nodd_definition\n\nfunction is_odd(n) {\n    return n % 2 === 1;\n}\n```\n\n```javascript\nsquare_definition\n      odd_definition\n      sum_odd_squares_example\n      34\n\nfunction sum_odd_squares(tree) {\n    return is_null(tree)\n           ? 0\n           : ! is_pair(tree)\n           ? is_odd(tree) ? square(tree) : 0\n           : sum_odd_squares(head(tree)) +\n             sum_odd_squares(tail(tree));\n}\n```\n\n```javascript\nsum_odd_squares_example\n\nsum_odd_squares(list(list(2, 3), list(4, 5)));\n```\n\nOn the surface, this function is very different from the following one, which constructs a list of all the even Fibonacci numbers ${\\textrm{Fib}}(k)$ , where\n\n$k$ is less than or equal to a given integer $n$ :\n\n```javascript\neven_definition\n      fib_definition\n      even_fibs_example\n      [ 2, [ 8, [ 34, null ] ] ]\n\nfunction even_fibs(n) {\n    function next(k) {\n        if (k > n) {\n            return null;\n        } else {\n            const f = fib(k);\n            return is_even(f)\n                   ? pair(f, next(k + 1))\n                   : next(k + 1);\n        }\n    }\n    return next(0);\n}\n```\n\n```javascript\neven_fibs_example\n\neven_fibs(9);\n\ntail(even_fibs(9));\n```\n\nDespite the fact that these two\nfunctions\nare structurally very different, a more abstract description of the two\ncomputations reveals a great deal of similarity.",
    "token_count": 300,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Sequences as Conventional Interfaces",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Sequences_as_Conventional_Interfaces_1"
  },
  {
    "content": "Despite the fact that these two\nfunctions\nare structurally very different, a more abstract description of the two\ncomputations reveals a great deal of similarity.\n\nThe first program\n-\n-\nenumerates the leaves of a tree;\n-\n-\nfilters them, selecting the odd ones;\n-\n-\nsquares each of the selected ones; and\n-\n-\naccumulates the results using\n+,\nstarting with 0.\n\nThe second program\n-\n-\nenumerates the integers from 0 to $n$ ;\n-\n-\ncomputes the Fibonacci number for each integer;\n-\n-\nfilters them, selecting the even ones; and\n-\n-\naccumulates the results using\npair,\nstarting with the empty list.\n\nA signal-processing engineer would find it natural to conceptualize these\nprocesses in terms of\nfigure.\n\nIn\nsum_odd_squares,\nwe begin with an\nenumerator , which generates a signal consisting of\nthe leaves of a given tree.\n\nThis signal is passed through a\nfilter , which eliminates all but the odd elements.\n\nThe resulting\nsignal is in turn passed through a\nmap , which is a transducer that applies the\nfunction\nto each element.\n\nThe output of the map is then fed to an\naccumulator , which combines the elements using\n+,\nstarting from an initial 0.\n\nThe plan for\neven_fibs\nis analogous.\n\nUnfortunately, the two\nfunction declarations\nabove fail to exhibit this signal-flow structure.\n\nFor instance, if we\nexamine the\nsum_odd_squares\nfunction,\nwe find that the enumeration is implemented partly by the\nis_null\nand\nis_pair\ntests and partly by the tree-recursive structure of the\nfunction.\n\nSimilarly, the accumulation is found partly in the tests and partly in the\naddition used in the recursion.\n\nIn general, there are no distinct parts of\neither\nfunction\nthat correspond to the elements in the signal-flow description.",
    "token_count": 287,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Sequences as Conventional Interfaces",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Sequences_as_Conventional_Interfaces_2"
  },
  {
    "content": "In general, there are no distinct parts of\neither\nfunction\nthat correspond to the elements in the signal-flow description.\n\nOur two\nfunctions\ndecompose the computations in a different way, spreading the enumeration\nover the program and mingling it with the map, the filter, and the\naccumulation.\n\nIf we could organize our programs to make the signal-flow\nstructure manifest in the\nfunctions\nwe write, this would increase the conceptual clarity of the resulting\nprogram.\n\nThe key to organizing programs so as to more clearly reflect the\nsignal-flow structure is to concentrate on the signals that\nflow from one stage in the process to the next.\n\nIf we represent these\nsignals as lists, then we can use list operations to implement the\nprocessing at each of the stages.\n\nFor instance, we can implement the\nmapping stages of the signal-flow diagrams using the\nfunction\nfrom section :\n\n```javascript\nsquare_definition\n      map\n      25\n\nmap(square, list(1, 2, 3, 4, 5));\n\nlist_ref(map(square, list(1, 2, 3, 4, 5)), 4);\n```\n\nFiltering a sequence to select only those elements that satisfy a given predicate is accomplished by\n\n```javascript\nfilter\n      filter_odd\n      [ 1, [ 3, [ 5, null ] ] ]\n\nfunction filter(predicate, sequence) {\n    return is_null(sequence)\n           ? null\n           : predicate(head(sequence))\n           ? pair(head(sequence),\n                  filter(predicate, tail(sequence)))\n           : filter(predicate, tail(sequence));\n}\n```\n\n```javascript\nfilter_odd\n      [ 1, [ 3, [ 5, null ] ] ]\n\nfunction is_odd(n) {\n    return n % 2 === 1;\n}\nfilter(is_odd, list(1, 2, 3, 4, 5));\n```\n\nFor example,\n\n```javascript\nfilter\n      odd_definition\n\nfilter(is_odd, list(1, 2, 3, 4, 5));\n```\n\nAccumulations can be implemented by\n\n```javascript\naccumulate\n\nfunction accumulate(op, initial, sequence) {\n    return is_null(sequence)\n           ? initial\n           : op(head(sequence),\n                accumulate(op, initial, tail(sequence)));\n}\n```\n\n```javascript\nsimple_plus\n\nfunction plus(x, y) {\n    return x + y;\n}\n```\n\n```javascript\naccumulate\n      simple_plus\n      15\n\naccumulate(plus, 0, list(1, 2, 3, 4, 5));\n```\n\n```javascript\nsimple_times\n\nfunction times(x, y) {\n    return x * y;\n}\n```",
    "token_count": 310,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Sequences as Conventional Interfaces",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Sequences_as_Conventional_Interfaces_3"
  },
  {
    "content": "Accumulations can be implemented by\n\n```javascript\naccumulate\n      simple_times\n      120\n\naccumulate(times, 1, list(1, 2, 3, 4, 5));\n```\n\n```javascript\naccumulate\n      [ 3, [ 4, [ 5, null ] ] ]\n\naccumulate(pair, null, list(1, 2, 3, 4, 5));\n\ntail(tail(accumulate(pair, null, list(1, 2, 3, 4, 5))));\n```\n\nAll that remains to implement signal-flow diagrams is to enumerate the\nsequence of elements to be processed.\n\nFor\neven_fibs,\nwe need to generate the sequence of integers in a given range, which we\ncan do as follows:\n\n```javascript\nenumerate_interval\n      enumerate_interval_example\n      [ 5, [ 6, [ 7, null ] ] ]\n\nfunction enumerate_interval(low, high) {\n    return low > high\n           ? null\n           : pair(low,\n                  enumerate_interval(low + 1, high));\n}\n```\n\n```javascript\nenumerate_interval_example\n      enumerate_interval\n\nenumerate_interval(2, 7);\n\ntail(tail(tail(enumerate_interval(2, 7))));\n```\n\nTo enumerate the leaves of a tree, we can use\n\n```javascript\nenumerate_tree\n      enumerate_tree_example\n      [ 3, [ 4, [ 5, null ] ] ]\n\nfunction enumerate_tree(tree) {\n    return is_null(tree)\n           ? null\n           : ! is_pair(tree)\n           ? list(tree)\n           : append(enumerate_tree(head(tree)),\n                    enumerate_tree(tail(tree)));\n}\n```\n\n```javascript\nenumerate_tree_example\n      enumerate_tree\n\nenumerate_tree(list(1, list(2, list(3, 4)), 5));\n\ntail(tail(enumerate_tree(list(1, list(2, list(3, 4)), 5))));\n```\n\nNow we can reformulate\nsum_odd_squares\nand\neven_fibs\nas in the signal-flow diagrams.\n\nFor\nsum_odd_squares,\nwe enumerate the sequence of leaves of the tree, filter this to keep only\nthe odd numbers in the sequence, square each element, and sum the results:\n\n```javascript\nsquare_definition\n      simple_plus\n      odd_definition\n      enumerate_tree\n      sum_odd_squares_example\n      34\n\nfunction sum_odd_squares(tree) {\n    return accumulate(plus,\n                      0,\n                      map(square,\n                          filter(is_odd,\n                                 enumerate_tree(tree))));\n}\n```\n\nFor even_fibs, we enumerate the integers from 0 to $n$ , generate the Fibonacci number for each of these integers, filter the resulting sequence to\n\nkeep only the even elements, and accumulate the results into a list:\n\n```javascript\neven_definition\n      fib_definition\n      enumerate_interval\n      even_fibs_example\n      [ 2, [ 8, [ 34, null ] ] ]\n\nfunction even_fibs(n) {\n    return accumulate(pair,\n                      null,\n                      filter(is_even,\n                             map(fib,\n                                 enumerate_interval(0, n))));\n}\n```",
    "token_count": 297,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Sequences as Conventional Interfaces",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Sequences_as_Conventional_Interfaces_4"
  },
  {
    "content": "keep only the even elements, and accumulate the results into a list:\n\nThe value of expressing programs as sequence operations is that this\nhelps us make program designs that are modular, that is, designs that\nare constructed by combining relatively independent pieces.\n\nWe can\nencourage modular design by providing a library of standard components\ntogether with a conventional interface for connecting the components\nin flexible ways.\n\nModular construction sum_odd_squares and even_fibs functions in a program that constructs a list of the squares of the first $n+1$ Fibonacci numbers:\n\n```javascript\nlist_fib_squares\n      square_definition\n      fib_definition\n      enumerate_interval\n      list_fib_squares_example\n      11\n\nfunction list_fib_squares(n) {\n    return accumulate(pair,\n                      null,\n                      map(square,\n                          map(fib,\n                              enumerate_interval(0, n))));\n}\n```\n\n```javascript\nlist_fib_squares_example\n      list_fib_squares\n\nlist_fib_squares(10);\n\nlength(list_fib_squares(10));\n```\n\nWe can rearrange the pieces and use them in computing the product of the squares of the odd integers in a sequence:\n\n```javascript\nproduct_of_squares_of_odd_elements\n      square_definition\n      odd_definition\n      simple_times\n      product_of_squares_of_odd_elements_example\n      225\n\nfunction product_of_squares_of_odd_elements(sequence) {\n    return accumulate(times,\n                      1,\n                      map(square,\n                          filter(is_odd, sequence)));\n}\n```\n\n```javascript\nproduct_of_squares_of_odd_elements_example\n      product_of_squares_of_odd_elements\n\nproduct_of_squares_of_odd_elements(list(1, 2, 3, 4, 5));\n```\n\nWe can also formulate conventional data-processing applications in terms of\nsequence operations.\n\nSuppose we have a sequence of personnel records and\nwe want to find the salary of the highest-paid programmer.\n\nAssume that we\nhave a selector\nis_programmer\nthat tests if a record is for a programmer.\n\nThen we can write\n\n```javascript\nlinus\n\nconst my_records = list(list(\"Linus\", \"programmer\", 30000),\n                        list(\"Richard\", \"programmer\", 25000),\n                        list(\"Bill\", \"manager\", 2500000));\nfunction is_programmer(record) {\n    return head(tail(record)) === \"programmer\";\n}\nfunction salary(record) {\n    return head(tail(tail(record)));\n}\nsalary_of_highest_paid_programmer(my_records);\n```\n\n```javascript\nlinus\n      30000\n\nfunction salary_of_highest_paid_programmer(records) {\n    return accumulate(math_max,\n                      0,\n                      map(salary,\n                          filter(is_programmer, records)));\n}\n```\n\nThese examples give just a hint of the vast range of operations that can be expressed as sequence operations.\n\nSequences, implemented here as lists, serve as a conventional interface\nthat permits us to combine processing modules.",
    "token_count": 293,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Sequences as Conventional Interfaces",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Data_Sequences_as_Conventional_Interfaces_5"
  },
  {
    "content": "Sequences, implemented here as lists, serve as a conventional interface\nthat permits us to combine processing modules.\n\nAdditionally, when we\nuniformly represent structures as sequences, we have localized the\ndata-structure dependencies in our programs to a small number of sequence\noperations.\n\nBy changing these, we can experiment with alternative\nrepresentations of sequences, while leaving the overall design of our\nprograms intact.\n\nWe will exploit this capability in\nsection , when we generalize the\nsequence-processing paradigm to admit infinite sequences.\n\nWe can extend the sequence paradigm to include many computations that are\ncommonly expressed using nested loops. $n$ , find all ordered pairs of distinct positive\nintegers $i$ and $j$ ,\nwhere $1\\leq j < i\\leq n$ , such that\n$i +j$ is prime.\n\nFor example, if\n$n$ is 6, then the pairs are the following:\n\\[\n\\begin{array}{c|ccccccc}\ni & 2 & 3 & 4 & 4 & 5 & 6 & 6 \\\\\nj & 1 & 2 & 1 & 3 & 2 & 1 & 5 \\\\\n\\hline\ni+j & 3 & 5 & 5 & 7 & 7 & 7 & 11\n\\end{array}\n\\]\nA natural way to organize this computation is to generate the sequence\nof all ordered pairs of positive integers less than or equal to\n$n$ , filter to select those pairs whose sum is\nprime, and then, for each pair $(i, j)$ that\npasses through the filter, produce the triple\n$(i, j, i+j)$.\n\nHere is a way to generate the sequence of pairs: For each integer\n$i\\leq n$ , enumerate the integers\n$j < i$ , and for each such\n$i$ and $j$\ngenerate the pair $(i, j)$.\n\nIn terms of\nsequence operations, we map along the sequence\nenumerate_interval(1, n).",
    "token_count": 287,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Sequences as Conventional Interfaces",
    "chunk_index": 6,
    "chunk_id": "Building_Abstractions_with_Data_Sequences_as_Conventional_Interfaces_6"
  },
  {
    "content": "In terms of\nsequence operations, we map along the sequence\nenumerate_interval(1, n).\n\nFor each $i$ in this sequence, we map along the\nsequence\nenumerate_interval(1, i - 1).\n\nFor each $j$ in this latter sequence, we\ngenerate the pair\nlist(i, j).\n\nThis gives us a sequence of pairs for each $i$.\n\nCombining all the sequences for all the $i$ (by\naccumulating with\n\n```javascript\nenumerate_interval_n\n\nconst n = 6;\n```\n\n```javascript\nenumerate_interval\n      enumerate_interval_n\n      15\n\naccumulate(append,\n           null,\n           map(i => map(j => list(i, j),\n                        enumerate_interval(1, i - 1)),\n               enumerate_interval(1, n)));\n\nlength(accumulate(append,\n           null,\n           map(i => map(j => list(i, j),\n                        enumerate_interval(1, i - 1)),\n               enumerate_interval(1, n))));\n```\n\nThe combination of mapping and accumulating with function:\n\n```javascript\nflatmap\n      flatmap_example\n      8\n\nfunction flatmap(f, seq) {\n    return accumulate(append, null, map(f, seq));\n}\n```\n\n```javascript\nflatmap_example\n\nflatmap(x => list(x, x), list(1, 2, 3, 4));\n\nlength(flatmap(x => list(x, x), list(1, 2, 3, 4)));\n```\n\nNow filter this sequence of pairs to find those whose sum is prime.\n\nThe\nfilter predicate is called for each element of the sequence; its argument\nis a pair and it must extract the integers from the pair.\n\nThus, the\npredicate to apply to each element in the sequence is\n\n```javascript\nprime_sum\n      prime_definition\n      prime_sum_example\n      true\n\nfunction is_prime_sum(pair) {\n    return is_prime(head(pair) + head(tail(pair)));\n}\n```\n\n```javascript\nprime_sum_example\n\nis_prime_sum(list(8, 9));\n```\n\nFinally, generate the sequence of results by mapping over the filtered pairs using the following function, which constructs a triple consisting of the two elements\n\nof the pair along with their sum:\n\n```javascript\nmake_pair_sum\n      make_pair_sum_example\n      [ 8, [ 9, [ 17, null ] ] ]\n\nfunction make_pair_sum(pair) {\n    return list(head(pair), head(tail(pair)),\n                head(pair) + head(tail(pair)));\n}\n```\n\n```javascript\nmake_pair_sum_example\n\nmake_pair_sum(list(8, 9));\n```\n\nCombining all these steps yields the complete function:\n\n```javascript\nprime_sum_pairs\n      make_pair_sum\n      prime_sum\n      flatmap\n      enumerate_interval\n      prime_sum_pairs_example\n      7\n\nfunction prime_sum_pairs(n) {\n    return map(make_pair_sum,\n               filter(is_prime_sum,\n                      flatmap(i => map(j => list(i, j),\n                                       enumerate_interval(1, i - 1)),\n                              enumerate_interval(1, n))));\n}\n```\n\n```javascript\nprime_sum_pairs_example\n\nprime_sum_pairs(6);\n\nlength(prime_sum_pairs(6));\n```",
    "token_count": 314,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Sequences as Conventional Interfaces",
    "chunk_index": 7,
    "chunk_id": "Building_Abstractions_with_Data_Sequences_as_Conventional_Interfaces_7"
  },
  {
    "content": "Combining all these steps yields the complete function:\n\nNested mappings are also useful for sequences other than those that\nenumerate intervals.\n\nSuppose we wish to generate all the\n$S$ ; that is, all the ways of ordering\nthe items in the set.\n\nFor instance, the permutations of\n$\\{1, 2, 3\\}$ are\n$\\{1, 2, 3\\}$ ,\n$\\{ 1, 3, 2\\}$ ,\n$\\{2, 1, 3\\}$ ,\n$\\{ 2, 3, 1\\}$ ,\n$\\{ 3, 1, 2\\}$ , and\n$\\{ 3, 2, 1\\}$.\n\nHere is a plan for generating\nthe permutations of $S$ : For each item\n$x$ in $S$ ,\nrecursively generate the sequence of permutations of\n$S-x$ , $x$ to the front of each one.\n\nThis yields, for\neach $x$ in $S$ , the\nsequence of permutations of $S$ that begin\nwith $x$.\n\nCombining these sequences for\nall $x$ gives all the permutations\nof $S$ :\n\n```javascript\nflatmap\n      permutations_example\n      6\n\nfunction permutations(s) {\n    return is_null(s)             // empty set?\n           ? list(null)           // sequence containing empty set\n           : flatmap(x => map(p => pair(x, p),\n                              permutations(remove(x, s))),\n                     s);\n}\n```\n\n```javascript\npermutations_example\n\npermutations(list(1, 2, 3));\n\nlength(permutations(list(1, 2, 3)));\n```\n\nNotice how this strategy reduces the problem of generating permutations of\n$S$ to the problem of generating the\npermutations of sets with fewer elements than\n$S$.\n\nIn the terminal case, we work our way down\nto the empty list, which represents a set of no elements.\n\nFor this, we\ngenerate\nlist(null),\nwhich is a sequence with one item, namely the set with no elements.\n\nThe\nremove\nfunction\nused in\n\n```javascript\nremove\n      remove_example\n      4\n\nfunction remove(item, sequence) {\n    return filter(x => ! (x === item),\n                  sequence);\n}\n```\n\n```javascript\nremove_example\n\nlength(remove(3, list(1, 2, 3, 4, 5)));\n\nlength(remove(3, list(1, 2, 3, 4, 5)));\n```",
    "token_count": 286,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Sequences as Conventional Interfaces",
    "chunk_index": 8,
    "chunk_id": "Building_Abstractions_with_Data_Sequences_as_Conventional_Interfaces_8"
  },
  {
    "content": "The\nremove\nfunction\nused in\n\nWe implement this solution as a\nfunction\nqueens,\nwhich returns a sequence of all solutions to the problem of placing\n$n$ queens on an\n$n\\times n$ chessboard.\n\nThe function queens\nhas an internal\nfunction\nqueens_cols\nthat returns the sequence of all ways to place queens in the first\n$k$ columns of the board.\n\n```javascript\nexample_queens\n\nqueens(8);\n\nlength(queens(8));\n```\n\n```javascript\nqueens\n      flatmap\n      enumerate_interval\n      example_queens\n\nfunction queens(board_size) {\n    function queen_cols(k) {\n        return k === 0\n               ? list(empty_board)\n               : filter(positions => is_safe(k, positions),\n                        flatmap(rest_of_queens =>\n                                  map(new_row =>\n                                        adjoin_position(new_row, k,\n                                                        rest_of_queens),\n                                      enumerate_interval(1, board_size)),\n                                queen_cols(k - 1)));\n    }\n    return queen_cols(board_size);\n}\n```\n\nIn this\nfunction\nrest_of_queens\nis a way to place $k-1$ queens in the first\n$k-1$ columns, and\nnew_row\nis a proposed row in which to place the queen for the\n$k$ th column.\n\nComplete the program by\nimplementing the representation for sets of board positions, including the\nfunction\nadjoin_position,\nwhich adjoins a new row-column position to a set of positions, and\nempty_board,\nwhich represents an empty set of positions.\n\nYou must also write the\nfunction\nis_safe,\nwhich determines for a set of positions whether the queen in the\n$k$ th column is safe with respect to the others.\n\n(Note that we need only check whether the new queen is safe the\nother queens are already guaranteed safe with respect to each other.)",
    "token_count": 224,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Hierarchical Data and the Closure Property",
    "subsection": "Sequences as Conventional Interfaces",
    "chunk_index": 9,
    "chunk_id": "Building_Abstractions_with_Data_Sequences_as_Conventional_Interfaces_9"
  },
  {
    "content": "In section , we noted that a\nfunction\nused as an element in creating a more complex\nfunction\ncould be regarded not only as a collection of particular operations but\nalso as a\nfunctional\nabstraction.\n\nThat is, the details of how the\nfunction\nwas implemented could be suppressed, and the particular\nfunction\nitself could be replaced by any other\nfunction\nwith the same overall behavior.\n\nIn other words, we could make an\nabstraction that would separate the way the\nfunction\nwould be used from the details of how the\nfunction\nwould be implemented in terms of more primitive\nfunctions.\n\nThe analogous notion for compound data is called\ndata abstraction.\n\nData abstraction is a methodology that enables\nus to isolate how a compound data object is used from the details of how it\nis constructed from more primitive data objects.\n\nThe basic idea of data abstraction is to structure the programs that are\nto use compound data objects so that they operate on\nabstract data.\n\nThat is, our programs should use data in such\na way as to make no assumptions about the data that are not strictly\nnecessary for performing the task at hand.\n\nAt the same time, a\nconcrete data representation is defined independent of the\nprograms that use the data.\n\nThe interface between these two parts of our\nsystem will be a set of\nfunctions,\ncalled\nselectors and\nconstructors , that implement the abstract data in terms of the\nconcrete representation.\n\nTo illustrate this technique, we will consider\nhow to design a set of\nfunctions\nfor manipulating rational numbers.",
    "token_count": 261,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Introduction_to_Data_Abstraction_1"
  },
  {
    "content": "make_@rat and selectors\n\nWe can envision the structure of the rational-number system as\nshown in\nfigure.\n\nThe horizontal lines represent abstraction barriers that isolate\ndifferent levels of the system.\n\nAt each level, the barrier\nseparates the programs (above) that use the data abstraction from the\nprograms (below) that implement the data abstraction.\n\nPrograms that\nuse rational numbers manipulate them solely in terms of the\nfunctions\nsupplied for public use by the rational-number package:\nadd_rat,\nsub_rat,\nmul_rat,\ndiv_rat,\nand\nequal_rat.\n\nThese, in turn, are implemented solely in terms of the\nmake_rat,\npair,\nhead,\nand\ntail.\n\nIn effect,\nfunctions\nat each level are the interfaces that define the abstraction barriers and\nconnect the different levels.\n\nThis simple idea has many advantages.\n\nOne advantage is that it makes\nprograms much easier to maintain and to modify.\n\nAny complex data\nstructure can be represented in a variety of ways with the primitive\ndata structures provided by a programming language.\n\nOf course, the\nchoice of representation influences the programs that operate on it;\nthus, if the representation were to be changed at some later time, all\nsuch programs might have to be modified accordingly.\n\nThis task could\nbe time-consuming and expensive in the case of large programs unless\nthe dependence on the representation were to be confined by design to\na very few program modules.\n\nFor example, an alternate way to address the problem of functions:\n\n```javascript\nmake_rat_4\n      [ 1, 2 ]\n      gcd_definition\n      print_rat_example5\n\nfunction make_rat(n, d) {\n    return pair(n, d);\n}\nfunction numer(x) {\n    const g = gcd(head(x), tail(x));\n    return head(x) / g;\n}\nfunction denom(x) {\n    const g = gcd(head(x), tail(x));\n    return tail(x) / g;\n}\n```",
    "token_count": 274,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "Abstraction Barriers",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Abstraction_Barriers_1"
  },
  {
    "content": "For example, an alternate way to address the problem of functions:\n\n```javascript\nprint_rat_example5\n\n// printing the rational in one line requires some string\n// manipulation: stringify turns a number into a string\n// and the operator + can be applied to strings for\n// string concatenation\nfunction print_rat(x) {\n    return display(stringify(numer(x)) + \"/\" + stringify(denom(x)));\n}\n\nconst one_half = make_rat(1, 2);\n\nprint_rat(one_half);\n\nconst one_half = make_rat(1, 2);\n\none_half;\n```\n\nThe difference between this implementation and the previous one lies in when we compute the functions add_rat, sub_rat, and so on do not have to\n\nbe modified at all.\n\nConstraining the dependence on the representation to a few interface\nfunctions\nhelps us design programs as well as modify them, because it allows us to\nmaintain the flexibility to consider alternate implementations.\n\nTo continue\nwith our simple example, suppose we are designing a rational-number package\nand we can t decide initially whether to perform the",
    "token_count": 153,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "Abstraction Barriers",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Abstraction_Barriers_2"
  },
  {
    "content": "Suppose we want to do\n\nLet us begin by assuming that we already have a way of constructing a\nrational number from a numerator and a denominator.\n\nWe also assume\nthat, given a rational number, we have a way of extracting (or\nselecting) its numerator and its denominator.\n\nLet us further assume\nthat the constructor and selectors are available as\nfunctions:\n-\n-\nmake_rat($n$, $d$)\n$n$ and whose denominator is the integer\n$d$.\n-\n-\nnumer($x$)\n$x$.\n-\n-\ndenom($x$)\n$x$.\n\nWe are using here a powerful strategy of synthesis:\nwishful thinking.\n\nWe haven t yet said how a rational number\nis represented, or how the\nfunctions\nmake_rat\nshould be implemented.\n\nEven so, if we did have these three\nfunctions,\nwe could then add, subtract, multiply, divide, and test equality by using\nthe following relations:\n\\[\n\\begin{array}{rll}\n\\dfrac{n_{1}}{d_{1}}+\\dfrac{n_{2}}{d_{2}}\n&=&\\dfrac{n_{1}d_{2}+n_{2}d_{1}}{d_{1}d_{2}}\\\\[15pt]\n\\dfrac{n_{1}}{d_{1}}-\\dfrac{n_{2}}{d_{2}}\n&=&\\dfrac{n_{1}d_{2}-n_{2}d_{1}}{d_{1}d_{2}}\\\\[15pt]\n\\dfrac{n_{1}}{d_{1}}\\cdot\\dfrac{n_{2}}{d_{2}}\n&=&\\dfrac{n_{1}n_{2}}{d_{1}d_{2}}\\\\[15pt]\n\\dfrac{n_{1}/d_{1}}{n_{2}/d_{2}}\n&=&\\dfrac{n_{1}d_{2}}{d_{1}n_{2}}\\\\[15pt]\n\\dfrac{n_{1}}{d_{1}}\n&=&\\dfrac{n_{2}}{d_{2}}\\ \\quad \\textrm{if and only if}\\ \\ \\ n_{1}d_{2}\\ =\\ n_{2}d_{1}\n\\end{array}\n\\]\n\nWe can express these rules as functions:\n\n```javascript\nadd_rat\n      make_rat2\n\nfunction add_rat(x, y) {\n    return make_rat(numer(x) * denom(y) + numer(y) * denom(x),\n                    denom(x) * denom(y));\n}\nfunction sub_rat(x, y) {\n    return make_rat(numer(x) * denom(y) - numer(y) * denom(x),\n                    denom(x) * denom(y));\n}\nfunction mul_rat(x, y) {\n    return make_rat(numer(x) * numer(y),\n                    denom(x) * denom(y));\n}\nfunction div_rat(x, y) {\n    return make_rat(numer(x) * denom(y),\n                    denom(x) * numer(y));\n}\nfunction equal_rat(x, y) {\n    return numer(x) * denom(y) === numer(y) * denom(x);\n}\n```\n\nNow we have the operations on rational numbers defined in terms of the\nselector and constructor\nfunctions\nmake_rat.\n\nBut we haven t yet defined these.\n\nWhat we need is some way to glue\ntogether a numerator and a denominator to form a rational number.",
    "token_count": 283,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "Example: Arithmetic Operations for Rational Numbers",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Example_Arithmetic_Operations_for_Rational_Numbers_1"
  },
  {
    "content": "What we need is some way to glue\ntogether a numerator and a denominator to form a rational number.\n\nTo enable us to implement the concrete level of our data abstraction, our\nJavaScript environment\nprovides a compound structure called a\npair , which can be constructed with the\nprimitive function\npair.\n\nThis\nfunction\ntakes two arguments and returns a compound data object that contains the\ntwo arguments as parts.\n\nGiven a pair, we can extract the parts using the\nprimitive\nfunctions\nhead\nand\ntail.\n\nThus, we can use\npair,\nhead,\nand\ntail\nas follows:\n\n```javascript\ncons_1_2\n        cons_1_2_example\n\nconst x = pair(1, 2);\n```\n\n```javascript\ncons_1_2_example\n\t1\n        cons_1_2\n\nhead(x);\n```\n\n```javascript\ncons_1_2_example2\n\t2\n        cons_1_2\n\ntail(x);\n```\n\nNotice that a pair is a data object that can be given a name and\nmanipulated, just like a primitive data object.\n\nMoreover,\npair\ncan be used to form pairs whose elements are pairs, and so on:\n\n```javascript\ncons_1_2_3_4\n        cons_1_2_3_4_example\n\nconst x = pair(1, 2);\n\nconst y = pair(3, 4);\n\nconst z = pair(x, y);\n```\n\n```javascript\ncons_1_2_3_4_example\n\t1\n        cons_1_2_3_4\n\nhead(head(z));\n```\n\n```javascript\ncons_1_2_3_4_example2\n\t3\n        cons_1_2_3_4\n\nhead(tail(z));\n```\n\nIn section we will see how this\nability to combine pairs means that pairs can be used as general-purpose\nbuilding blocks to create all sorts of complex data structures.\n\nThe single\ncompound-data primitive pair , implemented by the\nfunctions\npair,\nhead,\nand\ntail,\nis the only glue we need.\n\nData objects constructed from pairs are called\nlist-structured data.\n\nPairs offer a natural way to complete the make_rat,\n\n```javascript\nmake_rat2\n      2\n      rat_example_1\n\nfunction make_rat(n, d) { return pair(n, d); }\n\nfunction numer(x) { return head(x); }\n\nfunction denom(x) { return tail(x); }\n```\n\n```javascript\nrat_example_1\n\nnumer(make_rat(2, 3));\n```\n\nAlso, in order to display the results of our computations, we can",
    "token_count": 292,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "Example: Arithmetic Operations for Rational Numbers",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Example_Arithmetic_Operations_for_Rational_Numbers_2"
  },
  {
    "content": "Also, in order to display the results of our computations, we can\n\n```javascript\ndenominator.\n\tWe use the primitive function\n\tstringify to turn any value (here\n\ta number) into a string. The operator\n\t+ in JavaScript is\n\toverloaded; it can be applied to two numbers or to two strings,\n\tand in the latter case it returns the result of concatenating\n\tthe two strings.\n```\n\n```javascript\nprint_rat\n      make_rat2\n      print_rat_example_0\n\nfunction print_rat(x) {\n    return display(stringify(numer(x)) + \" / \" + stringify(denom(x)));\n}\n```\n\n```javascript\nprint_rat_example_0\n\nconst one_half = make_rat(1, 2);\n\nprint_rat(one_half);\n```\n\nNow we can try our rational-number functions:\n\n```javascript\nprint_rat_example\n      [ 1, 2 ]\n      make_rat2\n      print_rat\n\nconst one_half = make_rat(1, 2);\n\nprint_rat(one_half);\n\nconst one_half = make_rat(1, 2);\n\none_half;\n```\n\n```javascript\none_half\n\nconst one_half = make_rat(1, 2);\n```\n\n```javascript\none_third\n\nconst one_third = make_rat(1, 3);\n```\n\n```javascript\nprint_rat_example2\n      [ 5, 6 ]\n      add_rat\n      one_half\n      one_third\n      print_rat\n\nprint_rat(add_rat(one_half, one_third));\n\nadd_rat(one_half, one_third);\n```\n\n```javascript\nprint_rat_example3\n      [ 1, 6 ]\n      add_rat\n      one_half\n      one_third\n      print_rat\n\nprint_rat(mul_rat(one_half, one_third));\n\nmul_rat(one_half, one_third);\n```\n\n```javascript\nprint_rat_example4\n      [ 6, 9 ]\n      add_rat\n      one_third\n      print_rat\n\nprint_rat(add_rat(one_third, one_third));\n\nadd_rat(one_third, one_third);\n```\n\nAs the final example shows, our rational-number implementation does not\nmake_rat.\n\nIf we have a\nfunction\nlike the one in section that produces\n\n```javascript\nnumer\n\nfunction numer(x) {\n    return head(x);\n}\nfunction denom(x) {\n    return tail(x);\n}\n```\n\n```javascript\nmake_rat_3\n      [ 2, 3 ]\n      numer\n      make_rat_3_example_1\n      gcd_definition\n\nfunction make_rat(n, d) {\n    const g = gcd(n, d);\n    return pair(n / g, d / g);\n}\n```\n\n```javascript\nmake_rat_3_example_1\n\nmake_rat(4, 6);\n```\n\nNow we have\n\n```javascript\nnumer_rat\n      add_rat_2\n      one_third\n      print_rat\n\nprint_rat(add_rat(one_third, one_third));\n```",
    "token_count": 258,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "Example: Arithmetic Operations for Rational Numbers",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Example_Arithmetic_Operations_for_Rational_Numbers_3"
  },
  {
    "content": "Now we have\n\n```javascript\nadd_rat_2\n      make_rat_3\n\nfunction add_rat(x, y) {\n    return make_rat(numer(x) * denom(y) + numer(y) * denom(x),\n                    denom(x) * denom(y));\n}\nfunction sub_rat(x, y) {\n    return make_rat(numer(x) * denom(y) - numer(y) * denom(x),\n                    denom(x) * denom(y));\n}\nfunction mul_rat(x, y) {\n    return make_rat(numer(x) * numer(y),\n                    denom(x) * denom(y));\n}\nfunction div_rat(x, y) {\n    return make_rat(numer(x) * denom(y),\n                    denom(x) * numer(y));\n}\nfunction equal_rat(x, y) {\n    return numer(x) * denom(y) === numer(y) * denom(x);\n}\n```\n\nas desired.\n\nThis modification was accomplished by changing the constructor\nmake_@rat\nwithout changing any of the\nfunctions\n(such as\nadd_rat\nand\nmul_rat)\nthat implement the actual operations.",
    "token_count": 103,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "Example: Arithmetic Operations for Rational Numbers",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Example_Arithmetic_Operations_for_Rational_Numbers_4"
  },
  {
    "content": "Alyssa P.\n\nHacker is designing a system to help people solve\nengineering problems.\n\nOne feature she wants to provide in her system\nis the ability to manipulate inexact quantities (such as measured\nparameters of physical devices) with known precision, so that when\ncomputations are done with such approximate quantities the results\nwill be numbers of known precision.\n\nElectrical engineers will be using Alyssa s system to compute\nelectrical quantities.\n\nIt is sometimes necessary for them to compute\nthe value of a parallel equivalent resistance\n$R_{p}$ of two resistors\n$R_{1}$ and $R_{2}$\n\\[\n\\begin{array}{lll}\nR_{p} & = & \\dfrac{1}{1/R_{1}+1/R_{2}}\n\\end{array}\n\\]\nResistance values are usually known only up to some\n6.8 ohms with 10% tolerance you can\nonly be sure that the resistor has a resistance between\n$6.8-0.68=6.12$ and\n$6.8+0.68=7.48$ ohms.\n\nThus, if you have a\n6.8-ohm 10% resistor in parallel with a 4.7-ohm\n5% resistor, the resistance of the combination can range from about\n2.58 ohms (if the two resistors are at the lower bounds) to about 2.97 ohms\n(if the two resistors are at the upper bounds).\n\nAlyssa s idea is to implement interval arithmetic as a\nset of arithmetic operations for combining intervals (objects\nthat represent the range of possible values of an inexact quantity).\n\nThe\nresult of adding, subtracting, multiplying, or dividing two intervals is\nitself an interval, representing the range of the result.\n\nAlyssa postulates the existence of an abstract object called an\ninterval that has two endpoints: a lower bound and an upper bound.\n\nShe also presumes that, given the endpoints of an interval, she can\nconstruct the interval using the data constructor\nmake_interval.\n\nAlyssa first writes a\nfunction\nfor adding two intervals.",
    "token_count": 278,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "Extended Exercise: Interval Arithmetic",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Extended_Exercise_Interval_Arithmetic_1"
  },
  {
    "content": "Alyssa first writes a\nfunction\nfor adding two intervals.\n\nShe reasons that the minimum value the sum could\nbe is the sum of the two lower bounds and the maximum value it could be is\nthe sum of the two upper bounds:\n\n```javascript\nadd_interval\n      make_interval\n      print_interval\n      [ 4, 7 ]\n      add_interval_example\n\nfunction add_interval(x, y) {\n    return make_interval(lower_bound(x) + lower_bound(y),\n                         upper_bound(x) + upper_bound(y));\n}\n```\n\nAlyssa also works out the product of two intervals by finding the\nminimum and the maximum of the products of the bounds and using them\nas the bounds of the resulting interval.\n\n(The functions math_min\nand\nmath_max\nare\nprimitives that find the minimum or maximum of any number of arguments.)\n\n```javascript\nmul_interval\n      make_interval\n      print_interval\n      '[ 3 , 10 ]'\n      mul_interval_example\n\nfunction mul_interval(x, y) {\n    const p1 = lower_bound(x) * lower_bound(y);\n    const p2 = lower_bound(x) * upper_bound(y);\n    const p3 = upper_bound(x) * lower_bound(y);\n    const p4 = upper_bound(x) * upper_bound(y);\n    return make_interval(math_min(p1, p2, p3, p4),\n                         math_max(p1, p2, p3, p4));\n}\n```\n\nTo divide two intervals, Alyssa multiplies the first by the reciprocal of\nthe second.\n\nNote that the bounds of the reciprocal interval are\nthe reciprocal of the upper bound and the reciprocal of the lower bound, in\nthat order.\n\n```javascript\ndiv_interval\n      mul_interval\n      print_interval\n      '[ 0.2 , 0.6666666666666666 ]'\n      div_interval_example\n\nfunction div_interval(x, y) {\n    return mul_interval(x, make_interval(1 / upper_bound(y),\n                                         1 / lower_bound(y)));\n}\n```\n\nAfter debugging her program, Alyssa shows it to a potential user, who\ncomplains that her program solves the wrong problem.\n\nHe wants a program\nthat can deal with numbers represented as a center value and an additive\ntolerance; for example, he wants to work with intervals such as\n$3.5\\pm 0.15$ rather than\n$[3.35, 3.65]$.\n\nAlyssa returns to her desk and\nfixes this problem by supplying an alternate constructor and alternate\nselectors:",
    "token_count": 297,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "Extended Exercise: Interval Arithmetic",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Extended_Exercise_Interval_Arithmetic_2"
  },
  {
    "content": "Alyssa returns to her desk and\nfixes this problem by supplying an alternate constructor and alternate\nselectors:\n\n```javascript\nmake_center_width\n      make_interval\n      make_center_width_example\n      0.5\n\nfunction make_center_width(c, w) {\n    return make_interval(c - w, c + w);\n}\nfunction center(i) {\n    return (lower_bound(i) + upper_bound(i)) / 2;\n}\nfunction width(i) {\n    return (upper_bound(i) - lower_bound(i)) / 2;\n}\n```\n\n```javascript\nmake_center_width_example\n      make_interval\n\nconst my_interval = make_center_width(1, 0.5);\nwidth(my_interval);\n```\n\nUnfortunately, most of Alyssa s users are engineers.\n\nReal engineering\nsituations usually involve measurements with only a small uncertainty,\nmeasured as the ratio of the width of the interval to the midpoint of the\ninterval.\n\nEngineers usually specify percentage tolerances on the parameters\nof devices, as in the resistor specifications given earlier.\n\nAfter considerable work, Alyssa P.\n\nHacker delivers her finished\nsystem.\n\nSeveral years later, after she has forgotten all about it, she\ngets a frenzied call from an irate user, Lem E.\n\nTweakit.\n\nIt seems that Lem has\nnoticed that the\n\\[\n\\dfrac{R_{1}R_{2}}{R_{1}+R_{2}}\n\\]\nand\n\\[\n\\dfrac{1}{1/R_{1}+1/R_{2}}\n\\]\nHe has written the following two programs, each of which computes the\nparallel-resistors formula differently:\n\n```javascript\npar\n      add_interval\n      mul_interval\n      div_interval\n      print_interval\n      par_example\n      '[ 2 , 4.363636363636363 ][ 2.5454545454545454 , 3.428571428571429 ]'\n\nfunction par1(r1, r2) {\n    return div_interval(mul_interval(r1, r2),\n                        add_interval(r1, r2));\n}\nfunction par2(r1, r2) {\n    const one = make_interval(1, 1);\n    return div_interval(one,\n                        add_interval(div_interval(one, r1),\n                                     div_interval(one, r2)));\n}\n```\n\n```javascript\npar_example\n\ndisplay(print_interval(par1(pair(4, 6), pair(7, 8))));\n\ndisplay(print_interval(par2(pair(4, 6), pair(7, 8))));\n\nprint_interval(par1(pair(4, 6), pair(7, 8)))\n+\nprint_interval(par2(pair(4, 6), pair(7, 8)));\n```\n\nLem complains that Alyssa s program gives different answers for\nthe two ways of computing.\n\nThis is a serious complaint.",
    "token_count": 262,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "Extended Exercise: Interval Arithmetic",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Extended_Exercise_Interval_Arithmetic_3"
  },
  {
    "content": "We began the rational-number implementation in section by implementing the rational-number operations add_rat, sub_rat, and so on in terms of three unspecified functions: make_rat, numerators,\n\ndenominators, and rational numbers whose behavior was specified by the latter three functions.\n\nBut exactly what is meant by data ?\n\nIt is not enough to say\nwhatever is implemented by the given selectors and\nconstructors.\n\nClearly, not every arbitrary set of three\nfunctions\ncan serve as an appropriate basis for the rational-number\nimplementation.\n\nWe need to guarantee that,\nmake_rat,\nmake_rat(n, d),\nthen\n\n```javascript\n\\[\n\t  \\begin{array}{lll}\n          \\dfrac{\\texttt{numer}(\\texttt{x})}{\\texttt{denom}(\\texttt{x})}\n          &=&\n          \\dfrac{\\texttt{n}}{\\texttt{d}}\n\t  \\end{array}\n          \\]\n```\n\nIn fact, this is the only condition make_rat, functions must fulfill in order to be a valid representation.\n\nThis point of view can serve to define not only\nhigh-level data objects, such as rational numbers, but\nlower-level objects as well.\n\nConsider the notion of a\npair, which we used in order to define our\nrational numbers.\n\nWe never actually said what a pair was, only that\nthe language supplied\nfunctions\npair,\nhead,\nand\ntail\nfor operating on pairs.\n\nBut the only thing we need to know about these\nthree operations\nis that if we glue two objects together using\npair\nwe can retrieve the objects using\nhead\nand\ntail.\npair(x, y)\nthen\nhead(z)\nis\ntail(z)\nis\nfunctions\nare included as primitives in our language.\n\nHowever, any triple of\nfunctions\nthat satisfies the above condition can be used as the basis for\nimplementing pairs.\n\nThis point is illustrated strikingly by the fact\nthat we could implement\npair,\nhead,\nand\ntail\nwithout using any data structures at all but only using\nfunctions.\n\nHere are the definitions:",
    "token_count": 271,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "What Is Meant by Data?",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_What_Is_Meant_by_Data_1"
  },
  {
    "content": "Here are the definitions:\n\n```javascript\ncons_with_dispatch\n      cons_1_2_run\n      1\n\nfunction pair(x, y) {\n    function dispatch(m) {\n        return m === 0\n               ? x\n               : m === 1\n               ? y\n               : error(m, \"argument not 0 or 1 -- pair\");\n    }\n    return dispatch;\n}\nfunction head(z) { return z(0); }\n\nfunction tail(z) { return z(1); }\n```\n\n```javascript\ncons_1_2_run\n\nconst x = pair(1, 2);\nhead(x);\n```\n\nThis use of\nfunctions\ncorresponds to nothing like our intuitive notion of what data should be.\n\nNevertheless, all we need to do to show that this is a valid way to\nrepresent pairs is to verify that these\nfunctions\nsatisfy the condition given above.\n\nThe subtle point to notice is that the value returned by pair(x, y) is a functionnamely the internally defined function head(z) is defined to apply\n\nfunction formed by pair(x, y), then head(pair(x, y)) yields tail(pair(x, y)) applies the function returned by pair(x, y) to 1, which returns functional implementation of\n\npairs is a valid implementation, and if we access pairs using only pair, head, and tail we cannot distinguish this implementation from one that uses\n\nreal data structures.\n\nThe point of exhibiting the functional representation of pairs is not that our language works this way\n\n```javascript\n(an efficient implementation of pairs\n      might use JavaScript's native\n      vector data structure)\n```\n\nbut that it could work this way.\n\nThe\nfunctional\nrepresentation, although obscure, is a perfectly adequate way to represent\npairs, since it fulfills the only conditions that pairs need to fulfill.\n\nThis example also demonstrates that the ability to manipulate\nfunctions\nas objects automatically provides the ability to represent compound data.\n\nThis may seem a curiosity now, but\nfunctional\nrepresentations of data will play a central role in our programming\nrepertoire.",
    "token_count": 286,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "What Is Meant by Data?",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_What_Is_Meant_by_Data_2"
  },
  {
    "content": "This may seem a curiosity now, but\nfunctional\nrepresentations of data will play a central role in our programming\nrepertoire.\n\nThis style of programming is often called\nmessage passing , and we will be using it as a basic tool in\nchapter when we address the issues of modeling and simulation.\n\nDefine\nadd_1).\n\n(Hint: Use substitution to evaluate\nadd_1(zero)).\n\nGive a direct definition of the addition\nfunction plus\n(not in terms of repeated application of\nadd_1).",
    "token_count": 76,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Introduction to Data Abstraction",
    "subsection": "What Is Meant by Data?",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_What_Is_Meant_by_Data_3"
  },
  {
    "content": "We have introduced data abstraction, a methodology for structuring systems\nin such a way that much of a program can be specified independent of the\nchoices involved in implementing the data objects that the program\nmanipulates.\n\nFor example, we saw in\nsection how to separate the task of\ndesigning a program that uses rational numbers from the task of implementing\nrational numbers in terms of the computer language s primitive\nmechanisms for constructing compound data.\n\nThe key idea was to erect an\nin this case, the selectors and constructors for\nrational numbers\n(make_rat,\nthat isolates the way rational\nnumbers are used from their underlying representation in terms of list\nstructure.\n\nA similar abstraction barrier isolates the details of the\nfunctions\nthat perform rational arithmetic\n(add_rat,\nsub_rat,\nmul_rat,\nand\ndiv_rat)\nfrom the higher-level\nfunctions\nthat use rational numbers.\n\nThe resulting program has the structure shown\nin figure.\n\nThese data-abstraction barriers are powerful tools for controlling\ncomplexity.\n\nBy isolating the underlying representations of data\nobjects, we can divide the task of designing a large program into\nsmaller tasks that can be performed separately.\n\nBut this kind of data\nabstraction is not yet powerful enough, because it may not always make\nsense to speak of the underlying representation for a\ndata object.\n\nFor one thing, there might be more than one useful representation for\na data object, and we might like to design systems that can deal with\nmultiple representations.\n\nTo take a simple example, complex numbers\nmay be represented in two almost equivalent ways: in rectangular form\n(real and imaginary parts) and in polar form (magnitude and angle).\n\nSometimes rectangular form is more appropriate and sometimes polar\nform is more appropriate.",
    "token_count": 279,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Multiple_Representations_for_Abstract_Data_1"
  },
  {
    "content": "Sometimes rectangular form is more appropriate and sometimes polar\nform is more appropriate.\n\nIndeed, it is perfectly plausible to\nimagine a system in which complex numbers are represented in both\nways, and in which the\nfunctions\nfor manipulating complex numbers work with either representation.\n\nMore importantly, programming systems are often designed by many\npeople working over extended periods of time, subject to requirements\nthat change over time.\n\nIn such an environment, it is simply not\npossible for everyone to agree in advance on choices of data\nrepresentation.\n\nSo in addition to the data-abstraction barriers that\nisolate representation from use, we need abstraction barriers that\nisolate different design choices from each other and permit different\nchoices to coexist in a single program.\n\nFurthermore, since large\nprograms are often created by combining\npreexisting\nmodules that were\ndesigned in isolation, we need conventions that permit programmers to\nincorporate modules into larger systems\nadditively , that is,\nwithout having to redesign or reimplement these modules.\n\nIn this section, we will learn how to cope with data that may be\nrepresented in different ways by different parts of a program.\n\nThis\nrequires constructing\ngeneric functions functions\nthat can operate on data that may be represented in more than one way.\n\nOur\nmain technique for building generic\nfunctions\nwill be to work in terms of data objects that have\ntype tags , that is, data objects that include explicit information\nabout how they are to be processed.\n\nWe will also discuss\ndata-directed programming, a powerful and convenient\nimplementation strategy for additively assembling systems with generic\noperations.\n\nWe begin with the simple complex-number example.\n\nWe will see how\ntype tags and data-directed style enable us to design separate\nrectangular and polar representations for complex numbers while\nmaintaining the notion of an abstract\ncomplex-number\ndata object.",
    "token_count": 298,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Multiple_Representations_for_Abstract_Data_2"
  },
  {
    "content": "We will see how\ntype tags and data-directed style enable us to design separate\nrectangular and polar representations for complex numbers while\nmaintaining the notion of an abstract\ncomplex-number\ndata object.\n\nWe will accomplish this by defining arithmetic\nfunctions\nfor complex numbers\n(add_complex,\nsub_complex,\nmul_complex,\nand\ndiv_complex)\nin terms of generic selectors that access parts of a complex number\nindependent of how the number is represented.\n\nThe resulting complex-number\nsystem, as shown in\nfigure,\ncontains two different kinds of\nhorizontal abstraction barriers\nplay the same role as the ones in\nfigure.\n\nThey isolate\nhigher-level operations from lower-level\nrepresentations.\n\nIn addition, there is a vertical barrier\nthat gives us the ability to separately design and install alternative\nrepresentations.\n\n```javascript\nData-abstraction barriers in the\n\t    complex-number system.\n```\n\nIn section we will show how to\nuse type tags and data-directed style to develop a generic arithmetic\npackage.\n\nThis provides\nfunctions\n( numbers and\ncan be easily extended when a new kind of number is needed.\n\nIn\nsection , we ll show how to\nuse generic arithmetic in a system that performs symbolic algebra.",
    "token_count": 180,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": null,
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Multiple_Representations_for_Abstract_Data_3"
  },
  {
    "content": "The general strategy of checking the type of a datum and calling an\nappropriate\nfunction\nis called\ndispatching on type.\n\nThis is a powerful strategy for obtaining\nmodularity in system design.\n\nOn the other hand, implementing the dispatch\nas in section has two significant\nweaknesses.\n\nOne weakness is that the generic interface\nfunctions\n(real_part,\nimag_part,\nfunctions\nto check for the new type and apply the appropriate selector for that\nrepresentation.\n\nAnother weakness of the technique is that even though the individual\nrepresentations can be designed separately, we must guarantee that no two\nfunctions\nin the entire system have the same name.\n\nThis is why Ben and Alyssa had\nto change the names of their original\nfunctions\nfrom section.\n\nThe issue underlying both of these weaknesses is that the technique for\nimplementing generic interfaces is not additive.\n\nThe person\nimplementing the generic selector\nfunctions\nmust modify those\nfunctions\neach time a new representation is installed, and the people\ninterfacing the individual representations must modify their\ncode to avoid name conflicts.\n\nIn each of these cases, the changes\nthat must be made to the code are straightforward, but they must be\nmade nonetheless, and this is a source of inconvenience and error.\n\nThis is not much of a problem for the complex-number system as it\nstands, but suppose there were not two but hundreds of different\nrepresentations for complex numbers.\n\nAnd suppose that there were many\ngeneric selectors to be maintained in the abstract-data interface.\n\nSuppose, in fact, that no one programmer knew all the interface\nfunctions\nor all the representations.\n\nThe problem is real and must\nbe addressed in such programs as\nlarge-scale data-base-management systems.\n\nWhat we need is a means for modularizing the system design even\nfurther.\n\nThis is provided by the programming technique known as\ndata-directed programming.",
    "token_count": 298,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Data-Directed Programming and Additivity",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Data-Directed_Programming_and_Additivity_1"
  },
  {
    "content": "This is provided by the programming technique known as\ndata-directed programming.\n\nTo understand how data-directed\nprogramming works, begin with the observation that whenever we deal\nwith a set of generic operations that are common to a set of\ndifferent types we are, in effect, dealing with a two-dimensional\ntable that contains the possible operations on one axis and the\npossible types on the other axis.\n\nThe entries in the table are the\nfunctions\nthat implement each operation for each type of argument presented.\n\nIn the complex-number system developed in the previous section, the\ncorrespondence between operation name, data type, and actual\nfunction\nwas spread out among the various conditional clauses in the generic\ninterface\nfunctions.\n\nBut the same information could have been organized in a table, as shown in\nfigure.\n\nData-directed programming is the technique of designing programs to work\nwith such a\nfunctions\nthat each perform an explicit dispatch on type.\n\nHere we will implement the\ninterface as a single\nfunction\nthat looks up the combination of the operation name and argument type in\nthe table to find the correct\nfunction\nto apply, and then applies it to the contents of the argument.\n\nIf we do\nthis, then to add a new representation package to the system we need not\nchange any existing\n\n```javascript\nfunctions;\n```\n\nwe need only add new entries to the table.\n\nTable of operations for the complex-number system.\n\nTo implement this plan, assume that we have two\nfunctions,\n-\n-\nput(op, type, item)\ninstalls the\nitem\nin the table, indexed by the\n\n```javascript\nop and the\n\t    type.\n```\n\n- - get(op, type) looks up the\n\n```javascript\nop,\n\t    type\n```\n\nentry in the table and returns the item found there.\n\nIf no item is found,",
    "token_count": 289,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Data-Directed Programming and Additivity",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Data-Directed_Programming_and_Additivity_2"
  },
  {
    "content": "If no item is found,\n\n```javascript\na unique primitive value that is referred to by the name\n\t    undefined and recognized\n\t    by the primitive predicate\n\t    is_undefined.\n```\n\nFor now, we can assume that (section ) we will see how to implement these and other operations for manipulating tables.\n\nHere is how data-directed programming can be used in the complex-number\nsystem.\n\nBen, who developed the rectangular representation, implements his\ncode just as he did originally.\n\nHe defines a collection of\nfunctions\nor a\npackage , and interfaces these to the rest of the system by adding\nentries to the table that tell the system how to operate on rectangular\nnumbers.\n\nThis is accomplished by calling the following\nfunction:\n\n```javascript\noperation_table_from_chapter_3\n\n// operation_table, put and get\n// from chapter 3 (section 3.3.3)\n```\n\n```javascript\ninstall_rectangular_package_usage\n\ninstall_rectangular_package();\n```\n\n```javascript\ninstall_rectangular_package\n      operation_table_from_chapter_3\n      operation_table\n      attach_tag\n      square_definition\n      'done'\n      install_rectangular_package_usage\n\nfunction install_rectangular_package() {\n    // internal functions\n    function real_part(z) { return head(z); }\n    function imag_part(z) { return tail(z); }\n    function make_from_real_imag(x, y) { return pair(x, y); }\n    function magnitude(z) {\n        return math_sqrt(square(real_part(z)) + square(imag_part(z)));\n    }\n    function angle(z) {\n        return math_atan2(imag_part(z), real_part(z));\n    }\n    function make_from_mag_ang(r, a) {\n        return pair(r * math_cos(a), r * math_sin(a));\n    }\n\n    // interface to the rest of the system\n    function tag(x) { return attach_tag(\"rectangular\", x); }\n    put(\"real_part\", list(\"rectangular\"), real_part);\n    put(\"imag_part\", list(\"rectangular\"), imag_part);\n    put(\"magnitude\", list(\"rectangular\"), magnitude);\n    put(\"angle\", list(\"rectangular\"), angle);\n    put(\"make_from_real_imag\", \"rectangular\",\n        (x, y) => tag(make_from_real_imag(x, y)));\n    put(\"make_from_mag_ang\", \"rectangular\",\n        (r, a) => tag(make_from_mag_ang(r, a)));\n    return \"done\";\n}\n```\n\nNotice that the internal\nfunctions\nhere are the same\nfunctions\nfrom section that\nBen wrote when he was working in isolation.\n\nNo changes are necessary in\norder to interface them to the rest of the system.\n\nMoreover, since these\nfunction declarations\nare internal to the installation\nfunction,\nBen needn t worry about name conflicts with other\nfunctions\noutside the rectangular package.",
    "token_count": 301,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Data-Directed Programming and Additivity",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Data-Directed_Programming_and_Additivity_3"
  },
  {
    "content": "Moreover, since these\nfunction declarations\nare internal to the installation\nfunction,\nBen needn t worry about name conflicts with other\nfunctions\noutside the rectangular package.\n\nTo interface these to the rest of the\nsystem, Ben installs his\nreal_part\nfunction\nunder the operation name\nreal_part\nand the type\nlist(\"rectangular\"),\nand similarly for the other selectors. s internally defined\nconstructors, except that they attach the tag.\n\nAlyssa s\n\n```javascript\ninstall_polar_package\n      operation_table_from_chapter_3\n      operation_table\n      attach_tag\n      square_definition\n      install_polar_package_usage\n      'done'\n\nfunction install_polar_package() {\n    // internal functions\n    function magnitude(z) { return head(z); }\n    function angle(z) { return tail(z); }\n    function make_from_mag_ang(r, a) { return pair(r, a); }\n    function real_part(z) {\n        return magnitude(z) * math_cos(angle(z));\n    }\n    function imag_part(z) {\n        return magnitude(z) * math_sin(angle(z));\n    }\n    function make_from_real_imag(x, y) {\n        return pair(math_sqrt(square(x) + square(y)),\n                    math_atan2(y, x));\n    }\n\n    // interface to the rest of the system\n    function tag(x) { return attach_tag(\"polar\", x); }\n    put(\"real_part\", list(\"polar\"), real_part);\n    put(\"imag_part\", list(\"polar\"), imag_part);\n    put(\"magnitude\", list(\"polar\"), magnitude);\n    put(\"angle\", list(\"polar\"), angle);\n    put(\"make_from_real_imag\", \"polar\",\n        (x, y) => tag(make_from_real_imag(x, y)));\n    put(\"make_from_mag_ang\", \"polar\",\n        (r, a) => tag(make_from_mag_ang(r, a)));\n    return \"done\";\n}\n```\n\n```javascript\ninstall_polar_package_usage\n      install_polar_package\n\ninstall_polar_package();\n```\n\nEven though Ben and Alyssa both still use their original functions defined with the same names as each other s (e.g., real_part), these declarations are\n\nnow internal to different functions (see section ), so there is no name conflict.\n\nThe complex-arithmetic selectors access the table by means of a general operation function called apply_generic, which applies a generic operation to some arguments.\n\n```javascript\nThe function\n\tapply_generic\n```\n\nlooks in the table under the name of the operation and the types of the arguments and applies the resulting function if one is present:",
    "token_count": 269,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Data-Directed Programming and Additivity",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Data-Directed_Programming_and_Additivity_4"
  },
  {
    "content": "looks in the table under the name of the operation and the types of the arguments and applies the resulting function if one is present:\n\n```javascript\napply_definition\n\n// In Source, most functions have a fixed number of arguments.\n// (The function list is the only exception, to this so far.)\n// The function apply_in_underlying_javascript allows us to\n// apply any given function fun to all elements of the argument\n// list args, as if they were separate arguments\nfunction apply(fun, args) {\n    return apply_in_underlying_javascript(fun, args);\n}\n```\n\n```javascript\napply_generic\n      apply_definition\n\nfunction apply_generic(op, args) {\n    const type_tags = map(type_tag, args);\n    const fun = get(op, type_tags);\n    return ! is_undefined(fun)\n           ? apply_in_underlying_javascript(fun, map(contents, args))\n           : error(list(op, type_tags),\n                   \"no method for these types -- apply_generic\");\n}\n```\n\nUsing apply_generic, we can define our generic selectors as follows:\n\n```javascript\ngeneric_selectors\n      apply_generic\n      generic_selectors_example\n      9\n\nfunction real_part(z) { return apply_generic(\"real_part\", list(z)); }\n\nfunction imag_part(z) { return apply_generic(\"imag_part\", list(z)); }\n\nfunction magnitude(z) { return apply_generic(\"magnitude\", list(z)); }\n\nfunction angle(z)     { return apply_generic(\"angle\", list(z));     }\n```\n\n```javascript\ngeneric_selectors_example\n      install_rectangular_package\n      install_rectangular_package_usage\n      install_polar_package\n      complex_number_calculation\n      generic_constructors\n\nconst my_complex_number =\n    make_from_real_imag(1.0, 4.5);\n\nconst result =\n    add_complex(my_complex_number,\n                my_complex_number);\n\nimag_part(result);\n```\n\nObserve that these do not change at all if a new representation is added to the system.\n\nWe can also extract from the table the constructors to be used by the\nprograms external to the packages in making complex numbers from real and\nimaginary parts and from magnitudes and angles.\n\nAs in\nsection , we construct rectangular\nnumbers whenever we have real and imaginary parts, and polar numbers\nwhenever we have magnitudes and angles:\n\n```javascript\ngeneric_constructors\n      generic_selectors\n      generic_selectors_example\n      9\n\nfunction make_from_real_imag(x, y) {\n   return get(\"make_from_real_imag\", \"rectangular\")(x, y);\n}\nfunction make_from_mag_ang(r, a) {\n   return get(\"make_from_mag_ang\", \"polar\")(r, a);\n}\n```\n\nThe key idea of data-directed programming is to handle generic operations\nin programs by dealing explicitly with operation-and-type tables, such as\nthe table in\nfigure.",
    "token_count": 309,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Data-Directed Programming and Additivity",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Data_Data-Directed_Programming_and_Additivity_5"
  },
  {
    "content": "The key idea of data-directed programming is to handle generic operations\nin programs by dealing explicitly with operation-and-type tables, such as\nthe table in\nfigure.\n\nThe style of programming we used in\nsection organized the required\ndispatching on type by having each operation take care of its own\ndispatching.\n\nIn effect, this decomposes the operation-and-type table into\nrows, with each generic operation\nfunction\nrepresenting a row of the table.\n\nAn alternative implementation strategy is to decompose the table into\ncolumns and, instead of using intelligent operations that\ndispatch on data types, to work with intelligent data\nobjects that dispatch on operation names.\n\nWe can do this by\narranging things so that a data object, such as a rectangular number, is\nrepresented as a\nfunction\nthat takes as input the required operation name and performs the operation\nindicated.\n\nIn such a discipline,\nmake_from_real_imag\ncould be written as",
    "token_count": 146,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Data-Directed Programming and Additivity",
    "chunk_index": 6,
    "chunk_id": "Building_Abstractions_with_Data_Data-Directed_Programming_and_Additivity_6"
  },
  {
    "content": "In such a discipline,\nmake_from_real_imag\ncould be written as\n\n```javascript\nmake_from_real_imag_message_passing\n      square_definition\n      message_passing_example\n      9\n\nfunction make_from_real_imag(x, y) {\n    function dispatch(op) {\n        return op === \"real_part\"\n               ? x\n               : op === \"imag_part\"\n               ? y\n               : op === \"magnitude\"\n               ? math_sqrt(square(x) + square(y))\n               : op === \"angle\"\n               ? math_atan2(y, x)\n               : error(op, \"unknown op -- make_from_real_imag\");\n    }\n    return dispatch;\n}\n\nfunction make_from_real_imag(x, y) {\n    function dispatch(op) {\n        return op === \"real_part\"\n               ? x\n               : op === \"imag_part\"\n               ? y\n               : op === \"magnitude\"\n               ? math_sqrt(square(x) + square(y))\n               : op === \"angle\"\n               ? math_atan2(y, x)\n               : error(op, \"unknown op -- make_from_real_imag\");\n    }\n    return dispatch;\n}\n\nfunction make_from_mag_ang(r, a) {\n    function dispatch(op) {\n        return op === \"real_part\"\n               ? r * math_cos(a)\n               : op === \"imag_part\"\n               ? r * math_sin(a)\n               : op === \"magnitude\"\n               ? r\n               : op === \"angle\"\n               ? a\n               : error(op, \"unknown op -- make_from_real_imag\");\n    }\n    return dispatch;\n}\n\nfunction apply_generic(op, arg) {\n    return head(arg)(op);\n}\nfunction real_part(z) {\n   return apply_generic(\"real_part\", list(z));\n}\nfunction imag_part(z) {\n   return apply_generic(\"imag_part\", list(z));\n}\nfunction magnitude(z) {\n   return apply_generic(\"magnitude\", list(z));\n}\nfunction angle(z) {\n   return apply_generic(\"angle\", list(z));\n}\nfunction add_complex(z1, z2) {\n    return make_from_real_imag(\n               real_part(z1) + real_part(z2),\n               imag_part(z1) + imag_part(z2));\n}\nfunction sub_complex(z1, z2) {\n    return make_from_real_imag(\n               real_part(z1) - real_part(z2),\n               imag_part(z1) - imag_part(z2));\n}\nfunction mul_complex(z1, z2) {\n    return make_from_mag_ang(\n               magnitude(z1) * magnitude(z2),\n               angle(z1) + angle(z2));\n}\nfunction div_complex(z1, z2) {\n    return make_from_mag_ang(\n               magnitude(z1) / magnitude(z2),\n               angle(z1) - angle(z2));\n}\n// operation_table, put and get\n// from chapter 3 (section 3.3.3)\nfunction assoc(key, records) {\n    return is_null(records)\n           ? undefined\n           : equal(key, head(head(records)))\n           ? head(records)\n           : assoc(key, tail(records));\n}\nfunction make_table() {\n    const local_table = list(\"*table*\");\n    function lookup(key_1, key_2) {\n        const subtable = assoc(key_1, tail(local_table));\n        if (is_undefined(subtable)) {\n            return undefined;\n        } else {\n            const record = assoc(key_2, tail(subtable));\n            return is_undefined(record)\n                   ? undefined\n                   : tail(record);\n        }\n    }\n    function insert(key_1, key_2, value) {\n        const subtable = assoc(key_1, tail(local_table));\n        if (is_undefined(subtable)) {\n            set_tail(local_table,\n                     pair(list(key_1, pair(key_2, value)),\n                          tail(local_table)));\n        } else {\n            const record = assoc(key_2, tail(subtable));\n            if (is_undefined(record)) {\n      \t        set_tail(subtable,\n\t                       pair(pair(key_2, value),\n                              tail(subtable)));\n\t    } else {\n                set_tail(record, value);\n            }\n        }\n    }\n    function dispatch(m) {\n        return m === \"lookup\"\n               ? lookup\n               : m === \"insert\"\n               ? insert\n               : \"undefined operation -- table\";\n    }\n    return dispatch;\n}\nconst operation_table = make_table();\nconst get = operation_table(\"lookup\");\nconst put = operation_table(\"insert\");\nfunction attach_tag(type_tag, contents) {\n    return pair(type_tag, contents);\n}\nfunction type_tag(datum) {\n    return is_pair(datum)\n           ? head(datum)\n           : error(datum, \"bad tagged datum -- type_tag\");\n}\nfunction contents(datum) {\n    return is_pair(datum)\n           ? tail(datum)\n           : error(datum, \"bad tagged datum -- contents\");\n}\nfunction install_rectangular_package() {\n    function real_part(z) { return head(z); }\n    function imag_part(z) { return tail(z); }\n    function make_from_real_imag(x, y) { return pair(x, y); }\n    function magnitude(z) {\n        return math_sqrt(square(real_part(z)) +\n                   square(imag_part(z)));\n    }\n    function angle(z) {\n        return math_atan2(imag_part(z), real_part(z));\n    }\n    function make_from_mag_ang(r, a) {\n        return pair(r * math_cos(a), r * math_sin(a));\n    }\n    // interface to the rest of the system\n    function tag(x) {\n        return attach_tag(\"rectangular\", x);\n    }\n    put(\"real_part\", list(\"rectangular\"), real_part);\n    put(\"imag_part\", list(\"rectangular\"), imag_part);\n    put(\"magnitude\", list(\"rectangular\"), magnitude);\n    put(\"angle\", list(\"rectangular\"), angle);\n    put(\"make_from_real_imag\", \"rectangular\",\n        (x, y) => tag(make_from_real_imag(x, y)));\n    put(\"make_from_mag_ang\", \"rectangular\",\n        (r, a) => tag(make_from_mag_ang(r, a)));\n    return \"done\";\n}\n\ninstall_rectangular_package();\nfunction install_polar_package() {\n    // internal functions\n    function magnitude(z) { return head(z); }\n    function angle(z) { return tail(z); }\n    function make_from_mag_ang(r, a) { return pair(r, a); }\n    function real_part(z) {\n       return magnitude(z) * math_cos(angle(z));\n    }\n    function imag_part(z) {\n       return magnitude(z) * math_sin(angle(z));\n    }\n    function make_from_real_imag(x, y) {\n       return pair(math_sqrt(square(x) + square(y)),\n                   math_atan2(y, x));\n    }\n\n    // interface to the rest of the system\n    function tag(x) { return attach_tag(\"polar\", x); }\n    put(\"real_part\", list(\"polar\"), real_part);\n    put(\"imag_part\", list(\"polar\"), imag_part);\n    put(\"magnitude\", list(\"polar\"), magnitude);\n    put(\"angle\", list(\"polar\"), angle);\n    put(\"make_from_real_imag\", \"polar\",\n        (x, y) => tag(make_from_real_imag(x, y)));\n    put(\"make_from_mag_ang\", \"polar\",\n        (r, a) => tag(make_from_mag_ang(r, a)));\n    return \"done\";\n}\n\ninstall_polar_package();\n```",
    "token_count": 608,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Data-Directed Programming and Additivity",
    "chunk_index": 7,
    "chunk_id": "Building_Abstractions_with_Data_Data-Directed_Programming_and_Additivity_7"
  },
  {
    "content": "In such a discipline,\nmake_from_real_imag\ncould be written as\n\nThe corresponding apply_generic function, which applies a generic operation to an argument, now simply feeds the operation s name to the data object and lets\n\nthe object do the work:\n\n```javascript\napply_generic_message_passing\n      make_from_real_imag_message_passing\n      message_passing_example\n\nfunction apply_generic(op, arg) { return head(arg)(op); }\n```\n\n```javascript\nmessage_passing_example\n\nconst my_complex_number =\n    make_from_real_imag(1.0, 4.5);\n\nconst result =\n    add_complex(my_complex_number,\n                my_complex_number);\n\nimag_part(result);\n```\n\n```javascript\ngeneric_selectors_message_passing\n      apply_generic_message_passing\n      generic_selectors_example\n\nfunction real_part(z) {\n   return apply_generic(\"real_part\", list(z));\n}\nfunction imag_part(z) {\n   return apply_generic(\"imag_part\", list(z));\n}\nfunction magnitude(z) {\n   return apply_generic(\"magnitude\", list(z));\n}\nfunction angle(z) {\n   return apply_generic(\"angle\", list(z));\n}\n```\n\nNote that the value returned by\nmake_from_real_imag\nis a\nfunctionthe internal\nfunction.\n\nThis is the\nfunction\nthat is invoked when\napply_generic\nrequests an operation to be performed.\n\nThis style of programming is called message passing.\n\nThe name\ncomes from the image that a data object is an entity that receives the\nrequested operation name as a message.\n\nWe have already seen\nan example of message passing in section ,\nwhere we saw how\npair,\nhead,\nand\ntail\ncould be defined with no data objects but only\nfunctions.\n\nHere we see that message passing is not a mathematical trick but a useful\ntechnique for organizing systems with generic operations.\n\nIn the remainder\nof this chapter we will continue to use data-directed programming, rather\nthan message passing, to discuss generic arithmetic operations.\n\nIn\nchapter we will return to message passing, and we will see that\nit can be a powerful tool for structuring simulation programs.",
    "token_count": 251,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Data-Directed Programming and Additivity",
    "chunk_index": 8,
    "chunk_id": "Building_Abstractions_with_Data_Data-Directed_Programming_and_Additivity_8"
  },
  {
    "content": "We will develop a system that performs arithmetic operations on complex\nnumbers as a simple but unrealistic example of a program that uses generic\noperations.\n\nWe begin by discussing two plausible representations for\ncomplex numbers as ordered pairs: rectangular form (real part and imaginary\npart) and polar form (magnitude and angle).\nwill show how both representations can be made to coexist in a single\nsystem through the use of type tags and generic operations.\n\nLike rational numbers, complex numbers are naturally represented as ordered\npairs.\n\nThe set of complex numbers can be thought of as a two-dimensional\nspace with two orthogonal axes, the real axis and the\nimaginary axis.\n\n(See\nfigure.) From this point of view,\nthe complex number $z=x+iy$ (where\n$i^{2} =-1$ ) can be thought of as the point in\nthe plane whose real coordinate is $x$ and whose\nimaginary coordinate is $y$.\n\nAddition of complex\nnumbers reduces in this representation to addition of coordinates:\n\\[\n\\begin{array}{lll}\n\\mbox{Real-part}(z_{1}+z_{2}) & = &\n\\mbox{Real-part}(z_{1})+\\mbox{Real-part}(z_{2}) \\\\[1ex]\n\\mbox{Imaginary-part}(z_{1} +z_{2}) & = &\n\\mbox{Imaginary-part}(z_1)+\\mbox{Imaginary-part}(z_2)\n\\end{array}\n\\]\n\nWhen multiplying complex numbers, it is more natural to think in terms\nof representing a complex number in polar form, as a magnitude and an\nangle ( $r$ and $A$\nin figure ).\n\nThe product of two\ncomplex numbers is the vector obtained by stretching one complex number by\n\\[\n\\begin{array}{lll}\n\\mbox{Magnitude}(z_{1}\\cdot z_{2}) & = &\n\\mbox{Magnitude}(z_{1})\\cdot\\mbox{Magnitude}(z_{2})\\\\[1ex]\n\\mbox{Angle}(z_{1}\\cdot z_{2}) & = &\n\\mbox{Angle}(z_{1})+\\mbox{Angle}(z_{2})\n\\end{array}\n\\]\n\nThus, there are two different representations for complex numbers,\nwhich are appropriate for different operations.\n\nYet, from the\nviewpoint of someone writing a program that uses complex numbers, the\nprinciple of data abstraction suggests that all the operations for\nmanipulating complex numbers should be available regardless of which\nrepresentation is used by the computer.",
    "token_count": 292,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Representations for Complex Numbers",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Representations_for_Complex_Numbers_1"
  },
  {
    "content": "Yet, from the\nviewpoint of someone writing a program that uses complex numbers, the\nprinciple of data abstraction suggests that all the operations for\nmanipulating complex numbers should be available regardless of which\nrepresentation is used by the computer.\n\nFor example, it is often\nuseful to be able to find the magnitude of a complex number that is\nspecified by rectangular coordinates.\n\nSimilarly, it is often useful\nto be able to determine the real part of a complex number that is\nspecified by polar coordinates.\n\nComplex numbers as points in the plane.\n\nTo design such a system, we can follow the same.\n\nAssume that the\noperations on complex numbers are implemented in terms of four selectors:\nreal_part,\nimag_part,\nmagnitude,\nand\nfunctions\nfor constructing complex numbers:\nmake_from_real_imag\nreturns a complex number with specified real and imaginary parts, and\nmake_from_mag_ang\nreturns a complex number with specified magnitude and angle.\n\nThese\nfunctions\nhave the property that, for any complex number\n\n```javascript\nmake_from_real_imag(real_part(z), imag_part(z));\n```\n\nand\n\n```javascript\nmake_from_mag_ang(magnitude(z), angle(z));\n```\n\nproduce complex numbers that are equal to\n\nUsing these constructors and selectors, we can implement arithmetic on\ncomplex numbers using the abstract data specified by the\nconstructors and selectors, just as we did for rational numbers in\nsection.\n\nAs shown in the formulas\nabove, we can add and subtract complex numbers in terms of real and\nimaginary parts while multiplying and dividing complex numbers in terms of\nmagnitudes and angles:\n\n```javascript\ncomplex_number_calculation\n\nfunction add_complex(z1, z2) {\n    return make_from_real_imag(real_part(z1) + real_part(z2),\n                               imag_part(z1) + imag_part(z2));\n}\nfunction sub_complex(z1, z2) {\n    return make_from_real_imag(real_part(z1) - real_part(z2),\n                               imag_part(z1) - imag_part(z2));\n}\nfunction mul_complex(z1, z2) {\n    return make_from_mag_ang(magnitude(z1) * magnitude(z2),\n                             angle(z1) + angle(z2));\n}\nfunction div_complex(z1, z2) {\n    return make_from_mag_ang(magnitude(z1) / magnitude(z2),\n                             angle(z1) - angle(z2));\n}\n```",
    "token_count": 287,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Representations for Complex Numbers",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Representations_for_Complex_Numbers_2"
  },
  {
    "content": "As shown in the formulas\nabove, we can add and subtract complex numbers in terms of real and\nimaginary parts while multiplying and dividing complex numbers in terms of\nmagnitudes and angles:\n\nTo complete the complex-number package, we must choose a representation and\nwe must implement the constructors and selectors in terms of primitive\nnumbers and primitive list structure.\n\nThere are two obvious ways to do\nthis: We can represent a complex number in rectangular form\nas a pair (real part, imaginary part) or in polar form as a\npair (magnitude, angle).\n\nWhich shall we choose?\n\nIn order to make the different choices concrete, imagine that there are two\nprogrammers, Ben Bitdiddle and Alyssa P.\n\nHacker, who are independently\ndesigning representations for the complex-number system.\n\nBen chooses to represent\n\\[\n\\begin{array}{lllllll}\nx & = & r\\ \\cos A & \\quad \\quad \\quad & r & = & \\sqrt{x^2 +y^2} \\\\\ny & = & r\\ \\sin A & & A &= & \\arctan (y,x)\n\\end{array}\n\\]\nwhich relate the real and imaginary parts ( $x$ ,\n$y$ ) to the magnitude and the angle\n$(r, A)$. s representation is therefore given by the following selectors\nand constructors:\n\n```javascript\nmake_complex_number1\n      complex_number_calculation\n      square_definition\n      make_complex_number_example\n      -3\n\nfunction real_part(z) { return head(z); }\n\nfunction imag_part(z) { return tail(z); }\n\nfunction magnitude(z) {\n    return math_sqrt(square(real_part(z)) + square(imag_part(z)));\n}\nfunction angle(z) {\n    return math_atan2(imag_part(z), real_part(z));\n}\nfunction make_from_real_imag(x, y) { return pair(x, y); }\n\nfunction make_from_mag_ang(r, a) {\n    return pair(r * math_cos(a), r * math_sin(a));\n}\n```\n\n```javascript\nmake_complex_number_example\n\nconst my_co_num_1 = make_from_real_imag(2.5, -0.5);\nconst my_co_num_2 = make_from_real_imag(2.5, -0.5);\n\nconst result = add_complex(my_co_num_1,\n                           mul_complex(my_co_num_2,\n                                       my_co_num_2));\n\nimag_part(result);\n```\n\nAlyssa, in contrast, chooses to represent complex numbers in For her, selecting the magnitude and angle is straightforward, but she has to use the s\n\nrepresentation is:",
    "token_count": 298,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Representations for Complex Numbers",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Representations_for_Complex_Numbers_3"
  },
  {
    "content": "representation is:\n\n```javascript\nmake_complex_number2\n      complex_number_calculation\n      square_definition\n      make_complex_number_example\n      -3\n\nfunction real_part(z) {\n    return magnitude(z) * math_cos(angle(z));\n}\nfunction imag_part(z) {\n    return magnitude(z) * math_sin(angle(z));\n}\nfunction magnitude(z) { return head(z); }\n\nfunction angle(z) { return tail(z); }\n\nfunction make_from_real_imag(x, y) {\n    return pair(math_sqrt(square(x) + square(y)),\n                math_atan2(y, x));\n}\nfunction make_from_mag_ang(r, a) { return pair(r, a); }\n```\n\nThe discipline of data abstraction ensures that the same implementation of add_@complex, sub_complex, mul_complex, and div_complex will work with either Ben s representation or Alyssa\n\ns representation.",
    "token_count": 83,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Representations for Complex Numbers",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Representations_for_Complex_Numbers_4"
  },
  {
    "content": "One way to view data abstraction is as an application of the\nprinciple of least commitment.\n\nIn implementing the\ncomplex-number system in\nsection , we can\nuse either Ben s rectangular representation or Alyssa s polar\nrepresentation.\n\nThe abstraction barrier formed by the selectors and\nconstructors permits us to defer to the last possible moment the choice of\na concrete representation for our data objects and thus retain maximum\nflexibility in our system design.\n\nThe principle of least commitment can be carried to even further extremes.\n\nIf we desire, we can maintain the ambiguity of representation even\nafter we have designed the selectors and constructors, and elect\nto use both Ben s representation and Alyssa s\nrepresentation.\n\nIf both representations are included in a single system,\nhowever, we will need some way to distinguish data in polar form from data\nin rectangular form.\n\nOtherwise, if we were asked, for instance, to find\nthe $(3,4)$ , we wouldn t know whether to\nanswer 5 (interpreting the number in rectangular form) or\n3 (interpreting the number in polar form).\n\nA straightforward way to\naccomplish this distinction is to include a\ntype tag the\nstring \"rectangular\"\nor\n\"polar\"as\npart of each complex number.\n\nThen when we need to manipulate a complex\nnumber we can use the tag to decide which selector to apply.\n\nIn order to manipulate tagged data, we will assume that we have\nfunctions\ntype_tag\nand\nfunction\nattach_tag\nthat takes a tag and contents and produces a tagged data object.\n\nA\nstraightforward way to implement this is to use ordinary list structure:",
    "token_count": 261,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Tagged data",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Tagged_data_1"
  },
  {
    "content": "A\nstraightforward way to implement this is to use ordinary list structure:\n\n```javascript\nattach_tag\n      attach_tag_example\n      'frequency_list'\n\nfunction attach_tag(type_tag, contents) {\n    return pair(type_tag, contents);\n}\nfunction type_tag(datum) {\n    return is_pair(datum)\n           ? head(datum)\n           : error(datum, \"bad tagged datum -- type_tag\");\n}\nfunction contents(datum) {\n    return is_pair(datum)\n           ? tail(datum)\n           : error(datum, \"bad tagged datum -- contents\");\n}\n```\n\n```javascript\nattach_tag_example\n\nconst f_1 = list(\"A\", 4);\nconst my_frequency_1 =\n    attach_tag(\"frequency_list\", f_1);\n\ntype_tag(my_frequency_1);\n```\n\n```javascript\nUsing\n\ttype_tag,\n```\n\nwe can define predicates is_rectangular and is_polar, which recognize rectangular and polar numbers, respectively:\n\n```javascript\nrectangular_or_polar\n      rectangular_or_polar_example\n      attach_tag\n\nfunction is_rectangular(z) {\n    return type_tag(z) === \"rectangular\";\n}\nfunction is_polar(z) {\n    return type_tag(z) === \"polar\";\n}\n```\n\nWith type tags, Ben and Alyssa can now modify their code so that their two\ndifferent representations can coexist in the same system.\n\nWhenever Ben\nconstructs a complex number, he tags it as rectangular.\n\nWhenever Alyssa\nconstructs a complex number, she tags it as polar.\n\nIn addition, Ben and\nAlyssa must make sure that the names of their\nfunctions\ndo not conflict.\n\nOne way to do this is for Ben to append the suffix\nfunctions\nand for Alyssa to append s revised rectangular representation from\nsection :\n\n```javascript\nmake_complex_number_rectangular\n      attach_tag\n      square_definition\n      make_complex_number_rectangular_example\n      1.932653061713073\n\nfunction real_part_rectangular(z) { return head(z); }\n\nfunction imag_part_rectangular(z) { return tail(z); }\n\nfunction magnitude_rectangular(z) {\n    return math_sqrt(square(real_part_rectangular(z)) +\n                     square(imag_part_rectangular(z)));\n}\nfunction angle_rectangular(z) {\n    return math_atan2(imag_part_rectangular(z),\n                     real_part_rectangular(z));\n}\nfunction make_from_real_imag_rectangular(x, y) {\n    return attach_tag(\"rectangular\", pair(x, y));\n}\nfunction make_from_mag_ang_rectangular(r, a) {\n    return attach_tag(\"rectangular\",\n                      pair(r * math_cos(a), r * math_sin(a)));\n}\n```\n\n```javascript\nmake_complex_number_rectangular_example\n\nconst bens_co_num = make_from_mag_ang_rectangular(\n                        3.0, 0.7);\n\nimag_part_rectangular(contents(bens_co_num));\n```\n\nand here is Alyssa s revised polar representation:",
    "token_count": 269,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Tagged data",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Tagged_data_2"
  },
  {
    "content": "and here is Alyssa s revised polar representation:\n\n```javascript\nmake_complex_number_polar\n      attach_tag\n      square_definition\n      make_complex_number_polar_example\n      1.932653061713073\n\nfunction real_part_polar(z) {\n    return magnitude_polar(z) * math_cos(angle_polar(z));\n}\nfunction imag_part_polar(z) {\n    return magnitude_polar(z) * math_sin(angle_polar(z));\n}\nfunction magnitude_polar(z) { return head(z); }\n\nfunction angle_polar(z) { return tail(z); }\n\nfunction make_from_real_imag_polar(x, y) {\n    return attach_tag(\"polar\",\n                      pair(math_sqrt(square(x) + square(y)),\n                           math_atan2(y, x)));\n}\n\nfunction make_from_mag_ang_polar(r, a) {\n    return attach_tag(\"polar\", pair(r, a));\n}\n```\n\n```javascript\nmake_complex_number_polar_example\n\nconst alyssas_co_num = make_from_mag_ang_polar(\n                           3.0, 0.7);\n\nimag_part_polar(contents(alyssas_co_num));\n```\n\nfunction\nthat checks the tag of its argument and calls the appropriate\nfunction\nfor handling data of that type.\n\nFor example, to obtain the real part of\na complex number,\nreal_part\nexamines the tag to determine whether to use Ben s\nreal_part_rectangular\nor Alyssa s\nreal_@part_@polar.\n\nIn either case, we use\nfunction\nas required:\n\n```javascript\nmake_complex_number\n      rectangular_or_polar\n      make_complex_number_rectangular\n      make_complex_number_polar\n      make_complex_number_example_2\n      1.932653061713073\n\nfunction real_part(z) {\n    return is_rectangular(z)\n           ? real_part_rectangular(contents(z))\n           : is_polar(z)\n           ? real_part_polar(contents(z))\n           : error(z, \"unknown type -- real_part\");\n}\nfunction imag_part(z) {\n    return is_rectangular(z)\n           ? imag_part_rectangular(contents(z))\n           : is_polar(z)\n           ? imag_part_polar(contents(z))\n           : error(z, \"unknown type -- imag_part\");\n}\nfunction magnitude(z) {\n    return is_rectangular(z)\n           ? magnitude_rectangular(contents(z))\n           : is_polar(z)\n           ? magnitude_polar(contents(z))\n           : error(z, \"unknown type -- magnitude\");\n}\nfunction angle(z) {\n    return is_rectangular(z)\n           ? angle_rectangular(contents(z))\n           : is_polar(z)\n           ? angle_polar(contents(z))\n           : error(z, \"unknown type -- angle\");\n}\n```\n\n```javascript\nmake_complex_number_example_2\n\nconst alyssas_co_num = make_from_mag_ang_polar(\n                           3.0, 0.7);\n\nimag_part(alyssas_co_num);\n```\n\nTo implement the complex-number arithmetic operations, we can use the same\nfunctions\nadd_complex,\nsub_complex,\nmul_complex,\nand\ndiv_complex\nfrom section ,\nbecause the selectors they call are generic, and so will work with either\nrepresentation.\n\nFor example, the\nfunction\nadd_complex\nis still\n\n```javascript\nfunction add_complex(z1, z2) {\n   return make_from_real_imag(real_part(z1) + real_part(z2),\n                              imag_part(z1) + imag_part(z2));\n}\n```\n\nFinally, we must choose whether to construct complex numbers using\nBen s representation or Alyssa s representation.",
    "token_count": 290,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Tagged data",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Tagged_data_3"
  },
  {
    "content": "Finally, we must choose whether to construct complex numbers using\nBen s representation or Alyssa s representation.\n\nOne\nreasonable choice is to construct rectangular numbers whenever we have\nreal and imaginary parts and to construct polar numbers whenever we have\nmagnitudes and angles:\n\n```javascript\nmake_complex_number_generic\n      make_complex_number\n      make_complex_number_rectangular\n      make_complex_number_polar\n      make_complex_number_generic_example\n      1.932653061713073\n\nfunction make_from_real_imag(x, y) {\n    return make_from_real_imag_rectangular(x, y);\n}\nfunction make_from_mag_ang(r, a) {\n    return make_from_mag_ang_polar(r, a);\n}\n```\n\n```javascript\nmake_complex_number_generic_example\n\nconst alyssas_co_num = make_from_mag_ang(\n                           3.0, 0.7);\n\nimag_part(alyssas_co_num);\n```\n\nStructure\n$\\!$ The resulting complex-number system has the structure shown in\nfigure.\n\nThe system has been decomposed into three relatively independent parts: the\ncomplex-number-arithmetic operations, Alyssa s polar implementation,\nand Ben s rectangular implementation.\n\nThe polar and rectangular\nimplementations could have been written by Ben and Alyssa working\nseparately, and both of these can be used as underlying representations by\na third programmer implementing the complex-arithmetic\nfunctions\nin terms of the abstract constructor/selector interface.\n\nSince each data object is tagged with its type, the selectors operate on\nthe data in a\ns polar\npackage) a complex number is an untyped pair (magnitude, angle).\n\nWhen a\ngeneric selector operates on a number of s\ncode.\n\nConversely, when Alyssa constructs a number for general use, she\ntags it with a type so that it can be appropriately recognized by the\nhigher-level\nfunctions.\n\nThis discipline of stripping off and attaching tags as data objects are\npassed from level to level can be an important organizational strategy,\nas we shall see in section.",
    "token_count": 246,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Multiple Representations for Abstract Data",
    "subsection": "Tagged data",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Tagged_data_4"
  },
  {
    "content": "This section provides practice in the use of list structure and data\nabstraction to manipulate sets and trees.\n\nThe application is to\nmethods for representing data as sequences of ones and zeros (bits).\n\nFor example, the\n$2^7$ , or\n128, possible different characters.\n\nIn general, if we want to distinguish\n$n$ different symbols, we will need to use\n$\\log_2 n$ bits per symbol.\n\nIf all our messages\nare made up of the eight symbols A, B, C, D, E, F, G, and H, we can choose\na code with three bits per character, for example\nA\n000\nC\n010\nE\n100\nG\n110\nB\n001\nD\n011\nF\n101\nH\n111\nWith this code, the message\nBACADAEAFABBAAAGAH\nis encoded as the string of 54 bits\n001000010000011000100000101000001001000000000110000111\n\nCodes such as ASCII and the A-through-H code above are known as\nfixed-length codes, because they represent each symbol in the\nmessage with the same number of bits.\n\nIt is sometimes advantageous to use\nvariable-length codes, in which different symbols may be\nrepresented by different numbers of bits.\n\nFor example,\nA\n0\nC\n1010\nE\n1100\nG\n1110\nB\n100\nD\n1011\nF\n1101\nH\n1111\nWith this code, the same message as above is encoded as the string\n100010100101101100011010100100000111001111\nThis string contains 42 bits, so it saves more than 20% in space in\ncomparison with the fixed-length code shown above.\n\nOne of the difficulties of using a variable-length code is knowing\nwhen you have reached the end of a symbol in reading a sequence of\nzeros and ones.\n\nMorse code solves this problem by using a special\nseparator code (in this case, a pause) after the sequence of\ndots and dashes for each letter.",
    "token_count": 281,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Huffman Encoding Trees",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Example_Huffman_Encoding_Trees_1"
  },
  {
    "content": "Morse code solves this problem by using a special\nseparator code (in this case, a pause) after the sequence of\ndots and dashes for each letter.\n\nAnother solution is to design the\ncode in such a way that no complete code for any symbol is the\nbeginning (or prefix ) of the code for another symbol.\n\nSuch a\ncode is called a\nprefix code.\n\nIn the example above, A is encoded by 0 and B is\nencoded by 100, so no other symbol can have a code that begins with 0 or\nwith 100.\n\nIn general, we can attain significant savings if we use\nvariable-length prefix codes that take advantage of the relative\nfrequencies of the symbols in the messages to be encoded.\n\nOne\nparticular for doing this is called the Huffman encoding\nmethod, after its discoverer,\n\nA Huffman encoding tree.\n\nFigure shows the Huffman tree for the\nA-through-H code given above.\n\nThe weights at the leaves indicate that the\ntree was designed for messages in which A appears with relative frequency\n8, B with relative frequency 3, and the other letters each with relative\nfrequency 1.\n\nGiven a Huffman tree, we can find the encoding of any symbol by\nstarting at the root and moving down until we reach the leaf that\nholds the symbol.\n\nEach time we move down a left branch we add a 0 to\nthe code, and each time we move down a right branch we add a 1.",
    "token_count": 244,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Huffman Encoding Trees",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Example_Huffman_Encoding_Trees_2"
  },
  {
    "content": "Each time we move down a left branch we add a 0 to\nthe code, and each time we move down a right branch we add a 1.\n\n(We\ndecide which branch to follow by testing to see which branch either is\nthe leaf node for the symbol or contains the symbol in its set.) For\nexample, starting from the root of the tree in\nfigure , we arrive at the leaf for D by\nfollowing a right branch, then a left branch, then a right branch, then a\nright branch; hence, the code for D is 1011.\n\nTo decode a bit sequence using a Huffman tree, we begin at the root\nand use the successive zeros and ones of the bit sequence to determine\nwhether to move down the left or the right branch.\n\nEach time we come\nto a leaf, we have generated a new symbol in the message, at which\npoint we start over from the root of the tree to find the next symbol.\n\nFor example, suppose we are given the tree above and the sequence\n10001010.\n\nStarting at the root, we move down the right branch (since\nthe first bit of the string is 1), then down the left branch (since\nthe second bit is 0), then down the left branch (since the third bit\nis also 0).\n\nThis brings us to the leaf for B, so the first\nsymbol of the decoded message is B.\n\nNow we start again at the root,\nand we make a left move because the next bit in the string is 0.\n\nThis brings us to the leaf for A.\n\nThen we start again at the root\nwith the rest of the string 1010, so we move right, left, right, left and\nreach C.",
    "token_count": 295,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Huffman Encoding Trees",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Example_Huffman_Encoding_Trees_3"
  },
  {
    "content": "Then we start again at the root\nwith the rest of the string 1010, so we move right, left, right, left and\nreach C.\n\nThus, the entire message is BAC.\n\nGiven an alphabet of symbols and their relative frequencies,\nhow do we construct the best code?\n\n(In other words, which\ntree will encode messages with the fewest bits?) Huffman gave an algorithm\nfor doing this and showed that the resulting code is indeed the best\nvariable-length code for messages where the relative frequency of the\nsymbols matches the frequencies with which the code was constructed.\n\nThe algorithm for generating a Huffman tree is very simple.\n\nThe idea\nis to arrange the tree so that the symbols with the lowest frequency\nappear farthest away from the root.\n\nBegin with the set of leaf nodes,\ncontaining symbols and their frequencies, as determined by the initial data\nfrom which the code is to be constructed.\n\nNow find two leaves with\nthe lowest weights and merge them to produce a node that has these\ntwo nodes as its left and right branches.\n\nThe weight of the new node\nis the sum of the two weights.\n\nRemove the two leaves from the\noriginal set and replace them by this new node.\n\nNow continue this\nprocess.\n\nAt each step, merge two nodes with the smallest weights,\nremoving them from the set and replacing them with a node that has\nthese two as its left and right branches.\n\nThe process stops when\nthere is only one node left, which is the root of the entire tree.",
    "token_count": 259,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Huffman Encoding Trees",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Example_Huffman_Encoding_Trees_4"
  },
  {
    "content": "The process stops when\nthere is only one node left, which is the root of the entire tree.\n\nHere is how the Huffman tree of figure was\ngenerated:\nInitial leaves\n$\\{$ (A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1) $\\}$\nMerge\n$\\{$ (A 8) (B 3) ( $\\{$ C D $\\}$ 2) (E 1) (F 1) (G 1) (H 1) $\\}$\nMerge\n$\\{$ (A 8) (B 3) ( $\\{$ C D $\\}$ 2) ( $\\{$ E F $\\}$ 2) (G 1) (H 1) $\\}$\nMerge\n$\\{$ (A 8) (B 3) ( $\\{$ C D $\\}$ 2) ( $\\{$ E F $\\}$ 2) ( $\\{$ G H $\\}$ 2) $\\}$\nMerge\n$\\{$ (A 8) (B 3) ( $\\{$ C D $\\}$ 2) ( $\\{$ E F G H $\\}$ 4) $\\}$\nMerge\n$\\{$ (A 8) ( $\\{$ B C D $\\}$ 5) ( $\\{$ E F G H $\\}$ 4) $\\}$\nMerge\n$\\{$ (A 8) ( $\\{$ B C D E F G H $\\}$ 9) $\\}$\nFinal merge\n$\\{$ ( $\\{$ A B C D E F G H $\\}$ 17) $\\}$\nThe algorithm does not always specify a unique tree, because there may\nnot be unique smallest-weight nodes at each step.\n\nAlso, the choice of\nthe order in which the two nodes are merged (i.e., which will be the\nright branch and which will be the left branch) is arbitrary.\n\nIn the exercises below we will work with a system that uses\nHuffman trees to encode and decode messages and generates Huffman\ntrees according to the algorithm outlined above.\n\nWe will begin by\ndiscussing how trees are represented.\n\nLeaves of the tree are represented by a list consisting of the string \"leaf\", the symbol at the leaf, and the weight:",
    "token_count": 299,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Huffman Encoding Trees",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Data_Example_Huffman_Encoding_Trees_5"
  },
  {
    "content": "Leaves of the tree are represented by a list consisting of the string \"leaf\", the symbol at the leaf, and the weight:\n\n```javascript\nmake_leaf\n      make_leaf_example\n      8\n\nfunction make_leaf(symbol, weight) {\n    return list(\"leaf\", symbol, weight);\n}\nfunction is_leaf(object) {\n    return head(object) === \"leaf\";\n}\nfunction symbol_leaf(x) { return head(tail(x)); }\n\nfunction weight_leaf(x) { return head(tail(tail(x))); }\n```\n\n```javascript\nmake_leaf_example\n\nconst my_leaf = make_leaf(\"A\", 8);\n\nweight_leaf(my_leaf);\n```\n\nA general tree will be a list of\na string \"code_tree\",\na left branch, a right branch, a set\nof symbols, and a weight.\n\nThe set of symbols will be simply a list of\nthe symbols, rather than some more sophisticated set representation.\n\nWhen we make a tree by merging two nodes, we obtain the weight of the\ntree as the sum of the weights of the nodes, and the set of symbols as\nthe union of the sets of symbols for the nodes.\n\nSince our symbol sets are\nrepresented as lists, we can form the union by using the\nfunction\nwe defined in section :\n\n```javascript\nmake_code_tree\n      make_code_tree_example\n      [ 'leaf', [ 'A', [ 8, null ] ] ]\n      tree_property\n\nfunction make_code_tree(left, right) {\n    return list(\"code_tree\", left, right,\n                append(symbols(left), symbols(right)),\n                weight(left) + weight(right));\n}\n```\n\n```javascript\nmake_code_tree_example\n\nconst my_leaf_1 = make_leaf(\"A\", 8);\nconst my_leaf_2 = make_leaf(\"B\", 3);\n\nmake_code_tree(my_leaf_1, my_leaf_2);\n\nconst my_leaf_1 = make_leaf(\"A\", 8);\nconst my_leaf_2 = make_leaf(\"B\", 3);\n\nhead(tail(make_code_tree(my_leaf_1, my_leaf_2)));\n```\n\nIf we make a tree in this way, we have the following selectors:\n\n```javascript\ntree_property\n      make_leaf\n      tree_property_example\n      11\n\nfunction left_branch(tree) { return head(tail(tree)); }\n\nfunction right_branch(tree) { return head(tail(tail(tree))); }\n\nfunction symbols(tree) {\n    return is_leaf(tree)\n           ? list(symbol_leaf(tree))\n           : head(tail(tail(tail(tree))));\n}\nfunction weight(tree) {\n    return is_leaf(tree)\n           ? weight_leaf(tree)\n           : head(tail(tail(tail(tail(tree)))));\n}\n```\n\n```javascript\ntree_property_example\n      make_code_tree\n      make_leaf\n      tree_property_example\n\nconst my_leaf_1 = make_leaf(\"A\", 8);\nconst my_leaf_2 = make_leaf(\"B\", 3);\nconst my_tree = make_code_tree(my_leaf_1, my_leaf_2);\n\nweight(my_tree);\n```",
    "token_count": 300,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Huffman Encoding Trees",
    "chunk_index": 6,
    "chunk_id": "Building_Abstractions_with_Data_Example_Huffman_Encoding_Trees_6"
  },
  {
    "content": "If we make a tree in this way, we have the following selectors:\n\nThe functions generic functions (functions that can handle more than one kind of data), which we will have much more to say about in sections\n\nand.\n\nThe following\nfunction\nimplements the decoding algorithm.\n\nIt takes as arguments a list of zeros\nand ones, together with a Huffman tree.\n\n```javascript\ndecode_function\n      make_leaf\n      make_code_tree\n      tree_property\n      decode_function_example\n      [ 'B', [ 'B', [ 'A', null ] ] ]\n\nfunction decode(bits, tree) {\n    function decode_1(bits, current_branch) {\n        if (is_null(bits)) {\n            return null;\n        } else {\n            const next_branch = choose_branch(head(bits),\n                                              current_branch);\n            return is_leaf(next_branch)\n                   ? pair(symbol_leaf(next_branch),\n                          decode_1(tail(bits), tree))\n                   : decode_1(tail(bits), next_branch);\n        }\n    }\n    return decode_1(bits, tree);\n}\n\nfunction choose_branch(bit, branch) {\n    return bit === 0\n           ? left_branch(branch)\n           : bit === 1\n           ? right_branch(branch)\n           : error(bit, \"bad bit -- choose_branch\");\n}\n```\n\n```javascript\ndecode_function_example\n\nconst my_leaf_1 = make_leaf(\"A\", 8);\nconst my_leaf_2 = make_leaf(\"B\", 3);\n\nconst my_tree = make_code_tree(my_leaf_1, my_leaf_2);\n\ndecode(list(0, 1, 1, 0), my_tree);\n\nconst my_leaf_1 = make_leaf(\"A\", 8);\nconst my_leaf_2 = make_leaf(\"B\", 3);\n\nconst my_tree = make_code_tree(my_leaf_1, my_leaf_2);\n\ntail(decode(list(0, 1, 1, 0), my_tree));\n```\n\nThe\nfunction\ndecode_1\ntakes two arguments: the list of remaining bits and the current position in\nthe tree.\n\nIt keeps moving down the tree, choosing a left or\na right branch according to whether the next bit in the list is a zero or a\none.\n\n(This is done with the\nfunction\nchoose_branch.)\nWhen it reaches a leaf, it returns the symbol at that leaf as the next\nsymbol in the message by\n\n```javascript\nadjoining\n\tit to the result of decoding the rest of the message,\n\tstarting at the root of the tree.\n```\n\nNote the error check in the final clause of choose_branch, which complains if the function finds something other than a zero or a one in\n\nthe input data.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Huffman Encoding Trees",
    "chunk_index": 7,
    "chunk_id": "Building_Abstractions_with_Data_Example_Huffman_Encoding_Trees_7"
  },
  {
    "content": "the input data.\n\nIn our representation of trees, each non-leaf node contains a set of\nsymbols, which we have represented as a simple list.\n\nHowever, the\ntree-generating algorithm discussed above requires that we also work\nwith sets of leaves and trees, successively merging the two smallest\nitems.\n\nSince we will be required to repeatedly find the smallest item\nin a set, it is convenient to use an ordered representation for this\nkind of set.\n\nWe will represent a set of leaves and trees as a list of elements,\narranged in increasing order of weight.\n\nThe following\nadjoin_set\nfunction\nfor constructing sets is similar to the one\ndescribed in exercise ; however, items\nare compared by their weights, and the element being added to the set is\nnever already in it.\n\n```javascript\nadjoin_set3\n      tree_property\n      adjoin_set3_example\n      [ 'leaf', [ 'B', [ 3, null ] ] ]\n\nfunction adjoin_set(x, set) {\n    return is_null(set)\n           ? list(x)\n           : weight(x) < weight(head(set))\n           ? pair(x, set)\n           : pair(head(set), adjoin_set(x, tail(set)));\n}\n```\n\n```javascript\nadjoin_set3_example\n\nconst my_leaf_1 = make_leaf(\"A\", 8);\nconst my_leaf_2 = make_leaf(\"B\", 3);\n\nadjoin_set(my_leaf_1, adjoin_set(my_leaf_2, null));\n\nconst my_leaf_1 = make_leaf(\"A\", 8);\nconst my_leaf_2 = make_leaf(\"B\", 3);\n\nhead(adjoin_set(my_leaf_1, adjoin_set(my_leaf_2, null)));\n```\n\nThe following function takes a list of symbol-frequency pairs such as list(list(\"A\", 4), list(\"B\", 2), list(\"C\", 1), list(\"D\", 1)) and constructs an initial ordered set\n\nof leaves, ready to be merged according to the Huffman algorithm:\n\n```javascript\nmake_leaf_set\n      make_leaf\n      adjoin_set3\n      make_leaf_set_example\n      [ 'leaf', [ 'leaf', [ 'A', null ] ] ]\n\nfunction make_leaf_set(pairs) {\n    if (is_null(pairs)) {\n        return null;\n    } else {\n        const first_pair = head(pairs);\n        return adjoin_set(\n                   make_leaf(head(first_pair),        // symbol\n                             head(tail(first_pair))), // frequency\n                   make_leaf_set(tail(pairs)));\n    }\n}\n```\n\n```javascript\nmake_leaf_set_example\n\nmake_leaf_set( list( list(\"A\", 4),\n                     list(\"B\", 2),\n                     list(\"C\", 1),\n                     list(\"D\", 1) ) );\n\nhead(make_leaf_set( list( list(\"A\", 4),\n                          list(\"B\", 2),\n                          list(\"C\", 1),\n                          list(\"D\", 1) ) ) );\n```",
    "token_count": 300,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Huffman Encoding Trees",
    "chunk_index": 8,
    "chunk_id": "Building_Abstractions_with_Data_Example_Huffman_Encoding_Trees_8"
  },
  {
    "content": "of leaves, ready to be merged according to the Huffman algorithm:\n\nThe tree will be unbalanced, similar to the tree given in\nfigure.\n\nEncoding the most\nfrequent symbol requires one bit, whereas\n$n - 1$ bits are required to encode the\nleast frequent symbol.",
    "token_count": 44,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Huffman Encoding Trees",
    "chunk_index": 9,
    "chunk_id": "Building_Abstractions_with_Data_Example_Huffman_Encoding_Trees_9"
  },
  {
    "content": "In the previous examples we built representations for two kinds of\ncompound data objects: rational numbers and algebraic expressions.\n\nIn\none of these examples we had the choice of simplifying (reducing) the\nexpressions at either construction time or selection time, but other\nthan that the choice of a representation for these structures in terms\nof lists was straightforward.\n\nWhen we turn to the representation of\nsets, the choice of a representation is not so obvious.\n\nIndeed, there\nare a number of possible representations, and they differ\nsignificantly from one another in several ways.\n\nInformally, a set is simply a collection of distinct objects.\n\nTo give\na more precise definition we can employ the method of data\nabstraction.\n\nThat is, we define set by specifying the\nunion_set,\nintersection_set,\nis_element_of_set,\nand\nadjoin_set.\n\nThe function is_@element_of_set\nis a predicate that determines whether a given element is a member of a set.\n\nThe function adjoin_@set\ntakes an object and a set as arguments and returns a set that contains the\nelements of the original set and also the adjoined element.\n\nThe function union_@set\ncomputes the union of two sets, which is the set containing each element\nthat appears in either argument.\n\n```javascript\nThe function\n      intersection_@set\n```\n\ncomputes the intersection of two sets, which is the set containing only\nelements that appear in both arguments.\n\nFrom the viewpoint of data\nabstraction, we are free to design any representation that implements these\noperations in a way consistent with the interpretations given\nabove.\n\nOne way to represent a set is as a list of its elements in which no\nelement appears more than once.\n\nThe empty set is represented by the\nempty list.\n\nIn this representation,\nis_element_of_set\nis similar to the\nfunction\n\n```javascript\nmember\n      of section.\n```\n\nIt uses equal instead of\n\n```javascript\n===\n```",
    "token_count": 298,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Representing Sets",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Example_Representing_Sets_1"
  },
  {
    "content": "It uses equal instead of\n\nso that the set elements need not be just numbers or strings:\n\n```javascript\nis_element_of_set\n      is_element_of_set_example\n      true\n\nfunction is_element_of_set(x, set) {\n    return is_null(set)\n           ? false\n           : equal(x, head(set))\n           ? true\n           : is_element_of_set(x, tail(set));\n}\n```\n\n```javascript\nis_element_of_set_example\n      adjoin_set\n\nis_element_of_set(15,\n    adjoin_set(10, adjoin_set(15, adjoin_set(20, null))));\n```\n\nUsing this, we can write\nadjoin_set.\n\nIf the object to be adjoined is already in the set, we just return the set.\n\nOtherwise, we use\npair\nto add the object to the list that represents the set:\n\n```javascript\nadjoin_set\n      is_element_of_set\n      adjoin_set_example\n      [ 10, [ 15, [ 20, null ] ] ]\n\nfunction adjoin_set(x, set) {\n    return is_element_of_set(x, set)\n           ? set\n           : pair(x, set);\n}\n```\n\n```javascript\nadjoin_set_example\n\nadjoin_set(10, adjoin_set(15, adjoin_set(20, null)));\n```\n\nFor\nintersection_set\nwe can use a recursive strategy.\n\nIf we know how to form the intersection\nof\ntail\nof\nhead\nof\nhead(set1)\nis also in\nfunction:\n\n```javascript\nintersection_set\n      is_element_of_set\n      intersection_set_example\n      [ 10, [ 20, null ] ]\n\nfunction intersection_set(set1, set2) {\n    return is_null(set1) || is_null(set2)\n           ? null\n           : is_element_of_set(head(set1), set2)\n           ? pair(head(set1), intersection_set(tail(set1), set2))\n           : intersection_set(tail(set1), set2);\n}\n```\n\n```javascript\nintersection_set_example\n      adjoin_set\n      intersection_set\n\nintersection_set(\n   adjoin_set(10, adjoin_set(20, adjoin_set(30, null))),\n   adjoin_set(10, adjoin_set(15, adjoin_set(20, null))));\n```\n\nIn designing a representation, one of the issues we should be concerned\nwith is efficiency.\n\nConsider the number of steps required by our set\noperations.\n\nSince they all use\nis_element_of_set,\nthe speed of this operation has a major impact on the efficiency of the set\nimplementation as a whole.\n\nNow, in order to check whether an object is a\nmember of a set,\nis_element_of_set\nmay have to scan the entire set.\n\n(In the worst case, the object turns out\nnot to be in the set.) Hence, if the set has\n$n$ elements,\nis_element_of_set\nmight take up to $n$ steps.\n\nThus, the number of\nsteps required grows as $\\Theta(n)$.",
    "token_count": 301,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Representing Sets",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Example_Representing_Sets_2"
  },
  {
    "content": "Thus, the number of\nsteps required grows as $\\Theta(n)$.\n\nThe number\nof steps required by\nadjoin_set,\nwhich uses\nthis operation, also grows as $\\Theta(n)$.\n\nFor\nintersection_set,\nwhich does an\nis_element_of_set\ncheck for each element of $\\Theta(n^{2})$ for two sets of size\n$n$.\n\nThe same will be true of\nunion_set.\n\nOne way to speed up our set operations is to change the representation\nso that the set elements are listed in increasing order.\n\nTo do this,\nwe need some way to compare two objects so that we can say which is\nbigger.\n\nFor example, we could compare\nstrings\nlexicographically, or\nwe could agree on some method for assigning a unique number to an\nobject and then compare the elements by comparing the corresponding\nnumbers.\n\nTo keep our discussion simple, we will consider only the\ncase where the set elements are numbers, so that we can compare\nelements using $\\{1,3,6,10\\}$ by listing the elements in any\norder, our new representation allows only the list\nlist(1, 3, 6, 10).\n\nOne advantage of ordering shows up in\nis_element_of_set:\nIn checking for the presence of an item, we no longer have to scan the\nentire set.\n\nIf we reach a set element that is larger than the item we\nare looking for, then we know that the item is not in the set:\n\n```javascript\nx\n      is_element_of_set2\n      is_element_of_set_example_2\n      true\n\nfunction is_element_of_set(x, set) {\n    return is_null(set)\n           ? false\n           : x === head(set)\n           ? true\n           : x < head(set)\n           ? false\n           : // $\\texttt{x > head(set)}$\n             is_element_of_set(x, tail(set));\n}\n```\n\n```javascript\nis_element_of_set_example_2\n\nis_element_of_set(15, list(10, 15, 20));\n```\n\nHow many steps does this save?\n\nIn the worst case, the item we are\nlooking for may be the largest one in the set, so the number of steps\nis the same as for the unordered representation.",
    "token_count": 296,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Representing Sets",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Example_Representing_Sets_3"
  },
  {
    "content": "In the worst case, the item we are\nlooking for may be the largest one in the set, so the number of steps\nis the same as for the unordered representation.\n\nOn the other hand,\nif we search for items of many different sizes we can expect that\nsometimes we will be able to stop searching at a point near the\nbeginning of the list and that other times we will still need to\nexamine most of the list.\n\nOn the average we should expect to have to\nexamine about half of the items in the set.\n\nThus, the average\nnumber of steps required will be about $n/2$.\n\nThis is still $\\Theta(n)$ growth, but\nit does save us, on the average, a factor of 2 in number of steps over the\nprevious implementation.\n\nWe obtain a more impressive speedup with\nintersection_set.\n\nIn the unordered representation this operation required\n$\\Theta(n^2)$ steps, because we performed a\ncomplete scan of\ntails\nof the two sets.\n\nSuppose, however, that\ntail\nof\ntail\nof\nfunction:\n\n```javascript\nintersection_set_ordered\n      intersection_set_example2\n      [ 10, [ 20, null ] ]\n\nfunction intersection_set(set1, set2) {\n    if (is_null(set1) || is_null(set2)) {\n        return null;\n    } else {\n        const x1 = head(set1);\n        const x2 = head(set2);\n        return x1 === x2\n               ? pair(x1, intersection_set(tail(set1), tail(set2)))\n               : x1 < x2\n               ? intersection_set(tail(set1), set2)\n               : // $\\texttt{x2 < x1}$\n\t         intersection_set(set1, tail(set2));\n    }\n}\n```\n\n```javascript\nintersection_set_example2\n      intersection_set_ordered\n\nintersection_set(\n   list(10, 20, 30),\n   list(10, 15, 20));\n```\n\nTo estimate the number of steps required by this process, observe that at each step we reduce the intersection problem to computing intersections of smaller\n\nsets removing the first element from $\\Theta(n)$ growth rather than $\\Theta(n^2)$ a considerable speedup, even for sets of moderate size.\n\nWe can do better than the ordered-list representation by arranging the set\nelements in the form of a tree.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Representing Sets",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Example_Representing_Sets_4"
  },
  {
    "content": "We can do better than the ordered-list representation by arranging the set\nelements in the form of a tree.\n\nEach node of the tree holds one element of\nthe set, called the entry at that node, and a link to each\nof two other (possibly empty) nodes.\n\nThe left link points to\nelements smaller than the one at the node, and the right\nlink to elements greater than the one at the node.\n\nFigure shows some trees that represent\nthe set $\\{1,3,5,7,9,11\\}$.\n\nThe same set may be\nrepresented by a tree in a number of different ways.\n\nThe only thing we\nrequire for a valid representation is that all elements in the left subtree\nbe smaller than the node entry and that all elements in the right subtree be\nlarger.\n\nVarious binary trees that represent the set\n$\\{ 1,3,5,7,9,11 \\}$.\n\nThe advantage of the tree representation is this: Suppose we want to check\nwhether a number $x$ is contained in a set.\n\nWe\nbegin by comparing $x$ with the entry in the\ntop node.\n\nIf $x$ is less than this, we know\nthat we need only search the left subtree; if $x$\nis greater, we need only search the right subtree.\n\nNow, if the tree is\nbalanced, each of these subtrees will be about half the size\nof the original.\n\nThus, in one step we have reduced the problem of\nsearching a tree of size $n$ to searching a tree\nof size $n/2$.\n\nSince the size of the tree is\nhalved at each step, we should expect that the number of steps needed to\nsearch a tree of size $n$ grows as\n$\\Theta(\\log n)$.\n\nWe can represent trees by using functions :",
    "token_count": 282,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Representing Sets",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Data_Example_Representing_Sets_5"
  },
  {
    "content": "We can represent trees by using functions :\n\n```javascript\nmake_tree_function\n      make_tree_example\n      20\n\nfunction entry(tree) { return head(tree); }\n\nfunction left_branch(tree) { return head(tail(tree)); }\n\nfunction right_branch(tree) { return head(tail(tail(tree))); }\n\nfunction make_tree(entry, left, right) {\n    return list(entry, left, right);\n}\n```\n\n```javascript\nmake_tree_example\n\nentry(\n  left_branch(\n    right_branch(\n      make_tree(10,\n                null,\n                make_tree(30,\n                          make_tree(20, null, null),\n                          null)))));\n```\n\nNow we can write is_element_of_set using the strategy described above:\n\n```javascript\nmake_tree_function\n      is_element_of_set_example_3\n      true\n\nfunction is_element_of_set(x, set) {\n    return is_null(set)\n           ? false\n           : x === entry(set)\n           ? true\n           : x < entry(set)\n           ? is_element_of_set(x, left_branch(set))\n           : // $\\texttt{x > entry(set)}$\n             is_element_of_set(x, right_branch(set));\n}\n```\n\n```javascript\nis_element_of_set_example_3\n\nis_element_of_set(20,\n    make_tree(10,\n        null,\n        make_tree(30,\n            make_tree(20, null, null),\n            null)));\n```\n\nAdjoining an item to a set is implemented similarly and also requires\n$\\Theta(\\log n)$ steps.\n\nTo adjoin an item\nfunction:\n\n```javascript\nadjoin_set_example_2\n\nadjoin_set(10, adjoin_set(15, adjoin_set(20, null)));\n\nhead(tail(head(tail(adjoin_set(10, adjoin_set(15, adjoin_set(20, null)))))));\n```\n\n```javascript\nadjoin_set2\n      make_tree_function\n      adjoin_set_example_2\n      [ 10, [ null, [ null, null ] ] ]\n\nfunction adjoin_set(x, set) {\n    return is_null(set)\n           ? make_tree(x, null, null)\n           : x === entry(set)\n           ? set\n           : x < entry(set)\n           ? make_tree(entry(set),\n                       adjoin_set(x, left_branch(set)),\n                       right_branch(set))\n           : // $\\texttt{x > entry(set)}$\n             make_tree(entry(set),\n                       left_branch(set),\n                       adjoin_set(x, right_branch(set)));\n}\n```\n\nThe above claim that searching the tree can be performed in a logarithmic\nnumber of steps rests on the assumption that the tree is\nbalanced, i.e., that the\nleft and the right subtree of every tree have approximately the same\nnumber of elements, so that each subtree contains about half the\nelements of its parent.\n\nBut how can we be certain that the trees we\nconstruct will be balanced?\n\nEven if we start with a balanced tree,\nadding elements with\nadjoin_set\nmay produce an unbalanced result.",
    "token_count": 276,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Representing Sets",
    "chunk_index": 6,
    "chunk_id": "Building_Abstractions_with_Data_Example_Representing_Sets_6"
  },
  {
    "content": "Even if we start with a balanced tree,\nadding elements with\nadjoin_set\nmay produce an unbalanced result.\n\nSince the position of a newly adjoined\nelement depends on how the element compares with the items already in the\nset, we can expect that if we add elements randomly the tree\nwill tend to be balanced on the average.\n\nBut this is not a guarantee.\n\nFor\nexample, if we start with an empty set and adjoin the numbers 1 through 7\nin sequence we end up with the highly unbalanced tree shown in\nfigure.\n\nIn this tree all the left\nsubtrees are empty, so it has no advantage over a simple ordered list.\n\nOne\nway to solve this problem is to define an operation that transforms an\narbitrary tree into a balanced tree with the same elements.\n\nThen we can perform this transformation after every few\nadjoin_set\noperations to keep our set in balance.\n\nThere are also other ways to solve\nthis problem, most of which involve designing new data structures for which\nsearching and insertion both can be done in\n$\\Theta(\\log n)$\nsteps.\n\nWe have examined options for using lists to represent sets and have\nseen how the choice of representation for a data object can have a\nlarge impact on the performance of the programs that use the data.\n\nAnother reason for concentrating on sets is that the techniques\ndiscussed here appear again and again in applications involving\ninformation retrieval.\n\nkey.\n\nA key can be anything that uniquely identifies the\nrecord.\n\nFor a personnel file, it might be an employee s ID number.\n\nFor an accounting system, it might be a transaction number.\n\nWhatever\nthe key is, when we define the record as a data structure we should\ninclude a\nfunction\nthat retrieves the key associated with a given record.",
    "token_count": 300,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Representing Sets",
    "chunk_index": 7,
    "chunk_id": "Building_Abstractions_with_Data_Example_Representing_Sets_7"
  },
  {
    "content": "Whatever\nthe key is, when we define the record as a data structure we should\ninclude a\nfunction\nthat retrieves the key associated with a given record.\n\nNow we represent the data base as a set of records.\n\nTo locate the record\nwith a given key we use a\nfunction\nThe function lookup\nis implemented in almost the same way as\nis_element_of_set.\n\nFor example, if the set of records is implemented as an unordered list, we\ncould use\n\n```javascript\nrecord\n\nfunction make_record(key, data) {\n    return pair(key, data);\n}\nfunction key(record) {\n    return head(record);\n}\nfunction data(record) {\n    return tail(record);\n}\n```\n\n```javascript\nrecord\n      lookup_example\n      [ 3, 'Earth' ]\n\nfunction lookup(given_key, set_of_records) {\n    return is_null(set_of_records)\n           ? false\n           : equal(given_key, key(head(set_of_records)))\n           ? head(set_of_records)\n           : lookup(given_key, tail(set_of_records));\n}\n```\n\n```javascript\nlookup_example\n\nlookup(3, list(make_record(2, \"Venus\"),\n               make_record(5, \"Jupiter\"),\n               make_record(4, \"Mars\"),\n               make_record(3, \"Earth\"),\n               make_record(6, \"Saturn\")));\n```\n\nOf course, there are better ways to represent large sets than as unordered\nlists.\n\nInformation-retrieval systems in which records have to be\nrandomly accessed are typically implemented by a tree-based\nmethod, such as the binary-tree representation discussed previously.\n\nIn designing such a system the methodology of data abstraction\ncan be a great help.\n\nThe designer can create an initial implementation\nusing a simple, straightforward representation such as unordered lists.\n\nThis will be unsuitable for the eventual system, but it can be useful in\nproviding a quick and dirty data base with which to test the\nrest of the system.\n\nLater on, the data representation can be modified to\nbe more sophisticated.\n\nIf the data base is accessed in terms of abstract\nselectors and constructors, this change in representation will not require\nany changes to the rest of the system.",
    "token_count": 279,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Example: Representing Sets",
    "chunk_index": 8,
    "chunk_id": "Building_Abstractions_with_Data_Example_Representing_Sets_8"
  },
  {
    "content": "So far, we have used strings in order to display messages,\nusing the functions display and\nerror (as for example in\nexercise ).\n\nWe can form compound data using strings and have lists such as\n\n```javascript\nlist(\"a\", \"b\", \"c\", \"d\")\nlist(23, 45, 17)\nlist(list(\"Jakob\", 27), list(\"Lova\", 9), list(\"Luisa\", 24))\n```\n\nIn order to distinguish strings from names, we surround them z denotes the value of the name z , whereas the JavaScript expression \"z\" denotes\n\na string that consists of a single character, namely the last letter in the English alphabet in lower case.\n\nVia quotation marks, we can distinguish between strings and names:\n\n```javascript\nab\n\nconst a = 1;\nconst b = 2;\n```\n\n```javascript\nlist_ab\n          ab\n\t  [ 1, [ 2, null ] ]\n\nlist(a, b);\n```\n\n```javascript\nlist_quote_a_quote_b\n\t  [ 'a', [ 'b', null ] ]\n\nlist(\"a\", \"b\");\n```\n\n```javascript\nlist_quote_a_b\n          ab\n\t  [ 'a', [ 2, null ] ]\n\nlist(\"a\", b);\n```\n\nIn section , we introduced\n=== and\n!==\nas primitive predicates on numbers.\n=== and\n!==.\n\nThe predicate\n===\nreturns true if and only\nif the two strings are the same, and\n!==\nreturns true if and only\nif the two strings are not the same. === , we can implement\na useful function called member.\n\nThis takes two arguments: a string and a list of strings or\na number and a list of numbers.\n\nIf the first argument is\nnot contained in the list (i.e., is not\n=== to any item in the list),\nthen member returns\nnull.\n\nOtherwise, it returns the\nsublist of the list beginning with the first occurrence of the\nstring or number:\n\n```javascript\nmemq\n          memq_example\n\t  null\n\nfunction member(item, x) {\n    return is_null(x)\n           ? null\n           : item === head(x)\n           ? x\n           : member(item, tail(x));\n}\n```\n\nFor example, the value of\n\n```javascript\nmemq_example\n          memq\n\nmember(\"apple\", list(\"pear\", \"banana\", \"prune\"))\n\nmember(\"apple\", list(\"pear\", \"banana\", \"prune\"));\n```",
    "token_count": 310,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Strings",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Strings_1"
  },
  {
    "content": "For example, the value of\n\nis null , whereas the value of\n\n```javascript\nmemq\n\t  [ 'apple', [ 'pear', null ] ]\n\nmember(\"apple\", list(\"x\", \"y\", \"apple\", \"pear\"))\n\nmember(\"apple\", list(\"x\", \"y\", \"apple\", \"pear\"));\n```\n\nis list(\"apple\", \"pear\").",
    "token_count": 35,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Symbolic Data",
    "subsection": "Strings",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Strings_2"
  },
  {
    "content": "In the previous section, we saw how to design systems in which data\nobjects can be represented in more than one way.\n\nThe key idea is to\nlink the code that specifies the data operations to the several\nrepresentations by means of generic interface\nfunctions.\n\nNow we will see how to use this same idea not only to define operations\nthat are generic over different representations but also to define\noperations that are\n(add_rat,\nsub_rat,\nmul_rat,\ndiv_rat)\nof section , and the complex-number\narithmetic that we implemented in\nsection.\n\nWe will now use\ndata-directed techniques to construct a package of arithmetic operations\nthat incorporates all the arithmetic packages we have already constructed.\n\nFigure\nshows the structure of the system we\nshall build.\n\nNotice the\nnumbers, there is a single\nfunction\nThe function add\nis part of a generic interface that allows the separate ordinary-arithmetic,\nrational-arithmetic, and complex-arithmetic packages to be accessed\nuniformly by programs that use numbers.\n\nAny individual arithmetic package\n(such as the complex package) may itself be accessed through generic\nfunctions\n(such as\nadd_complex)\nthat combine packages designed for different representations (such as\nrectangular and polar).\n\nMoreover, the structure of the system is additive,\nso that one can design the individual arithmetic packages separately and\ncombine them to produce a generic arithmetic system.\n\nGeneric",
    "token_count": 216,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Systems_with_Generic_Operations_1"
  },
  {
    "content": "We have seen how to define a unified arithmetic system that\nencompasses ordinary numbers, complex numbers, rational numbers, and\nany other type of number we might decide to invent, but we have\nignored an important issue.\n\nThe operations we have defined so far\ntreat the different data types as being completely independent.\n\nThus,\nthere are separate packages for adding, say, two ordinary numbers, or\ntwo complex numbers.\n\nWhat we have not yet considered is the fact that\nit is meaningful to define operations that cross the type boundaries,\nsuch as the addition of a complex number to an ordinary number.\n\nWe\nhave gone to great pains to introduce barriers between parts of our\nprograms so that they can be developed and understood separately.\n\nWe\nwould like to introduce the cross-type operations in some carefully\ncontrolled way, so that we can support them\nwithout seriously violating our module boundaries.\n\nOne way to handle\nfunction\nfor each possible combination of types for which the operation is valid.\n\nFor example, we could extend the complex-number package so that it\nprovides a\nfunction\nfor adding complex numbers to ordinary numbers and installs this in the\ntable using the tag\nlist(\"complex\", \"javascript_number\") :\n\n```javascript\nadd_complex_to_javascript_number_example\n\nconst c = make_complex_from_real_imag(4, 3);\nconst n = make_javascript_number(7);\n\nadd(c, n);\n```\n\n```javascript\nadd_complex_to_javascript_number\n      install_javascript_number_package_usage\n      install_complex_package_usage\n      add_complex_to_javascript_number_example\n      [ 'complex', [ 'rectangular', [ 11, 3 ] ] ]\n\n// to be included in the complex package\nfunction add_complex_to_javascript_num(z, x) {\n   return make_complex_from_real_imag(real_part(z) + x, imag_part(z));\n}\nput(\"add\", list(\"complex\", \"javascript_number\"),\n    (z, x) => tag(add_complex_to_javascript_num(z, x)));\n```\n\nThis technique works, but it is cumbersome.\n\nWith such a system, the\ncost of introducing a new type is not just the construction of the\npackage of\nfunctions\nfor that type but also the construction and installation of the\nfunctions\nthat implement the cross-type operations.",
    "token_count": 299,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_1"
  },
  {
    "content": "With such a system, the\ncost of introducing a new type is not just the construction of the\npackage of\nfunctions\nfor that type but also the construction and installation of the\nfunctions\nthat implement the cross-type operations.\n\nThis can easily be much more\ncode than is needed to define the operations on the type itself.\n\nThe\nmethod also undermines our ability to combine separate packages additively,\nor least to limit the extent to which the implementors of the individual\npackages need to take account of other packages.\n\nFor instance, in the\nexample above, it seems reasonable that handling mixed operations on\ncomplex numbers and ordinary numbers should be the responsibility of\nthe complex-number package.\n\nCombining rational numbers and complex\nnumbers, however, might be done by the complex package, by the rational\npackage, or by some third package that uses operations extracted from\nthese two packages.\n\nFormulating coherent policies on the division of\nresponsibility among packages can be an overwhelming task in designing\nsystems with many packages and many cross-type operations.\n\nIn the general situation of completely unrelated operations acting on\ncompletely unrelated types, implementing explicit cross-type operations,\ncumbersome though it may be, is the best that one can hope for.\n\nFortunately, we can usually do better by taking advantage of additional\nstructure that may be latent in our type system.\n\nOften the different\ndata types are not completely independent, and there may be ways by which\nobjects of one type may be viewed as being of another type.\n\nThis process\nis called coercion.\n\nFor example, if we are asked to\narithmetically combine an ordinary number with a complex number, we can\nview the ordinary number as a complex number whose imaginary part is zero.",
    "token_count": 285,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_2"
  },
  {
    "content": "For example, if we are asked to\narithmetically combine an ordinary number with a complex number, we can\nview the ordinary number as a complex number whose imaginary part is zero.\n\nThis transforms the problem to that of combining two complex numbers, which\ncan be handled in the ordinary way by the complex-arithmetic package.\n\nIn general, we can implement this idea by designing\nfunctions\nthat transform an object of one type into an equivalent\nobject of another type.\n\nHere is a typical coercion\nfunction,\nwhich transforms a given ordinary number to a complex number with that real\npart and zero imaginary part:\n\n```javascript\njavascript_number_to_complex\n\nfunction javascript_number_to_complex(n) {\n    return make_complex_from_real_imag(contents(n), 0);\n}\n```\n\nfunctions in a special coercion table, indexed under the names of the two types:\n\n```javascript\nput_get_coercion\n\nlet coercion_list = null;\n\nfunction clear_coercion_list() {\n    coercion_list = null;\n}\n\nfunction put_coercion(type1, type2, item) {\n    if (is_null(get_coercion(type1, type2))) {\n        coercion_list = pair(list(type1, type2, item),\n                             coercion_list);\n    } else {\n        return coercion_list;\n    }\n}\n\nfunction get_coercion(type1, type2) {\n    function get_type1(list_item) {\n        return head(list_item);\n    }\n    function get_type2(list_item) {\n        return head(tail(list_item));\n    }\n    function get_item(list_item) {\n        return head(tail(tail(list_item)));\n    }\n    function get_coercion_iter(items) {\n        if (is_null(items)) {\n            return undefined;\n        } else {\n            const top = head(items);\n            return equal(type1, get_type1(top)) &&\n                   equal(type2, get_type2(top))\n                   ? get_item(top)\n                   : get_coercion_iter(tail(items));\n        }\n    }\n    return get_coercion_iter(coercion_list);\n}\n```\n\n```javascript\nput_coercion_usage\n      put_get_coercion\n      javascript_number_to_complex\n      install_complex_package_usage\n      put_coercion_usage_example\n      put_get_coercion\n\nput_coercion(\"javascript_number\", \"complex\",\n             javascript_number_to_complex);\n```\n\n```javascript\nput_coercion_usage_example\n\nget_coercion(\"javascript_number\", \"complex\");\n```\n\n(We assume that there are\nput_coercion\nand\nget_coercion\nfunctions\navailable for manipulating this table.) Generally some of the slots in\nthe table will be empty, because it is not generally possible to coerce\nan arbitrary data object of each type into all other types.\n\nFor example,\nthere is no way to coerce an arbitrary complex number to an ordinary\nnumber, so there will be no general\ncomplex_to_javascript_number\nfunction\nincluded in the table.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_3"
  },
  {
    "content": "For example,\nthere is no way to coerce an arbitrary complex number to an ordinary\nnumber, so there will be no general\ncomplex_to_javascript_number\nfunction\nincluded in the table.\n\nOnce the coercion table has been set up, we can handle coercion in a\nuniform manner by modifying the\napply_generic\nfunction\nof section.\n\nWhen asked to apply an\noperation, we first check whether the operation is defined for the\narguments types, just as before.\n\nIf so, we dispatch to the\nfunction\nfound in the operation-and-type table.\n\nOtherwise, we try coercion.\n\nFor\nsimplicity, we consider only the case where there are two\narguments.\nfunction:",
    "token_count": 101,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_4"
  },
  {
    "content": "For\nsimplicity, we consider only the case where there are two\narguments.\nfunction:\n\n```javascript\nbase_operation_table\n\n// operation_table, put and get\n// from chapter 3 (section 3.3.3)\nfunction assoc(key, records) {\n    return is_null(records)\n           ? undefined\n           : equal(key, head(head(records)))\n             ? head(records)\n             : assoc(key, tail(records));\n}\nfunction make_table() {\n    const local_table = list(\"*table*\");\n    function lookup(key_1, key_2) {\n        const subtable = assoc(key_1, tail(local_table));\n        if (is_undefined(subtable)) {\n            return undefined;\n        } else {\n            const record = assoc(key_2, tail(subtable));\n            if (is_undefined(record)) {\n                return undefined;\n            } else {\n                return tail(record);\n            }\n        }\n    }\n    function insert(key_1, key_2, value) {\n        const subtable = assoc(key_1, tail(local_table));\n        if (is_undefined(subtable)) {\n            set_tail(local_table,\n                     pair(list(key_1, pair(key_2, value)),\n                          tail(local_table)));\n        } else {\n            const record = assoc(key_2, tail(subtable));\n            if (is_undefined(record)) {\n                set_tail(subtable,\n                         pair(pair(key_2, value),\n                              tail(subtable)));\n            } else {\n                set_tail(record, value);\n            }\n        }\n    }\n    function dispatch(m) {\n        return m === \"lookup\"\n               ? lookup\n               : m === \"insert\"\n                 ? insert\n                 : \"undefined operation -- table\";\n    }\n    return dispatch;\n}\nconst operation_table = make_table();\nconst get = operation_table(\"lookup\");\nconst put = operation_table(\"insert\");\n\n// In Source, most functions have a fixed number of arguments.\n// (The function list is the only exception, to this so far.)\n// The function apply_in_underlying_javascript allows us to\n// apply any given function fun to all elements of the argument\n// list args, as if they were separate arguments\nfunction apply(fun, args) {\n    return apply_in_underlying_javascript(fun, args);\n}\nfunction add(x, y) {\n    return apply_generic(\"add\", list(x, y));\n}\nfunction sub(x, y) {\n    return apply_generic(\"sub\", list(x, y));\n}\nfunction mul(x, y) {\n    return apply_generic(\"mul\", list(x, y));\n}\nfunction div(x, y) {\n    return apply_generic(\"div\", list(x, y));\n}\n\nfunction attach_tag(type_tag, contents) {\n    return pair(type_tag, contents);\n}\nfunction type_tag(datum) {\n    return is_pair(datum)\n           ? head(datum)\n           : error(datum, \"bad tagged datum -- type_tag\");\n}\nfunction contents(datum) {\n    return is_pair(datum)\n           ? tail(datum)\n           : error(datum, \"bad tagged datum -- contents\");\n}\n```",
    "token_count": 296,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_5"
  },
  {
    "content": "For\nsimplicity, we consider only the case where there are two\narguments.\nfunction:\n\n```javascript\njavascript_number_package\n      base_operation_table\n\nfunction install_javascript_number_package() {\n    function tag(x) {\n        return attach_tag(\"javascript_number\", x);\n    }\n    put(\"add\", list(\"javascript_number\", \"javascript_number\"),\n        (x, y) => tag(x + y));\n    put(\"sub\", list(\"javascript_number\", \"javascript_number\"),\n        (x, y) => tag(x - y));\n    put(\"mul\", list(\"javascript_number\", \"javascript_number\"),\n        (x, y) => tag(x * y));\n    put(\"div\", list(\"javascript_number\", \"javascript_number\"),\n        (x, y) => tag(x / y));\n    put(\"make\", \"javascript_number\",\n        x => tag(x));\n    return \"done\";\n}\ninstall_javascript_number_package();\n\nfunction make_javascript_number(n) {\n    return get(\"make\", \"javascript_number\")(n);\n}\n```",
    "token_count": 79,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 6,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_6"
  },
  {
    "content": "For\nsimplicity, we consider only the case where there are two\narguments.\nfunction:\n\n```javascript\ncomplex_number_package\n      base_operation_table\n\n// generic selector functions for complex numbers\n\nfunction real_part(z) {\n    return apply_generic(\"real_part\", list(z));\n}\nfunction imag_part(z) {\n    return apply_generic(\"imag_part\", list(z));\n}\nfunction magnitude(z) {\n    return apply_generic(\"magnitude\", list(z));\n}\nfunction angle(z) {\n    return apply_generic(\"angle\", list(z));\n}\nfunction square(x) {\n    return x * x;\n}\n\nfunction install_rectangular_package() {\n    function real_part(z) { return head(z); }\n    function imag_part(z) { return tail(z); }\n    function make_from_real_imag(x, y) { return pair(x, y); }\n    function magnitude(z) {\n        return math_sqrt(square(real_part(z)) +\n                   square(imag_part(z)));\n    }\n    function angle(z) {\n        return math_atan2(imag_part(z), real_part(z));\n    }\n    function make_from_mag_ang(r, a) {\n        return pair(r * math_cos(a), r * math_sin(a));\n    }\n    // interface to the rest of the system\n    function tag(x) {\n        return attach_tag(\"rectangular\", x);\n    }\n    put(\"real_part\", list(\"rectangular\"), real_part);\n    put(\"imag_part\", list(\"rectangular\"), imag_part);\n    put(\"magnitude\", list(\"rectangular\"), magnitude);\n    put(\"angle\", list(\"rectangular\"), angle);\n    put(\"make_from_real_imag\", \"rectangular\",\n        (x, y) => tag(make_from_real_imag(x, y)));\n    put(\"make_from_mag_ang\", \"rectangular\",\n        (r, a) => tag(make_from_mag_ang(r, a)));\n    return \"done\";\n}\ninstall_rectangular_package();\n\nfunction install_polar_package() {\n    // internal functions\n    function magnitude(z) { return head(z); }\n    function angle(z) { return tail(z); }\n    function make_from_mag_ang(r, a) { return pair(r, a); }\n    function real_part(z) {\n        return magnitude(z) * math_cos(angle(z));\n    }\n    function imag_part(z) {\n        return magnitude(z) * math_sin(angle(z));\n    }\n    function make_from_real_imag(x, y) {\n        return pair(math_sqrt(square(x) + square(y)),\n                    math_atan2(y, x));\n    }\n\n    // interface to the rest of the system\n    function tag(x) { return attach_tag(\"polar\", x); }\n    put(\"real_part\", list(\"polar\"), real_part);\n    put(\"imag_part\", list(\"polar\"), imag_part);\n    put(\"magnitude\", list(\"polar\"), magnitude);\n    put(\"angle\", list(\"polar\"), angle);\n    put(\"make_from_real_imag\", \"polar\",\n        (x, y) => tag(make_from_real_imag(x, y)));\n    put(\"make_from_mag_ang\", \"polar\",\n        (r, a) => tag(make_from_mag_ang(r, a)));\n    return \"done\";\n}\ninstall_polar_package();\n\nfunction install_complex_package() {\n    // imported functions from rectangular and polar packages\n    function make_from_real_imag(x, y) {\n        return get(\"make_from_real_imag\", \"rectangular\")(x, y);\n    }\n    function make_from_mag_ang(r, a) {\n        return get(\"make_from_mag_ang\", \"polar\")(r, a);\n    }\n\n    // internal functions\n    function add_complex(z1, z2) {\n        return make_from_real_imag(real_part(z1) +\n                                   real_part(z2),\n                                   imag_part(z1) +\n                                   imag_part(z2));\n    }\n    function sub_complex(z1, z2) {\n        return make_from_real_imag(real_part(z1) -\n                                   real_part(z2),\n                                   imag_part(z1) -\n                                   imag_part(z2));\n    }\n    function mul_complex(z1, z2) {\n        return make_from_mag_ang(magnitude(z1) *\n                                 magnitude(z2),\n                                 angle(z1) +\n                                 angle(z2));\n    }\n    function div_complex(z1, z2) {\n        return make_from_mag_ang(magnitude(z1) /\n                                 magnitude(z2),\n                                 angle(z1) -\n                                 angle(z2));\n    }\n\n    // interface to rest of the system\n    function tag(z) {\n        return attach_tag(\"complex\", z);\n    }\n    put(\"add\", list(\"complex\", \"complex\"),\n        (z1, z2) => tag(add_complex(z1, z2)));\n    put(\"sub\", list(\"complex\", \"complex\"),\n        (z1, z2) => tag(sub_complex(z1, z2)));\n    put(\"mul\", list(\"complex\", \"complex\"),\n        (z1, z2) => tag(mul_complex(z1, z2)));\n    put(\"div\", list(\"complex\", \"complex\"),\n        (z1, z2) => tag(div_complex(z1, z2)));\n    put(\"make_from_real_imag\", \"complex\",\n        (x, y) => tag(make_from_real_imag(x, y)));\n    put(\"make_from_mag_ang\", \"complex\",\n        (r, a) => tag(make_from_mag_ang(r, a)));\n    return \"done\";\n}\ninstall_complex_package();\n\nfunction make_complex_from_real_imag(x, y){\n    return get(\"make_from_real_imag\", \"complex\")(x, y);\n}\nfunction make_complex_from_mag_ang(r, a){\n    return get(\"make_from_mag_ang\", \"complex\")(r, a);\n}\n```",
    "token_count": 413,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 7,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_7"
  },
  {
    "content": "For\nsimplicity, we consider only the case where there are two\narguments.\nfunction:\n\n```javascript\ncoercion_support\n\n// coercion support\n\nlet coercion_list = null;\n\nfunction clear_coercion_list() {\n    coercion_list = null;\n}\n\nfunction put_coercion(type1, type2, item) {\n    if (is_undefined(get_coercion(type1, type2))) {\n        coercion_list = pair(list(type1, type2, item),\n                             coercion_list);\n    } else {\n        return coercion_list;\n    }\n}\n\nfunction get_coercion(type1, type2) {\n    function get_type1(list_item) {\n        return head(list_item);\n    }\n    function get_type2(list_item) {\n        return head(tail(list_item));\n    }\n    function get_item(list_item) {\n        return head(tail(tail(list_item)));\n    }\n    function get_coercion_iter(items) {\n        if (is_null(items)) {\n            return undefined;\n        } else {\n            const top = head(items);\n            return equal(type1, get_type1(top)) &&\n                   equal(type2, get_type2(top))\n                   ? get_item(top)\n                   : get_coercion_iter(tail(items));\n        }\n    }\n    return get_coercion_iter(coercion_list);\n}\n```\n\n```javascript\napply_generic_with_coercion_example\n      base_operation_table\n      javascript_number_package\n      complex_number_package\n      coercion_support\n\nfunction javascript_number_to_complex(n) {\n    return make_complex_from_real_imag(contents(n), 0);\n}\n\nput_coercion(\"javascript_number\", \"complex\",\n             javascript_number_to_complex);\n\nconst c = make_complex_from_real_imag(4, 3);\nconst n = make_javascript_number(7);\n\nadd(c, n);\n```\n\n```javascript\napply_generic_with_coercion\n      apply_generic_with_coercion_example\n      [ 'complex', [ 'rectangular', [ 11, 3 ] ] ]\n\nfunction apply_generic(op, args) {\n    const type_tags = map(type_tag, args);\n    const fun = get(op, type_tags);\n    if (! is_undefined(fun)) {\n        return apply(fun, map(contents, args));\n    } else {\n        if (length(args) === 2) {\n            const type1 = head(type_tags);\n            const type2 = head(tail(type_tags));\n            const a1 = head(args);\n            const a2 = head(tail(args));\n            const t1_to_t2 = get_coercion(type1, type2);\n            const t2_to_t1 = get_coercion(type2, type1);\n            return ! is_undefined(t1_to_t2)\n                   ? apply_generic(op, list(t1_to_t2(a1), a2))\n                   : ! is_undefined(t2_to_t1)\n                   ? apply_generic(op, list(a1, t2_to_t1(a2)))\n                   : error(list(op, type_tags),\n                           \"no method for these types\");\n        } else {\n            return error(list(op, type_tags),\n                         \"no method for these types\");\n        }\n    }\n}\n```\n\nThis coercion has many advantages over the method of defining\nexplicit cross-type operations, as outlined above.\n\nAlthough we still\nneed to write coercion\nfunctions\nto relate the types (possibly $n^2$\nfunctions\nfor a system with $n$ types), we need to write\nonly one\nfunction\nfor each pair of types rather than a different\nfunction\nfor each collection of types and each generic operation.",
    "token_count": 301,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 8,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_8"
  },
  {
    "content": "Although we still\nneed to write coercion\nfunctions\nto relate the types (possibly $n^2$\nfunctions\nfor a system with $n$ types), we need to write\nonly one\nfunction\nfor each pair of types rather than a different\nfunction\nfor each collection of types and each generic operation.\n\nOn the other hand, there may be applications for which our coercion is not general enough.\n\nEven when neither of the objects to be\ncombined can be converted to the type of the other it may still be\npossible to perform the operation by converting both objects to a\nthird type.\n\nIn order to deal with such complexity and still preserve\nmodularity in our programs, it is usually necessary to build systems\nthat take advantage of still further structure in the relations among\ntypes, as we discuss next.\n\nThe coercion presented above relied on the existence of natural\nrelations between pairs of types.\n\nOften there is more global\nstructure in how the different types relate to each other.\n\nFor\ninstance, suppose we are building a generic arithmetic system to\nhandle integers, rational numbers, real numbers, and complex numbers.\n\nIn such a system, it is quite natural to regard an integer as a\nspecial kind of rational number, which is in turn a special kind of\nreal number, which is in turn a special kind of complex number.\n\nWhat\nwe actually have is a so-called hierarchy of types , in which,\nfor example, integers are a\nsubtype of rational numbers (i.e.,\nany operation that can be applied to a rational number can\nautomatically be applied to an integer).\n\nConversely, we say that\nrational numbers form a\nsupertype of integers.",
    "token_count": 275,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 9,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_9"
  },
  {
    "content": "Conversely, we say that\nrational numbers form a\nsupertype of integers.\n\nThe particular\nhierarchy we have here is of a very simple kind, in which each type\nhas at most one supertype and at most one subtype.\n\nSuch a structure,\ncalled a tower , is illustrated in\nfigure.\n\nA tower of types.\n\nIf we have a tower structure, then we can greatly simplify the problem\nof adding a new type to the hierarchy, for we need only specify how\nthe new type is embedded in the next supertype above it and how it is\nthe supertype of the type below it.\n\nFor example, if we want to add an\ninteger to a complex number, we need not explicitly define a special\ncoercion\nfunction\ninteger_to_complex.\n\nInstead, we define how an integer can be transformed into a rational\nnumber, how a rational number is transformed into a real number, and how\na real number is transformed into a complex number.\n\nWe then allow the\nsystem to transform the integer into a complex number through these steps\nand then add the two complex numbers.\n\napply_generic\nfunction\nin the following way: For each type, we need to supply a\nfunction,\nwhich raises objects of that type one level in the tower.\n\nThen when the system is required to operate on objects of different types\nit can successively raise the lower types until all the objects are at\nthe same level in the tower.\n\n(Exercises\nand\nconcern the details of implementing such a strategy.)\n\nAnother advantage of a tower is that we can easily implement the notion\nthat every type inherits all operations defined on a\nsupertype.",
    "token_count": 272,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 10,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_10"
  },
  {
    "content": "Another advantage of a tower is that we can easily implement the notion\nthat every type inherits all operations defined on a\nsupertype.\n\nFor instance, if we do not supply a special\nfunction\nfor finding the real part of an integer, we should nevertheless expect\nthat\nreal_part\nwill be defined for integers by virtue of the fact that integers are a\nsubtype of complex numbers.\n\nIn a tower, we can arrange for this to happen\nin a uniform way by modifying\napply_generic.\n\nIf the required operation is not directly defined for the type of the\nobject given, we raise the object to its supertype and try again.\n\nWe thus\ncrawl up the tower, transforming our argument as we go, until we either\nfind a level at which the desired operation can be performed or hit the\ntop (in which case we give up).\n\nlower a data object to the\nsimplest representation.\n\nFor example, if we add\n$2+3i$ to $4-3i$ ,\nit would be nice to obtain the answer as the integer 6 rather than as the\ncomplex number $6+0i$.\n\nExercise discusses a way to implement\nsuch a lowering operation.\n\n(The trick is that we need a general way\nto distinguish those objects that can be lowered, such as\n$6+0i$ , from those that cannot, such as\n$6+2i$.)\n\nIf the data types in our system can be naturally arranged in a tower,\nthis greatly simplifies the problems of dealing with generic operations\non different types, as we have seen.\n\nUnfortunately, this is usually\nnot the case.\n\nFigure\nillustrates a more complex arrangement of mixed types, this one showing\nrelations among different types of geometric figures.\n\nWe see that, in\ngeneral,\nraise a type\nin the hierarchy.",
    "token_count": 285,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 11,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_11"
  },
  {
    "content": "We see that, in\ngeneral,\nraise a type\nin the hierarchy.\n\nFinding the correct supertype in which\nto apply an operation to an object may involve considerable searching\nthrough the entire type network on the part of a\nfunction\nsuch as\napply_generic.\n\nSince there generally are multiple subtypes for a type, there is a similar\nproblem in coercing a value down the type hierarchy.\n\nDealing with large numbers of interrelated types while still preserving\nmodularity in the design of large systems is very difficult, and is an area\nof much current research.",
    "token_count": 92,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Combining Data of Different Types",
    "chunk_index": 12,
    "chunk_id": "Building_Abstractions_with_Data_Combining_Data_of_Different_Types_12"
  },
  {
    "content": "The manipulation of symbolic algebraic expressions is a complex\nprocess that illustrates many of the hardest problems that occur in\nthe design of large-scale systems.\n\nAn\ntypes, which are\noften useful for directing the processing of expressions.\n\nFor example, we\ncould describe the expression\n\\[ x^{2}\\, \\sin (y^2+1)+x\\, \\cos 2y+\\cos (y^3 -2y^2) \\]\nas a polynomial in $x$ with coefficients that\nare trigonometric functions of polynomials in\n$y$ whose coefficients are integers.\n\nWe will not attempt to develop a complete algebraic-manipulation\nsystem here.\n\nSuch systems are exceedingly complex programs, embodying\ndeep algebraic knowledge and elegant algorithms.\n\nWhat we will do is\nlook at a simple but important part of algebraic manipulation: the\narithmetic of polynomials.\n\nWe will illustrate the kinds of decisions\nthe designer of such a system faces, and how to apply the ideas of\nabstract data and generic operations to help organize this effort.\n\nOur first task in designing a system for performing arithmetic on\npolynomials is to decide just what a polynomial is.\n\nPolynomials are\nnormally defined relative to certain variables (the\nindeterminates of the polynomial).\n\nFor simplicity, we will\nrestrict ourselves to polynomials having just one indeterminate\n(univariate polynomials ).\n\\[ 5x^2 +3x +7 \\]\nis a simple polynomial in $x$ , and\n\\[ (y^2 +1)x^3 +(2y)x+1 \\]\nis a polynomial in $x$ whose coefficients are\npolynomials in $y$.\n\nAlready we are skirting some thorny issues.\n\nIs the first of these\npolynomials the same as the polynomial\n$5y^2 +3y +7$ , or not?\n\nA reasonable answer\nmight be yes, if we are considering a polynomial purely as a\nmathematical function, but no, if we are considering a polynomial to be a\nsyntactic form.\n\nThe second polynomial is algebraically equivalent\nto a polynomial in $y$ whose coefficients are\npolynomials in $x$.",
    "token_count": 294,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_1"
  },
  {
    "content": "The second polynomial is algebraically equivalent\nto a polynomial in $y$ whose coefficients are\npolynomials in $x$.\n\nShould our system recognize\nthis, or not?\n\nFurthermore, there are other ways to represent a\npolynomial for example, as a product of factors, or (for a\nunivariate polynomial) as the set of roots, or as a listing of the values\nof the polynomial at a specified set of points. polynomial will be a\nparticular syntactic form, not its underlying mathematical meaning.\n\nNow we must consider how to go about doing arithmetic on polynomials.\n\nIn this simple system, we will consider only addition and\nmultiplication.\n\nMoreover, we will insist that two polynomials to be\ncombined must have the same indeterminate.\n\nWe will approach the design of our system by following the familiar\ndiscipline of data abstraction.\n\nWe will represent polynomials using a\ndata structure called a\npoly , which consists of a variable and a\nterm_list\nthat extract those parts from a poly and a constructor\nmake_poly\nthat assembles a poly from a given variable and a term list.\n\nA variable will be just a\nstring,\nso we can use the\nis_same_variable\nfunction\nof section to compare\nvariables.\n\nThe following\nfunctions\ndefine\n\n```javascript\nadd_mul_poly\n      install_javascript_number_package_usage\n      make_polynomial_requires\n      make_polynomial\n      make_polynomial_example\n\nfunction add_poly(p1, p2) {\n    return is_same_variable(variable(p1), variable(p2))\n           ? make_poly(variable(p1),\n                       add_terms(term_list(p1), term_list(p2)))\n           : error(list(p1, p2), \"polys not in same var -- add_poly\");\n}\nfunction mul_poly(p1, p2) {\n    return is_same_variable(variable(p1), variable(p2))\n           ? make_poly(variable(p1),\n                       mul_terms(term_list(p1), term_list(p2)))\n           : error(list(p1, p2), \"polys not in same var -- mul_poly\");\n}\n```\n\nTo incorporate polynomials into our generic arithmetic system, we need\nto supply them with type tags.\n\nWe ll use the tag\n\"polynomial\",\nand install appropriate operations on tagged polynomials in the operation\ntable.",
    "token_count": 282,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_2"
  },
  {
    "content": "We ll use the tag\n\"polynomial\",\nand install appropriate operations on tagged polynomials in the operation\ntable.\n\n```javascript\nWell embed all our code in an installation function\n\tfor the polynomial package,\n\tsimilar to the installation functions in\n\tsection:\n\n\t    install_polynomial_package_template\n\t    install_javascript_number_package_usage\n\t    make_polynomial_requires\n\t    make_polynomial\n\t    make_polynomial_example\n\nfunction install_polynomial_package() {\n    // internal functions\n    // representation of poly\n    function make_poly(variable, term_list) {\n        return pair(variable, term_list);\n    }\n    function variable(p) { return head(p); }\n    function term_list(p) { return tail(p); }\n    functions is_same_variable and is_variable from section 2.3.2\n\n    // representation of terms and term lists\n    functions adjoin_term...coeff from text below\n\n    function add_poly(p1, p2) { ... }\n    functions used by add_poly\n    function mul_poly(p1, p2) { ... }\n    functions used by mul_poly\n\n    // interface to rest of the system\n    function tag(p) { return attach_tag(\"polynomial\", p); }\n    put(\"add\", list(\"polynomial\", \"polynomial\"),\n        (p1, p2) => tag(add_poly(p1, p2)));\n    put(\"mul\", list(\"polynomial\", \"polynomial\"),\n        (p1, p2) => tag(mul_poly(p1, p2)));\n    put(\"make\", \"polynomial\",\n        (variable, terms) => tag(make_poly(variable, terms)));\n    return \"done\";\n}\n```\n\nPolynomial addition is performed termwise.\n\nTerms of the same order\n(i.e., with the same power of the indeterminate) must be combined.\n\nThis is done by forming a new term of the same order whose coefficient\nis the sum of the coefficients of the addends.\n\nTerms in one addend\nfor which there are no terms of the same order in the other addend are\nsimply accumulated into the sum polynomial being constructed.\n\nIn order to manipulate term lists, we will assume that we have a\nconstructor\nthe_empty_termlist\nthat returns an empty term list and a constructor\nadjoin_@term\nthat adjoins a new term to a term list.\n\nWe will also assume that we have\na predicate\nis_empty_termlist\nthat tells if a given term list is empty, a selector\nfirst_term\nthat extracts the highest-order term from a term list, and a selector\nrest_terms\nthat returns all but the highest-order term.",
    "token_count": 300,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_3"
  },
  {
    "content": "We will also assume that we have\na predicate\nis_empty_termlist\nthat tells if a given term list is empty, a selector\nfirst_term\nthat extracts the highest-order term from a term list, and a selector\nrest_terms\nthat returns all but the highest-order term.\n\nTo manipulate terms,\nwe will suppose that we have a constructor\nmake_term\nthat constructs a term with given order and coefficient, and selectors\n\nHere is the function that constructs the term list for the sum of two\n\n```javascript\npolynomials;\n```\n\n```javascript\nnote that we slightly extend the syntax of\n\t by admitting another conditional\n      statement in place of the block following\n      else:\n```\n\n```javascript\nadd_terms\n      install_javascript_number_package_usage\n      make_polynomial_requires\n      make_polynomial\n      make_polynomial_example\n\nfunction add_terms(L1, L2) {\n    if (is_empty_termlist(L1)) {\n        return L2;\n    } else if (is_empty_termlist(L2)) {\n        return L1;\n    } else {\n        const t1 = first_term(L1);\n        const t2 = first_term(L2);\n        return order(t1) > order(t2)\n               ? adjoin_term(t1, add_terms(rest_terms(L1), L2))\n               : order(t1) < order(t2)\n               ? adjoin_term(t2, add_terms(L1, rest_terms(L2)))\n               : adjoin_term(make_term(order(t1),\n                                       add(coeff(t1), coeff(t2))),\n                             add_terms(rest_terms(L1),\n                                       rest_terms(L2)));\n    }\n}\n```\n\nThe most important point to note here is that we used the generic addition function\n\nIn order to multiply two term lists, we multiply each term of the first\nlist by all the terms of the other list, repeatedly using\nmul_term_by_all_terms,\nwhich multiplies a given term by all terms in a given term list.\n\nThe\nresulting term lists (one for each term of the first list) are accumulated\ninto a sum.\n\nMultiplying two terms forms a term whose order is the sum of\nthe orders of the factors and whose coefficient is the product of the\ncoefficients of the factors:",
    "token_count": 262,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_4"
  },
  {
    "content": "Multiplying two terms forms a term whose order is the sum of\nthe orders of the factors and whose coefficient is the product of the\ncoefficients of the factors:\n\n```javascript\nmul_terms\n      install_javascript_number_package_usage\n      make_polynomial_requires\n      make_polynomial\n      make_polynomial_example\n\nfunction mul_terms(L1, L2) {\n    return is_empty_termlist(L1)\n           ? the_empty_termlist\n           : add_terms(mul_term_by_all_terms(\n                                 first_term(L1), L2),\n                       mul_terms(rest_terms(L1), L2));\n}\nfunction mul_term_by_all_terms(t1, L) {\n    if (is_empty_termlist(L)) {\n        return the_empty_termlist;\n    } else {\n        const t2 = first_term(L);\n        return adjoin_term(\n                   make_term(order(t1) + order(t2),\n                             mul(coeff(t1), coeff(t2))),\n                   mul_term_by_all_terms(t1, rest_terms(L)));\n    }\n}\n```\n\nThis is really all there is to polynomial addition and multiplication.\n\nNotice that, since we operate on terms using the generic\nfunctions\n,\nthen we also are automatically able to handle operations on\npolynomials of different coefficient types, such as\n\\[\n\\begin{array}{l}\n{\\left[3x^2 +(2+3i)x+7\\right] \\cdot \\left[x^4 +\\frac{2}{3}x^2\n+(5+3i)\\right]}\n\\end{array}\n\\]\n\nBecause we installed the polynomial addition and multiplication\nfunctions\nadd_@poly\nand\nmul_poly\nin the generic arithmetic system as the\n\\[\n\\begin{array}{l}\n{\\left[ (y+1)x^2 +(y^2 +1)x+(y-1)\\right]\\cdot \\left[(y-2)x+(y^3 +7)\\right]}\n\\end{array}\n\\]\nThe reason is that when the system tries to combine coefficients, it\nwill dispatch through $y$ ), these will be combined\nusing\nadd_poly\nand\nmul_poly.\n\nThe result is a kind of\ndata-directed recursion in which, for example, a call to\nmul_poly\nwill result in recursive calls to\nmul_poly\nin order to multiply the coefficients.\n\nIf the coefficients of the\ncoefficients were themselves polynomials (as might be used to represent\npolynomials in three variables), the data direction would ensure that the\nsystem would follow through another level of recursive calls, and so on\nthrough as many levels as the structure of the data dictates.\n\nFinally, we must confront the job of implementing a good\nrepresentation for term lists.\n\nA term list is, in effect, a set of\ncoefficients keyed by the order of the term.",
    "token_count": 291,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_5"
  },
  {
    "content": "A term list is, in effect, a set of\ncoefficients keyed by the order of the term.\n\nHence, any of the\nmethods for representing sets, as discussed in\nsection , can be applied to this\ntask.\n\nOn the other hand, our\nfunctions\nadd_terms\nand\nmul_terms\nalways access term lists sequentially from highest to lowest order.\n\nThus, we will use some kind of ordered list representation.\n\nHow should we structure the list that represents a term list?\n\nOne\nconsideration is the density of the polynomials we intend\nto manipulate.\n\nA polynomial is said to be\ndense if it has nonzero coefficients in terms of most orders.\n\nIf it has many zero terms it is said to be\nsparse.\n\nFor example,\n\\[ A:\\quad x^5 +2x^4 +3x^2 -2x -5 \\]\nis a dense polynomial, whereas\n\\[ B:\\quad x^{100} +2x^2 +1 \\]\nis sparse.\n\n```javascript\nThe term list of a dense polynomial is most efficiently represented\n\tas a list of the coefficients.\n```\n\nFor example,\nthe polynomial\n$A$ above would be nicely represented as\nlist(1, 2, 0, 3, -2, -5).\n\nThe order of a term in this representation is the length of the sublist\nbeginning with that term s coefficient, decremented by 1. $B$ : There would be a giant list of zeros\npunctuated by a few lonely nonzero terms.\n\nA more reasonable representation\nof the term list of a sparse polynomial is as a list of the nonzero terms,\nwhere each term is a list containing the order of the term and the\ncoefficient for that order.\n\nIn such a , polynomial\n$B$ is efficiently represented as\nlist(list(100, 1), list(2, 2), list(0, 1)).\n\nAs most polynomial manipulations are performed on sparse polynomials, we\nwill use this method.\n\nWe will assume that term lists are represented as\nlists of terms, arranged from highest-order to lowest-order term.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 6,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_6"
  },
  {
    "content": "We will assume that term lists are represented as\nlists of terms, arranged from highest-order to lowest-order term.\n\nOnce we\nhave made this decision, implementing the selectors and constructors for\nterms and term lists is straightforward:\n\n```javascript\nadjoin_term\n      install_javascript_number_package_usage\n      make_polynomial_requires\n      make_polynomial\n      make_polynomial_example\n\nfunction adjoin_term(term, term_list) {\n    return is_equal_to_zero(coeff(term))\n           ? term_list\n           : pair(term, term_list);\n}\n\nconst the_empty_termlist = null;\n\nfunction first_term(term_list) { return head(term_list); }\n\nfunction rest_terms(term_list) { return tail(term_list); }\n\nfunction is_empty_termlist(term_list) { return is_null(term_list); }\n\nfunction make_term(order, coeff) { return list(order, coeff); }\n\nfunction order(term) { return head(term); }\n\nfunction coeff(term) { return head(tail(term)); }\n```\n\nwhere\nis_equal_to_zero\nis as defined in exercise.\n\n(See also\nexercise below.)\n\nUsers of the polynomial package will create (tagged) polynomials by means of the function:",
    "token_count": 122,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 7,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_7"
  },
  {
    "content": "Users of the polynomial package will create (tagged) polynomials by means of the function:\n\n```javascript\nmake_polynomial_requires\n      is_same_variable\n\nfunction install_javascript_number_is_equal_to_zero() {\n    put(\"is_equal_to_zero\", list(\"javascript_number\"),\n        x => x === 0);\n    return \"done\";\n}\ninstall_javascript_number_is_equal_to_zero();\n\nfunction is_equal_to_zero(x) {\n    return apply_generic(\"is_equal_to_zero\", list(x));\n}\n\nfunction install_polynomial_package() {\n\n    // internal functions\n\n    // representation of poly\n    function make_poly(variable, term_list) {\n        return pair(variable, term_list);\n    }\n    function variable(p) { return head(p); }\n    function term_list(p) { return tail(p); }\n\n    // representation of terms and term lists\n    function adjoin_term(term, term_list) {\n        return is_equal_to_zero(coeff(term))\n               ? term_list\n               : pair(term, term_list);\n    }\n    const the_empty_termlist = null;\n    function first_term(term_list) {\n        return head(term_list);\n    }\n    function rest_terms(term_list) {\n        return tail(term_list);\n    }\n    function is_empty_termlist(term_list) {\n        return is_null(term_list);\n    }\n    function make_term(order, coeff) {\n        return list(order, coeff);\n    }\n    function order(term) {\n        return head(term);\n    }\n    function coeff(term) {\n        return head(tail(term));\n    }\n\n    function add_poly(p1, p2) {\n        return is_same_variable(variable(p1), variable(p2))\n               ? make_poly(variable(p1),\n                           add_terms(term_list(p1),\n                                     term_list(p2)))\n               : error(list(p1, p2),\n                       \"polys not in same var -- add_poly\");\n    }\n\n    function add_terms(L1, L2) {\n        if (is_empty_termlist(L1)) {\n          return L2;\n        }\n        else if (is_empty_termlist(L2)) {\n          return L1;\n        }\n        else {\n            const t1 = first_term(L1);\n            const t2 = first_term(L2);\n            return order(t1) > order(t2)\n                   ? adjoin_term(t1, add_terms(rest_terms(L1), L2))\n                   : order(t1) < order(t2)\n                   ? adjoin_term(t2, add_terms(L1, rest_terms(L2)))\n                   : adjoin_term(make_term(order(t1),\n                                           add(coeff(t1),\n                                               coeff(t2))),\n                                 add_terms(rest_terms(L1),\n                                           rest_terms(L2)));\n        }\n    }\n\n    function mul_poly(p1, p2) {\n        return is_same_variable(variable(p1), variable(p2))\n               ? make_poly(variable(p1),\n                           mul_terms(term_list(p1),\n                                     term_list(p2)))\n               : error(list(p1, p2),\n                       \"polys not in same var -- mul_poly\");\n    }\n\n    function mul_terms(L1, L2) {\n        return is_empty_termlist(L1)\n               ? the_empty_termlist\n               : add_terms(mul_term_by_all_terms(\n                                     first_term(L1), L2),\n                           mul_terms(rest_terms(L1), L2));\n    }\n    function mul_term_by_all_terms(t1, L) {\n        if (is_empty_termlist(L)) {\n            return the_empty_termlist;\n        } else {\n            const t2 = first_term(L);\n            return adjoin_term(\n                       make_term(order(t1) + order(t2),\n                                 mul(coeff(t1), coeff(t2))),\n                       mul_term_by_all_terms(t1, rest_terms(L)));\n        }\n    }\n\n    // interface to rest of the system\n    function tag(p) {\n        return attach_tag(\"polynomial\", p);\n    }\n    put(\"add\", list(\"polynomial\", \"polynomial\"),\n        (p1, p2) => tag(add_poly(p1, p2)));\n    put(\"mul\", list(\"polynomial\", \"polynomial\"),\n        (p1, p2) => tag(mul_poly(p1, p2)));\n    put(\"make\", \"polynomial\",\n        (variable, terms) =>\n            tag(make_poly(variable, terms)));\n    return \"done\";\n}\ninstall_polynomial_package();\n```",
    "token_count": 308,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 8,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_8"
  },
  {
    "content": "Users of the polynomial package will create (tagged) polynomials by means of the function:\n\n```javascript\nmake_polynomial\n      install_javascript_number_package_usage\n      make_polynomial_requires\n      make_polynomial_example\n      [ 3, [ [ 'javascript_number', 23 ], null ] ]\n\nfunction make_polynomial(variable, terms) {\n    return get(\"make\", \"polynomial\")(variable, terms);\n}\n```\n\n```javascript\nmake_polynomial_example\n\nconst p1 = make_polynomial(\"x\",\n               list(make_term(2, make_javascript_number(4)),\n                    make_term(1, make_javascript_number(3)),\n                    make_term(0, make_javascript_number(7))));\nconst p2 = make_polynomial(\"x\",\n               list(make_term(2, make_javascript_number(5)),\n                    make_term(1, make_javascript_number(2)),\n                    make_term(0, make_javascript_number(10))));\n\nmul(p1, p2);\n\nconst p1 = make_polynomial(\"x\",\n               list(list(2, make_javascript_number(4)),\n                    list(1, make_javascript_number(3)),\n                    list(0, make_javascript_number(7))));\nconst p2 = make_polynomial(\"x\",\n               list(list(2, make_javascript_number(5)),\n                    list(1, make_javascript_number(2)),\n                    list(0, make_javascript_number(10))));\n\nhead(tail(tail(tail(mul(p1, p2)))));\n```\n\nOur polynomial system illustrates how objects of one type\n(polynomials) may in fact be complex objects that have objects of many\ndifferent types as parts.\n\nThis poses no real difficulty in defining\ngeneric operations.\n\nWe need only install appropriate generic operations\nfor performing the necessary manipulations of the parts of the\ncompound types.\n\nIn fact, we saw that polynomials form a kind of\nrecursive data abstraction, in that parts of a polynomial may\nthemselves be polynomials.\n\nOur generic operations and our\ndata-directed programming style can handle this complication without\nmuch trouble.\n\nOn the other hand, polynomial algebra is a system for which the data\ntypes cannot be naturally arranged in a tower.\n\nFor instance, it is\npossible to have polynomials in $x$ whose\ncoefficients are polynomials in $y$.\n\nIt is also\npossible to have polynomials in $y$ whose\ncoefficients are polynomials in $x$.\n\nNeither of\nthese types is above the other in any natural way, yet it is\noften necessary to add together elements from each set.\n\nThere are several\nways to do this.\n\nOne possibility is to convert one polynomial to the type\nof the other by expanding and rearranging terms so that both polynomials\nhave the same principal variable.",
    "token_count": 287,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 9,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_9"
  },
  {
    "content": "One possibility is to convert one polynomial to the type\nof the other by expanding and rearranging terms so that both polynomials\nhave the same principal variable.\n\nOne can impose a towerlike structure on\nthis by ordering the variables and thus always converting any polynomial\nto a\ncanonical form with the highest-priority variable\ndominant and the lower-priority variables buried in the coefficients.\n\nThis strategy works fairly well, except that the conversion may expand\na polynomial unnecessarily, making it hard to read and perhaps less\nefficient to work with.\n\nThe tower strategy is certainly not natural\nfor this domain or for any domain where the user can invent new types\ndynamically using old types in various combining forms, such as\ntrigonometric functions, power series, and integrals.\n\nIt should not be surprising that controlling\n\nWe can extend our generic arithmetic system to include rational\nfunctions.\n\nThese are fractions whose numerator and\ndenominator are polynomials, such as\n\\[\n\\begin{array}{l}\n\\dfrac{x+1}{x^3 -1}\n\\end{array}\n\\]\nThe system should be able to add, subtract, multiply, and divide\nrational functions, and to perform such computations as\n\\[\n\\begin{array}{lll}\n\\dfrac{x+1}{x^3 -1}+\\dfrac{x}{x^2 -1} & = & \\dfrac{x^3 +2x^2 +3x +1}{x^4 +\nx^3 -x-1}\n\\end{array}\n\\]\n(Here the sum has been simplified by removing common factors.\n\nOrdinary cross multiplication would have produced a\nfourth-degree polynomial over a fifth-degree polynomial.)\n\nIf we modify our rational-arithmetic package so that it uses generic operations, then it will do what we want, except for the problem of reducing\n\nfractions to lowest terms.\n\nWe can reduce polynomial fractions to lowest terms using the same idea\nwe used with integers: modifying\nmake_rat\nto divide both the numerator and the denominator by their greatest common\ndivisor.\n\nThe notion of\ngreatest common divisor makes sense for polynomials.",
    "token_count": 289,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 10,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_10"
  },
  {
    "content": "The notion of\ngreatest common divisor makes sense for polynomials.\n\nIn\nfact, we can compute the GCD of two polynomials using essentially the\nsame Euclid s Algorithm that works for integers.\n\n```javascript\nfunction gcd(a, b) {\n    return b === 0\n           ? a\n           : gcd(b, a % b);\n}\n```\n\nUsing this, we could make the obvious modification to define a GCD operation that works on term lists:\n\n```javascript\nfunction gcd_terms(a, b) {\n    return is_empty_termlist(b)\n           ? a\n           : gcd_terms(b, remainder_terms(a, b));\n}\n```\n\nwhere remainder_terms picks out the remainder component of the list returned by the term-list division operation div_terms that was implemented in exercise.\n\nWe can solve the problem exhibited in\nexercise if\nwe use the following modification of the GCD algorithm (which really\nworks only in the case of polynomials with integer coefficients).\n\nBefore performing any polynomial division in the GCD computation, we\nmultiply the dividend by an integer constant factor, chosen to\nguarantee that no fractions will arise during the division process.\n\nOur answer will thus differ from the actual GCD by an integer constant\nfactor, but this does not matter in the case of reducing rational\nfunctions to lowest terms; the GCD will be used to divide both the\nnumerator and denominator, so the integer constant factor will cancel\nout.\n\nMore precisely, if $P$ and\n$Q$ are polynomials, let\n$O_1$ be the order of\n$P$ (i.e., the order of the largest term of\n$P$ ) and let $O_2$\nbe the order of $Q$.\n\nLet\n$c$ be the leading coefficient of\n$Q$.\n\nThen it can be shown that, if we multiply\n$P$ by the\nintegerizing factor\n$c^{1+O_{1} -O_{2}}$ , the resulting polynomial\ncan be divided by $Q$ by using the\ndiv_terms\nalgorithm without introducing any fractions.",
    "token_count": 288,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 11,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_11"
  },
  {
    "content": "Then it can be shown that, if we multiply\n$P$ by the\nintegerizing factor\n$c^{1+O_{1} -O_{2}}$ , the resulting polynomial\ncan be divided by $Q$ by using the\ndiv_terms\nalgorithm without introducing any fractions.\n\nThe operation of multiplying\nthe dividend by this constant and then dividing is sometimes called the\npseudodivision of $P$ by\n$Q$.\n\nThe remainder of the division is\ncalled the\npseudoremainder.\n\nThus, here is how to reduce a rational function to lowest terms:\n-\n-\nCompute the GCD of the numerator and denominator, using\nthe version of\ngcd_@terms\nfrom exercise.\n-\n-\nWhen you obtain the GCD, multiply both numerator and\ndenominator by the same integerizing factor before dividing through by\nthe GCD, so that division by the GCD will not introduce any noninteger\ncoefficients.\n\nAs the factor you can use the leading coefficient of\nthe GCD raised to the power\n$1+O_{1} -O_{2}$ , where\n$O_{2}$ is the order of the GCD and\n$O_{1}$ is the maximum of the orders of the\nnumerator and denominator.\n\nThis will ensure that dividing the\nnumerator and denominator by the GCD will not introduce any fractions.\n-\n-\nThe result of this operation will be a numerator and denominator\nwith integer coefficients.\n\nThe coefficients will normally be very\nlarge because of all of the integerizing factors, so the last step is\nto remove the redundant factors by computing the (integer) greatest\ncommon divisor of all the coefficients of the numerator and the\ndenominator and dividing through by this factor.\n\nThe GCD computation is at the heart of any system that does operations\non rational functions.\n\nThe algorithm used above, although\nmathematically straightforward, is extremely slow.\n\nThe slowness is\ndue partly to the large number of division operations and partly to\nthe enormous size of the intermediate coefficients generated by the\npseudodivisions.",
    "token_count": 300,
    "has_code": false,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Example: Symbolic Algebra",
    "chunk_index": 12,
    "chunk_id": "Building_Abstractions_with_Data_Example_Symbolic_Algebra_12"
  },
  {
    "content": "The task of designing generic arithmetic operations is analogous to that of\ndesigning the generic complex-number operations.\n\nWe would like, for\ninstance, to have a generic addition\nfunction\nadd_rat\non rational numbers, and like\nadd_complex\non complex numbers.\n\nWe can implement following the same strategy we\nused in section to implement the\ngeneric selectors for complex numbers.\n\nWe will attach a type tag to each\nkind of number and cause the generic\nfunction\nto dispatch to an appropriate package according to the data type of its\narguments.\n\nThe generic arithmetic functions are defined as follows:\n\n```javascript\nops\n      apply_generic\n\nfunction add(x, y) { return apply_generic(\"add\", list(x, y)); }\n\nfunction sub(x, y) { return apply_generic(\"sub\", list(x, y)); }\n\nfunction mul(x, y) { return apply_generic(\"mul\", list(x, y)); }\n\nfunction div(x, y) { return apply_generic(\"div\", list(x, y)); }\n```\n\nWe begin\nby installing a package for handling\nordinary numbers,\nthat is, the primitive numbers of our language.\n\nWe\ntag these\nwith the\nstring \"javascript_number\".\n\nThe arithmetic operations in this package are the primitive arithmetic\nfunctions\n(so there is no need to define extra\nfunctions\nto handle the untagged numbers).\n\nSince these operations each take two\narguments, they are installed in the table keyed by the list\nlist(\"javascript_number\", \"javascript_number\"):\n\n```javascript\ninstall_javascript_number_package\n      ops\n      operation_table_from_chapter_3\n      operation_table\n      attach_tag\n\nfunction install_javascript_number_package() {\n    function tag(x) {\n        return attach_tag(\"javascript_number\", x);\n    }\n    put(\"add\", list(\"javascript_number\", \"javascript_number\"),\n        (x, y) => tag(x + y));\n    put(\"sub\", list(\"javascript_number\", \"javascript_number\"),\n        (x, y) => tag(x - y));\n    put(\"mul\", list(\"javascript_number\", \"javascript_number\"),\n        (x, y) => tag(x * y));\n    put(\"div\", list(\"javascript_number\", \"javascript_number\"),\n        (x, y) => tag(x / y));\n    put(\"make\", \"javascript_number\",\n        x => tag(x));\n    return \"done\";\n}\n```\n\nUsers of the JavaScript-number package will create (tagged) ordinary numbers by means of the function:\n\n```javascript\nactually_install_javascript_number_package\n\ninstall_javascript_number_package();\n```\n\n```javascript\ninstall_javascript_number_package_usage\n      install_javascript_number_package\n      actually_install_javascript_number_package\n      install_javascript_number_package_usage_example\n      [ 'javascript_number', 9 ]\n\nfunction make_javascript_number(n) {\n    return get(\"make\", \"javascript_number\")(n);\n}\n```",
    "token_count": 301,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Generic Arithmetic Operations",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Data_Generic_Arithmetic_Operations_1"
  },
  {
    "content": "Users of the JavaScript-number package will create (tagged) ordinary numbers by means of the function:\n\n```javascript\ninstall_javascript_number_package_usage_example\n\nconst n1 = make_javascript_number(4);\nconst n2 = make_javascript_number(5);\n\nadd(n1, n2);\n```\n\nNow that the framework of the generic arithmetic system is in place,\nwe can readily include new kinds of numbers.\n\nHere is a package that\nperforms rational arithmetic.\n\nNotice that, as a benefit of\nadditivity, we can use without modification the rational-number code\nfrom section as the internal\nfunctions\nin the package:\n\n```javascript\nbenefit_of_additivity\n      ops\n      operation_table_from_chapter_3\n      operation_table\n      attach_tag\n      gcd_definition\n      benefit_of_additivity_example\n      [ 'rational', [ 11, 15 ] ]\n\nfunction install_rational_package() {\n    // internal functions\n    function numer(x) { return head(x); }\n    function denom(x) { return tail(x); }\n    function make_rat(n, d) {\n        const g = gcd(n, d);\n        return pair(n / g, d / g);\n    }\n    function add_rat(x, y) {\n        return make_rat(numer(x) * denom(y) + numer(y) * denom(x),\n                        denom(x) * denom(y));\n    }\n    function sub_rat(x, y) {\n        return make_rat(numer(x) * denom(y) - numer(y) * denom(x),\n                        denom(x) * denom(y));\n    }\n    function mul_rat(x, y) {\n        return make_rat(numer(x) * numer(y),\n                        denom(x) * denom(y));\n    }\n    function div_rat(x, y) {\n        return make_rat(numer(x) * denom(y),\n                        denom(x) * numer(y));\n    }\n    // interface to rest of the system\n    function tag(x) {\n        return attach_tag(\"rational\", x);\n    }\n    put(\"add\", list(\"rational\", \"rational\"),\n        (x, y) => tag(add_rat(x, y)));\n    put(\"sub\", list(\"rational\", \"rational\"),\n        (x, y) => tag(sub_rat(x, y)));\n    put(\"mul\", list(\"rational\", \"rational\"),\n        (x, y) => tag(mul_rat(x, y)));\n    put(\"div\", list(\"rational\", \"rational\"),\n        (x, y) => tag(div_rat(x, y)));\n    put(\"make\", \"rational\",\n        (n, d) => tag(make_rat(n, d)));\n    return \"done\";\n}\n\nfunction make_rational(n, d) {\n    return get(\"make\", \"rational\")(n, d);\n}\n```\n\n```javascript\nbenefit_of_additivity_example\n\ninstall_rational_package();\n\nconst r1 = make_rational(1, 3);\nconst r2 = make_rational(2, 5);\n\nadd(r1, r2);\n```\n\nWe can install a similar package to handle complex numbers, using the tag\n\"complex\".",
    "token_count": 282,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Generic Arithmetic Operations",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Data_Generic_Arithmetic_Operations_2"
  },
  {
    "content": "We can install a similar package to handle complex numbers, using the tag\n\"complex\".\n\nIn creating the package, we extract from the table the operations\nmake_from_real_imag\nand\nmake_from_mag_ang\nthat were defined by the rectangular and polar packages.\nadd_complex,\nsub_complex,\nmul_complex,\nand\ndiv_complex\nfunctions\nfrom section.\n\n```javascript\ninstall_complex_package\n      ops\n      generic_selectors\n      operation_table_from_chapter_3\n      operation_table\n      install_rectangular_package\n      install_rectangular_package_usage\n      install_polar_package_usage\n      attach_tag\n      actually_install_complex_package\n      'done'\n\nfunction install_complex_package() {\n    // imported functions from rectangular and polar packages\n    function make_from_real_imag(x, y) {\n        return get(\"make_from_real_imag\", \"rectangular\")(x, y);\n    }\n    function make_from_mag_ang(r, a) {\n        return get(\"make_from_mag_ang\", \"polar\")(r, a);\n    }\n    // internal functions\n    function add_complex(z1, z2) {\n        return make_from_real_imag(real_part(z1) + real_part(z2),\n                                   imag_part(z1) + imag_part(z2));\n    }\n    function sub_complex(z1, z2) {\n        return make_from_real_imag(real_part(z1) - real_part(z2),\n                                   imag_part(z1) - imag_part(z2));\n    }\n    function mul_complex(z1, z2) {\n        return make_from_mag_ang(magnitude(z1) * magnitude(z2),\n                                 angle(z1) + angle(z2));\n    }\n    function div_complex(z1, z2) {\n        return make_from_mag_ang(magnitude(z1) / magnitude(z2),\n                                 angle(z1) - angle(z2));\n    }\n    // interface to rest of the system\n    function tag(z) { return attach_tag(\"complex\", z); }\n    put(\"add\", list(\"complex\", \"complex\"),\n        (z1, z2) => tag(add_complex(z1, z2)));\n    put(\"sub\", list(\"complex\", \"complex\"),\n        (z1, z2) => tag(sub_complex(z1, z2)));\n    put(\"mul\", list(\"complex\", \"complex\"),\n        (z1, z2) => tag(mul_complex(z1, z2)));\n    put(\"div\", list(\"complex\", \"complex\"),\n        (z1, z2) => tag(div_complex(z1, z2)));\n    put(\"make_from_real_imag\", \"complex\",\n        (x, y) => tag(make_from_real_imag(x, y)));\n    put(\"make_from_mag_ang\", \"complex\",\n        (r, a) => tag(make_from_mag_ang(r, a)));\n    return \"done\";\n}\n```\n\nPrograms outside the complex-number package can construct complex\nnumbers either from real and imaginary parts or from magnitudes and\nangles.\n\nNotice how the underlying\nfunctions,\noriginally defined in the rectangular and polar packages, are exported to\nthe complex package, and exported from there to the outside world.\n\n```javascript\nactually_install_complex_package\n\ninstall_complex_package();\n```\n\n```javascript\ninstall_complex_package_usage\n      install_complex_package\n      actually_install_complex_package\n      [ 'rectangular', [ 8.387912809451864, 5.397127693021015 ] ]\n      install_complex_package_example\n\nfunction make_complex_from_real_imag(x, y){\n   return get(\"make_from_real_imag\", \"complex\")(x, y);\n}\nfunction make_complex_from_mag_ang(r, a){\n   return get(\"make_from_mag_ang\", \"complex\")(r, a);\n}\n```",
    "token_count": 281,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Generic Arithmetic Operations",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Data_Generic_Arithmetic_Operations_3"
  },
  {
    "content": "Notice how the underlying\nfunctions,\noriginally defined in the rectangular and polar packages, are exported to\nthe complex package, and exported from there to the outside world.\n\n```javascript\ninstall_complex_package_example\n\nconst r = make_complex_from_real_imag(4, 3);\nconst p = make_complex_from_mag_ang(5, 0.5);\n\nadd(r, p);    // results in a complex number in rectangular coordinates\n// mul(r, p); // results in a complex number in polar coordinates\n\nconst r = make_complex_from_real_imag(4, 3);\nconst p = make_complex_from_mag_ang(5, 0.5);\ntail(add(r, p));\n```\n\nWhat we have here is a\n$3+4i$ in rectangular form, would be\nrepresented as shown in\nfigure.\n\nThe outer tag\n(\"complex\")\nis used to direct the number to the complex package.\n\nOnce within the\ncomplex package, the next tag\n(\"rectangular\")\nis used to direct the number to the rectangular package.\n\nIn a large and\ncomplicated system there might be many levels, each interfaced with the\nnext by means of generic operations.\n\nAs a data object is passed\ndownward, the outer tag that is used to direct it to the\nappropriate package is stripped off (by applying\n\n```javascript\nRepresentation of $3+4i$ in\n\t    rectangular form.\n```\n\nIn the above packages, we used\nadd_rat,\nadd_complex,\nand the other arithmetic\nfunctions\nexactly as originally written.\n\nOnce these declarations are internal to\ndifferent installation\nfunctions,\nhowever, they no longer need names that are distinct from each other:\nwe could simply name them",
    "token_count": 222,
    "has_code": true,
    "chapter": "Building Abstractions with Data",
    "section": "Systems with Generic Operations",
    "subsection": "Generic Arithmetic Operations",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Data_Generic_Arithmetic_Operations_4"
  },
  {
    "content": "We are about to study the idea of a\ncomputational process.\ndata.\nprogram.\n\nPeople create programs to direct processes.\n\nIn effect, we conjure the spirits of the computer with our spells.\n\nA computational process is indeed much like a sorcerer s idea of a\nspirit.\n\nIt cannot be seen or touched.\n\nIt is not composed of matter\nat all.\n\nHowever, it is very real.\n\nIt can perform intellectual work.\n\nIt can answer questions.\n\nIt can affect the world by disbursing money\nat a bank or by controlling a robot arm in a factory.\n\nThe programs we\nuse to conjure processes are like a sorcerer s spells.\n\nThey are\ncarefully composed from symbolic expressions in arcane and esoteric\nprogramming languages\n\nA computational process, in a correctly working computer, executes\nprograms precisely and accurately.\n\nThus, like the sorcerer s\napprentice, novice programmers must learn to understand and to\nanticipate the consequences of their conjuring.\n\nEven small errors\n(usually called bugs)\nin programs can have complex and unanticipated consequences.\n\nFortunately, learning to program is considerably less dangerous than\nlearning sorcery, because the spirits we deal with are conveniently\ncontained in a secure way.\n\nReal-world programming, however,\nrequires care, expertise, and wisdom.\n\nA small bug in a computer-aided\ndesign program, for example, can lead to the catastrophic collapse of\nan airplane or a dam or the self-destruction of an industrial robot.\n\nMaster software engineers have the ability to organize programs so\nthat they can be reasonably sure that the resulting processes will\nperform the tasks intended.\n\nThey can visualize the behavior of their\nsystems in advance.\n\nThey know how to structure programs so that\nunanticipated problems do not lead to catastrophic consequences, and\nwhen problems do arise, they can\ndebug\ntheir programs.",
    "token_count": 288,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": null,
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Building_Abstractions_with_Functions_1"
  },
  {
    "content": "They know how to structure programs so that\nunanticipated problems do not lead to catastrophic consequences, and\nwhen problems do arise, they can\ndebug\ntheir programs.\n\nWell-designed\ncomputational systems, like well-designed automobiles or nuclear\nreactors, are designed in a modular manner, so that the parts can be\nconstructed, replaced, and debugged separately.\n\nWe need an appropriate language for describing processes, and we will\nuse for this purpose the programming language JavaScript.\n\nJust as our\neveryday thoughts are usually expressed in our natural language (such\nas English, Swedish, or Chinese), and descriptions of quantitative\nphenomena are expressed with mathematical notations, our procedural\nthoughts will be expressed in JavaScript.\n\nMocha , which\nwas later renamed to LiveScript , and finally to JavaScript.\n\nJavaScript is a trademark\nof Oracle Corporation.\n\nDespite its inception as a language for scripting the web, JavaScript interpreter is a machine that carries out processes described in the JavaScript language.\n\nJavaScript bears only superficial resemblance to the language Java,\nafter which it was\n(eventually) named; both Java and JavaScript use the block structure of\nthe language C.\n\nIn contrast with Java and C, which usually\nemploy compilation to lower-level\nlanguages, JavaScript programs were initially\ninterpreted\nby web browsers.\ns Internet Explorer, whose\nJavaScript version is called\nJScript.\n\nThe popularity of JavaScript for controlling web\nbrowsers gave rise to a standardization effort, culminating in\nECMAScript.\n\nThe\nand completed in June 1997\n(\n\nThe practice of embedding JavaScript programs in web pages encouraged\nthe developers of web browsers to implement JavaScript interpreters.\n\nAs these programs became more complex,\nthe interpreters became more efficient in executing them, eventually\nusing sophisticated implementation techniques such as Just-In-Time\n(JIT) compilation.",
    "token_count": 275,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": null,
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Building_Abstractions_with_Functions_2"
  },
  {
    "content": "As these programs became more complex,\nthe interpreters became more efficient in executing them, eventually\nusing sophisticated implementation techniques such as Just-In-Time\n(JIT) compilation.\n\nThe majority of JavaScript programs as of this writing (2021) are embedded\nin web pages and interpreted by browsers, but JavaScript is increasingly\nused as a general-purpose programming language, using systems such as\nNode.js.",
    "token_count": 58,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": null,
    "subsection": null,
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Building_Abstractions_with_Functions_3"
  },
  {
    "content": "We have seen that\nfunctions\nare, in effect, abstractions that describe compound operations on\nnumbers independent of the particular numbers.\n\nFor example, when we\ndeclare\n\n```javascript\ncube_definition\n          cube_example\n\nfunction cube(x) {\n    return x * x * x;\n}\n```\n\n```javascript\ncube_example\n\t  27\n          cube_definition\n\ncube(3);\n```\n\nwe are not talking about the cube of a particular number, but rather\nabout a method for obtaining the cube of any number.\n\nOf course we could\nget along without ever\ndeclaring this function,\nby always writing expressions such as\n\n```javascript\n3 * 3 * 3\nx * x * x\ny * y * y\n```\n\nand never mentioning\nFunctions\nprovide this ability.\n\nThis is why all but the most primitive\nprogramming languages include mechanisms for\ndeclaring functions.\n\nYet even in numerical processing we will be severely limited in our\nability to create abstractions if we are restricted to\nfunctions\nwhose parameters must be numbers.\n\nOften the same programming pattern\nwill be used with a number of different\nfunctions.\n\nTo express such patterns as concepts, we will need to construct\nfunctions\nthat can accept\nfunctions\nas arguments or return\nfunctions\nas values.\n\nFunctions\nthat manipulate\nfunctions\nare called\nhigher-order functions.\n\nThis section shows how higher-order\nfunctions\ncan serve as powerful abstraction mechanisms, vastly increasing the\nexpressive power of our language.",
    "token_count": 216,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Formulating_Abstractions_with_Higher-Order_Functions_1"
  },
  {
    "content": "```javascript\nIn using sum as in\n\tsection, it seems\n\tterribly awkward to have to declare trivial functions such as\n        pi_term and\n\tpi_next just so we can use them as\n\targuments to our higher-order function. Rather than declare\n\tpi_next and\n        pi_term, it would be more convenient\n        to have a way to directly specify the function that returns its\n        input incremented by 4 and the function that returns the\n        reciprocal of its input times its input plus 2.  We can do this\n\tby introducing the lambda expression as a syntactic form for\n\tcreating functions.\n\tUsing lambda expressions, we can describe what we want as\n\nx => x + 4\n\n        and\n\nx => 1 / (x * (x + 2))\n```\n\n```javascript\nThen we can express our\n\tpi_sum\n\tfunction\n```\n\nwithout declaring any auxiliary functions:\n\n```javascript\npi_sum_definition3\n      3.139592655589783\n      sum_definition\n      pi_sum_example\n      3.139592655589783\n\nfunction pi_sum(a, b) {\n    return sum(x => 1 / (x * (x + 2)),\n               a,\n               x => x + 4,\n               b);\n}\n```\n\nAgain using a lambda expression, we can write the function without having to declare the auxiliary function add_dx:\n\n```javascript\nintegral_example_2\n\nintegral(cube, 0, 1, 0.01);\n```\n\n```javascript\nintegral_definition2\n      sum_definition\n      cube_definition\n      integral_example_2\n      0.24998750000000042\n\nfunction integral(f, a, b, dx) {\n    return sum(f,\n               a + dx / 2,\n               x => x + dx,\n               b)\n           *\n           dx;\n}\n```\n\n```javascript\nIn general, lambda expressions are used to create functions in the\n\tsame way as function declarations,\n\treturn keyword and braces are omitted\n\t(if there is only one\n\tparameter, the\n\n(parameters) => expression\n\n\tThe resulting function is just as much a function\n\tas one that is created using a function declaration statement.\n```\n\nWe consider\n\n```javascript\nplus4_definition_1\n      plus4_example\n\nfunction plus4(x) {\n    return x + 4;\n}\n```\n\n```javascript\nplus4_example\n\nplus4(3);\n```\n\n```javascript\nto be\n\tequivalent to\n```\n\n```javascript\nplus4_definition_2\n      plus4_example\n\nconst plus4 = x => x + 4;\n```",
    "token_count": 304,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Constructing Functions using Lambda Expressions",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Constructing_Functions_using_Lambda_Expressions_1"
  },
  {
    "content": "We consider\n\n```javascript\nWe can read a lambda expression as follows:\n\n\\begin{flushleft}\\normalcodesize\n\\begin{tabular}{@{}ccccc}\n   \\tt x & \\tt =>  & \\tt x & \\tt + & \\tt 4 \\\\\n  $\\Big\\uparrow$ & $\\Big\\uparrow$ & $\\Big\\uparrow$ & $\\Big\\uparrow$ & $\\Big\\uparrow$ \\\\[4pt]\n  \\normalsize The function of an argument \\small\\tt x & \\normalsize that results in & \\normalsize the value & \\normalsize plus & \\normalsize 4. \\\\\n\\end{tabular}\n\\end{flushleft}\n```\n\nLike any expression that has a function as its value, a lambda expression can be used as the function expression in an application such as\n\n```javascript\nsquare_definition\n      12\n\n((x, y, z) => x + y + square(z))(1, 2, 3);\n```\n\nor, more generally, in any context where we would normally use a function name.\n\n```javascript\nNote that =>\n  has\n```\n\nAnother use of lambda expressions is in creating local names.\n\n```javascript\nWe often need local names in our functions\n\tother than those that have been bound as parameters.\n```\n\nFor example, suppose we wish to compute the function\n\\[\\begin{array}{lll}\nf(x, y)&=&x(1 + x y)^2 +y (1 - y) + (1 + x y)(1 - y)\n\\end{array}\\]\nwhich we could also express as\n\\[\\begin{array}{rll}\na &=& 1+xy\\\\\nb &=& 1-y\\\\\nf(x, y) &= &x a^2 +y b + a b\n\\end{array}\\]\nIn writing a\nfunction\nto compute $f$ , we would like to include as\nlocal names\nnot only $x$ and $y$\nbut also the names of intermediate quantities like\n$a$ and $b$.\n\nOne way\nto accomplish this is to use an auxiliary\nfunction to bind the local names:\n\n```javascript\nf_helper_definition\n      square_definition\n      f_helper_example\n      456\n\nfunction f(x, y) {\n    function f_helper(a, b) {\n        return x * square(a) + y * b + a * b;\n    }\n    return f_helper(1 + x * y, 1 - y);\n}\n```\n\n```javascript\nf_helper_example\n\nf(3, 4);\n```",
    "token_count": 295,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Constructing Functions using Lambda Expressions",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Constructing_Functions_using_Lambda_Expressions_2"
  },
  {
    "content": "One way\nto accomplish this is to use an auxiliary\nfunction to bind the local names:\n\nOf course, we could use a\nlambda\nexpression to specify an anonymous\nfunction for binding our local names.\n\nThe\nfunction body\nthen becomes a single call to that\nfunction:\n\n```javascript\nf_helper_definition2\n      square_definition\n      f_2_helper_example\n      456\n\nfunction f_2(x, y) {\n    return ( (a, b) => x * square(a) + y * b + a * b\n           )(1 + x * y, 1 - y);\n}\n```\n\n```javascript\nf_2_helper_example\n\nf_2(3, 4);\n```\n\n```javascript\nconst, the  function\n\n\tcan be written as\n\n          f_helper_definition3\n          square_definition\n          f_3_helper_example\n\t  456\n\nfunction f_3(x, y) {\n    const a = 1 + x * y;\n    const b = 1 - y;\n    return x * square(a) + y * b + a * b;\n}\n\n\t  f_3_helper_example\n\nf_3(3, 4);\n\n      Names that are declared with\n      const inside a block have the\n      body of the immediately surrounding block as their scope.$^,$\n```\n\nConditional statements\nWe have seen that it is often useful to declare names that are local to\nfunction declarations.\n\nWhen functions become big, we should\nkeep the scope of the names as narrow as possible.\n\nConsider for example expmod in\nexercise.\n\n```javascript\nexpmod_definition_2\n        even_definition\n        expmod_example_2\n\t4\n\nfunction expmod(base, exp, m) {\n    return exp === 0\n           ? 1\n           : is_even(exp)\n           ? (  expmod(base, exp / 2, m)\n              * expmod(base, exp / 2, m)) % m\n           : (base * expmod(base, exp - 1, m)) % m;\n}\n```\n\nThis function is unnecessarily inefficient, because it contains two identical calls:\n\n```javascript\nexpmod_example_2\n        even_definition\n        expmod_definition_2\n\nexpmod(base, exp / 2, m);\n\nexpmod(4, 3, 5);\n```\n\nWhile this can be easily fixed in this example using the\nsquare function, this is not so easy\nin general.\n\nWithout using square ,\nwe would be tempted to introduce a local name for the expression as\nfollows:",
    "token_count": 300,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Constructing Functions using Lambda Expressions",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Constructing_Functions_using_Lambda_Expressions_3"
  },
  {
    "content": "Without using square ,\nwe would be tempted to introduce a local name for the expression as\nfollows:\n\n```javascript\neven_definition\n        expmod_example\n\nfunction expmod(base, exp, m) {\n    const half_exp = expmod(base, exp / 2, m);\n    return exp === 0\n           ? 1\n           : is_even(exp)\n           ? (half_exp * half_exp) % m\n           : (base * expmod(base, exp - 1, m)) % m;\n}\n```\n\nexp === 0 is met.\n\nTo avoid this situation, we provide for\nconditional statements , and allow return\nstatements to appear in the branches of the statement.\n\nUsing a\nconditional statement, we can write the function\nexpmod as follows:\n\n```javascript\neven_definition\n        expmod_example\n\t4\n\nfunction expmod(base, exp, m) {\n    if (exp === 0) {\n        return 1;\n    } else {\n        if (is_even(exp)) {\n            const half_exp = expmod(base, exp / 2, m);\n            return (half_exp * half_exp) % m;\n        } else {\n            return (base * expmod(base, exp - 1, m)) % m;\n        }\n    }\n}\n```\n\nThe general form of a conditional statement is\n\n```javascript\nif (predicate) { consequent-statements } else { alternative-statements }\n```\n\nAs for a conditional expression, the interpreter first evaluates the\npredicate.\n\nIf it evaluates to true,\nthe interpreter evaluates the\nconsequent-statements in sequence, and if it\nevaluates to false, the interpreter evaluates\nalternative-statements in sequence.\n\nEvaluation of a return\nstatement returns from the surrounding function, ignoring any\nstatements in the sequence\n\nLet's use the substitution model to illustrate what happens:\n\n```javascript\nf(f)\nf(2)\n2(2)\n```\n\nThe application 2(2) leads to an error, since 2 is neither a primitive nor a compound function.",
    "token_count": 253,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Constructing Functions using Lambda Expressions",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Functions_Constructing_Functions_using_Lambda_Expressions_4"
  },
  {
    "content": "Consider the following three\nfunctions.\n\nThe first computes the sum of the integers from\n\n```javascript\nsum_integers_definition\n      sum_integers_example\n      55\n\nfunction sum_integers(a, b) {\n    return a > b\n           ? 0\n           : a + sum_integers(a + 1, b);\n}\n```\n\n```javascript\nsum_integers_example\n\nsum_integers(1, 10);\n```\n\nThe second computes the sum of the cubes of the integers in the given range:\n\n```javascript\nsum_cubes_definition\n      cube_definition\n      sum_cubes_example\n      775\n\nfunction sum_cubes(a, b) {\n    return a > b\n           ? 0\n           : cube(a) + sum_cubes(a + 1, b);\n}\n```\n\n```javascript\nsum_cubes_example\n\nsum_cubes(3, 7);\n```\n\nThe third computes the sum of a sequence of terms in the series \\[ \\frac{1}{1\\cdot3}+\\frac{1}{5\\cdot7}+\\frac{1}{9\\cdot11}+\\cdots \\] which converges to $\\pi/8$ (very slowly):\n\n```javascript\npi_sum_definition\n      pi_sum_example\n      3.139592655589783\n\nfunction pi_sum(a, b) {\n    return a > b\n           ? 0\n           : 1 / (a * (a + 2)) + pi_sum(a + 4, b);\n}\n```\n\n```javascript\npi_sum_example\n\n8 * pi_sum(1, 1000);\n```\n\nThese three\nfunctions\nclearly share a common underlying pattern.\n\nThey are for the most part\nidentical, differing only in the name of the\nfunction,\nthe function of\nfunctions\nby filling in slots in the same template:\n\n```javascript\nfunction name(a, b) {\n    return a > b\n           ? 0\n           : term(a) + name(next(a), b);\n}\n```\n\nThe presence of such a common pattern is strong evidence that there is a\nuseful\nsummation of a series and invented sigma\nnotation, for example\n\\[\\begin{array}{lll}\n\\displaystyle\\sum_{n=a}^{b}\\ f(n)&=&f(a)+\\cdots+f(b)\n\\end{array}\\]\nto express this concept.\n\nThe power of sigma notation is that it allows\nmathematicians to deal with the concept of summation itself rather than only\nwith particular sums for example, to formulate general results about\nsums that are independent of the particular series being summed.\n\nSimilarly, as program designers, we would like our language to be powerful\nenough so that we can write a\nfunction\nthat expresses the concept of summation itself rather than only\nfunctions\nthat compute particular sums.",
    "token_count": 307,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as Arguments",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Arguments_1"
  },
  {
    "content": "Similarly, as program designers, we would like our language to be powerful\nenough so that we can write a\nfunction\nthat expresses the concept of summation itself rather than only\nfunctions\nthat compute particular sums.\n\nWe can do so readily in our\nfunctional\nlanguage by taking the common template shown above and transforming the\nslots into\nparameters:\n\n```javascript\nsum_definition\n\nfunction sum(term, a, next, b) {\n    return a > b\n           ? 0\n           : term(a) + sum(term, next(a), next, b);\n}\n```\n\nNotice that\nfunctions\nfunction.\n\nFor example, we can use it (along with a\nfunction\nsum_cubes:\n\n```javascript\ninc_definition\n\nfunction inc(n) {\n    return n + 1;\n}\n```\n\n```javascript\nsum_example\n      cube_definition\n      sum_definition\n      sum_example_example\n      3025\n\nfunction inc(n) {\n    return n + 1;\n}\nfunction sum_cubes(a, b) {\n    return sum(cube, a, inc, b);\n}\n```\n\nUsing this, we can compute the sum of the cubes of the integers from 1 to 10:\n\n```javascript\nsum_example_example\n      sum_example\n\nsum_cubes(1, 10);\n```\n\nWith the aid of an identity function to compute the term, we can define sum_@integers in terms of\n\n```javascript\nidentity\n      identity_example\n\nfunction identity(x) {\n    return x;\n}\n```\n\n```javascript\nidentity_example\n\nidentity(42);\n```\n\n```javascript\nsum_integers_definition2\n      sum_definition\n      inc_definition\n      identity\n      sum_integers_example2\n      55\n\nfunction sum_integers(a, b) {\n    return sum(identity, a, inc, b);\n}\n```\n\nThen we can add up the integers from 1 to 10:\n\n```javascript\nsum_integers_example2\n      sum_integers_definition2\n\nsum_integers(1, 10);\n```\n\nWe can also define pi_sum in the same way:\n\n```javascript\npi_sum_definition2\n      sum_definition\n      pi_sum_example2\n      3.139592655589783\n\nfunction pi_sum(a, b) {\n    function pi_term(x) {\n        return 1 / (x * (x + 2));\n    }\n    function pi_next(x) {\n        return x + 4;\n    }\n    return sum(pi_term, a, pi_next, b);\n}\n```\n\nUsing these functions, we can compute an approximation to $\\pi$ :\n\n```javascript\npi_sum_example2\n      pi_sum_definition2\n\n8 * pi_sum(1, 1000);\n```",
    "token_count": 285,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as Arguments",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Arguments_2"
  },
  {
    "content": "Using these functions, we can compute an approximation to $\\pi$ :\n\nOnce we have $f$ between the\nlimits $a$ and $b$ can\nbe approximated numerically using the formula\n\\[\n\\begin{array}{lll}\n\\displaystyle\\int_{a}^{b}f & = &\n\\left[\\,f\\!\\left( a+\\dfrac{dx}{2} \\right)\\,+\\,f\\!\\left(a+dx+\\dfrac{dx}{2}\n\\right)\\,+\\,f\\!\\left( a+2dx+\\dfrac{dx}{2}\\right)\\,+\\,\\cdots\n\\right] dx\n\\end{array}\n\\]\nfor small values of $dx$.\n\nWe can express this\ndirectly as a\nfunction:\n\n```javascript\nintegral_definition\n      sum_definition\n      integral_example\n      0.24998750000000042\n\nfunction integral(f, a, b, dx) {\n    function add_dx(x) {\n        return x + dx;\n    }\n    return sum(f, a + dx / 2, add_dx, b) * dx;\n}\n```\n\n```javascript\nintegral_example\n      cube_definition\n      integral_definition\n\nintegral(cube, 0, 1, 0.01);\n```\n\n```javascript\nintegral_example2\n      cube_definition\n      integral_definition\n\nintegral(cube, 0, 1, 0.001);\n\n// dare to try 0.001 with in browser?\nintegral(cube, 0, 1, 0.002);\n```\n\n(The exact value of the integral of",
    "token_count": 125,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as Arguments",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Arguments_3"
  },
  {
    "content": "We introduced compound\nfunctions\nin section as a mechanism for\nabstracting patterns of numerical operations so as to make them independent\nof the particular numbers involved.\n\nWith higher-order\nfunctions,\nsuch as\nthe\nfunction\nof section , we began to\nsee a more powerful kind of abstraction:\nfunctions\nused to express general methods of computation, independent of the\nparticular functions involved.\n\nIn this section we discuss two more elaborate\nexamples general methods for finding zeros and fixed points of\nfunctions and show how these methods can be expressed directly as\nfunctions.\n\nThe\nhalf-interval method is a simple but powerful technique for\nfinding roots of an equation $f(x)=0$ , where\n$f$ is a continuous function.\n\nThe idea is that,\nif we are given points $a$ and\n$b$ such that\n$f(a) < 0 < f(b)$ , then\n$f$ must have at least one zero between\n$a$ and $b$.\n\nTo locate\na zero, let $x$ be the average of\n$a$ and $b$ and\ncompute $f(x)$.\n\nIf\n$f(x) > 0$ , then\n$f$ must have a zero between\n$a$ and $x$.\n\nIf\n$f(x) < 0$ , then\n$f$ must have a zero between\n$x$ and $b$.\n\nContinuing in this way, we can identify smaller and smaller intervals on\nwhich $f$ must have a zero.\n\nWhen we reach a\npoint where the interval is small enough, the process stops.\n\nSince the\ninterval of uncertainty is reduced by half at each step of the process, the\nmaximal number of steps required grows as\n$\\Theta(\\log( L/T))$ , where\n$L$ is the length of the original interval and\n$T$ is the error tolerance (that is, the size of\nthe interval we will consider small enough ).\n\nHere is a\nfunction that implements this strategy:",
    "token_count": 285,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as General Methods",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_General_Methods_1"
  },
  {
    "content": "Here is a\nfunction that implements this strategy:\n\n```javascript\npositive_negative_definition\n\nfunction positive(x) { return x > 0; }\nfunction negative(x) { return x < 0; }\n```\n\n```javascript\nsearch_definition\n      average_definition\n      positive_negative_definition\n      close_enough_definition\n      search_example\n      1\n\nfunction search(f, neg_point, pos_point) {\n    const midpoint = average(neg_point, pos_point);\n    if (close_enough(neg_point, pos_point)) {\n        return midpoint;\n    } else {\n        const test_value = f(midpoint);\n        return positive(test_value)\n               ? search(f, neg_point, midpoint)\n               : negative(test_value)\n               ? search(f, midpoint, pos_point)\n               : midpoint;\n    }\n}\n```\n\n```javascript\nsearch_example\n\nsearch(x => x * x - 1, 0, 2);\n```\n\nWe assume that we are initially given the function\n$f$ together with points at which its values are\nnegative and positive.\n\nWe first compute the midpoint of the two given\npoints.\n\nNext we check to see if the given interval is small enough, and if\nso we simply return the midpoint as our answer.\n\nOtherwise, we compute as a\ntest value the value of $f$ at the midpoint.\n\nIf\nthe test value is positive, then we continue the process with a new interval\nrunning from the original negative point to the midpoint.\n\nIf the test value\nis negative, we continue with the interval from the midpoint to the positive\npoint.\n\nFinally, there is the possibility that the test value is 0, in\nwhich case the midpoint is itself the root we are searching for.\n\nTo test whether the endpoints are close enough we can use a\nfunction\nsimilar to the one used in section for\ncomputing square roots:\n\n```javascript\nclose_enough_definition\n      abs_definition\n      close_enough_example\n      false\n\nfunction close_enough(x, y) {\n    return abs(x - y) < 0.001;\n}\n```\n\n```javascript\nclose_enough_example\n\nclose_enough(7.7654, 7.7666);\n```\n\n```javascript\nThe function\n\tsearch\n```\n\nis awkward to use directly, because we can accidentally give it points at\nwhich $f$ s values do not have the required\nsign, in which case we get a wrong answer.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as General Methods",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_General_Methods_2"
  },
  {
    "content": "is awkward to use directly, because we can accidentally give it points at\nwhich $f$ s values do not have the required\nsign, in which case we get a wrong answer.\n\nInstead we will use\nfunction,\nwhich checks to see which of the endpoints has a negative function value and\nwhich has a positive value, and calls the\nfunction\naccordingly.\n\nIf the function has the same sign on the two given points, the\nhalf-interval method cannot be used, in which case the\nfunction\nsignals an error.\n\n```javascript\nhalf_definition\n      search_definition\n      half_example\n      3.14111328125\n\nfunction half_interval_method(f, a, b) {\n    const a_value = f(a);\n    const b_value = f(b);\n    return negative(a_value) && positive(b_value)\n           ? search(f, a, b)\n           : negative(b_value) && positive(a_value)\n           ? search(f, b, a)\n           : error(\"values are not of opposite sign\");\n}\n```\n\nThe following example uses the $\\pi$ as the root between 2 and 4 of $\\sin\\, x = 0$ :\n\n```javascript\nhalf_example\n      half_definition\n\nhalf_interval_method(math_sin, 2, 4);\n```\n\nHere is another example, using the half-interval method to search for a root of the equation $x^3 - 2x - 3 = 0$ between 1\n\nand 2:\n\n```javascript\nhalf_example2\n      half_definition\n      1.89306640625\n\nhalf_interval_method(x => x * x * x - 2 * x - 3, 1, 2);\n```\n\nA number $x$ is called a\nfixed point of a\nfunction $f$ if $x$\nsatisfies the equation $f(x)=x$.\n\nFor some\nfunctions $f$ we can locate a fixed point by\nbeginning with an initial guess and applying $f$\nrepeatedly,\n\\[\n\\begin{array}{l}\nf(x), \\ f(f(x)), \\ f(f(f(x))), \\ \\ldots\n\\end{array}\n\\]\nuntil the value does not change very much.\n\nUsing this idea, we can devise a\nfunction\nfixed_point\nthat takes as inputs a function and an initial guess and produces an\napproximation to a fixed point of the function.",
    "token_count": 289,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as General Methods",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_General_Methods_3"
  },
  {
    "content": "Using this idea, we can devise a\nfunction\nfixed_point\nthat takes as inputs a function and an initial guess and produces an\napproximation to a fixed point of the function.\n\nWe apply the function\nrepeatedly until we find two successive values whose difference is less\nthan some prescribed tolerance:\n\n```javascript\nfixed_definition\n      abs_definition\n      fixed_example\n      0.7390822985224023\n\nconst tolerance = 0.00001;\nfunction fixed_point(f, first_guess) {\n    function close_enough(x, y) {\n        return abs(x - y) < tolerance;\n    }\n    function try_with(guess) {\n        const next = f(guess);\n        return close_enough(guess, next)\n               ? next\n               : try_with(next);\n    }\n    return try_with(first_guess);\n}\n```\n\nFor example, we can use this method to approximate the fixed point of the\n\n```javascript\nfixed_example\n      fixed_definition\n\nfixed_point(math_cos, 1);\n```\n\nSimilarly, we can find a solution to the equation $y=\\sin y + \\cos y$ :\n\n```javascript\nfixed_example2\n      fixed_definition\n      1.2587315962971173\n\nfixed_point(y => math_sin(y) + math_cos(y), 1);\n```\n\nThe fixed-point process is reminiscent of the process we used for finding\nsquare roots in section.\n\nBoth are based on\nthe idea of repeatedly improving a guess until the result satisfies some\ncriterion.\n\nIn fact, we can readily formulate the\n$x$ requires finding a\n$y$ such that\n$y^2 = x$.\n\nPutting this equation into the\nequivalent form $y = x/y$ , we recognize that we\nare looking for a fixed point of the function $y \\mapsto x/y$ , and we can therefore try to\ncompute square roots as\n\n```javascript\nsqrt_definition2\n      fixed_definition\n      sqrt_example7\n\nfunction sqrt(x) {\n    return fixed_point(y => x / y, 1);\n}\n```\n\n```javascript\nsqrt_example7\n\nsqrt(5);\n```\n\nUnfortunately, this fixed-point search does not converge.\n\nConsider an\ninitial guess $y_1$.\n\nThe next guess is\n$y_2 = x/y_1$ and the next guess is\n$y_3 = x/y_2 = x/(x/y_1) = y_1$.\n\nThis results\nin an infinite loop in which the two guesses\n$y_1$ and $y_2$ repeat\nover and over, oscillating about the answer.",
    "token_count": 299,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as General Methods",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_General_Methods_4"
  },
  {
    "content": "This results\nin an infinite loop in which the two guesses\n$y_1$ and $y_2$ repeat\nover and over, oscillating about the answer.\n\nOne way to control such oscillations is to prevent the guesses from changing\nso much.\n\nSince the answer is always between our guess\n$y$\nand $x/y$ , we can make a new guess that is not as\nfar from $y$ as $x/y$\nby averaging $y$ with\n$x/y$ , so that the next guess after\n$y$ is\n$\\frac{1}{2}(y+x/y)$ instead of\n$x/y$.\n\nThe process of making such a sequence of\nguesses is simply the process of looking for a fixed point of\n$y \\mapsto \\frac{1}{2}(y+x/y)$ :\n\n```javascript\nsqrt_definition3\n      fixed_definition\n      average_definition\n      sqrt_example7\n      2.236067977499978\n\nfunction sqrt(x) {\n    return fixed_point(y => average(y, x / y), 1);\n}\n```\n\n(Note that $y=\\frac{1}{2}(y+x/y)$ is a simple transformation of the equation $y=x/y$ ; to derive it, add $y$ to both sides of the equation and divide\n\nby 2.)\n\nWith this modification, the square-root\nfunction\nworks.\n\nIn fact, if we unravel the definitions, we can see that the sequence\nof approximations to the square root generated here is precisely the same as\nthe one generated by our original square-root\nfunction\nof section.\n\nThis approach of averaging\nsuccessive approximations to a solution, a technique we call\naverage damping , often aids the convergence of fixed-point searches.",
    "token_count": 218,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as General Methods",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_General_Methods_5"
  },
  {
    "content": "The above examples demonstrate how the ability to pass\nfunctions\nas arguments significantly enhances the expressive power of our programming\nlanguage.\n\nWe can achieve even more expressive power by creating\nfunctions\nwhose returned values are themselves\nfunctions.\n\nWe can illustrate this idea by looking again at the fixed-point example\ndescribed at the end of\nsection.\n\nWe formulated a new\nversion of the square-root\nfunction\nas a fixed-point search, starting with the observation that\n$\\sqrt{x}$ is a fixed-point of the function\n$y\\mapsto x/y$.\n\nThen we used average damping to\nmake the approximations converge.\n\nAverage damping is a useful general\ntechnique in itself.\n\nNamely, given a\nfunction $f$ , we consider the function\nwhose value at $x$ is equal to the average of\n$x$ and $f(x)$.\n\nWe can express the idea of average damping by means of the following function:\n\n```javascript\naverage_damp_definition\n      average_definition\n      average_damp_example\n      55\n\nfunction average_damp(f) {\n    return x => average(x, f(x));\n}\n```\n\n```javascript\nThe function\n        average_damp\n```\n\ntakes as its argument a\nfunction\nfunction\n(produced by the lambda expression)\nthat, when applied to a number\nf(x).\n\nFor example, applying\naverage_damp\nto the\nfunction\nproduces a\nfunction\nwhose value at some number $x$ is the average of\n$x$ and $x^2$.\n\nApplying this resulting\nfunction\nto 10 returns the average of 10 and 100, or 55:\n\n```javascript\naverage_damp_example\n      average_damp_definition\n      square_definition\n\naverage_damp(square)(10);\n```\n\nUsing average_damp, we can reformulate the function as follows:\n\n```javascript\nsqrt_definition4\n      average_damp_definition\n      fixed_definition\n      sqrt_example3\n\nfunction sqrt(x) {\n    return fixed_point(average_damp(y => x / y), 1);\n}\n```\n\n```javascript\nsqrt_example3\n      sqrt_definition4\n      2.4494897427875517\n\nsqrt(6);\n```\n\nNotice how this formulation makes explicit the three ideas in the method:\nfixed-point search, average damping, and the function\n$y\\mapsto x/y$.\n\nIt is instructive to compare\nthis formulation of the square-root method with the original version given\nin section.",
    "token_count": 292,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as Returned Values",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Returned_Values_1"
  },
  {
    "content": "It is instructive to compare\nthis formulation of the square-root method with the original version given\nin section.\n\nBear in mind that these\nfunctions\nexpress the same process, and notice how much clearer the idea becomes when\nwe express the process in terms of these abstractions.\n\nIn general, there\nare many ways to formulate a process as a\nfunction.\n\nExperienced programmers know how to choose\nprocess\nformulations that are particularly perspicuous, and where useful elements of\nthe process are exposed as separate entities that can be reused in other\napplications.\n\nAs a simple example of reuse, notice that the cube root of\n$x$ is a fixed point of the function\n$y\\mapsto x/y^2$ , so we can immediately\ngeneralize our square-root\nfunction\nto one that extracts\n\n```javascript\ncube_root_definition\n      average_damp_definition\n      fixed_definition\n      square_definition\n      cube_root_example\n\nfunction cube_root(x) {\n    return fixed_point(average_damp(y => x / square(y)), 1);\n}\n```\n\n```javascript\ncube_root_example\n      cube_root_definition\n      2.9999972321057697\n\ncube_root(27);\n```\n\nWhen we first introduced the square-root\nfunction,\nin section , we mentioned that this was a\nspecial case of\nNewton s method.\n\nIf\n$x\\mapsto g(x)$ is a differentiable function,\nthen a solution of the equation $g(x)=0$ is a\nfixed point of the function $x\\mapsto f(x)$ where\n\\[\n\\begin{array}{lll}\nf(x) & = & x - \\dfrac{g(x)}{Dg(x)}\n\\end{array}\n\\]\nand $Dg(x)$ is the derivative of\n$g$ evaluated at $x$.\ns method is the use of the fixed-point method we saw above to\napproximate a solution of the equation by finding a fixed point of the\nfunction $f$. $g$ and for sufficiently good\ninitial guesses for $x$ , Newton s method\nconverges very rapidly to a solution of\n$g(x)=0$.\n\nIn order to implement Newton s method as a\nfunction,\nwe must first express the idea of\nderivative, like average damping, is something that\ntransforms a function into another function.",
    "token_count": 295,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as Returned Values",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Returned_Values_2"
  },
  {
    "content": "In order to implement Newton s method as a\nfunction,\nwe must first express the idea of\nderivative, like average damping, is something that\ntransforms a function into another function.\n\nFor instance, the derivative\nof the function $x\\mapsto x^3$ is the function\n$x \\mapsto 3x^2$.\n\nIn general, if\n$g$ is a function and\n$dx$ is a small number, then the derivative\n$Dg$ of $g$ is the\nfunction whose value at any number $x$ is given\n(in the limit of small $dx$ ) by\n\\[\n\\begin{array}{lll}\nDg(x) & = & \\dfrac {g(x+dx) - g(x)}{dx}\n\\end{array}\n\\]\nThus, we can express the idea of derivative (taking\n$dx$ to be, say, 0.00001) as the\nfunction\n\n```javascript\nderiv_definition\n      dx\n      deriv_example\n\nfunction deriv(g) {\n    return x => (g(x + dx) - g(x)) / dx;\n}\n```\n\nalong with the declaration\n\n```javascript\ndx\n\nconst dx = 0.00001;\n```\n\nLike\naverage_damp,\nfunction\nthat takes a\nfunction\nas argument and returns a\nfunction\nas value.\n\nFor example, to approximate the derivative of\n$x \\mapsto x^3$ at 5 (whose exact value is 75)\nwe can evaluate\n\n```javascript\nderiv_example\n      deriv_definition\n      75.00014999664018\n\nfunction cube(x) { return x * x * x; }\n\nderiv(cube)(5);\n```\n\nWith the aid of s method as a fixed-point process:\n\n```javascript\nnewtons_method_definition\n      fixed_definition\n      deriv_definition\n      sqrt_example4\n      2.4494897427970397\n\nfunction newton_transform(g) {\n    return x => x - g(x) / deriv(g)(x);\n}\nfunction newtons_method(g, guess) {\n    return fixed_point(newton_transform(g), guess);\n}\n```\n\nThe\nnewton_transform\nfunction\nexpresses the formula at the beginning of this section, and\nnewtons_method\nis readily defined in terms of this.\n\nIt takes as arguments a\nfunction\nthat computes the function for which we want to find a zero, together with\nan initial guess.\n\nFor instance, to find the\nsquare root of $x$ , we can use\ns\nmethod to find a zero of the function\n$y\\mapsto y^2-x$ starting with an initial guess\nof 1.\nfunction:",
    "token_count": 306,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as Returned Values",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Returned_Values_3"
  },
  {
    "content": "For instance, to find the\nsquare root of $x$ , we can use\ns\nmethod to find a zero of the function\n$y\\mapsto y^2-x$ starting with an initial guess\nof 1.\nfunction:\n\n```javascript\nsqrt_definition5\n      newtons_method_definition\n      square_definition\n      sqrt_example4\n\nfunction sqrt(x) {\n    return newtons_method(y => square(y) - x, 1);\n}\n```\n\n```javascript\nsqrt_example4\n      sqrt_definition5\n\nsqrt(6);\n```\n\nWe ve seen two ways to express the square-root computation as an\ninstance of a more general method, once as a fixed-point search and once\nusing Newton s method.\n\nSince Newton s method was itself\nexpressed as a fixed-point process, we actually saw two ways to compute\nsquare roots as fixed points.\n\nEach method begins with a function and finds a\nfunction:\n\n```javascript\nfixed_point_of_transform_definition\n      fixed_definition\n      sqrt_example5\n      2.4494897427875517\n\nfunction fixed_point_of_transform(g, transform, guess) {\n    return fixed_point(transform(g), guess);\n}\n```\n\nThis very general function takes as its arguments a function function that transforms\n\nUsing this abstraction, we can recast the first square-root computation $y \\mapsto x/y$ ) as an instance of this general method:\n\n```javascript\nsqrt_definition6\n      fixed_point_of_transform_definition\n      average_damp_definition\n      sqrt_example5\n      2.4494897427875517\n\nfunction sqrt(x) {\n    return fixed_point_of_transform(\n               y => x / y,\n               average_damp,\n               1);\n}\n```\n\n```javascript\nsqrt_example5\n      sqrt_definition6\n\nsqrt(6);\n```\n\nSimilarly, we can express the second square-root computation from this section (an instance of s method that finds a fixed point of the Newton transform\n\nof $y\\mapsto y^2-x$ ) as\n\n```javascript\nsqrt_definition7\n      fixed_point_of_transform_definition\n      square_definition\n      newtons_method_definition\n      sqrt_example6\n\nfunction sqrt(x) {\n    return fixed_point_of_transform(\n               y => square(y) - x,\n               newton_transform,\n               1);\n}\n```\n\n```javascript\nsqrt_example6\n      sqrt_definition7\n\nsqrt(6);\n```\n\nWe began section with the\nobservation that compound\nfunctions\nare a crucial abstraction mechanism, because they permit us to express\ngeneral methods of computing as explicit elements in our programming\nlanguage.\n\nNow we ve seen how higher-order\nfunctions\npermit us to manipulate these general methods to create further abstractions.",
    "token_count": 294,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as Returned Values",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Returned_Values_4"
  },
  {
    "content": "Now we ve seen how higher-order\nfunctions\npermit us to manipulate these general methods to create further abstractions.\n\nAs programmers, we should be alert to opportunities to identify the\nunderlying abstractions in our programs and to build upon them and\ngeneralize them to create more powerful abstractions.\n\nThis is not to say\nthat one should always write programs in the most abstract way possible;\nexpert programmers know how to choose the level of abstraction appropriate\nto their task.\n\nBut it is important to be able to think in terms of these\nabstractions, so that we can be ready to apply them in new contexts.\n\nThe\nsignificance of higher-order\nfunctions\nis that they enable us to represent these abstractions explicitly as\nelements in our programming language, so that they can be handled just\nlike other computational elements.\n\nIn general, programming languages impose restrictions on the ways in which\ncomputational elements can be manipulated.\n\nElements with the fewest\nrestrictions are said to have\nfirst-class status.\n\nSome of the rights and\nprivileges of first-class elements are:\n-\n-\nThey may be referred to using names.\n-\n-\nThey may be passed as arguments to\nfunctions.\n-\n-\nThey may be returned as the results of\nfunctions.\n-\n-\nThey may be included in data structures.\n\nJavaScript,\nlike other high-level\nprogramming languages, awards\nfunctions\nfull first-class status.\n\nThis poses challenges for efficient\nimplementation, but the resulting gain in expressive power is\nenormous.",
    "token_count": 238,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Formulating Abstractions with Higher-Order Functions",
    "subsection": "Functions as Returned Values",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Returned_Values_5"
  },
  {
    "content": "We have now considered the elements of programming: We have used\nprimitive arithmetic operations, we have combined these operations, and\nwe have abstracted these composite operations by\ndeclaring them as compound functions.\n\nBut that is not enough to enable us to say that we know\nhow to program.\n\nOur situation is analogous to that of someone who has\nlearned the rules for how the pieces move in chess but knows nothing\nof typical openings, tactics, or strategy.\n\nLike the novice chess\nplayer, we don t yet know the common patterns of usage in the domain.\n\nWe lack the knowledge of which moves are worth making\n(which functions are worth declaring).\n\nWe lack the experience to predict the consequences of making a move\n(executing a function).\n\nThe ability to visualize the consequences of the actions under\nconsideration is crucial to becoming an expert programmer, just as it\nis in any synthetic, creative activity.\n\nIn becoming an expert\nphotographer, for example, one must learn how to look at a scene and\nknow how dark each region will appear on a print for each possible\nchoice of exposure and\nprocessing options.\nprocessing\nto obtain the desired effects.\n\nSo it is with programming, where we are\nplanning the course of action to be taken by a process and where we control\nthe process by means of a program.\n\nTo become experts, we must learn to\nvisualize the processes generated by various types of\nfunctions.\n\nOnly after we have developed such a skill can we learn\nto reliably construct programs that exhibit the desired behavior.\n\nA\nfunction\nis a\nlocal evolution of a\ncomputational process.\n\nIt specifies how each stage of the process is\nbuilt upon the previous stage.",
    "token_count": 284,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_and_the_Processes_They_Generate_1"
  },
  {
    "content": "It specifies how each stage of the process is\nbuilt upon the previous stage.\n\nWe would like to be able to make\nstatements about the overall, or global , behavior of a\nprocess whose local\nfunction.\n\nThis is very difficult to do in general, but we can at least try to\ndescribe some typical patterns of process evolution.\n\nIn this section we will examine some common shapes for\nprocesses generated by simple\nfunctions.\n\nWe will also investigate the rates at which these processes consume the\nimportant computational resources of time and space.\n\nThe\nfunctions\nwe will consider are very simple.\n\nTheir role is like that played by test\npatterns in photography: as oversimplified prototypical patterns, rather\nthan practical examples in their own right.",
    "token_count": 123,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_and_the_Processes_They_Generate_2"
  },
  {
    "content": "This section describes two methods for checking the primality of an\ninteger $n$ , one with order of growth\n$\\Theta(\\sqrt{n})$ , and a\nprobabilistic algorithm with order of growth\n$\\Theta(\\log n)$.\n\nThe exercises at the end of\nthis section suggest programming projects based on these algorithms.\n\nSince ancient times, mathematicians have been fascinated by problems\nconcerning prime numbers, and many people have worked on the problem\nof determining ways to test if numbers are prime.\n\nOne way\nto test if a number is prime is to find the number s divisors.\n\nThe\nfollowing program finds the smallest integral divisor (greater than 1)\nof a given number $n$.\n\nIt does this in a\nstraightforward way, by testing $n$ for\ndivisibility by successive integers starting with 2.\n\n```javascript\nsmallest_divisor_definition\n      square_definition\n      smallest_divisor_example\n\nfunction smallest_divisor(n) {\n    return find_divisor(n, 2);\n}\nfunction find_divisor(n, test_divisor) {\n    return square(test_divisor) > n\n           ? n\n           : divides(test_divisor, n)\n           ? test_divisor\n           : find_divisor(n, test_divisor + 1);\n}\nfunction divides(a, b) {\n    return b % a === 0;\n}\n```\n\n```javascript\nsmallest_divisor_example\n      smallest_divisor_definition\n      2\n\nsmallest_divisor(42);\n```\n\nWe can test whether a number is prime as follows: $n$ is prime if and only if $n$ is its own smallest divisor.\n\n```javascript\nprime_definition\n      smallest_divisor_definition\n      prime_example\n\nfunction is_prime(n) {\n    return n === smallest_divisor(n);\n}\n```\n\n```javascript\nprime_example\n      prime_definition\n      false\n\nis_prime(42);\n```\n\nThe end test for\nfind_divisor\nis based on the fact that if $n$ is not prime it\nmust have a divisor less than or equal to\n$\\sqrt{n}$. $\\sqrt{n}$.\n\nConsequently, the number of steps\nrequired to identify $n$ as prime will have order\nof growth $\\Theta(\\sqrt{n})$.\n\nThe $\\Theta(\\log n)$ primality test is based on\na result from number theory known as\ns Little\nTheorem.",
    "token_count": 280,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Example: Testing for Primality",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Example_Testing_for_Primality_1"
  },
  {
    "content": "The $\\Theta(\\log n)$ primality test is based on\na result from number theory known as\ns Little\nTheorem.\n\nFermat s Little Theorem:\n$n$ is a prime number and\n$a$ is any positive integer less than\n$n$ , then $a$ raised\nto the $n$ th power is congruent to\n$a$ modulo $n$.\n\n(Two numbers are said to be\ncongruent modulo\n$n$ if they both have the same remainder when\ndivided by $n$.\n\nThe remainder of a number\n$a$ when divided by\n$n$ is also referred to as the\nremainder of $a$ modulo\n$n$ , or simply as $a$\nmodulo $n$.)\n\nIf $n$ is not prime, then, in general, most of\nthe numbers $a < n$ will not satisfy the above\nrelation.\n\nThis leads to the following algorithm for testing primality:\nGiven a number $n$ , pick a\n$a < n$ and compute the\nremainder of $a^n$ modulo\n$n$.\n\nIf the result is not equal to\n$a$ , then $n$ is\ncertainly not prime.\n\nIf it is $a$ , then chances\nare good that $n$ is prime.\n\nNow pick another\nrandom number $a$ and test it with the same\nmethod.\n\nIf it also satisfies the equation, then we can be even more\nconfident that $n$ is prime.\n\nBy trying more and\nmore values of $a$ , we can increase our\nconfidence in the result.\n\nThis algorithm is known as the Fermat test.\n\nTo implement the Fermat test, we need a function that computes the\n\n```javascript\nexpmod_definition\n      expmod_example\n      even_definition\n      square_definition\n\nfunction expmod(base, exp, m) {\n    return exp === 0\n           ? 1\n           : is_even(exp)\n           ? square(expmod(base, exp / 2, m)) % m\n           : (base * expmod(base, exp - 1, m)) % m;\n}\n```\n\n```javascript\nexpmod_example\n      expmod_definition\n      4\n\nexpmod(4, 3, 5);\n```\n\nThis is very similar to the\nfast_expt\nfunction\nof section.",
    "token_count": 298,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Example: Testing for Primality",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Example_Testing_for_Primality_2"
  },
  {
    "content": "This is very similar to the\nfast_expt\nfunction\nof section.\n\nIt uses successive\nsquaring, so that the number of steps grows logarithmically with the\nexponent.\n\nThe Fermat test is performed by choosing at random a number\n$a$ between 1 and\n$n-1$ inclusive and checking whether the remainder\nmodulo $n$ of the\n$n$ th power of $a$ is\nequal to $a$.\n\nThe random number\n$a$ is chosen using the\n\n```javascript\nprimitive function\n\tmath_random,\n```\n\n```javascript\n$n-1$, we multiply\n\tthe return value of math_random by\n\t$n-1$, round down the result with the\n\tprimitive function\n\tmath_floor,\n\tand add 1:\n```\n\n```javascript\nrandom_definition\n\nfunction random(n) {\n    return math_floor(math_random() * n);\n}\n```\n\n```javascript\nfermat_test_definition\n      square_definition\n      expmod_definition\n      random_definition\n      fermat_test_example\n\nfunction fermat_test(n) {\n    function try_it(a) {\n        return expmod(a, n, n) === a;\n    }\n    return try_it(1 + math_floor(math_random() * (n - 1)));\n}\n```\n\n```javascript\nfermat_test_example\n      fermat_test_definition\n      true\n\nfermat_test(97);\n```\n\nThe following\nfunction\nruns the test a given number of times, as specified by a parameter.\n\nIts\nvalue is true if the test succeeds every time, and false otherwise.\n\n```javascript\nfast_prime_definition\n      square_definition\n      expmod_definition\n      random_definition\n      fermat_test_definition\n      fast_prime_example\n\nfunction fast_is_prime(n, times) {\n    return times === 0\n           ? true\n           : fermat_test(n)\n           ? fast_is_prime(n, times - 1)\n           : false;\n}\n```\n\n```javascript\nfast_prime_example\n      fast_prime_definition\n      true\n\nfast_is_prime(97, 3);\n```\n\nThe Fermat test differs in character from most familiar algorithms, in which\none computes an answer that is guaranteed to be correct.\n\nHere, the answer\nobtained is only probably correct.\n\nMore precisely, if\n$n$ ever fails the Fermat test, we can be certain\nthat $n$ is not prime.\n\nBut the fact that\n$n$ passes the test, while an extremely strong\nindication, is still not a guarantee that $n$ is\nprime.",
    "token_count": 277,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Example: Testing for Primality",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Example_Testing_for_Primality_3"
  },
  {
    "content": "But the fact that\n$n$ passes the test, while an extremely strong\nindication, is still not a guarantee that $n$ is\nprime.\n\nWhat we would like to say is that for any number\n$n$ , if we perform the test enough times and find\nthat $n$ always passes the test, then the\nprobability of error in our primality test can be made as small as we like.\n\nUnfortunately, this assertion is not quite correct.\n\nThere do exist numbers\nthat fool the Fermat test: numbers $n$ that are\nnot prime and yet have the property that $a^n$ is\ncongruent to $a$ modulo\n$n$ for all integers\n$a < n$.\n\nSuch numbers are extremely rare, so\nthe Fermat test is quite reliable in practice. $n$ by choosing a random integer\n$a < n$ and checking some condition that\ndepends upon $n$ and\n$a$.\n\n(See\nexercise for an example of such a test.)\nOn the other hand, in contrast to the Fermat test, one can prove that, for\nany $n$ , the condition does not hold for most of\nthe integers $a < n$ unless\n$n$ is prime.\n\nThus, if\n$n$ passes the test for some random choice\nof $a$ , the chances are better than even\nthat $n$ is prime.\n\nIf\n$n$ passes the test for two random choices of\n$a$ , the chances are better than 3 out of 4 that\n$n$ is prime.\n\nBy running the test with more and\nmore randomly chosen values of $a$ we can make\nthe probability of error as small as we like.\n\nThe existence of tests for which one can prove that the chance of error\nbecomes arbitrarily small has sparked interest in algorithms of this type,\nwhich have come to be known as probabilistic algorithms.\n\nThere is",
    "token_count": 294,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Example: Testing for Primality",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Functions_Example_Testing_for_Primality_4"
  },
  {
    "content": "Consider the problem of computing the exponential of a given number.\n\nWe would like a\nfunction\nthat takes as arguments a base $b$ and a positive\ninteger exponent $n$ and\ncomputes $b^n$.\n\nOne way to do this is via\nthe recursive definition\n\\[\n\\begin{array}{lll}\nb^{n} &=& b\\cdot b^{n-1}\\\\\nb^{0} &=& 1\n\\end{array}\n\\]\nwhich translates readily into the\nfunction\n\n```javascript\nexpt_definition\n      expt_example\n\nfunction expt(b, n) {\n    return n === 0\n           ? 1\n           : b * expt(b, n - 1);\n}\n```\n\n```javascript\nexpt_example\n      expt_definition\n      81\n\nexpt(3, 4);\n```\n\nThis is a linear recursive process, which requires\n$\\Theta(n)$ steps and\n$\\Theta(n)$ space.\n\nJust as with factorial, we\ncan readily formulate an equivalent linear iteration:\n\n```javascript\nexpt_linear_definition\n      expt_example2\n      81\n\nfunction expt(b, n) {\n    return expt_iter(b, n, 1);\n}\nfunction expt_iter(b, counter, product) {\n    return counter === 0\n           ? product\n           : expt_iter(b, counter - 1, b * product);\n}\n```\n\n```javascript\nexpt_example2\n\nexpt(3, 4);\n```\n\nThis version requires $\\Theta(n)$ steps and $\\Theta(1)$ space.\n\nWe can compute exponentials in fewer steps by using $b^8$ as \\[ \\begin{array}{l} b\\cdot(b\\cdot(b\\cdot(b\\cdot(b\\cdot(b\\cdot(b\\cdot b)))))) \\end{array} \\] we can compute it using three multiplications: \\[\n\n\\begin{array}{lll} b^{2} &= & b\\cdot b\\\\ b^{4} &= & b^{2}\\cdot b^{2}\\\\ b^{8} &= & b^{4}\\cdot b^{4} \\end{array} \\]\n\nThis method works fine for exponents that are powers of 2.\n\nWe can also take\nadvantage of successive squaring in computing exponentials in general if we\nuse the rule\n\\[\n\\begin{array}{llll}\nb^{n} &=& (b^{n/2})^{2} &\\qquad\\,\\mbox{if}\\ n\\ \\mbox{is even}\\\\\nb^{n} &=& b\\cdot b^{n-1} &\\qquad\\mbox{if}\\ n\\ \\mbox{is odd}\n\\end{array}\n\\]\nWe can express this method as a\nfunction:\n\n```javascript\nexpt_log_definition\n      square_definition\n      even_definition\n      fast_expt_example\n\nfunction fast_expt(b, n) {\n    return n === 0\n           ? 1\n           : is_even(n)\n           ? square(fast_expt(b, n / 2))\n           : b * fast_expt(b, n - 1);\n}\n```\n\n```javascript\nfast_expt_example\n      expt_log_definition\n      81\n\nfast_expt(3, 4);\n```",
    "token_count": 297,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Exponentiation",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Exponentiation_1"
  },
  {
    "content": "We can also take\nadvantage of successive squaring in computing exponentials in general if we\nuse the rule\n\\[\n\\begin{array}{llll}\nb^{n} &=& (b^{n/2})^{2} &\\qquad\\,\\mbox{if}\\ n\\ \\mbox{is even}\\\\\nb^{n} &=& b\\cdot b^{n-1} &\\qquad\\mbox{if}\\ n\\ \\mbox{is odd}\n\\end{array}\n\\]\nWe can express this method as a\nfunction:\n\nwhere the predicate to test whether an integer is even is defined in terms of the\n\n```javascript\n%,\n\twhich computes the remainder after integer division,\n```\n\nby\n\n```javascript\neven_definition\n      even_example\n\nfunction is_even(n) {\n    return n % 2 === 0;\n}\n```\n\n```javascript\neven_example\n      even_definition\n\nis_even(7);\n```\n\nThe process evolved by\nfast_expt\n$n$ in both space and\nnumber of steps.\n\nTo see this, observe that computing\n$b^{2n}$ using\nfast_expt\nrequires only one more multiplication than computing\n$b^n$.\n\nThe size of the exponent we can compute\ntherefore doubles (approximately) with every new multiplication we are\nallowed.\n\nThus, the number of multiplications required for an exponent of\n$n$ grows about as fast as the logarithm of\n$n$ to the base 2.\n\nThe process has\n$\\Theta(\\log n)$ growth.\n\nThe difference between $\\Theta(\\log n)$ growth\nand $\\Theta(n)$ growth becomes striking as\n$n$ becomes large.\n\nFor example,\nfast_expt\nfor $n=1000$ requires only 14\nmultiplications. ), although, as is\noften the case with iterative algorithms, this is not written down so\nstraightforwardly as the recursive algorithm.",
    "token_count": 214,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Exponentiation",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Exponentiation_2"
  },
  {
    "content": "The greatest common divisor (GCD) of two integers\n$a$ and $b$ is defined\nto be the largest integer that divides both $a$\nand $b$ with no remainder.\n\nFor example, the GCD\nof 16 and 28 is 4.\n\nIn chapter , when we investigate how to\nimplement rational-number arithmetic, we will need to be able to compute\nGCDs in order to reduce rational numbers to lowest terms.\n\n(To reduce a\nrational number to lowest terms, we must divide both the numerator and the\ndenominator by their GCD.\n\nFor example, 16/28 reduces to 4/7.) One way to\nfind the GCD of two integers is to factor them and search for common\nfactors, but there is a famous algorithm that is much more efficient.\n\n$r$ is the remainder when\n$a$ is divided by\n$b$ , then the common divisors of\n$a$ and $b$ are\nprecisely the same as the common divisors of $b$\nand $r$.\n\nThus, we can use the equation\n\\[\\begin{array}{lll}\n\\textrm{GCD} (a, b) &=& \\textrm{GCD}(b, r)\n\\end{array}\\]\nto successively reduce the problem of computing a GCD to the problem of\ncomputing the GCD of smaller and smaller pairs of integers.\n\nFor example,\n\\[\\begin{array}{lll}\n\\textrm{GCD}(206,40) & = & \\textrm{GCD}(40,6) \\\\\n& = & \\textrm{GCD}(6,4) \\\\\n& = & \\textrm{GCD}(4,2) \\\\\n& = & \\textrm{GCD}(2,0) \\\\\n& = & 2\n\\end{array}\\]\nreduces $\\textrm{GCD}(206, 40)$ to\n$\\textrm{GCD}(2, 0)$ , which is 2.\n\nIt is\npossible to show that starting with any two positive integers and\nperforming repeated reductions will always eventually produce a pair\nwhere the second number is 0.\n\nThen the GCD is the other\nnumber in the pair.\n\nThis method for computing the GCD is\nknown as Euclid s Algorithm.\n\nIt is easy to express Euclid s Algorithm as a function:",
    "token_count": 289,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Greatest Common Divisors",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Greatest_Common_Divisors_1"
  },
  {
    "content": "It is easy to express Euclid s Algorithm as a function:\n\n```javascript\ngcd_definition\n      gcd_example\n\nfunction gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n}\n```\n\n```javascript\ngcd_example\n      gcd_definition\n      4\n\ngcd(20, 12);\n```\n\nThis generates an iterative process, whose number of steps grows as the logarithm of the numbers involved.\n\nThe fact that the number of steps required by Euclid s Algorithm has Lam s Theorem: s Algorithm requires $k$ steps to compute the GCD\n\nof some pair, then the smaller number in the pair must be greater than or equal to the $k$ th Fibonacci number.\n\nWe can use this theorem to get an order-of-growth estimate for Euclid s\nAlgorithm.\n\nLet $n$ be the smaller of the two\ninputs to the\nfunction.\n\nIf the process takes $k$ steps, then we must have\n$n\\geq {\\textrm{Fib}} (k)\\approx\\phi^k/\\sqrt{5}$.\n\nTherefore the number of steps $k$ grows as the\nlogarithm (to the base $\\phi$ ) of\n$n$.\n\nHence, the order of growth is\n$\\Theta(\\log n)$.",
    "token_count": 166,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Greatest Common Divisors",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Greatest_Common_Divisors_2"
  },
  {
    "content": "We begin by considering the\n\\[\n\\begin{array}{lll}\nn! &=& n\\cdot(n-1)\\cdot(n-2)\\cdots3\\cdot2\\cdot1\n\\end{array}\n\\]\nThere are many ways to compute factorials.\n\nOne way is to make use of\nthe observation that $n!$ is equal to\n$n$ times $(n-1)!$ for\nany positive integer $n$ :\n\\[\n\\begin{array}{lll}\nn! &=& n\\cdot\\left[(n-1)\\cdot(n-2)\\cdots3\\cdot2\\cdot1\\right] \\quad = \\quad n \\cdot(n-1)!\n\\end{array}\n\\]\nThus, we can compute $n!$ by computing\n$(n-1)!$ and multiplying the\nresult by $n$.\n\nIf we add the stipulation that 1!\nis equal to 1,\nthis observation translates directly into a\ncomputer function:\n\n```javascript\nfactorial_definition\n      factorial_example\n      120\n\nfunction factorial(n) {\n    return n === 1\n           ? 1\n           : n * factorial(n - 1);\n}\n```\n\n```javascript\nfactorial_example\n\nfactorial(5);\n```\n\n```javascript\nWe can use the substitution model of\n        section to watch this\n        .\n```\n\nNow let s take a different perspective on computing factorials.\n\nWe\ncould describe a rule for computing $n!$ by\nspecifying that we first multiply 1 by 2, then multiply the result by 3,\nthen by 4, and so on until we reach $n$.\n\nMore formally, we maintain a running product, together with a counter\nthat counts from 1 up to $n$.\n\nWe can describe\nthe computation by saying that the counter and the product simultaneously\nchange from one step to the next according to the rule\n\\[\n\\begin{array}{lll}\n\\textrm{product} & \\leftarrow & \\textrm{counter} \\cdot \\textrm{product}\\\\\n\\textrm{counter} & \\leftarrow & \\textrm{counter} + 1\n\\end{array}\n\\]\nand stipulating that $n!$ is the value of the\nproduct when the counter exceeds $n$.\n\nOnce again, we can recast our description as a function for computing factorials:\n\n```javascript\nfactorial_iterative_definition\n      factorial_example\n\nfunction factorial(n) {\n    return fact_iter(1, 1, n);\n}\nfunction fact_iter(product, counter, max_count) {\n    return counter > max_count\n           ? product\n           : fact_iter(counter * product,\n                       counter + 1,\n                       max_count);\n}\n```\n\nAs before, we can use the substitution model to visualize the process",
    "token_count": 302,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Linear Recursion and Iteration",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Linear_Recursion_and_Iteration_1"
  },
  {
    "content": "As before, we can use the substitution model to visualize the process\n\n```javascript\nA linear recursive process for computing 6!.\n\n\tA linear iterative process for computing\n\t$6!$.\n\n        of computing $6!$, as shown in\n\tfigure.\n```\n\nCompare the two processes.\n\nFrom one point of view, they seem hardly\ndifferent at all.\n\nBoth compute the same mathematical function on the\nsame domain, and each requires a number of steps proportional to\n$n$\nto compute $n!$.\n\nIndeed, both processes even\ncarry out the same sequence of multiplications, obtaining the same sequence\nof partial products.\n\nOn the other hand, when we consider the\nshapes of the two processes, we find that they evolve quite\ndifferently.\n\nConsider the first process.\n\nThe substitution model reveals a shape of\nexpansion followed by contraction, indicated by the arrow in\nfigure.\n\nThe expansion occurs as the process builds up a chain of\ndeferred operations (in this case, a chain of multiplications).\n\nThe contraction occurs as the operations are actually performed.\n\nThis\ntype of process, characterized by a chain of deferred operations, is called a\nrecursive process.\n\nCarrying out this process requires that the\ninterpreter keep track of the operations to be performed later on.\n\nIn the\ncomputation of $n!$ , the length of the chain of\ndeferred multiplications, and hence the amount of information needed to\nkeep track of it,\n$n$ (is proportional to\n$n$ ), just like the number of steps.\n\nSuch a process is called a\nlinear recursive process.\n\nBy contrast, the second process does not grow and shrink.\n\nAt each\nstep, all we need to keep track of, for any $n$ ,\nare the current values of the\nnames\nmax_count.\n\nWe call this an\niterative process.",
    "token_count": 280,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Linear Recursion and Iteration",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Linear_Recursion_and_Iteration_2"
  },
  {
    "content": "We call this an\niterative process.\n\nIn general, an iterative process is one whose\nstate can be summarized by a fixed number of\nstate variables , together with a fixed rule that describes how\nthe state variables should be updated as the process moves from state to\nstate and an (optional) end test that specifies conditions under which the\nprocess should terminate.\n\nIn computing $n!$ , the\nnumber of steps required grows linearly with $n$.\n\nSuch a process is called a\nlinear iterative process.\n\nThe contrast between the two processes can be seen in another way.\n\nIn the iterative case, the state variables provide a complete description of\nthe state of the process at any point.\n\nIf we stopped the computation between\nsteps, all we would need to do to resume the computation is to supply the\ninterpreter with the values of the three state variables.\n\nNot so with the\nrecursive process.\n\nIn this case there is some additional\nhidden information, maintained by the interpreter and not\ncontained in the state variables, which indicates where the process\nis in negotiating the chain of deferred operations.\n\nThe longer the\nchain, the more information must be maintained.\n\nIn contrasting iteration and recursion, we must be careful not to\nconfuse the notion of a\nprocess with the notion of a recursive\nfunction.\n\nWhen we describe a\nfunction\nas recursive, we are referring to the syntactic fact that the\nfunction declaration\nrefers (either directly or indirectly) to the\nfunction\nitself.\n\nBut when we describe a process as following a pattern that is, say,\nlinearly recursive, we are speaking about how the process evolves, not\nabout the syntax of how a\nfunction\nis written.\n\nIt may seem disturbing that we refer to a recursive\nfunction\nsuch as\nfact_iter\nas generating an iterative process.",
    "token_count": 298,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Linear Recursion and Iteration",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Linear_Recursion_and_Iteration_3"
  },
  {
    "content": "It may seem disturbing that we refer to a recursive\nfunction\nsuch as\nfact_iter\nas generating an iterative process.\n\nHowever, the process really is\niterative: Its state is captured completely by its three state variables,\nand an interpreter need keep track of only three\nnames\nin order to execute the process.\n\nOne reason that the distinction between process and\nfunction\nmay be confusing is that most implementations of common languages\n(including\nare designed in such a way that the interpretation of\nany recursive\nfunction\nconsumes an amount of memory that grows with the number of\nfunction\ncalls, even when the process described is, in principle, iterative.\n\nAs a consequence, these languages can describe iterative processes only\nby resorting to special-purpose\nlooping constructs such as\n$\\texttt{do}$ ,\n$\\texttt{repeat}$ ,\n$\\texttt{until}$ ,\n$\\texttt{for}$ , and\n$\\texttt{while}$.\n\nThe implementation of\nJavaScript\nwe shall consider in chapter does not share this defect.\n\nIt will\nexecute an iterative process in constant space, even if the iterative\nprocess is described by a recursive\nfunction.\n\n```javascript\nAn implementation with this property is called\n\ttail-recursive.\n```",
    "token_count": 178,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Linear Recursion and Iteration",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Functions_Linear_Recursion_and_Iteration_4"
  },
  {
    "content": "The previous examples illustrate that processes can differ\nconsiderably in the rates at which they consume computational\nresources.\n\nOne convenient way to describe this difference is to use\nthe notion of\norder of growth to obtain a gross measure of the\n\nLet $n$ be a parameter that measures the size of\nthe problem, and let $R(n)$ be the amount\nof resources the process requires for a problem of size\n$n$.\n\nIn our previous examples we took\n$n$ to be the number for which a given\nfunction is to be computed, but there are other possibilities.\n\nFor instance, if our goal is to compute an approximation to the\nsquare root of a number, we might take\n$n$ to be the number of digits accuracy required.\n\nFor matrix multiplication we might take $n$ to\nbe the number of rows in the matrices.\n\nIn general there are a number of\nproperties of the problem with respect to which it will be desirable to\nanalyze a given process.\n\nSimilarly, $R(n)$\nmight measure the number of internal storage registers used, the\nnumber of elementary machine operations performed, and so on.\n\nIn\ncomputers that do only a fixed number of operations at a time, the\ntime required will be proportional to the number of elementary machine\noperations performed.\n\nWe say that $R(n)$ has order of growth\n$\\Theta(f(n))$ , written\n$R(n)=\\Theta(f(n))$ (pronounced\ntheta of $f(n)$ ), if there are\npositive constants $k_1$ and\n$k_2$ independent of\n$n$ such that\n\\[\n\\begin{array}{lllll}\nk_1\\,f(n) & \\leq & R(n) & \\leq & k_2\\,f(n)\n\\end{array}\n\\]\nfor any sufficiently large value of $n$.\n\n(In other words, for large $n$ ,\nthe value $R(n)$ is sandwiched between\n$k_1f(n)$ and\n$k_2f(n)$.)\n\nthe\nnumber of steps grows proportionally to the input\n$n$.\n\nThus, the steps required for this process\ngrows as $\\Theta(n)$.",
    "token_count": 298,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Orders of Growth",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Orders_of_Growth_1"
  },
  {
    "content": "Thus, the steps required for this process\ngrows as $\\Theta(n)$.\n\nWe also saw that the space\nrequired grows as $\\Theta(n)$.\n\nFor the\n$\\Theta(n)$ but the space is\n$\\Theta(1)$ that is,\nconstant. $\\Theta(\\phi^{n})$ steps and space\n$\\Theta(n)$ , where\n$\\phi$ is the golden ratio described in\nsection.\n\nOrders of growth provide only a crude description of the behavior of a\nprocess.\n\nFor example, a process requiring $n^2$\nsteps and a process requiring $1000n^2$ steps and\na process requiring $3n^2+10n+17$ steps all have\n$\\Theta(n^2)$ order of growth.\n\nOn the other hand,\norder of growth provides a useful indication of how we may expect the\nbehavior of the process to change as we change the size of the problem.\n\nFor a\n$\\Theta(n)$ (linear) process, doubling the size\nwill roughly double the amount of resources used.\n\nFor an\nwe will examine two algorithms whose order of growth is\n\n-\n- The function p\nwill call itself recursively as long as the angle value is greater\nthan 0.1.\n\nThere will be altogether 5 calls of\np , with arguments 12.15, 4.05,\n1.35, 0.45, 0.15 and 0.05.\n-\n-\nThe function sine gives\nrise to a recursive process.\n\nIn each recursive call, the\nangle is divided by 3\nuntil its absolute value is smaller than 0.1.\n\nThus the number of steps and the space required has an order\nof growth of $O(\\log a)$.\n\nNote that the base of the logarithm\nis immaterial for the order of growth because the logarithms\nof different bases differ only by a constant factor.",
    "token_count": 253,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Orders of Growth",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Orders_of_Growth_2"
  },
  {
    "content": "Another common pattern of computation is called tree recursion.\n\nAs an example, consider computing the sequence of\n\\[\\begin{array}{l}\n0, 1, 1, 2, 3, 5, 8, 13, 21, \\ldots\n\\end{array}\\]\nIn general, the Fibonacci numbers can be defined by the rule\n\\[\\begin{array}{lll}\n\\textrm{Fib}(n) & = & \\left\\{ \\begin{array}{ll}\n0 & \\mbox{if $n=0$}\\\\\n1 & \\mbox{if $n=1$}\\\\\n\\textrm{Fib}(n-1)+\\textrm{Fib}(n-2) & \\mbox{otherwise}\n\\end{array}\n\\right.\n\\end{array}\\]\nWe can immediately translate this definition into a recursive\nfunction\nfor computing Fibonacci numbers:\n\n```javascript\nfib_definition\n      fib_example\n\nfunction fib(n) {\n    return n === 0\n           ? 0\n           : n === 1\n           ? 1\n           : fib(n - 1) + fib(n - 2);\n}\n```\n\n```javascript\nfib_example\n      fib_definition\n      8\n\nfib(6);\n```\n\n```javascript\nThe tree-recursive process generated in computing\n\t  fib(5).\n```\n\nConsider the pattern of this computation.\n\nTo compute\nfib(5),\nwe compute\nfib(4)\nand\nfib(3).\n\nTo compute\nfib(4),\nwe compute\nfib(3)\nand\nfib(2).\n\nIn general, the evolved process looks like a tree, as shown in\nfigure.\n\nNotice that the branches split into\ntwo at each level (except at the bottom); this reflects the fact that the\nfunction\ncalls itself twice each time it is invoked.\n\nThis\nfunction\nis instructive as a prototypical tree recursion, but it is a terrible way to\ncompute Fibonacci numbers because it does so much redundant computation.\n\nNotice in\nfigure\nthat the entire\ncomputation of\n\n```javascript\nfib(3)almost\n\thalf the workis\n```\n\nduplicated.\n\nIn fact, it is not hard to show that the number of times the\nfunction\nwill compute\nfib(1)\nor\nfib(0)\n(the number of leaves in the above tree, in general) is precisely\n$\\textrm{Fib}(n+1)$.\n\nTo get an idea of how\nbad this is, one can show that the value of\n$\\textrm{Fib}(n)$\n$n$.",
    "token_count": 274,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Tree Recursion",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Tree_Recursion_1"
  },
  {
    "content": "To get an idea of how\nbad this is, one can show that the value of\n$\\textrm{Fib}(n)$\n$n$.\n\nMore precisely\n(see exercise ),\n$\\textrm{Fib}(n)$ is the closest integer to\n$\\phi^{n} /\\sqrt{5}$ , where\n\\[\\begin{array}{lllll}\n\\phi&=&(1+\\sqrt{5})/2 & \\approx & 1.6180\n\\end{array}\\]\nis the\ngolden ratio , which satisfies the equation\n\\[\\begin{array}{lll}\n\\phi^{2} &=&\\phi + 1\n\\end{array}\\]\nThus, the process uses a number of steps that grows exponentially with the\ninput.\n\nOn the other hand, the space required grows only linearly with the\ninput, because we need keep track only of which nodes are above us in the\ntree at any point in the computation.\n\nIn general, the number of steps\nrequired by a tree-recursive process will be proportional to the number of\nnodes in the tree, while the space required will be proportional to the\nmaximum depth of the tree.\n\nWe can also formulate an iterative process for computing the Fibonacci\nnumbers.\n\nThe idea is to use a pair of integers $a$\nand $b$ , initialized to\n$\\textrm{Fib}(1)=1$ and\n$\\textrm{Fib}(0)=0$ , and to repeatedly apply the\nsimultaneous transformations\n\\[\\begin{array}{lll}\na & \\leftarrow & a+b \\\\\nb & \\leftarrow & a\n\\end{array}\\]\nIt is not hard to show that, after applying this transformation\n$n$ times, $a$ and\n$b$ will be equal, respectively, to\n$\\textrm{Fib}(n+1)$ and\n$\\textrm{Fib}(n)$.\n\nThus, we can compute\nFibonacci numbers iteratively using the\nfunction\n\n```javascript\nfib_example\n      8\n\nfunction fib(n) {\n    return fib_iter(1, 0, n);\n}\nfunction fib_iter(a, b, count) {\n    return count === 0\n           ? b\n           : fib_iter(a + b, a, count - 1);\n}\n```\n\nThis second method for computing $\\textrm{Fib}(n)$\nis a linear iteration.\n\nThe difference in number of steps required by the two\nmethods one linear in $n$ , one growing as\nfast as $\\textrm{Fib}(n)$ itself is\nenormous, even for small inputs.",
    "token_count": 295,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Tree Recursion",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Tree_Recursion_2"
  },
  {
    "content": "The difference in number of steps required by the two\nmethods one linear in $n$ , one growing as\nfast as $\\textrm{Fib}(n)$ itself is\nenormous, even for small inputs.\n\nOne should not conclude from this that tree-recursive processes are useless.\n\nWhen we consider processes that operate on hierarchically structured data\nrather than numbers, we will find that tree recursion is a natural and\npowerful tool.\nfunction\nis much less efficient than the second one, it is more straightforward,\nbeing little more than a translation into\nJavaScript\nof the definition of the Fibonacci sequence.\n\nTo formulate the iterative\nalgorithm required noticing that the computation could be recast as an\niteration with three state variables.\n\nIt takes only a bit of cleverness to come up with the iterative Fibonacci\nalgorithm.\n\nIn contrast, consider the following problem:\nHow many different ways can we make change of\n1.00 (100 cents),\ngiven half-dollars, quarters, dimes, nickels, and pennies\n(50 cents, 25 cents, 10 cents, 5 cents, and 1 cent, respectively)?\n\nMore generally, can\nwe write a\nfunction\nto compute the number of ways to change any given amount of money?\n\nThis problem has a simple solution as a recursive\nfunction.\n\nSuppose we think of the types of coins available as arranged in some order.\n\nThen the following relation holds:\nThe number of ways to change amount $a$ using\n$n$ kinds of coins equals\n-\n-\nthe number of ways to change amount $a$\nusing all but the first kind of coin, plus\n-\n-\nthe number of ways to change amount $a-d$\nusing all $n$ kinds of coins, where\n$d$ is the denomination of the first kind\nof coin.",
    "token_count": 274,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Tree Recursion",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Tree_Recursion_3"
  },
  {
    "content": "Then the following relation holds:\nThe number of ways to change amount $a$ using\n$n$ kinds of coins equals\n-\n-\nthe number of ways to change amount $a$\nusing all but the first kind of coin, plus\n-\n-\nthe number of ways to change amount $a-d$\nusing all $n$ kinds of coins, where\n$d$ is the denomination of the first kind\nof coin.\n\nTo see why this is true, observe that the ways to make change can be divided\ninto two groups: those that do not use any of the first kind of coin, and\nthose that do.\n\nTherefore, the total number of ways to make change for some\namount is equal to the number of ways to make change for the amount without\nusing any of the first kind of coin, plus the number of ways to make change\nassuming that we do use the first kind of coin.\n\nBut the latter number is\nequal to the number of ways to make change for the amount that remains after\nusing a coin of the first kind.\n\nThus, we can recursively reduce the problem of changing a given amount to\nproblems of changing smaller amounts or using fewer kinds of coins.\n\nConsider\nthis reduction rule carefully, and convince yourself that we can use it to\ndescribe an algorithm if we specify the following degenerate\ncases:\n-\n-\nIf $a$ is exactly 0, we should count that\nas 1 way to make change.\n-\n-\nIf $a$ is less than 0, we should count\nthat as 0 ways to make change.\n-\n- If $n$ is 0, we should count that\nas 0 ways to make change.\n\nWe can easily translate this description into a recursive\nfunction:",
    "token_count": 288,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Tree Recursion",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Functions_Tree_Recursion_4"
  },
  {
    "content": "We can easily translate this description into a recursive\nfunction:\n\n```javascript\ncount_change_definition\n      count_change_example\n\nfunction count_change(amount) {\n    return cc(amount, 5);\n}\n\nfunction cc(amount, kinds_of_coins) {\n    return amount === 0\n           ? 1\n           : amount < 0 || kinds_of_coins === 0\n           ? 0\n           : cc(amount, kinds_of_coins - 1)\n             +\n             cc(amount - first_denomination(kinds_of_coins),\n                kinds_of_coins);\n}\n\nfunction first_denomination(kinds_of_coins) {\n    return kinds_of_coins === 1 ? 1\n         : kinds_of_coins === 2 ? 5\n         : kinds_of_coins === 3 ? 10\n         : kinds_of_coins === 4 ? 25\n         : kinds_of_coins === 5 ? 50\n         : 0;\n}\n```\n\n(The\nfirst_denomination function\ntakes as input the number of kinds of coins available and returns the\ndenomination of the first kind.\n\nHere we are thinking of the coins as\narranged in order from largest to smallest, but any order would do as well.)\nWe can now answer our original question about changing a dollar:\n\n```javascript\ncount_change_example\n      count_change_definition\n      292\n\ncount_change(100);\n```\n\nThe function count_change\ngenerates a tree-recursive process with redundancies similar to those in\nour first implementation of\nOn the other hand, it is not\nobvious how to design a better algorithm for computing the result, and we\nleave this problem as a challenge.\n\nThe observation that a\nsmart compiler that could transform\ntree-recursive\nfunctions\ninto more efficient\nfunctions\nthat compute the same result.",
    "token_count": 211,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "Functions and the Processes They Generate",
    "subsection": "Tree Recursion",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Functions_Tree_Recursion_5"
  },
  {
    "content": "A powerful programming language is more than just a means for\ninstructing a computer to perform tasks.\n\nThe language also serves as\na framework within which we organize our ideas about processes.\n\nThus,\nwhen we describe a language, we should pay particular attention to the\nmeans that the language provides for combining simple ideas to form\nmore complex ideas.\n\nEvery powerful language has three mechanisms for\naccomplishing this:\n-\n-\nprimitive expressions ,\ncerned with,\n-\n-\nmeans of combination , by\n-\n-\nmeans of abstraction ,\n\nIn programming, we deal with two kinds of elements:\nand\nstuff that we want to manipulate, and\nfunctions\nare descriptions of the rules for manipulating the data.\n\nThus, any powerful programming language should be able to describe\nprimitive data and primitive\nfunctions\nand should have methods for\ncombining and abstracting\nfunctions\nand data.\n\nIn this chapter we will deal only with simple functions. functions to manipulate compound data as well.",
    "token_count": 158,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_The_Elements_of_Programming_1"
  },
  {
    "content": "We have identified in\nJavaScript\nsome of the elements that must appear in any powerful programming language:\n-\n-\nNumbers and arithmetic operations are primitive data and\nfunctions.\n-\n-\nNesting of combinations provides a means of combining operations.\n-\n-\nConstant declarations that associate names with values provide a\nlimited means of abstraction.\n\nNow we will learn about\nfunction declarations,\na much more powerful abstraction technique by which a compound\noperation can be given a name and then referred to as a unit.\n\nWe begin by examining how to express the idea of\nsquaring.\n\nWe might say,\nTo square something, take it times itself.\n\n```javascript\nsquare_definition\n      square_example\n\nfunction square(x) {\n    return x * x;\n}\n```\n\n```javascript\nsquare_example\n\nsquare(14);\n```\n\nWe can understand this in the following way:\n\\begin{flushleft}\\normalcodesize\n\\begin{tabular}{@{}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c}\n\\tt\\textbf{function} & \\tt square( & \\tt x & \\tt ) \\verb+{+ & \\tt\\textbf{return} & \\tt x & \\tt * & \\tt x & \\tt; \\verb+}+ \\\\\n$\\Big\\uparrow$ & $\\Big\\uparrow$ & $\\Big\\uparrow$ & & & $\\Big\\uparrow$ & $\\Big\\uparrow$ & $\\Big\\uparrow$ \\\\[4pt]\n\\normalsize To & \\normalsize square & \\normalsize something, & & \\normalsize take &\\normalsize it & \\normalsize times & \\normalsize itself. \\\\\n\\end{tabular}\n\\end{flushleft}\nWe have here a\ncompound function,\nwhich has been given the name\nfunction\nrepresents the operation of multiplying something by itself.\n\nThe thing to\nbe multiplied is given a local name,\nEvaluating the\ndeclaration\ncreates this compound\nfunction\nand associates it with the name\n\nThe simplest form of a function declaration is\n\n```javascript\nfunction name(parameters) { return expression; }\n```\n\nThe name is a symbol to be associated with the function definition in the environment. parameters are the names used within the body of the\n\nfunction to refer to the corresponding arguments of the function.",
    "token_count": 289,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Compound Functions",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Compound_Functions_1"
  },
  {
    "content": "function to refer to the corresponding arguments of the function.\n\n```javascript\nThe parameters\n\tare grouped within\n\tbody of a function declaration is a single\n\treturn statement,return\n\tfollowed by the return expression\n\tthat will yield the value of the function application, when the\n\n\tparameters are replaced by the actual arguments to which the function\n\tis applied. Like constant declarations and expression statements,\n\treturn statements\n```\n\n```javascript\nHaving declared square,\n\twe can now use it in a\n\tfunction application expression, which we turn into a statement\n\tusing a semicolon:\n```\n\n```javascript\nsquare_definition\n\nsquare(21);\n```\n\n```javascript\nafter operator\n\tcombinationsthe second kind of combination of\n\texpressions into larger expressions that we encounter.\n\tThe general form of a function application is\n\nfunction-expression(argument-expressions)\n\n\twhere the\n\tfunction-expression\n\tof the application specifies\n\tthe function to be applied to the comma-separated\n        argument-expressions.\n\tTo evaluate a function application, the interpreter follows\n\t.\n\n\t  To evaluate a function application, do the following:\n\n\t      Evaluate the subexpressions of the application, namely\n\t      the function expression and the argument expressions.\n\n\t      Apply the function that is the value of the function expression\n              to the values of the argument expressions.\n```\n\n```javascript\nsquare_definition\n\nsquare(2 + 5);\n```\n\n```javascript\nHere, the argument expression is itself a compound expression,\n\tthe operator combination 2 + 5.\n```\n\n```javascript\nsquare_square\n      81\n      square_definition\n\nsquare(square(3));\n```\n\nOf course function application expressions can also serve as argument expressions.\n\nWe can also use\nfunctions.\n\nFor example, $x^2 +y^2$ can be expressed as\n\n```javascript\nsquare(x) + square(y)\n```\n\nWe can easily declare a\n\n```javascript\nfunction\n\tsum_of_squares\n```\n\nthat, given any two numbers as arguments, produces the sum of their squares:\n\n```javascript\nsum_of_squares\n      25\n      sum_of_squares_example\n      square_definition\n\nfunction sum_of_squares(x, y) {\n    return square(x) + square(y);\n}\n```\n\n```javascript\nsum_of_squares_example\n      25\n      sum_of_squares\n\nsum_of_squares(3, 4);\n```\n\nNow we can use sum_of_squares as a building block in constructing further functions:\n\n```javascript\nf\n      f_example\n      136\n      sum_of_squares\n\nfunction f(a) {\n    return sum_of_squares(a + 1, a * 2);\n}\n```\n\n```javascript\nf_example\n      f\n\nf(5);\n```",
    "token_count": 320,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Compound Functions",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Compound_Functions_2"
  },
  {
    "content": "Now we can use sum_of_squares as a building block in constructing further functions:\n\n```javascript\nIn addition to compound functions, any JavaScript environment provides\n\tmath_log,\n\twhich computes the natural logarithm of its argument.math_log(1) results in the\tnumber 0.\n\tIndeed, one could not tell by looking at the definition of\n\tsum_of_squares given above whether\n\tsquare was built into the\n\tinterpreter, loaded from a library, or defined as a compound function.\n```",
    "token_count": 69,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Compound Functions",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Compound_Functions_3"
  },
  {
    "content": "The expressive power of the class of functions that we can define at this point is very limited, because we have no way to make\n\ntests and to perform different operations depending on the result of a test.\n\n```javascript\n\\[\\begin{array}{lll}\n          |x| & = & \\left\\{ \\begin{array}{rl}\n          x   & \\mbox{if $x \\geq 0$} \\\\\n          -x  & \\mbox{otherwise}\n          \\end{array}\n          \\right.\n      \\end{array}\\]\n\n\tcase analysis and can be written\n\tin JavaScript using a conditional expression as\n\n\t  abs_definition\n          abs_example\n\nfunction abs(x) {\n    return x >= 0 ? x : - x;\n}\n\n          abs_example\n\t  abs_definition\n\t  5\n\nabs(-5);\n\n\twhich could be expressed in English as If $x$ is\n\tgreater than or equal to zero, return$x$; otherwise\n\treturn $- x$.\n        The general form of a conditional expression is\n\npredicate ? consequent-expression : alternative-expression\n\n        Conditional\n\tpredicatethat is,\n        an expression whose value is either\n\ttrue or false, two distinguished\n\tboolean values in JavaScript.\n\tThe primitive boolean expressions\n\ttrue and\n\tfalse trivially evaluate\n\tto the boolean values true and false, respectively.\n\tThe predicate\n        is followed by a question mark, the\n        consequent-expression,\n        a colon, and finally the\n        alternative-expression.\n```\n\nTo\npredicate\nof the expression.\n\nIf the\npredicate\nevaluates to true, the interpreter evaluates the\nconsequent-expression and returns its value as the value of the conditional.\n\nIf the predicate\nevaluates to false, it evaluates the\nalternative-expression and returns its value as the value of the\nconditional.\n\nThe word\npredicate is used for operators and functions that\nreturn true or false, as well as for expressions that\nevaluate to true or false.\n\nThe absolute-value function\nabs makes use of the\n>= ,\nan operator that takes two numbers as arguments and tests whether the\nfirst number is greater than or equal to the second number, returning\ntrue or false accordingly.",
    "token_count": 286,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Conditional Expressions and Predicates",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Conditional_Expressions_and_Predicates_1"
  },
  {
    "content": "The absolute-value function\nabs makes use of the\n>= ,\nan operator that takes two numbers as arguments and tests whether the\nfirst number is greater than or equal to the second number, returning\ntrue or false accordingly.\n\nIf we prefer to handle the zero case separately, we can specify the function that computes the absolute value of a number by writing \\[\\begin{array}{lll}\n\n|x| &=& \\left\\{ \\begin{array}{rl} x & \\mbox{if $x > 0$} \\\\ 0 & \\mbox{if $x = 0$} \\\\ -x & \\mbox{otherwise} \\end{array} \\right. \\end{array}\\] In\n\nJavaScript, we express a case analysis with multiple cases by nesting conditional expressions as alternative expressions inside other conditional expressions:\n\n```javascript\nabs_example\n\nfunction abs(x) {\n    return x > 0\n           ? x\n           : x === 0\n           ? 0\n           : - x;\n}\n```\n\nParentheses are not needed around the alternative expression\nx === 0 ?\n\n0 : - x , because\nthe conditional-expression syntactic form\n? s\nand : s under the first predicate\nof the case analysis.\n\nThe general form of a\n\n```javascript\np$_1$\n? e$_1$\n: p$_2$\n? e$_2$\n$\\vdots$\n: p$_n$\n? e$_n$\n: final-alternative-expression\n```\n\nWe call a predicate $p_i$\ntogether with its consequent expression\n$e_i$\na\nclause.\n\nA case analysis\ncan be seen as a sequence of clauses, followed by a final\nalternative expression.\np $_1$.\n\nIf its value is false, then p $_2$\nis evaluated.\n\nIf p $_2$ s\nvalue is also false, then p $_3$\nis evaluated.\n\nThis process continues until a predicate is\nfound whose value is true, in which case the interpreter returns the\nvalue of the corresponding\ne\nof the clause\nas the value of the case analysis.\n\nIf none of the\np s\nis found to be true, the value of the case analysis\nis the value of the final alternative expression.",
    "token_count": 300,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Conditional Expressions and Predicates",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Conditional_Expressions_and_Predicates_2"
  },
  {
    "content": "If none of the\np s\nis found to be true, the value of the case analysis\nis the value of the final alternative expression.\n\nIn addition to primitive predicates such as\n>= ,\n> ,\n< ,\n<= ,\n=== , and\n!== that are applied to\nnumbers,\n-\n-\nexpression $_1$ &&\nexpression $_2$\nThis operation expresses\nlogical conjunction , meaning roughly\nthe same as the English word and.\n\nWe assume\nexpression $_1$ ?\nexpression $_2$ :\nfalse.\n-\n-\nexpression $_1$\n||\nexpression $_2$\nThis operation expresses\nlogical disjunction , meaning roughly\nthe same as the English word or.\n\nWe assume this syntactic form to be syntactic sugar for\nexpression $_1$ ?\ntrue :\nexpression $_2$.\n-\n-\n!\nexpression\nThis operation expresses\nlogical negation , meaning\nroughly the same as the English word not.\n\nThe value of the expression is true when\nexpression\nevaluates to false, and false when\nexpression\nevaluates to true.\n\nNotice that && and\n|| are syntactic forms,\nnot operators;\n! , on the other hand,\nfollows the evaluation rule of section.\n\nIt is a unary operator, which means that it takes only\none argument, whereas the arithmetic operators and primitive predicates\ndiscussed so far\nare binary , taking two arguments.\n\nThe operator\n! precedes its argument;\nwe call it a\nprefix operator.\n\nAnother prefix operator is\nthe numeric negation operator, an example of\nwhich is the expression - x\nin the abs functions above.\n\nAs an example of how these predicates are used, the condition that a number $x$ be in the range $5 < x < 10$ may\n\nbe expressed as\n\n```javascript\nx > 5 && x < 10\n```",
    "token_count": 279,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Conditional Expressions and Predicates",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Conditional_Expressions_and_Predicates_3"
  },
  {
    "content": "be expressed as\n\nThe syntactic form && has lower precedence than the comparison operators > and < , and the conditional-expression syntactic form $\\cdots$ ? $\\cdots$ : $\\cdots$\n\nhas lower precedence than any other operator we have encountered so far, a property we used in the abs functions above.\n\nAs another example, we can declare a predicate to test whether one number is greater than or equal to another as\n\n```javascript\ngeq_example\n\nfunction greater_or_equal(x, y) {\n    return x > y || x === y;\n}\n```\n\nor alternatively as\n\n```javascript\ngeq_example\n\nfunction greater_or_equal(x, y) {\n    return ! (x < y);\n}\n```\n\n```javascript\ngeq_example\n\ngreater_or_equal(7, 4);\n```\n\n```javascript\nThe function greater_or_equal,\n\twhen applied to two numbers, behaves the same as the operator\n\t>=. Unary operators have\n```",
    "token_count": 127,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Conditional Expressions and Predicates",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Functions_Conditional_Expressions_and_Predicates_4"
  },
  {
    "content": "One of our goals in this chapter is to isolate issues about thinking\nprocedurally.\n\nAs a case in point, let us consider that, in evaluating\noperator\ncombinations, the interpreter is itself following a procedure.\n-\n-\nTo evaluate\nan operator combination,\ndo the following:\n-\n- Evaluate the\noperand expressions\nof the combination.\n-\n-\n\n```javascript\nApply the function that is denoted by\n              the operator to the arguments that are the values of\n              the operands.\n```\n\nrecursive in nature; that is, it includes, as one of its steps, the need to invoke the rule itself.\n\nNotice how succinctly the idea of recursion can be used to express\n\n```javascript\n(2 + 4 * 6) * (3 + 12);\n```\n\nrequires that the evaluation rule be applied to four different\ncombinations.\n\nWe can obtain a picture of this process by\nrepresenting the combination in the form of a\nfigure.\n\nEach combination is represented by a\npercolate values\nupward form of the evaluation rule is an example of a general kind\nof process known as\ntree accumulation.\n\nTree representation, showing the value of each subexpression.\n\nNext, observe that the repeated application of the first step brings\nus to the point where we need to evaluate, not combinations, but\nprimitive expressions such as\nnumerals or names.\n\nWe take care of the primitive cases\n-\n-\nthe values of numerals are the numbers that they name,\nand\n-\n-\nthe values of\nnames are the objects associated\nwith those names in the environment.\n\nThe key point to\nnotice is the role of the\nnames\nin expressions.",
    "token_count": 261,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Evaluating Operator Combinations",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Evaluating_Operator_Combinations_1"
  },
  {
    "content": "The key point to\nnotice is the role of the\nnames\nin expressions.\n\nIn an interactive language such as\nJavaScript,\nit is meaningless to speak of the value of an expression such as\nx + 1\nwithout specifying any information about the environment\nthat would provide a meaning for the\nname\nAs we shall see in chapter 3, the general notion of\nthe environment as providing a context in which evaluation takes place\nwill play an important role in our understanding of program execution.\n\nNotice that the evaluation rule given above does not handle For instance, evaluating\n\n```javascript\nconst x = 3;\n```\n\ndoes not apply\n\n```javascript\nan equality operator =\n```\n\nto two arguments, one of which is the value of the name declaration is precisely to associate\n\n```javascript\nconst x = 3;\n```\n\nis not a combination.)\n\nThe letters in const are\nrendered in bold to indicate that it\nkeyword in JavaScript.\n\nKeywords carry a\nparticular meaning, and thus cannot be used as names.\n\nA keyword or a\ncombination of keywords in a statement instructs the JavaScript\ninterpreter to treat the statement in a special way.\n\nEach such\nsyntactic form has its own evaluation rule.\n\nThe\nvarious kinds of statements and expressions (each with its associated\nevaluation rule) constitute the\n\nThe letters in const are\nrendered in bold to indicate that it\nkeyword in JavaScript.\n\nKeywords carry a\nparticular meaning, and thus cannot be used as names.\n\nA keyword or a\ncombination of keywords in a statement instructs the JavaScript\ninterpreter to treat the statement in a special way.\n\nEach such\nsyntactic form has its own evaluation rule.\n\nThe\nvarious kinds of statements and expressions (each with its associated\nevaluation rule) constitute the",
    "token_count": 285,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Evaluating Operator Combinations",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Evaluating_Operator_Combinations_2"
  },
  {
    "content": "Functions,\nas introduced above, are much like ordinary mathematical functions.\n\nThey\nspecify a value that is determined by one or more parameters.\n\nBut there\nis an important difference between mathematical functions and computer\nfunctions.\n\nComputer functions\nmust be effective.\n\nAs a case in point, consider the problem of computing square\nroots.\n\nWe can define the square-root function as\n\\[\n\\sqrt{x}\\ =\\text{ the }y\\text{ such that }y \\geq 0\\text{ and }\ny^2\\ =\\ x\n\\]\nThis describes a perfectly legitimate mathematical function.\n\nWe could\nuse it to recognize whether one number is the square root of another, or\nto derive facts about square roots in general.\n\nOn the other hand, the\ndefinition does not describe a\ncomputer function.\n\nIndeed, it tells us almost nothing about how to actually find the square\nroot of a given number.\n\nIt will not help matters to rephrase this\ndefinition in\npseudo-JavaScript:\n\n```javascript\nfunction sqrt(x) {\n    return the y $\\texttt{with}$ y >= 0 && square(y) === x;\n}\n```\n\nThis only begs the question.\n\nThe contrast between mathematical function and computer function is a reflection of the general distinction between describing properties of things and describing how to do\n\nthings, or, as it is sometimes referred to, the distinction between\n\nHow does one compute\ns method of successive approximations, which says that whenever\nwe have a guess $y$ for the value of the square\nroot of a number $x$ , we can perform a simple\nmanipulation to get a better guess (one closer to the actual square root)\nby averaging $y$ with\n$x/y$.",
    "token_count": 257,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Example: Square Roots by Newton s Method",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Example_Square_Roots_by_Newton_s_Method_1"
  },
  {
    "content": "How does one compute\ns method of successive approximations, which says that whenever\nwe have a guess $y$ for the value of the square\nroot of a number $x$ , we can perform a simple\nmanipulation to get a better guess (one closer to the actual square root)\nby averaging $y$ with\n$x/y$.\n\n1:\n\\[\n\\begin{array}{lll}\n\\textrm{Guess} & \\textrm{Quotient} & \\textrm{Average}\\\\[1em]\n1 & {\\displaystyle \\frac{2}{1} = 2} & {\\displaystyle \\frac{(2+1)}{2} = 1.5} \\\\[1em]\n1.5 & {\\displaystyle \\frac{2}{1.5} = 1.3333} & {\\displaystyle \\frac{(1.3333+1.5)}{2} = 1.4167} \\\\[1em]\n1.4167 & {\\displaystyle \\frac{2}{1.4167} = 1.4118} & {\\displaystyle \\frac{(1.4167+1.4118)}{2} = 1.4142} \\\\[1em]\n1.4142 & \\ldots & \\ldots\n\\end{array}\n\\]\nContinuing this process, we obtain better and better approximations to the\nsquare root.\n\nNow let s formalize the process in terms of functions.\n\nWe start with\na value for the\nfunction:\n\n```javascript\nsqrt_iter\n      is_good_enough\n      improve\n      sqrt_iter_example\n\nfunction sqrt_iter(guess, x) {\n    return is_good_enough(guess, x)\n           ? guess\n           : sqrt_iter(improve(guess, x), x);\n}\n```\n\n```javascript\nsqrt_iter_example\n\nsqrt_iter(3, 25);\n```\n\nA guess is improved by averaging it with the quotient of the radicand and the old guess:\n\n```javascript\nimprove\n      average_definition\n      improve_example\n\nfunction improve(guess, x) {\n    return average(guess, x / guess);\n}\n```\n\n```javascript\nimprove_example\n\nimprove(3, 25);\n```\n\nwhere\n\n```javascript\naverage_definition\n      average_example\n\nfunction average(x, y) {\n    return (x + y) / 2;\n}\n```\n\n```javascript\naverage_example\n\naverage(3, 6);\n```\n\nWe also have to say what we mean by good enough.\n\nThe\nfollowing will do for illustration, but it is not really a very good\ntest.\n\n(See exercise.)\nThe idea is to improve the answer until it is close enough so that its\nsquare differs from the radicand by less than a predetermined\ntolerance (here 0.001):\n\n```javascript\nis_good_enough\n      abs_definition\n      square_definition\n      is_good_enough_example\n\nfunction is_good_enough(guess, x) {\n    return abs(square(guess) - x) < 0.001;\n}\n```\n\n```javascript\nis_good_enough_example\n\nis_good_enough(1.41, 2);\n```\n\nFinally, we need a way to get started.",
    "token_count": 304,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Example: Square Roots by Newton s Method",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Example_Square_Roots_by_Newton_s_Method_2"
  },
  {
    "content": "Finally, we need a way to get started.\n\nFor instance, we can always guess\nthat the square root of any number\nis 1:\n\n```javascript\nsqrt\n      sqrt_iter\n      sqrt_example_2\n      2.2360688956433634\n\nfunction sqrt(x) {\n    return sqrt_iter(1, x);\n}\n```\n\nIf we type these declarations to the interpreter, we can use function:\n\n```javascript\nsqrt_example\n      sqrt\n\nsqrt(9);\n```\n\n```javascript\nsqrt_example_2\n\nsqrt(5);\n```\n\n```javascript\nsqrt_example_3\n      sqrt\n\nsqrt(100 + 37);\n```\n\n```javascript\nsqrt_example_4\n      1.7739279023207892\n      sqrt\n\nsqrt(sqrt(2) + sqrt(3));\n```\n\n```javascript\nsqrt_example_5\n      sqrt\n\nsquare(sqrt(1000));\n```\n\nThe\nlanguage we have introduced so far is sufficient for writing any purely\nnumerical program that one could write in, say, C or Pascal.\n\nThis might\nseem surprising, since we have not included in our language any iterative\nThe function sqrt_iter,\non the other hand, demonstrates how iteration can be accomplished using no\nspecial construct other than the ordinary ability to call a\nfunction.",
    "token_count": 141,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Example: Square Roots by Newton s Method",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Example_Square_Roots_by_Newton_s_Method_3"
  },
  {
    "content": "One easy way to get started at programming is to examine some typical\ninteractions with an interpreter for the\nJavaScript language.\n\nYou type\na statement,\nand the interpreter responds by displaying the\nresult of its evaluating that\n\n```javascript\nOne kind of statement you might type is an\n        expression statement, which consists of an\n        expression followed by a semicolon.\n```\n\n(More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present JavaScript with the program\n\n```javascript\n486;\n```\n\nthe interpreter will respond by printing\n\nExpressions representing numbers may be combined with operators (such + * ) to form a\n\n```javascript\n137 + 349;\n```\n\n```javascript\n1000 - 334;\n```\n\n```javascript\n5 * 99;\n```\n\n```javascript\n10 / 4;\n```\n\n```javascript\n2.7 + 10;\n```\n\nExpressions such as these, which contain other expressions as components, are called combinations. operator symbol in the middle, and operand expressions to the left\n\nand right of it, are called operator combinations.\n\nThe convention of placing the operator between the operands is\nknown as\ninfix notation.\n\nIt follows the mathematical notation that\nyou are most likely familiar with from school and everyday life.\n\nAs in mathematics, operator combinations can be nested , that\nis, they can have operands that\n\n```javascript\n(3 * 5) + (10 - 6);\n```\n\nAs usual,\n\n```javascript\n3 * 5 + 10 / 2;\n```\n\nstands for\n\n```javascript\n(3 * 5) + (10 / 2);\n```\n\nWe say that * and\n/ have\nhigher precedence\nthan + and\n-.\n\nSequences of additions and\nsubtractions are read from left to right, as are sequences of\nmultiplications and divisions.\n\nThus,\n\n```javascript\n-6\n\n1 - 5 / 2 * 4 + 3;\n```\n\nstands for\n\n```javascript\n(1 - ((5 / 2) * 4)) + 3;\n```\n\nWe say that the operators + , - , * and / are left-associative.",
    "token_count": 314,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Expressions",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Expressions_1"
  },
  {
    "content": "We say that the operators + , - , * and / are left-associative.\n\nThere is no limit (in principle) to the depth of such nesting and to the\noverall complexity of the expressions that the JavaScript interpreter\ncan evaluate.\n\nIt is we humans who might get confused by still relatively\nsimple expressions such as\n\n```javascript\n57\n\n3 * 2 * (3 - 5 + 4) + 27 / 6 * 10;\n```\n\nwhich the interpreter would readily evaluate to be 57.\n\nWe can help\nourselves by writing such an expression in the form\n\n```javascript\n3 * 2 * (3 - 5 + 4)\n+\n27 / 6 * 10;\n```\n\nto visually separate the major components of the expression.\n\nEven with complex expressions, the interpreter always operates in the\nsame basic cycle: It reads\na statement typed by the user,\nevaluates the\nstatement,\nand prints the result.\n\nThis mode of operation is often expressed by saying\nthat the interpreter runs in a\nread-evaluate-print loop.\n\nObserve in particular that it is not necessary to explicitly instruct the\ninterpreter to print the value of the\nstatement.",
    "token_count": 185,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Expressions",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Expressions_2"
  },
  {
    "content": "The function sqrt\nis our first example of a process defined by a set of mutually\ndefined functions.\n\nNotice that the\n\n```javascript\ndeclaration of\n      sqrt_iter\n```\n\nis\nrecursive ; that is, the\nfunction\nis defined in terms of itself.\n\nThe idea of being able to define a\nfunction\nin terms of itself may be disturbing; it may seem unclear how such a\ncircular definition could make sense at all, much less\nspecify a well-defined process to be carried out by a computer.\n\nThis will\nbe addressed more carefully in\nsection.\n\nBut first\nlet s consider some other important points illustrated by the\n\nObserve that the problem of computing square roots breaks up naturally\ninto a number of subproblems:\nfunction.\n\nThe entire\n\n```javascript\nfunctions\n\t(shown in figure)\n```\n\nthat mirrors the decomposition of the problem into subproblems.\n\nThe importance of this\nthe first ten lines, the next\nten lines, the next ten lines, and so on.\n\nRather, it is crucial that\neach\nfunction\naccomplishes an identifiable task that can be used as a module in defining\nother\nfunctions.\n\nFor example, when we define the\nis_good_enough function\nin terms of\nfunction\nas a\nblack box.\n\nWe are not at that moment concerned with\nhow the\nfunction\ncomputes its result, only with the fact that it computes the\nsquare.\n\nThe details of how the square is computed can be suppressed,\nto be considered at a later time.\n\nIndeed, as far as the\nis_good_enough function\nis concerned,\nfunction\nbut rather an abstraction of a\nfunction,\na so-called\nfunctional abstraction.\n\nAt this level of abstraction, any\nfunction\nthat computes the square is equally good.\n\nThus, considering only the values they return, the following two\nfunctions\nsquaring a number should be indistinguishable.\n\nEach takes a numerical\nargument and produces the square of that number as the value.",
    "token_count": 301,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Functions as Black-Box Abstractions",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Black-Box_Abstractions_1"
  },
  {
    "content": "Each takes a numerical\nargument and produces the square of that number as the value.\n\n```javascript\nsquare_example\n\nfunction square(x) {\n    return x * x;\n}\n```\n\n```javascript\nsquare_example\n\nfunction square(x) {\n    return math_exp(double(math_log(x)));\n}\nfunction double(x) {\n    return x + x;\n}\n```\n\nSo a\nfunction\nshould be able to suppress detail.\n\nThe users of the\nfunction\nmay not have written the\nfunction\nthemselves, but may have obtained it from another programmer as a\nblack box.\n\nA user should not need to know how the\nfunction\nis implemented in order to use it.\n\nOne detail of a\nfunctions\nimplementation that should not matter to the user of the\nfunction\nis the implementer s choice of names for the\nfunctions parameters.\n\nThus, the following\nfunctions\nshould not be distinguishable:\n\n```javascript\nsquare_example\n\nfunction square(x) {\n    return x * x;\n}\n```\n\n```javascript\nsquare_example\n\nfunction square(y) {\n    return y * y;\n}\n```\n\nThis principle that the meaning of a\nfunction\nshould be independent of the parameter names used by its\nauthor seems on the surface to be self-evident, but its\nconsequences are profound.\n\nThe simplest consequence is that the\nparameter names of a\nfunction\nmust be local to the body of the\nfunction.\n\nFor example, we used\n\n```javascript\nin the declaration of\n        is_good_enough\n```\n\nin our square-root function:\n\n```javascript\nis_good_enough_example\n      abs_definition\n      square_definition\n\nfunction is_good_enough(guess, x) {\n    return abs(square(guess) - x) < 0.001;\n}\n```\n\nThe intention of the author of\nis_good_enough\nis to determine if the square of the first argument is within a given\ntolerance of the second argument.\n\nWe see that the author of\nis_good_enough\nused the name\nis_@good_@enough\nmust be a different\nfunction\nis_good_enough,\nbecause that value of\nis_good_enough\nafter\n\nIf the parameters were not local to the bodies of their respective functions, then the parameter is_@good_@enough, and the behavior of is_good_enough would depend upon\n\nwhich version of",
    "token_count": 309,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Functions as Black-Box Abstractions",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Black-Box_Abstractions_2"
  },
  {
    "content": "which version of\n\nA\nparameter of a function\nhas a very special role in the\nfunction declaration,\nin that it doesn t matter what name the\nparameter has.\n\nSuch a name is called\nbound, and we say that the function declaration\nbinds its\nparameters.\n\nThe meaning of a\nfunction declaration is unchanged if a bound name\nis consistently renamed throughout the\ndeclaration.\nname\nis not bound, we say that it is\nfree.\n\nThe set of\nstatements\nfor which a binding\ndeclares\na name is called the\nscope of that name.\n\nIn a\nfunction declaration, the bound names\ndeclared as the\nparameters of the function\nhave the body of the\nfunction\nas their scope.\n\nIn the\ndeclaration of is_good_enough\nabove,\nnames\nbut\nis_good_enough\nshould be independent of the names we choose for\ncapturing the\nname\nis_good_enough\nis not independent of the\nchoice of its free names,\nhowever.\n\nIt surely depends upon the fact\n(external to this declaration)\nthat the name\nfor computing the absolute value of a number.\n\nThe function is_good_enough\nwill compute a different function if we substitute\n\n```javascript\nmath_cos\n\t(the primitive cosine function)\n```\n\nfor declaration.\n\nWe have one kind of name isolation available to us so far:\nThe parameters of a function\nare local to the body of the\nfunction.\n\nThe square-root program illustrates another way in which we would like to\ncontrol the use of names.\nfunctions:\n\n```javascript\nsqrt_example_2\n        abs_definition\n        square_definition\n        average_definition\n\nfunction sqrt(x) {\n    return sqrt_iter(1, x);\n}\nfunction sqrt_iter(guess, x) {\n    return is_good_enough(guess, x)\n           ? guess\n           : sqrt_iter(improve(guess, x), x);\n}\nfunction is_good_enough(guess, x) {\n    return abs(square(guess) - x) < 0.001;\n}\nfunction improve(guess, x) {\n    return average(guess, x / guess);\n}\n```\n\nThe problem with this program is that the only function that is important to users of functions\n\n```javascript\n(sqrt_iter,\n\tis_good_enough,\n```",
    "token_count": 299,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Functions as Black-Box Abstractions",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Black-Box_Abstractions_3"
  },
  {
    "content": "The problem with this program is that the only function that is important to users of functions\n\nand\ndeclare any other function\ncalled\nis_good_enough\nas part of another program to work together\nwith the square-root program, because\nfunctions,\nmany numerical functions are computed as successive approximations and\nthus might have\nfunctions\nnamed\nis_good_enough\nand\nfunctions.\n\nWe would like to localize the\nsubfunctions,\nhiding them inside\nis_good_enough function.\n\nTo make this possible, we allow a\nfunction\nto have\ninternal declarations that are local to that\nfunction.\n\nFor example, in the square-root problem we can write\n\n```javascript\nsqrt_example_2\n      2.2360688956433634\n      abs_definition\n      square_definition\n      average_definition\n\nfunction sqrt(x) {\n    function is_good_enough(guess, x) {\n        return abs(square(guess) - x) < 0.001;\n    }\n    function improve(guess, x) {\n        return average(guess, x / guess);\n    }\n    function sqrt_iter(guess, x) {\n        return is_good_enough(guess, x)\n               ? guess\n               : sqrt_iter(improve(guess, x), x);\n    }\n    return sqrt_iter(1, x);\n}\n```\n\n```javascript\nAny matching pair of braces designates a block, and\n\tdeclarations inside the block are local to the block.\n```\n\nSuch nesting of\ndeclarations,\ncalled block structure , is basically the right solution to the\nsimplest name-packaging problem.\n\nBut there is a better idea lurking here.\n\nIn addition to internalizing the\ndeclarations of the auxiliary functions,\nwe can simplify them.\n\nSince\ndeclaration\nof\nfunctions\nis_good_enough,\n\n```javascript\nsqrt_iter,\n      which are declared internally to\n```\n\nfunctions.\n\nInstead, we allow\nname\nin the internal\ndeclarations,\nas shown below.\n\nThen\nfunction\nlexical scoping.\n\n```javascript\nsqrt_example_2\n      abs_definition\n      square_definition\n      average_definition\n\nfunction sqrt(x) {\n    function is_good_enough(guess) {\n        return abs(square(guess) - x) < 0.001;\n    }\n    function improve(guess) {\n        return average(guess, x / guess);\n    }\n    function sqrt_iter(guess) {\n        return is_good_enough(guess)\n               ? guess\n               : sqrt_iter(improve(guess));\n    }\n    return sqrt_iter(1);\n}\n```\n\nWe will use block structure extensively to help us break up large programs\ninto tractable pieces.\n\n60.",
    "token_count": 290,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Functions as Black-Box Abstractions",
    "chunk_index": 4,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Black-Box_Abstractions_4"
  },
  {
    "content": "60.\n\nIt appears in most advanced programming languages and is an\nimportant tool for helping to organize the construction of large programs.",
    "token_count": 22,
    "has_code": false,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Functions as Black-Box Abstractions",
    "chunk_index": 5,
    "chunk_id": "Building_Abstractions_with_Functions_Functions_as_Black-Box_Abstractions_5"
  },
  {
    "content": "A critical aspect of a programming language is the means it provides for using objects, and our first such means are constants. constant whose value\n\nis the object.\n\n```javascript\nIn JavaScript, we name constants with\n\tconstant declarations.\n```\n\n```javascript\nvar_size\n\nconst size = 2;\n```\n\ncauses the interpreter to associate the value 2 with the name\n\n```javascript\nsize_use_1\n      var_size\n      2\n\nsize;\n```\n\n```javascript\nsize_use_2\n      var_size\n      10\n\n5 * size;\n```\n\nHere are further examples of the use of const:\n\n```javascript\npi\n\nconst pi = 3.14159;\n```\n\n```javascript\nradius\n\nconst radius = 10;\n```\n\n```javascript\npi_radius_radius\n      314.159\n      pi\n      radius\n\npi * radius * radius;\n```\n\n```javascript\ncircumference_definition\n      pi\n      radius\n\nconst circumference = 2 * pi * radius;\n```\n\n```javascript\n62.8318\n      circumference_use\n      circumference_definition\n\ncircumference;\n```\n\nConstant is our language s simplest means of abstraction, for it allows us to use simple names to refer to the results of compound operations,\n\nsuch as the JavaScript program usually consists of a large number of relatively simple functions.\n\nIt should be clear that the possibility of associating values with\nnames and later retrieving them means that the interpreter must\nmaintain some sort of memory that keeps track of the name-object\npairs.\n\nThis memory is called the\nenvironment\n(more precisely the\nprogram environment,\nsince we will see later that a\ncomputation may involve a number of different\nenvironments).",
    "token_count": 222,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "Naming and the Environment",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_Naming_and_the_Environment_1"
  },
  {
    "content": "```javascript\nTo evaluate a function application, the interpreter follows the process\n\tdescribed in section.\n```\n\nThat is, the interpreter evaluates the elements of the application and applies the function (which is the value of the function expression of the application)\n\nto the arguments (which are the values of the argument expressions of the application).\n\n```javascript\nWe can assume that the application of primitive\n\tfunctions is handled by the interpreter or libraries.\n```\n\nFor compound\nfunctions,\nthe application process is as follows:\n-\n-\nTo apply a compound\nfunction\nto arguments,\nevaluate the return expression of the function\nwith each\nparameter replaced by the corresponding argument.\n\nTo illustrate this process, let s evaluate the\napplication\n\n```javascript\nf_of_five\n      f\n      136\n\nf(5)\n\nf(5);\n```\n\nwhere\nfunction declared\nin section.\n\nWe begin by retrieving the\nreturn expression\nof\n\n```javascript\nf\n\nsum_of_squares(a + 1, a * 2)\n```\n\nThen we replace the parameter\n\n```javascript\nsum_of_squares(5 + 1, 5 * 2)\n```\n\nThus the problem reduces to the evaluation of an application with two arguments and\n\n```javascript\na function expression\n\tsum_of_squares.\n```\n\nEvaluating this\napplication\ninvolves three subproblems.\n\nWe must evaluate the\nfunction expression\nto get the\nfunction\nto be applied, and we must evaluate the\nargument expressions\nto get the arguments.\n\nNow\n5 + 1\nproduces 6 and\n5 * 2\nproduces 10, so we must apply the\nsum_of_squares function\nto 6 and 10.\n\nThese values are substituted for the\nparameters\nsum_of_squares,\nreducing the expression to\n\n```javascript\nsquare(6) + square(10)\n```\n\nIf we use the declaration of\n\n```javascript\n(6 * 6) + (10 * 10)\n```\n\nwhich reduces by multiplication to\n\n```javascript\n36 + 100\n```\n\nand finally to\n\n```javascript\n136\n```\n\nThe process we have just described is called the substitution\nmodel for\nfunction\napplication.\n\nIt can be taken as a model that\ndetermines the meaning of\nfunction\napplication, insofar as the\nfunctions\nin this chapter are concerned.",
    "token_count": 314,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "The Substitution Model for Function Application",
    "chunk_index": 1,
    "chunk_id": "Building_Abstractions_with_Functions_The_Substitution_Model_for_Function_Application_1"
  },
  {
    "content": "It can be taken as a model that\ndetermines the meaning of\nfunction\napplication, insofar as the\nfunctions\nin this chapter are concerned.\n\nHowever, there are two\npoints that should be stressed:\n-\n-\nThe purpose of the substitution is to help us think about\nfunction\napplication, not to provide a description of how the interpreter\nreally works.\n\nTypical interpreters do not evaluate\nfunction\napplications by manipulating the text of a\nfunction to substitute values for the\nparameters.\n\nIn practice, the substitution is\naccomplished by using a local environment for the\nparameters.\n\nWe will discuss this more fully in chapters 3 and\n4 when we examine the implementation of an interpreter in detail.\n-\n-\nOver the course of this book, we will present a sequence of\nincreasingly elaborate models of how interpreters work, culminating\nwith a complete implementation of an interpreter and compiler in\nchapter.\n\nThe substitution model is only the first of\nthese models a way to get started thinking formally\nabout the evaluation process.\n\nIn general, when\nthe use of\nfunctions\nwith mutable data, we will see that the substitution\nmodel breaks down and must be replaced by a more complicated model of\nfunction\napplication.\n\nAccording to the description of evaluation given in\nsection,\nthe interpreter first evaluates the\nfunction\nand\nargument expressions\nand then applies the resulting\nfunction\nto the resulting arguments.\n\nThis is not the only way to perform evaluation.\n\nAn alternative evaluation model would not evaluate the\narguments\nuntil their values were needed.\n\nInstead it would first substitute\nargument\nexpressions for parameters until it obtained an expression involving\nonly\noperators and primitive functions,\nand would then perform the evaluation.\n\nIf we\nused this method, the evaluation of\n\n```javascript\nf(5)\n```\n\nwould proceed according to the sequence of expansions",
    "token_count": 294,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "The Substitution Model for Function Application",
    "chunk_index": 2,
    "chunk_id": "Building_Abstractions_with_Functions_The_Substitution_Model_for_Function_Application_2"
  },
  {
    "content": "would proceed according to the sequence of expansions\n\n```javascript\nsum_of_squares(5 + 1, 5 * 2)\n\nsquare(5 + 1)     + square(5 * 2)\n\n(5 + 1) * (5 + 1) + (5 * 2) * (5 * 2)\n```\n\nfollowed by the reductions\n\n```javascript\n6    *    6    +    10   *   10\n\n    36         +        100\n\n              136\n```\n\nThis gives the same answer as our previous evaluation model, but the\nprocess is different.\n\nIn particular, the evaluations of\n5 + 1\nand\n5 * 2\nare each performed twice here, corresponding to the reduction of the\nexpression\n\n```javascript\nx * x\n```\n\nwith 5 + 1 and 5 * 2.\n\nThis alternative fully expand and then reduce\nevaluation method is known as\nnormal-order evaluation , in contrast to the evaluate\nthe arguments and then apply method that the interpreter actually\nuses, which is called\napplicative-order evaluation.\n\nIt can be shown that, for\nfunction\napplications that can be modeled using substitution (including all the\nfunctions\nin the first two chapters of this book) and that yield legitimate values,\nnormal-order and applicative-order evaluation produce the same value.\n\n(See exercise\nfor an instance of an illegitimate value where normal-order\nand applicative-order evaluation do not give the same result.)\n\nJavaScript uses applicative-order evaluation, partly because of the additional efficiency obtained from avoiding multiple evaluations of expressions such as those illustrated with\n\n```javascript\n5 + 1\n\tand 5 * 2\n```\n\nabove and, more significantly, because normal-order evaluation\nbecomes much more complicated to deal with when we leave the realm of\nfunctions\nthat can be modeled by substitution.\n\nOn the other hand,\nnormal-order evaluation can be an extremely valuable tool, and we will\ninvestigate some of its implications in chapters 3 and 4.",
    "token_count": 285,
    "has_code": true,
    "chapter": "Building Abstractions with Functions",
    "section": "The Elements of Programming",
    "subsection": "The Substitution Model for Function Application",
    "chunk_index": 3,
    "chunk_id": "Building_Abstractions_with_Functions_The_Substitution_Model_for_Function_Application_3"
  },
  {
    "content": "We began this book by studying processes and by describing processes\nin terms of\nfunctions\nwritten in\nJavaScript.\n\nTo explain the meanings of these\nfunctions,\nwe used a succession of models of evaluation: the\nsubstitution model of chapter , the environment model of\nchapter , and the metacircular evaluator of chapter.\n\nOur\nexamination of the metacircular evaluator, in particular, dispelled much of\nthe mystery of how\nJavaScript-like languages are interpreted.\n\nBut even the metacircular evaluator leaves important questions\nunanswered, because it fails to elucidate the mechanisms of control in a\nJavaScript\nsystem.\n\nFor instance, the evaluator does not explain how the\nevaluation of a subexpression manages to return a value to the\nexpression that uses this value.\n\n```javascript\nAlso, the evaluator does not explain how some recursive\n        functions can generate iterative processes (that is, be\n        evaluated using constant space) whereas other recursive\n        functions will generate recursive processes.\n```\n\nWe\nwill describe processes in terms of the step-by-step\noperation of a traditional computer.\n\nSuch a computer, or\nregister machine , sequentially executes\ninstructions that\nmanipulate the contents of a fixed set of storage elements called\nregisters.\n\nA typical register-machine instruction applies a\nprimitive operation to the contents of some registers and assigns the\nresult to another register.\n\nOur descriptions of processes executed by\nregister machines will look very much like machine-language\nprograms for traditional computers.\n\nHowever, instead of focusing on\nthe machine language of any particular computer, we will examine\nseveral\nJavaScript\nfunctions\nand design a specific register machine to\nexecute each\nfunction.\n\nThus, we will approach our task from the\nperspective of a hardware architect rather than that of a\nmachine-language computer programmer.\n\nIn designing register machines,\nwe will develop mechanisms for implementing important programming\nconstructs such as recursion.\n\nWe will also present a language for\ndescribing designs for register machines.",
    "token_count": 301,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": null,
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_Computing_with_Register_Machines_1"
  },
  {
    "content": "We will also present a language for\ndescribing designs for register machines.\n\nIn\nsection we will\nimplement a\nJavaScript\nprogram that uses these descriptions to simulate the machines we design.\n\nMost of the primitive operations of our register machines are very\nsimple.\n\nFor example, an operation might add the numbers fetched from\ntwo registers, producing a result to be stored into a third register.\n\nSuch an operation can be performed by easily described hardware.\n\nIn\norder to deal with list structure, however, we will also use the\nmemory operations\nhead,\ntail,\nand\npair,\nwhich require an elaborate storage-allocation mechanism.\n\nIn\nsection we study their\nimplementation in terms of more elementary operations.\n\nIn section , after we have accumulated\nexperience formulating simple\nfunctions\nas register machines, we will design a\nmachine that carries out the algorithm described by the metacircular\nevaluator of section.\n\nThis will fill in\nthe gap in our understanding of how\nJavaScript programs\nare interpreted, by providing an explicit model for the mechanisms of\ncontrol in the evaluator.\n\nIn section we will study a simple\ncompiler that translates\nJavaScript\nprograms into sequences of instructions that can be executed directly with\nthe registers and operations of the evaluator register machine.",
    "token_count": 201,
    "has_code": false,
    "chapter": "Computing with Register Machines",
    "section": null,
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_Computing_with_Register_Machines_2"
  },
  {
    "content": "In order to gain a good understanding of the design of register machines,\nwe must test the machines we design to see if they perform as expected.\n\nOne way to test a design is to hand-simulate the operation of the\ncontroller, as in exercise.\n\nBut this is\nextremely tedious for all but the simplest machines.\n\nIn this section we\nconstruct a simulator for machines described in the register-machine\nlanguage.\n\nThe simulator is a\nJavaScript\nprogram with\nfour interface\nfunctions.\n\nThe first uses a description of a register\nmachine to construct a model of the machine (a data structure whose\nparts correspond to the parts of the machine to be simulated), and the\nother three allow us to simulate the machine by manipulating the\nmodel:\n-\n-\nmake_machine(register-names, operations, controller)\nconstructs and returns a model of the machine with the given\nregisters, operations, and controller.\n-\n-\nset_register_contents(machine-model, register-name, value)\nstores a value in a simulated register in the given machine.\n-\n-\nget_register_contents(machine-model, register-name)\nreturns the contents of a simulated register in the given machine.\n-\n-\nstart(machine-model)\nsimulates the execution of the given machine, starting from the\nbeginning of the controller sequence and stopping when it reaches the\nend of the sequence.\n\nAs an example of how these functions are used, we can define gcd_machine to be a model of the GCD machine of section as follows:\n\n```javascript\ngcd_machine_example\n      gcd_machine\n      start\n\nset_register_contents(gcd_machine, \"a\", 206);\nset_register_contents(gcd_machine, \"b\", 40);\nstart(gcd_machine);\nget_register_contents(gcd_machine, \"a\");\n```\n\n```javascript\ngcd_machine\n      make_machine\n      gcd_machine_example\n      2\n\nconst gcd_machine =\n    make_machine(\n        list(\"a\", \"b\", \"t\"),\n        list(list(\"rem\", (a, b) => a % b),\n             list(\"=\", (a, b) => a === b)),\n        list(\n          \"test_b\",\n            test(list(op(\"=\"), reg(\"b\"), constant(0))),\n            branch(label(\"gcd_done\")),\n            assign(\"t\", list(op(\"rem\"), reg(\"a\"), reg(\"b\"))),\n            assign(\"a\", reg(\"b\")),\n            assign(\"b\", reg(\"t\")),\n            go_to(label(\"test_b\")),\n          \"gcd_done\"));\n```\n\nThe first argument to\nmake_machine\nis a list of register names.",
    "token_count": 296,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_A_Register-Machine_Simulator_1"
  },
  {
    "content": "The first argument to\nmake_machine\nis a list of register names.\n\nThe next argument is a table (a list of\ntwo-element lists) that pairs each operation name with a\nJavaScript function\nthat implements the operation (that is, produces the same output value\ngiven the same input values).\n\nThe last argument specifies the controller\nas a list of labels and machine instructions, as in\nsection.\n\nTo compute GCDs with this machine, we set the input registers, start the machine, and examine the result when the simulation terminates:\n\n```javascript\nset_register_contents_a\n      gcd_machine\n      start\n      'done'\n\nset_register_contents(gcd_machine, \"a\", 206);\n```\n\n```javascript\nset_register_contents_b\n      set_register_contents_a\n      'done'\n\nset_register_contents(gcd_machine, \"b\", 40);\n```\n\n```javascript\nstart_gcd_machine\n      set_register_contents_b\n      'done'\n\nstart(gcd_machine);\n```\n\n```javascript\nget_register_contents_a\n      start_gcd_machine\n      2\n\nget_register_contents(gcd_machine, \"a\");\n```\n\nThis computation will run much more slowly than a function written in JavaScript, because we will simulate low-level machine instructions, such as",
    "token_count": 138,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_A_Register-Machine_Simulator_2"
  },
  {
    "content": "The assembler calls\nmake_execution_function\nto generate the execution\nfunction\nfor a controller instruction.\n\nLike the\nfunction\nin the evaluator of section ,\nthis dispatches on the type of instruction to generate the appropriate\nexecution\nfunction.\n\n```javascript\nThe details of these execution functions determine the\n        meaning of the individual instructions in the register-machine language.\n```\n\n```javascript\ngcd_machine_complete_example\n\nfunction make_execution_function(inst, labels, machine,\n                                 pc, flag, stack, ops) {\n    const inst_type = type(inst);\n    return inst_type === \"assign\"\n           ? make_assign_ef(inst, machine, labels, ops, pc)\n           : inst_type === \"test\"\n           ? make_test_ef(inst, machine, labels, ops, flag, pc)\n           : inst_type === \"branch\"\n           ? make_branch_ef(inst, machine, labels, flag, pc)\n           : inst_type === \"go_to\"\n           ? make_go_to_ef(inst, machine, labels, pc)\n           : inst_type === \"save\"\n           ? make_save_ef(inst, machine, stack, pc)\n           : inst_type === \"restore\"\n           ? make_restore_ef(inst, machine, stack, pc)\n           : inst_type === \"perform\"\n           ? make_perform_ef(inst, machine, labels, ops, pc)\n           : error(inst, \"unknown instruction type -- assemble\");\n}\n```\n\n```javascript\nmake_execution_function\n      make_assign\n      make_test\n      test_instruction_syntax\n      make_branch_5\n      branch_branch_dest\n      make_go_to\n      go_to_go_to_dest\n      make_save\n      save_restore\n      make_perform\n      perform_perform_action\n      gcd_machine_complete_example\n\nfunction make_execution_function(inst, labels, machine,\n                                 pc, flag, stack, ops) {\n    return type(inst) === \"assign\"\n           ? make_assign_ef(inst, machine, labels, ops, pc)\n           : type(inst) === \"test\"\n           ? make_test_ef(inst, machine, labels, ops, flag, pc)\n           : type(inst) === \"branch\"\n           ? make_branch_ef(inst, machine, labels, flag, pc)\n           : type(inst) === \"go_to\"\n           ? make_go_to_ef(inst, machine, labels, pc)\n           : type(inst) === \"save\"\n           ? make_save_ef(inst, machine, stack, pc)\n           : type(inst) === \"restore\"\n           ? make_restore_ef(inst, machine, stack, pc)\n           : type(inst) === \"push_marker_to_stack\"\n           ? make_push_marker_to_stack_ef(machine, stack, pc)\n           : type(inst) === \"revert_stack_to_marker\"\n           ? make_revert_stack_to_marker_ef(machine, stack, pc)\n           : type(inst) === \"perform\"\n           ? make_perform_ef(inst, machine, labels, ops, pc)\n           : error(inst, \"unknown instruction type -- assemble\");\n}\n```",
    "token_count": 262,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "Instructions and Their Execution Functions",
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_Instructions_and_Their_Execution_Functions_1"
  },
  {
    "content": "Like the\nfunction\nin the evaluator of section ,\nthis dispatches on the type of instruction to generate the appropriate\nexecution\nfunction.\n\n```javascript\nThe elements of the controller sequence\n        received by make_machine and passed\n        to assemble are strings (for\n        labels) and tagged lists (for instructions). The tag in an instruction\n        is a string that identifies the instruction type, such as\n        \"go_to\", and the remaining elements\n        of the list contains the arguments, such as the destination of the\n        go_to.\n        The dispatch in make_execution_function uses\n\n\t  type_function\n          gcd_machine_complete_example\n\nfunction type(instruction) { return head(instruction); }\n```\n\nThe tagged lists are constructed when the\nlist expression that is the third\nargument to make_machine is\nevaluated.\n\nEach argument to that\nlist is either a string (which\nevaluates to itself) or a call to a constructor for an instruction\ntagged list.\n\nFor example, assign(\"b\", reg(\"t\")) calls the constructor\nassign with arguments\n\"b\" and the result of calling the\nconstructor reg with the argument\n\"t\".\n\nThe constructors and their\narguments determine the syntax of the individual instructions in the\nregister-machine language.\n\nThe instruction constructors and selectors\nare shown below, along with the execution-function generators that use\nthe selectors.\n\nThe make_assign_ef function makes execution functions for assign instructions:\n\n```javascript\nmake_assign\n      type_function\n      make_operation_exp\n      assign_reg_name\n      gcd_machine_complete_example\n\nfunction make_assign_ef(inst, machine, labels, operations, pc) {\n    const target = get_register(machine, assign_reg_name(inst));\n    const value_exp = assign_value_exp(inst);\n    const value_fun =\n        is_operation_exp(value_exp)\n        ? make_operation_exp_ef(value_exp, machine, labels, operations)\n        : make_primitive_exp_ef(value_exp, machine, labels);\n    return () => {\n               set_contents(target, value_fun());\n               advance_pc(pc);\n           };\n}\n```\n\n```javascript\nThe function assign constructs\n\tassign instructions.\n\tThe selectors assign_@reg_@name and\n\tassign_value_exp extract the register name\n\tand value expression from an assign instruction.\n```\n\n```javascript\nassign_reg_name\n\n      gcd_machine_complete_example\n\nfunction assign(register_name, source) {\n    return list(\"assign\", register_name, source);\n}\nfunction assign_reg_name(assign_instruction) {\n    return head(tail(assign_instruction));\n}\nfunction assign_value_exp(assign_instruction) {\n    return head(tail(tail(assign_instruction)));\n}\n```",
    "token_count": 293,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "Instructions and Their Execution Functions",
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_Instructions_and_Their_Execution_Functions_2"
  },
  {
    "content": "The make_assign_ef function makes execution functions for assign instructions:\n\nThe function make_assign_ef looks up the register name\nwith\nget_register\nto produce the target register object.\n\nThe value expression is passed to\nmake_@operation_@exp_@ef\nif the value is the result of an operation, and\nit is passed\nto\nmake_@primitive_@exp_@ef\notherwise.\n\nThese\nfunctions\n(shown below)\nanalyze\nthe value expression and produce an execution\nfunction\nfor the value.\n\nThis is a\nfunction\nof no arguments, called\nvalue_fun,\nwhich will be evaluated during the simulation to produce the actual\nvalue to be assigned to the register.\n\nNotice that the work of looking\nup the register name and\nanalyzing\nthe value expression is performed\njust once, at assembly time, not every time the instruction is\nsimulated.\n\nThis saving of work is the reason we use execution\nfunctions,\nand corresponds directly to the saving in work we obtained by separating\nprogram analysis from execution in the evaluator of\nsection.\n\nThe result returned by\nmake_assign_ef\nis the execution\nfunction\nfor the\nfunction\nis called (by the machine model s\nfunction),\nit sets the contents of the target register to the result obtained by\nexecuting\nvalue_fun.\n\nThen it advances the\nfunction\n\n```javascript\nadvance_pc\n      gcd_machine_complete_example\n\nfunction advance_pc(pc) {\n    set_contents(pc, tail(get_contents(pc)));\n}\n```\n\n```javascript\nThe function\n\tadvance_pc\n```\n\nis the normal termination for all instructions except go_to.\n\n```javascript\nThe function\n\tmake_test_ef\n```\n\nhandles\nfunction\nfor it.\n\nAt simulation time, the\nfunction\nfor the condition is called, the result is assigned to the\n\n```javascript\nmake_test\n      advance_pc\n      gcd_machine_complete_example\n\nfunction make_test_ef(inst, machine, labels, operations, flag, pc) {\n    const condition = test_condition(inst);\n    if (is_operation_exp(condition)) {\n        const condition_fun = make_operation_exp_ef(\n                                  condition, machine,\n                                  labels, operations);\n        return () => {\n                   set_contents(flag, condition_fun());\n                   advance_pc(pc);\n               };\n    } else {\n        error(inst, \"bad test instruction -- assemble\");\n    }\n}\n```",
    "token_count": 288,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "Instructions and Their Execution Functions",
    "chunk_index": 3,
    "chunk_id": "Computing_with_Register_Machines_Instructions_and_Their_Execution_Functions_3"
  },
  {
    "content": "At simulation time, the\nfunction\nfor the condition is called, the result is assigned to the\n\n```javascript\nThe function\n\ttest constructs\n\ttest instructions. The selector\n\ttest_condition extracts the condition\n\tfrom a test.\n\n\t  test_instruction_syntax\n          gcd_machine_complete_example\n\nfunction test(condition) { return list(\"test\", condition); }\n\nfunction test_condition(test_instruction) {\n    return head(tail(test_instruction));\n}\n```\n\nThe execution\nfunction\nfor a\nmake_branch_ef\nfunction\nenforces this.\n\nNotice also that the label is looked up at assembly time,\nnot each time the\n\n```javascript\nmake_branch_5\n      gcd_machine_complete_example\n\nfunction make_branch_ef(inst, machine, labels, flag, pc) {\n    const dest = branch_dest(inst);\n    if (is_label_exp(dest)) {\n        const insts = lookup_label(labels, label_exp_label(dest));\n        return () => {\n                   if (get_contents(flag)) {\n                       set_contents(pc, insts);\n                   } else {\n                       advance_pc(pc);\n                   }\n               };\n    } else {\n        error(inst, \"bad branch instruction -- assemble\");\n    }\n}\n```\n\n```javascript\nThe function branch\n\tconstructs branch instructions. The\n\tselector\n\tbranch_dest extracts\n\tthe destination from a branch.\n\n\t  branch_branch_dest\n          gcd_machine_complete_example\n\nfunction branch(label) { return list(\"branch\", label); }\n\nfunction branch_dest(branch_instruction) {\n    return head(tail(branch_instruction));\n}\n```\n\nA go_to instruction is similar to a branch, except that the destination may be specified either as a label or as a register, and there\n\nis no condition to check the\n\n```javascript\nmake_go_to\n      is_register_exp\n      gcd_machine_complete_example\n\nfunction make_go_to_ef(inst, machine, labels, pc) {\n    const dest = go_to_dest(inst);\n    if (is_label_exp(dest)) {\n        const insts = lookup_label(labels, label_exp_label(dest));\n        return () => set_contents(pc, insts);\n    } else if (is_register_exp(dest)) {\n        const reg = get_register(machine, register_exp_reg(dest));\n        return () => set_contents(pc, get_contents(reg));\n    } else {\n        error(inst, \"bad go_to instruction -- assemble\");\n    }\n}\n```\n\n```javascript\nThe function go_to constructs\n\tgo_to instructions. The selector\n\tgo_to_dest extracts the destination from a\n\tgo_to instruction.\n\n\t  go_to_go_to_dest\n          make_go_to\n          gcd_machine_complete_example\n\nfunction go_to(label) { return list(\"go_to\", label); }\n\nfunction go_to_dest(go_to_instruction) {\n    return head(tail(go_to_instruction));\n}\n```\n\nThe stack instructions",
    "token_count": 275,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "Instructions and Their Execution Functions",
    "chunk_index": 4,
    "chunk_id": "Computing_with_Register_Machines_Instructions_and_Their_Execution_Functions_4"
  },
  {
    "content": "The stack instructions\n\n```javascript\nmake_save\n      pop\n      gcd_machine_complete_example\n\nfunction make_save_ef(inst, machine, stack, pc) {\n    const reg = get_register(machine, stack_inst_reg_name(inst));\n    return () => {\n               push(stack, get_contents(reg));\n               advance_pc(pc);\n           };\n}\nfunction make_restore_ef(inst, machine, stack, pc) {\n    const reg = get_register(machine, stack_inst_reg_name(inst));\n    return () => {\n               set_contents(reg, pop(stack));\n               advance_pc(pc);\n           };\n}\n```\n\n```javascript\nThe functions save and\n\trestore construct\n\tsave and restore instructions. The\n\tselector\n\tstack_inst_reg_name\n\textracts the register name from such instructions.\n\n\t  save_restore\n\t  make_save\n\t  gcd_machine_complete_example\n\nfunction save(reg) { return list(\"save\", reg); }\n\nfunction restore(reg) { return list(\"restore\", reg); }\n\nfunction stack_inst_reg_name(stack_instruction) {\n    return head(tail(stack_instruction));\n}\n```\n\nThe final instruction type, handled by\nmake_perform_ef,\ngenerates an execution\nfunction\nfor the action to be performed.\n\nAt simulation time, the action\nfunction\nis executed and the\n\n```javascript\nmake_perform\n      is_register_exp\n      gcd_machine_complete_example\n\nfunction make_perform_ef(inst, machine, labels, operations, pc) {\n    const action = perform_action(inst);\n    if (is_operation_exp(action)) {\n        const action_fun = make_operation_exp_ef(action, machine,\n                                                 labels, operations);\n        return () => {\n                   action_fun();\n                   advance_pc(pc);\n               };\n    } else {\n        error(inst, \"bad perform instruction -- assemble\");\n    }\n}\n```\n\n```javascript\nThe function perform\n\tconstructs perform instructions. The\n\tselector\n\tperform_@action extracts\n\tthe action from a perform instruction.\n\n\t  perform_perform_action\n          make_perform\n          gcd_machine_complete_example\n\nfunction perform(action) { return list(\"perform\", action); }\n\nfunction perform_action(perform_instruction) {\n    return head(tail(perform_instruction));\n}\n```\n\nThe value of a\nconstant\nexpression may be needed for assignment to a register\n(make_assign_ef, above)\nor for input to an operation\n(make_@operation_@exp_@ef,\nbelow).\n\nThe following\nfunction\ngenerates execution\nfunctions\nto produce values for these expressions during the simulation:\n\n```javascript\nmake_primitive_exp\n      lookup_label\n      gcd_machine_complete_example\n\nfunction make_primitive_exp_ef(exp, machine, labels) {\n    if (is_constant_exp(exp)) {\n        const c = constant_exp_value(exp);\n        return () => c;\n    } else if (is_label_exp(exp)) {\n        const insts = lookup_label(labels, label_exp_label(exp));\n        return () => insts;\n    } else if (is_register_exp(exp)) {\n        const r = get_register(machine, register_exp_reg(exp));\n        return () => get_contents(r);\n    } else {\n        error(exp, \"unknown expression type -- assemble\");\n    }\n}\n```",
    "token_count": 297,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "Instructions and Their Execution Functions",
    "chunk_index": 5,
    "chunk_id": "Computing_with_Register_Machines_Instructions_and_Their_Execution_Functions_5"
  },
  {
    "content": "The following\nfunction\ngenerates execution\nfunctions\nto produce values for these expressions during the simulation:\n\n```javascript\nThe syntax of reg,\n\tlabel, and constant\n        expressions is determined by the following constructor functions, along with\n        corresponding predicates and selectors.\n\n\t  is_register_exp0\n\t  tagged_list\n\t  gcd_machine_complete_example\n\nfunction reg(name) { return list(\"reg\", name); }\n\nfunction is_register_exp(exp) { return is_tagged_list(exp, \"reg\"); }\n\nfunction register_exp_reg(exp) { return head(tail(exp)); }\n\nfunction constant(value) { return list(\"constant\", value); }\n\nfunction is_constant_exp(exp) {\n    return is_tagged_list(exp, \"constant\");\n}\n\nfunction constant_exp_value(exp) { return head(tail(exp)); }\n\nfunction label(name) { return list(\"label\", name); }\n\nfunction is_label_exp(exp) { return is_tagged_list(exp, \"label\"); }\n\nfunction label_exp_label(exp) { return head(tail(exp)); }\n```\n\nThe instructions\nmay include the application of a machine operation (specified by an\nconstant\nexpressions).\n\nThe following\nfunction\nproduces an execution\nfunction\nfor an operation expression a list containing the\noperation and operand expressions from the instruction:\n\n```javascript\nmake_operation_exp\n      lookup_prim\n      make_primitive_exp\n      gcd_machine_complete_example\n\nfunction make_operation_exp_ef(exp, machine, labels, operations) {\n    const op = lookup_prim(operation_exp_op(exp), operations);\n    const afuns = map(e => make_primitive_exp_ef(e, machine, labels),\n                      operation_exp_operands(exp));\n    return () => apply_in_underlying_javascript(\n                     op, map(f => f(), afuns));\n}\n```\n\n```javascript\nThe syntax of operation expressions is determined by\n\n\t  is_register_exp\n\t  is_register_exp0\n\t  gcd_machine_complete_example\n\nfunction op(name) { return list(\"op\", name); }\n\nfunction is_operation_exp(exp) {\n    return is_pair(exp) && is_tagged_list(head(exp), \"op\");\n}\n\nfunction operation_exp_op(op_exp) { return head(tail(head(op_exp))); }\n\nfunction operation_exp_operands(op_exp) { return tail(op_exp); }\n```\n\nObserve that the treatment of operation expressions is very much like the treatment of function applications by the analyze_application function in the evaluator of section\n\nin that we generate an execution function for each operand.\n\n```javascript\nAt simulation time, we call the operand\n\tfunctions\n\tand apply the JavaScript function\n```\n\nthat simulates the operation to the resulting values.",
    "token_count": 273,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "Instructions and Their Execution Functions",
    "chunk_index": 6,
    "chunk_id": "Computing_with_Register_Machines_Instructions_and_Their_Execution_Functions_6"
  },
  {
    "content": "that simulates the operation to the resulting values.\n\n```javascript\nWe make use of the function\n\tapply_in_underlying_javascript, as we did\n\tin apply_primitive_function in\n\tsection. This is needed to apply\n\top to all elements of the argument list\n\tafuns\n\tproduced by the first map,\n\tas if they were separate arguments to\n\top. Without this,\n\top would have been restricted to be a unary\n\tfunction.\n```\n\nThe simulation function is found by looking up the operation name in the operation table for the machine:\n\n```javascript\nlookup_prim\n      gcd_machine_complete_example\n\nfunction lookup_prim(symbol, operations) {\n    const val = assoc(symbol, operations);\n    return is_undefined(val)\n           ? error(symbol, \"unknown operation -- assemble\")\n           : head(tail(val));\n}\n```",
    "token_count": 105,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "Instructions and Their Execution Functions",
    "chunk_index": 7,
    "chunk_id": "Computing_with_Register_Machines_Instructions_and_Their_Execution_Functions_7"
  },
  {
    "content": "Simulation is useful not only for verifying the correctness of a\nproposed machine design but also for measuring the machine s\nmeter that measures the number of stack operations used in a\ncomputation.\n\nTo do this, we modify our simulated stack to keep track\nof the number of times registers are saved on the stack and the\nmaximum depth reached by the stack, and add a message to the stack s\ninterface that prints the statistics, as shown below.\n\nWe also add an operation to the basic machine model to print the\nstack statistics, by initializing\nthe_ops\nin\nmake_new_machine\nto\n\n```javascript\nlist(list(\"initialize_stack\",\n          () => stack(\"initialize\")),\n     list(\"print_stack_statistics\",\n          () => stack(\"print_statistics\")));\n```\n\nHere is the new version of make_stack:\n\n```javascript\nfunction make_stack() {\n    let stack = null;\n    let number_pushes = 0;\n    let max_depth = 0;\n    let current_depth = 0;\n    function push(x) {\n        stack = pair(x, stack);\n        number_pushes = number_pushes + 1;\n        current_depth = current_depth + 1;\n        max_depth = math_max(current_depth, max_depth);\n        return \"done\";\n    }\n    function pop() {\n        if (is_null(stack)) {\n            error(\"empty stack -- pop\");\n        } else {\n            const top = head(stack);\n            stack = tail(stack);\n            current_depth = current_depth - 1;\n            return top;\n        }\n    }\n    function initialize() {\n        stack = null;\n        number_pushes = 0;\n        max_depth = 0;\n        current_depth = 0;\n        return \"done\";\n    }\n    function print_statistics() {\n        display(\"total pushes = \" + stringify(number_pushes));\n        display(\"maximum depth = \" + stringify(max_depth));\n    }\n    function dispatch(message) {\n        return message === \"push\"\n               ? push\n               : message === \"pop\"\n               ? pop()\n               : message === \"initialize\"\n               ? initialize()\n               : message === \"print_statistics\"\n               ? print_statistics()\n               : error(message, \"unknown request -- stack\");\n    }\n    return dispatch;\n}\n```\n\nExercises through describe other useful monitoring and debugging features that can be added to the register-machine simulator.",
    "token_count": 279,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "Monitoring Machine Performance",
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_Monitoring_Machine_Performance_1"
  },
  {
    "content": "The technique of producing an execution\nfunction\nfor each instruction is just what we used in\nsection to speed\nup the evaluator by separating analysis from runtime execution.\n\nAs we\nsaw in chapter , much useful\nJavaScript\nexpressions could\nbe performed without knowing the actual values of\nnames.\n\nHere, analogously, much useful analysis of register-machine-language\nexpressions can be performed without knowing the actual contents of\nmachine registers.\n\nFor example, we can replace references to\nregisters by pointers to the register objects, and we can\nreplace references to labels by pointers to the place in the\ninstruction sequence that the label designates.\n\nBefore it can generate the instruction execution\nfunctions,\nthe assembler must know what all the labels refer to, so it begins by\nscanning the controller sequence to separate the labels from the\ninstructions.\n\nAs it scans the controller , it constructs both a list of\ninstructions and a table that associates each label with a pointer\ninto that list.\n\nThen the assembler augments the instruction list by\ninserting the execution\nfunction\nfor each instruction.\n\nThe\nfunction\nis the main entry to the assembler.\n\nIt takes the controller\nsequence and the\nmachine model as arguments and returns the instruction sequence to be stored\nin the model.\n\n```javascript\nThe function\n\tassemble\n```\n\ncalls\nextract_labels\nto build the initial instruction list and label table from the supplied\ncontroller.\n\nThe second argument\nto\nextract_labels\nis a\nfunction\nto be called to process these results: This\nfunction\nuses\nupdate_insts\nto generate the instruction execution\nfunctions\nand insert them into the instruction list, and returns the modified list.\n\n```javascript\nassemble\n      update_insts\n      extract_labels\n      gcd_machine_complete_example\n\nfunction assemble(controller, machine) {\n    return extract_labels(controller,\n                          (insts, labels) => {\n                              update_insts(insts, labels, machine);\n                              return insts;\n                          });\n}\n```",
    "token_count": 286,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "The Assembler",
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_The_Assembler_1"
  },
  {
    "content": "The second argument\nto\nextract_labels\nis a\nfunction\nto be called to process these results: This\nfunction\nuses\nupdate_insts\nto generate the instruction execution\nfunctions\nand insert them into the instruction list, and returns the modified list.\n\n```javascript\nThe function extract_labels takes\n\t      a list controller\n\t      and a function receive\n\t      as arguments. The function receive will\n\t      be called with two values: (1)a list insts\n\t      of instruction data structures, each containing an instruction from\n\t      controller; and (2)a table called\n\t      labels, which associates each label from\n\t      controller with the position in the list\n\t      insts that the label designates.\n```\n\n```javascript\nextract_labels\n      make_label_entry\n      gcd_machine_complete_example\n\nfunction extract_labels(controller, receive) {\n    return is_null(controller)\n           ? receive(null, null)\n           : extract_labels(\n                 tail(controller),\n                 (insts, labels) => {\n                   const next_element = head(controller);\n                   return is_string(next_element)\n                          ? receive(insts,\n                                    pair(make_label_entry(next_element,\n                                                          insts),\n                                         labels))\n                          : receive(pair(make_inst(next_element),\n                                         insts),\n                                    labels);\n                 });\n}\n```\n\n```javascript\nThe function\n      extract_labels\n```\n\nworks by sequentially scanning the elements of the controller and accumulating the string (and thus a label) an appropriate entry is added to the\n\n```javascript\nThe function\n      update_insts\n```\n\nmodifies the instruction list, which initially contains only the controller instructions, to include the corresponding execution functions:\n\n```javascript\nupdate_insts\n      get_register\n      make_execution_function\n      make_inst\n      gcd_machine_complete_example\n\nfunction update_insts(insts, labels, machine) {\n    const pc = get_register(machine, \"pc\");\n    const flag = get_register(machine, \"flag\");\n    const stack = machine(\"stack\");\n    const ops = machine(\"operations\");\n    return for_each(inst => set_inst_execution_fun(\n                                inst,\n                                make_execution_function(\n                                    inst_controller_instruction(inst),\n                                    labels, machine, pc,\n                                    flag, stack, ops)),\n                    insts);\n}\n```\n\nThe machine instruction data structure simply pairs the\ncontroller\ninstruction with the corresponding execution\nfunction.\n\nThe execution\nfunction\nis not yet available when\nextract_labels\nconstructs the instruction, and is inserted later by\nupdate_insts.\n\n```javascript\nmake_inst\n      gcd_machine_complete_example\n\nfunction make_inst(inst_controller_instruction) {\n    return pair(inst_controller_instruction, null);\n}\nfunction inst_controller_instruction(inst) {\n    return head(inst);\n}\nfunction inst_execution_fun(inst) {\n    return tail(inst);\n}\nfunction set_inst_execution_fun(inst, fun) {\n    set_tail(inst, fun);\n}\n```",
    "token_count": 293,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "The Assembler",
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_The_Assembler_2"
  },
  {
    "content": "The execution\nfunction\nis not yet available when\nextract_labels\nconstructs the instruction, and is inserted later by\nupdate_insts.\n\nThe controller instruction is not used by our simulator, but is handy to keep around for debugging (see exercise ).\n\nElements of the label table are pairs:\n\n```javascript\nmake_label_entry\n      gcd_machine_complete_example\n\nfunction make_label_entry(label_name, insts) {\n    return pair(label_name, insts);\n}\n```\n\nEntries will be looked up in the table with\n\n```javascript\nlookup_label\n      gcd_machine_complete_example\n\nfunction lookup_label(labels, label_name) {\n    const val = assoc(label_name, labels);\n    return is_undefined(val)\n           ? error(label_name, \"undefined label -- assemble\")\n           : tail(val);\n}\n```",
    "token_count": 90,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "The Assembler",
    "chunk_index": 3,
    "chunk_id": "Computing_with_Register_Machines_The_Assembler_3"
  },
  {
    "content": "The machine model generated by\nmake_machine\nis represented as a\nfunction\nwith local state using the message-passing techniques\ndeveloped in chapter.\n\nTo build this model,\nmake_machine\nbegins by calling the\nfunction\nmake_new_machine\nto construct\nthe parts of the machine model that are common to all register\nmachines.\n\nThis basic machine model constructed by\nmake_new_machine\nis essentially a container for some registers and a stack, together with an\nexecution mechanism that processes the controller instructions one by one.\n\n```javascript\nThe function\n\tmake_machine\n```\n\nthen extends this basic model (by sending it\nmessages) to include the registers, operations, and controller of the\nparticular machine being defined.\n\nFirst it allocates a register in\nthe new machine for each of the supplied register names and installs\nthe designated operations in the machine.\n\nThen it uses an\nassembler (described below in\nsection ) to transform the controller list\ninto instructions for the new machine and installs these as the\nmachine s instruction sequence.\n\n```javascript\nThe function\n\tmake_machine\n```\n\nreturns as its value the modified machine model.\n\n```javascript\ngcd_machine_complete_example\n      make_machine\n      start\n\nconst gcd_machine =\n    make_machine(\n        list(\"a\", \"b\", \"t\"),\n        list(list(\"rem\", (a, b) => a % b),\n             list(\"=\", (a, b) => a === b)),\n        list(\n          \"test_b\",\n            test(list(op(\"=\"), reg(\"b\"), constant(0))),\n            branch(label(\"gcd_done\")),\n            assign(\"t\", list(op(\"rem\"), reg(\"a\"), reg(\"b\"))),\n            assign(\"a\", reg(\"b\")),\n            assign(\"b\", reg(\"t\")),\n            go_to(label(\"test_b\")),\n          \"gcd_done\"));\nset_register_contents(gcd_machine, \"a\", 206);\nset_register_contents(gcd_machine, \"b\", 40);\nstart(gcd_machine);\nget_register_contents(gcd_machine, \"a\");\n```\n\n```javascript\nmake_machine\n      assemble\n      make_new_machine\n      gcd_machine_complete_example\n\nfunction make_machine(register_names, ops, controller) {\n    const machine = make_new_machine();\n    for_each(register_name =>\n               machine(\"allocate_register\")(register_name),\n             register_names);\n    machine(\"install_operations\")(ops);\n    machine(\"install_instruction_sequence\")\n           (assemble(controller, machine));\n    return machine;\n}\n```\n\nWe will represent a register as a\nfunction\nwith local state, as in\nchapter.\n\nThe\nfunction\nmake_register\ncreates a register that\nholds a value that can be accessed or changed:",
    "token_count": 278,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "The Machine Model",
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_The_Machine_Model_1"
  },
  {
    "content": "The\nfunction\nmake_register\ncreates a register that\nholds a value that can be accessed or changed:\n\n```javascript\nmake_register\n      gcd_machine_complete_example\n\nfunction make_register(name) {\n    let contents = \"*unassigned*\";\n    function dispatch(message) {\n        return message === \"get\"\n               ? contents\n               : message === \"set\"\n               ? value => { contents = value; }\n               : error(message, \"unknown request -- make_register\");\n    }\n    return dispatch;\n}\n```\n\nThe following functions are used to access registers:\n\n```javascript\nget_contents\n      gcd_machine_complete_example\n\nfunction get_contents(register) {\n    return register(\"get\");\n}\nfunction set_contents(register, value) {\n    return register(\"set\")(value);\n}\n```\n\nWe can also represent a stack as a\nfunction\nwith local state.\n\nThe\nfunction\nmake_@stack\ncreates a stack whose local state consists\nof a list of the items on the stack.\n\nA stack accepts requests to\n\n```javascript\nmake_stack\n      gcd_machine_complete_example\n\nfunction make_stack() {\n    let stack = null;\n    let frame = null;\n    function push_marker() {\n        frame = pair(stack, frame);\n        return \"done\";\n    }\n    function pop_marker() {\n        stack = head(frame);\n        frame = tail(frame);\n        return \"done\";\n    }\n    function push(x) {\n        stack = pair(x, stack);\n        return \"done\";\n    }\n    function pop() {\n        if (is_null(stack)) {\n            error(\"empty stack -- pop\");\n        } else {\n            const top = head(stack);\n            stack = tail(stack);\n            return top;\n        }\n    }\n    function initialize() {\n        stack = null;\n        return \"done\";\n    }\n    function dispatch(message) {\n        return message === \"push\"\n               ? push\n               : message === \"pop\"\n               ? pop()\n               : message === \"push_marker\"\n               ? push_marker()\n               : message === \"pop_marker\"\n               ? pop_marker()\n               : message === \"initialize\"\n               ? initialize()\n               : error(message, \"unknown request -- stack\");\n    }\n    return dispatch;\n}\n\nfunction make_push_marker_to_stack_ef(machine, stack, pc) {\n    return () => {\n                   push_marker(stack);\n                   advance_pc(pc);\n                 };\n}\nfunction make_revert_stack_to_marker_ef(machine, stack, pc) {\n    return () => {\n                   pop_marker(stack);\n                   advance_pc(pc);\n                 };\n}\n\nfunction push_marker_to_stack() { return list(\"push_marker_to_stack\"); }\nfunction revert_stack_to_marker() { return list(\"revert_stack_to_marker\"); }\n\nfunction pop_marker(stack) {\n    return stack(\"pop_marker\");\n}\nfunction push_marker(stack) {\n    return stack(\"push_marker\");\n}\n```",
    "token_count": 292,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "The Machine Model",
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_The_Machine_Model_2"
  },
  {
    "content": "A stack accepts requests to\n\n```javascript\nfunction make_stack() {\n    let stack = null;\n    function push(x) {\n        stack = pair(x, stack);\n        return \"done\";\n    }\n    function pop() {\n        if (is_null(stack)) {\n            error(\"empty stack -- pop\");\n        } else {\n            const top = head(stack);\n            stack = tail(stack);\n            return top;\n        }\n    }\n    function initialize() {\n        stack = null;\n        return \"done\";\n    }\n    function dispatch(message) {\n        return message === \"push\"\n               ? push\n               : message === \"pop\"\n               ? pop()\n               : message === \"initialize\"\n               ? initialize()\n               : error(message, \"unknown request -- stack\");\n    }\n    return dispatch;\n}\n```\n\nThe following functions are used to access stacks:\n\n```javascript\npop\n      gcd_machine_complete_example\n\nfunction pop(stack) {\n    return stack(\"pop\");\n}\nfunction push(stack, value) {\n    return stack(\"push\")(value);\n}\n```\n\nThe\nmake_new_machine\nfunction,\nshown in figure , constructs an\nobject whose local state consists of a stack, an initially empty instruction\nsequence, a list of operations that initially contains an operation to\nregister table that initially contains two\nregisters, named\nprogram counter ).\n\nThe internal\nfunction\nallocate_register\nadds new entries to the register table, and the internal\nfunction\nlookup_register\nlooks up registers in the table.\n\nThe Our test instructions set the contents of Our branch instructions decide whether or not to branch by examining the contents of\n\nThe\nfunction\nfunction\nof no arguments, called the\ninstruction execution function,\nsuch that calling this\nfunction\nsimulates executing the instruction.\n\nAs the simulation runs,\nThe function execute\ngets that instruction, executes it by calling the instruction execution\nfunction,\nand repeats this cycle until there are no more instructions to execute\n(i.e., until\n\nAs part of its operation, each instruction execution function modifies\n\n```javascript\nThe instructions\n\tbranch\n\tand\n\tgo_to\n```\n\nchange function changes the contents of\n\n```javascript\nThe function\n\tmake_new_machine\n```\n\nreturns a\ndispatch\nfunction\nthat implements message-passing access to the internal state.\n\nNotice that\nstarting the machine is accomplished by setting",
    "token_count": 301,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "The Machine Model",
    "chunk_index": 3,
    "chunk_id": "Computing_with_Register_Machines_The_Machine_Model_3"
  },
  {
    "content": "Notice that\nstarting the machine is accomplished by setting\n\nFor convenience, we provide an alternate interface to a machine s functions to set and examine register contents, as specified at the beginning of section\n\n:\n\n```javascript\nstart\n      gcd_machine_complete_example\n\nfunction start(machine) {\n    return machine(\"start\");\n}\nfunction get_register_contents(machine, register_name) {\n    return get_contents(get_register(machine, register_name));\n}\nfunction set_register_contents(machine, register_name, value) {\n    set_contents(get_register(machine, register_name), value);\n    return \"done\";\n}\n```\n\nThese functions (and many functions in sections and ) use the following to look up the register with a given name in a given machine:\n\n```javascript\nget_register\n      gcd_machine_complete_example\n\nfunction get_register(machine, reg_name) {\n    return machine(\"get_register\")(reg_name);\n}\n```",
    "token_count": 100,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "A Register-Machine Simulator",
    "subsection": "The Machine Model",
    "chunk_index": 4,
    "chunk_id": "Computing_with_Register_Machines_The_Machine_Model_4"
  },
  {
    "content": "The explicit-control evaluator of\nsection is a\nregister machine whose controller interprets\nJavaScript\nprograms.\n\nIn this\nsection we will see how to run\nJavaScript\nprograms on a register machine whose controller is not a\nJavaScript\ninterpreter.\n\nThe explicit-control evaluator machine is\nit\ncan carry out any computational process that can be described in\nJavaScript.\n\nThe\nevaluator s controller orchestrates the use of its data\npaths to perform the desired computation.\n\nThus, the\nevaluator s data paths are universal: They are sufficient\nto perform any computation we desire, given an appropriate\ncontroller.\n\nCommercial\nnative language of the machine, or simply\nmachine language.\n\nPrograms written in machine language are\nsequences of instructions that use the machine s data paths.\n\nFor example, the\ns instruction sequence\ncan be thought of as a machine-language program for a general-purpose\ncomputer rather than as the controller for a specialized interpreter\nmachine.\n\nThere are two common strategies for bridging the gap between\nhigher-level languages and register-machine languages.\n\nThe explicit-control evaluator illustrates the\nstrategy of interpretation.\n\nAn interpreter written in the native\nlanguage of a machine configures the machine to execute programs\nwritten in a language (called the\nsource language ) that may\ndiffer from the native language of the machine performing the\nevaluation.\n\nThe primitive\nfunctions\nof the source language are implemented as a library of subroutines written\nin the native language of the given machine.\n\nA program to be interpreted\n(called the\nsource program ) is represented as a data structure.\n\nThe interpreter\ntraverses this data structure, analyzing the source program.\n\nAs it\ndoes so, it simulates the intended behavior of the source program by\ncalling appropriate primitive subroutines from the library.\n\nIn this section, we explore the alternative strategy of\ncompilation.",
    "token_count": 286,
    "has_code": false,
    "chapter": "Computing with Register Machines",
    "section": "Compilation",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_Compilation_1"
  },
  {
    "content": "In this section, we explore the alternative strategy of\ncompilation.\n\nA compiler for a given source language and machine\ntranslates a source program into an equivalent program (called the\nobject program ) written in the machine s native language.\n\nThe compiler that we implement in this section translates programs written in\nJavaScript\ninto sequences of instructions to be executed using the explicit-control\nevaluator machine s data paths.\n\nCompared with interpretation, compilation can provide a great increase\nin the efficiency of program execution, as we will explain below in\nthe overview of the compiler.\n\nOn the other hand, an interpreter\nprovides a more powerful environment for interactive program\ndevelopment and debugging, because the source program being executed\nis available at run time to be examined and modified.\n\nIn addition,\nbecause the entire library of primitives is present, new programs can\nbe constructed and added to the system during debugging.\n\nIn view of the complementary advantages of compilation and\ninterpretation, modern\nprogram-development environments\npursue a mixed\nstrategy.\n\nThese systems\nare generally organized so that interpreted\nfunctions\nand compiled\nfunctions\ncan call each other.\n\nThis enables a programmer to compile those parts of a\nprogram that are assumed to be debugged, thus gaining the efficiency\nadvantage of compilation, while retaining the interpretive mode of execution\nfor those parts of the program that are in the flux of interactive\ndevelopment and\ndebugging.\n\nIn section , after\nwe have implemented the compiler, we will show how to interface it\nwith our interpreter to produce an integrated\ninterpreter-compiler\nsystem.\n\nOur compiler is much like our interpreter, both in its structure and in\nthe function it performs.\n\nAccordingly, the mechanisms used by the\ncompiler for analyzing\ncomponents\nwill be similar to those used by\nthe interpreter.",
    "token_count": 289,
    "has_code": false,
    "chapter": "Computing with Register Machines",
    "section": "Compilation",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_Compilation_2"
  },
  {
    "content": "Accordingly, the mechanisms used by the\ncompiler for analyzing\ncomponents\nwill be similar to those used by\nthe interpreter.\n\nMoreover, to make it easy to interface compiled and\ninterpreted code, we will design the compiler to generate code that\nobeys the same conventions of\nfunction\nto be applied will be in\nfun,\nfunctions\nwill return their answers in\nfunction\nshould return will be kept in\n\nThis description suggests a strategy for implementing a rudimentary\ncompiler: We traverse the\ncomponent\nin the same way the\ninterpreter does.\n\nWhen we encounter a register instruction that the\ninterpreter would perform in evaluating the\ncomponent,\nwe do not\nexecute the instruction but instead accumulate it into a sequence.\n\nThe\nresulting sequence of instructions will be the object code.\n\nObserve\nthe\na componentfor example,\nf(96, 22)it\nperforms the work of classifying the\ncomponent\n(discovering that this is a\nfunction\napplication) and\ntesting for the end of the\n\n```javascript\nlist of argument expressions\n\t(discovering that there are two argument expressions).\n```\n\nWith a\ncompiler, the\ncomponent\nis analyzed only once, when the\ninstruction sequence is generated at compile time.\n\nThe object code\nproduced by the compiler contains only the instructions that evaluate\nthe\nfunction expression and the two argument expressions,\nassemble the argument list, and apply the\nfunction (in\nto the arguments (in\n\nThis is the same kind of optimization we implemented in the.\n\nBut there are further opportunities to gain efficiency in compiled code.\n\nAs the interpreter runs, it follows a process that must be applicable\nto any\ncomponent\nin the language.\n\nIn contrast, a given segment of\ncompiled code is meant to execute some particular\ncomponent.\n\nThis can make a big difference, for example in the use of the\nstack to save registers.\n\nWhen the interpreter evaluates\na component,\nit must be prepared for any contingency.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Compilation",
    "subsection": null,
    "chunk_index": 3,
    "chunk_id": "Computing_with_Register_Machines_Compilation_3"
  },
  {
    "content": "When the interpreter evaluates\na component,\nit must be prepared for any contingency.\n\nBefore evaluating a\nsubcomponent,\nthe interpreter saves all registers that will be needed later, because the\nsubcomponent\nmight require an arbitrary evaluation.\n\nA compiler, on the other hand, can exploit the structure of the particular\ncomponent\nit is processing to generate code that avoids\nunnecessary stack operations.\n\nAs a case in point, consider the\napplication f(96, 22).\n\nBefore the interpreter evaluates the\nfunction expression of the application,\nit prepares\nfor this evaluation by saving the registers containing the\nargument expressions\nand the environment, whose values will be needed later.\n\nThe interpreter then\nevaluates the\nfunction expression\nto obtain the result in\nHowever, in the particular expression we\nare dealing with, the\nfunction expression\nis the\nname\nlookup_symbol_value,\nwhich does not alter any registers.\n\nThe compiler that we implement in\nthis section will take advantage of this fact and generate code that\nevaluates the\nfunction expression\nusing the instruction\n\n```javascript\nassign(\"fun\",\n       list(op(\"lookup_symbol_value\"), constant(\"f\"), reg(\"env\")))\n```\n\n```javascript\nwhere the argument to lookup_symbol_value\n\tis extracted at compile time from the parser's representation of f(96, 22).\n```\n\nThis code not only avoids the unnecessary saves and restores but also assigns the value of the lookup directly to whereas the interpreter would obtain\n\nthe result in\n\nA compiler can also optimize access to the environment.\n\nHaving\nanalyzed the code, the compiler can\nknow in which frame\nthe value of a particular name\nwill be located and access that frame directly,\nrather than performing the\nlookup_@symbol_@value\nsearch.\n\nWe will discuss how to implement such\nlexical addressing\nin\nsection.\n\nUntil then, however,\nwe will focus on the kind of register and stack optimizations described\nabove.",
    "token_count": 281,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Compilation",
    "subsection": null,
    "chunk_index": 4,
    "chunk_id": "Computing_with_Register_Machines_Compilation_4"
  },
  {
    "content": "Until then, however,\nwe will focus on the kind of register and stack optimizations described\nabove.\n\nThere are many other optimizations that can be performed by a\ncompiler, such as coding primitive operations in line instead\nof using a general ); but we will not emphasize these\nhere.\n\nOur main goal in this section is to illustrate the compilation process\nin a simplified (but still interesting) context.",
    "token_count": 67,
    "has_code": false,
    "chapter": "Computing with Register Machines",
    "section": "Compilation",
    "subsection": null,
    "chunk_index": 5,
    "chunk_id": "Computing_with_Register_Machines_Compilation_5"
  },
  {
    "content": "To design a register machine, we must design its data paths\n(registers and operations) and the controller that sequences\nthese operations.\n\nTo illustrate the design of a simple register\nmachine, let us examine Euclid s Algorithm, which is used to compute\n,\ns Algorithm can be\ncarried out by an iterative process, as specified by the following\nfunction:\n\n```javascript\ngcd_example\n\nfunction gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n}\n```\n\nA machine to carry out this algorithm must keep track of two numbers,\n$a$ and $b$ , so let us\nassume that these numbers are stored in two registers with those names.\n\nThe\nbasic operations required are testing whether the contents of register\ntemporary register, which we call\n\nWe can illustrate the registers and operations required for this\nmachine by using the.\n\nIn this\ndiagram, the registers ( a buttondrawn as $\\otimes$ behind the\nhead, pointing from the source of data to the register.\n\nWhen pushed, the button allows\nthe value at the source to flow into the designated register.\n\nThe label next to each button is the name we will use to refer to the\nbutton.\n\nThe names are arbitrary, and can be chosen to have mnemonic value\n(for example,\n\nAn operation that computes a value from constants and the contents\nof registers is represented in a data-path diagram by a trapezoid\ncontaining a name for the operation.\n\nFor example, the box marked\nrepresents an operation that\ncomputes the remainder of the contents of the registers\ns output value\nto registers.\n\nA test is represented by a circle containing a name for the\ntest.",
    "token_count": 272,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Designing Register Machines",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_Designing_Register_Machines_1"
  },
  {
    "content": "A test is represented by a circle containing a name for the\ntest.\n\nFor example, our GCD machine has an operation that tests whether the\ncontents of register $\\otimes$ buttons as switches, the data-path diagram\nis very like the wiring diagram for a machine that could be constructed\nfrom electrical components.\n\nData paths for a GCD machine.\n\nIn order for the data paths to actually compute GCDs, the buttons must\nbe pushed in the correct sequence.\n\nWe will describe this sequence in\nterms of a.\n\nThe elements of the\ncontroller diagram indicate how the data-path components should be operated.\n\nThe rectangular boxes in the controller diagram identify data-path buttons\nto be pushed, and the arrows describe the sequencing from one step to the\nnext.\n\nThe diamond in the diagram represents a decision.\n\nOne of the two\nsequencing arrows will be followed, depending on the value of the data-path\ntest identified in the diamond.\n\nWe can interpret the controller in terms\nof a physical analogy: Think of the diagram as a maze in which a marble is\nrolling.\n\nWhen the marble rolls into a box, it pushes the data-path button\nthat is named by the box.\n\nWhen the marble rolls into a decision node (such\nas the test for\n$\\, =0$ ), it leaves\nthe node on the path determined by the result of the indicated test.\n\nTaken together, the data paths and the controller completely describe\na machine for computing GCDs.\n\nWe start the controller (the rolling\nmarble) at the place marked",
    "token_count": 252,
    "has_code": false,
    "chapter": "Computing with Register Machines",
    "section": "Designing Register Machines",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_Designing_Register_Machines_2"
  },
  {
    "content": "In section , we will show how to implement a\nJavaScript\nevaluator as a register machine.\n\nIn order to simplify the discussion, we\nwill assume that our register machines can be equipped with a\nlist-structured memory , in which the basic operations for\nmanipulating list-structured data are primitive.\n\nPostulating the existence\nof such a memory is a useful abstraction when one is focusing on the\nmechanisms of control in\nan\ninterpreter, but this does not reflect a realistic view of the actual\nprimitive data operations of contemporary computers.\n\nTo obtain a more\ncomplete picture of how\n\n```javascript\nsystems can support list-structured memory\n      efficiently,\n```\n\nwe must investigate how list structure can be represented in a way that is compatible with conventional computer memories.\n\nThere are two considerations in implementing list structure.\n\nThe first is\npurely an issue of representation: how to represent the\nbox-and-pointer structure of\npairs, using only the storage and addressing capabilities of typical computer\nmemories.\n\nThe second issue concerns the management of memory as a\ncomputation proceeds.\n\nThe operation of a\nJavaScript\nsystem depends crucially on the ability to\ncontinually create new data objects.\n\nThese include objects that are\nexplicitly created by the\nJavaScript\nfunctions\nbeing interpreted as well as structures created by the interpreter itself,\nsuch as environments and argument lists.\n\nAlthough the constant creation of\nnew data objects would pose no problem on a computer with an infinite amount\nof rapidly addressable memory, computer memories are available only in\nfinite sizes (more s the pity).\n\nJavaScript\nthus provide an\nautomatic storage allocation facility to\nsupport the illusion of an infinite memory.\n\nWhen a data object is no longer\nneeded, the memory allocated to it is automatically recycled and used to\nconstruct new data objects.\n\nThere are various techniques for providing such\nautomatic storage allocation.",
    "token_count": 299,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_Storage_Allocation_and_Garbage_Collection_1"
  },
  {
    "content": "There are various techniques for providing such\nautomatic storage allocation.\n\nThe method we shall discuss in this section\nis called garbage collection.",
    "token_count": 22,
    "has_code": false,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_Storage_Allocation_and_Garbage_Collection_2"
  },
  {
    "content": "The representation method outlined in\nsection solves the problem of\nimplementing list structure, provided that we have an infinite amount of\nmemory.\n\nWith a real computer we will eventually run out of free space in\nwhich to construct new pairs. they are\ngarbage.\n\nFor instance, the computation\n\n```javascript\naccumulate((x, y) => x + y,\n           0,\n           filter(is_odd, enumerate_interval(0, n)))\n```\n\nconstructs two lists: the enumeration and the result of filtering\nthe enumeration.\n\nWhen the accumulation is complete, these lists are\nno longer needed, and the allocated memory can be reclaimed.\n\nIf we\ncan arrange to collect all the garbage periodically, and if this turns\nout to recycle memory at about the same rate at which we construct new\npairs, we will have preserved the illusion that there is an infinite\namount of memory.\n\nIn order to recycle pairs, we must have a way to determine which\nallocated pairs are not needed (in the sense that their contents can\nno longer influence the future of the computation).\n\nThe method we\nshall examine for accomplishing this is known as garbage\ncollection.\n\nGarbage collection is based on the observation that, at\nany moment in\nan interpretation based on list-structured memory,\nthe only objects that can\naffect the future of the computation are those that can be reached by\nsome succession of\nhead\nand\ntail\noperations starting from the pointers that are currently in the machine\nregisters.\n\nThere are many ways to perform garbage collection.\n\nThe method we\nshall examine here is called\nstop-and-copy.\n\nThe basic idea is to divide memory into two\nhalves: working memory and free memory.\n\nWhen\npair\nconstructs pairs, it allocates these in working memory.\n\nWhen working memory\nis full, we perform garbage collection by locating all the useful pairs in\nworking memory and copying these into consecutive locations in free memory.",
    "token_count": 301,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Maintaining the Illusion of Infinite Memory",
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_Maintaining_the_Illusion_of_Infinite_Memory_1"
  },
  {
    "content": "When working memory\nis full, we perform garbage collection by locating all the useful pairs in\nworking memory and copying these into consecutive locations in free memory.\n\n(The useful pairs are located by tracing all the\nhead\nand\ntail\npointers, starting with the machine registers.) Since we do not copy the\ngarbage, there will presumably be additional free memory that we can\nuse to allocate new pairs.\n\nIn addition, nothing in the working memory\nis needed, since all the useful pairs in it have been copied.\n\nThus,\nif we interchange the roles of working memory and free memory, we can\ncontinue processing; new pairs will be allocated in the new working\nmemory (which was the old free memory).\n\nWhen this is full, we can\ncopy the useful pairs into the new free memory (which was the old\nworking memory).\n\nWe now use our register-machine language to describe the stop-and-copy\nalgorithm in more detail.\n\nWe will assume that there is a register\ncalled\nthe_heads\nand\nthe_tails,\nand the free memory is in registers called\nnew_heads\nand\nnew_tails.\n\nGarbage collection is triggered when we exhaust the free cells in the\ncurrent working memory, that is, when a\npair\noperation attempts to increment the new pairs will be constructed in the new memory,\nbeginning at the place indicated by\nFigure\nshows the arrangement of memory just before and just after garbage\ncollection.\n\nReconfiguration of memory by the garbage-collection process.\n\nThe state of the garbage-collection process is controlled by\nmaintaining two pointers:\nhead\nposition, we place a special tag that signals that this is an already-moved\nobject.\n\n(Such an object is traditionally called a\nbroken heart.)\ntail\nposition we place a\nforwarding address that points at the location to which the object\nhas been moved.",
    "token_count": 291,
    "has_code": false,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Maintaining the Illusion of Infinite Memory",
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_Maintaining_the_Illusion_of_Infinite_Memory_2"
  },
  {
    "content": "(Such an object is traditionally called a\nbroken heart.)\ntail\nposition we place a\nforwarding address that points at the location to which the object\nhas been moved.\n\nAfter relocating the root, the garbage collector enters its basic\ncycle.\n\nAt each step in the algorithm, the\nhead\nand\ntail\npointers still refer to objects in the old memory.\n\nThese objects are each\nrelocated, and the\nhead\npointer of the pair we are scanning) we check to see if the object has\nalready been moved (as indicated by the presence of a broken-heart tag\nin the\nhead\nposition of the object).\n\nIf the object has not\nalready been moved, we copy it to the place indicated by\ns old location, and update the pointer to the object (in this\nexample, the\nhead\npointer of the pair we are scanning) to point\nto the new location.\n\nIf the object has already been moved, its\nforwarding address (found in the\ntail\nposition of the broken heart) is substituted for the pointer in the pair\nbeing scanned.\n\nEventually, all accessible objects will have been moved and\nscanned, at which point the\n\nWe can specify the stop-and-copy algorithm as a sequence of instructions for\na register machine.\n\nThe basic step of relocating an object is accomplished\nby a subroutine called\nrelocate_old_result_in_new.\n\nThis subroutine gets its argument, a pointer to the object to be relocated,\nfrom a register named\nrelocate_continue.\n\nTo begin garbage collection, we invoke this subroutine to relocate the\n\n```javascript\nbegin_garbage_collection\n\n\"begin_garbage_collection\",\n  assign(\"free\", constant(0)),\n  assign(\"scan\", constant(0)),\n  assign(\"old\", reg(\"root\")),\n  assign(\"relocate_continue\", label(\"reassign_root\")),\n  go_to(label(\"relocate_old_result_in_new\")),\n\"reassign_root\",\n  assign(\"root\", reg(\"new\")),\n  go_to(label(\"gc_loop\")),\n```\n\nIn the main loop of the garbage collector we must determine whether\nthere are any more objects to be scanned.\n\nWe do this by testing\nwhether the\ngc_flip,\nwhich cleans things up so that we can continue the interrupted computation.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Maintaining the Illusion of Infinite Memory",
    "chunk_index": 3,
    "chunk_id": "Computing_with_Register_Machines_Maintaining_the_Illusion_of_Infinite_Memory_3"
  },
  {
    "content": "We do this by testing\nwhether the\ngc_flip,\nwhich cleans things up so that we can continue the interrupted computation.\n\nIf there are still pairs to be scanned, we call the relocate subroutine to\nrelocate the\nhead\nof the next pair (by placing the\nhead\npointer in\nrelocate_continue\nregister is set up so that the subroutine will return to update the\nhead\npointer.\n\n```javascript\ngc_loop\n\n\"gc_loop\",\n  test(list(op(\"===\"), reg(\"scan\"), reg(\"free\"))),\n  branch(label(\"gc_flip\")),\n  assign(\"old\", list(op(\"vector_ref\"), reg(\"new_heads\"), reg(\"scan\"))),\n  assign(\"relocate_continue\", label(\"update_head\")),\n  go_to(label(\"relocate_old_result_in_new\")),\n```\n\nAt\nupdate_head,\nwe modify the\nhead\npointer of the pair being scanned, then proceed to relocate the\ntail\nof the pair.\n\nWe return to\nupdate_tail\nwhen that relocation has been accomplished.\n\nAfter relocating and updating\nthe\ntail,\nwe are finished scanning that pair, so we continue with the main loop.\n\n```javascript\nupdate_head\n\n\"update_head\",\n  perform(list(op(\"vector_set\"),\n               reg(\"new_heads\"), reg(\"scan\"), reg(\"new\"))),\n  assign(\"old\", list(op(\"vector_ref\"),\n                     reg(\"new_tails\"), reg(\"scan\"))),\n  assign(\"relocate_continue\", label(\"update_tail\")),\n  go_to(label(\"relocate_old_result_in_new\")),\n\n\"update_tail\",\n  perform(list(op(\"vector_set\"),\n               reg(\"new_tails\"), reg(\"scan\"), reg(\"new\"))),\n  assign(\"scan\", list(op(\"+\"), reg(\"scan\"), constant(1))),\n  go_to(label(\"gc_loop\")),\n```\n\nThe subroutine\nrelocate_old_result_in_new\nrelocates objects as follows: If the object to be relocated (pointed at by\nhead\nis the number 4.\n\nIf we represent the\nhead\nby , then we want the\nrelocated\nhead\npointer to still be\nhead\nposition of the pair to be relocated contains a broken-heart tag, then the\npair has in fact already been moved, so we retrieve the forwarding address\n(from the\ntail\nposition of the broken heart) and return this in\n\n```javascript\nThe subroutine\n      relocate_old_result_in_new\n```\n\nuses a register oldht to hold the head or the tail of the object pointed at by",
    "token_count": 252,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Maintaining the Illusion of Infinite Memory",
    "chunk_index": 4,
    "chunk_id": "Computing_with_Register_Machines_Maintaining_the_Illusion_of_Infinite_Memory_4"
  },
  {
    "content": "uses a register oldht to hold the head or the tail of the object pointed at by\n\n```javascript\nrelocate_old_result_in_new\n\n\"relocate_old_result_in_new\",\n  test(list(op(\"is_pointer_to_pair\"), reg(\"old\"))),\n  branch(label(\"pair\")),\n  assign(\"new\", reg(\"old\")),\n  go_to(reg(\"relocate_continue\")),\n\"pair\",\n  assign(\"oldht\", list(op(\"vector_ref\"),\n                       reg(\"the_heads\"), reg(\"old\"))),\n  test(list(op(\"is_broken_heart\"), reg(\"oldht\"))),\n  branch(label(\"already_moved\")),\n  assign(\"new\", reg(\"free\")),     // new location for pair\n  // Update $\\texttt{free}$ pointer\n  assign(\"free\", list(op(\"+\"), reg(\"free\"), constant(1))),\n  // Copy the head and tail to new memory\n  perform(list(op(\"vector_set\"),\n               reg(\"new_heads\"), reg(\"new\"),\n               reg(\"oldht\"))),\n  assign(\"oldht\", list(op(\"vector_ref\"),\n                       reg(\"the_tails\"), reg(\"old\"))),\n  perform(list(op(\"vector_set\"),\n               reg(\"new_tails\"), reg(\"new\"),\n               reg(\"oldht\"))),\n  // Construct the broken heart\n  perform(list(op(\"vector_set\"),\n               reg(\"the_heads\"), reg(\"old\"),\n               constant(\"broken_heart\"))),\n  perform(list(op(\"vector_set\"),\n               reg(\"the_tails\"), reg(\"old\"),\n               reg(\"new\"))),\n  go_to(reg(\"relocate_continue\")),\n\"already_moved\",\n  assign(\"new\", list(op(\"vector_ref\"),\n                     reg(\"the_tails\"), reg(\"old\"))),\n  go_to(reg(\"relocate_continue\")),\n```\n\nAt the very end of the garbage collection process, we interchange the\nrole of old and new memories by interchanging pointers: interchanging\nthe_heads\nwith\nnew_heads,\nand\nthe_tails\nwith\nnew_tails.\n\nWe will then be ready to perform another garbage\ncollection the next time memory runs out.",
    "token_count": 136,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Maintaining the Illusion of Infinite Memory",
    "chunk_index": 5,
    "chunk_id": "Computing_with_Register_Machines_Maintaining_the_Illusion_of_Infinite_Memory_5"
  },
  {
    "content": "We will then be ready to perform another garbage\ncollection the next time memory runs out.\n\n```javascript\ntesting_5_3_2\n      tagged_list\n      make_go_to\n      pop\n      lookup1\n      go_to_go_to_dest\n      make_register\n\n// TYPED POINTERS\n\nconst NUMBER_TYPE = \"number\";\nconst BOOL_TYPE = \"bool\";\nconst STRING_TYPE = \"string\";\nconst PTR_TYPE = \"ptr\";\nconst PROG_TYPE = \"prog\";\nconst NULL_TYPE = \"null\";\nconst UNDEFINED_TYPE = \"undefined\";\nconst NO_VALUE_YET_TYPE = \"*unassigned*\";\nconst BROKEN_HEART_TYPE = \"broken_heart\";\n\nfunction make_ptr_ptr(idx) {\n    return pair(PTR_TYPE, idx);\n}\n\nfunction make_null_ptr() {\n    return pair(NULL_TYPE, null);\n}\n\nfunction make_no_value_yet_ptr() {\n    return pair(NO_VALUE_YET_TYPE, null);\n}\n\nfunction make_prog_ptr(idx) {\n    return pair(PROG_TYPE, idx);\n}\n\nfunction make_broken_heart_ptr() {\n    return pair(BROKEN_HEART_TYPE, null);\n}\n\nfunction get_elem_type(elem) {\n    return is_number(elem) ? NUMBER_TYPE :\n        is_boolean(elem) ? BOOL_TYPE :\n        is_string(elem) ? STRING_TYPE :\n        is_null(elem) ? NULL_TYPE :\n        is_undefined(elem) ? UNDEFINED_TYPE :\n        error(elem, \"invalid typed elem\");\n}\n\nfunction wrap_ptr(elem) {\n    return pair(get_elem_type(elem), elem);\n}\n\nfunction unwrap_ptr(ptr) {\n    return tail(ptr);\n}\n\nfunction is_ptr(ptr) {\n    return is_pair(ptr) &&\n        !is_pair(head(ptr)) &&\n        !is_pair(tail(ptr)) &&\n        (head(ptr) === NUMBER_TYPE ||\n        head(ptr) === BOOL_TYPE ||\n        head(ptr) === STRING_TYPE ||\n        head(ptr) === PTR_TYPE ||\n        head(ptr) === NULL_TYPE ||\n        head(ptr) === UNDEFINED_TYPE ||\n        head(ptr) === PROG_TYPE ||\n        head(ptr) === NO_VALUE_YET_TYPE ||\n        head(ptr) === BROKEN_HEART_TYPE);\n}\n\nfunction is_number_ptr(ptr) {\n    return is_ptr(ptr) && head(ptr) === NUMBER_TYPE;\n}\n\nfunction is_bool_ptr(ptr) {\n    return is_ptr(ptr) && head(ptr) === BOOL_TYPE;\n}\n\nfunction is_string_ptr(ptr) {\n    return is_ptr(ptr) && head(ptr) === STRING_TYPE;\n}\n\nfunction is_ptr_ptr(ptr) {\n    return is_ptr(ptr) && head(ptr) === PTR_TYPE;\n}\n\nfunction is_null_ptr(ptr) {\n    return is_ptr(ptr) && head(ptr) === NULL_TYPE;\n}\n\nfunction is_undefined_ptr(ptr) {\n    return is_ptr(ptr) && head(ptr) === UNDEFINED_TYPE;\n}\n\nfunction is_prog_ptr(ptr) {\n    return is_ptr(ptr) && head(ptr) === PROG_TYPE;\n}\n\nfunction is_no_value_yet_ptr(ptr) {\n    return is_ptr(ptr) && head(ptr) === NO_VALUE_YET_TYPE;\n}\n\nfunction is_broken_heart_ptr(ptr) {\n    return is_ptr(ptr) && head(ptr) === BROKEN_HEART_TYPE;\n}\n\n// Primitive functions and constants\n\nconst primitive_function_names_arities = list(\n       pair(\"display\", 1),\n       pair(\"error\", 1),\n       pair(\"+\", 2),\n       pair(\"-\", 2),\n       pair(\"*\", 2),\n       pair(\"/\", 2),\n       pair(\"%\", 2),\n       pair(\"===\", 2),\n       pair(\"!==\", 2),\n       pair(\"<\", 2),\n       pair(\"<=\", 2),\n       pair(\">\", 2),\n       pair(\">=\", 2),\n       pair(\"!\", 1),\n       pair(\"||\", 2),\n       pair(\"&&\", 2)\n);\n\nconst primitive_constants = list(\n       list(\"undefined\", undefined),\n       list(\"math_PI\"  , math_PI)\n      );\n\nfunction make_primitive_function(impl) {\n    return list(\"primitive\", impl);\n}\n\nfunction setup_environment() {\n    const primitive_function_names =\n        map(head, primitive_function_names_arities);\n    const primitive_function_values =\n        map(name => pair(make_primitive_function(name), false),\n            primitive_function_names);\n    const primitive_constant_names =\n        map(head, primitive_constants);\n    const primitive_constant_values =\n        map(f => pair(head(tail(f)), false),\n            primitive_constants);\n    return pair(pair(\n               append(primitive_function_names,\n                      primitive_constant_names),\n               append(primitive_function_values,\n                      primitive_constant_values)),\n               null);\n}\n\nfunction flatten_list_to_vectors(the_heads, the_tails, lst,\n                                 make_ptr_fn, starting_index) {\n    let free = starting_index;\n    function helper(lst) {\n        if (!is_pair(lst)) {\n            return wrap_ptr(lst);\n        } else {\n            const index = free;\n            free = free + 1;\n            const elem = head(lst);\n            the_heads[index] = helper(elem);\n            the_tails[index] = helper(tail(lst));\n            return make_ptr_fn(index);\n        }\n    }\n    helper(lst);\n    return free;\n}\n\n// MACHINE\nfunction get_contents(register) {\n    return register(\"get\");\n}\n\nfunction set_contents(register, value) {\n    return register(\"set\")(value);\n}\n\nfunction make_stack() {\n    let stack = null;\n\n    function push(x) {\n        stack = pair(x, stack);\n        return \"done\";\n    }\n\n    function pop() {\n        if (is_null(stack)) {\n            error(\"empty stack -- pop\");\n\n        } else {\n            const top = head(stack);\n            stack = tail(stack);\n            return top;\n        }\n    }\n\n    function initialize() {\n        stack = null;\n        return \"done\";\n    }\n\n    function dispatch(message) {\n        return message === \"push\"\n               ? push\n               : message === \"pop\"\n               ? pop()\n               : message === \"initialize\"\n               ? initialize()\n               : message === \"stack\"\n               ? stack\n               : error(message, \"unknown request -- stack\");\n    }\n\n    return dispatch;\n}\n\nfunction make_new_machine() {\n    const SIZE = make_register(\"SIZE\");\n    const pc = make_register(\"pc\");\n    const flag = make_register(\"flag\");\n    const stack = make_stack();\n    const stack_reassign_proc = make_register(\"stack_reassign_proc\");\n    const free = make_register(\"free\");\n    const root = make_register(\"root\");\n    const root_populate_proc = make_register(\"root_populate_proc\");\n    const root_restore_proc = make_register(\"root_restore_proc\");\n    const gc_registers = list(\n        list(\"free\", free),\n        list(\"scan\", make_register(\"scan\")),\n        list(\"old\", make_register(\"old\")),\n        list(\"new\", make_register(\"new\")),\n        list(\"relocate_continue\", make_register(\"relocate_continue\")),\n        list(\"temp\", make_register(\"temp\")),\n        list(\"oldht\", make_register(\"oldht\"))\n    );\n    const exp = make_register(\"exp\");\n    const env = make_register(\"env\");\n    const evaluator_registers = list(\n        list(\"exp\", exp),\n        list(\"env\", env),\n        list(\"val\", make_register(\"val\")),\n        list(\"continue\", make_register(\"continue\")),\n        list(\"fun\", make_register(\"fun\")),\n        list(\"argl\", make_register(\"argl\")),\n        list(\"unev\", make_register(\"unev\")),\n        list(\"fun\", make_register(\"fun\"))\n    );\n    const aux_registers = list(\n        list(\"res\", make_register(\"val\")),\n        list(\"err\", make_register(\"err\")),\n        list(\"a\", make_register(\"a\")),\n        list(\"b\", make_register(\"b\")),\n        list(\"c\", make_register(\"c\")),\n        list(\"d\", make_register(\"d\")),\n        list(\"e\", make_register(\"e\")),\n        list(\"f\", make_register(\"f\"))\n    );\n    const the_heads = make_register(\"the_heads\");\n    const the_tails = make_register(\"the_tails\");\n    set_contents(the_heads, make_vector());\n    set_contents(the_tails, make_vector());\n    const new_heads = make_register(\"new_heads\");\n    const new_tails = make_register(\"new_tails\");\n    set_contents(new_heads, make_vector());\n    set_contents(new_tails, make_vector());\n    const prog_heads = make_register(\"prog_heads\");\n    const prog_tails = make_register(\"prog_tails\");\n    let the_instruction_sequence = null;\n    let the_ops = list(list(\"initialize_stack\",\n                            () => stack(\"initialize\")));\n    the_ops = append(the_ops, vector_ops);\n    let register_table =\n          list(list(\"SIZE\", SIZE),\n               list(\"pc\", pc),\n               list(\"flag\", flag),\n               list(\"root\", root),\n               list(\"root_populate_proc\", root_populate_proc),\n               list(\"root_restore_proc\", root_restore_proc),\n               list(\"stack_reassign_proc\", stack_reassign_proc),\n               list(\"the_heads\", the_heads),\n               list(\"the_tails\", the_tails),\n               list(\"new_heads\", new_heads),\n               list(\"new_tails\", new_tails),\n               list(\"prog_heads\", prog_heads),\n               list(\"prog_tails\", prog_tails));\n    register_table = append(register_table, gc_registers);\n    register_table = append(register_table, evaluator_registers);\n    register_table = append(register_table, aux_registers);\n\n    function start() {\n        const root_registers =\n                append(aux_registers, evaluator_registers);\n        set_contents(pc, the_instruction_sequence);\n        set_contents(free,\n                     make_ptr_ptr(flatten_list_to_vectors(\n                                    the_heads(\"get\"),\n                                    the_tails(\"get\"),\n                                    setup_environment(),\n                                    make_ptr_ptr,\n                                    length(root_registers))));\n        set_contents(env, make_ptr_ptr(length(root_registers)));\n        function root_populate_proc_fn() {\n            const root_ptr = free(\"get\");\n            root(\"set\")(root_ptr);\n            let register_list = root_registers;\n            while (!is_null(register_list)) {\n                const content = head(tail(head(register_list)))(\"get\");\n                const index = unwrap_ptr(free(\"get\"));\n                the_heads(\"get\")[index] =\n                  content === \"*unassigned*\"\n                  ? make_null_ptr() : content;\n                free(\"set\")(make_ptr_ptr(index + 1));\n                the_tails(\"get\")[index] = free(\"get\");\n                register_list = tail(register_list);\n            }\n            the_tails(\"get\")[unwrap_ptr(free(\"get\")) - 1] =\n              make_null_ptr();\n        }\n        function root_restore_proc_fn() {\n            let root_ptr = root(\"get\");\n            let register_list = root_registers;\n            while (!is_null(register_list)) {\n                const index = unwrap_ptr(root_ptr);\n                const value = the_heads(\"get\")[index];\n                head(tail(head(register_list)))(\"set\")(value);\n                root_ptr = the_tails(\"get\")[index];\n                register_list = tail(register_list);\n            }\n        }\n        function stack_reassign_proc_fn() {\n            let local_stack = stack(\"stack\");\n            while (!is_null(local_stack)) {\n                const value = head(local_stack);\n                if (is_ptr_ptr(value)) {\n                    const index = unwrap_ptr(value);\n                    const new_ptr = the_tails(\"get\")[index];\n                    set_head(local_stack, new_ptr);\n                } else {}\n                local_stack = tail(local_stack);\n            }\n        }\n        set_contents(root_populate_proc, root_populate_proc_fn);\n        set_contents(root_restore_proc, root_restore_proc_fn);\n        set_contents(stack_reassign_proc, stack_reassign_proc_fn);\n        return execute();\n    }\n    function allocate_register(name) {\n        if (is_undefined(assoc(name, register_table))) {\n        register_table = pair(list(name, make_register(name)),\n                              register_table);\n        } else {\n            error(name, \"multiply defined register\");\n        }\n        return \"register allocated\";\n    }\n    function lookup_register(name) {\n        const val = assoc(name, register_table);\n        return is_undefined(val)\n               ? error(name, \"unknown register\")\n               : head(tail(val));\n    }\n    function execute() {\n        const insts = get_contents(pc);\n        if (is_null(insts)) {\n            return \"done\";\n        } else {\n            const proc = inst_execution_fun(head(insts));\n            proc();\n            return execute();\n        }\n    }\n    function dispatch(message) {\n        return message === \"start\"\n               ? start\n               : message === \"install_instruction_sequence\"\n               ? seq => { the_instruction_sequence = seq; }\n               : message === \"allocate_register\"\n               ? allocate_register\n               : message === \"get_register\"\n               ? lookup_register\n               : message === \"install_operations\"\n               ? ops => { the_ops = append(the_ops, ops); }\n               : message === \"stack\"\n               ? stack\n               : message === \"operations\"\n               ? the_ops\n               : error(message, \"unknown request -- machine\");\n    }\n    return dispatch;\n}\n\nfunction make_machine(register_names, ops, controller) {\n    const machine = make_new_machine();\n\n    map(reg_name => machine(\"allocate_register\")(reg_name), register_names);\n    machine(\"install_operations\")(ops);\n    machine(\"install_instruction_sequence\")(assemble(controller, machine));\n\n    return machine;\n}\n\nfunction start(machine) {\n    return machine(\"start\")();\n}\n\nfunction get_register_contents(machine, register_name) {\n    return get_contents(get_register(machine, register_name));\n}\n\nfunction set_register_contents(machine, register_name, value) {\n    set_contents(get_register(machine, register_name), value);\n    return \"done\";\n}\n\nfunction get_register(machine, reg_name) {\n    return machine(\"get_register\")(reg_name);\n}\n\n// ASSEMBLER\n\nfunction assemble(controller, machine) {\n    function receive(insts, labels) {\n        update_insts(insts, labels, machine);\n        return insts;\n    }\n\n    return extract_labels(controller, receive);\n}\n\nfunction extract_labels(text, receive) {\n    function helper(insts, labels) {\n        const next_inst = head(text);\n\n        return is_string(next_inst)\n               ? receive(insts, pair(make_label_entry(next_inst, insts), labels))\n               : receive(pair(make_inst(next_inst), insts), labels);\n    }\n\n    return is_undefined(text) || is_null(text)\n           ? receive(null, null)\n           : extract_labels(tail(text), helper);\n}\n\nfunction update_insts(insts, labels, machine) {\n    const pc = get_register(machine, \"pc\");\n    const flag = get_register(machine, \"flag\");\n    const stack = machine(\"stack\");\n    const ops = machine(\"operations\");\n\n    const set_iep = set_inst_execution_fun;\n    const make_ep = make_execution_function;\n    return map(i => set_iep(i,\n                            make_ep(inst_controller_instruction(i),\n                                    labels,\n                                    machine,\n                                    pc,\n                                    flag,\n                                    stack,\n                                    ops)),\n               insts);\n}\n\nfunction make_inst(inst_controller_instruction) {\n    return pair(inst_controller_instruction, null);\n}\n\nfunction inst_controller_instruction(inst) {\n    return head(inst);\n}\n\nfunction inst_execution_fun(inst) {\n    return tail(inst);\n}\n\nfunction set_inst_execution_fun(inst, fun) {\n    set_tail(inst, fun);\n}\n\nfunction make_label_entry(label_name, insts) {\n    return pair(label_name, insts);\n}\n\nfunction lookup_label(labels, label_name) {\n    const val = assoc(label_name, labels);\n\n    return is_undefined(val)\n           ? error(label_name, \"undefined label -- assemble\")\n           : tail(val);\n}\n\nfunction make_execution_function(inst, labels, machine, pc, flag, stack, ops) {\n    const x = head(inst);\n\n    return x === \"assign\"\n           ? make_assign_ef(inst, machine, labels, ops, pc)\n           : x === \"test\"\n           ? make_test_ef(inst, machine, labels, ops, flag, pc)\n           : x === \"branch\"\n           ? make_branch_ef(inst, machine, labels, flag, pc)\n           : x === \"go_to\"\n           ? make_go_to_ef(inst, machine, labels, pc)\n           : x === \"save\"\n           ? make_save_ef(inst, machine, stack, pc)\n           : x === \"restore\"\n           ? make_restore_ef(inst, machine, stack, pc)\n           : x === \"perform\"\n           ? make_perform_ef(inst, machine, labels, ops, pc)\n           : x === \"dump_memory\" // Added to allow printing the memory vectors\n           ? () => {\n               display(stringify(get_register_contents(machine, \"the_heads\")));\n               display(stringify(get_register_contents(machine, \"the_tails\")));\n               advance_pc(pc);\n           }\n           : error(inst, \"unknown instruction type -- assemble\");\n}\n\nfunction make_assign_ef(inst, machine, labels, operations, pc) {\n    const target = get_register(machine, assign_reg_name(inst));\n    const value_exp = assign_value_exp(inst);\n    const value_fun = is_operation_exp(value_exp)\n          ? make_operation_exp_ef(value_exp, machine, labels, operations)\n          : make_primitive_exp_ef(value_exp, machine, labels);\n\n    function perform_assign() {\n        set_contents(target, value_fun());\n        advance_pc(pc);\n    }\n\n    return perform_assign;\n}\n\nfunction assign_reg_name(assign_instruction) {\n    return head(tail(assign_instruction));\n}\n\nfunction assign_value_exp(assign_instruction) {\n    return head(tail(tail(assign_instruction)));\n}\n\nfunction assign(reg_name, value_exp) {\n    return list(\"assign\", reg_name, value_exp);\n}\n\nfunction dump_memory() {\n    return list(\"dump_memory\", \"the_heads\", \"the_tails\");\n}\n\nfunction advance_pc(pc) {\n    set_contents(pc, tail(get_contents(pc)));\n\n}\n\nfunction make_test_ef(inst, machine, labels, operations, flag, pc) {\n    const condition = test_condition(inst);\n\n    if (is_operation_exp(condition)) {\n    const condition_fun = make_operation_exp_ef(condition, machine,\n                                             labels, operations);\n\n        function perform_test() {\n            set_contents(flag, unwrap_ptr(condition_fun()));\n            advance_pc(pc);\n        }\n\n        return perform_test;\n    } else {\n        error(inst, \"bad test instruction -- assemble\");\n    }\n}\n\nfunction test_condition(test_instruction) {\n    return head(tail(test_instruction));\n}\n\nfunction test(condition) {\n    return list(\"test\", condition);\n}\n\nfunction make_branch_ef(inst, machine, labels, flag, pc) {\n    const dest = branch_dest(inst);\n\n    if (is_label_exp(dest)) {\n        const insts = lookup_label(labels, label_exp_label(dest));\n\n        function perform_branch() {\n            if (get_contents(flag)) {\n                set_contents(pc, insts);\n\n            } else {\n                advance_pc(pc);\n            }\n        }\n\n        return perform_branch;\n\n    } else {\n        error(inst, \"bad branch instruction -- assemble\");\n    }\n}\n\nfunction branch_dest(branch_instruction) {\n    return head(tail(branch_instruction));\n}\n\nfunction branch(dest) {\n    return list(\"branch\", dest);\n}\n\nfunction make_goto(inst, machine, labels, pc) {\n    const dest = goto_dest(inst);\n\n    if (is_label_exp(dest)) {\n        const insts = lookup_label(labels, label_exp_label(dest));\n        return () => set_contents(pc, insts);\n\n    } else if (is_register_exp(dest)) {\n        const reg = get_register(machine, register_exp_reg(dest));\n        return () => set_contents(pc, get_contents(reg));\n\n    } else {\n        error(inst, \"bad go_to instruction -- assemble\");\n    }\n}\n\nfunction goto_dest(goto_instruction) {\n    return head(tail(goto_instruction));\n}\n/*\nfunction go_to(dest) {\n    return list(\"go_to\", dest);\n}\n*/\nfunction make_save_ef(inst, machine, stack, pc) {\n    const reg = get_register(machine, stack_inst_reg_name(inst));\n\n    function perform_save() {\n        push(stack, get_contents(reg));\n        advance_pc(pc);\n    }\n\n    return perform_save;\n}\n\nfunction make_restore_ef(inst, machine, stack, pc) {\n    const reg = get_register(machine, stack_inst_reg_name(inst));\n\n    function perform_restore() {\n        set_contents(reg, pop(stack));\n        advance_pc(pc);\n    }\n\n    return perform_restore;\n}\n\nfunction stack_inst_reg_name(stack_instruction) {\n    return head(tail(stack_instruction));\n}\n\nfunction save(register_name) {\n    return list(\"save\", register_name);\n}\n\nfunction restore(register_name) {\n    return list(\"restore\", register_name);\n}\n\nfunction make_perform_ef(inst, machine, labels, operations, pc) {\n    const action = perform_action(inst);\n\n    if (is_operation_exp(action)) {\n        const action_fun = make_operation_exp_ef(action, machine,\n                                              labels, operations);\n        return () => { action_fun(); advance_pc(pc); };\n\n    } else {\n        error(inst, \"bad perform instruction -- assemble\");\n    }\n}\n\nfunction perform_action(inst) {\n    return head(tail(inst));\n}\n\nfunction perform(op) {\n    return list(\"perform\", op);\n}\n\nfunction make_primitive_exp_ef(exp, machine, labels) {\n    if (is_constant_exp(exp)) {\n        const c = constant_exp_value(exp);\n        return () => c;\n\n    } else if (is_label_exp(exp)) {\n        const insts = lookup_label(labels, label_exp_label(exp));\n        return () => insts;\n\n    } else if (is_register_exp(exp)) {\n        const r = get_register(machine, register_exp_reg(exp));\n        return () => get_contents(r);\n\n    } else {\n        error(exp, \"unknown expression type -- assemble\");\n    }\n}\n\n/* TODO: probably remove these -- suddenly available through new import chains\nfunction is_register_exp(exp) {\n    return is_tagged_list(exp, \"reg\");\n}\n\nfunction register_exp_reg(exp) {\n    return head(tail(exp));\n}\n\nfunction reg(name) {\n    return list(\"reg\", name);\n}\n\nfunction is_constant_exp(exp) {\n    return is_tagged_list(exp, \"constant\");\n}\n\nfunction constant_exp_value(exp) {\n    return head(tail(exp));\n}\n\nfunction constant(value) {\n    return list(\"constant\", wrap_ptr(value));\n}\n\nfunction is_label_exp(exp) {\n    return is_tagged_list(exp, \"label\");\n}\n\nfunction label_exp_label(exp) {\n    return head(tail(exp));\n}\n\nfunction label(string) {\n    return list(\"label\", string);\n}\n*/\n\nfunction make_operation_exp_ef(exp, machine, labels, operations) {\n    const op = lookup_prim(op_exp_op(exp), operations);\n    const aprocs = map(e => make_primitive_exp_ef(e, machine, labels),\n                       operation_exp_operands(exp));\n\n    function perform_operation_exp() {\n        return op(map(p => p(), aprocs));\n    }\n\n    return perform_operation_exp;\n}\n\n/* TODO: probably remove these -- suddenly available through new import chains\nfunction is_operation_exp(exp) {\n    return is_tagged_list(head(exp), \"op\");\n}\n\nfunction operation_exp_operands(operation_exp) {\n    return tail(operation_exp);\n}\n\nfunction op(name) {\n    return list(\"op\", name);\n}\n*/\n\nfunction op_exp_op(operation_exp) {\n    return head(tail(head(operation_exp)));\n}\n\nfunction lookup_prim(symbol, operations) {\n    const val = assoc(symbol, operations);\n\n    return is_undefined(val)\n           ? error(symbol, \"unknown operation -- assemble\")\n           : head(tail(val));\n}\n\n// PAIR OPERATIONS\n\n// head in \"a\", tail in \"b\"\nconst pair_controller = list(\n  \"pair\",\n    save(\"continue\"),\n    assign(\"continue\", label(\"pair_after_gc\")),\n    test(list(op(\"===\"), reg(\"free\"), reg(\"SIZE\"))),\n    branch(label(\"begin_garbage_collection\")),\n  \"pair_after_gc\",\n    restore(\"continue\"),\n    perform(list(op(\"vector_set\"), reg(\"the_heads\"), reg(\"free\"), reg(\"a\"))),\n    perform(list(op(\"vector_set\"), reg(\"the_tails\"), reg(\"free\"), reg(\"b\"))),\n    assign(\"res\", reg(\"free\")),\n    assign(\"free\", list(op(\"inc_ptr\"), reg(\"free\"))),\n    go_to(reg(\"continue\"))\n);\n\nfunction underlying_javascript_closure(fn) {\n    return args => apply_in_underlying_javascript(fn, args);\n}\n\nfunction unwrap_args(fn) {\n    return args => fn(map(unwrap_ptr, args));\n}\n\nfunction wrap_return_value(fn) {\n    return args => wrap_ptr(fn(args));\n}\n\nfunction primitive_function(fn) {\n    return wrap_return_value(unwrap_args(underlying_javascript_closure(fn)));\n}\n\n// 5.3 MEMORY MANAGEMENT\n\nfunction vector_ref(vector, idx) {\n    return vector[unwrap_ptr(idx)];\n}\n\nfunction vector_set(vector, idx, val) {\n    vector[unwrap_ptr(idx)] = val;\n}\n\nfunction make_vector() {\n    return [];\n}\n\nfunction inc_ptr(ptr) {\n    return make_ptr_ptr(unwrap_ptr(ptr) + 1);\n}\n\nconst vector_ops = list(\n    list(\"vector_ref\", underlying_javascript_closure(vector_ref)),\n    list(\"vector_set\", underlying_javascript_closure(vector_set)),\n    list(\"inc_ptr\", underlying_javascript_closure(inc_ptr))\n);\n\n// MACHINE SETUP\nconst ptr_ops =\n  list(\n    list(\"make_ptr_ptr\",\n         underlying_javascript_closure(make_ptr_ptr)),\n    list(\"make_null_ptr\",\n         underlying_javascript_closure(make_null_ptr)),\n    list(\"make_no_value_yet_ptr\",\n         underlying_javascript_closure(make_no_value_yet_ptr)),\n    list(\"make_prog_ptr\", underlying_javascript_closure(make_prog_ptr)),\n    list(\"make_broken_heart_ptr\",\n         underlying_javascript_closure(make_broken_heart_ptr)),\n    list(\"is_number_ptr\",\n         wrap_return_value(underlying_javascript_closure(is_number_ptr))),\n    list(\"is_bool_ptr\",\n         wrap_return_value(underlying_javascript_closure(is_bool_ptr))),\n    list(\"is_string_ptr\",\n         wrap_return_value(underlying_javascript_closure(is_string_ptr))),\n    list(\"is_ptr_ptr\",\n         wrap_return_value(underlying_javascript_closure(is_ptr_ptr))),\n    list(\"is_null_ptr\",\n         wrap_return_value(underlying_javascript_closure(is_null_ptr))),\n    list(\"is_undefined_ptr\",\n         wrap_return_value(underlying_javascript_closure(is_undefined_ptr))),\n    list(\"is_prog_ptr\",\n         wrap_return_value(underlying_javascript_closure(is_prog_ptr))),\n    list(\"is_no_value_yet_ptr\",\n         wrap_return_value(underlying_javascript_closure(is_no_value_yet_ptr))),\n    list(\"is_broken_heart_ptr\",\n         wrap_return_value(underlying_javascript_closure(is_broken_heart_ptr)))\n);\n\nconst primitive_ops = list(\n    list(\"display\", primitive_function(display)),\n    list(\"error\", primitive_function(error)),\n    list(\"+\", primitive_function((x, y) => x + y)),\n    list(\"-\", primitive_function((x, y) => x - y)),\n    list(\"*\", primitive_function((x, y) => x * y)),\n    list(\"/\", primitive_function((x, y) => x / y)),\n    list(\"%\", primitive_function((x, y) => x % y)),\n    list(\"===\", primitive_function((x, y) => x === y)),\n    list(\"!==\", primitive_function((x, y) => x !== y)),\n    list(\"<\", primitive_function((x, y) => x < y)),\n    list(\"<=\", primitive_function((x, y) => x <= y)),\n    list(\">\", primitive_function((x, y) => x > y)),\n    list(\">=\", primitive_function((x, y) => x >= y)),\n    list(\"!\", primitive_function(x => !x)),\n    list(\"||\", primitive_function((x, y) => x || y)),\n    list(\"&&\", primitive_function((x, y) => x && y))\n);\n\nconst gc_ops = list(\n    list(\"call_proc\", underlying_javascript_closure(proc => proc()))\n);\n\nconst gc_controller = list(\n  \"begin_garbage_collection\",\n    perform(list(op(\"call_proc\"), reg(\"root_populate_proc\"))),\n    assign(\"free\", list(op(\"make_ptr_ptr\"), constant(0))),\n    assign(\"scan\", list(op(\"make_ptr_ptr\"), constant(0))),\n    assign(\"old\", reg(\"root\")),\n    assign(\"relocate_continue\", label(\"reassign_root\")),\n    go_to(label(\"relocate_old_result_in_new\")),\n  \"reassign_root\",\n    assign(\"root\", reg(\"new\")),\n    go_to(label(\"gc_loop\")),\n  \"gc_loop\",\n    test(list(op(\"===\"), reg(\"scan\"), reg(\"free\"))),\n    branch(label(\"gc_flip\")),\n    assign(\"old\", list(op(\"vector_ref\"), reg(\"new_heads\"), reg(\"scan\"))),\n    assign(\"relocate_continue\", label(\"update_head\")),\n    go_to(label(\"relocate_old_result_in_new\")),\n  \"update_head\",\n    perform(list(op(\"vector_set\"), reg(\"new_heads\"), reg(\"scan\"), reg(\"new\"))),\n    assign(\"old\", list(op(\"vector_ref\"), reg(\"new_tails\"), reg(\"scan\"))),\n    assign(\"relocate_continue\", label(\"update_tail\")),\n    go_to(label(\"relocate_old_result_in_new\")),\n  \"update_tail\",\n    perform(list(op(\"vector_set\"), reg(\"new_tails\"), reg(\"scan\"), reg(\"new\"))),\n    assign(\"scan\", list(op(\"inc_ptr\"), reg(\"scan\"))),\n    go_to(label(\"gc_loop\")),\n  \"relocate_old_result_in_new\",\n    test(list(op(\"is_ptr_ptr\"), reg(\"old\"))),\n    branch(label(\"gc_pair\")),\n    assign(\"new\", reg(\"old\")),\n    go_to(reg(\"relocate_continue\")),\n  \"gc_pair\",\n    assign(\"oldht\", list(op(\"vector_ref\"), reg(\"the_heads\"), reg(\"old\"))),\n    test(list(op(\"is_broken_heart_ptr\"), reg(\"oldht\"))),\n    branch(label(\"already_moved\")),\n    assign(\"new\", reg(\"free\")),\n    // new location for pair\n    // Update free pointer\n    assign(\"free\", list(op(\"inc_ptr\"), reg(\"free\"))),\n    // Copy the head and tail to new memory\n    perform(list(op(\"vector_set\"),\n                 reg(\"new_heads\"), reg(\"new\"), reg(\"oldht\"))),\n    assign(\"oldht\", list(op(\"vector_ref\"), reg(\"the_tails\"), reg(\"old\"))),\n    perform(list(op(\"vector_set\"),\n                 reg(\"new_tails\"), reg(\"new\"), reg(\"oldht\"))),\n    // Construct the broken heart\n    assign(\"oldht\", list(op(\"make_broken_heart_ptr\"))),\n    perform(list(op(\"vector_set\"),\n                 reg(\"the_heads\"), reg(\"old\"), reg(\"oldht\"))),\n    perform(list(op(\"vector_set\"),\n                 reg(\"the_tails\"), reg(\"old\"), reg(\"new\"))),\n    go_to(reg(\"relocate_continue\")),\n  \"already_moved\",\n    assign(\"new\", list(op(\"vector_ref\"), reg(\"the_tails\"), reg(\"old\"))),\n    go_to(reg(\"relocate_continue\")),\n  \"gc_flip\",\n    perform(list(op(\"call_proc\"), reg(\"stack_reassign_proc\"))),\n    assign(\"temp\", reg(\"the_tails\")),\n    assign(\"the_tails\", reg(\"new_tails\")),\n    assign(\"new_tails\", reg(\"temp\")),\n    assign(\"temp\", reg(\"the_heads\")),\n    assign(\"the_heads\", reg(\"new_heads\")),\n    assign(\"new_heads\", reg(\"temp\")),\n    perform(list(op(\"call_proc\"), reg(\"root_restore_proc\"))),\n    go_to(reg(\"continue\"))\n);\n\nconst error_controller = list(\n    \"error\",\n    perform(list(op(\"error\"), reg(\"res\"), reg(\"err\"))),\n    go_to(label(\"end_evaluation\"))\n);\n\nconst begin_controller =  list(\n  \"fig_5_14\",\n  \"pair4\",\n    assign(\"a\", constant(4)),\n    assign(\"b\", list(op(\"make_null_ptr\"))),\n    assign(\"continue\", label(\"garbage1\")),\n    go_to(label(\"pair\")),\n    /// The following creates a garbage\n    /// pair (9999, 9999) which will\n    /// not affect live object count at\n    /// the end of the program. You can\n    /// verify by adding more garbage\n    /// or remove this line. Or\n    /// uncomment the use of\n    /// dump_memory() below, before and\n    /// after GC.\n  \"garbage1\",\n    assign(\"a\", constant(9999)),\n    assign(\"b\", constant(9999)),\n    assign(\"continue\", label(\"pair2\")),\n    go_to(label(\"pair\")),\n  \"pair2\",\n    assign(\"a\", constant(3)),\n    assign(\"b\", reg(\"res\")),\n    assign(\"continue\", label(\"garbage2\")),\n    go_to(label(\"pair\")),\n    /// The following creates a garbage\n    /// pair (9999, 9999) which will\n    /// not affect live object count at\n    /// the end of the program. You can\n    /// verify by adding more garbage\n    /// or remove this line. Or\n    /// uncomment the use of\n    /// dump_memory() below, before and\n    /// after GC.\n  \"garbage2\",\n    assign(\"a\", constant(9999)),\n    assign(\"b\", constant(9999)),\n    assign(\"continue\", label(\"pair7\")),\n    go_to(label(\"pair\")),\n  \"pair7\",\n    assign(\"temp\", reg(\"res\")),\n    assign(\"a\", constant(2)),\n    assign(\"b\", list(op(\"make_null_ptr\"))),\n    assign(\"continue\", label(\"pair5\")),\n    go_to(label(\"pair\")),\n  \"pair5\",\n    assign(\"a\", constant(1)),\n    assign(\"b\", reg(\"res\")),\n    assign(\"continue\", label(\"pair1\")),\n    go_to(label(\"pair\")),\n  \"pair1\",\n    assign(\"a\", reg(\"res\")),\n    assign(\"b\", reg(\"temp\")),\n    assign(\"continue\", label(\"done\")),\n    go_to(label(\"pair\")),\n  \"done\",\n    // dump_memory(), // uncomment to get a dump of heads and tails vectors\n    assign(\"continue\", label(\"after_gc\")),\n    go_to(label(\"begin_garbage_collection\")),\n  \"after_gc\",\n    // dump_memory(), // uncomment to get a dump of heads and tails vectors\n    go_to(label(\"end_evaluation\")));\n\nconst end_controller = list(\n    \"end_evaluation\"\n);\n\nconst ops = accumulate(append, null, list(\n    vector_ops,\n    ptr_ops,\n    gc_ops,\n    primitive_ops\n));\n\nconst controller = accumulate(append, null, list(\n    begin_controller,\n    pair_controller,\n    gc_controller,\n    error_controller,\n    end_controller\n));\n\nfunction make_evaluator_machine(size) {\n    const evaluator_machine = make_machine(null, ops, controller);\n    set_register_contents(evaluator_machine, \"SIZE\", wrap_ptr(size));\n    return evaluator_machine;\n}\n\nconst evaluator_machine = make_evaluator_machine(10000);\n\nset_register_contents(evaluator_machine, \"a\", wrap_ptr(206));\nset_register_contents(evaluator_machine, \"b\", wrap_ptr(40));\n\nstart(evaluator_machine);\nget_register_contents(evaluator_machine, \"free\");\n// [ 'ptr', 108 ] The number of live objects in the program at termination\n\n      [ 'ptr', 108 ]\n\n\"gc_flip\",\n  assign(\"temp\", reg(\"the_tails\")),\n  assign(\"the_tails\", reg(\"new_tails\")),\n  assign(\"new_tails\", reg(\"temp\")),\n  assign(\"temp\", reg(\"the_heads\")),\n  assign(\"the_heads\", reg(\"new_heads\")),\n  assign(\"new_heads\", reg(\"temp\"))\n```",
    "token_count": 2604,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Maintaining the Illusion of Infinite Memory",
    "chunk_index": 6,
    "chunk_id": "Computing_with_Register_Machines_Maintaining_the_Illusion_of_Infinite_Memory_6"
  },
  {
    "content": "A conventional computer memory can be thought of as an array of\ncubbyholes, each of which can contain a piece of information.\n\nEach\ncubbyhole has a unique name, called its\naddress or\nlocation.\n\nTypical memory systems provide two primitive operations:\none that fetches the data stored in a specified location and one that\nassigns new data to a specified location.\n\nMemory addresses can be\nincremented to support sequential access to some set of the\ncubbyholes.\n\nMore generally, many important data operations require\nthat memory addresses be treated as data, which can be stored in\nmemory locations and manipulated in machine registers.\n\nThe\nrepresentation of list structure is one application of such\naddress arithmetic.\n\nTo model computer memory, we use a new kind of data structure called a\nvector.\n\nAbstractly, a vector is a compound data object whose\nindividual elements can be accessed by means of an integer index in an\namount of time that is independent of the index.\nfunctions\nfor manipulating vectors:\n-\n-\nvector_ref(vector, n)\nn th element of the vector.\n-\n-\nvector_set(vector, n, value)\n$n$ th element of the vector to the\ndesignated value.\n\nFor example, if\nvector_ref(v, 5)\ngets the fifth entry in the vector\nvector_set(v, 5, 7)\nchanges the value of the fifth entry of the vector\nbase address\nthat specifies the beginning location of a vector in memory with an\nindex that specifies the offset of a particular element of the\nvector.\n\nWe can use vectors to implement the basic pair structures required for a\nlist-structured memory.\n\nLet us imagine that computer memory is divided into\ntwo vectors:\nthe_heads\nand\nthe_tails.\n\nWe will represent list structure as follows: A pointer to a pair is an index\ninto the two vectors.",
    "token_count": 287,
    "has_code": false,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Memory as Vectors",
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_Memory_as_Vectors_1"
  },
  {
    "content": "We will represent list structure as follows: A pointer to a pair is an index\ninto the two vectors.\n\nThe\nhead\nof the pair is the entry in\nthe_heads\nwith the designated index, and the\ntail\nof the pair is the entry in\nthe_tails\nwith the designated index.\n\nWe also need a representation for objects other\nthan pairs (such as numbers and\nstrings)\nand a way to distinguish one kind of data from another.\n\nThere are many\nmethods of accomplishing this, but they all reduce to using\ntyped pointers , that is, to extending the notion of\npointer to include information on data type. pair\ndata type and an index into the memory vectors) from pointers to other\nkinds of data (which consist of some other data type and whatever is\nbeing used to represent data of that type).\n\nTwo data objects are\n\n```javascript\n(===)\n```\n\nif their pointers are identical.\n\nFigure\nillustrates the use of this method to represent\nlist(list(1, 2), 3, 4),\nwhose box-and-pointer diagram is also shown.\n\nWe use letter prefixes to\ndenote the data-type information.\n\nThus, a pointer to the pair with\nindex 5 is denoted 4 is denoted\nhead\nand\ntail\nof the pair are stored.\n\nThe blank locations in\nthe_heads\nand\nthe_tails\nmay contain parts of other list structures (not of interest here).\n\nA pointer to a number, such as bignum data type, for which the pointer designates a list in which the parts of the number are\n\nstored.\n\nA string\ns printed\nrepresentation.\n\nThe parser constructs such a sequence\nwhen it encounters a string literal, and the\nstring-concatenation operator + and\nstring-producing\nprimitive functions such as\nstringify\nconstruct such a sequence.",
    "token_count": 278,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Memory as Vectors",
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_Memory_as_Vectors_2"
  },
  {
    "content": "The parser constructs such a sequence\nwhen it encounters a string literal, and the\nstring-concatenation operator + and\nstring-producing\nprimitive functions such as\nstringify\nconstruct such a sequence.\n\nSince we want two instances of a string to\nbe recognized as the same string by\n=== and we want\n===\nto\nbe a simple test for equality of pointers, we must ensure that if the\nsystem sees the same string twice, it will use the same pointer (to\nthe same sequence of characters) to represent both occurrences.\n\nTo\naccomplish this, the system maintains a table, called the\nstring pool ,\nof all the strings it has ever encountered.\n\nWhen the system\nis about to construct a string, it checks the string pool to see if it has ever\nbefore seen the same string.\n\nIf it has not, it\nconstructs a new string (a typed pointer to a new\ncharacter sequence) and enters this pointer in the string pool.\n\nIf the\nsystem has seen the string before, it returns the string pointer\nstored in the string pool.\n\nThis process of replacing strings by unique\npointers is called\nstring interning.\n\nGiven the above representation , we can replace each\nprimitive list operation of a register machine with one or\nmore primitive vector operations.\n\nWe will use two registers,\nthe_heads\nand\nthe_tails,\nto identify the memory vectors, and will\nassume that\nvector_ref\nand\nvector_set\nare available as primitive operations.\n\nWe also assume that numeric\noperations on pointers (such as incrementing a pointer, using a pair pointer\nto index a vector, or adding two numbers) use only the index portion of\nthe typed pointer.\n\nFor example, we can make a register machine support the instructions\n\n```javascript\nassign(reg$_1$, list(op(\"head\"), reg(reg$_2$)))\n\nassign(reg$_1$, list(op(\"tail\"), reg(reg$_2$)))\n```\n\nif we implement these, respectively, as\n\n```javascript\nassign(reg$_1$, list(op(\"vector_ref\"), reg(\"the_heads\"), reg(reg$_2$)))\n\nassign(reg$_1$, list(op(\"vector_ref\"), reg(\"the_tails\"), reg(reg$_2$)))\n```",
    "token_count": 304,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Memory as Vectors",
    "chunk_index": 3,
    "chunk_id": "Computing_with_Register_Machines_Memory_as_Vectors_3"
  },
  {
    "content": "if we implement these, respectively, as\n\nThe instructions\n\n```javascript\nperform(list(op(\"set_head\"), reg(reg$_1$), reg(reg$_2$)))\n\nperform(list(op(\"set_tail\"), reg(reg$_1$), reg(reg$_2$)))\n```\n\nare implemented as\n\n```javascript\nperform(list(op(\"vector_set\"), reg(\"the_heads\"), reg(reg$_1$), reg(reg$_2$)))\n\nperform(list(op(\"vector_set\"), reg(\"the_tails\"), reg(reg$_1$), reg(reg$_2$)))\n```\n\n```javascript\nThe operation\n\tpair\n```\n\nis performed by allocating an unused index and storing the arguments to\npair\nin\nthe_heads\nand\nthe_tails\nat that indexed vector position.\n\nWe presume that there is a special\nregister,\n\n```javascript\nassign(reg$_1$, list(op(\"pair\"), reg(reg$_2$), reg(reg$_3$)))\n```\n\nis implemented as the following sequence of vector operations:\n\n```javascript\nperform(list(op(\"vector_set\"),\n             reg(\"the_heads\"), reg(\"free\"), reg(reg$_2$))),\nperform(list(op(\"vector_set\"),\n             reg(\"the_tails\"), reg(\"free\"), reg(reg$_3$))),\nassign(reg$_1$, reg(\"free\")),\nassign(\"free\", list(op(\"+\"), reg(\"free\"), constant(1)))\n```\n\nThe\n\n```javascript\n===\n```\n\noperation\n\n```javascript\nlist(op(\"===\"), reg(reg$_1$), reg(reg$_2$))\n```\n\nsimply tests the equality of all fields in the registers, and predicates such as is_pair, is_null, is_string, and is_number need only check the type field.\n\nAlthough our register machines use stacks, we need do nothing special\nhere, since stacks can be modeled in terms of lists.\n\nThe stack can be\na list of the saved values, pointed to by a special register\nthe_stack.\n\nThus,\nsave(reg)\ncan be implemented as\n\n```javascript\nassign(\"the_stack\", list(op(\"pair\"), reg(reg), reg(\"the_stack\")))\n```\n\nSimilarly, restore(reg) can be implemented as\n\n```javascript\nassign(reg, list(op(\"head\"), reg(\"the_stack\")))\nassign(\"the_stack\", list(op(\"tail\"), reg(\"the_stack\")))\n```\n\nand perform(list(op(\"initialize_stack\"))) can be implemented as\n\n```javascript\nassign(\"the_stack\", constant(null))\n```\n\nThese operations can be further expanded in terms of the vector\noperations given above.\n\nIn conventional computer architectures,\nhowever, it is usually advantageous to allocate the stack as a\nseparate vector.\n\nThen pushing and popping the stack can be\naccomplished by incrementing or decrementing an index into that\nvector.",
    "token_count": 253,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "Storage Allocation and Garbage Collection",
    "subsection": "Memory as Vectors",
    "chunk_index": 4,
    "chunk_id": "Computing_with_Register_Machines_Memory_as_Vectors_4"
  },
  {
    "content": "In section we saw how to\ntransform simple\nJavaScript\nprograms into descriptions of register\nmachines.\n\nWe will now perform this transformation on a more complex\nprogram, the metacircular evaluator of\nsections ,\nwhich shows how the behavior of a\nJavaScript\ninterpreter can be described in terms of the\nfunctions\nand explicit-control\nevaluator that we develop in this section shows how the underlying\nfunction-calling\nand argument-passing mechanisms used in the\nevaluation process can be described in terms of operations on\nregisters and stacks.\n\nIn addition, the explicit-control evaluator can\nserve as an implementation of a\nJavaScript\ninterpreter, written in a language that is very similar to the native machine\nlanguage of conventional computers.\n\nThe evaluator can be executed by the\nregister-machine simulator of section.\n\nAlternatively, it can be used as a starting point for building a\nmachine-language implementation of a\nJavaScript\nevaluator, or even a\nJavaScript programs.\n\nFigure shows such a hardware\nimplementation: a silicon chip that acts as an evaluator for\n, the language used in place of JavaScript in the original edition of this book.\n\nThe chip designers started with the data-path and controller specifications\nfor a register machine similar to the evaluator described in this section\nand used design automation programs to construct the\nintegrated-circuit layout.\n\nIn designing the explicit-control evaluator, we must specify the\noperations to be used in our register machine.\n\nWe described the\nmetacircular evaluator in terms of abstract syntax, using\nfunctions\nsuch as\nis_literal\nand\nmake_function.\n\nIn implementing the\nregister machine, we could expand these\nfunctions\ninto sequences of\nelementary list-structure memory operations, and implement these\noperations on our register machine.\n\nHowever, this would make our\nevaluator very long, obscuring the basic structure with\ndetails.",
    "token_count": 281,
    "has_code": false,
    "chapter": "Computing with Register Machines",
    "section": "The Explicit-Control Evaluator",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Computing_with_Register_Machines_The_Explicit-Control_Evaluator_1"
  },
  {
    "content": "However, this would make our\nevaluator very long, obscuring the basic structure with\ndetails.\n\nTo clarify the presentation, we will include as primitive\noperations of the register machine the syntax\nfunctions\ngiven in\nsection and the\nfunctions\nfor representing environments and other runtime data given in\nsections\nand.\n\nIn order to completely specify an evaluator that could be programmed\nin a low-level machine language or implemented in hardware, we would\nreplace these operations by more elementary operations, using the\nlist-structure implementation we described in\nsection.\n\nOur\nJavaScript\nevaluator register machine includes a stack and seven\nregisters:\nThe comp register\nis used to hold the\ncomponent\nto be evaluated, and component\nin the designated environment.\n\nThe.\n\n(The evaluator needs to call itself recursively, since\nevaluating\n\n```javascript\na\n    component\n```\n\nrequires evaluating its subcomponents. ) The registers\n\nWe will not provide a data-path diagram to show how the registers and\noperations of the evaluator are connected, nor will we give the\ncomplete list of machine operations.\n\nThese are implicit in the\nevaluator s controller, which will be presented in detail.",
    "token_count": 178,
    "has_code": true,
    "chapter": "Computing with Register Machines",
    "section": "The Explicit-Control Evaluator",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Computing_with_Register_Machines_The_Explicit-Control_Evaluator_2"
  },
  {
    "content": "In our study of program design, we have seen that expert programmers\ncontrol the complexity of their designs with the same general\ntechniques used by designers of all complex systems.\n\nThey combine\nprimitive elements to form compound objects, they abstract compound\nobjects to form higher-level building blocks, and they preserve\nmodularity by adopting appropriate large-scale views of system\nstructure.\n\nIn illustrating these techniques, we have used\nJavaScript\nas a language for describing processes and for constructing computational\ndata objects and processes to model complex phenomena in the real world.\n\nHowever, as we confront increasingly complex problems, we will find that\nJavaScript,\nor indeed any fixed programming language, is not sufficient for our needs.\n\nWe must constantly turn to new languages in order to express our ideas more\neffectively.\n\nEstablishing new languages is a powerful strategy for\ncontrolling complexity in engineering design; we can often enhance our\nability to deal with a complex problem by adopting a new language that\nenables us to describe (and hence to think about) the problem in a different\nway, using primitives, means of combination, and means of abstraction that\nare particularly well suited to the problem at hand.\n\nProgramming is endowed with a multitude of languages.\n\nThere are\nphysical languages, such as the\nfunction declaration,\nthat are appropriate to the larger-scale organization of systems.\n\nMetalinguistic abstraction establishing\nplays an important role in all branches of engineering\ndesign.\n\nIt is particularly important to computer programming, because\nin programming not only can we formulate new languages but we can also\nimplement these languages by constructing evaluators.\n\nAn\nevaluator (or interpreter ) for a programming language is a\nfunction\nthat, when applied to\na statement or expression\nof the language, performs the actions required to evaluate that\nstatement or\nexpression.",
    "token_count": 292,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": null,
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Metalinguistic_Abstraction_1"
  },
  {
    "content": "An\nevaluator (or interpreter ) for a programming language is a\nfunction\nthat, when applied to\na statement or expression\nof the language, performs the actions required to evaluate that\nstatement or\nexpression.\n\nIt is no exaggeration to regard this as the most fundamental idea in\nprogramming:\nThe evaluator, which determines the meaning of\nstatements and\nexpressions in a programming language, is just another program.\n\nTo appreciate this point is to change our images of ourselves as\nprogrammers.\n\nWe come to see ourselves as designers of languages,\nrather than only users of languages designed by others.\n\nIn fact, we can regard almost any program as the evaluator for some\nlanguage.\n\nFor instance, the polynomial manipulation system of\nsection embodies the rules of\npolynomial arithmetic and implements them in terms of operations on\nlist-structured data.\n\nIf we augment this system with\nfunctions\nto read and print polynomial expressions, we have the core of a\nspecial-purpose language for dealing with problems in symbolic mathematics.\n\nThe digital-logic simulator of\nsection and the constraint\npropagator of section are legitimate\nlanguages in their own right, each with its own primitives, means of\ncombination, and means of abstraction.\n\nSeen from this perspective, the\ntechnology for coping with large-scale computer systems merges with the\ntechnology for building new computer languages, and\n\nWe now embark on a tour of the technology by which languages are\nestablished in terms of other languages.\n\nIn this chapter we shall use\nJavaScript\nas a base, implementing evaluators as\nJavaScript\nfunctions.\n\nWe will take the first step in understanding how languages are implemented\nby building an evaluator for\nJavaScript\nitself.\n\nThe language implemented by our evaluator will be a subset of\nJavaScript.",
    "token_count": 279,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": null,
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Metalinguistic_Abstraction_2"
  },
  {
    "content": "The language implemented by our evaluator will be a subset of\nJavaScript.\n\nAlthough the evaluator described in this chapter is written for a\nparticular\nsubset of JavaScript,\nit contains the essential structure of an evaluator for any\nlanguage\ndesigned for writing programs for a sequential machine.\n\n(In fact, most\nlanguage processors contain, deep within them, a little\nevaluator.)\nThe evaluator has been simplified for the purposes of illustration and\ndiscussion, and some features have been left out that would be\nimportant to include in a production-quality\nJavaScript\nsystem.\n\nNevertheless, this simple evaluator is adequate to execute most of\nthe programs in this book.\n\nAn important advantage of making the evaluator accessible as a\nJavaScript\nprogram is that we can implement alternative evaluation rules by describing\nthese as modifications to the evaluator program.\n\nOne place where we can use\nthis power to good effect is to gain extra control over the ways in which\ncomputational models embody the notion of time, which was so central to the\ndiscussion in chapter.\n\nThere, we mitigated some of the complexities\nof state and assignment by using streams to decouple the representation of\ntime in the world from time in the computer.\n\nOur stream programs, however,\nwere sometimes cumbersome, because they were constrained by the\napplicative-order evaluation of\nJavaScript.\n\nIn section , we ll change\nthe underlying language to provide for a more elegant approach, by modifying\nthe evaluator to provide for normal-order evaluation.\n\nSection implements a\nmore ambitious linguistic change, whereby statements and expressions\nhave many values, rather than just a single value.\n\nIn this language of\nnondeterministic computing , it is natural to express processes that\ngenerate all possible values for statements and expressions and then search\nfor those values that satisfy certain constraints.",
    "token_count": 291,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": null,
    "subsection": null,
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Metalinguistic_Abstraction_3"
  },
  {
    "content": "In this language of\nnondeterministic computing , it is natural to express processes that\ngenerate all possible values for statements and expressions and then search\nfor those values that satisfy certain constraints.\n\nIn terms of models of\ncomputation and time, this is like having time branch into a set of\npossible futures and then searching for appropriate time\nlines.\n\nWith our nondeterministic evaluator, keeping track of multiple values\nand performing searches are handled automatically by the underlying\nmechanism of the language.\n\nIn section we implement a\nlogic-programming language in which knowledge is expressed in terms\nof relations, rather than in terms of computations with inputs and outputs.\n\nEven though this makes the language drastically different from\nJavaScript,\nor indeed from any conventional language, we will see that\nthe logic-programming evaluator shares the essential structure of the\nJavaScript\nevaluator.",
    "token_count": 138,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": null,
    "subsection": null,
    "chunk_index": 4,
    "chunk_id": "Metalinguistic_Abstraction_Metalinguistic_Abstraction_4"
  },
  {
    "content": "Now that we have an evaluator expressed as a\nJavaScript\nprogram, we can experiment with alternative choices in\nJavaScript\nwith another member of the\nJavaScript\ncommunity, we can supply an evaluator that embodies\nthe change.\n\nThe recipient can then experiment with the new\nevaluator and send back comments as further modifications.\n\nNot only\ndoes the high-level implementation base make it easier to test and\ndebug the evaluator; in addition, the embedding enables the designer\nto snarf\nJavaScript\nevaluator uses primitives and control structure from the underlying\nJavaScript.\n\nOnly later (if ever) need the designer go to the trouble of building a\ncomplete implementation in a low-level language or in hardware.\n\nIn\nthis section and the next we explore some variations on\nJavaScript\nthat provide significant additional expressive power.",
    "token_count": 128,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Lazy_Evaluation_1"
  },
  {
    "content": "In this section we will implement a normal-order language that is\nthe same as\nJavaScript\nexcept that compound\nfunctions\nare non-strict in each argument.\n\nPrimitive\nfunctions\nwill still be strict.\n\nIt is not difficult to modify the evaluator of\nsection so that the language it\ninterprets behaves this way.\n\nAlmost all the required changes center around\nfunction\napplication.\n\nThe basic idea is that, when applying a\nfunction,\nthe interpreter must determine which arguments are to be evaluated and which\nare to be delayed.\n\nThe delayed arguments are not evaluated; instead, they\nare transformed into objects called\nthunk s.\nfunction\napplication is being evaluated.\n\nThe process of evaluating the expression in a thunk is called\nforcing.\nfunction\nthat will use the value of the thunk; when it is the value of a predicate of\na conditional; and when it is the value of\na function expression\nthat is about to be\napplied as a\nfunction.\n\nOne design choice we have available is whether or not to\nmemoize thunks, similar to the optimization for streams in\nsection.\n\nWith memoization, the first\ntime a thunk is forced, it stores the value that is computed.\n\nSubsequent\nforcings simply return the stored value without repeating the computation.\n\nWe ll make our interpreter memoize, because this is more efficient for\nmany applications.\n\nThere are tricky considerations here,\nhowever.\n\nThe main difference between the lazy evaluator and the one in section is in the handling of function applications in evaluate and\n\n```javascript\nThe is_application\n\tclause of\n```\n\n```javascript\neval_lazy_example\n      functions_4_1_1_lazy\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nconst my_program = parse(\"1; { true; 3; }\");\nevaluate(my_program, the_empty_environment);\n```",
    "token_count": 267,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": "An Interpreter with Lazy Evaluation",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_An_Interpreter_with_Lazy_Evaluation_1"
  },
  {
    "content": "The main difference between the lazy evaluator and the one in section is in the handling of function applications in evaluate and\n\n```javascript\neval_lazy\n      eval_lazy_example\n      3\n\n: is_application(component)\n? apply(actual_value(function_expression(component), env),\n        arg_expressions(component), env)\n\nfunction evaluate(component, env) {\n   return is_literal(component)\n          ? literal_value(component)\n          : is_name(component)\n          ? lookup_symbol_value(symbol_of_name(component), env)\n          : is_application(component)\n          ? apply(actual_value(function_expression(component), env),\n                  arg_expressions(component), env)\n          : is_operator_combination(component)\n          ? evaluate(operator_combination_to_application(component), env)\n          : is_conditional(component)\n          ? eval_conditional(component, env)\n          : is_lambda_expression(component)\n          ? make_function(lambda_parameter_symbols(component),\n                          lambda_body(component), env)\n          : is_sequence(component)\n          ? eval_sequence(sequence_statements(component), env)\n          : is_block(component)\n          ? eval_block(component, env)\n          : is_return_statement(component)\n          ? eval_return_statement(component, env)\n          : is_function_declaration(component)\n          ? evaluate(function_decl_to_constant_decl(component), env)\n          : is_declaration(component)\n          ? eval_declaration(component, env)\n          : is_assignment(component)\n          ? eval_assignment(component, env)\n          : error(component, \"unknown syntax -- evaluate\");\n}\n```\n\nThis is almost the same as the\nis_application\nclause of\nevaluate\nin section.\n\nFor lazy evaluation,\nhowever, we call\nargument\nexpressions, rather than the arguments produced by evaluating them.\n\nSince\nwe will need the environment to construct thunks if the arguments are to be\ndelayed, we must pass this as well.\n\nWe still evaluate the\nfunction expression,\nbecause\nfunction\nto be applied in order to dispatch on its type (primitive versus compound)\nand apply it.\n\nWhenever we need the actual value of an expression, we use\n\n```javascript\nactual_value_lazy_example\n      functions_4_1_1_lazy\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nactual_value(parse(\"1 + 2;\"), the_global_environment);\n```\n\n```javascript\nactual_value_lazy\n      actual_value_lazy_example\n      3\n\nfunction actual_value(exp, env) {\n  return force_it(evaluate(exp, env));\n}\n```\n\ninstead of just evaluate, so that if the expression s value is a thunk, it will be forced.\n\nOur new version of.\n\nThe difference is that\nevaluate\nhas passed in unevaluated\nargument\nexpressions: For primitive\nfunctions\n(which are strict), we evaluate all the arguments before applying the\nprimitive; for compound\nfunctions\n(which are non-strict) we delay all the\narguments before applying the\nfunction.\n\n```javascript\napply_lazy_example\n      functions_4_1_1_lazy\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nconst plus = list(\"primitive\", (x, y) => x + y);\napply(plus, list(list(\"literal\", 1), list(\"literal\", 2)), the_global_environment);\n```",
    "token_count": 303,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": "An Interpreter with Lazy Evaluation",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_An_Interpreter_with_Lazy_Evaluation_2"
  },
  {
    "content": "The difference is that\nevaluate\nhas passed in unevaluated\nargument\nexpressions: For primitive\nfunctions\n(which are strict), we evaluate all the arguments before applying the\nprimitive; for compound\nfunctions\n(which are non-strict) we delay all the\narguments before applying the\nfunction.\n\n```javascript\napply_lazy\n      list_of_arg_values\n      apply_lazy_example\n      3\n\nfunction apply(fun, args, env) {\n  if (is_primitive_function(fun)) {\n      return apply_primitive_function(\n                 fun,\n                 list_of_arg_values(args, env));              // changed\n  } else if (is_compound_function(fun)) {\n      const result = evaluate(\n                         function_body(fun),\n                         extend_environment(\n                             function_parameters(fun),\n                             list_of_delayed_args(args, env), // changed\n                         function_environment(fun)));\n      return is_return_value(result)\n             ? return_value_content(result)\n             : undefined;\n  } else {\n      error(fun, \"unknown function type -- apply\");\n  }\n}\n```\n\nThe functions that process the arguments are just like list_of_values from section , except that list_of_delayed_args delays the arguments instead of evaluating them, and list_of_arg_values\n\nuses actual_value instead of evaluate:\n\n```javascript\nlist_of_arg_values\n\nfunction list_of_arg_values(exps, env) {\n  return map(exp => actual_value(exp, env), exps);\n}\nfunction list_of_delayed_args(exps, env) {\n  return map(exp => delay_it(exp, env), exps);\n}\n```\n\nThe other place we must change the evaluator is in the handling of conditionals, where we must use actual_value instead of to get the value\n\nof the predicate expression before testing whether it is true or false:\n\n```javascript\neval_if_lazy_example\n      functions_4_1_1_lazy\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nconst my_cond_expr = parse(\"true ? 1 : 2;\");\neval_conditional(my_cond_expr, the_empty_environment);\n```\n\n```javascript\neval_if_lazy\n      eval_if_lazy_example\n      1\n\nfunction eval_conditional(component, env) {\n  return is_truthy(actual_value(conditional_predicate(component), env))\n         ? evaluate(conditional_consequent(component), env)\n         : evaluate(conditional_alternative(component), env);\n}\n```\n\nFinally, we must change the\ndriver_loop\nfunction\n(from section ) to use\nactual_@value\ninstead of\nso that if a delayed value is propagated back to the\nread-evaluate-print loop,\nit will be forced before being printed.\n\nWe also change the prompts to indicate that\nthis is the lazy evaluator:",
    "token_count": 272,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": "An Interpreter with Lazy Evaluation",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_An_Interpreter_with_Lazy_Evaluation_3"
  },
  {
    "content": "We also change the prompts to indicate that\nthis is the lazy evaluator:\n\n```javascript\ndriver_loop_lazy\n      functions_4_1_1_lazy\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n      user_print\n      user_read\n      driver_loop_lazy_example\n\nconst input_prompt = \"L-evaluate input: \";\nconst output_prompt = \"L-evaluate value: \";\n\nfunction driver_loop(env) {\n  const input = user_read(input_prompt);\n  if (is_null(input)) {\n      display(\"evaluator terminated\");\n  } else {\n      const program = parse(input);\n      const locals = scan_out_declarations(program);\n      const unassigneds = list_of_unassigned(locals);\n      const program_env = extend_environment(locals, unassigneds, env);\n      const output = actual_value(program, program_env);\n      user_print(output_prompt, output);\n      return driver_loop(program_env);\n  }\n}\n\nconst input_prompt = \"L-evaluate input: \";\nconst output_prompt = \"L-evaluate value: \";\n\nfunction driver_loop(env) {\n    const input = user_read(input_prompt);\n    if (is_null(input)) {\n        display(\"--- evaluator terminated ---\", \"\");\n    } else {\n        display(\"----------------------------\",\n                input_prompt + \"\\n\" + input + \"\\n\");\n        const program = parse(input);\n        const locals = scan_out_declarations(program);\n        const unassigneds = list_of_unassigned(locals);\n        const program_env = extend_environment(locals, unassigneds, env);\n        const output = actual_value(program, program_env);\n        user_print(output_prompt, output);\n        return driver_loop(program_env);\n    }\n}\n```\n\nWith these changes made, we can start the evaluator and test it.\n\nThe\nsuccessful evaluation of the\ntry_me\nexpression\ndiscussed in section indicates\nthat the interpreter is performing lazy evaluation:\n\n```javascript\ndriver_loop_lazy_example\n      driver_loop_lazy\n\nconst the_global_environment = setup_environment();\ndriver_loop(the_global_environment);\n\ndriver_loop(the_global_environment);\n\n// L-evaluate input:\n// function try_me(a, b) { return a === 0 ? 1 : b; }\n// L-evaluate value:\n// undefined\n\n// L-evaluate input:\n// try_me(0, head(null));\n// L-evaluate value:\n// 1\n```\n\n```javascript\nL-evaluate input:\n\nfunction try_me(a, b) {\n  return a === 0 ? 1 : b;\n}\n```\n\n```javascript\nL-evaluate input:\n\n      try_me(0, head(null));\n```\n\nOur evaluator must arrange to create thunks when\nfunctions\nare applied to arguments and to force these thunks later.\n\nA thunk must\npackage an expression together with the environment, so that the argument\ncan be produced later.\n\nTo force the thunk, we simply extract the expression\nand environment from the thunk and evaluate the expression in the\nenvironment.",
    "token_count": 300,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": "An Interpreter with Lazy Evaluation",
    "chunk_index": 4,
    "chunk_id": "Metalinguistic_Abstraction_An_Interpreter_with_Lazy_Evaluation_4"
  },
  {
    "content": "To force the thunk, we simply extract the expression\nand environment from the thunk and evaluate the expression in the\nenvironment.\n\nWe use\nactual_value\nrather than\nso that in case the value of the expression is itself a thunk, we will force\nthat, and so on, until we reach something that is not a thunk:\n\n```javascript\nforce_it_lazy_v1\n\nfunction force_it(obj) {\n    return is_thunk(obj)\n           ? actual_value(thunk_exp(obj), thunk_env(obj))\n           : obj;\n}\n```\n\nOne easy way to package an expression with an environment is to make a list\ncontaining the expression and the environment.\n\nThus, we create a thunk as\nfollows:\n\n```javascript\ndelay_it_lazy\n      eval_lazy_example\n\nfunction delay_it(exp, env) {\n    return list(\"thunk\", exp, env);\n}\nfunction is_thunk(obj) {\n    return is_tagged_list(obj, \"thunk\");\n}\nfunction thunk_exp(thunk) { return head(tail(thunk)); }\n\nfunction thunk_env(thunk) { return head(tail(tail(thunk))); }\n```\n\nActually, what we want for our interpreter is not quite this, but\nrather thunks that have been memoized.\n\nWhen a thunk is forced, we will turn it into an evaluated thunk by replacing\nthe stored expression with its value and changing the\n\n```javascript\nforce_it_lazy\n      eval_lazy_example\n\nfunction is_evaluated_thunk(obj) {\n    return is_tagged_list(obj, \"evaluated_thunk\");\n}\nfunction thunk_value(evaluated_thunk) {\n    return head(tail(evaluated_thunk));\n}\n\nfunction force_it(obj) {\n    if (is_thunk(obj)) {\n        const result = actual_value(thunk_exp(obj), thunk_env(obj));\n        set_head(obj, \"evaluated_thunk\");\n        set_head(tail(obj), result);  // replace exp with its value\n        set_tail(tail(obj), null);    // forget unneeded env\n        return result;\n    } else if (is_evaluated_thunk(obj)) {\n        return thunk_value(obj);\n    } else {\n        return obj;\n    }\n}\n```\n\nNotice that the same delay_it function works both with and without memoization.",
    "token_count": 243,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": "An Interpreter with Lazy Evaluation",
    "chunk_index": 5,
    "chunk_id": "Metalinguistic_Abstraction_An_Interpreter_with_Lazy_Evaluation_5"
  },
  {
    "content": "In section , where we began\nour discussion of models of evaluation, we noted that\nJavaScript\nis an applicative-order language, namely, that all the arguments to\nJavaScript\nfunctions\nare evaluated when the\nfunction\nis applied.\n\nIn contrast, normal-order languages delay evaluation of\nfunction\narguments until the actual argument values are needed.\n\nDelaying evaluation of\nfunction\narguments until the last possible moment (e.g., until they are required by a\nprimitive operation) is called\nlazy evaluation.\nfunction\n\n```javascript\ntry_me_example\n\ntry_me(0, head(null));\n```\n\n```javascript\ntry_me\n      try_me_example\n      1\n\nfunction try_me(a, b) {\n    return a === 0 ? 1 : b;\n}\n\n// Source Academy opens this program\n// in lazy mode. Choose \"Source 2\" to\n// to compare with strict mode\nfunction try_me(a, b) {\n    return a === 0 ? 1 : b;\n}\n```\n\nEvaluating\n\n```javascript\ntry_me(0, head(null));\n\tsignals\n```\n\nan error in\nJavaScript.\n\nWith lazy evaluation, there would be no error.\n\nEvaluating the\nstatement\nwould return 1, because the argument\nhead(null)\nwould never be evaluated.\n\nAn example that exploits lazy evaluation is the declaration of a function\n\n```javascript\nunless\n      unless_example\n\nfunction unless(condition, usual_value, exceptional_value) {\n    return condition ? exceptional_value : usual_value;\n}\n\n// Source Academy opens this program\n// in lazy mode. Choose \"Source 2\" to\n// to compare with strict mode\nfunction unless(condition, usual_value, exceptional_value) {\n    return condition ? exceptional_value : usual_value;\n}\n```\n\nthat can be used in statements such as\n\n```javascript\nxs_is_null\n\nconst xs = null;\n```\n\n```javascript\nunless_example\n      unless\n      xs_is_null\n\nunless(is_null(xs), head(xs), display(\"error: xs should not be null\"));\n```\n\nThis won t work in an applicative-order language because both the\nusual value and the exceptional value will be evaluated before\n).\n\nAn advantage of lazy evaluation is\nthat some\nfunctions,\nsuch as\n\nIf the body of a\nfunction\nis entered before an argument has been evaluated we say that the\nfunction\nis\nnon-strict in that argument.",
    "token_count": 308,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": "Normal Order and Applicative Order",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Normal_Order_and_Applicative_Order_1"
  },
  {
    "content": "If the body of a\nfunction\nis entered before an argument has been evaluated we say that the\nfunction\nis\nnon-strict in that argument.\n\nIf the argument is evaluated before\nthe body of the\nfunction\nis entered we say that the\nfunction\nis\nstrict in that\nargument.\nfunctions\nare strict in each argument.\n\nIn a purely normal-order language, all compound\nfunctions\nare non-strict in each argument, and primitive\nfunctions\nmay be either strict or non-strict.\n\nThere are also languages (see\nexercise ) that give\nprogrammers detailed control over the strictness of the\nfunctions\nthey define.\n\nA striking example of a\nfunction\nthat can usefully be made non-strict is\npair\n(or, in general, almost any constructor for data structures).\n\nOne can do useful computation, combining elements to form\ndata structures and operating on the resulting data structures,\neven if the values of the elements are not known.\n\nIt makes perfect\nsense, for instance, to compute the length of a list without knowing\nthe values of the individual elements in the list.\n\nWe will exploit\nthis idea in section to implement the\nstreams of chapter as lists formed of non-strict\npairs.",
    "token_count": 189,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": "Normal Order and Applicative Order",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Normal_Order_and_Applicative_Order_2"
  },
  {
    "content": "In section , we showed how to\nimplement streams as delayed lists.\n\nWe used a\nto construct a\npromise to compute the\ntail\nof a stream, without actually fulfilling that promise until later.\n\n```javascript\nWe were forced to create streams as a new kind of data object similar\n\tbut not identical to lists, and this required us to reimplement many\n\tordinary list operations (\n```\n\nWith lazy evaluation, streams and lists can be identical, so there is\nno need for\nseparate list and stream operations.\n\nAll we need to do is to arrange matters\nso that\npair\nis non-strict.\n\nOne way to accomplish this is to extend the lazy evaluator\nto allow for non-strict primitives, and to implement\npair\nas one of these.\n\nAn easier way is to recall\n(section ) that there is no fundamental need\nto implement\npair\nas a primitive at all.\n\nInstead, we can represent\nfunctions :\n\n```javascript\npair_lazy_header\n\nconst my_pair_lazy = `\n```\n\n```javascript\npair_lazy_footer\n\nhead(tail(pair(1, pair(3, 2))));\n`;\n```\n\n```javascript\npair_lazy_example\n      parse_and_evaluate_lazy\n      pair_lazy_header\n      pair_lazy\n      pair_lazy_footer\n      3\n\nparse_and_evaluate(my_pair_lazy);\n```\n\n```javascript\npair_lazy\n\nfunction pair(x, y) {\n    return m => m(x, y);\n}\nfunction head(z) {\n    return z((p, q) => p);\n}\nfunction tail(z) {\n    return z((p, q) => q);\n}\n```\n\nIn terms of these basic operations, the standard definitions of the list\noperations will work with infinite lists (streams) as well as finite ones,\nand the stream operations can be implemented as list operations.\n\nHere are\nsome examples:\n\n```javascript\nlist_lib_test_header\n\nconst my_list_lib_test = `\n```\n\n```javascript\nlist_lib_test_footer\n\nlist_ref(integers, 17);\n`;\n```\n\n```javascript\nlist_lib_test\n      parse_and_evaluate_lazy\n      list_lib_test_header\n      pair_lazy\n      list_library_lazy\n      list_lib_test_header\n      list_lib_test_footer\n      18\n\nparse_and_evaluate(my_list_lib_test);\n```",
    "token_count": 267,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": "Streams as Lazy Lists",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Streams_as_Lazy_Lists_1"
  },
  {
    "content": "Here are\nsome examples:\n\n```javascript\nlist_library_lazy\n\nfunction list_ref(items, n) {\n    return n === 0\n           ? head(items)\n           : list_ref(tail(items), n - 1);\n}\nfunction map(fun, items) {\n    return is_null(items)\n           ? null\n           : pair(fun(head(items)),\n                  map(fun, tail(items)));\n}\nfunction scale_list(items, factor) {\n    return map(x => x * factor, items);\n}\nfunction add_lists(list1, list2) {\n    return is_null(list1)\n           ? list2\n           : is_null(list2)\n           ? list1\n           : pair(head(list1) + head(list2),\n                  add_lists(tail(list1), tail(list2)));\n}\nconst ones = pair(1, ones);\nconst integers = pair(1, add_lists(ones, integers));\n```\n\n```javascript\nL-evaluate input:\n\nlist_ref(integers, 17);\n```\n\nNote that these lazy lists are even lazier than the streams of\nchapter : The\nhead\nof the list, as well as the\ntail,\nis delayed.\nhead\nor\ntail\nof a lazy pair need not force the value of a list element.\n\nThe value will be\nforced only when it is really needed e.g., for use as the argument\nof a primitive, or to be printed as an answer.\n\nLazy pairs also help with the problem that arose with streams in\nsection , where we\nfound that formulating stream models of systems with loops may require us to\nsprinkle our programs with\nadditional lambda expressions for\nWith lazy evaluation, all arguments to\nfunctions\nare delayed uniformly.\n\nFor instance, we can implement\nfunctions\nto integrate lists and solve differential equations as we originally\nintended in section :\n\n```javascript\nlazy_integral_header\n\nconst my_integral = `\n```\n\n```javascript\nlazy_integral_footer\n\nlist_ref(solve(x => x, 1, 0.1), 10);\n`;\n```\n\n```javascript\nlazy_integral_test\n      parse_and_evaluate_lazy\n      lazy_integral_header\n      pair_lazy\n      list_library_lazy\n      lazy_integral\n      lazy_integral_footer\n      2.5937424601\n\nparse_and_evaluate(my_integral);\n```\n\n```javascript\nlazy_integral\n\nfunction integral(integrand, initial_value, dt) {\n    const int = pair(initial_value,\n                     add_lists(scale_list(integrand, dt),\n                               int));\n    return int;\n}\nfunction solve(f, y0, dt) {\n    const y = integral(dy, y0, dt);\n    const dy = map(f, y);\n    return y;\n}\n```\n\n```javascript\nL-evaluate input:\n\nlist_ref(solve(x => x, 1, 0.001), 1000);\n```",
    "token_count": 295,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Lazy Evaluation",
    "subsection": "Streams as Lazy Lists",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Streams_as_Lazy_Lists_2"
  },
  {
    "content": "In chapter we stressed that computer science deals with\n\nMost programming languages, including\nJavaScript,\nare organized around\ncomputing the values of mathematical functions.\n\nExpression-oriented\nlanguages\n(such as , C, Python, and JavaScript)\ncapitalize on the\npun that an expression that describes the value of a\nfunction may also be interpreted as a means of computing that value.\n\nBecause of this, most programming languages are strongly biased toward\nunidirectional computations (computations with well-defined inputs and\noutputs).\n\nThere are, however, radically different programming languages\nthat relax this bias.\n\nWe saw one such example in\nsection , where the objects of\ncomputation were arithmetic constraints.\n\nIn a constraint system the\ndirection and the order of computation are not so well specified; in\ncarrying out a computation the system must therefore provide more detailed\nhow to knowledge than would be the case with an ordinary\narithmetic computation.\n\nThis does not mean, however, that the user is\nreleased altogether from the responsibility of providing imperative\nknowledge.\n\nThere are many constraint networks that implement the same set\nof constraints, and the user must choose from the set of mathematically\nequivalent networks a suitable network to specify a particular computation.\n\nThe nondeterministic program evaluator of\nsection also moves\naway from the view that programming is about constructing algorithms for\ncomputing unidirectional functions.\n\nIn a nondeterministic language,\nexpressions can have more than one value, and, as a result, the\ncomputation is\ndealing with\nunification.\n\nThis approach, when it works, can be a very\nwhat is\nfact can be used to solve a number of different problems that would have\ndifferent how to components.\n\nAs an example, consider the\nJavaScript,\nwe could define\npair,\nas we did in section :\n\n```javascript\nfunction append(x, y) {\n    return is_null(x)\n           ? y\n           : pair(head(x), append(tail(x), y));\n}\n```",
    "token_count": 296,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Logic Programming",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Logic_Programming_1"
  },
  {
    "content": "As an example, consider the\nJavaScript,\nwe could define\npair,\nas we did in section :\n\nThis\nfunction\ncan be regarded as a translation into\nJavaScript\nof the following two rules, the first of which covers the case where the\nfirst list is empty and the second of which handles the case of a nonempty\nlist, which is a\npair\nof two parts:\n-\n-\nFor any list\n-\n-\nFor any\npair(u, v)\nand\npair(u, z)\nif\nUsing the\nfunction,\nwe can answer questions such as\nFind the\nlist(\"a\", \"b\")\nand\nlist(\"c\", \"d\").\n\nBut the same two rules are also sufficient for answering the following\nsorts of questions, which the\nfunction\ncan t answer:\nFind a list\nlist(\"a\", \"b\")\nto produce\nlist(\"a\", \"b\", \"c\", \"d\").\n\nFind all\nlist(\"a\", \"b\", \"c\", \"d\").\n\nIn a\nfunction\nby stating the two rules about How to knowledge is provided automatically by the\ninterpreter to allow this single pair of rules to be used to answer all\nthree types of questions about\n\nContemporary logic programming languages (including the one we\nimplement here) have substantial deficiencies, in that their general\nhow to methods can lead them into spurious infinite loops or\nother undesirable behavior.\n\nLogic programming is an active field of research\nin computer science.\n\nEarlier in this chapter we explored the technology of implementing\ninterpreters and described the elements that are essential to an\ninterpreter for a\nJavaScript-like\nlanguage (indeed, to an interpreter for any conventional language).\n\nNow we\nwill apply these ideas to discuss an interpreter for a logic programming\nlanguage.\n\nWe call this\nlanguage the\nquery language , because it is very useful for\nretrieving information from data bases by formulating\nqueries , or questions, expressed in the language.",
    "token_count": 287,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": "Logic Programming",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Logic_Programming_2"
  },
  {
    "content": "We call this\nlanguage the\nquery language , because it is very useful for\nretrieving information from data bases by formulating\nqueries , or questions, expressed in the language.\n\nEven though the\nquery language is very different from\nJavaScript,\nwe will find it convenient to describe the language in terms of the same\ngeneral framework we have been using all along: as a collection of primitive\nelements, together with means of combination that enable us to combine\nsimple elements to create more complex elements and means of abstraction\nthat enable us to regard complex elements as single conceptual units.\n\nAn\ninterpreter for a logic programming language is considerably more complex\nthan an interpreter for a language like\nJavaScript.\n\nNevertheless, we will see\nthat our.\n\nIn\nparticular, there will be an evaluate part that classifies\nexpressions according to type and an apply part that\nimplements the language s abstraction mechanism\n(functions\nin the case of\nJavaScript,\nand rules in the case of logic programming).\n\nAlso, a central role\nis played in the implementation by a frame data structure, which determines\nthe correspondence between symbols and their associated values.\n\nOne\nadditional interesting aspect of our query-language implementation is\nthat we make substantial use of streams, which were introduced in\nchapter.",
    "token_count": 208,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": "Logic Programming",
    "subsection": null,
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Logic_Programming_3"
  },
  {
    "content": "In this section, we extend the JavaScript evaluator to support a programming paradigm called nondeterministic computing by building into the evaluator a facility to support\n\n.\n\nNondeterministic computing, like stream processing, is useful for\ngenerate and test applications.\n\nConsider the task of\nstarting with two lists of positive integers and finding a pair of\nintegers one from the first list and one from the second\nlist whose sum is prime.\n\nWe saw how to handle this with finite\nsequence operations in section and\nwith infinite streams in section.\n\nOur approach was to generate the sequence of all possible pairs and filter\nthese to select the pairs whose sum is prime.\n\nWhether we actually generate\nthe entire sequence of pairs first as in chapter , or interleave the\ngenerating and filtering as in chapter , is immaterial to the\nessential image of how the computation is organized.\n\nThe nondeterministic approach evokes a different image.\n\nImagine simply\nthat we choose (in some way) a number from the first list and a number\nfrom the second list and require (using some mechanism) that their\nfunction:\n\n```javascript\nprime_sum_pair_non_det\n      prime_sum_pair_non_det_example\n      [ 3, [ 20, null ] ]\n\nfunction prime_sum_pair(list1, list2) {\n    const a = an_element_of(list1);\n    const b = an_element_of(list2);\n    require(is_prime(a + b));\n    return list(a, b);\n}\n```\n\nIt might seem as if this\nfunction\nmerely restates the problem,\nrather than specifying a way to solve it.\n\nNevertheless, this is a\nlegitimate nondeterministic program.\n\nThe key idea here is that\ncomponents\nin a nondeterministic language\ncan have more than one possible value.\n\nFor instance,\nan_element_of\nmight return any element of the given list.\n\nOur nondeterministic program\nevaluator will work by automatically choosing a possible value and keeping\ntrack of the choice.",
    "token_count": 285,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Nondeterministic_Computing_1"
  },
  {
    "content": "Our nondeterministic program\nevaluator will work by automatically choosing a possible value and keeping\ntrack of the choice.\n\nIf a subsequent requirement is not met, the evaluator\nwill try a different choice, and it will keep trying new choices until the\nevaluation succeeds, or until we run out of choices.\n\nJust as the lazy\nevaluator freed the programmer from the details of how values are delayed\nand forced, the nondeterministic program evaluator will free the programmer\nfrom the details of how choices are made.\n\nIt is instructive to contrast the different images of\na component\nrepresents the exploration\nof a set of possible worlds, each determined by a set of choices.\n\nSome of the possible worlds lead to dead ends, while others have\nuseful values.\n\nThe nondeterministic program evaluator supports the\nillusion that time branches, and that our programs have different\npossible execution histories.\n\nWhen we reach a dead end, we can\nrevisit a previous choice point and proceed along a different branch.\n\nThe nondeterministic program evaluator implemented below is called the a new syntactic form called declaration of prime_sum_pair at the declarations of is_prime, an_element_of, and function\n\nas follows:\n\n```javascript\nprime_sum_pair_non_det_example\n      is_prime2\n      prime_sum_pair_non_det\n\namb-evaluate input:\n\nprime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));\n\nprime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```\n\nThe value returned was obtained after the evaluator repeatedly chose elements from each of the lists, until a successful choice was made.\n\nSection introduces\ns automatic search mechanism.\n\nSection presents examples of\nnondeterministic programs, and\nsection gives the details of how\nto implement the\nJavaScript\nevaluator.",
    "token_count": 277,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Nondeterministic_Computing_2"
  },
  {
    "content": "Section describes the implementation of the\n\nThe following puzzle (adapted from The software company\n\nWe can determine who moves into which office in a straightforward way by enumerating all the possibilities and imposing the given restrictions:\n\n```javascript\noffice_move\n      distinct\n      office_move_example\n      [ 'alyssa', [ 3, null ] ]\n\nfunction office_move() {\n    const alyssa = amb(1, 2, 3, 4, 5);\n    const ben = amb(1, 2, 3, 4, 5);\n    const cy = amb(1, 2, 3, 4, 5);\n    const lem = amb(1, 2, 3, 4, 5);\n    const louis = amb(1, 2, 3, 4, 5);\n    require(distinct(list(alyssa, ben, cy, lem, louis)));\n    require(alyssa !== 5);\n    require(ben !== 1);\n    require(cy !== 5);\n    require(cy !== 1);\n    require(lem > ben);\n    require(math_abs(louis - cy) !== 1);\n    require(math_abs(cy - ben) !== 1);\n    return list(list(\"alyssa\", alyssa),\n                list(\"ben\", ben),\n                list(\"cy\", cy),\n                list(\"lem\", lem),\n                list(\"louis\", louis));\n}\n```\n\n```javascript\noffice_move_example\n\noffice_move();\n\nhead(office_move());\n```\n\nEvaluating the expression office_move() produces the result\n\n```javascript\nlist(list(\"alyssa\", 3), list(\"ben\", 2), list(\"cy\", 4),\n     list(\"lem\", 5), list(\"louis\", 1))\n```\n\nAlthough this simple\nfunction\nworks, it is very slow.\n\nExercises\nand discuss some possible\nimprovements.\n\nPrograms designed to accept natural language as input usually start by\nattempting to parse the input, that is, to match the input\nagainst some grammatical structure.\n\nFor example, we might try to\nrecognize simple sentences consisting of an article followed by a noun\nfollowed by a verb, such as The cat eats.\n\nTo accomplish\nsuch an analysis, we must be able to identify the parts of speech of\nindividual words.\n\nWe could start with some lists that classify various\nwords:\n\n```javascript\nnouns\n\nconst nouns = list(\"noun\", \"student\", \"professor\", \"cat\", \"class\");\n\nconst verbs = list(\"verb\", \"studies\", \"lectures\", \"eats\", \"sleeps\");\n\nconst articles = list(\"article\", \"the\", \"a\");\n```\n\nWe also need a\ngrammar , that is, a set of rules describing how\ngrammatical elements are composed from simpler elements.",
    "token_count": 298,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Examples of Nondeterministic Programs",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Examples_of_Nondeterministic_Programs_1"
  },
  {
    "content": "We also need a\ngrammar , that is, a set of rules describing how\ngrammatical elements are composed from simpler elements.\n\nA very\nsimple grammar might stipulate that a sentence always consists of two\npieces a noun phrase followed by a verb and that a noun\nphrase consists of an article followed by a noun.\n\nWith this grammar, the\nsentence The cat eats is parsed as follows:\n\n```javascript\nlist(\"sentence\",\n     list(\"noun-phrase\", list(\"article\", \"the\"), list(\"noun\", \"cat\"),\n     list(\"verb\", \"eats\"))\n```\n\nWe can generate such a parse with a simple program that has separate\nfunctions\nfor each of the grammatical rules.\n\nTo parse a sentence, we identify its\ntwo constituent pieces and return a list of these two elements, tagged with\nthe symbol\n\n```javascript\nparse_sentence\n      parse_noun_phrase\n      nouns\n      parse_input_example\n      [ \"sentence\", [ [\"noun-phrase\", [[\"article\", [\"the\", null]], [[\"noun\", [\"cat\", null]], null]]], [[\"verb\", [\"eats\", null]], null]]]\n\nfunction parse_sentence() {\n    return list(\"sentence\",\n                parse_noun_phrase(),\n                parse_word(verbs));\n}\n```\n\nA noun phrase, similarly, is parsed by finding an article followed by a noun:\n\n```javascript\nparse_noun_phrase\n      nouns\n      parse_word\n      parse_input_example\n\nfunction parse_noun_phrase() {\n    return list(\"noun-phrase\",\n                parse_word(articles),\n                parse_word(nouns));\n}\n```\n\nAt the lowest level, parsing boils down to repeatedly checking that\nthe next\nnot-yet-parsed\nword is a member of the list of words for the\nrequired part of speech.\n\nTo implement this, we maintain a global\nvariable\nnot_yet_parsed,\nwhich is the input that has not yet been parsed.\n\nEach time we check a word,\nwe require that\nnot_yet_parsed\nmust be nonempty and that it should begin with a word from the designated\nlist.\n\nIf so, we remove that word from\nnot_yet_parsed\nand return the word together with its part of speech (which is found at\nthe head of the list):\n\n```javascript\nparse_word\n      unparsed\n      parse_input_example\n\nfunction parse_word(word_list) {\n    require(! is_null(not_yet_parsed));\n    require(! is_null(member(head(not_yet_parsed), tail(word_list))));\n    const found_word = head(not_yet_parsed);\n    not_yet_parsed = tail(not_yet_parsed);\n    return list(head(word_list), found_word);\n}\n```",
    "token_count": 300,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Examples of Nondeterministic Programs",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Examples_of_Nondeterministic_Programs_2"
  },
  {
    "content": "If so, we remove that word from\nnot_yet_parsed\nand return the word together with its part of speech (which is found at\nthe head of the list):\n\nTo start the parsing, all we need to do is set not_yet_parsed to be the entire input, try to parse a sentence, and check that\n\nnothing is left over:\n\n```javascript\nunparsed\n\nlet not_yet_parsed = null;\n```\n\n```javascript\nparse_input\n      unparsed\n      parse_sentence\n      parse_input_example\n\nfunction parse_input(input) {\n    not_yet_parsed = input;\n    const sent = parse_sentence();\n    require(is_null(not_yet_parsed));\n    return sent;\n}\n```\n\nWe can now try the parser and verify that it works for our simple test sentence:\n\n```javascript\nparse_input_example\n      parse_input\n\namb-evaluate input:\n\nparse_input(list(\"the\",  \"cat\",  \"eats\"));\n\nparse_input(list(\"the\",  \"cat\",  \"eats\"));\n```\n\nThe\n\nLet s add to our grammar a list of prepositions:\n\n```javascript\nprepositions\n\nconst prepositions = list(\"prep\", \"for\", \"to\", \"in\", \"by\", \"with\");\n```\n\nand define a prepositional phrase (e.g., for the cat ) to be a preposition followed by a noun phrase:\n\n```javascript\nparse_prepositional_phrase\n      parse_word\n      prepositions\n      parse_input_example_2\n      [ \"sentence\", [ [ \"noun-phrase\", [ [ \"simple-noun-phrase\", [[\"article\", [\"the\", null]], [[\"noun\", [\"student\", null]], null]]], [ [ \"prep-phrase\", [ [\"prep\", [\"with\", null]], [ [ \"simple-noun-phrase\", [[\"article\", [\"the\", null]], [[\"noun\", [\"cat\", null]], null]]], null]]], null]]], [ [ \"verb-phrase\", [ [\"verb\", [\"sleeps\", null]], [ [ \"prep-phrase\", [ [\"prep\", [\"in\", null]], [ [ \"simple-noun-phrase\", [[\"article\", [\"the\", null]], [[\"noun\", [\"class\", null]], null]]], null]]], null]]], null]]]\n\nfunction parse_prepositional_phrase() {\n    return list(\"prep-phrase\",\n                parse_word(prepositions),\n                parse_noun_phrase());\n}\n```\n\nNow we can define a sentence to be a noun phrase followed by a verb phrase, where a verb phrase can be either a verb\n\nor a verb phrase extended by a prepositional phrase:\n\n```javascript\nparse_sentence_2\n      parse_prepositional_phrase\n      parse_word\n      parse_noun_phrase_2\n      parse_input_example_2\n\nfunction parse_sentence() {\n    return list(\"sentence\",\n                parse_noun_phrase(),\n                parse_verb_phrase());\n}\nfunction parse_verb_phrase() {\n    function maybe_extend(verb_phrase) {\n        return amb(verb_phrase,\n                   maybe_extend(list(\"verb-phrase\",\n                                     verb_phrase,\n                                     parse_prepositional_phrase())));\n    }\n    return maybe_extend(parse_word(verbs));\n}\n```\n\n```javascript\nparse_input_2\n      unparsed\n      parse_sentence_2\n\nfunction parse_input(input) {\n    not_yet_parsed = input;\n    const sent = parse_sentence();\n    require(is_null(not_yet_parsed));\n    return sent;\n}\n```",
    "token_count": 311,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Examples of Nondeterministic Programs",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Examples_of_Nondeterministic_Programs_3"
  },
  {
    "content": "or a verb phrase extended by a prepositional phrase:\n\nWhile we re at it, we can also elaborate the definition of noun\nphrases to permit such things as a cat in the class.\n\nWhat\nwe used to call a noun phrase, we ll now call a simple noun phrase,\nand a noun phrase will now be either a simple noun phrase or a noun phrase\nextended by a prepositional phrase:\n\n```javascript\nparse_noun_phrase_2\n      parse_prepositional_phrase\n      parse_word\n      nouns\n      parse_input_example_2\n\nfunction parse_simple_noun_phrase() {\n    return list(\"simple-noun-phrase\",\n                parse_word(articles),\n                parse_word(nouns));\n}\nfunction parse_noun_phrase() {\n    function maybe_extend(noun_phrase) {\n        return amb(noun_phrase,\n                   maybe_extend(list(\"noun-phrase\",\n                                     noun_phrase,\n                                     parse_prepositional_phrase())));\n    }\n    return maybe_extend(parse_simple_noun_phrase());\n}\n```\n\nOur new grammar lets us parse more complex sentences.\n\nFor example\n\n```javascript\nparse_input_example_2\n      parse_input_2\n\nparse_input(list(\"the\", \"student\", \"with\", \"the\", \"cat\",\n                 \"sleeps\", \"in\", \"the\", \"class\"));\n```\n\nproduces\n\n```javascript\nlist(\"sentence\",\n     list(\"noun-phrase\",\n          list(\"simple-noun-phrase\",\n               list(\"article\", \"the\"), list(\"noun\", \"student\")),\n          list(\"prep-phrase\", list(\"prep\", \"with\"),\n               list(\"simple-noun-phrase\",\n                    list(\"article\", \"the\"),\n                    list(\"noun\", \"cat\")))),\n     list(\"verb-phrase\",\n          list(\"verb\", \"sleeps\"),\n          list(\"prep-phrase\", list(\"prep\", \"in\"),\n               list(\"simple-noun-phrase\",\n                    list(\"article\", \"the\"),\n                    list(\"noun\", \"class\")))))\n```\n\nObserve that a given input may have more than one legal parse.\n\nIn the\nsentence The professor lectures to the student with the cat,\nit may be that the professor is lecturing with the cat, or that the student\nhas the cat.\n\nOur nondeterministic program finds both possibilities:\n\n```javascript\nmultiple_legal_parses\n      parse_input_2\n\nparse_input(list(\"the\", \"professor\", \"lectures\",\n                 \"to\", \"the\", \"student\", \"with\", \"the\", \"cat\"));\n```\n\nproduces\n\n```javascript\nlist(\"sentence\",\n     list(\"simple-noun-phrase\",\n          list(\"article\", \"the\"), list(\"noun\", \"professor\")),\n     list(\"verb-phrase\",\n          list(\"verb-phrase\",\n               list(\"verb\", \"lectures\"),\n               list(\"prep-phrase\", list(\"prep\", \"to\"),\n                    list(\"simple-noun-phrase\",\n                    list(\"article\", \"the\"),\n\t\t    list(\"noun\", \"student\")))),\n          list(\"prep-phrase\", list(\"prep\", \"with\"),\n               list(\"simple-noun-phrase\",\n                    list(\"article\", \"the\"),\n                    list(\"noun\", \"cat\")))))\n```\n\nAsking the evaluator to retry yields\n\n```javascript\nlist(\"sentence\",\n     list(\"simple-noun-phrase\",\n          list(\"article\", \"the\"), list(\"noun\", \"professor\")),\n     list(\"verb-phrase\",\n          list(\"verb\", \"lectures\"),\n          list(\"prep-phrase\", list(\"prep\", \"to\"),\n               list(\"noun-phrase\",\n                    list(\"simple-noun-phrase\",\n                         list(\"article\", \"the\"),\n                         list(\"noun\", \"student\")),\n                    list(\"prep-phrase\", list(\"prep\", \"with\"),\n                         list(\"simple-noun-phrase\",\n                              list(\"article\", \"the\"),\n                              list(\"noun\", \"cat\")))))))\n```",
    "token_count": 277,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Examples of Nondeterministic Programs",
    "chunk_index": 4,
    "chunk_id": "Metalinguistic_Abstraction_Examples_of_Nondeterministic_Programs_4"
  },
  {
    "content": "The evaluation of an ordinary\nJavaScript program\nmay return a value, may never terminate, or may signal an error.\n\nIn nondeterministic\nJavaScript\nthe evaluation of\na program\nmay in addition result in the discovery of\na dead end, in which case evaluation must backtrack to a previous choice\npoint.\n\nThe interpretation of nondeterministic\nJavaScript\nis complicated by this extra case.\n\nWe will construct the\nJavaScript\nby modifying the.\na component\nis accomplished by calling an\nfunction\nproduced by analysis of that\ncomponent.\n\nThe difference between the interpretation of ordinary\nJavaScript\nand the interpretation of nondeterministic\nJavaScript\nwill be entirely\nin the execution\nfunctions.\n\nRecall that the\nfunctions\nfor the ordinary evaluator take one argument: the environment of execution.\n\nIn contrast, the execution\nfunctions\nin the\nfunctions\ncalled\ncontinuation functions.\n\nThe evaluation of\na component\nwill finish by calling one of these two\ncontinuations: If the evaluation results in a value, the\nsuccess continuation is called with that value; if the evaluation\nresults in the discovery of a dead end, the\nfailure continuation is called.\n\nConstructing and calling\nappropriate continuations is the mechanism by which the nondeterministic\nevaluator implements backtracking.\n\nIt is the job of the success continuation to receive a value and proceed\nwith the computation.\n\nAlong with that value, the success continuation is\npassed another failure continuation, which is to be called subsequently if\nthe use of that value leads to a dead end.\n\nIt is the job of the failure continuation to try another branch of the\nnondeterministic process.\n\nThe essence of the nondeterministic\nlanguage is in the fact that\ncomponents\nmay represent choices among\nalternatives.\n\nThe evaluation of such\na component\nmust proceed with\none of the indicated alternative choices, even though it is not known\nin advance which choices will lead to acceptable results.",
    "token_count": 298,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_1"
  },
  {
    "content": "The evaluation of such\na component\nmust proceed with\none of the indicated alternative choices, even though it is not known\nin advance which choices will lead to acceptable results.\n\nTo deal\nwith this, the evaluator picks one of the alternatives and passes this\nvalue to the success continuation.\n\nTogether with this value, the\nevaluator constructs and passes along a failure continuation that can\nbe called later to choose a different alternative.\n\nA failure is triggered during evaluation (that is, a failure\ncontinuation is called) when a user program explicitly rejects the\ncurrent line of attack (for example, a call to\namb(),\nan expression that always\nfails see section ).\n\nThe failure\ncontinuation in hand at that point will cause the most recent choice point\nto choose another alternative.\n\nIf there are no more alternatives to be\nconsidered at that choice point, a failure at an earlier choice point\nis triggered, and so on.\n\nFailure continuations are also invoked by\nthe driver loop in response to a\nretry\nrequest, to find another value of the\nprogram.\n\nIn addition, if a side-effect operation (such as assignment to a\nvariable) occurs on a branch of the process resulting from a choice,\nit may be necessary, when the process finds a dead end, to undo the\nside effect before making a new choice.\n\nThis is accomplished by\nhaving the side-effect operation produce a failure continuation that\nundoes the side effect and propagates the failure.\n\nIn summary, failure continuations are constructed by - - to provide a mechanism to make alternative choices if the current choice made by the -\n\n- the top-level driver to provide a mechanism to report failure when the choices are exhausted; - - assignments to intercept failures and undo assignments\n\nduring backtracking.",
    "token_count": 293,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_2"
  },
  {
    "content": "during backtracking.\n\nFailures are initiated only when a dead end is encountered.\n\nThis occurs\n-\n-\nif the user program executes\n\n```javascript\namb();\n```\n\n- - if the user types retry at the top-level driver.\n\nFailure continuations are also called during processing of a failure: - - When the failure continuation created by an assignment finishes undoing a side effect,\n\nit calls the failure continuation it intercepted, in order to propagate the failure back to the choice point that led to this assignment or to\n\nthe top level. - - When the failure continuation for an\n\nThe syntax- and data-representation functions for the function, are identical to those in the evaluator of section , except for the fact that we need\n\nadditional syntax functions to recognize the amb syntactic form:\n\n```javascript\nis_amb_amb\n      functions_4_1_2\n\nfunction is_amb(component) {\n    return is_tagged_list(component, \"application\") &&\n           is_name(function_expression(component)) &&\n           symbol_of_name(function_expression(component)) === \"amb\";\n}\nfunction amb_choices(component) {\n    return arg_expressions(component);\n}\n```\n\n```javascript\n\\newpage\\noindent\n\tWe continue to use the parse function of\n\tsection, which\n\tdoesn't support amb as a syntactic\n\tform and instead treats amb($\\ldots$) as\n\ta function application. The function\n\tis_amb ensures that\n\twhenever the name\n\tamb appears as the function\n\texpression of an application, the evaluator treats the\n\tapplication as\n\ta nondeterministic choice point.\n```\n\nWe must also add to the dispatch in\n\n```javascript\nsuch expressions and generate an appropriate execution\n      function:\n```\n\n```javascript\nis_amb_case_amb\n      all_solutions_test_5\n\n$\\ldots$\n: is_amb(component)\n? analyze_amb(component)\n: is_application(component)\n$\\ldots$\n```\n\nThe top-level function evaluate given in section ) analyzes the given component and applies the resulting execution function to the given environment, together with two\n\ngiven continuations:\n\n```javascript\nanalyze_amb_headline\n\n// functions from SICP JS 4.3.3\n```",
    "token_count": 274,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_3"
  },
  {
    "content": "given continuations:\n\n```javascript\nanalyze_amb\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n      analyze_amb_headline\n      is_amb_amb\n      analyze_literal_amb\n      analyze_variable_amb\n      analyze_lambda_amb\n      analyze_sequence_amb\n      analyze_declaration_amb\n      analyze_assignment_amb\n      analyze_if_amb\n      scan_out_declarations\n      analyze_block_amb\n      analyze_return_statement_amb\n      analyze_application_amb\n      analyze_amb_amb\n\nfunction analyze(component) {\n    return is_literal(component)\n           ? analyze_literal(component)\n           : is_name(component)\n           ? analyze_name(component)\n           : is_amb(component)\n           ? analyze_amb(component)\n           : is_application(component)\n           ? analyze_application(component)\n           : is_operator_combination(component)\n           ? analyze(operator_combination_to_application(component))\n           : is_conditional(component)\n           ? analyze_conditional(component)\n           : is_lambda_expression(component)\n           ? analyze_lambda_expression(component)\n           : is_sequence(component)\n           ? analyze_sequence(sequence_statements(component))\n           : is_block(component)\n           ? analyze_block(component)\n           : is_return_statement(component)\n           ? analyze_return_statement(component)\n           : is_function_declaration(component)\n           ? analyze(function_decl_to_constant_decl(component))\n           : is_declaration(component)\n           ? analyze_declaration(component)\n           : is_assignment(component)\n           ? analyze_assignment(component)\n           : error(component, \"unknown syntax -- analyze\");\n}\n```\n\n```javascript\nambeval\n      analyze_amb\n      all_solutions_test_4\n\nfunction ambeval(component, env, succeed, fail) {\n    return analyze(component)(env, succeed, fail);\n}\n```\n\nA success\nfunction\nof two arguments: the value just obtained and another failure continuation to\nbe used if that value leads to a subsequent failure.\n\nA\nfunction\nof no arguments.\n\nSo\nthe general form of an\nfunction\nis\n\n```javascript\n(env, succeed, fail) => {\n    // $\\texttt{succeed}\\,$ is $\\texttt{(value, fail) =>}~\\ldots$\n    // $\\texttt{fail}\\,$ is $\\texttt{() =>}~\\ldots$\n    $\\ldots$\n}\n```\n\nFor example, executing\n\n```javascript\nambeval(component,\n        the_global_environment,\n        (value, fail) => value,\n        () => \"failed\");\n```\n\nwill attempt to evaluate the given\ncomponent\nand will return either the\ncomponents\nvalue (if the evaluation succeeds) or the\nstring \"failed\"\n(if the evaluation fails).\n\nThe call to\nfunctions,\nwhich continue the loop and support the\nretry\nrequest.\n\nMost of the complexity of the\nfunctions\ncall each other.\n\nIn going through the following code, you should compare\neach of the execution\nfunctions\nwith the corresponding\nfunction\nfor the ordinary evaluator given in\nsection.\n\nThe execution\nfunctions\nfor the simplest kinds of expressions are\nessentially the same as those for the ordinary evaluator, except for the\nneed to manage the continuations.\n\nThe execution\nfunctions\nsimply succeed with the value of the expression, passing along the failure\ncontinuation that was passed to them.\n\n```javascript\nanalyze_literal_amb\n      all_solutions_test_4\n\nfunction analyze_literal(component) {\n    return (env, succeed, fail) =>\n             succeed(literal_value(component), fail);\n}\n```",
    "token_count": 309,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 4,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_4"
  },
  {
    "content": "The execution\nfunctions\nsimply succeed with the value of the expression, passing along the failure\ncontinuation that was passed to them.\n\n```javascript\nanalyze_variable_amb\n      all_solutions_test_4\n\nfunction analyze_name(component) {\n    return (env, succeed, fail) =>\n             succeed(lookup_symbol_value(symbol_of_name(component),\n                                         env),\n                     fail);\n}\n```\n\n```javascript\nanalyze_lambda_amb\n      all_solutions_test_4\n\nfunction analyze_lambda_expression(component) {\n    const params = lambda_parameter_symbols(component);\n    const bfun = analyze(lambda_body(component));\n    return (env, succeed, fail) =>\n             succeed(make_function(params, bfun, env),\n                     fail);\n}\n```\n\nNotice that looking up a\nname\nalways succeeds.\nlookup_symbol_value\nfails to find the\nname,\nit signals an\nerror, as usual.\n\nSuch a failure indicates a program\nbug a reference to an unbound\n\n```javascript\nname;\n```\n\nit is not an indication that we should try another nondeterministic choice instead of the one that is currently being tried.\n\nConditionals are also handled in a similar way as in the ordinary\nevaluator.\n\nThe execution\nfunction\ngenerated by\nanalyze_conditional\ninvokes the predicate execution\n\n```javascript\nfunction\n      pfun\n```\n\nwith a success continuation that checks whether the predicate value is true\nand goes on to execute either the consequent or the alternative.\n\nIf the\nexecution of\npfun\nfails, the original failure continuation for\nthe\nconditional\nexpression is called.\n\n```javascript\nanalyze_if_amb\n      all_solutions_test_4\n\nfunction analyze_conditional(component) {\n    const pfun = analyze(conditional_predicate(component));\n    const cfun = analyze(conditional_consequent(component));\n    const afun = analyze(conditional_alternative(component));\n    return (env, succeed, fail) =>\n             pfun(env,\n                  // success continuation for evaluating the predicate\n                  // to obtain $\\texttt{pred\\char`_value}$\n                  (pred_value, fail2) =>\n                    is_truthy(pred_value)\n                    ? cfun(env, succeed, fail2)\n                    : afun(env, succeed, fail2),\n                  // failure continuation for evaluating the predicate\n                  fail);\n}\n```",
    "token_count": 241,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 5,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_5"
  },
  {
    "content": "If the\nexecution of\npfun\nfails, the original failure continuation for\nthe\nconditional\nexpression is called.\n\n```javascript\nSequences are also handled in the same way as in the previous\n\tevaluator, except for the machinations in the\n\tsubfunction\n\n\t  analyze_sequence_amb\n\t  all_solutions_test_4\n\nfunction analyze_sequence(stmts) {\n    function sequentially(a, b) {\n        return (env, succeed, fail) =>\n                 a(env,\n                   // success continuation for calling $\\texttt{a}$\n                   (a_value, fail2) =>\n                     is_return_value(a_value)\n                     ? succeed(a_value, fail2)\n                     : b(env, succeed, fail2),\n                   // failure continuation for calling $\\texttt{a}$\n                   fail);\n    }\n    function loop(first_fun, rest_funs) {\n        return is_null(rest_funs)\n               ? first_fun\n               : loop(sequentially(first_fun, head(rest_funs)),\n                      tail(rest_funs));\n    }\n    const funs = map(analyze, stmts);\n    return is_null(funs)\n           ? env => undefined\n           : loop(head(funs), tail(funs));\n}\n```\n\nDeclarations\nare another case where we must go to some trouble to\nmanage the continuations, because it is necessary to evaluate the\ndeclaration-value expression before actually declaring the new name.\n\nTo accomplish this, the\ndeclaration-value\nexecution\nfunction\nis called with the environment, a success continuation, and the\nfailure continuation.\n\nIf the execution of\nsucceeds, obtaining a value\ndeclared name, the name is declared and the success is propagated:\n\n```javascript\nanalyze_declaration_amb\n      all_solutions_test_4\n\nfunction analyze_declaration(component) {\n    const symbol = declaration_symbol(component);\n    const vfun = analyze(declaration_value_expression(component));\n    return (env, succeed, fail) =>\n             vfun(env,\n                  (val, fail2) => {\n                      assign_symbol_value(symbol, val, env);\n                      return succeed(undefined, fail2);\n                  },\n                  fail);\n}\n```\n\nAssignments\nfunction\nfor assignments starts out like the one for\ndeclarations.\n\nIt first attempts\nto obtain the new value to be assigned to the\nname.\n\nIf this evaluation of\nvfun\nfails, the assignment fails.\n\nIf\nvfun\nsucceeds, however, and we go on to make the assignment, we must consider the\npossibility that this branch of the computation might later fail, which will\nrequire us to backtrack out of the assignment.\n\nThus, we must arrange to\nundo the assignment as part of the backtracking process.",
    "token_count": 292,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 6,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_6"
  },
  {
    "content": "Thus, we must arrange to\nundo the assignment as part of the backtracking process.\n\nThis is accomplished by giving\nvfun\na success continuation (marked with the comment *1* below)\nthat saves the old value of the variable before assigning the new value to\nthe variable and proceeding from the assignment.\n\nThe failure continuation\nthat is passed along with the value of the assignment (marked with the\ncomment *2* below) restores the old value of the variable\nbefore continuing the failure.\n\nThat is, a successful assignment provides a\nfailure continuation that will intercept a subsequent failure; whatever\nfailure would otherwise have called\nfunction\ninstead, to undo the assignment before actually calling\n\n```javascript\nanalyze_assignment_amb\n      all_solutions_test_4\n\nfunction analyze_assignment(component) {\n    const symbol = assignment_symbol(component);\n    const vfun = analyze(assignment_value_expression(component));\n    return (env, succeed, fail) =>\n             vfun(env,\n                  (val, fail2) => {              // *1*\n                      const old_value = lookup_symbol_value(symbol,\n                                                            env);\n                      assign_symbol_value(symbol, val, env);\n                      return succeed(val,\n                                     () => {     // *2*\n                                         assign_symbol_value(symbol,\n                                                             old_value,\n                                                             env);\n                                         return fail2();\n                                     });\n                  },\n                  fail);\n}\n```\n\nAnalyzing return statements is straightforward.\n\nThe return expression is analyzed to produce an execution function.\n\nThe execution function for the return statement calls that execution\nfunction with a success continuation that wraps the return value\nin a return value object and passes it to the original success continuation.\n\n```javascript\nanalyze_return_statement_amb\n\t  all_solutions_test_4\n\nfunction analyze_return_statement(component) {\n    const rfun = analyze(return_expression(component));\n    return (env, succeed, fail) =>\n             rfun(env,\n                  (val, fail2) =>\n                    succeed(make_return_value(val), fail2),\n                  fail);\n}\n```\n\nThe execution function for blocks calls the body s execution function on an extended environment, without changing success or failure continuations.\n\n```javascript\nanalyze_block_amb\n\t  list_of_unassigned\n\t  all_solutions_test_4\n\nfunction analyze_block(component) {\n    const body = block_body(component);\n    const locals = scan_out_declarations(body);\n    const unassigneds = list_of_unassigned(locals);\n    const bfun = analyze(body);\n    return (env, succeed, fail) =>\n             bfun(extend_environment(locals, unassigneds, env),\n                  succeed,\n                  fail);\n}\n```",
    "token_count": 289,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 7,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_7"
  },
  {
    "content": "The execution function for blocks calls the body s execution function on an extended environment, without changing success or failure continuations.\n\nThe execution\nfunction\nfor applications contains no new ideas except for the technical complexity\nof managing the continuations.\n\nThis complexity arises in\nanalyze_@application,\ndue to the need to keep track of the success and failure continuations as\nwe evaluate the\nargument expressions.\n\nWe use a\nfunction get_args\nto evaluate the list of\nargument expressions,\nrather than a simple\n\n```javascript\nanalyze_application_amb\n      get_args_amb\n      execute_application_amb\n      all_solutions_test_4\n\nfunction analyze_application(component) {\n    const ffun = analyze(function_expression(component));\n    const afuns = map(analyze, arg_expressions(component));\n    return (env, succeed, fail) =>\n             ffun(env,\n                  (fun, fail2) =>\n                    get_args(afuns,\n                             env,\n                             (args, fail3) =>\n                               execute_application(fun,\n                                                   args,\n                                                   succeed,\n                                                   fail3),\n                             fail2),\n                  fail);\n}\n```\n\n```javascript\nIn get_args,\n\tnotice how walking down the list of\n\tafun\n\texecution functions\n\tand constructing the resulting list of\n\tafun\n\tin the list with a success continuation that recursively calls\n\tget_args.\n```\n\nEach of these recursive calls to get_args has a success continuation whose value is the\n\n```javascript\nnew list resulting from using\n\tpair\n\tto adjoin the newly obtained argument\n\tto the list of accumulated arguments:\n```\n\n```javascript\nget_args_amb\n      all_solutions_test_4\n\nfunction get_args(afuns, env, succeed, fail) {\n    return is_null(afuns)\n           ? succeed(null, fail)\n           : head(afuns)(env,\n                         // success continuation for this $\\texttt{afun}$\n                         (arg, fail2) =>\n                           get_args(tail(afuns),\n                                    env,\n                                    // success continuation for\n                                    // recursive call to $\\texttt{get\\char`_args}$\n                                    (args, fail3) =>\n                                      succeed(pair(arg, args),\n                                              fail3),\n                                    fail2),\n                         fail);\n}\n```\n\nThe actual function application, which is performed by execute_application, is accomplished in the same way as for the ordinary evaluator, except for the need to\n\nmanage the continuations.\n\n```javascript\nexecute_application_amb\n      all_solutions_test_4\n\nfunction execute_application(fun, args, succeed, fail) {\n    return is_primitive_function(fun)\n           ? succeed(apply_primitive_function(fun, args),\n                     fail)\n           : is_compound_function(fun)\n           ? function_body(fun)(\n                 extend_environment(function_parameters(fun),\n                                    args,\n                                    function_environment(fun)),\n                 (body_result, fail2) =>\n                   succeed(is_return_value(body_result)\n                           ? return_value_content(body_result)\n                           : undefined,\n                           fail2),\n                 fail)\n           : error(fun, \"unknown function type - execute_application\");\n}\n```",
    "token_count": 300,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 8,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_8"
  },
  {
    "content": "manage the continuations.\n\nThe\nsyntactic\nform is the key element in the nondeterministic language.\n\nHere we see the\nessence of the interpretation process and the reason for keeping track of\nthe continuations.\n\nThe execution\nfunction\nfor\ntry_next\nthat cycles through the execution\nfunctions\nfor all the possible values of the\nfunction\nis called with a\n\n```javascript\nanalyze_amb_amb\n      all_solutions_test_4\n\nfunction analyze_amb(component) {\n    const cfuns = map(analyze, amb_choices(component));\n    return (env, succeed, fail) => {\n               function try_next(choices) {\n                   return is_null(choices)\n                          ? fail()\n                          : head(choices)(env,\n                                          succeed,\n                                          () =>\n                                            try_next(tail(choices)));\n               }\n               return try_next(cfuns);\n           };\n}\n```\n\nThe driver loop for the\na program.\n\nThe driver uses a\nfunction\ncalled\ninternal_loop,\nwhich takes as argument a\nfunction\nretry.\n\nThe intent is that calling\nretry\nshould go on to the next untried alternative in the nondeterministic\nevaluation.\n\n```javascript\nThe function\n    internal_loop\n```\n\neither calls retry in response to the user typing retry at the driver loop, or else starts a new evaluation by calling\n\nThe failure continuation for this call to\n\nThe success continuation for the call to\nreinvoke the internal loop\nwith a\nretry\nfunction\nthat will be able to try the next alternative.\n\nThis\nnext_alternative\nfunction\nis the second argument that was passed to the success continuation.\n\nOrdinarily, we think of this second argument as a failure continuation to\nbe used if the current evaluation branch later fails.\n\nIn this case,\nhowever, we have completed a successful evaluation, so we can invoke the\nfailure alternative branch in order to search for additional\nsuccessful evaluations.\n\n```javascript\ndriver_loop_amb_example\n\ndriver_loop();\n```",
    "token_count": 253,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 9,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_9"
  },
  {
    "content": "In this case,\nhowever, we have completed a successful evaluation, so we can invoke the\nfailure alternative branch in order to search for additional\nsuccessful evaluations.\n\n```javascript\ndriver_loop_amb\n      ambeval\n      user_print\n      user_read\n      driver_loop_amb_example\n\nconst input_prompt = \"amb-evaluate input:\";\nconst output_prompt =  \"amb-evaluate value:\";\n\nfunction driver_loop(env) {\n    function internal_loop(retry) {\n        const input = user_read(input_prompt);\n        if (is_null(input)) {\n            display(\"evaluator terminated\");\n        } else if (input === \"retry\") {\n            return retry();\n        } else {\n            display(\"Starting a new problem\");\n            const program = parse(input);\n            const locals = scan_out_declarations(program);\n            const unassigneds = list_of_unassigned(locals);\n            const program_env = extend_environment(\n                                    locals, unassigneds, env);\n            return ambeval(\n                       program,\n                       program_env,\n                       // ambeval success\n                       (val, next_alternative) => {\n                           user_print(output_prompt, val);\n                           return internal_loop(next_alternative);\n                       },\n                       // ambeval failure\n                       () => {\n                           display(\"There are no more values of\");\n                           display(input);\n                           return driver_loop(program_env);\n                       });\n        }\n    }\n    return internal_loop(() => {\n                             display(\"There is no current problem\");\n                             return driver_loop(env);\n                         });\n}\n\nconst input_prompt = \"amb-evaluate input:\";\nconst output_prompt =  \"amb-evaluate value:\";\nfunction driver_loop() {\n    function internal_loop(retry) {\n        const input = user_read(input_prompt);\n        if (is_null(input)) {\n        display(\"--- evaluator terminated ---\", \"\");\n        } else if (input === \"retry\") {\n            display(\"----------------------------\",\n                    input_prompt + \"\\n\" + input + \"\\n\");\n            return retry();\n        } else {\n            display(\"--- starting new problem ---\",\n                    input_prompt + \"\\n\" + input + \"\\n\");\n            ambeval(parse(\"{ \" + input + \" }\"),\n                the_global_environment,\n                // ambeval success\n                (val, next_alternative) => {\n                    user_print(output_prompt, val);\n                    return internal_loop(next_alternative);\n                },\n                // ambeval failure\n                () => {\n                    display(\"----------------------------\",\n                            \"no more values of:\\n\" + input + \"\\n\");\n                    return driver_loop();\n                });\n        }\n    }\n    return internal_loop(\n               () => {\n                   display(\"---  no current problem  ---\", \"\");\n                   return driver_loop();\n               });\n}\n```\n\nThe initial call to\ninternal_loop\nuses a\nretry\nfunction\nthat complains that there is no current problem and restarts the driver loop.\n\nThis is the behavior that will happen if the user types\nretry\nwhen there is no evaluation in progress.",
    "token_count": 296,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 10,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_10"
  },
  {
    "content": "This is the behavior that will happen if the user types\nretry\nwhen there is no evaluation in progress.\n\nWe start the driver loop as usual, by setting up the global environment and passing it as the enclosing environment for the first iteration of\n\ndriver_loop.\n\n```javascript\nconst the_global_environment = setup_environment();\ndriver_loop(the_global_environment);\n```",
    "token_count": 52,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Implementing the amb Evaluator",
    "chunk_index": 11,
    "chunk_id": "Metalinguistic_Abstraction_Implementing_the_amb_Evaluator_11"
  },
  {
    "content": "To extend\nJavaScript\nto support nondeterminism, we introduce a new\nsyntactic form\namb($e_1,\\ e_2,\\ldots, e_n$)\nreturns the value of one of the $n$ expressions\n$e_i$ ambiguously.\n\nFor example,\nthe expression\n\n```javascript\nlist_non_det\n\nlist(amb(1, 2, 3), amb(\"a\", \"b\"));\n\nlist(amb(1, 2, 3), amb(\"a\", \"b\"));\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```\n\ncan have six possible values:\n\n```javascript\nlist(1, \"a\") list(1, \"b\") list(2, \"a\")\nlist(2, \"b\") list(3, \"a\") list(3, \"b\")\n```\n\nAn amb expression with a single choice produces an ordinary (single) value.\n\nAn amb expression\nwith no choices the expression\namb()is\namb()\nas an expression that when evaluated causes the computation to\nfail : The computation aborts and no value is produced.\n\nUsing this idea, we can express the requirement that a particular predicate\nexpression\n\n```javascript\nrequire_non_det_example\n\nconst x = amb(1, 3, 5, 7, 9);\nrequire(x >= 4);\nx;\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```\n\n```javascript\nrequire_non_det\n      require_non_det_example\n      5\n\nfunction require(p) {\n    if (! p) {\n        amb();\n    } else {}\n}\n```\n\nWith an_element_of function used above:\n\n```javascript\nan_element_of_example\n\nconst xs = list(\"apple\", \"banana\", \"cranberry\");\nan_element_of(xs);\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```\n\n```javascript\nan_element_of\n      an_element_of_example\n      'apple'\n\nfunction an_element_of(items) {\n    require(! is_null(items));\n    return amb(head(items), an_element_of(tail(items)));\n}\n```\n\nAn application of an_element_of\nfails if the list is empty.\n\nOtherwise it ambiguously returns either the\nfirst element of the list or an element chosen from the rest of the list.\n\nWe can also express infinite ranges of choices.\n\nThe following\nfunction\npotentially returns any integer greater than or equal to some\ngiven $n$ :",
    "token_count": 293,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Search and amb",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Search_and_amb_1"
  },
  {
    "content": "The following\nfunction\npotentially returns any integer greater than or equal to some\ngiven $n$ :\n\n```javascript\nan_integer_starting_from_example\n\nconst x = an_integer_starting_from(1);\nrequire(x >= 4.5);\nx;\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```\n\n```javascript\nan_integer_starting_from\n      an_integer_starting_from_example\n      5\n\nfunction an_integer_starting_from(n) {\n    return amb(n, an_integer_starting_from(n + 1));\n}\n```\n\nThis is like the stream\n\n```javascript\nfunction\n      integers_starting_from\n```\n\ndescribed in section , but with an important difference: The stream function returns an object that represents the sequence of all integers beginning with $n$\n\n, whereas the function returns a single integer.\n\nAbstractly, we can imagine that evaluating an\nnondeterministic choice point.\n\nIf we had a machine with a\nsufficient number of processors that could be dynamically allocated, we\ncould implement the search in a straightforward way.\n\nExecution would\nproceed as in a sequential machine, until an\n\nOn the other hand, if we have a machine that can execute only one process\n(or a few concurrent processes), we must consider the alternatives\nsystematically search all possible execution paths.\n\nThe\nbacktracks to the most recent choice point and tries the next\nalternative.\n\nIf it runs out of alternatives at any choice point, the\nevaluator will back up to the previous choice point and resume from there.\n\nThis process leads to a search strategy known as\ndepth-first search or\nchronological\nbacktracking.\n\nThe\na program\nand prints the value of the\nfirst non-failing execution, as in the\nprime_sum_pair\nexample shown above.\n\nIf we want to see the value of the next successful\nexecution, we can ask the interpreter to backtrack and attempt to generate a\nsecond non-failing execution.\n\n```javascript\nThis is signaled by typing\n\tretry.\n\tIf any other input except retry\n\tis given, the interpreter will start a new problem, discarding the\n\tunexplored alternatives in the previous problem.\n```",
    "token_count": 307,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Search and amb",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Search_and_amb_2"
  },
  {
    "content": "If we want to see the value of the next successful\nexecution, we can ask the interpreter to backtrack and attempt to generate a\nsecond non-failing execution.\n\nHere is a sample interaction:\n\n```javascript\ninteraction_non_det\n      is_prime2\n      prime_sum_pair_non_det\n\namb-evaluate input:\n\nprime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));\n\nprime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```\n\n```javascript\ninteraction_non_det_2\n      is_prime2\n      prime_sum_pair_non_det\n\namb-evaluate input:\n\nretry\n\nprime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```\n\n```javascript\ninteraction_non_det_3\n      is_prime2\n      prime_sum_pair_non_det\n\namb-evaluate input:\n\nretry\n\nprime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```\n\n```javascript\ninteraction_non_det_4\n      is_prime2\n      prime_sum_pair_non_det\n\namb-evaluate input:\n\nretry\n\nprime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```\n\n```javascript\ninteraction_non_det_5\n      is_prime2\n      prime_sum_pair_non_det\n\namb-evaluate input:\n\nprime_sum_pair(list(19, 27, 30), list(11, 36, 58));\n\nprime_sum_pair(list(19, 27, 30), list(11, 36, 58));\n// Press \"Run\" for the first solution. Type\n// retry\n// in the REPL on the right, for more solutions\n```",
    "token_count": 217,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "Nondeterministic Computing",
    "subsection": "Search and amb",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Search_and_amb_3"
  },
  {
    "content": "Our evaluator for\nJavaScript\nwill be implemented as a\nJavaScript\nprogram.\n\nIt may\nseem circular to think about evaluating\nJavaScript\nprograms using an evaluator that is itself implemented in\nJavaScript.\n\nHowever, evaluation is a process, so it is appropriate to describe the\nevaluation process using\nJavaScript,\nwhich, after all, is our tool for describing processes. metacircular.\n\nThe metacircular evaluator is essentially a JavaScript formulation of the.\n\n```javascript\nRecall that the model specifies the\n\tevaluation of function application in two basic steps:\n```\n\n- -\n\n```javascript\nTo evaluate a function application, evaluate the\n\t    subexpressions and then apply the\n\t    value of the function subexpression to the values of the argument\n            subexpressions.\n```\n\n-\n-\nTo apply a compound\nfunction\nto a set of arguments, evaluate the\nbody of the\nfunction\nin a new environment.\n\nTo construct this\nenvironment, extend the environment part of the\nfunction\nobject by a\nframe in which the\nparameters of the\nfunction\nare bound to\nthe arguments to which the\nfunction\nis applied.\n\nThese two rules describe the essence of the evaluation process, a basic cycle in which statements and expressions to be evaluated in environments are reduced\n\nto functions to be applied to arguments, which in turn are reduced to new statements and expressions to be evaluated in new environments, and so\n\non, until we get down to names, whose values are looked up in the environment, and to operators and primitive functions, which are applied directly\n\n(see figure ). functions in the evaluator, and (see figure ).",
    "token_count": 251,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_The_Metacircular_Evaluator_1"
  },
  {
    "content": "(see figure ). functions in the evaluator, and (see figure ).\n\n```javascript\nThe implementation of the evaluator will depend upon functions that\n\tdefine the syntax of the statements and\n\texpressions to be evaluated.\n\tWe will use\n\t=, we use an abstract predicate\n\tis_assignment to test for an\n\tassignment, and we use abstract\n\tselectors assignment_symbol and\n\tassignment_value_expression to\n\taccess the parts of an assignment.\n\tThe data abstraction layers presented in\n\tsection\n\twill allow the evaluator to remain independent of concrete syntactic\n\tissues, such as the keywords of the interpreted language, and of the\n\tchoice of data structures that represent the program components.\n```\n\nThere are also\noperations, described in\nsection , that specify the\nrepresentation of\nfunctions\nand environments.\n\nFor example,\nmake_function\nconstructs compound\nfunctions,\nlookup_symbol_value\naccesses the values of\nnames,\nand\napply_primitive_function\napplies a primitive\nfunction\nto a given list of arguments.",
    "token_count": 142,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_The_Metacircular_Evaluator_2"
  },
  {
    "content": "In thinking about a\nJavaScript\nprogram that evaluates\nJavaScript statements and\nexpressions, an analogy might be helpful.\n\nOne operational view of the\nmeaning of a program is that a\n\n```javascript\nfactorial_4_1_5\n      factorial_example\n      120\n\nfunction factorial(n) {\n    return n === 1\n           ? 1\n           : factorial(n - 1) * n;\n}\n```\n\nWe may regard this program as the description of a is a flow diagram for the factorial machine, showing how the parts are wired together.\n\nIn a similar way, we can regard the evaluator as a very special\nfigure,\nthe evaluator will be able to compute factorials.\n\nThe evaluator emulating a factorial machine.\n\nFrom this perspective, our evaluator is seen to be a\nuniversal machine.\n\nIt mimics other machines when these are described as\nJavaScript\nprograms.\n\nAnother striking aspect of the evaluator is that it acts as a bridge between\nthe data objects that are manipulated by our programming language and the\nprogramming language itself.\n\nImagine that the evaluator program\n(implemented in JavaScript)\nis running, and that a user is typing\nprograms\nto the evaluator and\nobserving the results.\n\nFrom the perspective of the user, an input\nprogram\nsuch as\n\n```javascript\nx * x;\n```\n\nis a program in the programming language, which the evaluator should execute.\n\n```javascript\nFrom the perspective of the evaluator, however, the program is simply\n\ta string orafter parsinga tagged-list representation\n\tthat is to be manipulated according to a well-defined set of rules.\n```\n\nThat the\ns programs are the evaluator s data need not\nbe a source of confusion.\n\nIn fact, it is sometimes convenient to ignore\nthis distinction, and to give the user the ability to explicitly\nevaluate a string as a JavaScript statement, using JavaScript's\nprimitive function provided that it is syntactically correct evaluates the\nresulting representation in the environment in which\n\n```javascript\neval(\"5 * 5;\");\n```\n\nand",
    "token_count": 305,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Data as Programs",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Data_as_Programs_1"
  },
  {
    "content": "and\n\n```javascript\nevaluate_example_4_1_5\n\t  functions_4_1_1\n\t  functions_4_1_2\n\t  functions_4_1_3\n\t  functions_4_1_4\n\t  25\n\nevaluate(parse(\"5 * 5;\"), the_global_environment);\n```\n\nwill both return 25.",
    "token_count": 17,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Data as Programs",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Data_as_Programs_2"
  },
  {
    "content": "In addition to defining the representation of components, the evaluator implementation must also define the data structures that the evaluator manipulates internally, as part of\n\nthe execution of a program, such as the representation of functions and environments and the representation of true and false.\n\n```javascript\nIn order to limit the predicate expressions of conditionals to proper\n\tpredicates (expressions that evaluate to a boolean value) as we do throughout\n\tthis book, we insist here that the function\n\tis_truthy gets applied only to\n\tboolean values, and we accept only the boolean value\n\ttrue to be truthy.\n      The opposite of\n      is_truthy is called\n      is_falsy.\n```\n\n```javascript\nheadline_4_1_3\n\n// functions from SICP JS 4.1.3\n```\n\n```javascript\ntrue\n      true_example\n      false\n\nfunction is_truthy(x) {\n    return is_boolean(x)\n           ? x\n           : error(x, \"boolean expected, received\");\n}\nfunction is_falsy(x) { return ! is_truthy(x); }\n```\n\n```javascript\ntrue_example\n\nis_truthy(false); // should return false because only true is truthy\n```\n\nTo handle primitives, we assume that we have available the following\nfunctions:\n-\n-\napply_primitive_function(fun, args)\napplies the given primitive\nfunction\nto the argument values in the list args and returns the result of\nthe application.\n-\n-\nis_primitive_function(fun)\ntests whether\nfun\nis a primitive\nfunction.\n\nThese mechanisms for handling primitives are further described in\nsection.\n\nCompound functions are constructed from parameters, function bodies, and environments using the constructor make_function:\n\n```javascript\nmake_procedure\n      tagged_list\n      make_procedure_example\n      [ 'x', [ 'y', null ] ]\n\nfunction make_function(parameters, body, env) {\n    return list(\"compound_function\", parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, \"compound_function\");\n}\nfunction function_parameters(f) { return list_ref(f, 1); }\n\nfunction function_body(f) { return list_ref(f, 2); }\n\nfunction function_environment(f) { return list_ref(f, 3); }\n```\n\n```javascript\nmake_procedure_example\n      enclosing_environment\n\nconst my_function =\n    make_function(\n        list(\"x\", \"y\"),\n        list(\"return_statement\", parse(\"x + y;\")),\n        the_empty_environment);\ndisplay(is_compound_function(my_function));\ndisplay(function_parameters(my_function));\ndisplay(function_body(my_function));\ndisplay(function_environment(my_function));\n\nconst my_function =\n    make_function(\n        list(\"x\", \"y\"),\n        list(\"return_statement\", parse(\"x + y;\")),\n        the_empty_environment);\nis_compound_function(my_function);\nfunction_body(my_function);\nfunction_environment(my_function);\nfunction_parameters(my_function);\n```",
    "token_count": 305,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Evaluator Data Structures",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Evaluator_Data_Structures_1"
  },
  {
    "content": "Compound functions are constructed from parameters, function bodies, and environments using the constructor make_function:\n\nWe saw in section that the\nevaluation of a sequence terminates when a return statement\nis encountered, and that the evaluation of a function application needs\nto return the value undefined if\nthe evaluation of the function body does not encounter a\nreturn statement.\n\nIn order to recognize that a value resulted from a\nreturn values as evaluator data\nstructures.\n\n```javascript\nreturn_value\n\t  tagged_list\n\t  return_value_example\n\t  42\n\nfunction make_return_value(content) {\n    return list(\"return_value\", content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value, \"return_value\");\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n```\n\n```javascript\nreturn_value_example\n\t  enclosing_environment\n\nconst my_return_value = make_return_value(42);\ndisplay(is_return_value(my_return_value));\ndisplay(return_value_content(my_return_value));\n\nconst my_return_value = make_return_value(42);\nis_return_value(my_return_value);\nreturn_value_content(my_return_value);\n```\n\nThe evaluator needs operations for\n, an environment is a\nsequence of frames, where each frame is a table of bindings that associate\nsymbols\nwith their corresponding values.\n\nWe use the following operations for\nmanipulating environments:\n\n```javascript\nlookup_symbol_value(symbol, env)\n\n\t  returns the value that is bound to\n\t  symbol in the environment\n\t  env, or signals an error if\n\t  symbol is unbound.\n\n\t    extend_environment(symbols, values, base-env)\n\n\t    returns a new environment, consisting of a new frame in which the\n\t    symbols in the list symbols\n\t    are bound to the corresponding elements in the list\n\t    values, where the enclosing\n\t    environment is the environment\n\t    base-env.\n\n\t    assign_symbol_value(symbol, value, env)\n\n\t    finds the innermost frame of\n\t    env\n\t    in which symbol\n\t    is bound, and changes that frame\n\t    so that\n\t    symbol\n\t    is now bound to\n\t    value, or signals an\n\t    error if symbol is\n\t    unbound.\n```\n\nTo implement these operations we\ntail\nof the list.\n\nThe empty environment is simply the empty list.\n\n```javascript\nenclosing_environment\n      enclosing_environment_example\n      null\n\nfunction enclosing_environment(env) { return tail(env); }\n\nfunction first_frame(env) { return head(env); }\n\nconst the_empty_environment = null;\n```\n\n```javascript\nenclosing_environment_example\n\nthe_empty_environment;\n```",
    "token_count": 290,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Evaluator Data Structures",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Evaluator_Data_Structures_2"
  },
  {
    "content": "The empty environment is simply the empty list.\n\nEach frame of an environment is represented as a pair of lists: a list of the names bound in that frame and a list of\n\nthe associated values.\n\n```javascript\nmake_frame_example\n\nconst my_frame = make_frame(list(\"x\", \"y\"), list(1, 2));\nframe_symbols(my_frame);\n```\n\n```javascript\nmake_frame\n      make_frame_example\n      [ 'x', [ 'y', null ] ]\n\nfunction make_frame(symbols, values) { return pair(symbols, values); }\n\nfunction frame_symbols(frame) { return head(frame); }\n\nfunction frame_values(frame) { return tail(frame); }\n```\n\nTo extend an environment by a new frame that associates\nsymbols\nwith values, we make a frame consisting of the list of\nsymbols\nand the list of values, and we adjoin this to the environment.\n\nWe signal\nan error if the number of\nsymbols\ndoes not match the number of values.\n\n```javascript\nextend_environment\n      extend_environment_example\n      [ 1, [ 2, [ 3, null ] ] ]\n\nfunction extend_environment(symbols, vals, base_env) {\n    return length(symbols) === length(vals)\n           ? pair(make_frame(symbols, vals), base_env)\n           : error(pair(symbols, vals),\n                   length(symbols) < length(vals)\n                   ? \"too many arguments supplied\"\n                   : \"too few arguments supplied\");\n}\n\nfunction extend_environment(symbols, vals, base_env) {\n    return length(symbols) === length(vals)\n           ? pair(make_frame(symbols, vals), base_env)\n           : length(symbols) < length(vals)\n           ? error(\"too many arguments supplied: \" +\n                   stringify(symbols) + \", \" +\n                   stringify(vals))\n           : error(\"too few arguments supplied: \" +\n                   stringify(symbols) + \", \" +\n                   stringify(vals));\n}\n```\n\n```javascript\nextend_environment_example\n      enclosing_environment\n      make_frame\n\nextend_environment(list(\"x\", \"y\", \"z\"),\n                   list(1, 2, 3),\n                   the_empty_environment);\n\ntail(head(extend_environment(list(\"x\", \"y\", \"z\"),\n                   list(1, 2, 3),\n                   the_empty_environment)));\n```\n\n```javascript\nThis is used by apply in\n\tsection to bind the\n\tparameters of a function to its arguments.\n```\n\nTo look up a\nsymbol\nin an environment, we scan the list of\nsymbols\nin the first frame.\n\nIf we find the desired\nsymbol,\nwe return the corresponding element in the list of values.\n\nIf we do not\nfind the\nsymbol\nin the current frame, we search the enclosing environment, and so on.",
    "token_count": 308,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Evaluator Data Structures",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Evaluator_Data_Structures_3"
  },
  {
    "content": "If we do not\nfind the\nsymbol\nin the current frame, we search the enclosing environment, and so on.\n\nIf we reach the empty environment, we signal an\n\"unbound name\"\nerror.\n\n```javascript\nlookup_variable_value\n      lookup_variable_value_example\n      1\n\nfunction lookup_symbol_value(symbol, env) {\n    function env_loop(env) {\n        function scan(symbols, vals) {\n            return is_null(symbols)\n                   ? env_loop(enclosing_environment(env))\n                   : symbol === head(symbols)\n                   ? head(vals)\n                   : scan(tail(symbols), tail(vals));\n        }\n        if (env === the_empty_environment) {\n            error(symbol, \"unbound name\");\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_symbols(frame), frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n```\n\n```javascript\nlookup_variable_value_example\n      enclosing_environment\n      extend_environment\n      make_frame\n\nconst my_environment =\n    extend_environment(list(\"x\", \"y\", \"z\"),\n                       list(1, 2, 3),\n                       the_empty_environment);\n\nlookup_symbol_value(\"x\", my_environment);\n```\n\n```javascript\nTo assign\n      a new value to a symbol in a specified environment, we scan\n      for the symbol, just as in\n      lookup_symbol_value,\n      and change the corresponding value when we find it.\n```\n\n```javascript\nassign_name_value\n      assign_name_value_example\n      2\n\nfunction assign_symbol_value(symbol, val, env) {\n    function env_loop(env) {\n        function scan(symbols, vals) {\n            return is_null(symbols)\n                   ? env_loop(enclosing_environment(env))\n                   : symbol === head(symbols)\n                   ? set_head(vals, val)\n                   : scan(tail(symbols), tail(vals));\n        }\n        if (env === the_empty_environment) {\n            error(symbol, \"unbound name -- assignment\");\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_symbols(frame), frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n```\n\n```javascript\nassign_name_value_example\n      functions_4_1_1\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nconst my_block = parse(\"{ let x = 1; x = 2; }\");\nevaluate(my_block, the_global_environment);\n```\n\nThe method described here is only one of many plausible ways to represent\nenvironments.\n\nSince we used.) In a\nproduction-quality\nJavaScript\nsystem, the speed of the evaluator s environment\noperations especially that of\nsymbol\nlookup has a major\nimpact on the performance of the system.\n\nThe representation described here,\nalthough conceptually simple, is not efficient and would not ordinarily be\nused in a production system.",
    "token_count": 277,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Evaluator Data Structures",
    "chunk_index": 4,
    "chunk_id": "Metalinguistic_Abstraction_Evaluator_Data_Structures_4"
  },
  {
    "content": "In JavaScript, the scope of a declaration\nis the entire block that immediately surrounds the declaration,\nnot just the portion of the block starting at the point where\nthe declaration occurs.\n\nThis section takes a closer look at this design choice.\n\nLet us revisit the pair of mutually recursive functions is_even and is_odd from Section , declared locally in the body of a function f.\n\n```javascript\nf_is_even_is_odd_2\n\nfunction f(x) {\n    function is_even(n) {\n        return n === 0\n               ? true\n               : is_odd(n - 1);\n    }\n    function is_odd(n) {\n        return n === 0\n               ? false\n               : is_even(n - 1);\n    }\n    return is_even(x);\n}\n```\n\nOur intention here is that the name\nis_odd\nin the body of the function is_even\nshould refer to the function is_odd\nthat is declared after is_even.\n\nThe scope of the name is_odd is the\nentire body block of is_odd\noccurs.\n\nIndeed, when we consider that\nis_odd is itself defined in terms of\nis_even so that\nis_even and\nis_odd are mutually recursive\nfunctions we see that the only satisfactory interpretation of\nthe two declarations is to regard them as if the names\nis_even and\nis_odd\nwere being added to the environment simultaneously.\n\nMore generally, in\nblock structure, the scope of a local name is the entire block\nin which the declaration is evaluated.\n\nThe evaluation of blocks in the metacircular evaluator of\nsection achieves such\na simultaneous scope for local names by\nis_even and\nis_odd , and any occurrence\nof one of these names refers to the correct binding.\n\nOnce their\ndeclarations are evaluated,\nthese names are bound to their declared values, namely function\nobjects that have the extended environment as their environment\npart.",
    "token_count": 275,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Internal Declarations",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Internal_Declarations_1"
  },
  {
    "content": "Once their\ndeclarations are evaluated,\nthese names are bound to their declared values, namely function\nobjects that have the extended environment as their environment\npart.\n\nThus, for example,\nby the time\nis_even\ngets applied in the body of\nf , its environment\nalready contains the correct binding for the symbol\nis_odd , and\nthe evaluation of the name\nis_odd in the body of\nis_even retrieves the correct\nvalue.\n\nimposes a\nruntime burden on the evaluation of blocks: It needs to scan\nthe body of the block for locally declared names, extend the\ncurrent environment with a new frame that binds those names, and evaluate the\nblock body in this extended environment.\n\nAlternatively, the evaluation\nof a block could extend the current environment with an empty frame.\n\nThe evaluation of each declaration in the block body would then add\na new binding to that frame.\n\nTo implement this design, we first simplify\neval_block :\n\n```javascript\neval_block_simplified\n\nfunction eval_block(component, env) {\n    const body = block_body(component);\n    return evaluate(body, extend_environment(null, null, env);\n}\n```\n\nThe function\neval_declaration can no\nlonger assume that the environment already has a binding for\nthe name.\n\nInstead of using\nassign_symbol_value to\nchange an existing binding, it calls a new function,\nadd_binding_to_frame , to\nadd to the first frame of the environment a binding of the name\nto the value of the value expression.\n\n```javascript\neval_declaration_simplified\n\nfunction eval_declaration(component, env) {\n    add_binding_to_frame(\n        declaration_symbol(component),\n        evaluate(declaration_value_expression(component), env),\n        first_frame(env));\n    return undefined;\n}\nfunction add_binding_to_frame(symbol, value, frame) {\n    set_head(frame, pair(symbol, head(frame)));\n    set_tail(frame, pair(value, tail(frame)));\n}\n```\n\nWith sequential declaration processing, the scope of a\ndeclaration is no longer the entire block that immediately surrounds\nthe declaration, but rather just the portion of the block starting at\nthe point where the declaration occurs.",
    "token_count": 287,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Internal Declarations",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Internal_Declarations_2"
  },
  {
    "content": "With sequential declaration processing, the scope of a\ndeclaration is no longer the entire block that immediately surrounds\nthe declaration, but rather just the portion of the block starting at\nthe point where the declaration occurs.\n\nAlthough we no longer have simultaneous scope, sequential\ndeclaration processing\nwill evaluate calls to the function\naccidental reason: Since the declarations\nof the internal functions come first, no calls to these functions\nwill be evaluated until all of them have been declared.\n\nHence,\nis_odd will have been declared by the time\nis_even is executed.\n\nIn fact,\nsequential declaration processing\nwill give the same result as our scanning-out-names evaluator in\nsection\nfor any function\nin which the\nt actually use any of\nthe declared names.\n\nExercise shows\nan example of a function that doesn t\nobey these restrictions, so that the alternative evaluator isn t\nequivalent to our scanning-out-names evaluator.\n\nSequential declaration processing is more efficient and easier to\nimplement than scanning out names.\n\nHowever, with sequential processing, the\ndeclaration to which a name refers may depend on the order in which\nthe statements in a block are evaluated.\n\nIn exercise , we see that\nviews may differ as to whether that is desirable.",
    "token_count": 199,
    "has_code": false,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Internal Declarations",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Internal_Declarations_3"
  },
  {
    "content": "Programmers write programs as text, i.e. sequences of characters, entered\nin a programming environment or a text editor.\n\nTo run our evaluator, we need\nto start with a representation of this program text as a JavaScript value.\n\nIn section we introduced strings to represent\ntext.\n\nWe would like to evaluate programs such as\n\"const size = 2; 5 * size;\"\nfrom section.\n\nUnfortunately, such program text does not provide enough structure to\nthe evaluator.\n\nIn this example, the program parts\n\"size = 2\" and\n\"5 * size\" look similar, but carry\nvery different meanings.\n\nAbstract syntax functions such as\ndeclaration_@value_@expression would be\ndifficult\nand error-prone to implement by examining the program text.\n\nIn this section, we therefore\nintroduce a function\nparse that translates program text\nto a tagged-list representation , reminiscent of\nthe tagged data of section.\n\nFor example, the application of\nparse to the program string\nabove produces a data structure that\nreflects the structure of the program: a sequence consisting\nof a constant declaration associating the name\nsize with the value 2\nand a multiplication.\n\n```javascript\nparse_declaration\n\nparse(\"const size = 2; 5 * size;\");\n```\n\nThe syntax functions used by the evaluator access the tagged-list representation produced by parse.\n\nThe evaluator is reminiscent of the.\n\nBoth programs operate on symbolic\ndata.\n\nIn both programs, the\nresult of operating on\nan object\nis determined by\noperating recursively on the pieces of the\nobject\nand combining\nthe results in a way that depends on the type of the\nobject.\n\nIn both programs we used\nthe objects\nare represented.\n\nIn\nthe differentiation program this meant that the same differentiation\nfunction\ncould deal with algebraic expressions in prefix form, in\ninfix form, or in some other form.\n\nFor the evaluator, this means that",
    "token_count": 291,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Representing Components",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Representing_Components_1"
  },
  {
    "content": "For the evaluator, this means that\n\n```javascript\nthe syntax of the language being evaluated is determined\n\tsolely by parse and\n\tthe functions that classify and extract pieces of the\n\ttagged lists produced by parse.\n```\n\nSyntax abstraction in the evaluator.\n\nFigure depicts the\nparse.\n\nBelow we\ndescribe the parsing of program components and list the\ncorresponding syntax predicates and selectors, as well as\nconstructors if they are needed.\n\n```javascript\nheadline_4_1_2\n\n// functions from SICP JS 4.1.2\n```\n\nLiteral expressions\n\"literal\" and\nthe actual value.\n\\begin{Parsing}\n\\ll\\ \\mathit{literal}\\mhyphen\\mathit{expression}\\ \\gg & = &\n\\texttt{list(\"literal\", }\\mathit{value}\\texttt{)}\n\\end{Parsing}%\nwhere value is\nthe JavaScript value represented by the\nliteral-expression string.\n\nHere $\\ll\\ \\mathit{literal}\\mhyphen\\mathit{expression}\\ \\gg$ denotes the\nresult of parsing the string literal-expression.\n\n```javascript\nparse_literal_example\n\nparse(\"1;\");\n```\n\n```javascript\nparse_literal_example_2\n\nparse(\"'hello world';\");\n```\n\n```javascript\nparse_literal_example_3\n\nparse(\"null;\");\n```\n\nThe syntax predicate for literal expressions is is_literal.\n\n```javascript\nis_literal\n\t  tagged_list\n\t  is_literal_example\n\t  true\n\nfunction is_literal(component) {\n    return is_tagged_list(component, \"literal\");\n}\n\nfunction is_literal(component) {\n    return is_tagged_list(component, \"literal\");\n}\nfunction literal_value(component) {\n    return head(tail(component));\n}\n```\n\n```javascript\nis_literal_example\n\nconst my_program = parse(\"true; 1;\");\nconst my_true_statement = list_ref(list_ref(my_program, 1), 0);\nis_literal(my_true_statement);\n```\n\nIt is defined in terms of the function is_tagged_list , which identifies lists that begin with a designated string:\n\n```javascript\ntagged_list\n\t  tagged_list_example\n\t  true\n\nfunction is_tagged_list(component, the_tag) {\n    return is_pair(component) && head(component) === the_tag;\n}\n```\n\n```javascript\ntagged_list_example\n\nis_tagged_list(list(\"name\", \"x\"), \"name\");\n```\n\nThe second element of the list that results from parsing a literal expression\nis its actual JavaScript value.\n\nThe selector for retrieving the value is\nliteral_value.\n\n```javascript\nliteral_value\n\t  literal_value_example\n\t  null\n\nfunction literal_value(component) {\n    return head(tail(component));\n}\n```\n\n```javascript\nliteral_value_example\n\nliteral_value(parse(\"null;\"));\n```\n\nIn the rest of this section, we just list the syntax predicates and selectors, and omit their declarations if they just access the obvious list\n\nelements.\n\nWe provide a constructor for literals, which will come in handy:\n\n```javascript\nmake_literal\n\nfunction make_literal(value) {\n    return list(\"literal\", value);\n}\n```",
    "token_count": 308,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Representing Components",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Representing_Components_2"
  },
  {
    "content": "We provide a constructor for literals, which will come in handy:\n\nThe tagged-list representation for\n\"name\" as first\nelement and the string representing the name as second element.\n\\begin{Parsing}\n\\ll\\ \\mathit{name}\\ \\gg & = &\n\\texttt{list(\"name\", }\\mathit{symbol}\\texttt{)}\n\\end{Parsing}%\nwhere symbol is a string\nthat contains the characters that make up the\nname as written in the program.\n\nThe syntax predicate for names is\nis_name.\n\n```javascript\nvariable\n\t      variable_example\n\t      tagged_list\n\nfunction is_name(component) {\n    return is_tagged_list(component, \"name\");\n}\n```\n\nThe symbol is accessed using the selector symbol_of_name.\n\n```javascript\nsymbol_of_name\n\t      variable_example\n\t      tagged_list\n\t      variable\n\nfunction symbol_of_name(component) {\n    return head(tail(component));\n}\n```\n\n```javascript\nvariable_example\n\nconst my_name_statement = parse(\"x;\");\ndisplay(is_name(my_name_statement));\ndisplay(symbol_of_name(my_name_statement));\n```\n\nWe provide a constructor for names, to be used by operator_combination_to_application :\n\n```javascript\nmake_name\n\t      variable_example\n\t      tagged_list\n\nfunction make_name(symbol) {\n    return list(\"name\", symbol);\n}\n```\n\nWe do not need to distinguish between expressions and parse can ignore the difference between the two kinds of components: \\begin{ParsingNoPostPadding} \\ll\\ \\mathit{expression}\\texttt{;}\\ \\gg &\n\n= & \\ll\\ \\mathit{expression}\\ \\gg \\end{ParsingNoPostPadding}\n\nFunction applications\n\n```javascript\n$\\ll\\ $fun-expr(arg-expr$_1$, $\\ldots$, arg-expr$_n$)$\\ \\gg$ =\n     list(\"application\",\n          $\\ll\\ $fun-expr$\\ \\gg$,\n          list($\\ll\\ $arg-expr$_1\\;\\gg$, $\\ldots$, $\\ll\\ $arg-expr$_n\\;\\gg$))\n```\n\nWe declare is_application as the syntax predicate and function_expression and arg_expressions as the selectors.\n\n```javascript\napplication\n      tagged_list\n      application_example\n\nfunction is_application(component) {\n   return is_tagged_list(component, \"application\");\n}\nfunction function_expression(component) {\n   return head(tail(component));\n}\nfunction arg_expressions(component) {\n   return head(tail(tail(component)));\n}\n```\n\n```javascript\napplication_example\n\nconst my_application = parse(\"math_pow(3, 4);\");\ndisplay(is_application(my_application));\ndisplay(function_expression(my_application));\nconst my_expressions = arg_expressions(my_application);\ndisplay(no_arg_expressions(my_expressions));\ndisplay(first_arg_expression(my_expressions));\ndisplay(rest_arg_expressions(my_expressions));\n```\n\nWe add a constructor for function applications, to be used by operator_combination_to_application :\n\n```javascript\nmake_application\n      variable\n      variable_example\n      tagged_list\n\nfunction make_application(function_expression, argument_expressions) {\n    return list(\"application\",\n                function_expression, argument_expressions);\n}\n```\n\nConditional expressions\n\n```javascript\n$\\ll\\ $predicate ? consequent-expression : alternative-expression$\\ \\gg$ =\n        list(\"conditional_expression\",\n             $\\ll\\ $predicate$\\ \\gg$,\n             $\\ll\\ $consequent-expression$\\ \\gg$,\n             $\\ll\\ $alternative-expression$\\ \\gg$)\n```\n\nSimilarly, conditional statements are parsed as follows:\n\n```javascript\n$\\ll\\ $if (predicate) consequent-block else alternative-block$\\ \\gg$ =\n        list(\"conditional_statement\",\n             $\\ll\\ $predicate$\\ \\gg$,\n             $\\ll\\ $consequent-block$\\ \\gg$,\n             $\\ll\\ $alternative-block$\\ \\gg$)\n```",
    "token_count": 311,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Representing Components",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Representing_Components_3"
  },
  {
    "content": "Similarly, conditional statements are parsed as follows:\n\nThe syntax predicate is_conditional returns true for both kinds of conditionals, and the selectors conditional_predicate , conditional_consequent , and conditional_alternative can be applied to both\n\nkinds.\n\n```javascript\nif\n\t      tagged_list\n\t      if_example\n\t      [ 'literal', [ 2, null ] ]\n\nfunction is_conditional(component) {\n    return is_tagged_list(component, \"conditional_expression\") ||\n           is_tagged_list(component, \"conditional_statement\");\n}\nfunction conditional_predicate(component) {\n   return list_ref(component, 1);\n}\nfunction conditional_consequent(component) {\n   return list_ref(component, 2);\n}\nfunction conditional_alternative(component) {\n   return list_ref(component, 3);\n}\n```\n\n```javascript\nif_example\n\nconst my_cond_expr =\n    parse(\"true ? 1 : 2;\");\ndisplay(is_conditional(my_cond_expr));\ndisplay(conditional_predicate(my_cond_expr));\ndisplay(conditional_consequent(my_cond_expr));\ndisplay(conditional_alternative(my_cond_expr));\n\nconst my_cond_expr =\n    parse(\"true ? 1 : 2;\");\nis_conditional(my_cond_expr);\nconditional_predicate(my_cond_expr);\nconditional_consequent(my_cond_expr);\nconditional_alternative(my_cond_expr);\n```\n\nA lambda expression\n\n```javascript\n$\\ll\\ $(name$_1$, $\\ldots$, name$_n$) => expression$\\ \\gg$ =\n    $\\ll\\ $(name$_1$, $\\ldots$, name$_n$) => { return expression; }$\\ \\gg$\n```\n\nA lambda expression whose body is a block is parsed as follows:\n\n```javascript\n$\\ll\\ $(name$_1$, $\\ldots$, name$_n$) => block$\\ \\gg$ =\n     list(\"lambda_expression\",\n          list($\\ll\\ $name$_1\\;\\gg$, $\\ldots$, $\\ll\\ $name$_n\\;\\gg$),\n          $\\ll\\ $block$\\ \\gg$)\n```\n\nThe syntax predicate is\nis_lambda_expression\nand the selector for the body of the lambda expression is\nlambda_body.\n\nThe selector for the parameters, called\nlambda_parameter_symbols ,\nadditionally extracts the symbols from the names.\n\n```javascript\nlambda\n\t      variable\n\t      symbol_of_name\n\t      tagged_list\n\t      lambda_example\n\nfunction lambda_parameter_symbols(component) {\n    return map(symbol_of_name, head(tail(component)));\n}\n\nfunction is_lambda_expression(component) {\n    return is_tagged_list(component, \"lambda_expression\");\n}\nfunction lambda_parameter_symbols(component) {\n    return map(symbol_of_name, head(tail(component)));\n}\nfunction lambda_body(component) {\n    return head(tail(tail(component)));\n}\n```\n\n```javascript\nlambda_example\n\nconst my_lambda = parse(\"x => x\");\ndisplay(is_lambda_expression(my_lambda));\ndisplay(lambda_parameter_symbols(my_lambda));\ndisplay(lambda_body(my_lambda));\n```\n\nThe function function_decl_to_constant_decl needs a constructor for lambda expressions:\n\n```javascript\nmake_lambda_expression\n\t      variable_example\n\t      tagged_list\n\t      variable\n\nfunction make_lambda_expression(parameters, body) {\n    return list(\"lambda_expression\", parameters, body);\n}\n```\n\nA sequence statement sequence of statements is parsed as follows:\n\n```javascript\n$\\ll\\ $statement$_1$ $\\cdots$ statement$_n\\;\\gg$ =\n     list(\"sequence\", list($\\ll\\ $statement$_1\\;\\gg$, $\\ldots$, $\\ll\\ $statement$_n\\;\\gg$))\n```\n\nThe syntax predicate is\nis_sequence and\nthe selector is sequence_statements.\n\nWe retrieve the first of a list of statements using\nfirst_statement and\nthe remaining statements using\nrest_statements.",
    "token_count": 309,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Representing Components",
    "chunk_index": 4,
    "chunk_id": "Metalinguistic_Abstraction_Representing_Components_4"
  },
  {
    "content": "We retrieve the first of a list of statements using\nfirst_statement and\nthe remaining statements using\nrest_statements.\n\nWe test\nwhether the list is empty using the predicate\nis_empty_sequence and\nwhether it contains only one element\nusing the predicate\nis_last_statement.\n\n```javascript\nbegin\n    tagged_list\n    begin_example\n    [ 'literal', [ 45, null ] ]\n\nfunction first_statement(stmts) { return head(stmts); }\n\nfunction rest_statements(stmts) { return tail(stmts); }\n\nfunction is_empty_sequence(stmts) { return is_null(stmts); }\n\nfunction is_last_statement(stmts) { return is_null(tail(stmts)); }\n\nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, \"sequence\");\n}\nfunction sequence_statements(stmt) {\n   return head(tail(stmt));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\n```\n\n```javascript\nbegin_example\n\nconst my_sequence = parse(\"1; true; 45;\");\ndisplay(is_sequence(my_sequence));\nconst my_actions = sequence_statements(my_sequence);\ndisplay(is_empty_sequence(my_actions));\ndisplay(is_last_statement(my_actions));\ndisplay(first_statement(my_actions));\ndisplay(rest_statements(my_actions));\n\nconst my_sequence = parse(\"1; true; 45;\");\nis_sequence(my_sequence);\nconst my_actions = sequence_statements(my_sequence);\nis_empty_sequence(my_actions);\nis_last_statement(my_actions);\nfirst_statement(my_actions);\nrest_statements(my_actions);\nlist_ref(rest_statements(my_actions), 1);\n```\n\nBlocks\n\\begin{Parsing}\n\\ll\\ \\texttt{\\{}\\ \\mathit{statements}\\ \\texttt{\\}}\\ \\gg\n& = &\n\\texttt{list(\"block\",}\\ \\ll\\ \\mathit{statements}\\ \\gg \\texttt{)}\n\\end{Parsing}%\nHere statements refers to a sequence of\nstatements, as shown above.\n\nThe syntax predicate is\nis_block\nand the selector is\nblock_body.\n\n```javascript\nblock\n\t      tagged_list\n\t      block_example\n\nfunction is_block(component) {\n    return is_tagged_list(component, \"block\");\n}\nfunction block_body(component) {\n    return head(tail(component));\n}\n\nfunction is_block(component) {\n    return is_tagged_list(component, \"block\");\n}\nfunction block_body(component) {\n    return head(tail(component));\n}\nfunction make_block(statement) {\n    return list(\"block\", statement);\n}\n```\n\n```javascript\nblock_example\n\nconst my_block = parse(\"{ 1; true; 45; }\");\ndisplay(is_block(my_block));\ndisplay(block_body(my_block));\n```\n\nReturn statements \\begin{Parsing} \\ll\\ \\textbf{\\texttt{return}}\\ \\mathit{expression} \\texttt{;}\\ \\gg & = & \\texttt{list(\"return_statement\",}\\ \\ll\\ \\mathit{expression}\\ \\gg \\texttt{)} \\end{Parsing}% The syntax predicate and selector are, respectively, is_return_statement\n\nand return_expression.\n\n```javascript\nreturn\n\t      tagged_list\n\t      return_example\n\t      [ 'name', [ 'x', null ] ]\n\nfunction is_return_statement(component) {\n   return is_tagged_list(component, \"return_statement\");\n}\nfunction return_expression(component) {\n   return head(tail(component));\n}\n```\n\n```javascript\nreturn_example\n\nconst my_function_declaration = parse(\"function f(x) { return x; }\");\nconst my_return = list_ref(my_function_declaration, 3);\nlist_ref(my_return, 1);\n```",
    "token_count": 306,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Representing Components",
    "chunk_index": 5,
    "chunk_id": "Metalinguistic_Abstraction_Representing_Components_5"
  },
  {
    "content": "and return_expression.\n\nAssignments\n\\begin{Parsing}\n\\ll\\;\\mathit{name} \\ \\texttt{=}\\ \\mathit{expression}\\;\\gg & = &\n\\texttt{list(\"assignment\",}\\ \\ll\\;\\mathit{name}\\;\\gg \\texttt{, }\\ll\\;\\mathit{expression}\\;\\gg \\texttt{)}\n\\end{Parsing}%\nThe syntax predicate is\nis_assignment\nand the selectors are\nassignment_symbol\nand\nassignment_value_expression.\n\nThe symbol is wrapped in a tagged list representing the name, and thus\nassignment_symbol needs to\nunwrap it.\n\n```javascript\nassignment\n      tagged_list\n      assignment_example\n      [ 'literal', [ 1, null ] ]\n\nfunction assignment_symbol(component) {\n    return symbol_of_name(head(tail(component))));\n}\n\nfunction is_assignment(component) {\n    return is_tagged_list(component, \"assignment\");\n}\nfunction assignment_symbol(component) {\n    return head(tail(head(tail(component))));\n}\nfunction assignment_value_expression(component) {\n    return head(tail(tail(component)));\n}\n```\n\n```javascript\nassignment_example\n\nconst my_assignment_statement = parse(\"x = 1;\");\ndisplay(assignment_symbol(my_assignment_statement));\ndisplay(assignment_value_expression(my_assignment_statement));\n\nconst my_assignment_statement = parse(\"x = 1;\");\nassignment_symbol(my_assignment_statement);\nassignment_value_expression(my_assignment_statement);\n```\n\nConstant and variable declarations\n\n```javascript\n$\\ll\\ $const name = expression;$\\ \\gg$ =\n     list(\"constant_declaration\", $\\ll\\ $name$\\ \\gg$, $\\ll\\ $expression$\\ \\gg$)\n\n$\\ll\\ $let name = expression;$\\ \\gg$ =\n     list(\"variable_declaration\", $\\ll\\ $name$\\ \\gg$, $\\ll\\ $expression$\\ \\gg$)\n```\n\nThe selectors declaration_symbol and declaration_value_expression apply to both kinds.\n\n```javascript\ndeclaration_symbol\n\t      tagged_list\n\t      definition_example\n\nfunction declaration_symbol(component) {\n    return symbol_of_name(head(tail(component)));\n}\nfunction declaration_value_expression(component) {\n    return head(tail(tail(component)));\n}\n```\n\nThe function function_decl_to_constant_decl needs a constructor for constant declarations:\n\n```javascript\nmake_constant_declaration\n\t      tagged_list\n\t      definition\n\t      definition_example\n\nfunction make_constant_declaration(name, value_expression) {\n    return list(\"constant_declaration\", name, value_expression);\n}\n```\n\nFunction declarations\n\n```javascript\n$\\ll\\ $function name(name$_1$, $\\ldots$ name$_n$) block$\\ \\gg$ =\n    list(\"function_declaration\",\n         $\\ll\\ $name$\\ \\gg$,\n         list($\\ll\\ $name$_1\\;\\gg$, $\\ldots$, $\\ll\\ $name$_n\\;\\gg$),\n         $\\ll\\ $block$\\ \\gg$)\n```\n\nThe syntax predicate\nis_function_declaration\nrecognizes these.\n\nThe selectors are\nfunction_declaration_name ,\nfunction_declaration_parameters , and\nfunction_declaration_body.\n\n```javascript\nfunction_declaration_syntax\n       tagged_list\n\nfunction is_function_declaration(component) {\n    return is_tagged_list(component, \"function_declaration\");\n}\nfunction function_declaration_name(component) {\n    return list_ref(component, 1);\n}\nfunction function_declaration_parameters(component) {\n    return list_ref(component, 2);\n}\nfunction function_declaration_body(component) {\n    return list_ref(component, 3);\n}\n```\n\nThe syntax predicate is_declaration returns true for all three kinds of declarations.\n\n```javascript\ndefinition\n\t      tagged_list\n\t      definition_example\n\nfunction is_declaration(component) {\n    return is_tagged_list(component, \"constant_declaration\") ||\n           is_tagged_list(component, \"variable_declaration\") ||\n           is_tagged_list(component, \"function_declaration\");\n}\n```\n\n```javascript\ndefinition_example\n\nconst my_declaration_statement = parse(\"let x = 1;\");\ndisplay(is_declaration(my_declaration_statement));\ndisplay(declaration_symbol(my_declaration_statement));\ndisplay(declaration_value_expression(my_declaration_statement));\n```\n\nSome evaluate transforms into a constant declaration whose value expression is a lambda expression.",
    "token_count": 315,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Representing Components",
    "chunk_index": 6,
    "chunk_id": "Metalinguistic_Abstraction_Representing_Components_6"
  },
  {
    "content": "Some evaluate transforms into a constant declaration whose value expression is a lambda expression.\n\n```javascript\nfunction_declaration\n\t  tagged_list\n\nfunction function_decl_to_constant_decl(component) {\n    return make_constant_declaration(\n               function_declaration_name(component),\n               make_lambda_expression(\n                   function_declaration_parameters(component),\n                   function_declaration_body(component)));\n}\n\nfunction is_function_declaration(component) {\n    return is_tagged_list(component, \"function_declaration\");\n}\nfunction function_declaration_name(component) {\n    return list_ref(component, 1);\n}\nfunction function_declaration_parameters(component) {\n    return list_ref(component, 2);\n}\nfunction function_declaration_body(component) {\n    return list_ref(component, 3);\n}\nfunction function_decl_to_constant_decl(component) {\n    return make_constant_declaration(\n               function_declaration_name(component),\n               make_lambda_expression(\n                   function_declaration_parameters(component),\n                   function_declaration_body(component)));\n}\n```\n\nImplementing the evaluation of function declarations in this way simplifies the evaluator because it reduces the number of syntactic forms for which the evaluation process\n\nmust be explicitly specified.\n\nSimilarly, we define\n\n```javascript\n$\\ll\\ $unary-operator expression$\\ \\gg$ =\n     list(\"unary_operator_combination\",\n          \"unary-operator\",\n          list($\\ll\\ $expression$\\ \\gg$))\n```\n\nwhere unary-operator is\n!\n\n(for logical negation) or\n-unary (for numeric negation), and\n\n```javascript\n$\\ll\\ $expression$_1$ binary-operator expression$_2\\;\\gg$ =\n     list(\"binary_operator_combination\",\n          \"binary-operator\",\n          list($\\ll\\ $expression$_1\\;\\gg$, $\\ll\\ $expression$_2\\;\\gg$))\n```\n\nwhere binary-operator is\n+ ,\n- ,\n* ,\n/ ,\n% ,\n=== ,\n!== ,\n> ,\n< ,\n>= or\n<=.\n\nThe syntax predicates are\nis_operator_combination ,\nis_unary_operator_combination , and\nis_binary_operator_combination ,\nand the selectors are\noperator_symbol ,\nfirst_operand , and\nsecond_operand.\n\n```javascript\noperator_combination\n\nfunction is_operator_combination(component) {\n    return is_unary_operator_combination(component) ||\n           is_binary_operator_combination(component);\n}\nfunction is_unary_operator_combination(component) {\n    return is_tagged_list(component, \"unary_operator_combination\");\n}\nfunction is_binary_operator_combination(component) {\n    return is_tagged_list(component, \"binary_operator_combination\");\n}\nfunction operator_symbol(component) {\n    return list_ref(component, 1);\n}\nfunction first_operand(component) {\n    return list_ref(component, 2);\n}\nfunction second_operand(component) {\n    return list_ref(component, 3);\n}\n```\n\nThe evaluator uses operator_combination_to_application to transform an\n\n```javascript\noperator_combination_to_application\n\t  operator_combination\n\t  make_application\n\nfunction operator_combination_to_application(component) {\n    const operator = operator_symbol(component);\n    return is_unary_operator_combination(component)\n           ? make_application(make_name(operator),\n                              list(first_operand(component)))\n           : make_application(make_name(operator),\n                              list(first_operand(component),\n                                   second_operand(component)));\n}\n```\n\nComponents (such as function declarations and operator combinations) that we\nchoose\nto implement as syntactic transformations are called\nderived components.\n\nLogical composition operations are also\nderived components (see exercise ).\n\nFor example, recall the imperative-style version of the iterative factorial function from section :",
    "token_count": 300,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Representing Components",
    "chunk_index": 7,
    "chunk_id": "Metalinguistic_Abstraction_Representing_Components_7"
  },
  {
    "content": "For example, recall the imperative-style version of the iterative factorial function from section :\n\n```javascript\nfactorial_imperative_2\n\t    factorial_example\n\t    120\n\nfunction factorial(n) {\n    let product = 1;\n    let counter = 1;\n    function iter() {\n        if (counter > n) {\n            return product;\n        } else {\n            product = counter * product;\n            counter = counter + 1;\n            return iter();\n        }\n    }\n    return iter();\n}\n```\n\n\\newpage\\noindent We can formulate the same algorithm using a while loop as follows:\n\n```javascript\nfactorial_with_loop\n\nfunction factorial(n) {\n    let product = 1;\n    let counter = 1;\n    while (counter <= n) {\n        product = counter * product;\n        counter = counter + 1;\n    }\n    return product;\n}\n```\n\nWhile loops are parsed as follows:\n\n```javascript\n$\\ll\\ $while (predicate) block$\\ \\gg$ =\n        list(\"while_loop\", $\\ll\\ $predicate$\\ \\gg$, $\\ll\\ $block$\\ \\gg$)\n```\n\nFor such a program, JavaScript\nstatically\ndistinguishes between value-producing and\nnon-value-producing statements.\n\n(Here\nstatically means that\nwe can make the distinction by inspecting the program\nrather than by running it.)\nAll declarations are\nnon-value-producing, and all\nStatements and conditional statements are\nvalue-producing.\n\nThe value of an statement is the value of the expression.\n\nThe value of a conditional statement is the value of the branch that\ngets executed, or the value\nundefined if that branch is\nnot value-producing.\n\nA block is value-producing if its body (sequence of statements)\nis value-producing, and then its value is the value of its body.\n\nA sequence is value-producing if any of\nits component statements is value-producing, and then its value is\nthe value of its last value-producing component statement.\n\nFinally, if the whole\nprogram is not value-producing, its value is the value\nundefined.\n-\n-\nAccording to this specification, what are the values of the\nfollowing four programs?",
    "token_count": 281,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Representing Components",
    "chunk_index": 8,
    "chunk_id": "Metalinguistic_Abstraction_Representing_Components_8"
  },
  {
    "content": "Finally, if the whole\nprogram is not value-producing, its value is the value\nundefined.\n-\n-\nAccording to this specification, what are the values of the\nfollowing four programs?\n\n```javascript\n1; 2; 3;\n\n1; { if (true) {} else { 2; } }\n\n1; const x = 2;\n\n1; { let x = 2; { x = x + 3; } }\n```\n\n- - Modify the evaluator to adhere to this specification.",
    "token_count": 73,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Representing Components",
    "chunk_index": 9,
    "chunk_id": "Metalinguistic_Abstraction_Representing_Components_9"
  },
  {
    "content": "Given the evaluator, we have in our hands a description\n(expressed in JavaScript)\nof the process by which\nJavaScript statements and expressions\nare evaluated.\n\nOne advantage of expressing the evaluator as a program is\nthat we can run the program.\n\nThis gives us, running within\nJavaScript,\na working model of how\nJavaScript\nitself evaluates expressions.\n\nThis can serve as a framework for\nexperimenting with evaluation rules, as we shall do later in this chapter.\n\nOur evaluator program reduces expressions ultimately to the application of\nprimitive\nfunctions.\n\nTherefore, all that we need to run the evaluator is to create a mechanism\nthat calls on the underlying\nJavaScript\nsystem to model the application of primitive\nfunctions.\n\nThere must be a binding for each primitive function name and operator, so that when evaluate evaluates the function expression of an application of a\n\nprimitive, it will find an object to pass to functions and operators that can appear in the expressions we will be evaluating.\n\n```javascript\nThe global environment also includes bindings for\n\tundefined\n\tand other names,\n```\n\nso that they can be used as constants in expressions to be evaluated.\n\n```javascript\nheadline_4_1_4\n\n// functions from SICP JS 4.1.4\n```\n\n```javascript\nsetup_environment\n      setup_environment_example\n      tagged_list\n      extend_environment\n      enclosing_environment\n      make_frame\n      primitive_constants\n      primitive_procedures\n      primitive_procedure\n      '/'\n\nfunction setup_environment() {\n    return extend_environment(append(primitive_function_symbols,\n                                     primitive_constant_symbols),\n                              append(primitive_function_objects,\n                                     primitive_constant_values),\n                              the_empty_environment);\n}\n```\n\n```javascript\nsetup_environment_example\n\nconst the_global_environment = setup_environment();\n\nthe_global_environment;\n\nconst the_global_environment = setup_environment();\n\nlist_ref(head(head(the_global_environment)), 12);\n```\n\n```javascript\nthe_global_environment\n      setup_environment\n      the_global_environment_example\n\nconst the_global_environment = setup_environment();\n```\n\n```javascript\nthe_global_environment_example\n\nthe_global_environment;\n```\n\nIt does not matter how we represent primitive function objects, so long\nas is_primitive_function\nand apply_primitive_function.\n\nWe\nhave chosen to represent a primitive function as a list beginning with\nthe string \"primitive\" and\ncontaining a function in the underlying JavaScript that implements that\nprimitive.\n\n```javascript\nprimitive_procedure\n\t  tagged_list\n\t  primitive_procedure_example\n\t  true\n\nfunction is_primitive_function(fun) {\n    return is_tagged_list(fun, \"primitive\");\n}\n\nfunction primitive_implementation(fun) { return head(tail(fun)); }\n```",
    "token_count": 308,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Running the Evaluator as a Program",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Running_the_Evaluator_as_a_Program_1"
  },
  {
    "content": "We\nhave chosen to represent a primitive function as a list beginning with\nthe string \"primitive\" and\ncontaining a function in the underlying JavaScript that implements that\nprimitive.\n\n```javascript\nprimitive_procedure_example\n\nconst my_primitive_plus =\n    list(\"primitive\", (x, y) => x + y );\ndisplay(is_primitive_function(my_primitive_plus));\ndisplay(primitive_implementation(my_primitive_plus));\n\nconst my_primitive_plus =\n    list(\"primitive\", (x, y) => x + y );\nprimitive_implementation(my_primitive_plus);\nis_primitive_function(my_primitive_plus);\n```\n\n```javascript\nThe function\n      setup_environment\n```\n\nwill get the primitive names and implementation functions from a list:\n\n```javascript\nprimitive_procedures\n      primitive_procedures_example\n      20\n\nconst primitive_functions = list(list(\"head\",    head             ),\n                                 list(\"tail\",    tail             ),\n                                 list(\"pair\",    pair             ),\n                                 list(\"is_null\", is_null          ),\n                                 list(\"+\",       (x, y) => x + y  ),\n                                 more primitive functions\n                                );\n\nconst primitive_function_symbols =\n    map(f => head(f), primitive_functions);\n\nconst primitive_function_objects =\n    map(f => list(\"primitive\", head(tail(f))),\n        primitive_functions);\n\nconst primitive_functions = list(\n       list(\"head\",    head             ),\n       list(\"tail\",    tail             ),\n       list(\"pair\",    pair             ),\n       list(\"list\",    list             ),\n       list(\"is_null\", is_null          ),\n       list(\"display\", display          ),\n       list(\"error\",   error            ),\n       list(\"math_abs\",math_abs         ),\n       list(\"+\",       (x, y) => x + y  ),\n       list(\"-\",       (x, y) => x - y  ),\n       list(\"-unary\",   x     =>   - x  ),\n       list(\"*\",       (x, y) => x * y  ),\n       list(\"/\",       (x, y) => x / y  ),\n       list(\"%\",       (x, y) => x % y  ),\n       list(\"===\",     (x, y) => x === y),\n       list(\"!==\",     (x, y) => x !== y),\n       list(\"<\",       (x, y) => x <   y),\n       list(\"<=\",      (x, y) => x <=  y),\n       list(\">\",       (x, y) => x >   y),\n       list(\">=\",      (x, y) => x >=  y),\n       list(\"!\",        x     =>   !   x)\n       );\nconst primitive_function_symbols =\n    map(head, primitive_functions);\nconst primitive_function_objects =\n    map(fun => list(\"primitive\", head(tail(fun))),\n        primitive_functions);\n```\n\n```javascript\nprimitive_procedures_example\n\nprimitive_functions;\n\nlength(primitive_functions);\n```\n\nSimilar to primitive functions, we define other primitive constants that are installed in the global environment by the function setup_environment.",
    "token_count": 279,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Running the Evaluator as a Program",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Running_the_Evaluator_as_a_Program_2"
  },
  {
    "content": "Similar to primitive functions, we define other primitive constants that are installed in the global environment by the function setup_environment.\n\n```javascript\nprimitive_constants\n\t  primitive_constants_example\n\t  5\n\nconst primitive_constants = list(list(\"undefined\", undefined),\n                                 list(\"math_PI\",   math_PI)\n                                 more primitive constants\n                                );\n\nconst primitive_constant_symbols =\n    map(c => head(c), primitive_constants);\n\nconst primitive_constant_values =\n    map(c => head(tail(c)), primitive_constants);\n\nconst primitive_constants = list(list(\"undefined\", undefined),\n                                 list(\"Infinity\",  Infinity),\n                                 list(\"math_PI\",   math_PI),\n                                 list(\"math_E\",    math_E),\n                                 list(\"NaN\",       NaN)\n                                );\nconst primitive_constant_symbols =\n    map(c => head(c), primitive_constants);\nconst primitive_constant_values =\n    map(c => head(tail(c)), primitive_constants);\n```\n\n```javascript\nprimitive_constants_example\n\nprimitive_constants;\n\nlength(primitive_constants);\n```\n\nTo apply a primitive function, we simply apply the implementation function to the arguments, using the underlying JavaScript system:\n\n```javascript\napply_primitive_procedure\n      apply_primitive_procedure_example\n      3\n\nfunction apply_primitive_function(fun, arglist) {\n    return apply_in_underlying_javascript(\n               primitive_implementation(fun), arglist);\n}\n```\n\n```javascript\napply_primitive_procedure_example\n      primitive_procedure\n      primitive_procedure_example\n\napply_primitive_function(my_primitive_plus, list(1, 2));\n```",
    "token_count": 124,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Running the Evaluator as a Program",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Running_the_Evaluator_as_a_Program_3"
  },
  {
    "content": "To apply a primitive function, we simply apply the implementation function to the arguments, using the underlying JavaScript system:\n\n```javascript\nFor convenience in running the metacircular evaluator, we provide a\n\tdriver loop that models the read-evaluate-print loop of\n\tthe underlying JavaScript system. It prints a\n\tprompt and reads an input program as a string.\n\tIt transforms the program string\n\tinto a tagged-list representation of the statement as described in\n\tsectiona\n\tprocess called parsing and accomplished by the primitive function\n\tparse.\n\tWe precede each printed result by\n\tan output prompt so as to distinguish the value of the\n\tprogram from other output that may be printed. The driver loop gets\n\tthe program environment of the previous program as argument.\n\tAs described at the end of section, the\n\tdriver loop treats the program as if it were in a block: It\n\tscans out the declarations, extends the given environment by a frame\n\tcontaining a binding of each name to\n\t\"*unassigned*\", and evaluates\n\tthe program with respect to the extended environment, which\n\tis then passed as argument to the next iteration of the driver loop.\n\n\t  driver_loop\n\t  functions_4_1_1\n\t  functions_4_1_2\n\t  functions_4_1_3\n\t  functions_4_1_4\n\t  user_print\n\t  user_read\n\t  driver_loop_example\n\nconst input_prompt = \"M-evaluate input: \";\nconst output_prompt = \"M-evaluate value: \";\n\nfunction driver_loop(env) {\n    const input = user_read(input_prompt);\n    if (is_null(input)) {\n       display(\"evaluator terminated\");\n    } else {\n       const program = parse(input);\n       const locals = scan_out_declarations(program);\n       const unassigneds = list_of_unassigned(locals);\n       const program_env = extend_environment(locals, unassigneds, env);\n       const output = evaluate(program, program_env);\n       user_print(output_prompt, output);\n       return driver_loop(program_env);\n    }\n}\n\nconst input_prompt = \"\\nM-evaluate input:\\n\";\nconst output_prompt = \"\\nM-evaluate value:\\n\";\n\nfunction driver_loop(env, history) {\n    const input = user_read(history);\n    if (is_null(input)) {\n        display(\"\", history + \"\\n--- session end ---\\n\");\n    } else {\n        const program = parse(input);\n        const locals = scan_out_declarations(program);\n        const unassigneds = list_of_unassigned(locals);\n        const program_env = extend_environment(\n                                locals, unassigneds, env);\n        const output = evaluate(program, program_env);\n        const new_history = history +\n              input_prompt +\n              input +\n              output_prompt +\n              to_string(output);\n        return driver_loop(program_env, new_history);\n    }\n}\n\n\"metacircular evaluator loaded\";\n```",
    "token_count": 322,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Running the Evaluator as a Program",
    "chunk_index": 4,
    "chunk_id": "Metalinguistic_Abstraction_Running_the_Evaluator_as_a_Program_4"
  },
  {
    "content": "To apply a primitive function, we simply apply the implementation function to the arguments, using the underlying JavaScript system:\n\n```javascript\nWe use JavaScript's prompt function\n\tto request and read the input string from the user:\n\n\t  user_read\n\nfunction user_read(prompt_string) {\n    return prompt(prompt_string);\n}\n```\n\nThe function\nprompt returns\nnull when the user cancels the\ninput.\n\nWe use a special printing\nfunction user_print,\nto avoid printing the environment part of a compound\nfunction,\nwhich may be a very long list (or may even contain cycles).\n\n```javascript\nuser_print\n      user_print_example\n\nfunction user_print(string, object) {\n    function prepare(object) {\n        return is_compound_function(object)\n               ? \"< compound-function >\"\n               : is_primitive_function(object)\n               ? \"< primitive-function >\"\n               : is_pair(object)\n               ? pair(prepare(head(object)),\n                      prepare(tail(object)))\n               : object;\n    }\n    display(string + \" \" + stringify(prepare(object)));\n}\n\nfunction to_string(object) {\n    return is_compound_function(object)\n           ? \"<compound-function>\"\n           : is_primitive_function(object)\n           ? \"<primitive-function>\"\n           : is_pair(object)\n           ? \"[\" + to_string(head(object)) + \", \"\n                 + to_string(tail(object)) + \"]\"\n           : stringify(object);\n}\n\nfunction user_print(prompt_string, object) {\n    display(\"----------------------------\",\n            prompt_string + \"\\n\" + to_string(object) + \"\\n\");\n}\n```\n\n```javascript\nuser_print_example\n      functions_4_1_1\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nuser_print(\"output: \",\n           evaluate(parse(\"1 + 2;\"),\n                    the_global_environment));\n```\n\nNow all we need to do to run the evaluator is to initialize the global\nenvironment and start the driver loop.\n\nHere is a sample interaction:\n\n```javascript\ndriver_loop_example\n      driver_loop\n\nconst the_global_environment = setup_environment();\ndriver_loop(the_global_environment);\n\ndriver_loop(the_global_environment, \"--- session start ---\");\n```\n\n```javascript\nmeta_append\n      driver_loop\n      driver_loop_example\n\nM-evaluate input:\n\nfunction append(xs, ys) {\n    return is_null(xs)\n           ? ys\n           : pair(head(xs), append(tail(xs), ys));\n}\n\n// press \"Run\" to start the driver loop\n// M-evaluate input:\n// function append(xs, ys) { return is_null(xs) ? ys : pair(head(xs), append(tail(xs), ys)); }\n// M-evaluate value:\n// undefined\n\n// M-evaluate input:\n// append(list(\"a\", \"b\", \"c\"), list(\"d\", \"e\", \"f\"));\n// M-evaluate value:\n// [\"a\", [\"b\", [\"c\", [\"d\", [\"e\", [\"f\", null]]]]]]\n```",
    "token_count": 285,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Running the Evaluator as a Program",
    "chunk_index": 5,
    "chunk_id": "Metalinguistic_Abstraction_Running_the_Evaluator_as_a_Program_5"
  },
  {
    "content": "Here is a sample interaction:\n\n```javascript\nmeta_append_example\n      driver_loop\n      driver_loop_example\n\nM-evaluate input:\n\nappend(list(\"a\", \"b\", \"c\"), list(\"d\", \"e\", \"f\"));\n\n// press \"Run\" to start the driver loop\n// M-evaluate input:\n// function append(xs, ys) { return is_null(xs) ? ys : pair(head(xs), append(tail(xs), ys)); }\n// M-evaluate value:\n// undefined\n\n// M-evaluate input:\n// append(list(\"a\", \"b\", \"c\"), list(\"d\", \"e\", \"f\"));\n// M-evaluate value:\n// [\"a\", [\"b\", [\"c\", [\"d\", [\"e\", [\"f\", null]]]]]]\n```",
    "token_count": 69,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Running the Evaluator as a Program",
    "chunk_index": 6,
    "chunk_id": "Metalinguistic_Abstraction_Running_the_Evaluator_as_a_Program_6"
  },
  {
    "content": "The evaluator implemented above is simple, but it is very\ncomponents\nis interleaved\nwith their execution.\n\nThus if a program is executed many times, its\nsyntax is analyzed many times.\n\nConsider, for example, evaluating\nfactorial(4)\nusing the following definition of\n\n```javascript\nfactorial_4_1_7\n      factorial_example\n      120\n\nfunction factorial(n) {\n    return n === 1\n           ? 1\n           : factorial(n - 1) * n;\n}\n```\n\nEach time\na conditional\nexpression and extract the predicate.\n\nOnly then can it evaluate the\npredicate and dispatch on its value.\n\nEach time it evaluates the expression\nfactorial(n - 1) * n,\nor the subexpressions\nfactorial(n - 1)\nand\nn - 1,\nthe evaluator must perform the case analysis in\nevaluate\nto determine that the expression is an application, and must extract\nits function expression and argument expressions.\n\nThis analysis is expensive.\n\nPerforming it repeatedly is wasteful.\n\nWe can transform the evaluator to be significantly more efficient by\narranging things so that syntactic analysis is performed only\nonce.\nevaluate,\nwhich takes\na component\nand an environment, into two parts.\n\nThe\nfunction\ncomponent.\n\nIt performs the syntactic\nanalysis and returns a new\nfunction , the\nexecution\nfunction , that\nencapsulates the work to be done in executing the analyzed\ncomponent.\n\nThe execution\nfunction\ntakes an environment as its\nargument and completes the evaluation.\n\nThis saves work because\na component,\nwhile the execution\nfunction\nmay be called many times.\n\nWith the separation into analysis and execution, evaluate now becomes\n\n```javascript\nanalyze_headline\n\n// functions from SICP JS 4.1.7\n```\n\n```javascript\nevaluate_4_1_7\n      analyze\n      evaluate_4_1_7_simple_function\n\nfunction evaluate(component, env) {\n    return analyze(component)(env);\n}\n```\n\n```javascript\nevaluate_4_1_7_simple_function\n      evaluate_4_1_7\n      5\n\nevaluate(parse(\"{ function f(x) { return x + 1; } f(4); }\"),\n         the_global_environment);\n```\n\nThe result of calling\nfunction\nto be applied to the environment.",
    "token_count": 287,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Separating Syntactic Analysis from Execution",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_Separating_Syntactic_Analysis_from_Execution_1"
  },
  {
    "content": "The result of calling\nfunction\nto be applied to the environment.\n\nThe\nfunction\nis the same case analysis as performed by the original\nevaluate\nof section , except that the\nfunctions\nto which we dispatch perform only analysis, not full evaluation:\n\n```javascript\nanalyze_example\n\nanalyze(parse(\"{ const x = 1; x + 1; }\"))\n       (the_global_environment);\n```\n\n```javascript\nanalyze\n      headline_4_1_1\n      list_of_unassigned\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n      analyze_headline\n      analyze_literal\n      analyze_variable\n      analyze_assignment\n      analyze_if\n      scan_out_declarations\n      analyze_lambda\n      analyze_sequence\n      analyze_block\n      analyze_return_statement\n      analyze_application\n      analyze_example\n      2\n\nfunction analyze(component) {\n    return is_literal(component)\n           ? analyze_literal(component)\n           : is_name(component)\n           ? analyze_name(component)\n           : is_application(component)\n           ? analyze_application(component)\n           : is_operator_combination(component)\n           ? analyze(operator_combination_to_application(component))\n           : is_conditional(component)\n           ? analyze_conditional(component)\n           : is_lambda_expression(component)\n           ? analyze_lambda_expression(component)\n           : is_sequence(component)\n           ? analyze_sequence(sequence_statements(component))\n           : is_block(component)\n           ? analyze_block(component)\n           : is_return_statement(component)\n           ? analyze_return_statement(component)\n           : is_function_declaration(component)\n           ? analyze(function_decl_to_constant_decl(component))\n           : is_declaration(component)\n           ? analyze_declaration(component)\n           : is_assignment(component)\n           ? analyze_assignment(component)\n           : error(component, \"unknown syntax -- analyze\");\n}\n```\n\nHere is the simplest syntactic analysis\n\n```javascript\nfunction,\n\twhich handles literal expressions.\n```\n\nIt returns an execution function that ignores its environment argument and just returns the value of the literal:\n\n```javascript\nanalyze_literal_example\n\n// null is the empty environment (not used here)\nanalyze_literal(parse(\"true;\"))(null);\n```\n\n```javascript\nanalyze_literal\n      functions_4_1_2\n      analyze_literal_example\n      true\n\nfunction analyze_literal(component) {\n    return env => literal_value(component);\n}\n```\n\nLooking up the value of a name must still be done in the execution phase, since this depends upon knowing the environment.\n\n```javascript\nanalyze_variable_example\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nanalyze_name(parse(\"myname;\"))\n (extend_environment(list(\"myname\"), list(1),\n                     the_global_environment));\n```\n\n```javascript\nanalyze_variable\n      analyze_variable_example\n      1\n\nfunction analyze_name(component) {\n    return env => lookup_symbol_value(symbol_of_name(component), env);\n}\n```\n\nFor conditionals, we extract and analyze the predicate, consequent, and alternative at analysis time.\n\n```javascript\nanalyze_if_example\n\t  analyze\n\nanalyze_conditional(parse(\"true ? 3 : 7;\"))\n   (the_global_environment);\n```\n\n```javascript\nanalyze_if\n\t  analyze_if_example\n\t  3\n\nfunction analyze_conditional(component) {\n    const pfun = analyze(conditional_predicate(component));\n    const cfun = analyze(conditional_consequent(component));\n    const afun = analyze(conditional_alternative(component));\n    return env => is_truthy(pfun(env)) ? cfun(env) : afun(env);\n}\n```\n\nAnalyzing a lambda expression also achieves a major gain in efficiency: We analyze the lambda body only once, even though functions resulting from evaluation of",
    "token_count": 315,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Separating Syntactic Analysis from Execution",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_Separating_Syntactic_Analysis_from_Execution_2"
  },
  {
    "content": "Analyzing a lambda expression also achieves a major gain in efficiency: We analyze the lambda body only once, even though functions resulting from evaluation of\n\nthe lambda expression may be applied many times.\n\n```javascript\nanalyze_lambda_example\n\t  analyze\n\nlist_ref(analyze_lambda_expression(parse(\"x => x;\"))\n         (the_global_environment),\n         2)\n        (extend_environment(list(\"x\"), list(7),\n                            the_global_environment));\n```\n\n```javascript\nanalyze_lambda\n\t  analyze_lambda_example\n\t  [ 'return_value', [ 7, null ] ]\n\nfunction analyze_lambda_expression(component) {\n    const params = lambda_parameter_symbols(component);\n    const bfun = analyze(lambda_body(component));\n    return env => make_function(params, bfun, env);\n}\n```\n\nAnalysis of a sequence of statements is more involved.\n\n```javascript\nanalyze_sequence_example\n\t  analyze\n\nanalyze_sequence(sequence_statements(parse(\"10; 20; 30;\")))\n   (the_global_environment);\n```\n\n```javascript\nanalyze_sequence\n\t  analyze_sequence_example\n\t  30\n\nfunction analyze_sequence(stmts) {\n    function sequentially(fun1, fun2) {\n        return env => {\n                   const fun1_val = fun1(env);\n                   return is_return_value(fun1_val)\n                          ? fun1_val\n                          : fun2(env);\n               };\n    }\n    function loop(first_fun, rest_funs) {\n        return is_null(rest_funs)\n               ? first_fun\n               : loop(sequentially(first_fun, head(rest_funs)),\n                      tail(rest_funs));\n    }\n    const funs = map(analyze, stmts);\n    return is_null(funs)\n           ? env => undefined\n           : loop(head(funs), tail(funs));\n}\n```\n\nThe body of a\nblock is scanned only once for local declarations.\n\nThe bindings are installed in the environment when\nthe execution function for the block is called.\n\n```javascript\nanalyze_block_example\n\t  analyze\n\nanalyze_block(parse(\"{ const x = 4; x; }\"))\n   (the_global_environment);\n```\n\n```javascript\nanalyze_block\n\t  list_of_unassigned\n\t  analyze_block_example\n\t  4\n\nfunction analyze_block(component) {\n    const body = block_body(component);\n    const bfun = analyze(body);\n    const locals = scan_out_declarations(body);\n    const unassigneds = list_of_unassigned(locals);\n    return env => bfun(extend_environment(locals, unassigneds, env));\n}\n```\n\nFor return statements, we analyze the return expression.\n\nThe execution function for the return statement simply calls\nthe execution function for the return expression and wraps\nthe result in a return value.\n\n```javascript\nanalyze_return_statement_example\n\t  analyze\n\nanalyze_return_statement(list_ref(parse(\"() => x + 1;\"), 2))\n   (extend_environment(list(\"x\"), list(6), the_global_environment));\n```\n\n```javascript\nanalyze_return_statement\n\t  analyze_return_statement_example\n\t  [ 'return_value', [ 7, null ] ]\n\nfunction analyze_return_statement(component) {\n    const rfun = analyze(return_expression(component));\n    return env => make_return_value(rfun(env));\n}\n```\n\n```javascript\nThe function\n      analyze_assignment\n```\n\nmust defer actually setting the variable until the execution, when the\nenvironment has been supplied.",
    "token_count": 307,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Separating Syntactic Analysis from Execution",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_Separating_Syntactic_Analysis_from_Execution_3"
  },
  {
    "content": "must defer actually setting the variable until the execution, when the\nenvironment has been supplied.\n\nHowever, the fact that the\nassignment-value expression\ncan be analyzed (recursively) during analysis is a major gain in\nefficiency, because the\nassignment-value expression\nwill now be analyzed only once.\n\nThe same holds true for\nconstant and variable declarations.\n\n```javascript\nanalyze_assignment_example\n      analyze\n\nanalyze_assignment(parse(\"x = x + 1;\"))\n   (extend_environment(list(\"x\"), list(7), the_global_environment));\n```\n\n```javascript\nanalyze_assignment\n      analyze_assignment_example\n      8\n\nfunction analyze_assignment(component) {\n    const symbol = assignment_symbol(component);\n    const vfun = analyze(assignment_value_expression(component));\n    return env => {\n               const value = vfun(env);\n               assign_symbol_value(symbol, value, env);\n               return value;\n           };\n}\nfunction analyze_declaration(component) {\n    const symbol = declaration_symbol(component);\n    const vfun = analyze(declaration_value_expression(component));\n    return env => {\n               assign_symbol_value(symbol, vfun(env), env);\n               return undefined;\n           };\n}\n```\n\nOur new evaluator uses the same data structures, syntax functions, and runtime support functions as in sections , , and.",
    "token_count": 138,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "Separating Syntactic Analysis from Execution",
    "chunk_index": 4,
    "chunk_id": "Metalinguistic_Abstraction_Separating_Syntactic_Analysis_from_Execution_4"
  },
  {
    "content": "The The evaluation functions: evaluate and\n\nThe function evaluate takes as arguments\n\n```javascript\na program componenta statement or\n\texpressionand an environment.\n```\n\nIt classifies the\ncomponent\nand directs its evaluation.\n\nThe function evaluate\nis structured as a case analysis of the syntactic type of the\ncomponent\nto be evaluated.\n\nIn order to keep the\nfunction\ngeneral, we express\nthe determination of the type of\na component\nabstractly, making no\ncommitment to any particular\ncomponents.\n\nEach type of\ncomponent\nhas a\nsyntax predicate\nthat tests for it and an abstract means for selecting its parts.\n\nThis\nabstract syntax\nmakes it easy to see how we can change the syntax of the language by\nusing the same evaluator, but with a different collection of syntax\nfunctions.",
    "token_count": 124,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "The Core of the Evaluator",
    "chunk_index": 1,
    "chunk_id": "Metalinguistic_Abstraction_The_Core_of_the_Evaluator_1"
  },
  {
    "content": "This\nabstract syntax\nmakes it easy to see how we can change the syntax of the language by\nusing the same evaluator, but with a different collection of syntax\nfunctions.\n\n```javascript\nFor\n\t    evaluate\n\t    returns their value.\n\n\t    The function\n\t    evaluate\n\t    must look up names in the environment to find their values.\n\n\t  Combinations\n\n\t    For a function application,\n\t    evaluate must recursively\n\t    evaluate the function expression and the argument expressions of the\n\t    application.  The resulting function and arguments are passed to\n\n\t    An operator combination is transformed into a function application\n\t    and then evaluated.\n\n\t  Syntactic forms\n\n\t    A conditional expression or statement requires special processing of\n\t    its parts,\n\t    so as to evaluate the consequent if the predicate is true, and\n\t    otherwise to evaluate the alternative.\n\n\t    A lambda expression must be transformed into an applicable\n\t    function by packaging together the parameters and body specified\n\t    by the lambda expression with the environment of the evaluation.\n\n\t    A sequence of statements requires evaluating its\n\t    components in the order in which they appear.\n\n\t    A block requires evaluating its body in a new environment\n\t    that reflects all names declared within the block.\n\n\t    A return statement must produce a value that becomes the\n\t    result of the function call that gave rise to the\n\t    evaluation of the return statement.\n\n\t    A function declaration is transformed into a\n\t    constant declaration and then evaluated.\n\n\t    A constant or variable declaration or an assignment must\n\t    call\n\t    evaluate\n\t    recursively to compute the new\n\t    value to be associated with the name being declared or assigned.\n\t    The environment must be\n\t    modified to reflect the new value of the name.\n\n\tHere is the declaration of\n\tevaluate:\n\n\t  headline_4_1_1\n\n// functions from SICP JS 4.1.1\n\n\t  eval\n\t  eval_example\n\t  3\n\nfunction evaluate(component, env) {\n    return is_literal(component)\n           ? literal_value(component)\n           : is_name(component)\n           ? lookup_symbol_value(symbol_of_name(component), env)\n           : is_application(component)\n           ? apply(evaluate(function_expression(component), env),\n                   list_of_values(arg_expressions(component), env))\n           : is_operator_combination(component)\n           ? evaluate(operator_combination_to_application(component),\n                      env)\n           : is_conditional(component)\n           ? eval_conditional(component, env)\n           : is_lambda_expression(component)\n           ? make_function(lambda_parameter_symbols(component),\n                           lambda_body(component), env)\n           : is_sequence(component)\n           ? eval_sequence(sequence_statements(component), env)\n           : is_block(component)\n           ? eval_block(component, env)\n           : is_return_statement(component)\n           ? eval_return_statement(component, env)\n           : is_function_declaration(component)\n           ? evaluate(function_decl_to_constant_decl(component), env)\n           : is_declaration(component)\n           ? eval_declaration(component, env)\n           : is_assignment(component)\n           ? eval_assignment(component, env)\n           : error(component, \"unknown syntax -- evaluate\");\n}\n\n\t  eval_example\n\t  functions_4_1_1\n\t  functions_4_1_2\n\t  functions_4_1_3\n\t  functions_4_1_4\n\nconst my_program = parse(\"1; { true; 3; }\");\nevaluate(my_program, the_empty_environment);\n```",
    "token_count": 362,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "The Core of the Evaluator",
    "chunk_index": 2,
    "chunk_id": "Metalinguistic_Abstraction_The_Core_of_the_Evaluator_2"
  },
  {
    "content": "This\nabstract syntax\nmakes it easy to see how we can change the syntax of the language by\nusing the same evaluator, but with a different collection of syntax\nfunctions.\n\nFor clarity,\nevaluate\nhas been implemented as a\nconditional expressions.\n\nThe disadvantage of this is that our\nfunction\nhandles only a few distinguishable types of\nstatements and\nexpressions, and no new ones can be defined without editing the\n\n```javascript\ndeclaration of\n\tevaluate.\n```\n\nIn most\ninterpreter\nimplementations, dispatching on the type of\na component\nis done in a data-directed style.\n\nThis allows a user to add new types of\n\n```javascript\ncomponents that\n      evaluate\n```\n\ncan distinguish, without modifying the\n\n```javascript\ndeclaration of\n\tevaluate\n```\n\nitself.\n\n(See exercise.)\n\nThe representation of names is handled by the syntax abstractions.\n\nInternally,\nthe evaluator uses strings to represent names, and we refer to such strings as\nsymbols.\n\nThe function\nsymbol_of_name used in\nevaluate extracts from a\nname the symbol by which it is represented.\n\nThe function apply\ntakes two arguments, a\nfunction\nand a list of arguments to which the\nfunction\nshould be applied.\n\nThe function apply\nclassifies\nfunctions\ninto two kinds: It calls\napply_primitive_function\nto apply primitives; it applies compound\nfunctions\n\n```javascript\nby evaluating the block that makes up the body\n\tof the function.\n```\n\nThe environment for the evaluation of the body of a compound\nfunction\nis constructed by extending the base environment carried by the\nfunction\nto include a frame that binds the parameters of the\nfunction\nto the arguments to which the\nfunction\nis to be applied.\n\nHere is the\ndeclaration\nof\n\n```javascript\napply\n      apply_example\n      3\n\nfunction apply(fun, args) {\n    if (is_primitive_function(fun)) {\n        return apply_primitive_function(fun, args);\n    } else if (is_compound_function(fun)) {\n        const result = evaluate(function_body(fun),\n                                extend_environment(\n                                    function_parameters(fun),\n                                    args,\n                                    function_environment(fun)));\n        return is_return_value(result)\n               ? return_value_content(result)\n               : undefined;\n    } else {\n        error(fun, \"unknown function type -- apply\");\n    }\n}\n```",
    "token_count": 307,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "The Core of the Evaluator",
    "chunk_index": 3,
    "chunk_id": "Metalinguistic_Abstraction_The_Core_of_the_Evaluator_3"
  },
  {
    "content": "Here is the\ndeclaration\nof\n\n```javascript\napply_example\n      functions_4_1_1\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nconst plus = list(\"primitive\", (x, y) => x + y);\napply(plus, list(1, 2));\n```\n\n```javascript\nIn order to return a value, a JavaScript function needs to evaluate a\n\tundefined is returned.\n\tTo distinguish the two cases, the evaluation of a return statement\n\twill wrap the result of evaluating its return expression into a\n\treturn value. If\n\tthe evaluation of the function body yields such a return value, the content\n\tof the return value is retrieved; otherwise the value\n\tundefined is returned.\n```\n\nWhen processes a function application, it uses list_of_values to produce the list of arguments to which the function is to be applied.\n\n```javascript\nThe function\n      list_of_values\n```\n\ntakes as an argument the\nargument expressions of the application.\n\nIt evaluates each\nargument expression\nand returns a\nlist of the corresponding values:\n\n```javascript\nlist_of_values\n      list_of_values_example\n\nfunction list_of_values(exps, env) {\n    return map(arg => evaluate(arg, env), exps);\n}\n```\n\n```javascript\nlist_of_values_example\n      functions_4_1_1\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nconst my_addition_expression = parse(\"1 + 2;\");\nlist_of_values(list(parse(\"1;\"), my_addition_expression, parse(\"7;\")),\n               the_global_environment);\n```\n\n```javascript\nThe function\n      eval_conditional\n```\n\nevaluates the predicate part of\na conditional component\nin the given environment.\n\nIf the result is true,\nthe consequent is evaluated, otherwise the alternative is evaluated:\n\n```javascript\neval_if\n      eval_if_example\n      1\n\nfunction eval_conditional(component, env) {\n    return is_truthy(evaluate(conditional_predicate(component), env))\n           ? evaluate(conditional_consequent(component), env)\n           : evaluate(conditional_alternative(component), env);\n}\n```\n\n```javascript\neval_if_example\n      functions_4_1_1\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nconst my_cond_expr = parse(\"true ? 1 : 2;\");\neval_conditional(my_cond_expr, the_empty_environment);\n```\n\n```javascript\nNote that the evaluator does not need to distinguish between\n\tconditional expressions and conditional statements.\n```\n\nThe use of\nis_truthy\nin\neval_conditional\nconditional_predicate\nis evaluated in the language being implemented and thus yields a value in\nthat language.",
    "token_count": 281,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "The Core of the Evaluator",
    "chunk_index": 4,
    "chunk_id": "Metalinguistic_Abstraction_The_Core_of_the_Evaluator_4"
  },
  {
    "content": "The use of\nis_truthy\nin\neval_conditional\nconditional_predicate\nis evaluated in the language being implemented and thus yields a value in\nthat language.\n\nThe interpreter predicate\nis_truthy\ntranslates that value into a value that can be tested by the\nconditional expression\nin the implementation language: The metacircular representation of truth\nmight not be the same as that of the underlying\nJavaScript.\n\nThe function eval_sequence\nis used by evaluate\nto evaluate a sequence of statements at the top level or in a block.\n\nIt takes as arguments a sequence of statements and an\nenvironment, and evaluates the statements in the order in which they\noccur.\n\nThe value returned is the value of the final statement, except\nthat if the evaluation of any statement in the sequence yields\na return value, that value is returned and the subsequent statements are\nignored.\n\n```javascript\neval_sequence\n\t  eval_sequence_example\n\t  3\n\nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n        return evaluate(first_statement(stmts), env);\n    } else {\n        const first_stmt_value =\n            evaluate(first_statement(stmts), env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(rest_statements(stmts), env);\n        }\n    }\n}\n```\n\n```javascript\neval_sequence_example\n\t  functions_4_1_1\n\t  functions_4_1_2\n\t  functions_4_1_3\n\t  functions_4_1_4\n\nconst my_sequence = head(tail(parse(\"1; true; 3;\")));\neval_sequence(my_sequence, the_empty_environment);\n```\n\nThe function eval_block handles\nblocks.\n\nThe variables and constants (including functions)\ndeclared in the block have the whole block as their scope and thus\nare scanned out before the body of the block is\nevaluated.\n\nThe body of the block is evaluated with respect to an environment\nthat extends the current\nenvironment by a frame that binds each local name\nto a special value,\n\"*unassigned*\".\n\nThis string serves as a placeholder, before\nthe evaluation of the declaration assigns the name\nits proper value.",
    "token_count": 280,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "The Core of the Evaluator",
    "chunk_index": 5,
    "chunk_id": "Metalinguistic_Abstraction_The_Core_of_the_Evaluator_5"
  },
  {
    "content": "This string serves as a placeholder, before\nthe evaluation of the declaration assigns the name\nits proper value.\n\nAn attempt to access the value of the name before its\ndeclaration is evaluated leads to an error at run time (see\nexercise ), as stated in\nfootnote in chapter.\n\n```javascript\neval_block\n          scan_out_declarations\n\t  eval_block_example\n\t  42\n\nfunction eval_block(component, env) {\n    const body = block_body(component);\n    const locals = scan_out_declarations(body);\n    const unassigneds = list_of_unassigned(locals);\n    return evaluate(body, extend_environment(locals,\n                                             unassigneds,\n                                             env));\n}\nfunction list_of_unassigned(symbols) {\n    return map(symbol => \"*unassigned*\", symbols);\n}\n```\n\n```javascript\nlist_of_unassigned\n\nfunction list_of_unassigned(symbols) {\n    return map(symbol => \"*unassigned*\", symbols);\n}\n```\n\nThe function scan_out_declarations declaration_symbol to retrieve the symbol that represents the name from the declaration statements it finds.\n\n```javascript\nscan_out_declarations\n\t  scan_out_declarations_example\n\t  [ 'x', [ 'y', null ] ]\n\nfunction scan_out_declarations(component) {\n    return is_sequence(component)\n           ? accumulate(append,\n                        null,\n                        map(scan_out_declarations,\n                            sequence_statements(component)))\n           : is_declaration(component)\n           ? list(declaration_symbol(component))\n           : null;\n}\n```\n\n```javascript\nscan_out_declarations_example\n\t  functions_4_1_1\n\t  functions_4_1_2\n\t  functions_4_1_3\n\t  functions_4_1_4\n\nscan_out_declarations(parse(\"const x = 1; let y = 2;\"));\n```\n\n```javascript\neval_block_example\n\t  functions_4_1_1\n\t  functions_4_1_2\n\t  functions_4_1_3\n\t  functions_4_1_4\n\nconst my_block = parse(\"{ const x = 1; 3; 42; }\");\neval_block(my_block, the_empty_environment);\n```\n\nWe ignore declarations that are nested in another block,\nbecause the evaluation of that block will take care of them.\n\nThe function scan_out_declarations\nlooks for declarations only in sequences because\ndeclarations in conditional statements, function declarations, and\nlambda expressions are always in a nested block.\n\nThe function eval_return_statement\nis used to evaluate\napply and\nthe evaluation\nof sequences, the result of evaluation of a return statement\nneeds to be identifiable so that the evaluation of a function\nbody can return immediately, even if there are statements\nafter the return statement.\n\nFor this purpose,\nthe evaluation of a return statement wraps the result of\nevaluating the return expression in a return value object.\n\n```javascript\neval_return\n\t  eval_return_example\n\t  1\n\nfunction eval_return_statement(component, env) {\n    return make_return_value(evaluate(return_expression(component),\n                                      env));\n}\n```",
    "token_count": 303,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "The Core of the Evaluator",
    "chunk_index": 6,
    "chunk_id": "Metalinguistic_Abstraction_The_Core_of_the_Evaluator_6"
  },
  {
    "content": "For this purpose,\nthe evaluation of a return statement wraps the result of\nevaluating the return expression in a return value object.\n\n```javascript\neval_return_example\n\t  functions_4_1_1\n\t  functions_4_1_2\n\t  functions_4_1_3\n\t  functions_4_1_4\n\nconst my_program = parse(\"{ function f() { return 1; } f(); }\");\nevaluate(my_program, the_global_environment);\n```\n\nThe function eval_assignment handles assignments to\n\n```javascript\nnames.\n\t(To simplify the\tpresentation of our evaluator,\n\twe are allowing assignment not just to variables but\n\talsoerroneouslyto constants.\n\tExercise\n\texplains how we could\n\tdistinguish constants from variables and prevent\n\tassignment to constants.)\n```\n\n```javascript\nThe function\n\teval_assignment\n\tcalls\n\tassignment_symbol\n\tto retrieve the symbol that represents the name\n\tfrom the assignment. The function\n\teval_assignment\n\ttransmits the symbol and the value to\n\tassign_symbol_value\n\tto be installed in the designated environment.\n\tThe evaluation of an assignment returns the value\n\tthat was assigned.\n```\n\n```javascript\neval_assignment\n      eval_assignment_example\n      2\n\nfunction eval_assignment(component, env) {\n    const value = evaluate(assignment_value_expression(component),\n                           env);\n    assign_symbol_value(assignment_symbol(component), value, env);\n    return value;\n}\n```\n\n```javascript\neval_assignment_example\n      functions_4_1_1\n      functions_4_1_2\n      functions_4_1_3\n      functions_4_1_4\n\nconst my_program = parse(\"{ let x = 1; x = 2; }\");\nevaluate(my_program, the_global_environment);\n```\n\nConstant and variable declarations are both recognized by the\nis_declaration syntax predicate.\n\nThey are treated in a manner similar to\nassignments, because eval_block\nhas already bound their symbols to \"*unassigned*\"\nin the current environment.\n\nTheir evaluation replaces \"*unassigned*\"\nwith the result of evaluating the value expression.\n\n```javascript\neval_definition\n\t  eval_definition_example\n\t  3\n\nfunction eval_declaration(component, env) {\n    assign_symbol_value(\n        declaration_symbol(component),\n        evaluate(declaration_value_expression(component), env),\n        env);\n    return undefined;\n}\n```\n\nThe result of evaluating the body of a function is determined by\nreturn statements, and therefore the return value\nundefined in\neval_declaration only\nmatters when the declaration occurs at the top level,\noutside of any function body.\n\nHere we use the return value\nundefined to simplify\nthe presentation; exercise\ndescribes the real result of evaluating top-level components\nin JavaScript.",
    "token_count": 294,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "The Core of the Evaluator",
    "chunk_index": 7,
    "chunk_id": "Metalinguistic_Abstraction_The_Core_of_the_Evaluator_7"
  },
  {
    "content": "Here we use the return value\nundefined to simplify\nthe presentation; exercise\ndescribes the real result of evaluating top-level components\nin JavaScript.\n\n```javascript\neval_definition_example\n\t  functions_4_1_1\n\t  functions_4_1_2\n\t  functions_4_1_3\n\t  functions_4_1_4\n\nconst my_program = parse(\"{ let x = 1; const y = 2; x + y; }\");\nevaluate(my_program, the_global_environment);\n```",
    "token_count": 47,
    "has_code": true,
    "chapter": "Metalinguistic Abstraction",
    "section": "The Metacircular Evaluator",
    "subsection": "The Core of the Evaluator",
    "chunk_index": 8,
    "chunk_id": "Metalinguistic_Abstraction_The_Core_of_the_Evaluator_8"
  },
  {
    "content": "The preceding chapters introduced the basic elements from which\nprograms are made.\n\nWe saw how primitive\nfunctions\nand primitive data are combined to construct compound entities, and we\nlearned that abstraction is vital in helping us to cope with the complexity\nof large systems.\n\nBut these tools are not sufficient for designing\nprograms.\n\nEffective program synthesis also requires organizational\nprinciples that can guide us in formulating the overall design of a\nprogram.\n\nIn particular, we need strategies to help us structure large\nsystems so that they will be\nmodular , that is, so that they can\nbe divided naturally into coherent parts that can be\nseparately developed and maintained.\n\nOne powerful design strategy, which is particularly appropriate to the construction of programs for\n\nTo a large extent, then, the way we organize a large program is\ndictated by our perception of the system to be modeled.\n\nIn this\nchapter we will investigate two prominent organizational strategies\narising from two rather different world views of the\nstructure of systems.\n\nThe first organizational strategy concentrates on\nobjects , viewing a large system as a collection of distinct objects\nwhose behaviors may change over time.\n\nAn alternative organizational\nstrategy concentrates on the\nstreams of information that flow in\nthe system, much as an electrical engineer views a signal-processing\nsystem.\n\nBoth the object-based approach and the stream-processing approach\nraise significant linguistic issues in programming.\n\nWith objects, we must be concerned with how a computational object can\nchange and yet maintain its identity.\n\nThis will force us to abandon\nour old substitution model of computation\n(section ) in favor of a more\nmechanistic but less theoretically tractable\nenvironment model of\ncomputation.\n\nThe difficulties of dealing with objects, change, and\nidentity are a fundamental consequence of the need to grapple with\ntime in our computational models.",
    "token_count": 300,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": null,
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Modularity_Objects_and_State_1"
  },
  {
    "content": "The difficulties of dealing with objects, change, and\nidentity are a fundamental consequence of the need to grapple with\ntime in our computational models.\n\nThese difficulties become even\ngreater when we allow the possibility of concurrent execution of\nprograms.\n\nThe stream approach can be most fully exploited when we\ndecouple simulated time in our model from the order of the events that\ntake place in the computer during evaluation.\n\nWe will accomplish this\nusing a technique known as\ndelayed evaluation.",
    "token_count": 80,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": null,
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Modularity_Objects_and_State_2"
  },
  {
    "content": "We ordinarily view the world as populated by independent objects, each\nof which has a state that changes over time.\n\nAn object is said to\nhave state if its behavior is influenced by its history.\n\nA bank account, for example, has state in that the answer to the question\nCan I withdraw 100? depends upon the history of\ndeposit and withdrawal transactions.\n\nWe can characterize an\nobject s state by one or more\nstate variables , which among them maintain enough\ninformation about history to determine the object s current behavior.\n\nIn a simple banking system, we could characterize the state of an\naccount by a current balance rather than by remembering the entire\nhistory of account transactions.\n\nIn a system composed of many objects, the objects are rarely\ncompletely independent.\n\nEach may influence the states of others\nthrough interactions, which serve to couple the state variables of one\nobject to those of other objects.\n\nIndeed, the view that a system is\ncomposed of separate objects is most useful when the state variables\nof the system can be grouped into closely coupled subsystems that are\nonly loosely coupled to other subsystems.\n\nThis view of a system can be a powerful framework for organizing\ncomputational models of the system.\n\nFor such a model to be modular,\nit should be decomposed into computational objects that model the\nactual objects in the system.\n\nEach computational object must have its\nown local state variables describing the actual object s\nstate.\n\nSince the states of objects in the system being modeled change over\ntime, the state variables of the corresponding computational objects\nmust also change.",
    "token_count": 270,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Assignment_and_Local_State_1"
  },
  {
    "content": "Since the states of objects in the system being modeled change over\ntime, the state variables of the corresponding computational objects\nmust also change.\n\nIf we choose to model the flow of time in the\nsystem by the elapsed time in the computer, then we must have a way to\nconstruct computational objects whose behaviors change as our programs\nrun.\n\nIn particular, if we wish to model state variables by ordinary\nsymbolic names in the programming language, then the language must\nprovide an\nassignment operation\nto enable us to change the value\nassociated with a name.",
    "token_count": 96,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Assignment_and_Local_State_2"
  },
  {
    "content": "To illustrate what we mean by having a computational object with\nfunction\nInsufficient funds.\n\nFor example, if we begin with 100\nin the account, we should obtain the following sequence of responses\nusing\n\n```javascript\nwithdraw_example\n      75\n      withdraw\n\nwithdraw(25);\n```\n\n```javascript\nwithdraw_example2\n      withdraw\n      withdraw_example\n      50\n\nwithdraw(25);\n```\n\n```javascript\nwithdraw_example3\n      withdraw\n      withdraw_example\n      withdraw_example2\n      'Insufficient funds'\n\nwithdraw(60);\n```\n\n```javascript\nwithdraw_example4\n      withdraw\n      withdraw_example\n      withdraw_example2\n      withdraw_example3\n      35\n\nwithdraw(15);\n```\n\nObserve that the expression\nwithdraw(25),\nevaluated twice, yields different values.\n\nThis is a new kind of\nbehavior for a\nfunction.\n\nUntil now, all our\nJavaScript functions\ncould be viewed as specifications for computing mathematical functions.\n\nA call to a\nfunction\ncomputed the value of the function applied to the given arguments,\nand two calls to the same\nfunction\nwith the same arguments always produced the same\nresult.\n\n```javascript\nSo far, all our names have been immutable.\n\tWhen a function was applied, the values that its parameters\n\treferred to never changed, and once a declaration was evaluated,\n\tthe declared name never changed its value.\n        To implement functions like\n\tvariable declarations, which use the keyword\n\tlet, in addition to constant\n\tdeclarations, which use the keyword\n\tconst.\n        We can declare a variable\n\tbalance\n\tto indicate the balance of money\n\tin the account and define\n```\n\nThe\nfunction\nchecks to see if Insufficient funds\nmessage.\n\nHere are the\ndeclarations\nof\n\n```javascript\nwithdraw\n      withdraw_example\n\nlet balance = 100;\n\nfunction withdraw(amount) {\n    if (balance >= amount) {\n        balance = balance - amount;\n        return balance;\n    } else {\n        return \"Insufficient funds\";\n    }\n}\n```\n\nDecrementing statement\n\n```javascript\nbalance = balance - amount;\n```\n\n```javascript\nThe syntax of\n\tassignment expressions is\n\nname = new-value\n```\n\nHere\n\n```javascript\nname\n\thas been declared with\n\tlet or\n\tas a\n```\n\nand\nnew-value\nis any expression.\n\nThe assignment\nchanges\nname\nso that its value is the\nresult obtained by evaluating\nnew-value.\n\nIn the case at hand, we are changing",
    "token_count": 311,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "Local State Variables",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Local_State_Variables_1"
  },
  {
    "content": "In the case at hand, we are changing\n\n```javascript\nThe function withdraw also uses a\n\tsequence of statements to cause two statements to be evaluated\n\tin the case where the if test is\n\ttrue: first decrementing  balance\n\tand then returning the value of\n\tbalance.\n\tIn general, executing a sequence\n\nstmt$_{1}$ stmt$_{2} \\ldots$stmt$_{n}$\n\n        causes the statements stmt$_{1}$\n\tthrough\n\tstmt$_{n}$ to be evaluated in\n\tsequence.\n```\n\nAlthough\nprogram\nenvironment and is freely accessible to be examined or\nmodified by any\nfunction.\n\nIt would be much better if we could somehow make\nfunction\nthat could access\nfunction\ncould access\n\nWe can make\n\n```javascript\nnew_withdraw_example\n\nnew_withdraw(60);\nnew_withdraw(60);\n```\n\n```javascript\nnew_withdraw\n      new_withdraw_example\n\nfunction make_withdraw_balance_100() {\n    let balance = 100;\n    return amount => {\n               if (balance >= amount) {\n                   balance = balance - amount;\n                   return balance;\n               } else {\n                   return \"Insufficient funds\";\n               }\n           };\n}\nconst new_withdraw = make_withdraw_balance_100();\n```\n\n```javascript\nWhat we have done here is use let\n\tto establish an environment with a local variable\n\tbalance, bound to the initial\n\tvalue 100. Within this local environment, we use a lambda\n\texpressionamount\n\tas an argument and behaves like our previous\n\twithdraw function.  This\n\tfunctionreturned as the result of evaluating the body of the\n\tmake_withdraw_balance_100\n\tfunctionbehaves in precisely the same way as\n\twithdraw, but its variable\n\tbalance is not accessible by any\n\tother function.\n```\n\nCombining\nassignments with variable declarations\nis the general programming\ntechnique we will use for constructing computational objects with\nlocal state.\n\nUnfortunately, using this technique raises a serious\nproblem: When we first introduced\nfunctions,\nwe also introduced the substitution model of evaluation\n(section ) to provide an\ninterpretation of what\nfunction\napplication means.\n\nWe said that applying a\nfunction whose body is a return statement\nshould be interpreted as evaluating the\nreturn expression of the function\nwith the\nparameters replaced by their values.",
    "token_count": 301,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "Local State Variables",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Local_State_Variables_2"
  },
  {
    "content": "We said that applying a\nfunction whose body is a return statement\nshould be interpreted as evaluating the\nreturn expression of the function\nwith the\nparameters replaced by their values.\n\n```javascript\nFor functions with more complex\n\tbodies, we need to evaluate the whole body with the\n\tparameters replaced by their values.\n```\n\nThe trouble is that,\nas soon as we introduce assignment into our language, substitution is no\nlonger an adequate model of\nfunction\napplication.\n\n(We will see why this is so in\nsection.) As a consequence, we\ntechnically have at this point no way to understand why the\nnew_withdraw\nfunction\nbehaves as claimed above.\n\nIn order to really understand a\nfunction\nsuch as\nnew_withdraw,\nwe will need to develop a new model of\nfunction\napplication.\n\nIn section we will\nintroduce such a model, together with an explanation of\nassignments and variable declarations.\n\nFirst, however, we examine some variations on the theme established by\nnew_withdraw.\n\n```javascript\nParameters of functions as well as names declared with\n\tlet are\n```\n\nThe following\nfunction, make_withdraw,\ncreates withdrawal processors.\n\nThe parameter\nmake_withdraw\nspecifies the initial amount of money in the\naccount.\n\n```javascript\nmake_withdraw\n      make_withdraw_define\n\nfunction make_withdraw(balance) {\n    return amount => {\n               if (balance >= amount) {\n                   balance = balance - amount;\n                   return balance;\n               } else {\n                   return \"Insufficient funds\";\n               }\n           };\n}\n```\n\nThe function make_withdraw can be used as follows to create two objects\n\n```javascript\nmake_withdraw_define\n      make_withdraw\n\nconst W1 = make_withdraw(100);\nconst W2 = make_withdraw(100);\n```\n\n```javascript\nmake_withdraw_example1\n      make_withdraw_define\n      50\n\nW1(50);\n```\n\n```javascript\nmake_withdraw_example1\n      make_withdraw_example2\n      30\n\nW2(70);\n```\n\n```javascript\nmake_withdraw_example3\n      make_withdraw_example2\n      'Insufficient funds'\n\nW2(40);\n```\n\n```javascript\nmake_withdraw_example4\n      make_withdraw_example3\n      10\n\nW1(40);\n```\n\nObserve that\n\nWe can also create objects that handle function that returns a bank-account object with a specified initial balance:",
    "token_count": 288,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "Local State Variables",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Local_State_Variables_3"
  },
  {
    "content": "We can also create objects that handle function that returns a bank-account object with a specified initial balance:\n\n```javascript\nmake_account\n      make_account_example_my\n\nfunction make_account(balance) {\n    function withdraw(amount) {\n        if (balance >= amount) {\n            balance = balance - amount;\n            return balance;\n        } else {\n            return \"Insufficient funds\";\n        }\n    }\n    function deposit(amount) {\n        balance = balance + amount;\n        return balance;\n    }\n    function dispatch(m) {\n        return m === \"withdraw\"\n               ? withdraw\n               : m === \"deposit\"\n               ? deposit\n               : error(m, \"unknown request -- make_account\");\n    }\n    return dispatch;\n}\n```\n\n```javascript\nmake_account_example_my\n\nconst acc = make_account(100);\n\nacc(\"withdraw\")(50);\n```\n\nEach call to\nfunctions\nfunction\nmessage as input and returns one of the two local\nfunctions.\n\nThe\nfunction\nitself is returned as the value that represents the bank-account object.\n\nThis is precisely the\nmessage-passing style of programming that we saw in\nsection , although here we are using\nit in conjunction with the ability to modify local variables.\n\n```javascript\nThe function\n\tmake_account\n```\n\ncan be used as follows:\n\n```javascript\nmake_account_example\n      make_account\n\nconst acc = make_account(100);\n```\n\n```javascript\nmake_account_example1\n      make_account_example\n      50\n\nacc(\"withdraw\")(50);\n```\n\n```javascript\nmake_account_example1\n      make_account_example2\n      'Insufficient funds'\n\nacc(\"withdraw\")(60);\n```\n\n```javascript\nmake_account_example2\n      make_account_example3\n      90\n\nacc(\"deposit\")(40);\n```\n\n```javascript\nmake_account_example3\n      make_account_example4\n      30\n\nacc(\"withdraw\")(60);\n```\n\nEach call to function, which is then applied to the specified\n\n```javascript\nmake_withdraw, another\n\tcall to make_account\n```\n\n```javascript\nmake_account\n\nconst acc2 = make_account(100);\n```\n\nwill produce a completely separate account object, which maintains its own local",
    "token_count": 230,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "Local State Variables",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Local_State_Variables_4"
  },
  {
    "content": "As we shall see, introducing assignment into our programming language\nleads us into a thicket of difficult conceptual issues.\n\nNevertheless,\nviewing systems as\nfunction\n\nIt is not at all clear what is meant by chosen at random.\n\nWhat we presumably want is for successive calls to\nfunction\nrand_update\nthat has the property that if we start with a given number\n$x_{1}$ and form\n\n```javascript\n$x_2$ = rand_update($x_1$);\n$x_3$ = rand_update($x_2$);\n```\n\nthen the sequence of values $x_1, x_2, x_3, \\ldots$ , will have the desired statistical properties.\n\nWe can implement\nfunction\nwith a local state variable\nrandom_init.\n\nEach call to\nrand_update\nof the current value of\n\n```javascript\nrand_update\n\n// A very simple rand_update function computes a number\n// from 0 (inclusive) to 200560490131 (a large prime)\n// from a value x by multiplying it with a constant a,\n// adding a constant b, and then taking the remainder\n// of dividing it by the large prime. We used it here\n// for illustration only, and do not claim any\n// statistical properties.\nconst m = 200560490131;\nconst a = 1103515245;\nconst b = 12345;\n\nfunction rand_update(x) {\n    return (a * x + b) % m;\n}\n```\n\n```javascript\nrand_definition\n      rand_update\n      random_init\n      rand_example\n      40083849805\n\nfunction make_rand() {\n   let x = random_init;\n   return () => {\n              x = rand_update(x);\n              return x;\n          };\n}\nconst rand = make_rand();\n```\n\n```javascript\nrandom_init\n\nconst random_init = 123456789;\n```\n\n```javascript\nrand_example\n\ndisplay(rand());\ndisplay(rand());\ndisplay(rand());\n\nrand();\nrand();\nrand();\n```\n\nOf course, we could generate the same sequence of random numbers\nwithout using assignment by simply calling\nrand_update\ndirectly.\n\nHowever, this would mean that any part of our program that used\nrandom numbers would have to explicitly remember the current value of\nrand_update.\n\nTo realize what an annoyance this would be, consider using random numbers\nto implement a technique called\nMonte Carlo simulation.",
    "token_count": 305,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Benefits of Introducing Assignment",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_The_Benefits_of_Introducing_Assignment_1"
  },
  {
    "content": "To realize what an annoyance this would be, consider using random numbers\nto implement a technique called\nMonte Carlo simulation.\n\nThe Monte Carlo method consists of choosing sample experiments at random\nfrom a large set and then making deductions on the basis of the\nprobabilities estimated from tabulating the results of those experiments.\n\nFor example, we can approximate\n$\\pi$ using the fact that\n$6/\\pi^2$ is the probability that two integers\nchosen at random will have no factors in common; that is, that their\ngreatest common divisor will be 1. $\\pi$ , we perform\na large number of experiments.\n\nIn each experiment we choose two integers at\nrandom and perform a test\n$6/\\pi^2$ , and from this\nwe obtain our approximation to $\\pi$.\n\nThe heart of our program is a\nfunction\nmonte_carlo,\nwhich takes as arguments the number of times to try an experiment, together\nwith the experiment, represented as a no-argument\nfunction\nthat will return either true or false each time it is run.\n\nThe function\nruns the experiment for the designated number of trials and returns a\nnumber telling the fraction of the trials in which the experiment was\nfound to be true.\n\n```javascript\nmonte_carlo\n      rand_definition\n      gcd_definition\n      estimate_pi_example\n      3.1408877612819492\n\nfunction estimate_pi(trials) {\n    return math_sqrt(6 / monte_carlo(trials, dirichlet_test));\n}\nfunction dirichlet_test() {\n    return gcd(rand(), rand()) === 1;\n}\nfunction monte_carlo(trials, experiment) {\n    function iter(trials_remaining, trials_passed) {\n        return trials_remaining === 0\n               ? trials_passed / trials\n               : experiment()\n               ? iter(trials_remaining - 1, trials_passed + 1)\n               : iter(trials_remaining - 1, trials_passed);\n    }\n    return iter(trials, 0);\n}\n```\n\n```javascript\nestimate_pi_example\n\nestimate_pi(10000);\n```\n\nNow let us try the same computation using rand_update directly rather than",
    "token_count": 270,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Benefits of Introducing Assignment",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_The_Benefits_of_Introducing_Assignment_2"
  },
  {
    "content": "Now let us try the same computation using rand_update directly rather than\n\n```javascript\nestimate_pi_alternative\n      rand_definition\n      gcd_definition\n      estimate_pi_example\n      3.1408877612819492\n\nfunction estimate_pi(trials) {\n    return math_sqrt(6 / random_gcd_test(trials, random_init));\n}\nfunction random_gcd_test(trials, initial_x) {\n    function iter(trials_remaining, trials_passed, x) {\n        const x1 = rand_update(x);\n        const x2 = rand_update(x1);\n        return trials_remaining === 0\n               ? trials_passed / trials\n               : gcd(x1, x2) === 1\n               ? iter(trials_remaining - 1, trials_passed + 1, x2)\n               : iter(trials_remaining - 1, trials_passed, x2);\n    }\n    return iter(trials, 0, initial_x);\n}\n```\n\nWhile the program is still simple, it betrays some painful breaches of\nmodularity.\n\nIn our first version of the program, using\nmonte_carlo\nfunction\nthat takes as an argument an arbitrary\nfunction.\n\nIn our second version of the program, with no local state for the\nrandom-number generator,\nrandom_gcd_test\nmust explicitly manipulate the random numbers\nrand_update.\n\nThis explicit handling of the random numbers intertwines the structure of\naccumulating test results with the fact that our particular experiment uses\ntwo random numbers, whereas other Monte Carlo experiments might use one\nrandom number or three.\n\nEven the top-level\nfunction\nestimate_pi\nhas to be concerned with supplying an initial random number.\n\nThe fact that\nthe random-number generator s insides are leaking out into other parts\nof the program makes it difficult for us to isolate the Monte Carlo idea so\nthat it can be applied to other tasks.\n\nIn the first version of the program,\nassignment encapsulates the state of the random-number generator within the\nfunction,\nso that the details of random-number generation remain independent of the\nrest of the program.\n\nThe general phenomenon illustrated by the Monte Carlo example is this: From\nthe point of view of one part of a complex process, the other parts appear\nto change with time.\n\nThey have hidden time-varying local state.",
    "token_count": 291,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Benefits of Introducing Assignment",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_The_Benefits_of_Introducing_Assignment_3"
  },
  {
    "content": "They have hidden time-varying local state.\n\nIf we wish\nto write computer programs whose structure reflects this decomposition, we\nmake computational objects (such as bank accounts and random-number\ngenerators) whose behavior changes with time.\n\nWe model state with local\nstate variables, and we model the changes of state with assignments to those\nvariables.\n\nIt is tempting to conclude this discussion by saying that, by introducing\nassignment and the technique of hiding state in local variables, we are able\nto structure systems in a more modular fashion than if all state had to be\nmanipulated explicitly, by passing additional parameters.\n\nUnfortunately,\nas we shall see, the story is not so simple.",
    "token_count": 110,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Benefits of Introducing Assignment",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_The_Benefits_of_Introducing_Assignment_4"
  },
  {
    "content": "As we have seen,\nassignment\nenables us to model objects\nthat have local state.\n\nHowever, this advantage comes at a price.\n\nOur\nprogramming language can no longer be interpreted in terms of the\nsubstitution model of\nfunction\napplication that we introduced in\nsection.\n\nMoreover, no simple\nmodel with nice mathematical properties can be an adequate\nframework for dealing with objects and assignment in programming languages.\n\nSo long as we do not use assignments, two evaluations of the same\nfunction\nwith the same arguments will produce the same result, so that\nfunctions\ncan be viewed as computing mathematical functions.\n\nProgramming without any\nuse of assignments, as we did throughout the first two chapters of this\nbook, is accordingly known as\nfunctional programming.\n\nfunction of section that does not bother to check for an insufficient amount:\n\n```javascript\nmake_simplified_withdraw\n      make_simplified_withdraw_example\n\nfunction make_simplified_withdraw(balance) {\n    return amount => {\n               balance = balance - amount;\n               return balance;\n           };\n}\n```\n\n```javascript\nmake_simplified_withdraw_example\n      make_simplified_withdraw\n\nconst W = make_simplified_withdraw(25);\n```\n\n```javascript\nmake_simplified_withdraw_example1\n      make_simplified_withdraw\n      make_simplified_withdraw_example\n      5\n\nW(20);\n```\n\n```javascript\nmake_simplified_withdraw_example2\n      make_simplified_withdraw\n      make_simplified_withdraw_example\n      make_simplified_withdraw_example1\n      -5\n\nW(10);\n```\n\nCompare this function with the following function, which does not use assignment:\n\n```javascript\nmake_decrementer\n\nfunction make_decrementer(balance) {\n    return amount => balance - amount;\n}\n```\n\n```javascript\nThe function\n      make_decrementer\n```\n\nreturns a function that subtracts its input from a designated amount\n\n```javascript\nmake_decrementer\n      make_decrementer_example\n\nconst D = make_decrementer(25);\n```\n\n```javascript\nmake_decrementer_example\n      make_decrementer_example1\n      5\n\nD(20);\n```\n\n```javascript\nmake_decrementer_example1\n      make_decrementer_example2\n      15\n\nD(10);\n```\n\nWe can use the substitution model to explain how\n\n```javascript\nmake_decrementer\n      5\n\nmake_decrementer(25)(20)\n\nmake_decrementer(25)(20);\n```\n\nWe first simplify the\nfunction expression of the application\nby substituting\n$25$ for\nmake_decrementer.\n\nThis reduces the\nexpression to\n\n```javascript\n(amount => 25 - amount)(20)\n```\n\nNow we apply the function by substituting 20 for lambda expression:\n\n```javascript\n5\n\n25 - 20\n\n25 - 20;\n```\n\nThe final answer is 5.\n\nObserve, however, what happens if we attempt a similar substitution analysis with\n\n```javascript\nmake_simplified_withdraw\n\nmake_simplified_withdraw(25)(20)\n```",
    "token_count": 320,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Costs of Introducing Assignment",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_The_Costs_of_Introducing_Assignment_1"
  },
  {
    "content": "Observe, however, what happens if we attempt a similar substitution analysis with\n\nWe first simplify the function expression by substituting 25 for the body of expression to\n\n```javascript\n(amount => {\n     balance = 25 - amount;\n     return 25;\n })(20)\n```\n\nNow we apply the function by substituting 20 for lambda expression:\n\n```javascript\nbalance = 25 - 20;\nreturn 25;\n```\n\nIf we adhered to the substitution model, we would have to say that the meaning of the function application is to first set assignment) from\n\nthe second occurrence of assignment), and the substitution model cannot do this.\n\nThe trouble here is that substitution is based ultimately on the notion that\n\n```javascript\nthe name in our language are essentially\n\tsymbols for values.\n```\n\n```javascript\nThis worked well for constants.\n\tBut a variable, whose value can change with assignment, cannot simply\n\tbe a name for a value. A variable somehow refers to a place where a\n\tvalue can be stored, and the value stored at this place can change.\n```\n\nIn section we will see how environments play this role of place in our computational model.\n\nThe issue surfacing here is more profound than the mere breakdown of a\nparticular model of computation.\n\nAs soon as we introduce change into\nour computational models, many notions that were previously\nstraightforward become problematical.\n\nConsider the concept of two\nthings being the same.\n\nSuppose we call make_decrementer twice with the same argument to create two functions:\n\n```javascript\nmake_decrementer\n\nconst D1 = make_decrementer(25);\n\nconst D2 = make_decrementer(25);\n```\n\nAre\neach is a\nfunction\nthat subtracts its input from 25.\n\nIn fact,\n\nContrast this with making two calls to make_simplified_withdraw:\n\n```javascript\nmake_simplified_withdraw\n      make_simplified_withdraw_example3\n\nconst W1 = make_simplified_withdraw(25);\n\nconst W2 = make_simplified_withdraw(25);\n```\n\nAre\n\n```javascript\nmake_simplified_withdraw_example3\n      make_simplified_withdraw_example4\n      5\n\nW1(20);\n```\n\n```javascript\nmake_simplified_withdraw_example4\n      make_simplified_withdraw_example5\n      -15\n\nW1(20);\n```\n\n```javascript\nmake_simplified_withdraw_example5\n      make_simplified_withdraw_example6\n      5\n\nW2(20);\n```",
    "token_count": 304,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Costs of Introducing Assignment",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_The_Costs_of_Introducing_Assignment_2"
  },
  {
    "content": "Are\n\nEven though equal in the sense that they are both created by evaluating the same expression, make_simplified_withdraw(25), it is not true that\n\nA language that supports the concept that equals can be substituted\nfor equals in an expression without changing the value of the\nexpression is said to be\nreferentially transparent.\n\nReferential transparency is violated\nwhen we include\nassignment\nin our computer language.\n\nThis makes it tricky to determine when we can\nsimplify expressions by substituting equivalent expressions.\n\nConsequently,\nreasoning about programs that use assignment becomes drastically more\ndifficult.\n\nOnce we forgo referential transparency, the notion of what it means for\ncomputational objects to be the same becomes difficult to\ncapture in a formal way.\n\nIndeed, the meaning of same in the\nreal world that our programs model is hardly clear in itself.\n\nIn general,\nwe can determine that two apparently identical objects are indeed\nthe same one only by modifying one object and then observing\nwhether the other object has changed in the same way.\n\nBut how can we tell\nif an object has changed other than by observing the\nsame object twice and seeing whether some property of the\nobject differs from one observation to the next?\n\nThus, we cannot determine\nchange without some a priori notion of\nsameness, and we cannot determine sameness without observing\nthe effects of change.\n\nAs an example of how this issue arises in programming, consider the\nsituation where Peter and Paul have a\n100 in\nit.\n\nThere is a substantial difference between modeling this as\n\n```javascript\nmake_account\n      50\n\nconst peter_acc = make_account(100);\nconst paul_acc = make_account(100);\n\nconst peter_acc = make_account(100);\nconst paul_acc = make_account(100);\n\npeter_acc(\"withdraw\")(10);\npeter_acc(\"withdraw\")(20);\npaul_acc(\"withdraw\")(50);\n```\n\nand modeling it as\n\n```javascript\nmake_account\n      20\n\nconst peter_acc = make_account(100);\nconst paul_acc = peter_acc;\n\nconst peter_acc = make_account(100);\nconst paul_acc = peter_acc;\npeter_acc(\"withdraw\")(10);\npeter_acc(\"withdraw\")(20);\npaul_acc(\"withdraw\")(50);\n```",
    "token_count": 304,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Costs of Introducing Assignment",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_The_Costs_of_Introducing_Assignment_3"
  },
  {
    "content": "and modeling it as\n\nIn the first situation, the two bank accounts are distinct.\n\nTransactions made by Peter will not affect Paul s account, and vice\nversa.\n\nIn the second situation, however, we have defined\npaul_acc\nto be the same thing as\npeter_acc.\n\nIn effect, Peter and Paul now have a joint bank account, and if Peter makes\na withdrawal from\npeter_acc\nPaul will observe less money in\npaul_acc.\n\nThese two similar but distinct situations can cause confusion in building\ncomputational models.\n\nWith the shared account, in particular, it can be\nespecially confusing that there is one object (the bank account) that has\ntwo different names\n\n```javascript\n(peter_acc and\n\tpaul_acc);\n```\n\nif we are searching for all the places in our program where paul_acc can be changed, we must remember to look also at things that\n\nchange peter_acc.\n\nWith reference to the above remarks on sameness and\nchange, observe that if Peter and Paul could only examine\ntheir bank balances, and could not perform operations that changed the\nbalance, then the issue of whether the two accounts are distinct would be\nmoot.\n\nIn general, so long as we never modify data objects, we can regard a\ncompound data object to be precisely the totality of its pieces.\n\nFor\nexample, a rational number is determined by giving its numerator and\nits denominator.\n\nBut this view is no longer valid in the presence of\nchange, where a compound data object has an identity that is\nsomething different from the pieces of which it is composed.\n\nA bank\naccount is still the same bank account even if we change the\nbalance by making a withdrawal; conversely, we could have two\ndifferent bank accounts with the same state information.",
    "token_count": 285,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Costs of Introducing Assignment",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_The_Costs_of_Introducing_Assignment_4"
  },
  {
    "content": "A bank\naccount is still the same bank account even if we change the\nbalance by making a withdrawal; conversely, we could have two\ndifferent bank accounts with the same state information.\n\nThis\ncomplication is a consequence, not of our programming language, but of\nour perception of a bank account as an object.\n\nWe do not, for\nexample, ordinarily regard a rational number as a changeable object\nwith identity, such that we could change the numerator and still have\nthe same rational number.\n\nIn contrast to functional programming, programming that makes extensive use\nof assignment is known as\nimperative programming.\n\nIn addition to raising complications about\ncomputational models, programs written in imperative style are susceptible\nto bugs that cannot occur in functional programs.\n\nFor example, recall the\niterative factorial program from\n\n```javascript\nsection\n\t(here using a conditional statement instead of a conditional\n\texpression):\n```\n\n```javascript\nfactorial_iterative\n      factorial_example\n      120\n\nfunction factorial(n) {\n    function iter(product, counter) {\n        if (counter > n) {\n            return product;\n        } else {\n            return iter(counter * product,\n                        counter + 1);\n        }\n    }\n    return iter(1, 1);\n}\n```\n\nInstead of passing arguments in the internal iterative loop, we could adopt a more imperative style by using explicit assignment to update the values of\n\nthe variables\n\n```javascript\nfactorial_imperative\n      factorial_example\n      120\n\nfunction factorial(n) {\n    let product = 1;\n    let counter = 1;\n    function iter() {\n        if (counter > n) {\n            return product;\n        } else {\n            product = counter * product;\n            counter = counter + 1;\n            return iter();\n        }\n    }\n    return iter();\n}\n```\n\nThis does not change the results produced by the program, but it does\nintroduce a subtle trap.\n\nHow do we decide the order of the assignments?\n\nAs it happens, the program is correct as written.\n\nBut writing the\nassignments in the opposite order\n\n```javascript\ncounter = counter + 1;\nproduct = counter * product;\n```",
    "token_count": 307,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Costs of Introducing Assignment",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_The_Costs_of_Introducing_Assignment_5"
  },
  {
    "content": "But writing the\nassignments in the opposite order\n\nwould have produced a different,\n\nThe complexity of imperative programs becomes even worse if we consider\napplications in which several processes execute concurrently.\n\nWe will\nreturn to this in section.\n\nFirst, however, we will address the issue of providing a computational\nmodel for expressions that involve assignment, and explore the uses of\nobjects with local state in designing simulations.",
    "token_count": 67,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Assignment and Local State",
    "subsection": "The Costs of Introducing Assignment",
    "chunk_index": 6,
    "chunk_id": "Modularity_Objects_and_State_The_Costs_of_Introducing_Assignment_6"
  },
  {
    "content": "We ve seen the power of computational objects with local state as\ntools for modeling.\n\nYet, as\nsection\nwarned, this power extracts a price: the loss of referential\ntransparency, giving rise to a thicket of questions about sameness and\nchange, and the need to abandon the substitution model of evaluation in\nfavor of the more intricate environment model.\n\nThe central issue lurking beneath the complexity of state, sameness,\nand change is that by introducing assignment we are forced to admit\ntime into our computational models.\n\nBefore we introduced\nassignment, all our programs were timeless, in the sense that any\nexpression that has a value always has the same value.\n\nIn contrast,\nrecall the example of modeling withdrawals from a bank account\nand returning the resulting balance,\nintroduced at the beginning of\nsection :\n\n```javascript\nwithdraw_example_3_4\n      withdraw\n      75\n\nwithdraw(25);\n```\n\n```javascript\nwithdraw_example_3_4_second\n      withdraw\n      withdraw_example_3_4\n      50\n\nwithdraw(25);\n```\n\nHere successive evaluations of the same expression yield different\nvalues.\n\nThis behavior arises from the fact that the execution of\nassignments (in this case, assignments to the variable\nmoments in time\nwhen values change.\n\nThe result of evaluating an expression depends not\nonly on the expression itself, but also on whether the evaluation occurs\nbefore or after these moments.\n\nBuilding models in terms of computational\nobjects with local state forces us to confront time as an essential concept\nin programming.\n\nWe can go further in structuring computational models to match our\nperception of the physical world.\n\nObjects in the world do not change\none at a time in sequence.\n\nRather we perceive them as acting\nconcurrently all at once.\n\nSo it is often natural to\nmodel systems as collections of\nthreads (sequences of computational steps)\nthat execute concurrently.",
    "token_count": 284,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Concurrency_Time_Is_of_the_Essence_1"
  },
  {
    "content": "So it is often natural to\nmodel systems as collections of\nthreads (sequences of computational steps)\nthat execute concurrently.\n\nJust as we can make our programs modular by\norganizing models in terms of objects with separate local state, it is\noften appropriate to divide computational models into parts that evolve\nseparately and concurrently.\n\nEven if the programs are to be executed on\na sequential computer, the practice of writing programs as if they were\nto be executed concurrently forces the programmer to avoid inessential\ntiming constraints and thus makes programs more modular.\n\nIn addition to making programs more modular, concurrent computation\ncan provide a speed advantage over sequential computation.\n\nSequential\ncomputers execute only one operation at a time, so the amount of time\nit takes to perform a task is proportional to the total number of\noperations performed.\n\nUnfortunately, the complexities introduced by assignment become even\nmore problematic in the presence of concurrency.\n\nThe fact of\nconcurrent execution, either because the world operates in parallel or\nbecause our computers do, entails additional complexity in our\nunderstanding of time.",
    "token_count": 178,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Concurrency_Time_Is_of_the_Essence_2"
  },
  {
    "content": "We ve seen that the difficulty in dealing with concurrent\nthreads\nis rooted in the need to consider the interleaving of the order of events\nin the different\nthreads.\n\nFor example, suppose we have two\nthreads ,\none with three ordered events $(a,b,c)$\nand one with three ordered events $(x,y,z)$.\n\nIf the two\nthreads\nrun concurrently, with no constraints on how their execution is\ninterleaved, then there are 20 different possible orderings for the events\nthat are consistent with the individual orderings for the two\nthreads :\n\\[ \\begin{array}{cccc}\n(a,b,c,x,y,z) & (a,x,b,y,c,z) & (x,a,b,c,y,z) & (x,a,y,z,b,c)\\\\\n(a,b,x,c,y,z) & (a,x,b,y,z,c) & (x,a,b,y,c,z) & (x,y,a,b,c,z)\\\\\n(a,b,x,y,c,z) & (a,x,y,b,c,z) & (x,a,b,y,z,c) & (x,y,a,b,z,c)\\\\\n(a,b,x,y,z,c) & (a,x,y,b,z,c) & (x,a,y,b,c,z) & (x,y,a,z,b,c)\\\\\n(a,x,b,c,y,z) & (a,x,y,z,b,c) & (x,a,y,b,z,c) & (x,y,z,a,b,c)\n\\end{array} \\]\nAs programmers designing this system, we would have to consider the\neffects of each of these 20 orderings and check that each behavior is\nacceptable.\n\nSuch an approach rapidly becomes unwieldy as the numbers of\nthreads and events increase.\n\nA more practical approach to the design of concurrent systems is to\ndevise general mechanisms that allow us to constrain the interleaving\nof concurrent\nthreads\nso that we can be sure that the program\nbehavior is correct.\n\nMany mechanisms have been developed for this\npurpose.\n\nIn this section, we describe one of them, the\nserializer.\n\nSerialization implements the following idea:\nThreads\nwill execute concurrently, but there will be certain collections of\nfunctions\nthat cannot be executed concurrently.\n\nMore precisely, serialization\ncreates distinguished sets of\nfunctions\nsuch that only one execution of a\nfunction\nin each serialized set is permitted to happen at a time.",
    "token_count": 269,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_1"
  },
  {
    "content": "More precisely, serialization\ncreates distinguished sets of\nfunctions\nsuch that only one execution of a\nfunction\nin each serialized set is permitted to happen at a time.\n\nIf some\nfunction\nin the set is being executed, then a\nthread\nthat attempts to execute any\nfunction\nin the set will be forced to wait\nuntil the first execution has finished.\n\nWe can use serialization to control access to shared variables.\n\nFor example, if we want to update a shared variable based on the\nprevious value of that variable, we put the access to the previous\nvalue of the variable and the assignment of the new value to the\nvariable in the same\nfunction.\n\nWe then ensure that no other\nfunction\nthat assigns to the variable can run concurrently with this\nfunction\nby serializing all of these\nfunctions\nwith the same serializer.\n\nThis guarantees that the value of the\nvariable cannot be changed between an access and the corresponding\nassignment.\n\nTo make the above mechanism more concrete, suppose that we have extended JavaScript to include a function called concurrent_execute:\n\n```javascript\nconcurrent_execute($f_{1}$, $f_{2}$, $\\ldots$, $f_{k}$)\n```\n\n```javascript\nEach $f$ must be a function of no arguments.\n        The function concurrent_execute\n        creates a separate thread for each\n        $f$, which applies\n        $f$ (to no arguments).\n```\n\nThese threads all run concurrently.\n\nAs an example of how this is used, consider\n\n```javascript\nconcurrent_execute_example\n      'all threads terminated'\n\nlet x = 10;\n\nconcurrent_execute(() => { x = x * x; },\n                   () => { x = x + 1; });\n```\n\n```javascript\nThis creates two concurrent\n\tthreads$T_1$, which sets\n\t$T_2$,\n\twhich increments $T_1$ and $T_2$:\n\n            101:\n\t    $T_1$\n            sets $T_2$ increments\n\n            121:\n\t    $T_2$ increments\n\t    $T_1$ sets\n\n            110:\n\t    $T_2$ changes\n            $T_1$\n\n\t      accesses the value of\n              x * x.\n\n            11:\n\t    $T_2$ accesses\n\t    $T_1$ sets $T_2$ sets\n\n            100:\n\t    $T_1$ accesses\n\t    $T_2$ sets\n\t    $T_1$ sets\n```",
    "token_count": 302,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_2"
  },
  {
    "content": "As an example of how this is used, consider\n\nWe can constrain the concurrency by using serialized\nfunctions,\nwhich are created by serializers.\n\nSerializers are constructed by\nmake_serializer,\nwhose implementation is given below.\n\nA serializer takes a\nfunction\nas argument and returns a serialized\nfunction\nthat behaves like the original\nfunction.\n\nAll calls to a given serializer return serialized\nfunctions\nin the same set.\n\nThus, in contrast to the example above, executing\n\n```javascript\nserializer_example\n      serializer\n      'all threads terminated'\n\nlet x = 10;\n\nconst s = make_serializer();\n\nconcurrent_execute(s(() => { x = x * x; }),\n                   s(() => { x = x + 1; }));\n```\n\ncan produce only two possible values for\n\n```javascript\n$T_1$ and\n      $T_2$ cannot be interleaved.\n```\n\nHere is a version of the make_account function from section , where the deposits and withdrawals have been\n\n```javascript\nmake_account_serialize_attempt_example\n\nconst my_account = make_account(100);\n\nconcurrent_execute(\n    () => {\n        display(my_account(\"balance\"), \"T1 balance\");\n        my_account(\"withdraw\")(50);\n        display(my_account(\"balance\"), \"T1 balance\");\n        my_account(\"deposit\")(100);\n    },\n    () => { display(my_account(\"balance\"), \"T2 balance\");\n        my_account(\"withdraw\")(50);\n        display(my_account(\"balance\"), \"T2 balance\");\n        my_account(\"deposit\")(100);\n    }\n);\n```\n\n```javascript\nmake_account_serialize_attempt\n      serializer\n      make_account_serialize_attempt_example\n\nfunction make_account(balance) {\n    function withdraw(amount) {\n        if (balance > amount) {\n            balance = balance - amount;\n            return balance;\n        } else {\n            return \"Insufficient funds\";\n        }\n    }\n    function deposit(amount) {\n        balance = balance + amount;\n        return balance;\n    }\n    const protect = make_serializer();\n    function dispatch(m) {\n        return m === \"withdraw\"\n               ? protect(withdraw)\n               : m === \"deposit\"\n               ? protect(deposit)\n               : m === \"balance\"\n               ? balance\n               : error(m, \"unknown request -- make_account\");\n    }\n    return dispatch;\n}\n```\n\nWith this implementation, two\nthreads\ncannot be withdrawing from or\ndepositing into a single account concurrently.\n\nThis eliminates the source\nof the error illustrated in figure ,\nwhere Peter changes the account balance between the times when Paul accesses\nthe balance to compute the new value and when Paul actually performs the\nassignment.",
    "token_count": 301,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_3"
  },
  {
    "content": "This eliminates the source\nof the error illustrated in figure ,\nwhere Peter changes the account balance between the times when Paul accesses\nthe balance to compute the new value and when Paul actually performs the\nassignment.\n\nOn the other hand, each account has its own serializer,\nso that deposits and withdrawals for different accounts can proceed\nconcurrently.\n\nSerializers provide a powerful abstraction that helps isolate the\ncomplexities of concurrent programs so that they can be dealt with\ncarefully and (hopefully) correctly.\n\nHowever, while using serializers\nis relatively straightforward when there is only a single shared\nresource (such as a single bank account), concurrent programming can\nbe treacherously difficult when there are multiple shared resources.\n\nTo illustrate one of the difficulties that can arise, suppose we wish to\n\n```javascript\nexchange_example\n\nconst a1 = make_account(100);\nconst a2 = make_account(200);\nconst a3 = make_account(300);\n\nconcurrent_execute(\n    () => {\n        display(a1(\"balance\"), \"Peter balance a1 before\");\n        display(a2(\"balance\"), \"Peter balance a2 before\");\n        exchange(a1, a2);\n        display(a1(\"balance\"), \"Peter balance a1 after\");\n        display(a2(\"balance\"), \"Peter balance a2 after\");\n    },\n    () => {\n        display(a1(\"balance\"), \"Paul balance a1 before\");\n        display(a3(\"balance\"), \"Paul balance a3 before\");\n        exchange(a1, a3);\n        display(a1(\"balance\"), \"Paul balance a1 after\");\n        display(a3(\"balance\"), \"Paul balance a3 after\");\n    }\n);\n```\n\n```javascript\nexchange\n      make_account_serialize_attempt\n      exchange_example\n\nfunction exchange(account1, account2) {\n    const difference = account1(\"balance\") - account2(\"balance\");\n    account1(\"withdraw\")(difference);\n    account2(\"deposit\")(difference);\n}\n```\n\nThis\nfunction\nworks well when only a single\nthread\nis trying to do the exchange.\n\nSuppose, however, that Peter and Paul both\nhave access to accounts $a_1$ ,\n$a_2$ , and $a_3$ , and\nthat Peter exchanges $a_1$ and\n$a_2$ while Paul concurrently exchanges\n$a_1$ and $a_3$.",
    "token_count": 262,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_4"
  },
  {
    "content": "Suppose, however, that Peter and Paul both\nhave access to accounts $a_1$ ,\n$a_2$ , and $a_3$ , and\nthat Peter exchanges $a_1$ and\n$a_2$ while Paul concurrently exchanges\n$a_1$ and $a_3$.\n\nEven with account deposits and withdrawals\nserialized for individual accounts (as in the\nmake_account\nfunction\nshown above in this section), $a_1$ and\n$a_2$ , but then Paul might change the balance in\n$a_1$ before Peter is able to complete the\nexchange.\nfunction\nto lock out any other concurrent accesses to the accounts during the\nentire time of the exchange.\n\nOne way we can accomplish this is by using both accounts serializers\nto serialize the entire function.\n\nTo do this, we will arrange for access to an account s serializer.\n\nNote that we are deliberately breaking the modularity of the bank-account\nobject by exposing the serializer.\n\nThe following version of\nmake_@account\nis identical to the original version given in\nsection , except that a\nserializer is provided to protect the balance variable, and the serializer\nis exported via message passing:\n\n```javascript\nmake_account_and_serializer\n      serializer\n      'all threads terminated'\n\nfunction make_account_and_serializer(balance) {\n    function withdraw(amount) {\n        if (balance > amount) {\n            balance = balance - amount;\n            return balance;\n        } else {\n            return \"Insufficient funds\";\n        }\n    }\n    function deposit(amount) {\n        balance = balance + amount;\n        return balance;\n    }\n    const balance_serializer = make_serializer();\n    return m => m === \"withdraw\"\n                ? withdraw\n                : m === \"deposit\"\n                ? deposit\n                : m === \"balance\"\n                ? balance\n                : m === \"serializer\"\n                ? balance_serializer\n                : error(m, \"unknown request -- make_account\");\n}\n```\n\nWe can use this to do serialized deposits and withdrawals.\n\nHowever,\nunlike our earlier serialized account, it is now the responsibility of\neach user of bank-account objects to explicitly manage the\nserialization, for example as\nfollows:\n\n```javascript\nmake_account_and_serializer_example\n\nconst my_account = make_account_and_serializer(100);\n\ndeposit(my_account, 200);\n\ndisplay(my_account(\"balance\"));\n```",
    "token_count": 298,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_5"
  },
  {
    "content": "However,\nunlike our earlier serialized account, it is now the responsibility of\neach user of bank-account objects to explicitly manage the\nserialization, for example as\nfollows:\n\n```javascript\nmake_account_and_serializer_usage\n      make_account_and_serializer\n      make_account_and_serializer_example\n\nfunction deposit(account, amount) {\n    const s = account(\"serializer\");\n    const d = account(\"deposit\");\n    s(d(amount));\n}\n```\n\nExporting the serializer in this way gives us enough flexibility to\nimplement a serialized exchange program.\n\nWe simply serialize the original\nfunction\nwith the serializers for both accounts:\n\n```javascript\nserialized_exchange_example\n\nconst a1 = make_account_and_serializer(100);\nconst a2 = make_account_and_serializer(200);\nconst a3 = make_account_and_serializer(300);\n\nconcurrent_execute(\n    () => {\n        display(a1(\"balance\"), \"Peter balance a1 before\");\n        display(a2(\"balance\"), \"Peter balance a2 before\");\n        serialized_exchange(a1, a2);\n        display(a1(\"balance\"), \"Peter balance a1 after\");\n        display(a2(\"balance\"), \"Peter balance a2 after\");\n    },\n    () => {\n        display(a1(\"balance\"), \"Paul balance a1 before\");\n        display(a3(\"balance\"), \"Paul balance a3 before\");\n        serialized_exchange(a1, a3);\n        display(a1(\"balance\"), \"Paul balance a1 after\");\n        display(a3(\"balance\"), \"Paul balance a3 after\");\n    }\n);\n```\n\n```javascript\nserialized_exchange\n      make_account_and_serializer\n      exchange\n      serialized_exchange_example\n\nfunction serialized_exchange(account1, account2) {\n    const serializer1 = account1(\"serializer\");\n    const serializer2 = account2(\"serializer\");\n    serializer1(serializer2(exchange))(account1, account2);\n}\n```\n\nWe implement serializers in terms of a more primitive synchronization\nmechanism called a\nmutex.\n\nA mutex is an object that supports two\noperations the mutex can be\nacquired , and the mutex can be\nreleased.\n\nOnce a mutex has been acquired, no other acquire\noperations on that mutex may proceed until the mutex is\nreleased.\n\n```javascript\nfunction\n\tf,\n```\n\nthe serializer returns a\nfunction\nthat acquires the mutex, runs\nf,\nand then releases the mutex.\n\nThis ensures that only one of the\nfunctions\nproduced by the serializer can be running at once, which is\nprecisely the serialization property that we need to guarantee.",
    "token_count": 266,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 6,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_6"
  },
  {
    "content": "This ensures that only one of the\nfunctions\nproduced by the serializer can be running at once, which is\nprecisely the serialization property that we need to guarantee.\n\n```javascript\nTo apply serializers to functions that take an arbitrary number of arguments,\n\twe use JavaScript's rest parameter and spread syntax.\n\t... in front of the\n\tparameter args collects\n\tthe rest (here all) of the arguments of any call of the function\n\tinto a vector data structure.\n\tThe\n\t... in front of\n\targs in\n\tthe application\n\tf(...args)\n\tspreads the elements of\n\targs so that\n\tthey become separate arguments of\n\tf.\n```\n\n```javascript\nserializer\n      mutex\n      'all threads terminated'\n\nfunction make_serializer() {\n    const mutex = make_mutex();\n    return f => {\n               function serialized_f(...args) {\n                   mutex(\"acquire\");\n                   const val = f(...args);\n                   mutex(\"release\");\n                   return val;\n               }\n               return serialized_f;\n           };\n}\n\nfunction make_serializer() {\n    const mutex = make_mutex();\n    return f => {\n               function serialized_f() {\n                   mutex(\"acquire\");\n                   const val = f();\n                   mutex(\"release\");\n                   return val;\n               }\n               return serialized_f;\n           };\n}\n```\n\nThe mutex is a mutable object (here we ll use a one-element list,\nwhich we ll refer to as a\ncell ) that can hold the value true or false.\n\nWhen the value is\nfalse, the mutex is available to be acquired.\n\nWhen the value is true, the\nmutex is unavailable, and any\nthread\nthat attempts to acquire the mutex must wait.\n\nOur mutex constructor\nmake_mutex\nbegins by initializing the cell contents to false.\n\nTo acquire the mutex,\nwe test the cell.\n\nIf the mutex is available, we set the cell contents to\ntrue and proceed.\n\nOtherwise, we wait in a loop, attempting to acquire over\nand over again, until we find that the mutex is available.",
    "token_count": 277,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 7,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_7"
  },
  {
    "content": "Otherwise, we wait in a loop, attempting to acquire over\nand over again, until we find that the mutex is available.\n\n```javascript\nmutex\n      'all threads terminated'\n\nfunction make_mutex() {\n    const cell = list(false);\n    function the_mutex(m) {\n        return m === \"acquire\"\n               ? test_and_set(cell)\n                 ? the_mutex(\"acquire\") // retry\n                 : true\n               : m === \"release\"\n               ? clear(cell)\n               : error(m, \"unknown request -- mutex\");\n    }\n    return the_mutex;\n}\nfunction clear(cell) {\n    set_head(cell, false);\n}\n```\n\nThe function test_and_set\ntests the cell and returns the result of the test.\n\nIn addition, if the\ntest was false,\ntest_and_set\nsets the cell contents to true before returning false.\n\nWe can express this\nbehavior as the following\nfunction:\n\n```javascript\ntest_and_set\n      'all threads terminated'\n\nfunction test_and_set(cell) {\n    if (head(cell)) {\n        return true;\n    } else {\n        set_head(cell, true);\n        return false;\n    }\n}\n```\n\nHowever, this implementation of\ntest_and_set\ndoes not suffice as it stands.\n\nThere is a crucial subtlety here, which is\nthe essential place where concurrency control enters the system: The\ntest_and_set\noperation must be performed\natomically.\n\nThat is, we must guarantee that, once a\nthread\nhas tested the cell and found it to be false, the cell contents will\nactually be set to true before any other\nthread\ncan test the cell.\n\nIf we do not make this guarantee, then the mutex can\nfail in a way similar to the bank-account failure in\nfigure.\n\n(See\nexercise.)\n\nThe actual implementation of\ntest_and_set\ndepends on the details of how our system runs concurrent\nthreads.\n\nFor example, we might be executing concurrent\nthreads\non a sequential processor using a\nthreads,\npermitting each\nthread\nto run for a short time before interrupting it\nand moving on to the next\nthread.\n\nIn that case,\ntest_and_set\ncan work by disabling time slicing during the testing and\nsetting.",
    "token_count": 293,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 8,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_8"
  },
  {
    "content": "In that case,\ntest_and_set\ncan work by disabling time slicing during the testing and\nsetting.\n\nAlternatively, multiprocessing computers provide instructions that\nsupport atomic operations directly in hardware.\n\nNow that we have seen how to implement serializers, we can see\nthat account exchanging still has a problem, even with the\nserialized_exchange\nfunction\nabove.\n\nImagine that Peter attempts to exchange $a_1$\nwith $a_2$ while Paul concurrently attempts to\nexchange $a_2$ with\n$a_1$.\n\nSuppose that Peter s\nthread\nreaches the point where it has entered a serialized\nfunction\nprotecting $a_1$ and, just after that,\nPaul s\nthread\nenters a serialized\nfunction\nprotecting $a_2$.\n\nNow Peter cannot proceed (to\nenter a serialized\nfunction\nprotecting $a_2$ ) until Paul exits the serialized\nfunction\nprotecting $a_2$.\n\nSimilarly, Paul cannot proceed\nuntil Peter exits the serialized\nfunction\nprotecting $a_1$.\n\nEach\nthread\nis stalled forever, waiting for the other.\n\nThis situation is called a\ndeadlock.\n\nDeadlock is always a danger in systems that provide\nconcurrent access to multiple shared resources.\n\nOne way to avoid the\nserialized_exchange\nso that a\nthread\nwill always attempt to enter a\nfunction\nprotecting the lowest-numbered account first.\n\nAlthough this method works\nwell for the exchange problem, there are other situations that require more\nsophisticated deadlock-avoidance techniques, or where deadlock cannot\nbe avoided at all.\n\n(See exercises\nand.)\n\nWe ve seen how programming concurrent systems requires controlling\nthe ordering of events when different\nthreads\naccess shared state, and we ve seen how to achieve this control\nthrough judicious use of serializers.\n\nBut the problems of concurrency\nlie deeper than this, because, from a fundamental point of view, it s\nnot always clear what is meant by shared state.\n\nMechanisms such as\ntest_and_set\nrequire\nthreads\nto examine a global shared flag at arbitrary times.",
    "token_count": 289,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 9,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_9"
  },
  {
    "content": "Mechanisms such as\ntest_and_set\nrequire\nthreads\nto examine a global shared flag at arbitrary times.\n\nThis is problematic\nand inefficient to implement in modern high-speed processors, where\ndue to optimization techniques such as pipelining and cached memory,\nthe contents of memory may not be in a consistent state at every instant.\n\nIn\nsome\nmultiprocessing systems, therefore, the serializer paradigm\nis being supplanted by\nother\napproaches to concurrency\ncontrol.\n\nThe problematic aspects of shared state also arise in large, distributed\nsystems.\n\nFor instance, imagine a distributed banking system where\nindividual branch banks maintain local values for bank balances and\nperiodically compare these with values maintained by other branches.\n\nIn\nsuch a system the value of the account balance would be\nundetermined, except right after synchronization.\n\nIf Peter deposits money\nin an account he holds jointly with Paul, when should we say that the\naccount balance has changed when the balance in the local branch\nchanges, or not until after the synchronization?\n\nAnd if Paul accesses the\naccount from a different branch, what are the reasonable constraints to\nplace on the banking system such that the behavior is\ncorrect ?\n\nThe only thing that might matter for correctness\nis the behavior observed by Peter and Paul individually and the\nstate of the account immediately after synchronization.\n\nQuestions about the real account balance or the order of\nevents between synchronizations may be irrelevant or\nmeaningless.\n\nThe basic phenomenon here is that synchronizing different threads, establishing shared state, or imposing an order on events requires communication among the threads.",
    "token_count": 255,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "Mechanisms for Controlling Concurrency",
    "chunk_index": 10,
    "chunk_id": "Modularity_Objects_and_State_Mechanisms_for_Controlling_Concurrency_10"
  },
  {
    "content": "On the surface, time seems straightforward.\n\nIt\nis an ordering imposed on events. $A$ and\n$B$ ,\neither $A$ occurs before\n$B$ ,\n$A$ and\n$B$ are simultaneous, or\n$A$ occurs after\n$B$.\n\nFor instance,\nreturning to the bank account example, suppose that Peter withdraws\n10 and Paul withdraws 25 from a\n100, leaving 65 in the account.\n\nDepending on the\norder of the two withdrawals, the sequence of balances in the account is\neither $\\$100 \\rightarrow \\$90 \\rightarrow\\$65$\nor $\\$100 \\rightarrow \\$75 \\rightarrow\\$65$.\n\nIn a computer implementation of the banking system, this changing\nsequence of balances could be modeled by successive assignments to\na variable\n\nIn complex situations, however, such a view can be problematic.\n\nSuppose that Peter and Paul, and other people besides, are\naccessing the same bank account through a network of banking machines\ndistributed all over the world.\n\nThe actual sequence of balances in\nthe account will depend critically on the detailed timing of the\naccesses and the details of the communication among the machines.\n\nThis threads sharing a common variable thread specified by the function given in section :\n\n```javascript\nwithdraw_concurrency\n      balance_concurrency\n      withdraw_example_concurrency\n      75\n\nfunction withdraw(amount) {\n    if (balance >= amount) {\n        balance = balance - amount;\n        return balance;\n    } else {\n        return \"Insufficient funds\";\n    }\n}\n```\n\n```javascript\nbalance_concurrency\n\nlet balance = 100;\n```\n\n```javascript\nwithdraw_example_concurrency\n\nwithdraw(25); // output: 75\n```\n\nIf the two threads operate independently, then Peter might test the balance and attempt to withdraw a legitimate amount. s test.\n\nThings can be worse still.\n\nConsider the\nstatement\n\n```javascript\nbalance = balance - amount;\n```\n\nexecuted as part of each withdrawal process.\n\nThis consists of three\nsteps: (1) accessing the value of the s withdrawals execute this statement concurrently, then the\ntwo withdrawals might interleave the order in which they access",
    "token_count": 299,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "The Nature of Time in Concurrent Systems",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_The_Nature_of_Time_in_Concurrent_Systems_1"
  },
  {
    "content": "This consists of three\nsteps: (1) accessing the value of the s withdrawals execute this statement concurrently, then the\ntwo withdrawals might interleave the order in which they access\n\nThe timing diagram in\nfigure\ndepicts\nan order of events where s assignment of 75 to\n100.\n\nAfterwards, Peter has 10, Paul has\n25, and the bank has 75.\n\nThe general phenomenon illustrated\nhere is that several\nthreads\nmay\nthread\nmay be trying to manipulate the shared state at the same\ntime.\n\nFor the bank account example, during each transaction, each\ncustomer should be able to act as if the other customers did not\nexist.\n\nWhen\ncustomers change\nthe balance in a way that depends on\nthe balance,\nthey\nmust be able to assume that, just before the moment of\nchange, the balance is still what\nthey\nthought it was.\n\nThe above example typifies the subtle bugs that can creep into\nconcurrent programs.\n\nThe root of this complexity lies in the\nassignments to variables that are shared among the different\nthreads.\n\nWe already know that we must be careful in writing programs that use\nassignment,\nbecause the results of a computation depend on the order in which the\nassignments occur. threads\nwe must be especially careful about\nassignments, because we may not be able to control the order of the\nassignments made by the different\nthreads.\n\nIf several such changes\nmight be made concurrently (as with two depositors accessing a joint\naccount) we need some way to ensure that our system behaves correctly.\n\nFor example, in the case of withdrawals from a joint bank account, we\nmust ensure that money is conserved.\n\nTo make concurrent programs behave correctly, we may have to\nplace some restrictions on concurrent execution.",
    "token_count": 287,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "The Nature of Time in Concurrent Systems",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_The_Nature_of_Time_in_Concurrent_Systems_2"
  },
  {
    "content": "To make concurrent programs behave correctly, we may have to\nplace some restrictions on concurrent execution.\n\nOne possible restriction on concurrency would stipulate that no two\noperations that change any shared state variables can occur at the same\ntime.\n\nThis is an extremely stringent requirement.\n\nFor distributed banking,\nit would require the system designer to ensure that only one transaction\ncould proceed at a time.\n\nThis would be both inefficient and overly\nconservative.\n\nFigure shows\nPeter and Paul sharing a bank account, where Paul has a private account\nas well.\n\nThe diagram illustrates two withdrawals from the shared account\n(one by Peter and one by Paul) and a deposit to Paul s private\naccount. s deposit and\nwithdrawal must not be concurrent (since both access and update the amount\nin Paul s wallet).\n\nBut there should be no problem permitting\nPaul s deposit to his private account to proceed concurrently with\nPeter s withdrawal from the shared account.\n\nConcurrent deposits and withdrawals from a\njoint account in Bank1 and a private account in Bank2.\n\nA less stringent restriction on concurrency would ensure that a\nconcurrent system produces the same result as if the\nthreads\nhad run sequentially in some order.\n\nThere are two important aspects to this\nrequirement.\n\nFirst, it does not require the\nthreads\nto actually run sequentially, but only to produce results that are the same\nas if they had run sequentially.\n\nFor the example in\nfigure , the designer of the\nbank account system can safely allow Paul s deposit and Peter s\nwithdrawal to happen concurrently, because the net result will be the same as\nif the two operations had happened sequentially.",
    "token_count": 276,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "The Nature of Time in Concurrent Systems",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_The_Nature_of_Time_in_Concurrent_Systems_3"
  },
  {
    "content": "For the example in\nfigure , the designer of the\nbank account system can safely allow Paul s deposit and Peter s\nwithdrawal to happen concurrently, because the net result will be the same as\nif the two operations had happened sequentially.\n\nSecond, there may be more\nthan one possible correct result produced by a concurrent\nprogram, because we require only that the result be the same as for\nsome sequential order.\n\nFor example, suppose that Peter and\nPaul s joint account starts out with 100, and Peter deposits\n40 while Paul concurrently withdraws half the money in the account.\n\nThen sequential execution could result in the account balance being either\n70 or 90 (see\nexercise ).\n\nThere are still weaker requirements for correct execution of concurrent\nprograms.\n\nA program for simulating\nthreads,\neach one representing a small volume of space, that update their values\nconcurrently.\n\nEach\nthread\nrepeatedly changes its value to the average of its own value and its\nneighbors values.\n\nThis algorithm converges to the right answer\nindependent of the order in which the operations are done; there is no\nneed for any restrictions on concurrent use of the shared values.",
    "token_count": 194,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Concurrency: Time Is of the Essence",
    "subsection": "The Nature of Time in Concurrent Systems",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_The_Nature_of_Time_in_Concurrent_Systems_4"
  },
  {
    "content": "Chapter dealt with compound data as a means for constructing\ncomputational objects that have several parts, in order to model\nreal-world objects that have several aspects.\n\nIn that chapter we\nintroduced the discipline of data abstraction, according to which data\nstructures are specified in terms of constructors, which create data\nobjects, and selectors, which access the parts of compound data\nobjects.\n\nBut we now know that there is another aspect of data that\nchapter did not address.\n\nThe desire to model systems composed of\nobjects that have changing state leads us to the need to modify\ncompound data objects, as well as to construct and select from them.\n\nIn order to model compound objects with changing state, we will design\ndata abstractions to include, in addition to selectors and\nconstructors, operations called\nmutators , which modify data\nobjects.\n\nFor instance, modeling a banking system requires us to\nchange account balances.\n\nThus, a data structure for representing bank\naccounts might admit an operation\n\n```javascript\nset_balance(account, new-value)\n```\n\nthat changes the balance of the designated account to the designated\nnew value.\n\nData objects for which mutators are defined are known as\nmutable data objects.\n\nChapter introduced pairs as a general-purpose glue\nfor synthesizing compound data.\n\nWe begin this section by defining basic\nmutators for pairs, so that pairs can serve as building blocks for\nconstructing mutable data objects.\n\nThese mutators greatly enhance the\nrepresentational power of pairs, enabling us to build data structures\nother than the sequences and trees that we worked with in\nsection.\n\nWe also present some\nexamples of simulations in which complex systems are modeled as collections\nof objects with local state.",
    "token_count": 273,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Modeling_with_Mutable_Data_1"
  },
  {
    "content": "Designing complex digital systems, such as computers, is an important\nengineering activity.\n\nDigital systems are constructed by\ninterconnecting simple elements.\n\nAlthough the behavior of these\nindividual elements is simple, networks of them can have very complex\nbehavior.\n\nComputer simulation of proposed circuit designs is an\nimportant tool used by digital systems engineers.\n\nIn this section we\ndesign a system for performing digital logic simulations.\n\nThis system\ntypifies a kind of program called an\nevent-driven simulation , in\nwhich actions ( events ) trigger further events that happen\nat a later time, which in turn trigger more events, and so on.\n\nOur computational model of a circuit will be composed of objects that\ncorrespond to the elementary components from which the circuit is\nconstructed.\n\nThere are\nwires , which carry\ndigital signals.\n\nA digital signal may at any moment have only one of two\npossible values,\n0 and 1.\n\nThere are also various types of digital\nfunction boxes , which connect wires carrying input signals to other output\nwires.\n\nSuch boxes produce output signals computed from their input\nsignals.\n\nThe output signal is\ninverter is a\nprimitive function box that inverts its input.\n\nIf the\ninput signal to an inverter changes to 0, then one inverter-delay\nlater the inverter will change its output signal to 1.\n\nIf the input\nsignal to an inverter changes to 1, then one inverter-delay later\nthe inverter will change its output signal to 0.\n\nWe draw an inverter\nsymbolically as in figure.\n\nAn\nand-gate ,\nalso shown in figure , is a primitive\nfunction box with two inputs and one output.\n\nIt drives its output signal\nto a value that is the\nlogical and of the inputs.",
    "token_count": 281,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_1"
  },
  {
    "content": "It drives its output signal\nto a value that is the\nlogical and of the inputs.\n\nThat is, if both\nof its input signals become 1, then one and-gate-delay time\nlater the and-gate will force its output signal to be 1; otherwise the\noutput will be 0.\n\nAn\nor-gate is a similar two-input primitive function\nbox that drives its output signal to a value that is the\nlogical or of the inputs.\n\nThat is, the output will become 1 if at least one\nof the input signals is 1; otherwise the output will become 0.\n\nWe can connect primitive functions together to construct more complex\nfunctions.\n\nTo accomplish this we wire the outputs of some\nfunction boxes to the inputs of other function boxes.\n\nFor example,\nthe\nhalf-adder circuit shown in\nfigure consists of an\nor-gate, two and-gates, and an inverter.\n\nIt takes two input signals,\n$A$ and $B$ , and has\ntwo output signals, $S$ and $C$.\n$S$ will become 1\nwhenever precisely one of $A$ and $B$\nis 1, and $C$ will become 1 whenever\n$A$ and $B$ are both 1.\n\nWe can see\nfrom the figure that, because of the\ndelays involved, the outputs may be generated at different times.\n\nMany of the difficulties in the design of digital circuits arise from\nthis fact.\n\nA half-adder circuit.\n\nWe will now build a program for modeling the digital logic circuits we\nwish to study.\n\nThe program will construct computational objects\nmodeling the wires, which will hold the signals.\n\nFunction\nboxes will be modeled by\nfunctions\nthat enforce the correct relationships among the signals.\n\nOne basic element of our simulation will be a\nfunction\nmake_wire,\nwhich constructs wires.\n\nFor example, we can construct six wires as follows:",
    "token_count": 288,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_2"
  },
  {
    "content": "For example, we can construct six wires as follows:\n\n```javascript\nmake_wire_usage\n      make_wire\n\nconst a = make_wire();\nconst b = make_wire();\nconst c = make_wire();\nconst d = make_wire();\nconst e = make_wire();\nconst s = make_wire();\n```\n\nWe attach a function box to a set of wires by calling a\nfunction\nthat constructs that kind of box.\n\nThe arguments to the constructor\nfunction\nare the wires to be attached to the box.\n\nFor example, given\nthat we can construct and-gates, or-gates, and inverters, we can wire\ntogether the half-adder shown in figure :\n\n```javascript\nor_gate_example\n      or_gate\n      make_wire_usage\n      'ok'\n\nor_gate(a, b, d);\n```\n\n```javascript\nand_gate_example\n      and_gate\n      make_wire_usage\n      'ok'\n\nand_gate(a, b, c);\n```\n\n```javascript\ninverter_example\n      inverter\n      make_wire_usage\n      'ok'\n\ninverter(c, e);\n```\n\n```javascript\nand_gate_example_2\n      and_gate\n      make_wire_usage\n      'ok'\n\nand_gate(d, e, s);\n```\n\nBetter yet, we can explicitly name this operation by defining a function half_@adder that constructs this circuit, given the four external wires to be attached\n\nto the half-adder:\n\n```javascript\nhalf_adder_example\n      half_adder\n\nconst a = make_wire();\nconst b = make_wire();\nconst s = make_wire();\nconst c = make_wire();\nhalf_adder(a, b, s, c);\n```\n\n```javascript\nhalf_adder\n      make_wire\n      or_gate\n      and_gate\n      inverter\n      half_adder_example\n      'ok'\n\nfunction half_adder(a, b, s, c) {\n    const d = make_wire();\n    const e = make_wire();\n    or_gate(a, b, d);\n    and_gate(a, b, c);\n    inverter(c, e);\n    and_gate(d, e, s);\n    return \"ok\";\n}\n```\n\nThe advantage of making this definition is that we can use\nhalf_adder\nitself as a building block in creating more complex\ncircuits.\n\nFigure , for example, shows a\nfull-adder composed of two half-adders and an or-gate.\n\n```javascript\nfull_adder_example\n      full_adder\n\nconst a     = make_wire();\nconst b     = make_wire();\nconst c_in  = make_wire();\nconst sum   = make_wire();\nconst c_out = make_wire();\nfull_adder(a, b, c_in, sum, c_out);\n```",
    "token_count": 282,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_3"
  },
  {
    "content": "Figure , for example, shows a\nfull-adder composed of two half-adders and an or-gate.\n\n```javascript\nfull_adder\n      make_wire\n      half_adder\n      or_gate\n      full_adder_example\n      'ok'\n\nfunction full_adder(a, b, c_in, sum, c_out) {\n    const s = make_wire();\n    const c1 = make_wire();\n    const c2 = make_wire();\n    half_adder(b, c_in, s, c1);\n    half_adder(a, s, sum, c2);\n    or_gate(c1, c2, c_out);\n    return \"ok\";\n}\n```\n\nHaving defined\nfull_adder\nas a\nfunction,\nwe can now use it as a building block for creating still more complex\ncircuits.\n\n(For example, see exercise.)\n\nIn essence, our simulator provides us with the tools to construct a\nlanguage of circuits.\n\nIf we adopt the general perspective on\nlanguages with which we approached the study of\nJavaScript\nin section ,\nwe can say that the primitive function boxes form the primitive\nelements of the language, that wiring boxes together provides a means\nof combination, and that specifying wiring patterns as\nfunctions\nserves as a means of abstraction.\n\nThe primitive function boxes\nforces by which a\nchange in the signal on one wire influences the signals on other\nwires.\n\nTo build function boxes, we use the following operations on\nwires:\n-\n-\nget_signal(wire)\nreturns the current value of the signal on the wire.\n-\n-\nset_signal(wire, new-value):\nchanges the value of the signal on the wire to the new value.\n-\n-\nadd_action(wire, function-of-no-arguments):\nasserts that the designated\nfunction\nshould be run whenever the signal on the wire changes value.\n\nSuch\nfunctions\nare the vehicles by which changes in the signal value on the wire are\ncommunicated to other wires.\n\nIn addition, we will make use of a\nfunction\nafter_delay\nthat takes a time delay and a\nfunction\nto be run and executes the given\nfunction\nafter the given delay.\n\nUsing these\nfunctions,\nwe can define the primitive digital logic functions.",
    "token_count": 294,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_4"
  },
  {
    "content": "Using these\nfunctions,\nwe can define the primitive digital logic functions.\n\nTo connect an input\nto an output through an inverter, we use\nadd_action\nto associate with the input wire a\nfunction\nthat will be run whenever the signal on the input wire changes value.\n\nThe\nfunction\ncomputes the\nlogical_not\nof the input signal, and then, after one\ninverter_delay,\nsets the output signal to be this new value:\n\n```javascript\ninverter\n      get_signal\n      after_delay\n      inverter_example\n      'ok'\n\nfunction inverter(input, output) {\n    function invert_input() {\n        const new_value = logical_not(get_signal(input));\n        after_delay(inverter_delay,\n                    () => set_signal(output, new_value));\n    }\n    add_action(input, invert_input);\n    return \"ok\";\n}\nfunction logical_not(s) {\n    return s === 0\n           ? 1\n           : s === 1\n           ? 0\n           : error(s, \"invalid signal\");\n}\n```\n\nAn and-gate is a little more complex.\n\nThe action\nfunction\nmust be run if\neither of the inputs to the gate changes.\n\nIt computes the\n\n```javascript\nlogical_and\n\t(using a function analogous to\n\tlogical_not)\n```\n\nof the values of the signals on the input wires and sets up a change to the new value to occur on the output wire\n\nafter one and_gate_delay.\n\n```javascript\nand_gate\n      get_signal\n      after_delay\n      logical_and\n      and_gate_example\n      'ok'\n\nfunction and_gate(a1, a2, output) {\n    function and_action_function() {\n        const new_value = logical_and(get_signal(a1),\n                                      get_signal(a2));\n        after_delay(and_gate_delay,\n                    () => set_signal(output, new_value));\n    }\n    add_action(a1, and_action_function);\n    add_action(a2, and_action_function);\n    return \"ok\";\n}\n```\n\nA wire\nasignal_value\n(initially taken to be 0) and a collection of\naction_functions\nto be run when the signal changes value.\n\nWe implement the wire,\nusing\nfunctions\ntogether with a function\nthat selects the appropriate local operation, just as we did\nwith the simple bank-account object in section\n:",
    "token_count": 262,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_5"
  },
  {
    "content": "We implement the wire,\nusing\nfunctions\ntogether with a function\nthat selects the appropriate local operation, just as we did\nwith the simple bank-account object in section\n:\n\n```javascript\nmake_wire\n      call_each\n      make_wire_usage\n\nfunction make_wire() {\n    let signal_value = 0;\n    let action_functions = null;\n    function set_my_signal(new_value) {\n        if (signal_value !== new_value) {\n            signal_value = new_value;\n            return call_each(action_functions);\n        } else {\n            return \"done\";\n        }\n    }\n    function accept_action_function(fun) {\n        action_functions = pair(fun, action_functions);\n        fun();\n    }\n    function dispatch(m) {\n        return m === \"get_signal\"\n               ? signal_value\n               : m === \"set_signal\"\n               ? set_my_signal\n               : m === \"add_action\"\n               ? accept_action_function\n               : error(m, \"unknown operation -- wire\");\n    }\n    return dispatch;\n}\n```\n\nThe local\nfunction\nset_my_signal\ntests whether the new signal value changes the signal on the wire.\n\nIf so, it runs each of the action\nfunctions,\nusing the following\nfunction\ncall_each,\nwhich calls each of the items in a list of no-argument\nfunctions:\n\n```javascript\ncall_each\n\nfunction call_each(functions) {\n    if (is_null(functions)) {\n        return \"done\";\n    } else {\n        head(functions)();\n        return call_each(tail(functions));\n    }\n}\n```\n\nThe local\nfunction\naccept_action_function\nadds the given\nfunction\nto the list of\nfunctions\nto be run, and then runs the new\nfunction\nonce.\n\n(See exercise.)\n\nWith the local function set up as specified, we can provide the following functions to access the local operations on wires:\n\n```javascript\nget_signal\n\nfunction get_signal(wire) {\n    return wire(\"get_signal\");\n}\nfunction set_signal(wire, new_value) {\n    return wire(\"set_signal\")(new_value);\n}\nfunction add_action(wire, action_function) {\n    return wire(\"add_action\")(action_function);\n}\n```\n\nWires, which have time-varying signals and may be incrementally attached to\ndevices, are typical of mutable objects.\n\nWe have modeled them as\nfunctions\nwith local state variables that are modified by assignment.\n\nWhen a new\nwire is created, a new set of state variables is allocated (by the\nlet statements in\nmake_wire)\nand a new\nfunction\nis constructed and returned, capturing\nthe environment with the new state variables.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 6,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_6"
  },
  {
    "content": "When a new\nwire is created, a new set of state variables is allocated (by the\nlet statements in\nmake_wire)\nand a new\nfunction\nis constructed and returned, capturing\nthe environment with the new state variables.\n\nThe wires are shared among the various devices that have been\nconnected to them.\n\nThus, a change made by an interaction with one\ndevice will affect all the other devices attached to the wire.\n\nThe\nwire communicates the change to its neighbors by calling the action\nfunctions\nprovided to it when the connections were established.\n\nThe only thing needed to complete the simulator is\nafter_delay.\n\nThe idea here is that we maintain a data structure, called an\nagenda , that contains a schedule of things to do.\n\nThe following operations are defined for agendas:\n-\n-\nmake_agenda():\nreturns a new empty agenda.\n-\n-\nis_empty_agenda(agenda)\nis true if the specified agenda is empty.\n-\n-\nfirst_agenda_item(agenda)\nreturns the first item on the agenda.\n-\n-\nremove_first_agenda_item(agenda)\nmodifies the agenda by removing the first item.\n-\n-\nadd_to_agenda(time, action, agenda)\nmodifies the agenda by adding the given action\nfunction\nto be run at the specified time.\n-\n-\ncurrent_time(agenda)\nreturns the current simulation time.\n\nThe particular agenda that we use is denoted by\nthe_agenda.\n\nThe\nfunction\nafter_delay\nadds new elements to\nthe_agenda:\n\n```javascript\nafter_delay\n      add_to_agenda\n      make_agenda\n      the_agenda\n\nfunction after_delay(delay, action) {\n    add_to_agenda(delay + current_time(the_agenda),\n                  action,\n                  the_agenda);\n}\n```\n\n```javascript\nThe simulation is driven by the function\n\tthe_agenda\n\tin sequence.\n```\n\nIn general, as the simulation runs, new items will be added to the agenda, and\n\n```javascript\npropagate\n      remove_first_agenda_item\n      first_agenda_item\n      the_agenda\n\nfunction propagate() {\n    if (is_empty_agenda(the_agenda)) {\n        return \"done\";\n    } else {\n        const first_item = first_agenda_item(the_agenda);\n        first_item();\n        remove_first_agenda_item(the_agenda);\n        return propagate();\n    }\n}\n```\n\nThe following\nfunction,\nwhich places a probe on a wire, shows the simulator in\naction.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 7,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_7"
  },
  {
    "content": "The following\nfunction,\nwhich places a probe on a wire, shows the simulator in\naction.\n\nThe probe tells the wire that, whenever its signal changes value,\nit should print the new signal value, together with the current time and\na name that identifies the\nwire.\n\n```javascript\nprobe\n      the_agenda\n      get_signal\n\nfunction probe(name, wire) {\n    add_action(wire,\n               () => display(name + \" \" +\n                             stringify(current_time(the_agenda)) +\n                             \", new value = \" +\n                             stringify(get_signal(wire))));\n}\n\nfunction probe(name, wire) {\n    add_action(wire,\n               () => name + \" \" +\n                     stringify(current_time(the_agenda)) +\n                     \", new value = \" +\n                     stringify(get_signal(wire)));\n}\n```\n\nWe begin by initializing the agenda and specifying delays for the primitive function boxes:\n\n```javascript\nthe_agenda\n      make_agenda\n\nconst the_agenda = make_agenda();\nconst inverter_delay = 2;\nconst and_gate_delay = 3;\nconst or_gate_delay = 5;\n```\n\nNow we define four wires, placing probes on two of them:\n\n```javascript\nprobing_two_wires\n      make_wire\n      probe\n\nconst input_1 = make_wire();\nconst input_2 = make_wire();\nconst sum = make_wire();\nconst carry = make_wire();\n\nprobe(\"sum\", sum);\n```\n\n```javascript\nprobe_carry\n      probing_two_wires\n\nprobe(\"carry\", carry);\n```\n\nNext we connect the wires in a half-adder circuit (as in figure ), set the signal on input_1 to 1, and run the simulation:\n\n```javascript\nhalf_adder_example_2\n      half_adder\n      probe_carry\n      'ok'\n\nhalf_adder(input_1, input_2, sum, carry);\n```\n\n```javascript\nset_signal_example\n      half_adder_example_2\n      'done'\n\nset_signal(input_1, 1);\n```\n\n```javascript\npropagate_example_1\n      set_signal_example\n      propagate\n      'done'\n\npropagate();\n```\n\nThe input_2 to 1 and allow the values to propagate:\n\n```javascript\nset_signal_example_2\n      propagate_example_1\n      'done'\n\nset_signal(input_2, 1);\n```\n\n```javascript\npropagate_example_2\n      set_signal_example_2\n      'done'\n\npropagate();\n```\n\nThe\n\nFinally, we give details of the agenda data structure, which holds the functions that are scheduled for future execution.\n\nThe agenda is made up of\ntime segments.\n\nEach time segment is a\npair consisting of a number (the time) and a\n) that holds the\nfunctions\nthat are scheduled to be run during that time segment.\n\n```javascript\nmake_time_segment\n\nfunction make_time_segment(time, queue) {\n   return pair(time, queue);\n}\nfunction segment_time(s) { return head(s); }\n\nfunction segment_queue(s) { return tail(s); }\n```",
    "token_count": 319,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 8,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_8"
  },
  {
    "content": "Each time segment is a\npair consisting of a number (the time) and a\n) that holds the\nfunctions\nthat are scheduled to be run during that time segment.\n\nWe will operate on the time-segment queues using the queue operations described in section.\n\nThe agenda itself is a one-dimensional\nin that the segments will be sorted in order of increasing time.\n\nIn\naddition, we store the\ncurrent time (i.e., the time of the last action\nthat was processed) at the head of the agenda.\n\nA newly constructed\nagenda has no time segments and has a current time of 0:\n\n```javascript\nmake_agenda\n\nfunction make_agenda() { return list(0); }\n\nfunction current_time(agenda) { return head(agenda); }\n\nfunction set_current_time(agenda, time) {\n   set_head(agenda, time);\n}\nfunction segments(agenda) { return tail(agenda); }\n\nfunction set_segments(agenda, segs) {\n   set_tail(agenda, segs);\n}\nfunction first_segment(agenda) { return head(segments(agenda)); }\n\nfunction rest_segments(agenda) { return tail(segments(agenda)); }\n```\n\nAn agenda is empty if it has no time segments:\n\n```javascript\nis_empty_agenda\n      make_agenda\n\nfunction is_empty_agenda(agenda) {\n   return is_null(segments(agenda));\n}\n```\n\nTo add an action to an agenda, we first check if the agenda is empty.\n\nIf so, we create a time segment for the action and install this in\nthe agenda.\n\nOtherwise, we scan the agenda, examining the time of each\nsegment.\n\nIf we find a segment for our appointed time, we add the\naction to the associated queue.\n\nIf we reach a time later than the one\nto which we are appointed, we insert a new time segment into the\nagenda just before it.\n\nIf we reach the end of the agenda, we must\ncreate a new time segment at the end.",
    "token_count": 269,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 9,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_9"
  },
  {
    "content": "If we reach the end of the agenda, we must\ncreate a new time segment at the end.\n\n```javascript\nadd_to_agenda\n      make_time_segment\n      make_queue\n      insert_queue\n      make_time_segment\n      make_agenda\n\nfunction add_to_agenda(time, action, agenda) {\n   function belongs_before(segs) {\n      return is_null(segs) || time < segment_time(head(segs));\n   }\n   function make_new_time_segment(time, action) {\n      const q = make_queue();\n      insert_queue(q, action);\n      return make_time_segment(time, q);\n   }\n   function add_to_segments(segs) {\n      if (segment_time(head(segs)) === time) {\n          insert_queue(segment_queue(head(segs)), action);\n      } else {\n          const rest = tail(segs);\n          if (belongs_before(rest)) {\n              set_tail(segs, pair(make_new_time_segment(time, action),\n                                  tail(segs)));\n          } else {\n              add_to_segments(rest);\n          }\n      }\n   }\n   const segs = segments(agenda);\n   if (belongs_before(segs)) {\n       set_segments(agenda,\n                    pair(make_new_time_segment(time, action), segs));\n   } else {\n       add_to_segments(segs);\n   }\n}\n```\n\nThe\nfunction\nthat removes the first item from the agenda deletes the\nitem at the front of the queue in the first time segment.\n\nIf this\ndeletion makes the time segment empty, we remove it from the list of\nsegments:\n\n```javascript\nremove_first_agenda_item\n      make_agenda\n      is_empty_queue\n      delete_queue\n      make_time_segment\n\nfunction remove_first_agenda_item(agenda) {\n   const q = segment_queue(first_segment(agenda));\n   delete_queue(q);\n   if (is_empty_queue(q)) {\n       set_segments(agenda, rest_segments(agenda));\n   } else {}\n}\n```\n\nThe first agenda item is found at the head of the queue in the first\ntime segment.\n\nWhenever we extract an item, we also update the current\ntime:\n\n```javascript\nfirst_agenda_item\n      is_empty_agenda\n      make_time_segment\n      front_queue\n\nfunction first_agenda_item(agenda) {\n    if (is_empty_agenda(agenda)) {\n        error(\"agenda is empty -- first_agenda_item\");\n    } else {\n        const first_seg = first_segment(agenda);\n        set_current_time(agenda, segment_time(first_seg));\n        return front_queue(segment_queue(first_seg));\n    }\n}\n```",
    "token_count": 225,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "A Simulator for Digital Circuits",
    "chunk_index": 10,
    "chunk_id": "Modularity_Objects_and_State_A_Simulator_for_Digital_Circuits_10"
  },
  {
    "content": "The basic operations on\npairspair,\nhead,\nand\ntailcan\nbe used to construct list structure and to select parts\nfrom list structure, but they are incapable of modifying list\nstructure.\n\nThe same is true of the list operations we have used so\nfar, such as\npair,\nhead,\nand\ntail.\n\nTo modify list structures we need new operations.\n\nThe primitive mutators for pairs are\nset_head\nand\nset_tail.\n\nThe function set_head\ntakes two arguments, the first of which must be a pair.\n\nIt modifies this\npair, replacing the\nhead\npointer by a pointer to the second argument of\nset_head.\n\nAs an example, suppose that\nlist(list(\"a\", \"b\"), \"c\", \"d\")\nand\nlist(\"e\", \"f\")\nas illustrated in\nfigure.\n\nEvaluating the expression\nset_head(x, y)\nmodifies the pair to which\nhead\nby the value of\nfigure.\n\nThe structure\n\n```javascript\nis now equivalent to\n\tlist(list(\"e\", \"f\"), \"c\", \"d\").\n```\n\nThe pairs representing the list list(\"a\", \"b\"), identified by the pointer that was replaced, are now detached from the original structure.\n\nCompare figure with figure, which illustrates the result of executing\n\n```javascript\nmutable_list_example\n\nconst x = list(list(\"a\", \"b\"), \"c\");\nconst y = list(\"e\", \"f\");\n```\n\n```javascript\nmutable_list_example\n\nconst z = pair(y, tail(x));\n```\n\nwith\nfigure.\n\nThe\nname\npair\noperation; the list to which\n\nThe\nset_tail\noperation is similar to\nset_head.\n\nThe only difference is that the\ntail\npointer of the pair, rather than the\nhead\npointer, is replaced.\n\nThe effect of executing\nset_tail(x, y)\non the lists of\nfigure\nis shown in\nfigure.\n\nHere the\ntail\npointer of\nlist(\"e\", \"f\").\n\nAlso, the list\nlist(\"c\", \"d\"),\nwhich used to be the\ntail\nof\n\nThe function pair\nbuilds new list structure by creating new pairs,\nwhereas set_@head\nand\nset_tail\nmodify existing pairs.",
    "token_count": 280,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Mutable List Structure",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Mutable_List_Structure_1"
  },
  {
    "content": "The function pair\nbuilds new list structure by creating new pairs,\nwhereas set_@head\nand\nset_tail\nmodify existing pairs.\n\nIndeed, we could\npair\nin terms of the two mutators, together with a\nfunction\nget_new_pair,\nwhich returns a new pair that is not part of any existing list structure.\n\nWe obtain the new pair, set its\nhead\nand\ntail\npointers to the designated objects, and return the new pair as the result of\nthe\npair.\n\n```javascript\nget_new_pair\n\n// The book proposes a primitive function get_new_pair.\n// Since JavaScript does not provide such a function, let's\n// define it as follows, for the sake of the example.\n\nfunction get_new_pair() {\n    return pair(undefined, undefined);\n}\n{\n```\n\n```javascript\nget_new_pair\n    mutable_pair_example\n    [ [ 1, 2 ], 4 ]\n\nfunction pair(x, y) {\n    const fresh = get_new_pair();\n    set_head(fresh, x);\n    set_tail(fresh, y);\n    return fresh;\n}\n```\n\n```javascript\nmutable_pair_example\n\npair(pair(1, 2), 4);\n}\n```\n\nWe mentioned in section the\ntheoretical issues of\nsameness and change\nraised by the introduction of assignment.\n\nThese issues arise in practice\nwhen individual pairs are shared among different data objects.\n\nFor example, consider the structure formed by\n\n```javascript\npair_example1\n\nconst x = list(\"a\", \"b\");\nconst z1 = pair(x, x);\n```\n\nAs shown in\nfigure,\nhead\nand\ntail\nboth point to the same pair\nhead\nand\ntail\nof\npair\nis implemented.\n\nIn general, using\npair\nto construct lists will result in an interlinked structure of pairs in\nwhich many individual pairs are shared by many different structures.\n\nThe list pair(x, x).\n\nThe list pair(list(\"a\", \"b\"), list(\"a\", \"b\")).\n\nIn contrast to\n\n```javascript\nfigure,\n\tfigure\n```\n\nshows the structure created by\n\n```javascript\npair_example2\n\nconst z2 = pair(list(\"a\", \"b\"), list(\"a\", \"b\"));\n```\n\nIn this structure, the pairs in the two list(\"a\", \"b\") lists are distinct, although they contain the same strings.\n\nWhen thought of as a list, the same list:",
    "token_count": 303,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Mutable List Structure",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Mutable_List_Structure_2"
  },
  {
    "content": "When thought of as a list, the same list:\n\n```javascript\nabab\n      [ [ 'a', [ 'b', null ] ], [ 'a', [ 'b', null ] ] ]\n\nlist(list(\"a\", \"b\"), \"a\", \"b\")\n\nlist(list(\"a\", \"b\"), \"a\", \"b\");\n```\n\nIn general, sharing is completely undetectable if we operate on lists using\nonly\npair,\nhead,\nand\ntail.\n\nHowever, if we allow mutators on list structure, sharing becomes\nsignificant.\n\nAs an example of the difference that sharing can make,\nconsider the following\nfunction,\nwhich modifies the\nhead\nof the structure to which it is applied:\n\n```javascript\nset_to_wow\n\nfunction set_to_wow(x) {\n    set_head(head(x), \"wow\");\n    return x;\n}\n```\n\nEven though the same structure,\napplying\nset_to_wow\nto them yields different results.\n\nWith\nhead\nalso changes the\ntail,\nbecause in\nhead\nand the\ntail\nare the same pair.\n\nWith\nhead\nand\ntail\nare distinct, so\nset_to_wow\nmodifies only the\nhead:\n\n```javascript\nset_to_wow_example_1\n      pair_example1\n      [ [ 'a', [ 'b', null ] ], [ 'a', [ 'b', null ] ] ]\n\nz1;\n```\n\n```javascript\nset_to_wow_example_2\n      set_to_wow\n      pair_example1\n      [ [ 'wow', [ 'b', null ] ], [ 'wow', [ 'b', null ] ] ]\n\nset_to_wow(z1);\n```\n\n```javascript\nset_to_wow_example_3\n      pair_example2\n      [ [ 'a', [ 'b', null ] ], [ 'a', [ 'b', null ] ] ]\n\nz2;\n```\n\n```javascript\nset_to_wow_example_4\n      set_to_wow\n      pair_example2\n      [ [ 'wow', [ 'b', null ] ], [ 'a', [ 'b', null ] ] ]\n\nset_to_wow(z2);\n```\n\n```javascript\nOne way to detect sharing in list structures is to use the\n\t===,\n\twhich we introduced in\n\tsection to test whether two numbers\n\tare equal\n\tand extended in section to test whether\n\ttwo strings are equal. When applied to two nonprimitive values,\n\tx === y\n\ttests whether\n```\n\nThus, with\n\n```javascript\nfigure\n\tand,\n```\n\n```javascript\nhead(z1) === tail(z1)\n```\n\nis true and\n\n```javascript\nhead(z2) === tail(z2)\n```\n\nis false.",
    "token_count": 297,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Mutable List Structure",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Mutable_List_Structure_3"
  },
  {
    "content": "is false.\n\nAs will be seen in the following sections, we can exploit sharing to\ngreatly extend the repertoire of data structures that can be\nrepresented by pairs.\n\nOn the other hand, sharing can also be\nset_head\nand\nset_tail\nshould be used with care; unless we have a good understanding of how our\ndata objects are shared, mutation can have unanticipated\nresults.\n\nWhen we introduced compound data, we observed in section that pairs can be represented purely in terms of functions:\n\n```javascript\ncons_1_2_run\n      1\n\nfunction pair(x, y) {\n    function dispatch(m) {\n        return m === \"head\"\n               ? x\n               : m === \"tail\"\n               ? y\n               : error(m, \"undefined operation -- pair\");\n    }\n    return dispatch;\n}\n\nfunction head(z) { return z(\"head\"); }\n\nfunction tail(z) { return z(\"tail\"); }\n```\n\nThe same observation is true for mutable data.\n\nWe can implement\nmutable data objects as\nfunctions\nusing assignment and local state.\n\nFor instance, we can extend the above\npair implementation to handle\nset_head\nand\nset_tail\nin a manner analogous to the way we implemented bank accounts using\nmake_account\nin section :\n\n```javascript\ncons_1_2_run_3\n\nconst x = pair(1, 2);\nset_head(x, 3);\nhead(x);\n```\n\n```javascript\npair2\n      cons_1_2_run_3\n      3\n\nfunction pair(x, y) {\n    function set_x(v) { x = v; }\n    function set_y(v) { y = v; }\n    return m => m === \"head\"\n                ? x\n                : m === \"tail\"\n                ? y\n                : m === \"set_head\"\n                ? set_x\n                : m === \"set_tail\"\n                ? set_y\n                : error(m, \"undefined operation -- pair\");\n}\n\nfunction head(z) { return z(\"head\"); }\n\nfunction tail(z) { return z(\"tail\"); }\n\nfunction set_head(z, new_value) {\n    z(\"set_head\")(new_value);\n    return z;\n}\nfunction set_tail(z, new_value) {\n    z(\"set_tail\")(new_value);\n    return z;\n}\n```\n\nAssignment is all that is needed, theoretically, to account for the\nbehavior of mutable data.",
    "token_count": 287,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Mutable List Structure",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Mutable_List_Structure_4"
  },
  {
    "content": "Assignment is all that is needed, theoretically, to account for the\nbehavior of mutable data.\n\nAs soon as we admit\nassignment\nto our language, we raise all the issues, not only of assignment, but of\nmutable data in general.",
    "token_count": 39,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Mutable List Structure",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_Mutable_List_Structure_5"
  },
  {
    "content": "Computer programs are traditionally organized as\none-directional computations, which perform operations on prespecified\narguments to produce desired outputs.\n\nOn the other hand, we often\nmodel systems in terms of relations among quantities.\n\nFor example, a\nmathematical model of a mechanical structure might include the\ninformation that the deflection $d$ of a metal\nrod is related to the force $F$ on the rod, the\nlength $L$ of the rod, the cross-sectional\narea $A$ , and the elastic modulus\n$E$ via the equation\n\\[\n\\begin{array}{lll}\nd A E & = & F L\n\\end{array}\n\\]\nSuch an equation is not one-directional.\n\nGiven any four of the\nquantities, we can use it to compute the fifth.\n\nYet translating the\nequation into a traditional computer language would force us to choose\none of the quantities to be computed in terms of the other four.\n\nThus, a\nfunction\nfor computing the area $A$ could not be used to\ncompute the deflection $d$ , even though the\ncomputations of $A$ and\n$d$ arise from the same\nequation.\n\nIn this section, we sketch the design of a language that enables us to work\nin terms of\nprimitive constraints , which state that certain relations hold\nbetween quantities.\n\nFor example,\nadder(a, b, c)\nspecifies that the quantities $a$ ,\n$b$ , and $c$ must be\nrelated by the equation $a+b=c$ ,\nmultiplier(x, y, z)\nexpresses the constraint $xy = z$ , and\nconstant(3.14, x)\nsays that the value of $x$ must be 3.14.\n\nOur language provides a means of combining primitive constraints in order to\nexpress more complex relations.\n\nWe combine constraints by constructing\nconstraint networks , in which constraints are joined by\nconnectors.\n\nA connector is an object that holds a\nvalue that may participate in one or more constraints.",
    "token_count": 293,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Propagation of Constraints",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Propagation_of_Constraints_1"
  },
  {
    "content": "A connector is an object that holds a\nvalue that may participate in one or more constraints.\n\nFor example, we know\nthat the relationship between Fahrenheit and Celsius temperatures is\n\\[\n\\begin{array}{lll}\n9C & = & 5(F - 32)\n\\end{array}\n\\]\nSuch a constraint can be thought of as a network consisting of primitive\nadder, multiplier, and constant constraints\n(figure ).\n\nIn the figure, we see on the\nleft a multiplier box with three terminals, labeled\n$m_1$ , $m_2$ , and\n$p$.\n\nThese connect the multiplier to the rest of\nthe network as follows:\nThe $m_1$ terminal is linked to a connector\n$C$ , which will hold the Celsius temperature.\n\nThe $m_2$ terminal is linked to a connector\n$w$ , which is also linked to a constant box that\nholds 9.\n\nThe $p$ terminal, which the multiplier\nbox constrains to be the product of $m_1$ and\n$m_2$ , is linked to the\n$p$ terminal of another multiplier box, whose\n$m_2$ is connected to a constant 5 and whose\n$m_1$ is connected to one of the terms in a sum.\n\nThe relation $9C = 5(F - 32)$\nexpressed as a constraint network.\n\nComputation by such a network proceeds as follows: When a connector is\ngiven a value (by the user or by a constraint box to which it is\nlinked), it awakens all of its associated constraints (except for the\nconstraint that just awakened it) to inform them that it has a value.\n\nEach awakened constraint box then polls its connectors to see if there\nis enough information to determine a value for a connector.\n\nIf so,\nthe box sets that connector, which then awakens all of its associated\nconstraints, and so on.",
    "token_count": 282,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Propagation of Constraints",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Propagation_of_Constraints_2"
  },
  {
    "content": "If so,\nthe box sets that connector, which then awakens all of its associated\nconstraints, and so on.\n\nFor instance, in conversion between\nCelsius and Fahrenheit, $w$ ,\n$x$ , and $y$ are\nimmediately set by the constant boxes to $9$, $5$, and $32$, respectively.\n\nThe\nconnectors awaken the multipliers and the adder, which determine that there\nis not enough information to proceed.\n\nIf the user (or some other part of\nthe network) sets $C$ to a value (say 25), the\nleftmost multiplier will be awakened, and it will set\n$u$ to $25\\cdot 9=225$.\n\nThen $u$ awakens the second multiplier, which sets\n$v$ to $45$, and $v$\nawakens the adder, which sets $F$ to $77$.\n\n```javascript\nTo use the constraint system to carry out the temperature computation\n\toutlined above, we first call the constructor\n\tmake_connector\n\tto create two connectors,\n```\n\n```javascript\ncelsius_fahrenheit_converter_example\n      celsius_fahrenheit_converter\n      'ok'\n\nconst C = make_connector();\nconst F = make_connector();\ncelsius_fahrenheit_converter(C, F);\n```\n\nThe function that creates the network is defined as follows:\n\n```javascript\ncelsius_fahrenheit_converter\n      make_connector\n      multiplier_2\n      adder\n      constant\n      celsius_fahrenheit_converter_example\n      'ok'\n\nfunction celsius_fahrenheit_converter(c, f) {\n    const u = make_connector();\n    const v = make_connector();\n    const w = make_connector();\n    const x = make_connector();\n    const y = make_connector();\n    multiplier(c, w, u);\n    multiplier(v, x, u);\n    adder(v, y, f);\n    constant(9, w);\n    constant(5, x);\n    constant(32, y);\n    return \"ok\";\n}\n```\n\nThis function creates the internal connectors using the primitive constraint constructors , expressing these combinations of primitive elements in terms of functions automatically provides our\n\nlanguage with a means of abstraction for compound objects.\n\nTo watch the network in action, we can place probes on the connectors\nfunction\nsimilar to the one we used to monitor wires in\nsection.\n\nPlacing a probe on a\nconnector will cause a message to be printed whenever the connector is\ngiven a value:\n\n```javascript\ncelsius_probe\n      probe_2\n      celsius_fahrenheit_converter_example\n\nprobe(\"Celsius temp\", C);\nprobe(\"Fahrenheit temp\", F);\n```",
    "token_count": 306,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Propagation of Constraints",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Propagation_of_Constraints_3"
  },
  {
    "content": "Placing a probe on a\nconnector will cause a message to be printed whenever the connector is\ngiven a value:\n\nNext we set the value of set_value tells\n\n```javascript\nset_value_example\n      has_value\n      celsius_probe\n      'done'\n\nset_value(C, 25, \"user\");\n```\n\nThe probe on\n\nNow we can try to set\n\n```javascript\nset_value_example_2\n      set_value_example\n\nset_value(F, 212, \"user\");\n```\n\nThe connector complains that it has sensed a contradiction: Its value\nis 77, and someone is trying to set it to 212.\n\nIf we really want to\nreuse the network with new values, we can tell\n\n```javascript\nforget_value_example\n      set_value_example\n      'done'\n\nforget_value(C, \"user\");\n```\n\n\"user\",\nwho set its value originally, is now retracting that value, so\n77.\n\nThus,\n\nNow that\n\n```javascript\nset_value_example_3\n      forget_value_example\n      'done'\n\nset_value(F, 212, \"user\");\n```\n\nThis new value, when propagated through the network, forces\n\nThe constraint system is implemented via procedural objects with local\nstate, in a manner very similar to the digital-circuit simulator of\nsection.\n\nAlthough the primitive\nobjects of the constraint system are somewhat more complex, the overall\nsystem is simpler, since there is no concern about agendas and logic delays.\n\nThe basic\n-\n-\nhas_value(connector)\ntells whether the connector has a value.\n-\n-\nget_value(connector)\nreturns the connector s current value.\n-\n-\nset_value(connector, new-value, informant)\nindicates that the informant is requesting the connector to set its\nvalue to the new value.\n-\n-\nforget_value(connector, retractor)\ntells the connector that the retractor is requesting it to forget its\nvalue.\n-\n-\nconnect(connector, new-constraint)\ntells the connector to participate in the new constraint.\n\nThe connectors communicate with the constraints by means of the\nfunctions\ninform_@about_@value,\nwhich tells the given constraint that the connector has a value, and\ninform_@about_@no_@value,\nwhich tells the constraint that the connector has lost its value.\n\nfunction with local state (the function",
    "token_count": 292,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Propagation of Constraints",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Propagation_of_Constraints_4"
  },
  {
    "content": "function with local state (the function\n\n```javascript\nadder\n      has_value\n\nfunction adder(a1, a2, sum) {\n    function process_new_value() {\n        if (has_value(a1) && has_value(a2)) {\n            set_value(sum, get_value(a1) + get_value(a2), me);\n        } else if (has_value(a1) && has_value(sum)) {\n            set_value(a2, get_value(sum) - get_value(a1), me);\n        } else if (has_value(a2) && has_value(sum)) {\n            set_value(a1, get_value(sum) - get_value(a2), me);\n        } else {}\n    }\n    function process_forget_value() {\n        forget_value(sum, me);\n        forget_value(a1, me);\n        forget_value(a2, me);\n        process_new_value();\n    }\n    function me(request) {\n        if (request === \"I have a value.\") {\n            process_new_value();\n        } else if (request === \"I lost my value.\") {\n            process_forget_value();\n        } else {\n            error(request, \"unknown request -- adder\");\n        }\n    }\n    connect(a1, me);\n    connect(a2, me);\n    connect(sum, me);\n    return me;\n}\n```\n\nThe function\nconnects the new adder to the designated\nconnectors and returns it as its value.\n\nThe\nfunction\nfunctions.\n\nThe following\nsyntax interfaces (see\nfootnote in\nsection ) are used in conjunction\nwith the dispatch:\n\n```javascript\ninform_about_value\n\nfunction inform_about_value(constraint) {\n    return constraint(\"I have a value.\");\n}\n\nfunction inform_about_no_value(constraint) {\n    return constraint(\"I lost my value.\");\n}\n```\n\nThe adder s local\nfunction\nprocess_new_value\nis called when the adder is informed that one of its connectors has a value.\n\nThe adder first checks to see if both\nset_value\nis\nprocess_new_value.\n\nThe reason for this last step is that one or more connectors may still\nhave a value (that is, a connector may have had a value that was not\noriginally set by the adder), and these values may need to be\npropagated back through the adder.\n\nA multiplier is very similar to an adder.\n\nIt will set its",
    "token_count": 255,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Propagation of Constraints",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_Propagation_of_Constraints_5"
  },
  {
    "content": "It will set its\n\n```javascript\nmultiplier_2\n      has_value\n\nfunction multiplier(m1, m2, product) {\n    function process_new_value() {\n        if ((has_value(m1) && get_value(m1) === 0)\n         || (has_value(m2) && get_value(m2) === 0)) {\n            set_value(product, 0, me);\n        } else if (has_value(m1) && has_value(m2)) {\n            set_value(product, get_value(m1) * get_value(m2), me);\n        } else if (has_value(product) && has_value(m1)) {\n            set_value(m2, get_value(product) / get_value(m1), me);\n        } else if (has_value(product) && has_value(m2)) {\n            set_value(m1, get_value(product) / get_value(m2), me);\n        } else {}\n    }\n    function process_forget_value() {\n        forget_value(product, me);\n        forget_value(m1, me);\n        forget_value(m2, me);\n        process_new_value();\n    }\n    function me(request) {\n        if (request === \"I have a value.\") {\n            process_new_value();\n        } else if (request === \"I lost my value.\") {\n            process_forget_value();\n        } else {\n            error(request, \"unknown request -- multiplier\");\n        }\n    }\n    connect(m1, me);\n    connect(m2, me);\n    connect(product, me);\n    return me;\n}\n```\n\nA \"I have a value.\" or \"I lost my value.\" message sent to the constant box will produce an error.\n\n```javascript\nconstant\n      has_value\n\nfunction constant(value, connector) {\n    function me(request) {\n        error(request, \"unknown request -- constant\");\n    }\n    connect(connector, me);\n    set_value(connector, value, me);\n    return me;\n}\n```\n\nFinally, a probe prints a message about the setting or unsetting of the designated connector:\n\n```javascript\nredefine_display\n\nconst display = x => x;\n```\n\n```javascript\nprobe_2\n      redefine_display\n      has_value\n\nfunction probe(name, connector) {\n    function print_probe(value) {\n        display(\"Probe: \" + name + \" = \" + stringify(value));\n    }\n    function process_new_value() {\n        print_probe(get_value(connector));\n    }\n    function process_forget_value() {\n        print_probe(\"?\");\n    }\n    function me(request) {\n        return request === \"I have a value.\"\n               ? process_new_value()\n               : request === \"I lost my value.\"\n               ? process_forget_value()\n               : error(request, \"unknown request -- probe\");\n    }\n    connect(connector, me);\n    return me;\n}\n```\n\nA connector is represented as a procedural object with local state variables s value; and",
    "token_count": 275,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Propagation of Constraints",
    "chunk_index": 6,
    "chunk_id": "Modularity_Objects_and_State_Propagation_of_Constraints_6"
  },
  {
    "content": "A connector is represented as a procedural object with local state variables s value; and\n\n```javascript\nmake_connector\n      for_each_except\n      inform_about_value\n      has_value\n\nfunction make_connector() {\n    let value = false;\n    let informant = false;\n    let constraints = null;\n    function set_my_value(newval, setter) {\n        if (!has_value(me)) {\n            value = newval;\n            informant = setter;\n            return for_each_except(setter,\n                                   inform_about_value,\n                                   constraints);\n        } else if (value !== newval) {\n            error(list(value, newval), \"contradiction\");\n        } else {\n            return \"ignored\";\n        }\n    }\n    function forget_my_value(retractor) {\n        if (retractor === informant) {\n            informant = false;\n            return for_each_except(retractor,\n                                   inform_about_no_value,\n                                   constraints);\n        } else {\n            return \"ignored\";\n        }\n    }\n    function connect(new_constraint) {\n        if (is_null(member(new_constraint, constraints))) {\n            constraints = pair(new_constraint, constraints);\n        } else {}\n        if (has_value(me)) {\n            inform_about_value(new_constraint);\n        } else {}\n        return \"done\";\n    }\n    function me(request) {\n        if (request === \"has_value\") {\n            return informant !== false;\n        } else if (request === \"value\") {\n            return value;\n        } else if (request === \"set_value\") {\n            return set_my_value;\n        } else if (request === \"forget\") {\n            return forget_my_value;\n        } else if (request === \"connect\") {\n            return connect;\n        } else {\n            error(request, \"unknown operation -- connector\");\n        }\n    }\n    return me;\n}\n```\n\nThe connector s local\nfunction\nset_my_value\nis called when there is a request to set the connector s value.\n\nIf\nthe connector does not currently have a value, it will set its value and\nremember as\nfunction\nto all items in a list except a given one:\n\n```javascript\nfor_each_except\n\nfunction for_each_except(exception, fun, list) {\n    function loop(items) {\n        if (is_null(items)) {\n            return \"done\";\n        } else if (head(items) === exception) {\n            return loop(tail(items));\n        } else {\n            fun(head(items));\n            return loop(tail(items));\n        }\n    }\n    return loop(list);\n}\n```\n\nIf a connector is asked to forget its value, it runs\n\n```javascript\nforget_my_value,\n\ta local function that\n```\n\nfirst checks to make sure that the request is coming from the same\nobject that set the value originally.",
    "token_count": 297,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Propagation of Constraints",
    "chunk_index": 7,
    "chunk_id": "Modularity_Objects_and_State_Propagation_of_Constraints_7"
  },
  {
    "content": "first checks to make sure that the request is coming from the same\nobject that set the value originally.\n\nIf so, the connector informs its\nassociated constraints about the loss of the value.\n\nThe local function Then, if the connector has a value, it informs the new constraint of this fact.\n\nThe connector s\nfunction\nfunctions\nand also represents the connector as an object.\n\nThe following\nfunctions\nprovide a syntax interface for the dispatch:\n\n```javascript\nhas_value\n\nfunction has_value(connector) {\n    return connector(\"has_value\");\n}\nfunction get_value(connector) {\n    return connector(\"value\");\n}\nfunction set_value(connector, new_value, informant) {\n    return connector(\"set_value\")(new_value, informant);\n}\nfunction forget_value(connector, retractor) {\n    return connector(\"forget\")(retractor);\n}\n\nfunction connect(connector, new_constraint) {\n    return connector(\"connect\")(new_constraint);\n}\n```",
    "token_count": 112,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Propagation of Constraints",
    "chunk_index": 8,
    "chunk_id": "Modularity_Objects_and_State_Propagation_of_Constraints_8"
  },
  {
    "content": "The mutators\nset_head\nand\nset_tail\nenable us to use pairs to construct data structures that cannot be built\nwith\npair,\nhead,\nand\ntail\nalone.\n\nThis section shows how to use pairs to represent a data structure\ncalled a queue.\n\nSection will show how to\nrepresent data structures called tables.\n\nA queue is a sequence in which items are inserted at one end\n(called the\nrear of the queue) and deleted from the other end (the\nfront ).\n\nFigure\nshows an initially empty queue in which the items\nFIFO (first in, first out) buffer.\n\n```javascript\nOperation\n\n\t\tResulting Queue\n\n\t\tconst q = make_queue();\n\n\t\tinsert_queue(q, \"a\");\n\n\t\ta\n\n\t\tinsert_queue(q, \"b\");\n\n\t\ta  b\n\n\t\tdelete_queue(q);\n\n\t\tb\n\n\t\tinsert_queue(q, \"c\");\n\n\t\tb c\n\n\t\tinsert_queue(q, \"d\");\n\n\t\tb c d\n\n\t\tdelete_queue(q);\n\n\t\tc d\n\n          Queue operations.\n```\n\nIn terms of - - a constructor: make_queue() returns an empty queue (a queue containing no items). \\vspace{6pt} - - a predicate: is_empty_queue(queue) tests if\n\nthe queue is empty. \\vspace{6pt} - - a selector: front_queue(queue) returns the object at the front of the queue, signaling an error if the queue\n\nis empty; it does not modify the queue. \\vspace{6pt} - - two mutators: insert_queue(queue, item) inserts \\\\[4pt] delete_queue(queue) removes\n\nBecause a queue is a sequence of items, we could certainly represent\nit as an ordinary list; the front of the queue would be the\nhead\nof the list, inserting an item in the queue would amount to appending\na new element at the end of the list, and deleting an item from the\nqueue would just be taking the\ntail\nof the list.\n\nHowever, this representation is inefficient, because in order\nto insert an item we must scan the list until we reach the end.",
    "token_count": 280,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Representing Queues",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Representing_Queues_1"
  },
  {
    "content": "However, this representation is inefficient, because in order\nto insert an item we must scan the list until we reach the end.\n\nSince the\nonly method we have for scanning a list is by successive\ntail\noperations, this scanning requires $\\Theta(n)$\nsteps for a list of $n$ items.\n\nA simple\nmodification to the list representation overcomes this disadvantage by\nallowing the queue operations to be implemented so that they require\n$\\Theta(1)$ steps; that is, so that the number\nof steps needed is independent of the length of the queue.\n\nThe difficulty with the list representation arises from the need to\nscan to find the end of the list.\n\nThe reason we need to scan is that,\nalthough the standard way of representing a list as a chain of pairs\nreadily provides us with a pointer to the beginning of the list, it\ngives us no easily accessible pointer to the end.\n\nThe modification\nthat avoids the drawback is to represent the queue as a list, together\nwith an additional pointer that indicates the final pair in the list.\n\nThat way, when we go to insert an item, we can consult the rear\npointer and so avoid scanning the list.\n\nA queue is represented, then, as a pair of pointers,\nfront_ptr\nand\nrear_ptr,\nwhich indicate, respectively, the first and last pairs in an ordinary list.\n\nSince we would like the queue to be an identifiable object, we can use\npair\nto combine the two pointers.\n\nThus, the queue itself will be the\npair\nof the two pointers.\n\nFigure\nillustrates this representation.\n\nImplementation of a queue as a list with front and rear pointers.\n\nTo define the queue operations we use the following functions, which enable us to select and to modify the front and rear pointers of a\n\nqueue:",
    "token_count": 298,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Representing Queues",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Representing_Queues_2"
  },
  {
    "content": "queue:\n\n```javascript\nmodify_pointers_example\n\nconst q = pair(1, 2);\nset_front_ptr(q, 42);\nfront_ptr(q);\n```\n\n```javascript\nmodify_pointers\n      modify_pointers_example\n      42\n\nfunction front_ptr(queue) { return head(queue); }\n\nfunction rear_ptr(queue) { return tail(queue); }\n\nfunction set_front_ptr(queue, item) { set_head(queue, item); }\n\nfunction set_rear_ptr(queue, item) { set_tail(queue, item); }\n```\n\nNow we can implement the actual queue operations.\n\nWe will consider a\nqueue to be empty if its front pointer is the empty list:\n\n```javascript\nis_empty_queue_example\n\nconst q = pair(null, 2);\nis_empty_queue(q);\n```\n\n```javascript\nmodify_pointers\n      is_empty_queue\n      is_empty_queue_example\n      true\n\nfunction is_empty_queue(queue) { return is_null(front_ptr(queue)); }\n```\n\nThe make_queue constructor returns, as an initially empty queue, a pair whose head and tail are both the empty list:\n\n```javascript\nmake_queue_example\n      modify_pointers\n\nconst q = make_queue();\nfront_ptr(q);\n```\n\n```javascript\nmake_queue\n      make_queue_example\n      null\n\nfunction make_queue() { return pair(null, null); }\n```\n\nTo select the item at the front of the queue, we return the head of the pair indicated by the front pointer:\n\n```javascript\nfront_queue_example\n\nconst q = pair(pair(1, 2), 3);\nfront_queue(q);\n```\n\n```javascript\nfront_queue\n      is_empty_queue\n      front_queue_example\n      1\n\nfunction front_queue(queue) {\n    return is_empty_queue(queue)\n           ? error(queue, \"front_queue called with an empty queue\")\n           : head(front_ptr(queue));\n}\n```\n\nTo insert an item in a queue, we follow the method whose result is\nindicated in\nfigure.\n\nWe first create a new\npair whose\nhead\nis the item to be inserted and whose\ntail\nis the empty list.\n\nIf the queue was initially empty, we set the front and\nrear pointers of the queue to this new pair.\n\nOtherwise, we modify the\nfinal pair in the queue to point to the new pair, and also set the\nrear pointer to the new pair.\n\n```javascript\nResult of using\n\t    insert_queue(q, \"d\") on the\n\t    queue of figure.\n```\n\n```javascript\nprint_queue_example\n      make_queue\n      insert_queue\n      delete_queue\n\nconst q1 = make_queue();\ninsert_queue(q1, \"a\");\ninsert_queue(q1, \"b\");\ndelete_queue(q1);\ndelete_queue(q1);\n```",
    "token_count": 294,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Representing Queues",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Representing_Queues_3"
  },
  {
    "content": "Otherwise, we modify the\nfinal pair in the queue to point to the new pair, and also set the\nrear pointer to the new pair.\n\n```javascript\ninsert_queue\n      modify_pointers\n      is_empty_queue\n      print_queue_example\n      [ null, [ 'b', null ] ]\n\nfunction insert_queue(queue, item) {\n    const new_pair = pair(item, null);\n    if (is_empty_queue(queue)) {\n        set_front_ptr(queue, new_pair);\n        set_rear_ptr(queue, new_pair);\n    } else {\n        set_tail(rear_ptr(queue), new_pair);\n        set_rear_ptr(queue, new_pair);\n    }\n    return queue;\n}\n```\n\nTo delete the item at the front of the queue, we merely modify the front pointer so that it now points at the second item\n\nin the queue, which can be found by following the tail pointer of the first item (see figure ):\n\n```javascript\nResult of using delete_queue(q)\n\t    on the queue of figure.\n```\n\n```javascript\ndelete_queue\n      is_empty_queue\n      modify_pointers\n      print_queue_example\n      [ null, [ 'b', null ] ]\n\nfunction delete_queue(queue) {\n    if (is_empty_queue(queue)) {\n        error(queue, \"delete_queue called with an empty queue\");\n    } else {\n        set_front_ptr(queue, tail(front_ptr(queue)));\n        return queue;\n    }\n}\n```",
    "token_count": 155,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Representing Queues",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Representing_Queues_4"
  },
  {
    "content": "When we studied various ways of representing sets in chapter , we\nmentioned in section the task of\nmaintaining a table of records\n, we made extensive use of\ntwo-dimensional tables, in which information is stored and retrieved\nusing two keys.\n\nHere we see how to build tables as mutable list\nstructures.\n\nWe first consider a\nheads\npoint to successive records.\n\nThese gluing pairs are called the\nbackbone of the table.\n\nIn order to have a place that we can\nchange when we add a new record to the table, we build the table as a\nheaded list.\n\nA headed list has a special backbone pair at the\nbeginning, which holds a dummy record in this case\nthe arbitrarily chosen\nstring \"*table*\".\n\nFigure\nshows the box-and-pointer diagram for the table\n\n```javascript\na: 1\nb: 2\nc: 3\n```\n\nA table represented as a headed list.\n\nTo extract information from a table we use the\nfunction,\nwhich takes a key as argument and returns the associated value (or\nundefined\nif\nthere is no value stored under that key).\n\nThe function lookup\nis defined in terms of the\nThe function assoc\nreturns the record that has the given key as its\nhead.\n\nThe function lookup\nthen checks to see that the resulting record returned by\nundefined,\nand returns the value (the\ntail)\nof the record.\n\n```javascript\nlookup1_example\n      make_table1\n      insert_into_table1\n\nconst t = make_table();\ninsert(\"a\", 10, t);\nlookup(\"a\", t);\n```\n\n```javascript\nlookup1\n      lookup1_example\n      10\n\nfunction lookup(key, table) {\n    const record = assoc(key, tail(table));\n    return is_undefined(record)\n           ? undefined\n           : tail(record);\n}\nfunction assoc(key, records) {\n    return is_null(records)\n           ? undefined\n           : equal(key, head(head(records)))\n           ? head(records)\n           : assoc(key, tail(records));\n}\n```",
    "token_count": 275,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Representing Tables",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Representing_Tables_1"
  },
  {
    "content": "The function lookup\nthen checks to see that the resulting record returned by\nundefined,\nand returns the value (the\ntail)\nof the record.\n\nTo insert a value in a table under a specified key, we first use\npairing\nthe key with the value, and insert this at the head of the table s\nlist of records, after the dummy record.\n\nIf there already is a record with\nthis key, we set the\ntail\nof this record to the designated new value.\n\nThe header of the table\nprovides us with a fixed location to modify in order to insert the new\nrecord.\n\n```javascript\nlookup1\n      insert_into_table1\n\nfunction insert(key, value, table) {\n    const record = assoc(key, tail(table));\n    if (is_undefined(record)) {\n        set_tail(table,\n                 pair(pair(key, value), tail(table)));\n    } else {\n        set_tail(record, value);\n    }\n    return \"ok\";\n}\n```\n\nTo construct a new table, we simply create a list containing just the string\n\n```javascript\nmake_table1\n\nfunction make_table() {\n    return list(\"*table*\");\n}\n```\n\nIn a two-dimensional table, each value is indexed by two keys.\n\nWe can\nconstruct such a table as a one-dimensional table in which each key\nidentifies a subtable.\n\nFigure\nshows the box-and-pointer diagram for the table\n\n```javascript\n\"math\":\n    \"+\":  43\n    \"-\":  45\n    \"*\":  42\n\"letters\":\n    \"a\":  97\n    \"b\":  98\n```\n\nwhich has two subtables.\n\n(The subtables don t need a special header\nstring,\nsince the key that identifies the subtable serves this purpose.)\nA two-dimensional table.\n\nWhen we look up an item, we use the first key to identify the correct\nsubtable.\n\nThen we use the second key to identify the record within the\nsubtable.\n\n```javascript\nlookup2_example\n      make_table2\n      insert_into_table2\n\nconst t = list(\"*table*\");\ninsert(\"a\", \"b\", 10, t);\nlookup(\"a\", \"b\", t);\n```\n\n```javascript\njust_assoc\n\nfunction assoc(key, records) {\n    return is_null(records)\n           ? undefined\n           : equal(key, head(head(records)))\n           ? head(records)\n           : assoc(key, tail(records));\n}\n```",
    "token_count": 295,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Representing Tables",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Representing_Tables_2"
  },
  {
    "content": "Then we use the second key to identify the record within the\nsubtable.\n\n```javascript\nlookup2\n      just_assoc\n      lookup2_example\n      10\n\nfunction lookup(key_1, key_2, table) {\n    const subtable = assoc(key_1, tail(table));\n    if (is_undefined(subtable)) {\n        return undefined;\n    } else {\n        const record = assoc(key_2, tail(subtable));\n        return is_undefined(record)\n               ? undefined\n               : tail(record);\n    }\n}\n```\n\nTo insert a new item under a pair of keys, we use (key_2,\n\n```javascript\njust_assoc\n      insert_into_table2\n\nfunction insert(key_1, key_2, value, table) {\n    const subtable = assoc(key_1, tail(table));\n    if (is_undefined(subtable)) {\n        set_tail(table,\n                 pair(list(key_1, pair(key_2, value)), tail(table)));\n    } else {\n        const record = assoc(key_2, tail(subtable));\n        if (is_undefined(record)) {\n            set_tail(subtable,\n                     pair(pair(key_2, value), tail(subtable)));\n        } else {\n            set_tail(record, value);\n        }\n    }\n    return \"ok\";\n}\n```\n\nThe\ninsert\noperations defined above take the table as an argument.\n\nThis enables us to\nuse programs that access more than one table.\n\nAnother way to deal with\nmultiple tables is to have separate\ninsert\nfunctions\nfor each table.\n\nWe can do this by representing a table procedurally, as an\nobject that maintains an internal table as part of its local state.\n\nWhen\nsent an appropriate message, this table object supplies the\nfunction\nwith which to operate on the internal table.\n\nHere is a generator for\ntwo-dimensional tables represented in this fashion:",
    "token_count": 203,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Representing Tables",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Representing_Tables_3"
  },
  {
    "content": "Here is a generator for\ntwo-dimensional tables represented in this fashion:\n\n```javascript\nmake_table2\n      just_assoc\n\nfunction make_table() {\n    const local_table = list(\"*table*\");\n    function lookup(key_1, key_2) {\n        const subtable = assoc(key_1, tail(local_table));\n        if (is_undefined(subtable)) {\n            return undefined;\n        } else {\n            const record = assoc(key_2, tail(subtable));\n            return is_undefined(record)\n                   ? undefined\n                   : tail(record);\n        }\n    }\n    function insert(key_1, key_2, value) {\n        const subtable = assoc(key_1, tail(local_table));\n        if (is_undefined(subtable)) {\n            set_tail(local_table,\n                     pair(list(key_1, pair(key_2, value)),\n                          tail(local_table)));\n        } else {\n            const record = assoc(key_2, tail(subtable));\n            if (is_undefined(record)) {\n                set_tail(subtable,\n                         pair(pair(key_2, value), tail(subtable)));\n            } else {\n                set_tail(record, value);\n            }\n        }\n    }\n    function dispatch(m) {\n        return m === \"lookup\"\n               ? lookup\n               : m === \"insert\"\n               ? insert\n               : error(m, \"unknown operation -- table\");\n    }\n    return dispatch;\n}\n```\n\nUsing make_table, we could for data-directed programming, as follows:\n\n```javascript\noperation_table_example\n\nput(\"a\", \"b\", 10);\nget(\"a\", \"b\");\n```\n\n```javascript\noperation_table\n      make_table2\n      operation_table_example\n      10\n\nconst operation_table = make_table();\nconst get = operation_table(\"lookup\");\nconst put = operation_table(\"insert\");\n```\n\nThe function get takes as arguments two keys, and make_table.",
    "token_count": 163,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Modeling with Mutable Data",
    "subsection": "Representing Tables",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Representing_Tables_4"
  },
  {
    "content": "We ve gained a good understanding of assignment as a tool in modeling,\nas well as an appreciation of the complex problems that assignment\nraises.\n\nIt is time to ask whether we could have gone about things in a\ndifferent way, so as to avoid some of these problems.\n\nIn this\nsection, we explore an alternative approach to modeling state, based\non data structures called streams.\n\nAs we shall see, streams can\nmitigate some of the complexity of modeling state.\n\nLet s step back and review where this complexity comes from.\n\nIn an\nattempt to model real-world phenomena, we made some apparently\nreasonable decisions: We modeled real-world objects with local state\nby computational objects with local variables.\n\nWe identified time\nvariation in the real world with time variation in the computer.\n\nWe\nimplemented the time variation of the states of the model objects in\nthe computer with assignments to the local variables of the model\nobjects.\n\nIs there another approach?\n\nCan we avoid identifying time in the\ncomputer with time in the modeled world?\n\nMust we make the model\nchange with time in order to model phenomena in a changing world?\n\nThink about the issue in terms of mathematical functions.\n\nWe can\ndescribe the time-varying behavior of a quantity\n$x$ as a function of time\n$x(t)$.\n\nIf we concentrate on $x$ instant by instant,\nwe think of it as a changing quantity.\n\nYet if we concentrate on the entire\ntime history of values, we do not emphasize change the function\nitself does not change.\n\nIf time is measured in discrete steps, then we can model a time function as\na (possibly infinite) sequence.\n\nIn this section, we will see how to\nmodel change in terms of sequences that represent the time histories\nof the systems being modeled.",
    "token_count": 297,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Streams_1"
  },
  {
    "content": "In this section, we will see how to\nmodel change in terms of sequences that represent the time histories\nof the systems being modeled.\n\nTo accomplish this, we introduce new\ndata structures called streams.\n\nFrom an abstract point of view,\na stream is simply a sequence.\n\nHowever, we will find that the\nstraightforward implementation of streams as lists (as in\nsection ) doesn t fully reveal\nthe power of stream processing.\n\nAs an alternative, we introduce the\ntechnique of\ndelayed evaluation , which enables us to represent\nvery large (even infinite) sequences as streams.\n\nStream processing lets us model systems that have state without ever\nusing assignment or mutable data.\n\nThis has important implications,\nboth theoretical and practical, because we can build models that avoid\nthe drawbacks inherent in introducing assignment.\n\nOn the other hand,\nthe stream framework raises difficulties of its own, and the question\nof which modeling technique leads to more modular and more easily\nmaintained systems remains open.",
    "token_count": 161,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Streams_2"
  },
  {
    "content": "Streams with delayed evaluation can be a powerful modeling tool,\nproviding many of the benefits of local state and assignment.\n\nMoreover, they avoid some of the theoretical tangles that accompany\nthe introduction of assignment into a programming language.\n\nThe stream approach can be illuminating because it allows us to build systems with different\n\nIn section , we introduced\niterative processes, which proceed by updating state variables.\n\nWe know now\nthat we can represent state as a timeless stream of values\nrather than as a set of variables to be updated.\n\nLet s adopt this\nperspective in revisiting the square-root\nfunction\nfrom section.\n\nRecall that the idea is to\ngenerate a sequence of better and better guesses for the square root of\n$x$ by applying over and over again the\nfunction\nthat improves guesses:\n\n```javascript\nsqrt_improve_example\n\nsqrt_improve(1.2, 2);\n```\n\n```javascript\nsqrt_improve\n      average_definition\n      sqrt_improve_example\n      1.4333333333333333\n\nfunction sqrt_improve(guess, x) {\n    return average(guess, x / guess);\n}\n```\n\nIn our original\nfunction,\nwe made these guesses be the successive values of a state variable.\n\nInstead\nwe can generate the infinite stream of guesses, starting with an initial\nguess of 1:\n\n```javascript\nsqrt_stream\n      sqrt_improve\n      sqrt_stream_example\n\nfunction sqrt_stream(x) {\n   return pair(1, () => stream_map(guess => sqrt_improve(guess, x),\n                                   sqrt_stream(x)));\n}\n```\n\n```javascript\nsqrt_stream_example\n      display_stream\n      sqrt_stream\n      1.414213562373095\n\ndisplay_stream(sqrt_stream(2));\n\nstream_ref(sqrt_stream(2), 5);\n```\n\nWe can generate more and more terms of the stream to get better and\nbetter guesses.\n\nIf we like, we can write a\nfunction\nthat keeps generating terms until the answer is good enough.\n\n(See exercise.)\n\nAnother iteration that we can treat in the same way is to generate an\napproximation to\n$\\pi$ , based upon the\nalternating series that we saw in\nsection :\n\\[\n\\begin{array}{lll}\n\\dfrac {\\pi}{4} &=& 1-\\dfrac{1}{3}+\\dfrac{1}{5}-\\dfrac{1}{7}+\\cdots\n\\end{array}\n\\]\nWe first generate the stream of summands of the series (the reciprocals\nof the odd integers, with alternating signs).",
    "token_count": 305,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Exploiting the Stream Paradigm",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Exploiting_the_Stream_Paradigm_1"
  },
  {
    "content": "Another iteration that we can treat in the same way is to generate an\napproximation to\n$\\pi$ , based upon the\nalternating series that we saw in\nsection :\n\\[\n\\begin{array}{lll}\n\\dfrac {\\pi}{4} &=& 1-\\dfrac{1}{3}+\\dfrac{1}{5}-\\dfrac{1}{7}+\\cdots\n\\end{array}\n\\]\nWe first generate the stream of summands of the series (the reciprocals\nof the odd integers, with alternating signs).\n\nThen we take the stream\nof sums of more and more terms (using the\npartial_sums function\nof exercise ) and scale the result by 4:\n\n```javascript\npi_stream\n      display_stream\n      scale_stream\n      partial_sums\n      pi_stream_example\n\nfunction pi_summands(n) {\n   return pair(1 / n, () => stream_map(x => - x, pi_summands(n + 2)));\n}\nconst pi_stream = scale_stream(partial_sums(pi_summands(1)), 4);\n```\n\n```javascript\npi_stream_example\n      pi_stream\n      3.017071817071818\n\ndisplay_stream(pi_stream);\n\nstream_ref(pi_stream, 7);\n```\n\nThis gives us a stream of better and better approximations to\n$\\pi$ , although the approximations converge\nrather slowly.\n\nEight terms of the sequence bound the value of\n$\\pi$ between 3.284 and 3.017.\n\nSo far, our use of the stream of states approach is not much different\nfrom updating state variables.\n\nBut streams give us an opportunity to do\nsome interesting tricks.\n\nFor example, we can transform a stream with a\nsequence accelerator that converts a sequence of approximations to a\nnew sequence that converges to the same value as the original, only faster.\n\nOne such accelerator, due to the eighteenth-century Swiss mathematician s technique, if $S_n$ is the $n$ th term of the original sum sequence, then the\n\naccelerated sequence has terms \\[ \\begin{array}{l} S_{n+1} - \\dfrac{(S_{n+1}-S_n)^2}{S_{n-1}-2S_n+S_{n+1}} \\end{array} \\] Thus, if the original sequence is represented as a stream of values, the transformed\n\nsequence is given by",
    "token_count": 266,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Exploiting the Stream Paradigm",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Exploiting_the_Stream_Paradigm_2"
  },
  {
    "content": "sequence is given by\n\n```javascript\neuler_transform\n      square_definition\n      memo\n      euler_transform_example\n      3.1418396189294033\n\nfunction euler_transform(s) {\n    const s0 = stream_ref(s, 0);     // $S_{n-1}$\n    const s1 = stream_ref(s, 1);     // $S_{n}$\n    const s2 = stream_ref(s, 2);     // $S_{n+1}$\n    return pair(s2 - square(s2 - s1) / (s0 + (-2) * s1 + s2),\n                memo(() => euler_transform(stream_tail(s))));\n}\n```\n\n```javascript\nNote that we make use of the memoization optimization of\n\t  section, because in the\n\t  following we will rely on repeated evaluation of the resulting stream.\n```\n\nWe can demonstrate Euler acceleration with our sequence of approximations to $\\pi$ :\n\n```javascript\neuler_transform_example\n      euler_transform\n      display_stream\n      pi_stream\n      3.1418396189294033\n\ndisplay_stream(euler_transform(pi_stream));\n\nstream_ref(euler_transform(pi_stream), 8);\n```\n\nEven better, we can accelerate the accelerated sequence, and recursively\naccelerate that, and so on.\n\nNamely, we create a stream of streams (a\nstructure we ll call a\ntableau ) in which each stream is the transform of the preceding one:\n\n```javascript\nmake_tableau\n\nfunction make_tableau(transform, s) {\n    return pair(s, () => make_tableau(transform, transform(s)));\n}\n```\n\nThe tableau has the form \\[ \\begin{array}{llllll} s_{00} & s_{01} & s_{02} & s_{03} & s_{04} & \\ldots\\\\ & s_{10} & s_{11} & s_{12} &\n\ns_{13} & \\ldots\\\\ & & s_{20} & s_{21} & s_{22} & \\ldots\\\\ & & & & \\ldots & \\end{array} \\] Finally, we form a sequence\n\nby taking the first term in each row of the tableau:\n\n```javascript\naccelerated_sequence\n      make_tableau\n      accelerated_sequence_example\n\nfunction accelerated_sequence(transform, s) {\n    return stream_map(head, make_tableau(transform, s));\n}\n```\n\nWe can demonstrate this kind of super-acceleration of the $\\pi$ sequence:\n\n```javascript\naccelerated_sequence_example\n      accelerated_sequence\n      euler_transform\n      pi_stream\n      display_stream\n      3.1415926535911765\n\ndisplay_stream(accelerated_sequence(euler_transform, pi_stream));\n\nstream_ref(accelerated_sequence(euler_transform, pi_stream),\n           6);\n```\n\nThe result is impressive.\n\nTaking eight terms of the sequence yields the\ncorrect value of $\\pi$ to 14 decimal places.",
    "token_count": 277,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Exploiting the Stream Paradigm",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Exploiting_the_Stream_Paradigm_3"
  },
  {
    "content": "Taking eight terms of the sequence yields the\ncorrect value of $\\pi$ to 14 decimal places.\n\nIf we had used only the original $\\pi$ sequence,\nwe would need to compute on the order of $10^{13}$\nterms (i.e., expanding the series far enough so that the individual terms\nare less then $10^{-13}$ ) to get that much\naccuracy!\n\nWe could have implemented these acceleration techniques without using\nstreams.\n\nBut the stream formulation is particularly elegant and convenient\nbecause the entire sequence of states is available to us as a data structure\nthat can be manipulated with a uniform set of operations.\n\nIn section , we saw how the\nsequence paradigm handles traditional nested loops as processes defined\non sequences of pairs.\n\nIf we generalize this technique to infinite streams,\nthen we can write programs that are not easily represented as loops, because\nthe looping must range over an infinite set.\n\nFor example, suppose we want to generalize the\nprime_sum_pairs function\nof section to produce the stream\nof pairs of all integers $(i,j)$ with\n$i \\leq j$ such that\n$i+j$\nis prime.\n\nIf\nint_pairs\nis the sequence of all pairs of integers $(i,j)$\nwith $i \\leq j$ , then our required stream is\nsimply\n\n```javascript\nint_pairs\n      pairs_second_attempt\n      integers_definition\n      display_stream\n\nconst int_pairs = pairs(integers, integers);\n```\n\n```javascript\nprime_sum_pairs_stream\n      is_prime2\n      int_pairs\n      [ 1, [ 12, null ] ]\n\nstream_filter(pair => is_prime(head(pair) + head(tail(pair))),\n              int_pairs);\n\nstream_ref(stream_filter(pair => is_prime(head(pair) + head(tail(pair))),\n              int_pairs), 8);\n```\n\nOur problem, then, is to produce the stream\nint_pairs.",
    "token_count": 247,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Exploiting the Stream Paradigm",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Exploiting_the_Stream_Paradigm_4"
  },
  {
    "content": "Our problem, then, is to produce the stream\nint_pairs.\n\nMore generally, suppose we have two streams\n$S = (S_i)$ and\n$T = (T_j)$ ,\nand imagine the infinite rectangular array\n\\[\n\\begin{array}{cccc}\n(S_0,T_0) & (S_0,T_1) & (S_0, T_2) & \\ldots\\\\\n(S_1,T_0) & (S_1,T_1) & (S_1, T_2) & \\ldots\\\\\n(S_2,T_0) & (S_2,T_1) & (S_2, T_2) & \\ldots\\\\\n\\ldots\n\\end{array}\n\\]\nWe wish to generate a stream that contains all the pairs in the array\nthat lie on or above the diagonal, i.e., the pairs\n\\[\n\\begin{array}{cccc}\n(S_0,T_0) & (S_0,T_1) & (S_0, T_2) & \\ldots\\\\\n& (S_1,T_1) & (S_1, T_2) & \\ldots\\\\\n& & (S_2, T_2) & \\ldots\\\\\n& & & \\ldots\n\\end{array}\n\\]\n(If we take both $S$ and\n$T$ to be the stream of integers, then this\nwill be our desired stream\nint_pairs.)\n\nCall the general stream of pairs\npairs(S, T),\nand consider it to be composed of three parts: the pair\n$(S_0,T_0)$ , the rest of the pairs in the first\nrow, and the remaining pairs:\n\\[\n\\begin{array}{c|ccc}\n(S_0,T_0) & (S_0,T_1) & (S_0, T_2) & \\ldots\\\\\n\\hline{} %--------------------------------------------------- \\\\\n& (S_1,T_1) & (S_1, T_2) & \\ldots\\\\\n& & (S_2, T_2) & \\ldots\\\\\n& & & \\ldots\n\\end{array}\n\\]\nObserve that the third piece in this decomposition (pairs that are not in\nthe first row) is (recursively) the pairs formed from\nstream_tail(S)\nand\nstream_tail(T).\n\nAlso note that the second piece (the rest of the first row) is\n\n```javascript\nstream_map(x => list(head(s), x),\n           stream_tail(t));\n```\n\nThus we can form our stream of pairs as follows:\n\n```javascript\nfunction pairs(s, t) {\n    return pair(list(head(s), head(t)),\n                () => combine-in-some-way(\n                          stream_map(x => list(head(s), x),\n                                     stream_tail(t)),\n                          pairs(stream_tail(s), stream_tail(t))));\n}\n```\n\nIn order to complete the function, we must choose some way to function from section :",
    "token_count": 290,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Exploiting the Stream Paradigm",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_Exploiting_the_Stream_Paradigm_5"
  },
  {
    "content": "In order to complete the function, we must choose some way to function from section :\n\n```javascript\nstream_append_example\n\nconst ones = pair(1, () => ones);\nconst twos = pair(2, () => twos);\nconst appended = stream_append(ones, twos);\nstream_ref(appended, 100);\n```\n\n```javascript\nstream_append\n      stream_append_example\n      1\n\nfunction stream_append(s1, s2) {\n    return is_null(s1)\n           ? s2\n           : pair(head(s1),\n                  () => stream_append(stream_tail(s1), s2));\n}\n```\n\nThis is unsuitable for infinite streams, however, because it takes all the\nelements from the first stream before incorporating the second stream.\n\nIn\nparticular, if we try to generate all pairs of positive integers using\n\n```javascript\npairs_first_attempt\n      stream_append\n\nfunction pairs(s, t) {\n    return pair(list(head(s), head(t)),\n                () => stream_append(\n                         stream_map(x => list(head(s), x),\n                                    stream_tail(t)),\n                         pairs(stream_tail(s), stream_tail(t)))\n               );\n}\n```\n\n```javascript\npairs_first_attempt_usage\n      pairs_first_attempt\n      pairs_first_attempt_example\n      [ 1, [ 9, null ] ]\n\npairs(integers, integers);\n```\n\n```javascript\npairs_first_attempt_example\n      display_stream\n      integers_definition\n\ndisplay_stream(pairs(integers, integers));\n\nstream_ref(pairs(integers, integers), 8);\n```\n\nour stream of results will first try to run through all pairs with the first integer equal to 1, and hence will never produce pairs\n\nwith any other value of the first integer.\n\nTo handle infinite streams, we need to devise an order of combination\nthat ensures that every element will eventually be reached if we let\nour program run long enough.\n\nAn elegant way to accomplish this is\nwith the following function :\n\n```javascript\ninterleave_example\n      display_stream\n\nconst ones = pair(1, () => ones);\nconst twos = pair(2, () => twos);\nconst interleaved = interleave(ones, twos);\ndisplay_stream(interleaved);\n\nconst ones = pair(1, () => ones);\nconst twos = pair(2, () => twos);\nconst interleaved = interleave(ones, twos);\nstream_ref(interleaved, 7);\n```\n\n```javascript\ninterleave\n      interleave_example\n      2\n\nfunction interleave(s1, s2) {\n    return is_null(s1)\n           ? s2\n           : pair(head(s1),\n                  () => interleave(s2, stream_tail(s1)));\n}\n```\n\nSince\n\nWe can thus generate the required stream of pairs as",
    "token_count": 292,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Exploiting the Stream Paradigm",
    "chunk_index": 6,
    "chunk_id": "Modularity_Objects_and_State_Exploiting_the_Stream_Paradigm_6"
  },
  {
    "content": "We can thus generate the required stream of pairs as\n\n```javascript\npairs_second_attempt\n      interleave\n      pairs_second_attempt_example\n      [ 2, [ 4, null ] ]\n\nfunction pairs(s, t) {\n    return pair(list(head(s), head(t)),\n                () => interleave(stream_map(x => list(head(s), x),\n                                            stream_tail(t)),\n                                 pairs(stream_tail(s),\n                                       stream_tail(t))));\n}\n```\n\n```javascript\npairs_second_attempt_example\n      display_stream\n      integers_definition\n\ndisplay_stream(pairs(integers, integers));\n\nstream_ref(pairs(integers, integers), 8);\n```\n\nWe began our discussion of streams by describing them as computational\nanalogs of the signals in signal-processing systems.\n\nIn fact, we can use streams to model signal-processing systems in a very\ndirect way, representing the values of a signal at successive time\nintervals as consecutive elements of a stream.\n\nFor instance, we can\nimplement an\nintegrator or\nsummer that, for an input stream\n$x=(x_{i})$ , an initial value $C$ , and a small increment $dt$ ,\naccumulates the sum\n\\[\n\\begin{array}{lll}\nS_i &=& C +\\sum_{j=1}^{i} x_{j} \\, dt\n\\end{array}\n\\]\nand returns the stream of values $S=(S_{i})$.\n\nThe following\nfunction\nis reminiscent of the implicit style definition of the\nstream of integers (section ):\n\n```javascript\nintegral_1_example\n\nfunction numbers_starting_from(t, dt) {\n    return pair(t,\n                () => numbers_starting_from(t + dt, dt)\n               );\n}\nconst dt = 0.01;\nconst linear = numbers_starting_from(0, dt);\nconst linear_integral = integral(linear, 0, dt);\n// computing integral from 0 to 3 of f(x) = x\n// (the integral is g(x) = 0.5 x^2, and therefore\n// the result is near 0.5 * 3^2 = 4.5)\nstream_ref(linear_integral, math_round(3 / dt));\n```\n\n```javascript\nintegral_1\n      add_streams\n      scale_stream\n      integral_1_example\n      4.484999999999992\n\nfunction integral(integrand, initial_value, dt) {\n    const integ = pair(initial_value,\n                       () => add_streams(scale_stream(integrand, dt),\n                                         integ));\n    return integ;\n}\n```\n\nThe\n\n\\noindent\nFigure\nis a picture of a signal-processing\nsystem that corresponds to the\nfunction.\n\nThe input stream is scaled by $dt$ and passed\nthrough an adder, whose output is passed back through the same adder.",
    "token_count": 290,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Exploiting the Stream Paradigm",
    "chunk_index": 7,
    "chunk_id": "Modularity_Objects_and_State_Exploiting_the_Stream_Paradigm_7"
  },
  {
    "content": "The input stream is scaled by $dt$ and passed\nthrough an adder, whose output is passed back through the same adder.\n\nThe self-reference in the definition of\ninteg\nis reflected in the figure by the feedback loop that\nconnects the output of the adder to one of the inputs.",
    "token_count": 49,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Exploiting the Stream Paradigm",
    "chunk_index": 8,
    "chunk_id": "Modularity_Objects_and_State_Exploiting_the_Stream_Paradigm_8"
  },
  {
    "content": "We have seen how to support the illusion of manipulating streams\nas complete entities even though, in actuality, we compute only\nas much of the stream as we need to access.\n\nWe can exploit this\ntechnique to represent sequences efficiently as streams, even if the\nsequences are very long.\n\nWhat is more striking, we can use streams to\nrepresent sequences that are infinitely long.\n\nFor instance, consider\nthe following definition of the stream of positive integers:\n\n```javascript\nintegers_starting_from_example\n\nconst from_20 = integers_starting_from(20);\neval_stream(from_20, 50);\n\nconst from_20 = integers_starting_from(20);\nstream_ref(from_20, 50);\n```\n\n```javascript\nintegers_starting_from\n      integers_starting_from_example\n      70\n\nfunction integers_starting_from(n) {\n    return pair(n, () => integers_starting_from(n + 1));\n}\n```\n\n```javascript\nintegers_definition\n      integers_starting_from\n      integers_definition_example\n      51\n\nconst integers = integers_starting_from(1);\n```\n\n```javascript\nintegers_definition_example\n\neval_stream(integers, 50);\n\nstream_ref(integers, 50);\n```\n\nThis makes sense because\nhead\nis 1 and whose\ntail\nis a promise to produce the integers beginning with 2.\n\nThis is an infinitely\nlong stream, but in any given time we can examine only a finite portion of\nit.\n\nThus, our programs will never know that the entire infinite stream is\nnot there.\n\nUsing\n\n```javascript\nis_divisible2_example\n\nis_divisible(42, 7);\n```\n\n```javascript\nis_divisible2\n      is_divisible2_example\n\nfunction is_divisible(x, y) { return x % y === 0; }\n```\n\n```javascript\nno_sevens\n      integers_definition\n      is_divisible2\n      no_sevens_example\n      27\n\nconst no_sevens = stream_filter(x => ! is_divisible(x, 7),\n                                integers);\n```\n\n```javascript\nno_sevens_example\n\neval_stream(no_sevens, 23);\n\nstream_ref(no_sevens, 23);\n```\n\nThen we can find integers not divisible by 7 simply by accessing elements of this stream:\n\n```javascript\non_sevens_example\n      no_sevens\n      117\n\nstream_ref(no_sevens, 100);\n```\n\nIn analogy with\n\n```javascript\nfibgen_example\n\neval_stream(fibs, 50);\n\nstream_ref(fibs, 50);\n```\n\n```javascript\nfibgen\n      fibgen_example\n      12586269025\n\nfunction fibgen(a, b) {\n    return pair(a, () => fibgen(b, a + b));\n}\n\nconst fibs = fibgen(0, 1);\n```\n\nThe constant fibs\nis a pair whose\nhead\nis 0 and whose\ntail\nis a promise to evaluate\nfibgen(1, 1).",
    "token_count": 298,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Infinite Streams",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Infinite_Streams_1"
  },
  {
    "content": "The constant fibs\nis a pair whose\nhead\nis 0 and whose\ntail\nis a promise to evaluate\nfibgen(1, 1).\n\nWhen we evaluate this delayed\nfibgen(1, 1),\nit will produce a pair whose\nhead\nis 1 and whose\ntail\nis a promise to evaluate\nfibgen(1, 2),\nand so on.\n\nFor a look at a more exciting infinite stream, we can generalize the no_sevens example to construct the infinite stream of prime numbers, using a\n\nmethod known as the sieve of Eratosthenes.\n\n```javascript\nsieve_example\n\neval_stream(primes, 50);\n\nstream_ref(primes, 50);\n```\n\n```javascript\nsieve\n      is_divisible2\n      integers_starting_from\n      sieve_example\n      233\n\nfunction sieve(stream) {\n    return pair(head(stream),\n                () => sieve(stream_filter(\n                                x => ! is_divisible(x, head(stream)),\n                                stream_tail(stream))));\n}\nconst primes = sieve(integers_starting_from(2));\n```\n\nNow to find a particular prime we need only ask for it:\n\n```javascript\nsieve_example_2\n      sieve\n      233\n\nstream_ref(primes, 50);\n```\n\nIt is interesting to contemplate the signal-processing system set up\nby Henderson diagram in\nfigure.\nunpairer\nthat separates the first element of the stream from the rest of the stream.\n\nThe first element is used to construct a divisibility filter, through\nwhich the rest is passed, and the output of the filter is fed to\nanother sieve box.\n\nThen the original first element is\n\n```javascript\nadjoined to the output of the internal sieve\n\tto form the output stream.\n```\n\nThus, not only is the stream infinite, but the signal processor is also infinite, because the sieve contains a sieve within it.\n\n```javascript\nThe prime sieve viewed as a signal-processing system.\nEach solid line represents a\n    stream of values being transmitted.  The dashed line from the\n    head\n    to the\n    pair\n    and the\n```\n\nThe generating\nfunctions\nthat explicitly compute the stream elements one by one.\n\nAn alternative way\nto specify streams is to take advantage of delayed evaluation to define\nstreams implicitly.\n\nFor example, the following\nstatement\ndefines the\nstream\n\n```javascript\nones_example\n\neval_stream(ones, 50);\n\nstream_ref(ones, 50);\n```",
    "token_count": 309,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Infinite Streams",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Infinite_Streams_2"
  },
  {
    "content": "For example, the following\nstatement\ndefines the\nstream\n\n```javascript\nones_definition\n      ones_example\n      1\n\nconst ones = pair(1, () => ones);\n```\n\nThis works much like the declaration of a recursive function: head is 1 and whose tail is a promise to evaluate tail gives us again\n\na 1 and a promise to evaluate\n\nWe can do more interesting things by manipulating streams with operations such as add_streams, which produces the elementwise sum of two given streams:\n\n```javascript\nadd_streams_example\n\nconst ones = pair(1, () => ones);\nconst twos = pair(2, () => twos);\nconst threes = add_streams(ones, twos);\neval_stream(threes, 50);\n\nconst ones = pair(1, () => ones);\nconst twos = pair(2, () => twos);\nconst threes = add_streams(ones, twos);\nstream_ref(threes, 50);\n```\n\n```javascript\nadd_streams\n      stream_combine\n      add_streams_example\n      3\n\nfunction add_streams(s1, s2) {\n    return stream_map_2((x1, x2) => x1 + x2, s1, s2);\n}\n```\n\nNow we can define the integers as follows:\n\n```javascript\nintegers_definition_2_example\n\neval_stream(integers, 50);\n\nstream_ref(integers, 50);\n```\n\n```javascript\nintegers_definition_2\n      add_streams\n      ones_definition\n      integers_definition_2_example\n      51\n\nconst integers = pair(1, () => add_streams(ones, integers));\n```\n\nThis defines\n\nWe can define the Fibonacci numbers in the same style:\n\n```javascript\nfibs_by_magic_example\n\neval_stream(fibs, 20);\n\nstream_ref(fibs, 20);\n```\n\n```javascript\nfibs_by_magic\n      fibs_by_magic_example\n      add_streams\n      6765\n\nconst fibs = pair(0,\n                  () => pair(1,\n                             () => add_streams(stream_tail(fibs),\n                                               fibs)));\n```\n\nThis definition says that\n\n```javascript\n\\[\n\\begin{array}{ccccccccccccl}\n  &   & 1 & 1 & 2 & 3 & 5 &  8 & 13 & 21 & \\ldots & = & \\texttt{stream}\\mathtt{\\_}\\texttt{tail(fibs)} \\\\\n  &   & 0 & 1 & 1 & 2 & 3 &  5 &  8 & 13 & \\ldots & = & \\texttt{fibs} \\\\ \\hline\n0 & 1 & 1 & 2 & 3 & 5 & 8 & 13 & 21 & 34 & \\ldots & = & \\texttt{fibs}\n\\end{array}\n\\]\n```\n\n```javascript\nThe function\n\tscale_stream\n\tis also useful\n```\n\nin formulating such stream definitions.\n\nThis multiplies each item in a\nstream by a given constant:",
    "token_count": 314,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Infinite Streams",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Infinite_Streams_3"
  },
  {
    "content": "This multiplies each item in a\nstream by a given constant:\n\n```javascript\nscale_stream_example\n\nconst twos = pair(2, () => twos);\nconst sixes = scale_stream(twos, 3);\neval_stream(sixes, 50);\n\nconst twos = pair(2, () => twos);\nconst sixes = scale_stream(twos, 3);\nstream_ref(sixes, 50);\n```\n\n```javascript\nscale_stream\n      scale_stream_example\n      6\n\nfunction scale_stream(stream, factor) {\n    return stream_map(x => x * factor,\n                      stream);\n}\n```\n\nFor example,\n\n```javascript\ndouble_stream_example\n\neval_stream(double, 50);\n\nstream_ref(double, 50);\n```\n\n```javascript\ndouble_stream\n      scale_stream\n      double_stream_example\n      1125899906842624\n\nconst double = pair(1, () => scale_stream(double, 2));\n```\n\nproduces the stream of powers of 2: $1, 2, 4, 8, 16, 32,$.\n\nAn alternate definition of the stream of primes can be given by\nstarting with the integers and filtering them by testing for\nprimality.\n\nWe will need the first prime, 2, to get started:\n\n```javascript\nprimes_example\n\neval_stream(primes, 50);\n\nstream_ref(primes, 50);\n```\n\n```javascript\nprimes\n      square_definition\n      is_divisible2\n      integers_starting_from\n      primes_example\n      233\n\nfunction is_prime(n) {\n    function iter(ps) {\n        return square(head(ps)) > n\n               ? true\n               : is_divisible(n, head(ps))\n               ? false\n               : iter(stream_tail(ps));\n    }\n    return iter(primes);\n}\n\nconst primes = pair(2,\n                    () => stream_filter(is_prime,\n                                        integers_starting_from(3)));\n\nconst primes = pair(2,\n                    () => stream_filter(is_prime,\n                                        integers_starting_from(3)));\n```\n\nThis definition is not so straightforward as it appears, because we will test whether a number $n$ is prime by checking whether $n$ is divisible\n\nby a prime (not by just any integer) less than or equal to $\\sqrt{n}$ :\n\n```javascript\nis_prime2_example\n\nis_prime(100003);\n```\n\n```javascript\nis_prime2\n      square_definition\n      is_divisible2\n      integers_starting_from\n      is_prime2_example\n      true\n\nfunction is_prime(n) {\n    function iter(ps) {\n        return square(head(ps)) > n\n               ? true\n               : is_divisible(n, head(ps))\n               ? false\n               : iter(stream_tail(ps));\n    }\n    return iter(primes);\n}\n\nfunction is_prime(n) {\n    function iter(ps) {\n        return square(head(ps)) > n\n               ? true\n               : is_divisible(n, head(ps))\n               ? false\n               : iter(stream_tail(ps));\n    }\n    return iter(primes);\n}\nconst primes = pair(2,\n                    () => stream_filter(\n                              is_prime,\n                              integers_starting_from(3))\n                   );\n```\n\nThis is a recursive definition, since is_prime predicate, which itself uses the function works is that, at any point, enough of the $n$ we test",
    "token_count": 315,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Infinite Streams",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Infinite_Streams_4"
  },
  {
    "content": "This is a recursive definition, since is_prime predicate, which itself uses the function works is that, at any point, enough of the $n$ we test\n\nfor primality, either $n$ is not prime (in which case there is a prime already generated that divides it) or $n$ is prime (in which\n\ncase there is a prime already generated i.e., a prime less than $n$ that is greater than $\\sqrt{n}$ ).",
    "token_count": 69,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Infinite Streams",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_Infinite_Streams_5"
  },
  {
    "content": "As we saw in section , one of\nthe major benefits of introducing assignment is that we can increase the\nmodularity of our systems by encapsulating, or hiding, parts\nof the state of a large system within local variables.\n\nStream models can\nprovide an equivalent modularity without the use of assignment.\n\nAs an\nillustration, we can reimplement the\n$\\pi$ , which we examined in\nsection , from a\nstream-processing point of view.\n\nThe key modularity issue was that we wished to hide the internal state\nof a random-number generator from programs that used random numbers.\n\nWe began with a\nfunction rand_update,\nwhose successive values furnished our supply of random numbers, and used\nthis to produce a random-number generator:\n\n```javascript\nrand_update\n      random_init\n      rand_example\n      40083849805\n\nfunction make_rand() {\n    let x = random_init;\n    return () => {\n               x = rand_update(x);\n               return x;\n           };\n}\nconst rand = make_rand();\n```\n\nIn the stream formulation there is no random-number generator per se , just a stream of random numbers produced by successive calls to rand_update:\n\n```javascript\nrandom_numbers\n      rand_update\n      random_init\n      random_numbers_example\n      172561279022\n\nconst random_numbers =\n    pair(random_init,\n         () => stream_map(rand_update, random_numbers));\n```\n\n```javascript\nrandom_numbers_example\n\neval_stream(random_numbers, 5);\n\nstream_ref(random_numbers, 4);\n```\n\nWe use this to construct the stream of outcomes of the Ces ro experiment performed on consecutive pairs in the stream:\n\n```javascript\ncesaro_stream\n      random_numbers\n      gcd_definition\n      cesaro_stream_example\n      true\n\nfunction map_successive_pairs(f, s) {\n    return pair(f(head(s), head(stream_tail(s))),\n                () => map_successive_pairs(\n                          f,\n                          stream_tail(stream_tail(s))));\n}\nconst dirichlet_stream =\n    map_successive_pairs((r1, r2) => gcd(r1, r2) === 1,\n                         random_numbers);\n```\n\n```javascript\ncesaro_stream_example\n\neval_stream(dirichlet_stream, 20);\n\nstream_ref(dirichlet_stream, 42);\n```\n\nThe\ndirichlet_stream\nis now fed to a\nmonte_carlo\nfunction,\nwhich produces a stream of estimates of probabilities.\n\nThe results are then\nconverted into a stream of estimates of $\\pi$.\n\nThis version of the program doesn t need a parameter telling how many\ntrials to perform.",
    "token_count": 296,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Modularity of Functional Programs and Modularity of Objects",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Modularity_of_Functional_Programs_and_Modularity_of_Objects_1"
  },
  {
    "content": "This version of the program doesn t need a parameter telling how many\ntrials to perform.\n\nBetter estimates of $\\pi$\n(from performing more experiments) are obtained by looking farther into the\n\n```javascript\nmonte_carlo_stream\n      cesaro_stream\n      display_pi\n      3.1780497164141406\n\nfunction monte_carlo(experiment_stream, passed, failed) {\n    function next(passed, failed) {\n        return pair(passed / (passed + failed),\n                    () => monte_carlo(stream_tail(experiment_stream),\n                                      passed, failed));\n    }\n    return head(experiment_stream)\n           ? next(passed + 1, failed)\n           : next(passed, failed + 1);\n}\nconst pi = stream_map(p => math_sqrt(6 / p),\n                      monte_carlo(dirichlet_stream, 0, 0));\n```\n\n```javascript\ndisplay_pi\n\nstream_ref(pi, 100);\n```\n\nThere is considerable\nmonte_carlo function\nthat can deal with arbitrary experiments.\n\nYet there is no assignment or\nlocal state.\n\nLet us now return to the issues of objects and state that were raised\nat the beginning of this chapter and examine them in a new light.\n\nWe\nintroduced assignment and mutable objects to provide a mechanism for\nmodular construction of programs that model systems with state.\n\nWe constructed computational objects with local state variables and used\nassignment to modify these variables.\n\nWe modeled the temporal behavior of\nthe objects in the world by the temporal behavior of the corresponding\ncomputational objects.\n\nNow we have seen that streams provide an alternative way to model\nobjects with local state.\n\nWe can model a changing quantity, such as\nthe local state of some object, using a stream that represents the\ntime history of successive states.\n\nIn essence, we represent time\nexplicitly, using streams, so that we decouple time in our simulated\nworld from the sequence of events that take place during evaluation.\n\nIndeed, because of the presence of\ndelayed evaluation\nthere may be little relation between simulated time in the model and the\norder of events during the evaluation.",
    "token_count": 283,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Modularity of Functional Programs and Modularity of Objects",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Modularity_of_Functional_Programs_and_Modularity_of_Objects_2"
  },
  {
    "content": "Indeed, because of the presence of\ndelayed evaluation\nthere may be little relation between simulated time in the model and the\norder of events during the evaluation.\n\nIn order to contrast these two approaches to modeling, let us reconsider the implementation of a withdrawal processor that monitors the balance in a we\n\nimplemented a simplified version of such a processor:\n\n```javascript\nmake_simplified_withdraw_example\n      make_simplified_withdraw_example1\n      make_simplified_withdraw_example2\n\nfunction make_simplified_withdraw(balance) {\n    return amount => {\n               balance = balance - amount;\n               return balance;\n           };\n}\n```\n\nCalls to produce computational objects, each with a local state variable\n\nAlternatively, we can model a withdrawal processor as a function that takes as input a balance and a stream of amounts to withdraw and produces\n\nthe stream of successive balances in the account:\n\n```javascript\nstream_withdraw\n      stream_withdraw_example\n      50\n\nfunction stream_withdraw(balance, amount_stream) {\n    return pair(balance,\n                () => stream_withdraw(balance - head(amount_stream),\n                                      stream_tail(amount_stream)));\n}\n```\n\n```javascript\nstream_withdraw_example\n\nconst my_amounts = list_to_stream(list(50, 100, 40));\nconst my_account_stream = stream_withdraw(200, my_amounts);\neval_stream(my_account_stream, 3);\n\nconst my_amounts = list_to_stream(list(50, 100, 40));\nconst my_account_stream = stream_withdraw(200, my_amounts);\nstream_ref(my_account_stream, 2);\n```\n\nThe function stream_withdraw\nimplements a well-defined mathematical function whose output is fully\ndetermined by its input.\n\nSuppose, however, that the input\namount_stream\nis the stream of successive values typed by the user and that the resulting\nstream of balances is displayed.\n\nThen, from the perspective of the user who\nis typing values and watching results, the stream process has the same\nbehavior as the object created by\nmake_simplified_withdraw.\n\nHowever, with the stream version, there is no assignment, no local state\nvariable, and consequently none of the theoretical difficulties that we\nencountered.\n\nYet the system\nhas state!\n\nThis is really remarkable.\n\nEven though\nstream_withdraw\nimplements a well-defined mathematical function whose behavior does not\nchange, the user s perception here is one of interacting with a system\nthat has a changing state.",
    "token_count": 302,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Modularity of Functional Programs and Modularity of Objects",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Modularity_of_Functional_Programs_and_Modularity_of_Objects_3"
  },
  {
    "content": "Even though\nstream_withdraw\nimplements a well-defined mathematical function whose behavior does not\nchange, the user s perception here is one of interacting with a system\nthat has a changing state.\n\nOne way to resolve this paradox is to realize\nthat it is the user s temporal existence that imposes state on the\nsystem.\n\nIf the user could step back from the interaction and think in terms\nof streams of balances rather than individual transactions, the system\nwould appear stateless.\n\nFrom the point of view of one part of a complex process, the other parts\nappear to change with time.\n\nThey have hidden time-varying local state.\n\nIf\nwe wish to write programs that model this kind of natural decomposition in\nour world (as we see it from our viewpoint as a part of that world) with\nstructures in our computer, we make computational objects that are not\nfunctional they must change with time.\n\nWe model state with local\nstate variables, and we model the changes of state with assignments to\nthose variables.\n\nBy doing this we make the time of execution of a\ncomputation model time in the world that we are part of, and thus we\nget objects in our computer.\n\nModeling with objects is powerful and intuitive, largely because this\nmatches the perception of interacting with a world of which we are\npart.\n\nHowever, as we ve seen repeatedly throughout this chapter,\nthese models raise thorny problems of constraining the order of events\nand of synchronizing multiple processes.\n\nThe possibility of avoiding\nthese problems has stimulated the development of\nfunctional programming languages , which do not include any\nprovision for assignment or mutable data.\n\nIn such a language, all\nfunctions\nimplement well-defined mathematical functions of their arguments,\nwhose behavior does not change.",
    "token_count": 293,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Modularity of Functional Programs and Modularity of Objects",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Modularity_of_Functional_Programs_and_Modularity_of_Objects_4"
  },
  {
    "content": "In such a language, all\nfunctions\nimplement well-defined mathematical functions of their arguments,\nwhose behavior does not change.\n\nThe functional approach is extremely\nattractive for dealing with\n\nOn the other hand, if we look closely, we can see time-related problems\ncreeping into functional models as well.\n\nOne particularly troublesome area\narises when we wish to design interactive systems, especially ones that\nmodel interactions between independent entities.\n\nFor instance, consider once\nmore the implementation of a banking system that permits joint bank accounts.\n\nIn a conventional system using assignment and objects, we would model the\nfact that Peter and Paul share an account by having both Peter and Paul send\ntheir transaction requests to the same bank-account object, as we saw in\nsection.\n\nFrom the stream point\nof view, where there are no objects per se , we have\nalready indicated that a bank account can be modeled as a process that\noperates on a stream of transaction requests to produce a stream of\nresponses.\n\nAccordingly, we could model the fact that Peter and Paul have a\njoint bank account by merging Peter s stream of transaction requests\nwith Paul s stream of requests and feeding the result to the\nbank-account stream process, as shown in\nfigure.\n\nA joint\n\nThe trouble with this formulation is in the notion of merge.\n\nIt\nwill not do to merge the two streams by simply taking alternately one\nrequest from Peter and one request from Paul.\n\nSuppose Paul accesses\nthe account only very rarely.",
    "token_count": 249,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Modularity of Functional Programs and Modularity of Objects",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_Modularity_of_Functional_Programs_and_Modularity_of_Objects_5"
  },
  {
    "content": "Suppose Paul accesses\nthe account only very rarely.\n\nWe could hardly force Peter to wait for\nPaul to access the account before he could issue a second transaction.\nreal\ntime as perceived by Peter and Paul, in the sense that, if Peter and\nPaul meet, they can agree that certain transactions were processed\nbefore the meeting, and other transactions were processed after the\nmeeting. , where we found the need to\nintroduce explicit synchronization to ensure a correct order\nof events in concurrent processing of objects with state.\n\nThus, in an\nattempt to support the functional style, the need to merge inputs from\ndifferent agents reintroduces the same problems that the functional style\nwas meant to eliminate.\n\nWe began this chapter with the goal of building computational models\nwhose structure matches our perception of the real world we are trying\nto model.\n\nWe can model the world as a collection of separate,\ntime-bound, interacting objects with state, or we can model the world\nas a single, timeless, stateless unity.\n\nEach view has powerful\nadvantages, but neither view alone is completely satisfactory.\n\nA\ngrand unification has yet to emerge.",
    "token_count": 188,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Modularity of Functional Programs and Modularity of Objects",
    "chunk_index": 6,
    "chunk_id": "Modularity_Objects_and_State_Modularity_of_Functional_Programs_and_Modularity_of_Objects_6"
  },
  {
    "content": "As we saw in\nsection ,\nsequences can serve as standard interfaces for combining program\nmodules.\n\nWe formulated powerful abstractions for manipulating\nsequences, such as\n\nUnfortunately, if we represent sequences as lists, this elegance is\nbought at the price of severe inefficiency with respect to both the\ntime and space required by our computations.\n\nWhen we represent manipulations on sequences as transformations\nof lists, our programs must construct and copy data structures (which\nmay be huge) at every step of a process.\n\nTo see why this is true, let us compare two programs for computing the\nsum of all the prime numbers in an interval.\n\nThe first program is\nwritten in standard iterative style:\n\n```javascript\nprime_definition\n      sum_primes1\n      sum_primes1_example\n      3437\n\nfunction sum_primes(a, b) {\n    function iter(count, accum) {\n        return count > b\n               ? accum\n               : is_prime(count)\n               ? iter(count + 1, count + accum)\n               : iter(count + 1, accum);\n    }\n    return iter(a, 0);\n}\n```\n\n```javascript\nsum_primes1_example\n\nsum_primes(7, 182);\n```\n\nThe second program performs the same computation using the sequence operations of section :\n\n```javascript\nsum_primes2\n      prime_definition\n      enumerate_interval\n      sum_primes1_example\n      3437\n\nfunction sum_primes(a, b) {\n    return accumulate((x, y) => x + y,\n                      0,\n                      filter(is_prime,\n                             enumerate_interval(a, b)));\n}\n```\n\nIn carrying out the computation, the first program needs to store only\nthe sum being accumulated.\n\nIn contrast, the filter in the second\nprogram cannot do any testing until\nenumerate_interval\nhas constructed a complete list of the numbers in the interval.\n\nThe filter generates another list, which in turn is passed to\n\nThe inefficiency in using lists becomes painfully apparent if we use the sequence paradigm to compute the second prime in the interval from 10,000 to\n\n1,000,000 by evaluating the expression\n\n```javascript\npainfully\n      prime_definition\n      enumerate_interval\n\nhead(tail(filter(is_prime,\n                 enumerate_interval(10000, 1000000))));\n```\n\nThis expression does find the second prime, but the computational overhead\nis outrageous.",
    "token_count": 298,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams Are Delayed Lists",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Streams_Are_Delayed_Lists_1"
  },
  {
    "content": "This expression does find the second prime, but the computational overhead\nis outrageous.\n\nWe construct a list of almost a million integers, filter\nthis list by testing each element for primality, and then ignore almost\nall of the result.\n\nIn a more traditional programming style, we would\ninterleave the enumeration and the filtering, and stop when we reached\nthe second prime.\n\nStreams are a clever idea that allows one to use sequence\nmanipulations without incurring the costs of manipulating sequences as\nlists.\n\nWith streams we can achieve the best of both worlds: We can\nformulate programs elegantly as sequence manipulations, while attaining\nthe efficiency of incremental computation.\n\nThe basic idea is to arrange\nto construct a stream only partially, and to pass the partial\nconstruction to the program that consumes the stream.\n\nIf the consumer\nattempts to access a part of the stream that has not yet been\nconstructed, the stream will automatically construct just enough more\nof itself to produce the required part, thus preserving the illusion\nthat the entire stream exists.\n\nIn other words, although we will write\nprograms as if we were processing complete sequences, we design our\nstream implementation to automatically and transparently interleave\nthe construction of the stream with its use.\n\nTo accomplish this, we will construct streams using pairs,\nwith the first item of the stream in the head of the pair.\n\nHowever, rather than placing the value of the rest of the stream\npromise\nto compute the rest if it is ever requested.",
    "token_count": 250,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams Are Delayed Lists",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Streams_Are_Delayed_Lists_2"
  },
  {
    "content": "However, rather than placing the value of the rest of the stream\npromise\nto compute the rest if it is ever requested.\n\nIf we have a data item\nh and a stream\nt , we construct a stream\nwhose head is\nh and whose tail is\nt by evaluating\npair(h, () => t) the\ntail\nt of a stream is\nwrapped in a function of no arguments,\ndelayed.\nnull , the same as the empty list.\n\nTo access the first data item of a nonempty stream,\nwe simply select the\nhead of the pair, as with a list.\n\nBut to access the tail of a stream, we need to evaluate the\ndelayed expression.\n\nFor convenience, we define\n\n```javascript\nstream_tail\n\t  stream_tail_example\n\t  5\n\nfunction stream_tail(stream) {\n    return tail(stream)();\n}\n```\n\n```javascript\nstream_tail_example\n\nstream_tail(pair(4, () => pair(5, () => null)));\n\nhead(stream_tail(pair(4, () => pair(5, () => null))));\n```\n\nThis selects the tail of the pair and applies the function found there to obtain the next pair of the stream (or null if the\n\ntail of the stream is empty) in effect, forcing the function in the tail of the pair to fulfill its promise.\n\nWe can make and use streams, in just the same way as we can make\nand use lists, to represent aggregate data arranged in a sequence.\n\nIn\nparticular, we can build stream analogs of the list operations from\nchapter , such as list_ref ,\nfor_each :\n\n```javascript\nstream_tail\n          stream_functions\n          stream_functions_example\n\nfunction stream_ref(s, n) {\n    return n === 0\n           ? head(s)\n           : stream_ref(stream_tail(s), n - 1);\n}\nfunction stream_map(f, s) {\n    return is_null(s)\n           ? null\n           : pair(f(head(s)),\n                  () => stream_map(f, stream_tail(s)));\n}\nfunction stream_for_each(fun, s) {\n    if (is_null(s)) {\n        return true;\n    } else {\n        fun(head(s));\n        return stream_for_each(fun, stream_tail(s));\n    }\n}\n```",
    "token_count": 291,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams Are Delayed Lists",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Streams_Are_Delayed_Lists_3"
  },
  {
    "content": "In\nparticular, we can build stream analogs of the list operations from\nchapter , such as list_ref ,\nfor_each :\n\n```javascript\nstream_tail\n          stream_functions_example\n\nconst my_stream = pair(4, () => pair(5, () => null));\ndisplay(stream_ref(my_stream, 1));\nconst my_stream_2 = stream_map(x => x + 1, my_stream);\nstream_for_each(display, my_stream_2);\n\nconst my_stream = pair(4, () => pair(5, () => null));\nconst my_stream_2 = stream_map(x => x + 1, my_stream);\nlet acc = 0;\nstream_for_each(x => {acc = acc + x;}, my_stream_2);\nacc;\n```\n\nThe function stream_for_each is useful for viewing streams:\n\n```javascript\ndisplay_stream\n          display_stream_example\n\nfunction display_stream(s) {\n    return stream_for_each(display, s);\n}\n\nconst max_display = 9;\nfunction display_stream(s) {\n    function display_stream_iter(st, n) {\n        if (is_null(st)) {\n        } else if (n === 0) {\n            display('', \"...\");\n        } else {\n            display(head(st));\n            display_stream_iter(stream_tail(st), n - 1);\n        }\n    }\n    display_stream_iter(s, max_display);\n}\n```\n\n```javascript\nstream_tail\n\t  display_stream\n          display_stream_example\n\nconst my_stream = pair(4, () => pair(5, () => null));\ndisplay_stream(my_stream);\n```\n\nTo make the stream implementation automatically and transparently\ninterleave the construction of a stream with its use, we have arranged\nfor the tail\nof a stream to be evaluated when it is accessed by the\nstream_tail\nfunction rather than when the stream is constructed by\npair.\n\nThis implementation choice is reminiscent of our discussion of rational numbers\nin section , where we saw\nthat we can choose to implement rational numbers so that the reduction\nof numerator and denominator to lowest terms is performed either at\nconstruction time or at selection time.\n\nThe two rational-number\nimplementations produce the same data abstraction, but the choice has\nan effect on efficiency.\n\nThere is a similar relationship between\nstreams and ordinary lists.\n\nAs a data abstraction, streams are the\nsame as lists.\n\nThe difference is the time at which the elements are\nevaluated.\n\nWith ordinary lists, both the\nhead and the\ntail\nare evaluated at construction time.",
    "token_count": 304,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams Are Delayed Lists",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Streams_Are_Delayed_Lists_4"
  },
  {
    "content": "With ordinary lists, both the\nhead and the\ntail\nare evaluated at construction time.\n\nWith streams, the\ntail is evaluated at selection time.\n\nTo see how this data structure behaves, let us analyze the outrageous prime computation we saw above, reformulated in terms of streams:\n\n```javascript\nno_more_outrageous\n          prime_definition\n          stream_enumerate_interval\n\t  10009\n\nhead(stream_tail(stream_filter(\n                     is_prime,\n                     stream_enumerate_interval(10000, 1000000))));\n```\n\nWe will see that it does indeed work efficiently.\n\nWe begin by calling\nstream_enumerate_interval with\nthe arguments 10,000 and 1,000,000.\n\nThe function\nstream_enumerate_interval\nis the stream analog of\nenumerate_interval\n(section ):\n\n```javascript\nstream_enumerate_interval_example\n          stream_enumerate_interval\n\nstream_enumerate_interval(10000, 1000000);\n\nstream_ref(stream_enumerate_interval(10000, 1000000), 100);\n```\n\n```javascript\nprime_definition\n          stream_enumerate_interval\n\t  stream_enumerate_interval_example\n\t  10100\n\nfunction stream_enumerate_interval(low, high) {\n    return low > high\n           ? null\n           : pair(low,\n                  () => stream_enumerate_interval(low + 1, high));\n}\n```\n\nand thus the result returned by stream_enumerate_interval , formed by the\n\n```javascript\nstream_enumerate_interval_example_2\n          stream_enumerate_interval\n\t  10100\n\npair(10000, () => stream_enumerate_interval(10001, 1000000));\n\nstream_ref(pair(10000, () => stream_enumerate_interval(10001, 1000000)), 100);\n```\n\nThat is, stream_enumerate_interval\nreturns a stream represented as a pair whose\nhead\nis 10,000 and whose tail\nis a promise to enumerate more of the\ninterval if so requested.\n\nThis stream is now filtered for primes,\nusing the stream analog of the ):\n\n```javascript\nstream_tail\n          stream_filter\n          stream_filter_example\n\t  6\n\nfunction stream_filter(pred, stream) {\n    return is_null(stream)\n           ? null\n           : pred(head(stream))\n           ? pair(head(stream),\n                  () => stream_filter(pred, stream_tail(stream)))\n           : stream_filter(pred, stream_tail(stream));\n}\n```\n\n```javascript\nstream_filter_example\n          display_stream\n\nconst my_stream = pair(5, () => pair(6, () => pair(7, () => null)));\nconst my_filtered_stream =\n    stream_filter(x => x % 2 === 0, my_stream);\ndisplay_stream(my_filtered_stream);\n\nconst my_stream = pair(5, () => pair(6, () => pair(7, () => null)));\nconst my_filtered_stream =\n    stream_filter(x => x % 2 === 0, my_stream);\nhead(my_filtered_stream);\n```\n\nThe function stream_filter tests the\nstream_filter\nexamines the tail of its input stream.\n\nThe call to\nstream_tail forces evaluation of the\ndelayed stream_enumerate_interval ,\nwhich now returns\n\n```javascript\nenumerate_interval_example_3\n          stream_enumerate_interval\n\t  10101\n\npair(10001, () => stream_enumerate_interval(10002, 1000000));\n\nstream_ref(pair(10001, () => stream_enumerate_interval(10002, 1000000)), 100);\n```",
    "token_count": 313,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams Are Delayed Lists",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_Streams_Are_Delayed_Lists_5"
  },
  {
    "content": "The call to\nstream_tail forces evaluation of the\ndelayed stream_enumerate_interval ,\nwhich now returns\n\nThe function stream_filter now looks at the head of this stream, 10,001, sees that this is not prime either, forces another stream_@tail , and so\n\non, until stream_@enumerate_interval yields the prime 10,007, whereupon stream_@filter , according to its definition, returns\n\n```javascript\npair(head(stream),\n     () => stream_filter(pred, stream_tail(stream)));\n```\n\nwhich in this case is\n\n```javascript\nwhich_in_this_case\n          prime_definition\n          stream_enumerate_interval\n\t  10949\n\npair(10007,\n     () => stream_filter(\n              is_prime,\n              pair(10008,\n                   () => stream_enumerate_interval(10009, 1000000))));\n\nstream_ref(pair(10007,\n     () => stream_filter(\n               is_prime,\n               pair(10008,\n                    () => stream_enumerate_interval(10009, 1000000))\n              )\n    ), 100);\n```\n\nThis result is now passed to\nstream_tail in our original\nexpression.\n\nThis forces the delayed\nstream_filter ,\nwhich in turn keeps forcing the delayed\nstream_@enumerate_interval until it\nfinds the next prime, which is 10,009.\n\nFinally, the result passed to\n\n```javascript\nnow_passed_to\n          prime_definition\n          stream_enumerate_interval\n\t  10957\n\npair(10009,\n     () => stream_filter(\n              is_prime,\n              pair(10010,\n                   () => stream_enumerate_interval(10011, 1000000))));\n\nstream_ref(pair(10009,\n     () => stream_filter(\n               is_prime,\n               pair(10010,\n                    () => stream_enumerate_interval(10011, 1000000))\n              )\n    ), 100);\n```\n\nThe function\n\nIn general, we can think of delayed evaluation as\ndemand-driven programming, whereby each stage in the\nstream process is activated only enough to satisfy the next stage.\n\nWhat\nwe have done is to\nall at once when, in reality, the computation is\nperformed incrementally, as in traditional programming styles.\n\nWhen we construct stream pairs, we delay the evaluation of their tail\nexpressions by wrapping these expressions in a function.\n\nWe force their\nevaluation when needed, by applying the function.\n\nThis implementation suffices for streams to work as advertised, but\nthere is an important optimization that we shall consider where needed.\n\nIn many applications, we end up forcing the same delayed object many\ntimes.\n\nThis can lead to serious inefficiency in recursive programs\ninvolving streams.",
    "token_count": 289,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams Are Delayed Lists",
    "chunk_index": 6,
    "chunk_id": "Modularity_Objects_and_State_Streams_Are_Delayed_Lists_6"
  },
  {
    "content": "This can lead to serious inefficiency in recursive programs\ninvolving streams.\n\n(See\nexercise.)\nThe solution is to build delayed objects so that the first time they are\nforced, they store the value that is computed.\n\nSubsequent forcings will\nsimply return the stored value without repeating the computation.\n\nIn\nother words, we implement the construction of stream pairs as a.\n\nOne way to accomplish this\nis to use the following function, which takes as argument a function\n(of no arguments) and returns a memoized version of the function.\n\nThe first time the memoized function is run, it saves the computed\nresult.\n\nOn subsequent evaluations, it simply returns\nthe result.\n\n```javascript\nmemo\n\t  memo_example\n\t  1\n\nfunction memo(fun) {\n    let already_run = false;\n    let result = undefined;\n    return () => {\n               if (!already_run) {\n                   result = fun();\n                   already_run = true;\n                   return result;\n               } else {\n                   return result;\n               }\n           };\n}\n```\n\n```javascript\nmemo_example\n\nfunction square_4() {\n    const result = 4 * 4;\n    display(\"multiplication carried out\");\n    return result;\n}\nconst memo_square_4 = memo(square_4);\ndisplay(memo_square_4()); // shows \"multipl..\"\ndisplay(memo_square_4()); // does not show \"multipl..\"\n\nlet calls = 0;\nfunction square_4() {\n    const result = 4 * 4;\n    calls = calls + 1;\n    return result;\n}\nconst memo_square_4 = memo(square_4);\nmemo_square_4();\nmemo_square_4();\ncalls;\n```\n\nWe can make use of memo whenever\nwe construct a stream pair.\n\nFor example, instead of\n\n```javascript\nstream_map_example\n\t  3\n\nfunction stream_map(f, s) {\n    return is_null(s)\n           ? null\n           : pair(f(head(s)),\n                  () => stream_map(f, stream_tail(s)));\n}\n```",
    "token_count": 242,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams Are Delayed Lists",
    "chunk_index": 7,
    "chunk_id": "Modularity_Objects_and_State_Streams_Are_Delayed_Lists_7"
  },
  {
    "content": "For example, instead of\n\n```javascript\nstream_tail\n\t  stream_map_example\n\nconst my_stream = pair(4, () => pair(5, () => null));\n\nconst my_stream_2 =\n    stream_map(display, my_stream);\n\nstream_ref(my_stream_2, 1);\nstream_ref(my_stream_2, 1);\n// the number 5 is shown twice\n// because the same delayed\n// object is forced twice\n\nconst my_stream = pair(4, () => pair(5, () => null));\nlet calls = 0;\nconst my_stream_2 =\n    stream_map(x => {calls = calls + 1;}, my_stream);\n\nstream_ref(my_stream_2, 1);\nstream_ref(my_stream_2, 1);\ncalls;\n```\n\nwe can define an optimized function stream_map as follows:\n\n```javascript\nstream_map_optimized\n\t  memo\n\t  stream_map_optimized_example\n\t  2\n\nfunction stream_map_optimized(f, s) {\n    return is_null(s)\n           ? null\n           : pair(f(head(s)),\n                  memo(() =>\n                         stream_map_optimized(f, stream_tail(s))));\n}\n```\n\n```javascript\nstream_map_optimized_example\n\nconst my_stream = pair(4, () => pair(5, () => null));\n\nconst my_stream_2 =\n    stream_map(display, my_stream);\n\nstream_ref(my_stream_2, 1);\nstream_ref(my_stream_2, 1);\n// the number 5 is shown twice\n// because the same delayed\n// object is forced twice\n\nconst my_stream_3 =\n    stream_map_optimized(display, my_stream);\n\nstream_ref(my_stream_3, 1);\nstream_ref(my_stream_3, 1);\n// the number 5 is shown only once\n// because the result of forcing\n// the delayed object is memoized\n\nconst my_stream = pair(4, () => pair(5, () => null));\n\nconst my_stream_2 =\n    stream_map(x => x, my_stream);\n\nstream_ref(my_stream_2, 1);\nstream_ref(my_stream_2, 1);\n// the number 5 is shown twice\n// because the same delayed\n// object is forced twice\n\nlet calls = 0;\nconst my_stream_3 =\n    stream_map_optimized(x => {calls = calls + 1;}, my_stream);\n\nstream_ref(my_stream_3, 1);\nstream_ref(my_stream_3, 1);\ncalls;\n```",
    "token_count": 230,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams Are Delayed Lists",
    "chunk_index": 8,
    "chunk_id": "Modularity_Objects_and_State_Streams_Are_Delayed_Lists_8"
  },
  {
    "content": "The function at the end of the preceding section shows how we can use streams to model signal-processing systems that contain is modeled by the\n\nfact that s internal stream integ is defined in terms of itself:\n\n```javascript\nconst integ = pair(initial_value,\n                   () => add_streams(scale_stream(integrand, dt),\n                                     integ));\n```\n\n```javascript\nThe interpreters ability to deal with such an implicit definition\n\tdepends on the delay resulting from wrapping the call to\n\tadd_streams in a lambda expression.\n\tWithout this delay, the interpreter could not\n\tconstruct\n```\n\nUnfortunately, stream models of systems with loops may require uses of a\ndelay beyond the stream programming pattern seen so far.\n\nFor instance,\nfigure shows a\nsignal-processing system for solving the\n$dy/dt=f(y)$ where\n$f$ is a given function.\n\nThe figure shows a\nmapping component, which applies $f$ to its\ninput signal, linked in a feedback loop to an integrator in a manner\nvery similar to that of the analog computer circuits that are actually\nused to solve such equations.\n\nAn\nanalog computer circuit that solves the equation\n$dy/dt = f(y)$.\n\nAssuming we are given an initial value $y_0$ for $y$ , we could try to model this system using the function\n\n```javascript\nfunction solve(f, y0, dt) {\n    const y = integral(dy, y0, dt);\n    const dy = stream_map(f, y);\n    return y;\n}\n```\n\nThis function does not work, because in the first line of\n\nOn the other hand, the intent of our definition does make sense, because we can, in principle, begin to generate the Indeed, For in the\n\nsecond line of\n\nTo take advantage of this idea, we will redefine\ndelayed argument.\n\nThe function\nthe integrand to be evaluated only when it is required to generate more than\nthe first element of the output stream:",
    "token_count": 288,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams and Delayed Evaluation",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Streams_and_Delayed_Evaluation_1"
  },
  {
    "content": "The function\nthe integrand to be evaluated only when it is required to generate more than\nthe first element of the output stream:\n\n```javascript\nintegral_example_4\n\nfunction numbers_starting_from(t, dt) {\n    return pair(t,\n                () => numbers_starting_from(t + dt, dt)\n               );\n}\nconst dt = 0.01;\nconst linear = numbers_starting_from(0, dt);\nconst linear_integral = integral(() => linear, 0, dt);\n// computing integral from 0 to 3 of f(x) = x\n// (the integral is g(x) = 0.5 x^2, and therefore\n// the result is near 0.5 * 3^2 = 4.5)\nstream_ref(linear_integral, math_round(3 / dt));\n```\n\n```javascript\nintegral\n      add_streams\n      scale_stream\n      integral_example_4\n      4.484999999999992\n\nfunction integral(delayed_integrand, initial_value, dt) {\n    const integ =\n        pair(initial_value,\n             () => {\n                 const integrand = delayed_integrand();\n                 return add_streams(scale_stream(integrand, dt),\n                                    integ);\n             });\n    return integ;\n}\n```\n\nNow we can implement our function by delaying the evaluation of declaration of\n\n```javascript\nsolve\n      e\n\nfunction solve(f, y0, dt) {\n    const y = integral(() => dy, y0, dt);\n    const dy = stream_map(f, y);\n    return y;\n}\n```\n\nIn general, every caller of\ndelay\nthe integrand argument.\n\nWe can demonstrate that the\nfunction\nworks by approximating\n$e\\approx 2.718$ by computing the value at\n$y=1$ of the solution to the differential\nequation $dy/dt=y$ with initial condition\n$y(0)=1$ :",
    "token_count": 200,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams and Delayed Evaluation",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Streams_and_Delayed_Evaluation_2"
  },
  {
    "content": "We can demonstrate that the\nfunction\nworks by approximating\n$e\\approx 2.718$ by computing the value at\n$y=1$ of the solution to the differential\nequation $dy/dt=y$ with initial condition\n$y(0)=1$ :\n\n```javascript\nsolve_optimized\n\nfunction memo(fun) {\n    let already_run = false;\n    let result = undefined;\n    return () => {\n                     if (!already_run) {\n                         result = fun();\n                         already_run = true;\n                         return result;\n                     } else {\n                         return result;\n                     }\n\t         };\n}\n// note the use of the memoization optimization\nfunction stream_combine(f, s1, s2) {\n    return is_null(s1) && is_null(s2)\n           ? null\n           : is_null(s1) || is_null(s2)\n           ? error(null, \"unexpected argument -- stream_combine\")\n           : pair(f(head(s1), head(s2)),\n                  memo(() => stream_combine(f, stream_tail(s1),\n                                            stream_tail(s2))));\n}\nfunction add_streams(s1, s2) {\n    return stream_combine((x1, x2) => x1 + x2, s1, s2);\n}\nfunction scale_stream(stream, factor) {\n    return stream_map(x => x * factor,\n                      stream);\n}\n// note the use of the memoization optimization\nfunction integral(delayed_integrand, initial_value, dt) {\n    const integ =\n        pair(initial_value,\n             memo(() => {\n                  const integrand = delayed_integrand();\n                  return add_streams(scale_stream(integrand, dt),\n                                     integ);\n                 }));\n    return integ;\n}\nfunction solve(f, y0, dt) {\n    const y = integral(() => dy, y0, dt);\n    const dy = stream_map(f, y);\n    return y;\n}\n```\n\n```javascript\ne\n      solve_optimized\n      2.716923932235896\n\nstream_ref(solve(y => y, 1, 0.001), 1000);\n```\n\nWrite a\nfunction\n$R$ , $L$ , and\n$C$ of the circuit and the time increment\n$dt$.\n\nIn a manner similar to that of the\nfunction\nof exercise ,\nfunction\nthat takes the initial values of the state variables,\n$v_{C_{0}}$ and\n$i_{L_{0}}$ , and produces a pair\n(using pair)\nof the streams of states $v_{C}$ and\n$i_{L}$.\n\nUsing $R = 1$ ohm,\n$C= 0.2$ farad,\n$L = 1$ henry,\n$dt = 0.1$ second, and initial values\n$i_{L_{0}} = 0$ amps and\n$v_{C_{0}} = 10$ volts.",
    "token_count": 280,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams and Delayed Evaluation",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Streams_and_Delayed_Evaluation_3"
  },
  {
    "content": "Using $R = 1$ ohm,\n$C= 0.2$ farad,\n$L = 1$ henry,\n$dt = 0.1$ second, and initial values\n$i_{L_{0}} = 0$ amps and\n$v_{C_{0}} = 10$ volts.\n\nThe examples in this section illustrate how\ndelayed evaluation\nprovides great programming flexibility, but the same examples also show how\nthis can make our programs more complex.\n\nOur new\nfunction,\nfor instance, gives us the power to model systems with loops, but we must\nnow remember that\nfunction\nthat uses\nfunctions:\nordinary\nfunctions\nand\nfunctions\nthat take delayed arguments.\n\nIn general, creating separate classes of\nfunctions\nforces us to create separate classes of higher-order\nfunctions\nas well.\n\nOne way to avoid the need for two different classes of\nfunctions\nis to make all\nfunctions\ntake delayed arguments.\n\nWe could adopt a model of evaluation in which all\narguments to\nfunctions\nare automatically delayed and arguments are forced only when they are\nactually needed (for example, when they are required by a primitive\noperation).\n\nThis would transform our language to use normal-order\nevaluation, which we first described when we introduced the substitution\nmodel for evaluation in section.\n\nConverting to normal-order evaluation provides a uniform and elegant way to\nsimplify the use of delayed evaluation, and this would be a natural strategy\nto adopt if we were concerned only with stream processing.\n\nIn\nsection , after we have studied the\nevaluator, we will see how to transform our language in just this way.\n\nUnfortunately, including delays in\nfunction\ncalls wreaks havoc with our ability to design programs that depend on the\norder of events, such as programs that use assignment, mutate data, or\nperform input or output.\n\n```javascript\nEven a single delay in the tail of a pair can cause great confusion, as\n\tillustrated by exercises\n\tand.\n```",
    "token_count": 294,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams and Delayed Evaluation",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Streams_and_Delayed_Evaluation_4"
  },
  {
    "content": "Unfortunately, including delays in\nfunction\ncalls wreaks havoc with our ability to design programs that depend on the\norder of events, such as programs that use assignment, mutate data, or\nperform input or output.\n\nAs far as anyone knows, mutability and delayed evaluation do not mix well\nin programming\nlanguages.\n\nA signal-flow diagram for the solution to a series RLC circuit.",
    "token_count": 61,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "Streams",
    "subsection": "Streams and Delayed Evaluation",
    "chunk_index": 5,
    "chunk_id": "Modularity_Objects_and_State_Streams_and_Delayed_Evaluation_5"
  },
  {
    "content": "When we introduced compound functions in chapter , we used the ) to define what is meant by applying a function to arguments: - -\n\nTo apply a compound function to arguments, evaluate the return expression of the function (more generally, the body) with each parameter replaced by the corresponding\n\nargument.\n\nOnce we admit assignment into our programming language, such a\ndefinition is no longer adequate.\n\nIn particular,\nsection argued that, in the\npresence of assignment,\n\n```javascript\na name cannot be considered to be merely\n\trepresenting a value.  Rather, a name must somehow designate a\n\tplace in which values can be stored.\n```\n\nIn our new model of evaluation, these places will be maintained in structures called environments.\n\nAn environment is a sequence of\nframes.\n\nEach frame is a table (possibly empty) of\nbindings , which associate\nnames\nwith their corresponding\nvalues.\n\n(A single frame may contain at most one binding for any name.)\nEach frame also has a pointer to its\nenclosing environment , unless, for the purposes of discussion, the\nframe is considered to be\nglobal.\n\nThe\nvalue of a name\nwith respect to an environment is the value given by the binding of\nthe\nname\nin the first frame in the environment that contains a\nbinding for that\nname.\n\nIf no frame in the sequence specifies a\nbinding for the\nname,\nthen the\nname\nis said to be\nunbound in the environment.\n\nA simple\n\nFigure\nshows a simple environment\nstructure consisting of three frames, labeled I, II, and III.\n\nIn the\ndiagram, A, B, C, and D are pointers to environments.\n\nC and D point\nto the same environment.\n\nThe\nnames\nII, while\nshadow the binding of\n\nThe environment is crucial to the evaluation process, because it determines\nthe context in which an expression should be evaluated.",
    "token_count": 300,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": null,
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_The_Environment_Model_of_Evaluation_1"
  },
  {
    "content": "The environment is crucial to the evaluation process, because it determines\nthe context in which an expression should be evaluated.\n\nIndeed, one could\nsay that expressions in a programming language do not, in themselves, have\nany meaning.\n\nRather, an expression acquires a meaning only with respect to\nsome environment in which it is evaluated.\n\n```javascript\nEven the interpretation of an expression as straightforward as\n\tdisplay(1) depends on an\n\tunderstanding that one is operating in a context in which the name\n```\n\nThus, in our model of evaluation we will always speak of evaluating an\nexpression with respect to some environment.\n\nTo describe interactions with\nthe interpreter, we will suppose that there is a\nnames\nassociated with the\nprimitive\nfunctions.\n\nFor example, the idea that\n\n```javascript\ndisplay is the name for the\n\tprimitive display function is captured by saying that the\n\tname display\n```\n\nis bound in the global environment to the primitive display function.\n\nBefore we evaluate a program, we extend the global\nenvironment with a new frame, the\nprogram frame , resulting in the\nprogram environment.\n\nWe will add\nthe names that are declared at the top level of the\nprogram, outside of any block, to this frame.\n\nThe given program\nis then evaluated with respect to the program environment.",
    "token_count": 211,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": null,
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_The_Environment_Model_of_Evaluation_2"
  },
  {
    "content": "we showed how the\n\n```javascript\napplication\n      f(5)\n```\n\nevaluates to 136, given the following function declarations:\n\n```javascript\nf_example\n      136\n\nfunction square(x) {\n    return x * x;\n}\nfunction sum_of_squares(x, y) {\n    return square(x) + square(y);\n}\nfunction f(a) {\n    return sum_of_squares(a + 1, a * 2);\n}\n```\n\nWe can analyze the same example using the environment model.\n\nFigure shows the three\nfunction\nobjects created by evaluating the definitions of\nsum_of_squares\nin the\nprogram\nenvironment.\n\nEach\nfunction\nobject consists of some code, together with a pointer to the\nprogram\nenvironment.\n\nFunction objects in the program frame.\n\nfigure\nwe see the environment structure created by evaluating the expression\nf(5).\n\nThe call to parameter of\n\n```javascript\nreturn sum_of_squares(a + 1, a * 2);\n```\n\nTo evaluate\n\n```javascript\nthe return statement, we first evaluate the\n\tsubexpressions of the return expression.\n```\n\nThe first subexpression,\nsum_of_squares,\nhas a value that is a\nfunction\nobject.\n\n(Notice how this value is found: We first look in the first frame\nof E1, which contains no binding for\nsum_of_squares.\n\nThen we proceed to the enclosing environment, i.e., the\nprogram\nenvironment, and find the binding shown in\nfigure.)\nThe other two subexpressions are evaluated by applying the primitive\noperations\na + 1\nand\na * 2\nto obtain 6 and 10, respectively.\n\nNow we apply the\nfunction\nobject\nsum_of_squares\nto the arguments 6 and 10.\n\nThis results in a new environment, E2, in which\nthe parameters\n\n```javascript\nthe statement\n\nreturn square(x) + square(y);\n```\n\nThis leads us to evaluate square(x), where program frame and\n\n```javascript\nreturn x * x;.\n```\n\nAlso as part of applying sum_of_squares, we must evaluate the subexpression square(y), where parameter of\n\n```javascript\nreturn x * x;.\n```\n\nThe important point to observe is that each call to program environment, since this is the environment indicated by the function object.\n\nAfter the subexpressions are evaluated, the results are returned.",
    "token_count": 313,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "Applying Simple Functions",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Applying_Simple_Functions_1"
  },
  {
    "content": "After the subexpressions are evaluated, the results are returned.\n\nThe\nvalues generated by the two calls to\nsum_of_squares,\nand this result is returned by.",
    "token_count": 24,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "Applying Simple Functions",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Applying_Simple_Functions_2"
  },
  {
    "content": "The environment model as presented so far focuses on how functions can refer\nto their parameters, locally declared names, and names that are declared\noutside the function.\n\nWe achieve this by evaluating statements and expressions\nwith respect to a current environment.\n\nIt does not specify how\nwe keep track of environments as computation proceeds.\n\nFor example, when we\nevaluate an expression f(x) + y , we\nneed to evaluate x in the current\nenvironment, establish as the new current environment the environment of\nf extended by a binding of its\nparameter to the value of x , and\nevaluate the body of f in this\nextended environment.\n\nBut what environment should we use for evaluating\ny after\nf returns?\n\nIn this section, we extend the\n\nExercise shows that the presence of\nassignments makes the result of a program depend on the order in which\nthe operands of an operator combination are evaluated.\n\nTo remove\nambiguities that arise from this, the JavaScript standard specifies\nleft-to-right evaluation of operands.\n\nAs an example, consider the evaluation of the arithmetic statement\n\n```javascript\n1 + (2 * 3);\n```\n\nThe expression is decomposed into its operands 1 and 2 * 3 , followed by the instruction to add their results.",
    "token_count": 205,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "CSE Machine",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_CSE_Machine_1"
  },
  {
    "content": "We can turn to the environment model to see how\nfunctions\nand assignment can be used to represent objects with local state.\n\nAs an\nexample, consider the\nwithdrawal processor from\nsection created by calling the\nfunction\n\n```javascript\nmake_withdraw2\n\nfunction make_withdraw(balance) {\n    return amount => {\n               if (balance >= amount) {\n                   balance = balance - amount;\n                   return balance;\n               } else {\n                   return \"insufficient funds\";\n               }\n           };\n}\n```\n\nLet us describe the evaluation of\n\n```javascript\nmake_withdraw2\n      make_withdraw2_w1_declare\n\nconst W1 = make_withdraw(100);\n```\n\nfollowed by\n\n```javascript\nmake_withdraw2_w1_example\n      make_withdraw2_w1_declare\n      50\n\nW1(50);\n```\n\nFigure shows the result of\n\n```javascript\ndeclaring the\n      make_withdraw\n```\n\nfunction\nin the\nprogram\nenvironment.\n\nThis produces a\nfunction\nobject that contains a pointer to the\nprogram\nenvironment.\n\nSo far, this is no different from the examples we have already\nseen, except that\n\n```javascript\nthe return expression in the body of the function is itself\n\ta lambda expression.\n```\n\n```javascript\nResult of defining\n\t    make_withdraw in\n\t    the program environment.\n```\n\nThe interesting part of the computation happens when we apply the function make_withdraw to an argument:\n\n```javascript\nconst W1 = make_withdraw(100);\n```\n\nWe begin, as usual, by setting up an environment E1 in which the parameter make_withdraw, namely the\n\n```javascript\nreturn statement whose return expression is\n      a lambda expression. The evaluation of this lambda expression\n```\n\nconstructs a new\nfunction\nobject, whose code is as specified by the\nlambda expression\nand whose environment is E1, the environment in which the\nlambda expression\nwas evaluated to produce the\nfunction.\n\nThe resulting\nfunction\nobject is the value returned by the call to\nmake_withdraw.\n\nThis is bound to\nprogram\nenvironment, since the\nconstant declaration\nitself is being evaluated in the\nprogram\nenvironment.\n\nFigure\nshows the resulting environment structure.\n\n```javascript\nResult of evaluating\n\t    const W1 = make_withdraw(100);.\n```\n\nNow we can analyze what happens when\n\n```javascript\nW1(50);\n```",
    "token_count": 302,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "Frames as the Repository of Local State",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Frames_as_the_Repository_of_Local_State_1"
  },
  {
    "content": "Now we can analyze what happens when\n\nWe begin by constructing a frame in which\nparameter of\nprogram\nenvironment, but rather the environment E1, because this is the\nenvironment that is specified by the\nfunction\nobject.\n\nWithin this new environment, we evaluate the body of the\nfunction:\n\n```javascript\nif (balance >= amount) {\n    balance = balance - amount;\n    return balance;\n} else {\n    return \"insufficient funds\";\n}\n```\n\nThe resulting environment structure is shown in\nfigure.\n\nThe expression being evaluated references\nboth\nThe variable amount\nwill be found in the first frame in the environment, and\n\n```javascript\nEnvironments created by applying the function object\n\t    W1.\n```\n\nWhen the\nassignment\nis executed, the binding of\nfunction\nobject\nfunction\ncall that constructed it has terminated, and there are no pointers to that\nframe from other parts of the environment.\n\nThe next time\nplace that holds the local\nstate variable for the\nfunction\nobject\nFigure\nshows the situation after the call to\n\n```javascript\nEnvironments after the call to\n\t    W1.\n```\n\nObserve what happens when we create a second withdraw object by making another call to make_withdraw:\n\n```javascript\nmake_withdraw2\n      make_withdraw2_w2_declare\n      20\n\nconst W2 = make_withdraw(100);\n\nconst W1 = make_withdraw(100);\nW1(50);\nconst W2 = make_withdraw(100);\nW2(80);\n```\n\nThis produces the environment structure of\nfigure,\nwhich shows\nthat\nfunction\nobject, that is, a pair with some code and an environment.\n\nThe environment\nE2 for\nmake_withdraw.\n\nIt contains a frame with its own local binding for\nlambda\nexpression in the body of\nmake_withdraw.\n\n```javascript\nUsing\n\t    const W2 = make_withdraw(100);\n\t    to create a second object.\n```",
    "token_count": 258,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "Frames as the Repository of Local State",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Frames_as_the_Repository_of_Local_State_2"
  },
  {
    "content": "In this section we handle the evaluation of function bodies or other\nblocks (such as the branches of conditional statements) that contain\ndeclarations.\n\nEach block opens a new scope for names declared in the block.\n\nIn order to evaluate a block in a given environment, we extend that\nenvironment by a new frame that contains all names declared directly\n(that is, outside of nested blocks) in the body of the block and\nthen evaluate the body in the newly constructed environment.\n\nSection introduced the idea that functions can have internal declarations, thus leading to a block structure as in the function to compute square roots:\n\n```javascript\nanother_sqrt\n      abs_definition\n      square_definition\n      average_definition\n      sqrt_example7\n      2.2360688956433634\n\nfunction sqrt(x) {\n    function is_good_enough(guess) {\n        return abs(square(guess) - x) < 0.001;\n    }\n    function improve(guess) {\n        return average(guess, x / guess);\n    }\n    function sqrt_iter(guess){\n        return is_good_enough(guess)\n               ? guess\n               : sqrt_iter(improve(guess));\n    }\n    return sqrt_iter(1);\n}\n```\n\nNow we can use the environment model to see why these internal\ndeclarations\nbehave as desired.\n\nFigure\nshows the point in the evaluation of the expression\nsqrt(2)\nwhere the internal\nfunction\nis_good_enough\nhas been called for the first time with\n1.\n\nThe\n\nObserve the structure of the environment.\n\nThe name\nto a\nfunction\nobject whose associated environment is the\nprogram\nenvironment.\n\nWhen\nprogram\nenvironment, in which the parameter 2.\n\nThe body of E1.\n\n```javascript\nThat body is a block with local\n\tfunction declarations and therefore E1 was extended with a new frame for\n\tthose declarations, resulting in the new environment E2. The body\n\tof the block was then evaluated in E2. Since the first statement\n\tin the body is\n```\n\n```javascript\nabs_definition\n      square_definition\n\nfunction is_good_enough(guess) {\n    return abs(square(guess) - x) < 0.001;\n}\n```\n\n```javascript\nevaluating this declaration created the function\n\tis_good_enough\n\tin the environmentE2.\n```",
    "token_count": 293,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "Internal Declarations",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_Internal_Declarations_1"
  },
  {
    "content": "The body of E1.\n\n```javascript\nTobe more precise,\n\tthe name is_good_enough\n\tin the first frame of E2 was bound to a function\n\tobject whose associated environment is E2.\n```\n\nSimilarly,\nsqrt_iter\nwere defined as\nfunctions in E2.\n\nFor conciseness,\nfigure\nshows only the\nfunction\nobject for\nis_good_enough.\n\nAfter the local\nfunctions\nwere defined, the expression\nsqrt_@iter(1)\nwas evaluated, still in environment\nE2.\n\nSo the\nfunction\nobject bound to\n\n```javascript\nsqrt_@iter\n      in E2 was called with 1 as an argument.  This created an environment E3\n      in which\n```\n\nsqrt_@iter,\nis bound to 1.\n\nThe function sqrt_@iter\nin turn called\nis_@good_@enough\nwith the value of\n\n```javascript\n(from E3) as the argument for\n\tis_@good_@enough.\n```\n\nThis set up another environment,\n\n```javascript\nE4, in which\n\tis_@good_@enough)\n```\n\nis bound to 1.\n\nAlthough\nsqrt_@iter\nand\nis_@good_@enough\nboth have a parameter named\n\n```javascript\nAlso, E3 and E4 both have E2 as their enclosing environment, because the\n\tsqrt_@iter\n\tand\n\tis_@good_@enough functions\n\tboth have E2 as their environment part.\n```\n\nOne consequence of this is that the name is_@good_@enough will reference the binding of function was called.\n\nThe environment model thus explains the two key properties that make local\nfunction declarations\na useful technique for modularizing programs:\n-\n-\nThe names of the local\nfunctions\ndo not interfere with\nnames external to the enclosing\nfunction,\nbecause the local\nfunction\nnames will be bound in the frame that the\nblock creates when it is evaluated,\nrather than being bound in the\nprogram\nenvironment.\n-\n-\nThe local\nfunctions\ncan access the arguments of the enclosing\nfunction,\nsimply by using parameter names as free\nnames.\n\nThis is\nbecause the body of the local\nfunction\nis evaluated in an environment that is subordinate to the\nevaluation environment for the enclosing\nfunction.\n\nAs we saw, the scope of the names declared in\nsqrt is the whole body of\nsqrt.",
    "token_count": 307,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "Internal Declarations",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_Internal_Declarations_2"
  },
  {
    "content": "As we saw, the scope of the names declared in\nsqrt is the whole body of\nsqrt.\n\nThis explains why\nmutual recursion works, as in this (quite\nwasteful) way of checking whether a nonnegative\ninteger is even.\n\n```javascript\nf_is_even_is_odd\n\nfunction f(x) {\n    function is_even(n) {\n        return n === 0\n               ? true\n               : is_odd(n - 1);\n    }\n    function is_odd(n) {\n        return n === 0\n               ? false\n               : is_even(n - 1);\n    }\n    return is_even(x);\n}\n```\n\nAt the time when\nis_even is called during a call to\nf , the environment diagram looks\nlike the one in figure when\nsqrt_iter is called.\n\nThe functions\nis_even and\nis_odd are bound in E2 to function objects\nthat point to E2 as the environment in which to evaluate calls to those\nfunctions.\n\nThus\nis_odd in the body of\nis_even refers to the right function.\n\nAlthough\nis_odd\nis defined after\nis_even ,\nthis is no different from how in the body of\nsqrt_iter\nthe name\nimprove\nand the name\nsqrt_iter\nitself refer to the right functions.\n\nEquipped with a way to handle declarations within blocks, we can\nrevisit declarations of names at the top level.\n\nIn\nsection , we saw\nthat the names declared at the top level are added to the program\nframe.\n\nA better explanation is that the whole program is placed in\nan implicit block, which is evaluated in the global environment.\n\nThe treatment of blocks described above then handles the top\nlevel:\nThe global environment is extended by a frame that contains the\nbindings of all names declared in the implicit block.\n\nThat frame is\nthe program frame and the resulting\nenvironment is the\n\nWe said that a block s body is evaluated in an environment that\ncontains all names declared directly in the body of the block.",
    "token_count": 296,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "Internal Declarations",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_Internal_Declarations_3"
  },
  {
    "content": "We said that a block s body is evaluated in an environment that\ncontains all names declared directly in the body of the block.\n\nA locally declared name is put into the environment when the block is\nentered, but without an associated value.\n\nThe evaluation of its\ndeclaration during evaluation of the block body then assigns to the\nname the result of evaluating the expression to the right of the\n= , as if the declaration were\nan assignment.\n\nSince the addition of the name to the environment is\nseparate from the evaluation of the declaration, and the whole block\nis in the scope of the name, an erroneous program could attempt to",
    "token_count": 113,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "Internal Declarations",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_Internal_Declarations_4"
  },
  {
    "content": "The overall specification of how the interpreter\nfunction application\nremains the same as when we first introduced it in\nsection :\n-\n-\nTo evaluate\nan application:\n-\n-\nEvaluate the subexpressions\nof the\napplication.\n-\n-\nApply the value of the\nfunction\nsubexpression\nto the values of the\nargument\nsubexpressions.\n\nThe environment model of evaluation replaces the substitution model in\nspecifying what it means to apply a compound\nfunction\nto arguments.\n\nIn the environment model of evaluation, a\nfunction\nis always a pair consisting of some code and a pointer to an environment.\n\nFunctions\nare created in one way only: by evaluating a\nlambda\nexpression.\nfunction\nwhose code is obtained from the text of the\nlambda\nexpression and whose environment is the environment in which the\nlambda\nexpression was evaluated to produce the\nfunction.\n\nFor example, consider the\nfunction declaration\n\n```javascript\nsquare_example\n      196\n\nfunction square(x) {\n    return x * x;\n}\n```\n\nevaluated in the\nprogram\nenvironment.\n\nThe\nfunction declaration\nsyntax is\nequivalent to\nan underlying implicit\nlambda\nexpression.\n\nIt would have been equivalent to have used\n\n```javascript\nsquare_example\n      196\n\nconst square = x => x * x;\n```\n\nwhich evaluates\n\n```javascript\nx => x * x\n```\n\nand binds program environment.\n\nFigure shows the result of evaluating this declaration statement.\n\n```javascript\nThe global environment encloses the program environment. To reduce\n\tclutter, after this figure we will not display the global environment\n\t(as it is always the same), but we are reminded of its existence by the\n\tpointer from the program environment upward.\n```\n\nThe function object is a pair whose code specifies that the function has one parameter, namely function body\n\n```javascript\nreturn x * x;.\n```\n\nThe environment part of the\nfunction\nis a pointer to the program environment, since that is the environment in\nwhich the\nlambda\nexpression was evaluated to produce the\nfunction.",
    "token_count": 308,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "The Rules for Evaluation",
    "chunk_index": 1,
    "chunk_id": "Modularity_Objects_and_State_The_Rules_for_Evaluation_1"
  },
  {
    "content": "The environment part of the\nfunction\nis a pointer to the program environment, since that is the environment in\nwhich the\nlambda\nexpression was evaluated to produce the\nfunction.\n\nA new binding, which associates the\nfunction\nobject with the\nname\n\n```javascript\nEnvironment structure produced by evaluating\n\t    function square(x) { return x * x; }\n\t    in the program environment.\n```\n\nIn general, const ,\nfunction , and\nlet\nadd bindings to frames.\n\nAssignment is forbidden on constants, so our environment model\nneeds to distinguish names that refer to constants\nfrom names that refer to variables.\n\nWe indicate that\na name is a constant by writing an equal sign after the colon\nthat follows the name.\n\nWe consider function declarations as equivalent to constant\ndeclarations;.\n\nNow that we have seen how\nfunctions\nare created, we can describe how\nfunctions\nare applied.\n\nThe environment model specifies: To apply a\nfunction\nto arguments, create a new environment containing a frame that binds the\nparameters to the values of the arguments.\n\nThe enclosing environment of\nthis frame is the environment specified by the\nfunction.\n\nNow, within this new environment, evaluate the\nfunction\nbody.\n\nTo show how this rule is followed,\nfigure\nillustrates the environment structure created by evaluating the\nexpression\nsquare(5)\nin the\nprogram\nenvironment, where\nfunction\ngenerated in\nfigure.\n\nApplying the\nfunction\nresults in the creation of a new environment, labeled E1 in the figure, that\nbegins with a frame in which\nparameter for the\nfunction,\nis bound to the argument 5.\n\nNote that name\nThe pointer leading upward from this frame shows that the\nframe s enclosing environment is the\nprogram\nenvironment.\n\nThe\nprogram\nenvironment is chosen here, because this is the environment that is\nindicated as part of the\nfunction\nobject.\n\nWithin E1, we evaluate the body of the\nfunction,\n\n```javascript\nreturn x * x;.\n```",
    "token_count": 304,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "The Rules for Evaluation",
    "chunk_index": 2,
    "chunk_id": "Modularity_Objects_and_State_The_Rules_for_Evaluation_2"
  },
  {
    "content": "Within E1, we evaluate the body of the\nfunction,\n\nSince the value of 5 * 5, or 25.\n\n```javascript\nEnvironment created by evaluating\n\t    square(5)\n\t    in the program environment.\n```\n\nThe environment model of\nfunction\napplication can be summarized by two\nrules:\n-\n-\nA\nfunction\nobject is applied to a set of arguments by constructing a frame,\nbinding the parameters of the function\nto the arguments of the call, and then evaluating the body of the\nfunction\nin the context of the new environment constructed.\n\nThe new frame has as\nits enclosing environment the environment part of the\nfunction\nobject being applied.\n\nThe result of the application is the result of evaluating\nthe return expression of the first return statement encountered\nwhile evaluating the function body.\n-\n-\nA\nfunction\nis created by evaluating a\nlambda\nexpression relative to a given environment.\n\nThe resulting\nfunction\nobject is a pair consisting of the text of the\nlambda\nexpression and a pointer to the environment in which the\nfunction\nwas created.\n\n```javascript\nname=value\n\tin some environment\n\tlocates the binding of the name in the environment.\n\tThat is, one finds the first frame in the environment that contains a\n\tbinding for the name.\n\tIf the binding is a variable bindingindicated in the frame by\n\tjust :\n\tafter the namethat binding is changed to reflect the new\n\tvalue of the variable.\n\tOtherwise, if the binding in the frame is a constant\n\tbindingindicated\n\tin the frame by :=\n\tafter the namethe assignment signals an\n\t\"assignment to constant\" error.\n\tIf the name is unbound in the environment, then\n\tthe assignment signals a\n\t\"variable undeclared\" error.\n```\n\nThese evaluation rules, though considerably more complex than the\nsubstitution model, are still reasonably straightforward.\n\nMoreover,\nthe evaluation model, though abstract, provides a correct description\nof how the interpreter evaluates expressions.",
    "token_count": 301,
    "has_code": true,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "The Rules for Evaluation",
    "chunk_index": 3,
    "chunk_id": "Modularity_Objects_and_State_The_Rules_for_Evaluation_3"
  },
  {
    "content": "Moreover,\nthe evaluation model, though abstract, provides a correct description\nof how the interpreter evaluates expressions.\n\nIn chapter we shall\nsee how this model can serve as a blueprint for implementing a working\ninterpreter.\n\nThe following sections elaborate the details of the\nmodel by analyzing some illustrative programs.",
    "token_count": 48,
    "has_code": false,
    "chapter": "Modularity, Objects, and State",
    "section": "The Environment Model of Evaluation",
    "subsection": "The Rules for Evaluation",
    "chunk_index": 4,
    "chunk_id": "Modularity_Objects_and_State_The_Rules_for_Evaluation_4"
  }
]