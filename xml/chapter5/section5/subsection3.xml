<SUBSECTION>
  <NAME>
    Compiling
    <SPLITINLINE>
      <SCHEME>
	Combinations
      </SCHEME>
      <JAVASCRIPT>
	Applications and Return Statements
      </JAVASCRIPT>
    </SPLITINLINE>
  </NAME>

  <LABEL NAME="sec:compiling-combinations"/>
  
  <INDEX>compiler for JavaScript<SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE> applications<OPEN/></SUBINDEX></INDEX>
  <INDEX>compiler for JavaScript<SUBINDEX>combinations<OPEN/></SUBINDEX></INDEX>
  
  <TEXT>
    The essence of the compilation process is the compilation of
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    applications. The code for
    <SPLITINLINE>
      <SCHEME>a combination</SCHEME>
      <JAVASCRIPT>an application</JAVASCRIPT>
    </SPLITINLINE>
    compiled with a given target and
    linkage has the form
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      ^compilation of operator, target ^ proc^, linkage^ next
      ^evaluate operands and construct argument list in^ argl
      ^compilation of procedure call with given target and linkage^
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>compilation of function expression, target <JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE></METAPHRASE>
<METAPHRASE>evaluate argument expressions and construct argument list in <JAVASCRIPTINLINE>argl</JAVASCRIPTINLINE></METAPHRASE>
<METAPHRASE>compilation of function call with given target and linkage</METAPHRASE>
      </JAVASCRIPT>
    </SNIPPET>

    The registers <SCHEMEINLINE>env</SCHEMEINLINE>,
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>fun</SCHEMEINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    and <SCHEMEINLINE>argl</SCHEMEINLINE> may
    have to be saved and restored during evaluation of the
    <SPLITINLINE>
      <SCHEME>
	operator and operands.
      </SCHEME>
      <JAVASCRIPT>
	function and argument expressions.
      </JAVASCRIPT>
    </SPLITINLINE>
    Note that this is the only place in the compiler where a target other
    than <SCHEMEINLINE>val</SCHEMEINLINE> is specified.
  </TEXT>

  <TEXT>
    The required code is generated by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-application</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_application</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    This recursively compiles the
    <SPLITINLINE>
      <SCHEME>operator,</SCHEME>
      <JAVASCRIPT>function expression,</JAVASCRIPT>
    </SPLITINLINE>
    to produce code that puts the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to be applied into
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    and compiles the
    <SPLITINLINE>
      <SCHEME>operands,</SCHEME>
      <JAVASCRIPT>argument expressions,</JAVASCRIPT>
    </SPLITINLINE>
    to produce code that evaluates the individual
    <SPLITINLINE>
      <SCHEME>operands</SCHEME>
      <JAVASCRIPT>argument expressions</JAVASCRIPT>
    </SPLITINLINE>
    of the
    application.  The instruction sequences for the
    <SPLITINLINE>
      <SCHEME>operands</SCHEME>
      <JAVASCRIPT>argument expressions</JAVASCRIPT>
    </SPLITINLINE>
    are combined
    (by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>construct-arglist</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>construct_arglist</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    with code that constructs the list of
    arguments in <SCHEMEINLINE>argl</SCHEMEINLINE>, and the resulting
    argument-list code is combined with the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code and the code that performs the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call (produced by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-procedure-call</SCHEMEINLINE>).</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_function_call</JAVASCRIPTINLINE>).
      </JAVASCRIPT>
    </SPLITINLINE>
    In appending the code sequences, the <SCHEMEINLINE>env</SCHEMEINLINE>
    register must be preserved around the evaluation of the
    <SPLITINLINE>
      <SCHEME>operator</SCHEME>
      <JAVASCRIPT>function expression</JAVASCRIPT>
    </SPLITINLINE>
    (since
    evaluating the
    <SPLITINLINE>
      <SCHEME>operator</SCHEME>
      <JAVASCRIPT>function expression</JAVASCRIPT>
    </SPLITINLINE>
    might modify <SCHEMEINLINE>env</SCHEMEINLINE>, which
    will be needed to evaluate the
    <SPLITINLINE>
      <SCHEME>operands),</SCHEME>
      <JAVASCRIPT>argument expressions),</JAVASCRIPT>
    </SPLITINLINE>
    and the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>fun</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    register must be preserved around the
    construction of the argument list (since evaluating the
    <SPLITINLINE>
      <SCHEME>operands</SCHEME>
      <JAVASCRIPT>argument expressions</JAVASCRIPT>
    </SPLITINLINE>
    might
    modify
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>fun</SCHEMEINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which will be needed for the actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application). <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>Continue</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
        The <SCHEMEINLINE>continue</SCHEMEINLINE> register
      </JAVASCRIPT>
    </SPLITINLINE>
    must also be preserved throughout, since
    it is needed for the linkage in the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call.
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_application</DECLARATION></INDEX>
      <NAME>compile_application</NAME>
      <SCHEME>
      (define (compile-application exp target linkage)
      (let ((proc-code (compile (operator exp) 'proc 'next))
            (operand-codes
            (map (lambda (operand) (compile operand 'val 'next))
            (operands exp))))
      (preserving '(env continue)
      proc-code
      (preserving '(proc continue)
      (construct-arglist operand-codes)
      (compile-procedure-call target linkage)))))
      </SCHEME>
      <JAVASCRIPT>
function compile_application(exp, target, linkage) {
    const fun_code = compile(function_expression(exp), "fun", "next");
    const argument_codes =
              map(arg => compile(arg, "val", "next"),
                  arg_expressions(exp));
    return preserving(list("env", "continue"),
                      fun_code,
                      preserving(list("fun", "continue"),
                                 construct_arglist(argument_codes),
                                 compile_function_call(target, linkage)));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    The code to construct the argument list will evaluate each
    <SPLITINLINE>
      <SCHEME>
    operand
      </SCHEME>
      <JAVASCRIPT>
	argument expression
      </JAVASCRIPT>
    </SPLITINLINE>
    into
    <SCHEMEINLINE>val</SCHEMEINLINE> and then
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>cons</SCHEMEINLINE>
	that value onto the argument list being accumulated in
	<SCHEMEINLINE>argl</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	combine
	that value with the argument list being accumulated in
	<SCHEMEINLINE>argl</SCHEMEINLINE>
	using <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Since we
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>cons</SCHEMEINLINE>
	the arguments onto <SCHEMEINLINE>argl</SCHEMEINLINE>
	in sequence,
      </SCHEME>
      <JAVASCRIPT>
	put the arguments onto the front of <SCHEMEINLINE>argl</SCHEMEINLINE>
	in sequence using
	<JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    we must start with the last argument and end with the first, so that the
    arguments will appear in order from first to last in the resulting list.
    Rather than waste an instruction by initializing
    <SCHEMEINLINE>argl</SCHEMEINLINE> to the empty list
    to set up for this sequence of evaluations,
    we make the first code sequence construct the initial
    <SCHEMEINLINE>argl</SCHEMEINLINE>.
    The general form of the argument-list construction is thus as follows:
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      ^compilation of last operand, targeted to^ val
      (assign argl (op list) (reg val))
      ^compilation of next operand, targeted to^ val
      (assign argl (op cons) (reg val) (reg argl))
      ^$\ldots$^
      ^compilation of first operand, targeted to^ val
      (assign argl (op cons) (reg val) (reg argl))
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>compilation of last argument, targeted to <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE></METAPHRASE>
assign("argl", list(op("list"), reg("val"))),
<METAPHRASE>compilation of next argument, targeted to <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE></METAPHRASE>
assign("argl", list(op("pair"), reg("val"), reg("argl"))),
$\ldots$
<METAPHRASE>compilation of first argument, targeted to <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE></METAPHRASE>
assign("argl", list(op("pair"), reg("val"), reg("argl"))),
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Argl</SCHEMEINLINE>
	must be preserved around each operand
      </SCHEME>
      <JAVASCRIPT>
	The register
	<SCHEMEINLINE>argl</SCHEMEINLINE>
	must be preserved around each argument
      </JAVASCRIPT>
    </SPLITINLINE>
    evaluation except the first (so that arguments accumulated so far
    won<APOS/>t be lost), and <SCHEMEINLINE>env</SCHEMEINLINE> must be
    preserved around each
    <SPLITINLINE>
      <SCHEME>
	operand evaluation except the last (for use by subsequent operand evaluations).
      </SCHEME>
      <JAVASCRIPT>
	argument evaluation except the last (for use by subsequent argument evaluations).
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    Compiling this argument code is a bit tricky, because of the special
    treatment of the first
    <SPLITINLINE>
      <SCHEME>operand</SCHEME>
      <JAVASCRIPT>argument expression</JAVASCRIPT>
    </SPLITINLINE>
    to be evaluated and the need to preserve
    <SCHEMEINLINE>argl</SCHEMEINLINE> and <SCHEMEINLINE>env</SCHEMEINLINE> in
    different places. The
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>construct-arglist</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>construct_arglist</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    takes as arguments the code that evaluates the individual
    <SPLITINLINE>
      <SCHEME>operands.</SCHEME>
      <JAVASCRIPT>argument expressions.</JAVASCRIPT>
    </SPLITINLINE>
    If there are no
    <SPLITINLINE>
      <SCHEME>operands</SCHEME>
      <JAVASCRIPT>argument expressions</JAVASCRIPT>
    </SPLITINLINE>
    at all, it simply emits the instruction
    <SNIPPET EVAL="no">
      <SCHEME>
      (assign argl (const ()))
      </SCHEME>
      <JAVASCRIPT>
assign(argl, constant(null))
      </JAVASCRIPT>
    </SNIPPET>
    Otherwise,
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>construct-arglist</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>construct_arglist</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    creates code that initializes <SCHEMEINLINE>argl</SCHEMEINLINE> with the
    last argument, and appends code that evaluates the rest of the arguments and
    adjoins them to <SCHEMEINLINE>argl</SCHEMEINLINE> in succession.  In order
    to process the arguments from last to first, we must reverse the list of
    <SPLITINLINE>
      <SCHEME>operand</SCHEME>
      <JAVASCRIPT>argument</JAVASCRIPT>
    </SPLITINLINE>
    code sequences from the order supplied by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-application</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_application</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>construct_arglist</DECLARATION></INDEX>
      <NAME>construct_arglist</NAME>
      <SCHEME>
      (define (construct-arglist operand-codes)
      (let ((operand-codes (reverse operand-codes)))
      (if (null? operand-codes)
            (make-instruction-sequence '() '(argl)
            '((assign argl (const ()))))
            (let ((code-to-get-last-arg
            (append-instruction-sequences
            (car operand-codes)
            (make-instruction-sequence '(val) '(argl)
            '((assign argl (op list) (reg val)))))))
            (if (null? (cdr operand-codes))
            code-to-get-last-arg
            (preserving '(env)
            code-to-get-last-arg
            (code-to-get-rest-args
            (cdr operand-codes))))))))

      (define (code-to-get-rest-args operand-codes)
      (let ((code-for-next-arg
            (preserving '(argl)
            (car operand-codes)
            (make-instruction-sequence '(val argl) '(argl)
            '((assign argl
            (op cons) (reg val) (reg argl)))))))
      (if (null? (cdr operand-codes))
            code-for-next-arg
            (preserving '(env)
            code-for-next-arg
            (code-to-get-rest-args (cdr operand-codes))))))
      </SCHEME>
      <JAVASCRIPT>
function construct_arglist(arg_codes) {
    if (is_null(arg_codes)) {
        return make_instruction_sequence(null, list("argl"),
                   list(assign("argl", constant(null))));
    } else {
        const rev_arg_codes = reverse(arg_codes);
        const code_to_get_last_arg =
                  append_instruction_sequences(
                      head(rev_arg_codes),
                      make_instruction_sequence(list("val"), list("argl"),
                          list(assign("argl", list(op("list"),
                                                   reg("val"))))));
        return is_null(tail(rev_arg_codes))
               ? code_to_get_last_arg
               : preserving(list("env"),
                   code_to_get_last_arg,
                   code_to_get_rest_args(tail(rev_arg_codes)));
    }
}

function code_to_get_rest_args(arg_codes) {
    const code_for_next_arg =
              preserving(list("argl"),
                  head(arg_codes),
                  make_instruction_sequence(list("val", "argl"), list("argl"),
                      list(assign("argl", list(op("pair"),
                                               reg("val"), reg("argl"))))));
    return is_null(tail(arg_codes))
           ? code_for_next_arg
           : preserving(list("env"),
                        code_for_next_arg,
                        code_to_get_rest_args(tail(arg_codes)));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING> 
    <NAME>
      Applying
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    <!--  %linekludge - - discretionary hyphen in metacircular -->
    After evaluating the elements of a
    <SPLITINLINE>
      <SCHEME>combination,</SCHEME>
      <JAVASCRIPT>function application,</JAVASCRIPT>
    </SPLITINLINE>
    the compiled code must apply the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    in
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>fun</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to the arguments in
    <SCHEMEINLINE>argl</SCHEMEINLINE>.  The code performs essentially the same
    dispatch as the <SCHEMEINLINE>apply</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    in the metacircular evaluator of
    section<SPACE/><REF NAME="sec:core-of-evaluator"/> or the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    entry point in the explicit-control evaluator of
    section<SPACE/><REF NAME="sec:procedure-application"/>.  It checks whether
    the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to be applied is a primitive
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    or a compiled
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    For a primitive
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    it uses
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-primitive-procedure</SCHEMEINLINE>;</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>apply_primitive_function</JAVASCRIPTINLINE>;
      </JAVASCRIPT>
    </SPLITINLINE>
    we will see shortly how it handles compiled
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    The
    <SPLITINLINE>
      <SCHEME>procedure-application</SCHEME>
      <JAVASCRIPT>function-application</JAVASCRIPT>
    </SPLITINLINE>
    code has the following form:
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch))
      compiled-branch
      ^code to apply compiled procedure with given target and appropriate linkage^
      primitive-branch
      (assign ^target^
            (op apply-primitive-procedure)
            (reg proc)
            (reg argl))
      ^linkage^
      after-call
      </SCHEME>
      <JAVASCRIPT latex="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  test(op("primitive_function"), reg("fun")),
  branch(label("primitive_branch")),
"compiled_branch",
  <METAPHRASE>code to apply compiled function with given target and appropriate linkage</METAPHRASE>
"primitive_branch",
  assign(<META>target</META>,
         list(op("apply_primitive_function"), reg("fun"), reg("argl"))),
  <METAPHRASE>linkage</METAPHRASE>
"after_call"
      </JAVASCRIPT>
    </SNIPPET>
    Observe that the compiled branch must skip around the primitive
    branch.  Therefore, if the linkage for the original
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call was
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    the compound branch must use a
    linkage that jumps to a label that is inserted after the primitive branch.
    (This is similar to the linkage used for the true branch in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-if</SCHEMEINLINE>.)</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_conditional</JAVASCRIPTINLINE>.)</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_function_call</DECLARATION></INDEX>
      <NAME>compile_function_call</NAME>
      <SCHEME>
      (define (compile-procedure-call target linkage)
      (let ((primitive-branch (make-label 'primitive-branch))
            (compiled-branch (make-label 'compiled-branch))
            (after-call (make-label 'after-call)))
      (let ((compiled-linkage
            (if (eq? linkage 'next) after-call linkage)))
      (append-instruction-sequences
      (make-instruction-sequence '(proc) '()
            `((test (op primitive-procedure?) (reg proc))
            (branch (label ,primitive-branch))))
      (parallel-instruction-sequences
            (append-instruction-sequences
            compiled-branch
            (compile-proc-appl target compiled-linkage))
            (append-instruction-sequences
            primitive-branch
            (end-with-linkage linkage
            (make-instruction-sequence '(proc argl)
            (list target)
            `((assign ,target
            (op apply-primitive-procedure)
            (reg proc)
            (reg argl)))))))
      after-call))))
      </SCHEME>
      <JAVASCRIPT>
function compile_function_call(target, linkage) {
    const primitive_branch = make_label("primitive_branch");
    const compiled_branch = make_label("compiled_branch");
    const after_call = make_label("after_call");
    const compiled_linkage = linkage === "next" ? after_call : linkage;
    return append_instruction_sequences(
               make_instruction_sequence(list("fun"), null,
                   list(test(list(op("is_primitive_function"), reg("fun"))),
                        branch(label(primitive_branch)))),
               append_instruction_sequences(
                   parallel_instruction_sequences(
                       append_instruction_sequences(
                           compiled_branch,
                           compile_fun_appl(target, compiled_linkage)),
                       append_instruction_sequences(
                           primitive_branch,
                           end_with_linkage(linkage,
                               make_instruction_sequence(
                                   list("fun", "argl"),
                                   list(target),
                                   list(assign(target,
                                               list(op("apply_primitive_function"),
                                                    reg("fun"), reg("argl")))))))),
                   after_call));
}
      </JAVASCRIPT>
    </SNIPPET>
    The primitive and compound branches, like the true
    and false branches in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-if</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_conditional</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    are appended using
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>parallel-instruction-sequences</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>parallel_instruction_sequences</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    rather than the ordinary
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>append-instruction-sequences</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>append_instruction_sequences</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    because they will not be executed sequentially.
  </TEXT>

  <SUBHEADING> 
    <NAME>
      Applying compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    </NAME>
  </SUBHEADING>

<SPLIT>
<SCHEME>
  <TEXT>
    The code that handles
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application is the most subtle part of the compiler<SPLITINLINE><SCHEME>, even though the
    instruction sequences it generates are very short</SCHEME></SPLITINLINE>.  A compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    (as constructed by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-lambda</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_lambda_expression</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    has an entry point, which is a label that designates where the code for the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    starts.  The code at this entry point computes a result in
    <SCHEMEINLINE>val</SCHEMEINLINE> and returns by executing the instruction
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE> after
      having reverted the stack using the marker to the state expected by the label 
      in
      <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>, which was set up at the
      beginning of the function call.
      </JAVASCRIPT>
    </SPLITINLINE>
    Thus, we might expect the code for a
    <SPLITINLINE>
      <SCHEME>compiled-procedure</SCHEME>
      <JAVASCRIPT>compiled-function</JAVASCRIPT>
    </SPLITINLINE>
    application (to be generated by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-proc-appl</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_fun_appl</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    with a given target and linkage to look like this if the linkage is a
    <SPLITINLINE>
      <SCHEME>label</SCHEME>
      <JAVASCRIPT>label:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      (assign continue (label proc-return))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      proc-return
      <!--  % (assign ^target^ (reg val)) <EM>; included if target is not <SCHEMEINLINE>val</SCHEMEINLINE></EM> -->
      \aligncomment{ (assign ^target^ (reg val))}{2in}<EM>; included if target is not </EM><SCHEMEINLINE>val</SCHEMEINLINE>
      <!--  % (goto (label ^linkage^))   <EM>; linkage code</EM> -->
      \aligncomment{ (goto (label ^linkage^))}{2in}<EM>; linkage code</EM>
      </SCHEME>
      <JAVASCRIPT latex="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  assign("continue", label("fun_return")),
  save("continue"),
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"fun_return",                  // function body will end with go_to(reg("continue"))
  assign(<META>target</META>, reg("val")),  // included if target is not val
  go_to(label(<META>linkage</META>)),        // linkage code
      </JAVASCRIPT>
    </SNIPPET>
    or like this if the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return.</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      (save continue)
      (assign continue (label proc-return))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      proc-return
      <!--  % (assign ^target^ (reg val)) <EM>; included if target is not <SCHEMEINLINE>val</SCHEMEINLINE></EM> -->
      \aligncomment{ (assign ^target^ (reg val))}{2in}<EM>; included if target is not <SCHEMEINLINE>val</SCHEMEINLINE></EM>
      (restore continue)
      <!--  % (goto (reg continue))      <EM>; linkage code</EM> -->
      \aligncomment{ (goto (reg continue))}{2in}<EM>; linkage code</EM>
      </SCHEME>
      <JAVASCRIPT latex="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  assign("continue", label("fun_return")),
  save("continue"),
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),           // function body will end with go_to(reg("continue"))
"fun_return",
  assign(<META>target</META>, reg("val")),   // included if target is not val
  restore("continue"),
  go_to(reg("continue")),      // linkage code
      </JAVASCRIPT>
    </SNIPPET>
    This code sets up <SCHEMEINLINE>continue</SCHEMEINLINE> so that the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    will return to a label
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>proc-return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>fun_return</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and jumps to the
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s</SCHEME>
      <JAVASCRIPT>function<APOS/>s</JAVASCRIPT>
    </SPLITINLINE>
    entry point.  The code at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc-return</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun_return</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    transfers the
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s</SCHEME>
      <JAVASCRIPT>function<APOS/>s</JAVASCRIPT>
    </SPLITINLINE>
    result from <SCHEMEINLINE>val</SCHEMEINLINE> to the target register (if
    necessary) and then jumps to the location specified by the linkage.
    (The linkage is always
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    or a label,
    because
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-procedure-call</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compile_function_call</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    replaces a
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    linkage for the
    <SPLITINLINE>
      <SCHEME>
	compound-procedure branch by an
      <SCHEMEINLINE>after-call</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	compound-function branch by an
      <JAVASCRIPTINLINE>after_call</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    label.)
  </TEXT>
</SCHEME>
<JAVASCRIPT>

  <TEXT>
    The code that handles
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application is the most subtle part of the compiler<SPLITINLINE><SCHEME>, even though the
    instruction sequences it generates are very short</SCHEME></SPLITINLINE>.  A compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    (as constructed by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-lambda</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_lambda_expression</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    has an entry point, which is a label that designates where the code for the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    starts.  The code at this entry point computes a result in
    <SCHEMEINLINE>val</SCHEMEINLINE> and returns by executing the instruction
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE> after
      having reverted the stack using the marker to the state expected by the label 
      in
      <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>, which was set up at the
      beginning of the function call.
      </JAVASCRIPT>
    </SPLITINLINE>
</TEXT>
  <TEXT>
Calls to compiled functions are different from what we
have seen so far because the instructions for the function call
and the instructions in the body of the called function are
generated separately and are stored in different places of the
object code. Also, regardless of the number of calls to a function,
there will only be one set of instructions generated from its body
to which all calls to the function will dispatch, by jumping to
the corresponding label. Compiled functions must be applied
so that that no matter how the function returns, it will proceed
to the right continuation, with any intermediate saves to the
stack restored, and with the return value in the <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> register.
</TEXT>
  <TEXT>
The compiler generates instructions that correspond to
the behavior of the explicit-control evaluator: the function<APOS/>s
continuation is saved to the stack followed by a marker which
allows reverting the stack to the state right before the call,
with the continuation of the function on top. If the target of
a function call is not <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, 
we generate a new entry
point that assigns from <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> to the target register before jumping
to the function<APOS/>s continuation (stored in <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>), and make this
intermediate step the continuation of the function.
</TEXT>
  <TEXT>
Compiling a return statement will generate code for reverting the
stack and restoring and jumping to <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>. Because we
append a <JAVASCRIPTINLINE>return undefined;</JAVASCRIPTINLINE> to all function bodies, 
every function call eventually results in the execution of
instructions leading to a corresponding return (unless the function enters an infinite loop).<FOOTNOTE>
        Because the execution of a function body always ends with a return statement<EMDASH/>either
        a return statement written by the programmer or one
        inserted by the compiler returning <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE><EMDASH/>we
        have eliminated the need for the
        <JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE> entry point from
	section<SPACE/><REF NAME="sec:eceval"/> for compiled-function calls.
        </FOOTNOTE>
</TEXT>
  <TEXT>
In summary, the code for applying a compiled function has the following form
    <SNIPPET EVAL="no" LATEX="yes">
      <JAVASCRIPT>
save("continue"),
push_marker_to_stack(),
<METAPHRASE>lookup the function's entry point and jump to it</METAPHRASE>
      </JAVASCRIPT>
    </SNIPPET>

and the code for returning from a compiled function (due to a return statement) has the following form
    <SNIPPET EVAL="no" LATEX="yes">
      <JAVASCRIPT>
revert_stack_to_marker(),
restore("continue"),
<METAPHRASE>compute the return value</METAPHRASE>
go_to(reg("continue"))
      </JAVASCRIPT>
    </SNIPPET>
</TEXT>

<TEXT>
    Thus, we might expect the code for a
    <SPLITINLINE>
      <SCHEME>compiled-procedure</SCHEME>
      <JAVASCRIPT>compiled-function</JAVASCRIPT>
    </SPLITINLINE>
    application (to be generated by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-proc-appl</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_fun_appl</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    with a given target and linkage to look like this if the linkage is a
    <SPLITINLINE>
      <SCHEME>label</SCHEME>
      <JAVASCRIPT>label:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      (assign continue (label proc-return))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      proc-return
      <!--  % (assign ^target^ (reg val)) <EM>; included if target is not <SCHEMEINLINE>val</SCHEMEINLINE></EM> -->
      \aligncomment{ (assign ^target^ (reg val))}{2in}<EM>; included if target is not </EM><SCHEMEINLINE>val</SCHEMEINLINE>
      <!--  % (goto (label ^linkage^))   <EM>; linkage code</EM> -->
      \aligncomment{ (goto (label ^linkage^))}{2in}<EM>; linkage code</EM>
      </SCHEME>
      <JAVASCRIPT latex="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  assign("continue", label("fun_return")),
  save("continue"),
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),           // function body will end with go_to(reg("continue"))
"fun_return",                  
  assign(<META>target</META>, reg("val")),   // included if target is not val
  go_to(label(<META>linkage</META>)),        // linkage code
      </JAVASCRIPT>
    </SNIPPET>
    or like this if the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return.</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>:
      </JAVASCRIPT>
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      (save continue)
      (assign continue (label proc-return))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      proc-return
      <!--  % (assign ^target^ (reg val)) <EM>; included if target is not <SCHEMEINLINE>val</SCHEMEINLINE></EM> -->
      \aligncomment{ (assign ^target^ (reg val))}{2in}<EM>; included if target is not <SCHEMEINLINE>val</SCHEMEINLINE></EM>
      (restore continue)
      <!--  % (goto (reg continue))      <EM>; linkage code</EM> -->
      \aligncomment{ (goto (reg continue))}{2in}<EM>; linkage code</EM>
      </SCHEME>
      <JAVASCRIPT latex="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  save("continue"),
  assign("continue", label("fun_return")),
  save("continue"),
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),           // function body will end with go_to(reg("continue"))
"fun_return",
  assign(<META>target</META>, reg("val")),   // included if target is not val
  restore("continue"),
  go_to(reg("continue")),      // linkage code
      </JAVASCRIPT>
    </SNIPPET>
    This code sets up <SCHEMEINLINE>continue</SCHEMEINLINE> so that the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    will return to a label
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>proc-return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>fun_return</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and jumps to the
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s</SCHEME>
      <JAVASCRIPT>function<APOS/>s</JAVASCRIPT>
    </SPLITINLINE>
    entry point.  The code at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc-return</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun_return</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    transfers the
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s</SCHEME>
      <JAVASCRIPT>function<APOS/>s</JAVASCRIPT>
    </SPLITINLINE>
    result from <SCHEMEINLINE>val</SCHEMEINLINE> to the target register (if
    necessary) and then jumps to the location specified by the linkage.
    (The linkage is always
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    or a label,
    because
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-procedure-call</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compile_function_call</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    replaces a
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    linkage for the
    <SPLITINLINE>
      <SCHEME>
	compound-procedure branch by an
      <SCHEMEINLINE>after-call</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	compound-function branch by an
      <JAVASCRIPTINLINE>after_call</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    label.)
    <SPLIT>
      <JAVASCRIPT>
        Before looking up the function entry point and jumping to it, we 
        save <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> and
        call <JAVASCRIPTINLINE>push_marker_to_stack()</JAVASCRIPTINLINE> to enable 
        the function to return to the intended location in the program with the expected stack. The
        corresponding
        <JAVASCRIPTINLINE>revert_stack_to_mark()</JAVASCRIPTINLINE> and
        restoring of <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> are 
        generated by <JAVASCRIPTINLINE>compile_return_statement</JAVASCRIPTINLINE> for each return statement in the body of the
        function. As compiling a function call does not involve compilation of the called function 
        we must generate the
        <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> and <JAVASCRIPTINLINE>restore</JAVASCRIPTINLINE> of 
        <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> explicitly, and cannot rely on
        a mechanism such as
	      <JAVASCRIPTINLINE>preserving</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>
</JAVASCRIPT>
</SPLIT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>In fact, if</SCHEME>
      <JAVASCRIPT>If</JAVASCRIPT>
    </SPLITINLINE>
    the target is not <SCHEMEINLINE>val</SCHEMEINLINE>,
    <SPLITINLINE><SCHEME>that is</SCHEME><JAVASCRIPT>the above is</JAVASCRIPT></SPLITINLINE>
    exactly the code our compiler will generate.<FOOTNOTE>Actually, we signal
    an error when the target is not <SCHEMEINLINE>val</SCHEMEINLINE> and the
    linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    since the only place we request
    <SPLITINLINE>
      <SCHEME>
	      <SCHEMEINLINE>return</SCHEMEINLINE>linkages 
      </SCHEME>
      <JAVASCRIPT>
        a <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE> linkage
      </JAVASCRIPT>
    </SPLITINLINE>
    is in compiling
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <JAVASCRIPT>return expressions,</JAVASCRIPT>
    </SPLITINLINE>
    and our convention is that
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    return their values in <SCHEMEINLINE>val</SCHEMEINLINE>.</FOOTNOTE>
    Usually, however, the target is <SCHEMEINLINE>val</SCHEMEINLINE> (the only
    time the compiler specifies a different register is when targeting the
    evaluation of
    <SPLITINLINE>
      <SCHEME>an operator</SCHEME>
      <JAVASCRIPT>a function expression</JAVASCRIPT>
    </SPLITINLINE>
    to
    <SPLITINLINE>
      <SCHEME>
    <SCHEMEINLINE>proc</SCHEMEINLINE>),
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>fun</SCHEMEINLINE>),
      </JAVASCRIPT>
    </SPLITINLINE>
    so the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    result is put directly into
    the target register and there is no need to
    <SPLITINLINE>
      <SCHEME>return</SCHEME>
      <JAVASCRIPT>jump</JAVASCRIPT>
    </SPLITINLINE>
    to a special
    location that copies it. Instead we simplify the code by
    setting up <SCHEMEINLINE>continue</SCHEMEINLINE> so that the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    will
    <SPLITINLINE>
      <SCHEME><QUOTE>return</QUOTE></SCHEME>
      <JAVASCRIPT>jump</JAVASCRIPT>
    </SPLITINLINE>
    directly to the place specified by the caller<APOS/>s linkage:
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      ^set up^ continue ^for linkage^
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>set up <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> for linkage and push the marker</METAPHRASE>
assign("val", list(op("compiled_function_entry"), reg("fun"))),
go_to(reg("val")),
      </JAVASCRIPT>
    </SNIPPET>
    If the linkage is a label, we set up <SCHEMEINLINE>continue</SCHEMEINLINE>
    so that the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    will <SPLITINLINE><SCHEME>return to</SCHEME><JAVASCRIPT>continue at</JAVASCRIPT></SPLITINLINE>
    that label.  (That is, the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    ends with becomes equivalent to the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (label ^linkage^))</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>go_to(label(</JAVASCRIPTINLINE><META>linkage</META><JAVASCRIPTINLINE>))</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc-return</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun_return</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    above.)
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      (assign continue (label ^linkage^))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      </SCHEME>
      <JAVASCRIPT>
assign("continue", label(<META>linkage</META>)),
save("continue"),
push_marker_to_stack(),
assign("val", list(op("compiled_function_entry"), reg("fun"))),
go_to(reg("val")),
      </JAVASCRIPT>
    </SNIPPET>
    If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    we don<APOS/>t need to 
<SPLITINLINE>
<SCHEME>
    set up <SCHEMEINLINE>continue</SCHEMEINLINE> at all:
</SCHEME>
<JAVASCRIPT>
    assign <SCHEMEINLINE>continue</SCHEMEINLINE>:
</JAVASCRIPT>
</SPLITINLINE>
    It already holds the desired location.
    (That is, the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    ends with goes directly to the
    place where the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc-return</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun_return</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    would have gone.)
    <SPLITINLINE><JAVASCRIPT>In this case, it suffices to save the 
<JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> register and push a
marker to the stack.</JAVASCRIPT></SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      </SCHEME>
      <JAVASCRIPT>
save("continue"),
push_marker_to_stack(),
assign("val", list(op("compiled_function_entry"), reg("fun"))),
go_to(reg("val")),
      </JAVASCRIPT>
    </SNIPPET>
    With this implementation of the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    linkage,
    the compiler generates
    <INDEX>compiler for JavaScript<SUBINDEX>tail-recursive code generated by</SUBINDEX></INDEX>
    <INDEX>tail recursion<SUBINDEX>compiler and</SUBINDEX></INDEX>
    tail-recursive code.
    <SPLITINLINE>
      <SCHEME>Calling a procedure</SCHEME>
      <JAVASCRIPT>A function call</JAVASCRIPT>
    </SPLITINLINE>
    as the
    <SPLITINLINE>
      <SCHEME>final step in a procedure</SCHEME>
      <JAVASCRIPT>return expression in a function</JAVASCRIPT>
    </SPLITINLINE>
    body does a direct transfer, without saving any information on the stack.
    <SPLITINLINE>
      <JAVASCRIPT>
        As in the explicit-control evaluator, an explicit return is needed for tail
        recursion. Due to our simple compile-time transformation of function bodies, a
        function call outside of a return statement at the end of
        a function body will no longer be the body<APOS/>s last statement, as a
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE>
        <JAVASCRIPTINLINE>undefined;</JAVASCRIPTINLINE> has been added
	after it<EMDASH/>a deferred operation invisible in the program<APOS/>s source.
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    Suppose instead that we had handled the case of a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call with a
    linkage of <SPLITINLINE><SCHEME>return</SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and a target of
    <SCHEMEINLINE>val</SCHEMEINLINE> in the same way as for a
    non-<SCHEMEINLINE>val</SCHEMEINLINE> target. This would destroy tail
    recursion. Our system would still give the same value for any
    <SPLITINLINE>
      <SCHEME>
	expression.
      </SCHEME>
      <JAVASCRIPT>
	component.
      </JAVASCRIPT>
    </SPLITINLINE>
    But each time we called a
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    we would save
    <SCHEMEINLINE>continue</SCHEMEINLINE> 
    <SPLITINLINE>
      <SCHEME>and return after the call to undo the (useless) save. These extra </SCHEME>
      <JAVASCRIPT>
        twice<EMDASH/>the final continuation of the function plus the intermediate <JAVASCRIPTINLINE>fun_return</JAVASCRIPTINLINE> entry point that assigns <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> to the appropriate target register before jumping to <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>.
        As a return statement would only restore the last of these saves before computing the return value, these
      </JAVASCRIPT>
    </SPLITINLINE>
    saves would accumulate during a nest of
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    calls.<FOOTNOTE>Making a
    <INDEX>compiler<SUBINDEX>tail recursion, stack allocation, and garbage-collection</SUBINDEX></INDEX>
    compiler generate tail-recursive
    <SPLITINLINE>
      <SCHEME>
        code might seem like a straightforward idea.  But
      </SCHEME>
      <JAVASCRIPT>
        code is desirable, especially in the functional paradigm.
      </JAVASCRIPT>
    </SPLITINLINE>
    However, compilers for common languages,
    including
    <SPLITINLINE>
      <SCHEME>C and Pascal,</SCHEME>
      <JAVASCRIPT>C and C++,</JAVASCRIPT>
    </SPLITINLINE>
    do not always do this, and therefore these languages
    cannot represent iterative processes in terms of
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call alone. The difficulty with
    <INDEX>tail recursion<SUBINDEX>garbage collection and</SUBINDEX></INDEX>
    <INDEX>garbage collection<SUBINDEX>tail recursion and</SUBINDEX></INDEX>
    <INDEX>stack allocation and tail recursion</INDEX>
    tail recursion in these languages is that their
    implementations use the stack to store
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    arguments and local
    <SPLITINLINE>
      <SCHEME>variables</SCHEME>
      <JAVASCRIPT>names</JAVASCRIPT>
    </SPLITINLINE>
    as well as return addresses.  The
    <SPLITINLINE>
      <SCHEME>
	Scheme
      </SCHEME>
      <JAVASCRIPT>
	JavaScript
      </JAVASCRIPT>
    </SPLITINLINE>
    implementations described in this book store arguments and
    <SPLITINLINE>
      <SCHEME>variables</SCHEME>
      <JAVASCRIPT>names</JAVASCRIPT>
    </SPLITINLINE>
    in memory to be garbage-collected.  The reason for using the stack for
    <SPLITINLINE>
      <SCHEME>variables</SCHEME>
      <JAVASCRIPT>names</JAVASCRIPT>
    </SPLITINLINE>
    and arguments is that it avoids the need for garbage collection
    in languages that would not otherwise require it, and is generally
    believed to be more efficient.  Sophisticated
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
    </SPLITINLINE>
    compilers can, in fact, use the stack for arguments without destroying tail
    recursion. (See
    <INDEX>Hanson, Christopher P.</INDEX>
    <CITATION>Hanson 1990</CITATION> for a description.)  There is also some
    debate about whether stack allocation is actually more efficient than garbage
    collection in the first place, but the details seem to hinge on fine
    points of computer architecture.  (See
    <INDEX>Appel, Andrew W.</INDEX>
    <CITATION>Appel 1987</CITATION> and
    <INDEX>Miller, James S.</INDEX>
    <INDEX>Rozas, Guillermo Juan</INDEX>
    <CITATION>Miller and Rozas 1994</CITATION>
    for opposing views on this issue.)</FOOTNOTE>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Compile-proc-appl</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>compile_fun_appl</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    generates the above
    <SPLITINLINE>
      <SCHEME>procedure-application</SCHEME>
      <JAVASCRIPT>function-application</JAVASCRIPT>
    </SPLITINLINE>
    code by considering four cases,
    depending on whether the target for the call
    is <SCHEMEINLINE>val</SCHEMEINLINE> and whether the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Observe that the instruction sequences
    are declared to modify all the registers, since executing the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body can change the registers in arbitrary ways.<FOOTNOTE>The
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>constant</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>compiler for JavaScript<SUBINDEX>register use</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>all-regs</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>all_regs</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is bound to the list of names of all the registers:
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>all_regs</DECLARATION> (compiler)</INDEX>
      <NAME>all_regs</NAME>
      <SCHEME>
        (define all-regs '(env proc val argl continue))
      </SCHEME>
      <JAVASCRIPT>
const all_regs = list("env", "fun", "val", "argl", "continue");
      </JAVASCRIPT>
    </SNIPPET></FOOTNOTE>
    <SPLIT>
      <SCHEME>
	Also note that the code sequence for the case with target
	<SCHEMEINLINE>val</SCHEMEINLINE> and linkage
	<SCHEMEINLINE>return</SCHEMEINLINE>
	is declared to need
	<SCHEMEINLINE>continue</SCHEMEINLINE>:  Even though
	<SCHEMEINLINE>continue</SCHEMEINLINE> is not explicitly used in the
	two-instruction sequence, we must be sure that
	<SCHEMEINLINE>continue</SCHEMEINLINE> will have the correct
	value when we enter the compiled procedure.
      </SCHEME>
    </SPLIT>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_fun_appl</DECLARATION></INDEX>
      <NAME>compile_fun_appl</NAME>
      <SCHEME>
      (define (compile-proc-appl target linkage)
      (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
            (make-instruction-sequence '(proc) all-regs
            `((assign continue (label ,linkage))
            (assign val (op compiled-procedure-entry)
            (reg proc))
            (goto (reg val)))))
            ((and (not (eq? target 'val))
            (not (eq? linkage 'return)))
            (let ((proc-return (make-label 'proc-return)))
            (make-instruction-sequence '(proc) all-regs
            `((assign continue (label ,proc-return))
            (assign val (op compiled-procedure-entry)
            (reg proc))
            (goto (reg val))
            ,proc-return
            (assign ,target (reg val))
            (goto (label ,linkage))))))
            ((and (eq? target 'val) (eq? linkage 'return))
            (make-instruction-sequence '(proc continue) all-regs
            '((assign val (op compiled-procedure-entry)
            (reg proc))
            (goto (reg val)))))
            ((and (not (eq? target 'val)) (eq? linkage 'return))
            (error "return linkage, target not val - - COMPILE"
            target))))
      </SCHEME>
      <JAVASCRIPT>
function compile_fun_appl(target, linkage) {
    const fun_return = make_label("fun_return");
    return target === "val" &amp;&amp; linkage !== "return"
           ? make_instruction_sequence(list("fun"), all_regs,
                 list(assign("continue", label(linkage)),
                      save("continue"),
                      push_marker_to_stack(),
                      assign("val", list(op("compiled_function_entry"), reg("fun"))),
                      go_to(reg("val"))))
           : target !== "val" &amp;&amp; linkage !== "return"
           ? make_instruction_sequence(list("fun"), all_regs,
                 list(assign("continue", label(fun_return)),
                      save("continue"),
                      push_marker_to_stack(),
                      assign("val", list(op("compiled_function_entry"), reg("fun"))),
                      go_to(reg("val")),
                      fun_return,
                      assign(target, reg("val")),
                      go_to(label(linkage))))
           : target === "val" &amp;&amp; linkage === "return"
           ? make_instruction_sequence(list("fun", "continue"), all_regs,
                 list(save("continue"),
                      push_marker_to_stack(),
                      assign("val", list(op("compiled_function_entry"), reg("fun"))),
                      go_to(reg("val"))))
           : // target !== "val" &amp;&amp; linkage === "return"
             error(target, "return linkage, target not val -- compile");
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <INDEX>compiler for JavaScript<SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE> applications<CLOSE/></SUBINDEX></INDEX>
  <INDEX>compiler for JavaScript<SUBINDEX>combinations<CLOSE/></SUBINDEX></INDEX>
  
  <SPLIT>
    <JAVASCRIPT>
      <SUBHEADING>
	<NAME> 
	  Compiling return statements
        </NAME>
      </SUBHEADING>
      <TEXT>
        The code for a
        <INDEX>compiler for JavaScript<SUBINDEX>return statements</SUBINDEX></INDEX>
	return statement takes the following form, regardless of the given linkage and target:
        <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
revert_stack_to_marker(),
restore("continue"), // saved by compile_fun_appl
<METAPHRASE>evaluate the return expression and store the result in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE></METAPHRASE>
go_to(reg("continue"))
          </JAVASCRIPT>
        </SNIPPET>
        The reverting of the stack using the marker and the subsequent restoring
        of <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> correspond to the
        instructions generated by <JAVASCRIPTINLINE>compile_fun_appl</JAVASCRIPTINLINE>
        to save <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> and mark the stack.
        The final jump to <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> is
        generated by the use of the <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
        linkage when compiling the return expression.
        The function <JAVASCRIPTINLINE>compile_return_statement</JAVASCRIPTINLINE>
        is different from all other code generators in that it ignores the target 
        and linkage arguments<EMDASH/>it always compiles the return expression with
        target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> and linkage 
        <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>.
         <SNIPPET EVAL="no">
          <INDEX><DECLARATION>compile_return_statement</DECLARATION></INDEX>
           <NAME>compile_return</NAME>
           <JAVASCRIPT>
function compile_return_statement(stmt, target, linkage) {
    return append_instruction_sequences(
               make_instruction_sequence(null, list("continue"),
                   list(revert_stack_to_marker(),
                        restore("continue"))),
               compile(return_expression(stmt), "val", "return"));
}
	   </JAVASCRIPT>
	 </SNIPPET>
       </TEXT>
     </JAVASCRIPT>
   </SPLIT>
</SUBSECTION>
