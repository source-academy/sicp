<SUBSECTION> 
  <NAME>
    Mutable List Structure
  </NAME>

  <LABEL NAME="sec:mutable-list-structure"/>
  <INDEX>mutable data objects<SUBINDEX>list structure<OPEN/></SUBINDEX></INDEX>
  <INDEX>list structure<SUBINDEX>mutable<OPEN/></SUBINDEX></INDEX>
  <INDEX>mutable data objects<SUBINDEX>pairs<OPEN/></SUBINDEX></INDEX>
  <INDEX>pair(s)<SUBINDEX>mutable<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    The basic operations on
    <SPLITINLINE>
      <SCHEME>
	pairs<EMDASH/><SCHEMEINLINE>cons</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	pairs<EMDASH/><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE><EMDASH/>can</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE><EMDASH/>can
      </JAVASCRIPT>
    </SPLITINLINE>
    be used to construct list structure and to select parts
    from list structure, but they are incapable of modifying list
    structure.  The same is true of the list operations we have used so
    far, such as <SCHEMEINLINE>append</SCHEMEINLINE> and
    <SCHEMEINLINE>list</SCHEMEINLINE>, since these can be defined in terms of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    To modify list structures we need new operations.
    <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE src="img_original/ch3-Z-G-13.svg"></FIGURE>
          <CAPTION>
	    Lists <SCHEMEINLINE>x</SCHEMEINLINE>:
	    <SCHEMEINLINE>((a b) c d)</SCHEMEINLINE> and
	    <SCHEMEINLINE>y</SCHEMEINLINE>: <SCHEMEINLINE>(e f)</SCHEMEINLINE>.
          </CAPTION>
          <LABEL NAME="fig:two-lists_scheme"/>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE src="img_javascript/ch3-Z-G-13.svg"></FIGURE>
          <CAPTION>
	    Lists <SCHEMEINLINE>x</SCHEMEINLINE>:
	    <JAVASCRIPTINLINE>list(list("a", "b"), "c", "d")</JAVASCRIPTINLINE>
	    and <SCHEMEINLINE>y</SCHEMEINLINE>:
	    <JAVASCRIPTINLINE>list("e", "f")</JAVASCRIPTINLINE>.
          </CAPTION>
          <LABEL NAME="fig:two-lists"/>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
    <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE src="img_original/ch3-Z-G-14.svg"></FIGURE>
          <CAPTION>
	    Effect of <SCHEMEINLINE>(set-car! x y)</SCHEMEINLINE> on the lists
	    in figure<SPACE/><REF NAME="fig:two-lists_scheme"/>.
          </CAPTION>
          <LABEL NAME="fig:set-car_scheme"/>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE src="img_javascript/ch3-Z-G-14.svg"></FIGURE>
          <CAPTION>
	    Effect of <JAVASCRIPTINLINE>set_head(x, y)</JAVASCRIPTINLINE> on
	    the lists in figure<SPACE/><REF NAME="fig:two-lists"/>.
          </CAPTION>
          <LABEL NAME="fig:set-car"/>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
    <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE src="img_original/ch3-Z-G-15.svg"></FIGURE>
          <CAPTION>
	    Effect of <SCHEMEINLINE>(define z (cons y (cdr x)))</SCHEMEINLINE>
	    on the lists in figure<SPACE/><REF NAME="fig:two-lists_scheme"/>.
          </CAPTION>
          <LABEL NAME="fig:list-cons_scheme"/>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE src="img_javascript/ch3-Z-G-15.svg"></FIGURE>
          <CAPTION>
	    Effect of
	    <JAVASCRIPTINLINE>const z = pair(y, tail(x));</JAVASCRIPTINLINE>
	    on the lists in figure<SPACE/><REF NAME="fig:two-lists"/>.
          </CAPTION>
          <LABEL NAME="fig:list-cons"/>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
    <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE src="img_original/ch3-Z-G-16.svg"></FIGURE>
          <CAPTION>
	    Effect of <SCHEMEINLINE>(set-cdr! x y)</SCHEMEINLINE> on the lists
	    in figure<SPACE/><REF NAME="fig:two-lists_scheme"/>.
	  </CAPTION>
          <LABEL NAME="fig:set-cdr_scheme"/>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE src="img_javascript/ch3-Z-G-16.svg"></FIGURE>
          <CAPTION>
	    Effect of <JAVASCRIPTINLINE>set_tail(x, y)</JAVASCRIPTINLINE> on the
	    lists in figure<SPACE/><REF NAME="fig:two-lists"/>.
	  </CAPTION>
          <LABEL NAME="fig:set-cdr"/>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    The primitive mutators for pairs are
    <INDEX><DECLARATION>set_head</DECLARATION> (primitive function)</INDEX>
    <INDEX><PRIMITIVE/><SUBINDEX><DECLARATION>set_head</DECLARATION> (\textit{ns})</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <INDEX><DECLARATION>set_tail</DECLARATION> (primitive function)</INDEX>
    <INDEX><PRIMITIVE/><SUBINDEX><DECLARATION>set_tail</DECLARATION> (\textit{ns})</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    takes two arguments, the first of which must be a pair.  It modifies this
    pair, replacing the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer by a pointer to the second argument of
    <SPLITINLINE><SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.<FOOTNOTE>
    <SPLIT>
      <SCHEME>
	<SCHEMEINLINE>Set-car!</SCHEMEINLINE> and
	<SCHEMEINLINE>set-cdr!</SCHEMEINLINE> return
	implementation-dependent
	<INDEX><USE>set-car!</USE> (primitive function)<SUBINDEX>value of</SUBINDEX></INDEX>
	<INDEX>unspecified values<SUBINDEX><ORDER>set-car</ORDER><SCHEMEINLINE>set-car!</SCHEMEINLINE></SUBINDEX></INDEX>
	<INDEX><USE>set-cdr!</USE> (primitive function)<SUBINDEX>value of</SUBINDEX></INDEX>
	<INDEX>unspecified values<SUBINDEX><ORDER>set-cdr</ORDER><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SUBINDEX></INDEX>
	values.  Like <SCHEMEINLINE>set!</SCHEMEINLINE>, they should be used
	only for their effect.
      </SCHEME>
      <JAVASCRIPT>
	The functions <JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE> and
	<JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE> return the value
	<JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>.
	<INDEX><USE>set_head</USE> (primitive function)<SUBINDEX>value of</SUBINDEX></INDEX>
	<INDEX><USE>set_tail</USE> (primitive function)<SUBINDEX>value of</SUBINDEX></INDEX>
	Like assignment, they should be used only for their effect.
      </JAVASCRIPT>
    </SPLIT></FOOTNOTE>
  </TEXT>

  <TEXT>
    As an example, suppose that <SCHEMEINLINE>x</SCHEMEINLINE> is bound to the
    list
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>((a b) c d)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>list(list("a", "b"), "c", "d")</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and <SCHEMEINLINE>y</SCHEMEINLINE> to the list
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(e f)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list("e", "f")</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    as illustrated in
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE/><REF NAME="fig:two-lists_scheme"/>.
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE/><REF NAME="fig:two-lists"/>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Evaluating the expression
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(set-car! x y)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>set_head(x, y)</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    modifies the pair to which <SCHEMEINLINE>x</SCHEMEINLINE> is bound,
    replacing its
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    by the value of <SCHEMEINLINE>y</SCHEMEINLINE>.  The result of the operation
    is shown in
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE/><REF NAME="fig:set-car_scheme"/>.
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE/><REF NAME="fig:set-car"/>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The structure <SCHEMEINLINE>x</SCHEMEINLINE> has been modified and would
    now be equivalent to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>((e<SPACE/>f)<SPACE/>c<SPACE/>d)</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>list(list("e", "f"), "c", "d")</JAVASCRIPTINLINE>.
    </JAVASCRIPT></SPLITINLINE>
    The pairs representing the list
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(a b)</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list("a", "b")</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    identified by the pointer that was replaced, are now detached from the
    original structure.<FOOTNOTE>We see from this that mutation operations on
    lists can create <QUOTE>garbage</QUOTE> that is not part of any accessible
    structure. We will see in section<SPACE/><REF NAME="sec:gc"/> that
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    memory-management systems include a 
    <INDEX>garbage collection<SUBINDEX>mutation and</SUBINDEX></INDEX>
    <EM>garbage collector</EM>, which identifies and recycles the memory
    space used by unneeded pairs.</FOOTNOTE>
  </TEXT>

  <TEXT>
    Compare
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE/><REF NAME="fig:set-car_scheme"/>
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE/><REF NAME="fig:set-car"/>
      </JAVASCRIPT>
    </SPLITINLINE>
    with
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE/><REF NAME="fig:list-cons_scheme"/>,
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE/><REF NAME="fig:list-cons"/>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which illustrates the result of executing
    <SNIPPET HIDE="yes">
      <NAME>mutable_list_example</NAME>
      <SCHEME>
(define x '((a b) c d))
(define y '(e f))
      </SCHEME>
      <JAVASCRIPT>
const x = list(list("a", "b"), "c");
const y = list("e", "f");
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <REQUIRES>mutable_list_example</REQUIRES>
      <SCHEME>
(define z (cons y (cdr x)))
      </SCHEME>
      <JAVASCRIPT>
const z = pair(y, tail(x));
      </JAVASCRIPT>
    </SNIPPET>
    with <SCHEMEINLINE>x</SCHEMEINLINE> and <SCHEMEINLINE>y</SCHEMEINLINE>
    bound to the original lists of
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE/><REF NAME="fig:two-lists_scheme"/>.
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE/><REF NAME="fig:two-lists"/>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The
    <SPLITINLINE>
      <SCHEME>
	variable
      </SCHEME>
      <JAVASCRIPT>
	name
      </JAVASCRIPT>
    </SPLITINLINE>
      <SCHEMEINLINE>z</SCHEMEINLINE> is now bound to a
    new pair created by the
    <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operation; the list to which <SCHEMEINLINE>x</SCHEMEINLINE> is bound is
    unchanged.
  </TEXT>

  <TEXT>
    The
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operation is similar to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    The only difference is that the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer of the pair, rather than the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer, is replaced.  The effect of executing
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(set-cdr! x y)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail(x, y)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    on the lists of
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE/><REF NAME="fig:two-lists_scheme"/>
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE/><REF NAME="fig:two-lists"/>
      </JAVASCRIPT>
    </SPLITINLINE>
    is shown in
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE/><REF NAME="fig:set-cdr_scheme"/>.
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE/><REF NAME="fig:set-cdr"/>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Here the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer of
    <SCHEMEINLINE>x</SCHEMEINLINE> has been replaced by the pointer to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(e f)</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list("e", "f")</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Also, the list
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(c d)</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list("c", "d")</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which used to be the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of <SCHEMEINLINE>x</SCHEMEINLINE>, is now detached from the structure.
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    builds new list structure by creating new pairs, while
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    modify existing pairs.
    Indeed, we could
    <INDEX><USE>pair</USE> (primitive function)<SUBINDEX>implemented with mutators</SUBINDEX></INDEX>
    implement
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in terms of the two mutators, together with a
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-new-pair</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_new_pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    which returns a new pair that is not part of any existing list structure.
    We obtain the new pair, set its
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointers to the designated objects, and return the new pair as the result of
    the
    <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.<FOOTNOTE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Get-new-pair</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>get_new_pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is one of the operations that must be implemented as part of the memory
    management required by a
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    implementation. We will discuss this in
    section<SPACE/><REF NAME="sec:memory-as-vectors"/>.
  </FOOTNOTE>

  <SNIPPET HIDE="yes">
    <NAME>get_new_pair</NAME>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
// The book proposes a primitive function get_new_pair.
// Since JavaScript does not provide such a function, let's
// define it as follows, for the sake of the example.

function get_new_pair() {
    return pair(undefined, undefined);
}
    </JAVASCRIPT>
  </SNIPPET>
  <SNIPPET>
    <INDEX><DECLARATION>pair</DECLARATION> (primitive function)<SUBINDEX>implemented with mutators</SUBINDEX></INDEX>
    <REQUIRES>get_new_pair</REQUIRES>
    <EXAMPLE>mutable_pair_example</EXAMPLE>
    <EXPECTED>[ [ 1, 2 ], 4 ]</EXPECTED>
    <SCHEME>
(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
    </SCHEME>
    <JAVASCRIPT>
function pair(x, y) {
    const fresh = get_new_pair();
    set_head(fresh, x);
    set_tail(fresh, y);
    return fresh;
}
    </JAVASCRIPT>
    <JAVASCRIPT_RUN>
{
    function pair(x, y) {
        const fresh = get_new_pair();
        set_head(fresh, x);
        set_tail(fresh, y);
        return fresh;
    }

  </JAVASCRIPT_RUN>
  </SNIPPET>

  <SNIPPET HIDE="yes">
    <NAME>mutable_pair_example</NAME>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
pair(pair(1, 2), 4);	    
    </JAVASCRIPT>
    <JAVASCRIPT_RUN>
    //
    pair(pair(1, 2), 4);	    
}
    </JAVASCRIPT_RUN>
  </SNIPPET>
  </TEXT>

  <EXERCISE>
    <LABEL NAME="ex:append"/>
    The following
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for appending lists was introduced in
    section<SPACE/><REF NAME="sec:sequences"/>:
    <SNIPPET HIDE="yes">
      <NAME>append_example3</NAME>
      <EXPECTED>9</EXPECTED>
      <JAVASCRIPT>
append(list(1, 3), list(5, 7, 9));	
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
list_ref(append(list(1, 3), list(5, 7, 9)), 4);	
      </JAVASCRIPT_TEST>
    </SNIPPET>
    <INDEX><DECLARATION>append</DECLARATION></INDEX> 
    <SNIPPET EVAL="yes">
      <NAME>append2</NAME>
      <EXAMPLE>append_example3</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      <SCHEME>
(define (append x y)
  (if (null? x)
    y
    (cons (car x) (append (cdr x) y))))
      </SCHEME>
      <JAVASCRIPT>
function append(x, y) {
    return is_null(x)
           ? y
           : pair(head(x), append(tail(x), y));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Append</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>append</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    forms a new list by successively
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>cons</SCHEMEINLINE>ing
	the elements of <SCHEMEINLINE>x</SCHEMEINLINE> onto
	<SCHEMEINLINE>y</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	applying <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
	to the elements of <SCHEMEINLINE>x</SCHEMEINLINE> and
	the results of the recursive calls, starting with
	<JAVASCRIPTINLINE>y</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>append</USE><SUBINDEX><ORDER>append mutator</ORDER><LATEXINLINE>append_mutator</LATEXINLINE> vs.</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>append!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>append_mutator</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is similar to <SCHEMEINLINE>append</SCHEMEINLINE>, but it is a mutator
    rather than a constructor. It appends the lists by splicing them together,
    modifying the final pair of <SCHEMEINLINE>x</SCHEMEINLINE> so that its
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is now <SCHEMEINLINE>y</SCHEMEINLINE>. (It is an error to call
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>append!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>append_mutator</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    with an empty<SPACE/><SCHEMEINLINE>x</SCHEMEINLINE>.)
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>append_mutator</DECLARATION><FRAGILE/></INDEX> 
      <NAME>append_mutator</NAME>
      <REQUIRES>last_pair</REQUIRES>
      <SCHEME>
(define (append! x y)
  (set-cdr! (last-pair x) y)
            x)
      </SCHEME>
      <JAVASCRIPT>
function append_mutator(x, y) {
    set_tail(last_pair(x), y);
    return x;
}
      </JAVASCRIPT>
    </SNIPPET>
    Here
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>last-pair</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>last_pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that returns the last pair in its argument:
    <SNIPPET HIDE="yes">
      <NAME>last_pair_example_2</NAME>
      <JAVASCRIPT>
last_pair(list(1,2,3,4,5));
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>last_pair</DECLARATION><FRAGILE/></INDEX> 
      <NAME>last_pair</NAME>
      <EXAMPLE>last_pair_example_2</EXAMPLE>
      <EXPECTED>[ 5, null ]</EXPECTED>
      <SCHEME>
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
      </SCHEME>
      <JAVASCRIPT>
function last_pair(x) {
    return is_null(tail(x))
           ? x
           : last_pair(tail(x));
}
      </JAVASCRIPT>
    </SNIPPET>
    Consider the interaction
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_1</NAME>
      <REQUIRES>append2</REQUIRES>
      <REQUIRES>append_mutator</REQUIRES>
      <SCHEME>
(define x (list 'a 'b))
      </SCHEME>
      <JAVASCRIPT>
const x = list("a", "b");
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_2</NAME>
      <REQUIRES>append_interaction_1</REQUIRES>
      <SCHEME>
(define y (list 'c 'd))
      </SCHEME>
      <JAVASCRIPT>
const y = list("c", "d");
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_3</NAME>
      <REQUIRES>append_interaction_2</REQUIRES>
      <SCHEME>
(define z (append x y))
      </SCHEME>
      <JAVASCRIPT>
const z = append(x, y);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_4</NAME>
      <REQUIRES>append_interaction_3</REQUIRES>
      <SCHEME>
z
      </SCHEME>
      <SCHEMEOUTPUT>
(a b c d)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
z;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
["a", ["b", ["c", ["d, null]]]]	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_5</NAME>
      <REQUIRES>append_interaction_4</REQUIRES>
      <SCHEME>
(cdr x)
      </SCHEME>
      <SCHEMEOUTPUT>
&lt;response&gt;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
tail(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
<META>response</META>
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_6</NAME>
      <REQUIRES>append_interaction_5</REQUIRES>
      <SCHEME>
(define w (append! x y))
      </SCHEME>
      <JAVASCRIPT>
const w = append_mutator(x, y);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_7</NAME>
      <REQUIRES>append_interaction_6</REQUIRES>
      <SCHEME>
w
      </SCHEME>
      <SCHEMEOUTPUT>
(a b c d)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
w;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
["a", ["b", ["c", ["d", null]]]]      
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_8</NAME>
      <REQUIRES>append_interaction_7</REQUIRES>
      <SCHEME>
(cdr x)
      </SCHEME>
      <SCHEMEOUTPUT>
&lt;response&gt;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
tail(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
<META>response</META>
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    What are the missing <META>response</META>s?
    Draw box-and-pointer diagrams to explain your answer.
  </EXERCISE>

  <EXERCISE>
    Consider the following
    <INDEX>cycle in list</INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-cycle</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_cycle</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    which uses the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>last-pair</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>last_pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    defined in exercise<SPACE/><REF NAME="ex:append"/>:
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_cycle</DECLARATION><FRAGILE/></INDEX> 
      <NAME>make_cycle</NAME>
      <REQUIRES>last_pair</REQUIRES>
      <EXAMPLE>make_cycle_example</EXAMPLE>
      <SCHEME>
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
            x)
      </SCHEME>
      <JAVASCRIPT>
function make_cycle(x) {
    set_tail(last_pair(x), x);
    return x;
}
      </JAVASCRIPT>
    </SNIPPET>
    Draw a box-and-pointer diagram that shows the structure
    <SCHEMEINLINE>z</SCHEMEINLINE> created by
    <SNIPPET EVAL="yes">
      <NAME>make_cycle_example</NAME>
      <REQUIRES>make_cycle</REQUIRES>
      <EXPECTED>'b'</EXPECTED>
      <SCHEME>
(define z (make-cycle (list 'a 'b 'c)))
      </SCHEME>
      <JAVASCRIPT>
const z = make_cycle(list("a", "b", "c"));
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
const z = make_cycle(list("a", "b", "c"));
list_ref(z, 100);	
      </JAVASCRIPT_TEST>
    </SNIPPET>
    What happens if we try to compute
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(last-pair z)</SCHEMEINLINE>?</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>last_pair(z)</JAVASCRIPTINLINE>?
      </JAVASCRIPT>
    </SPLITINLINE>
    <LABEL NAME="ex:make-cycle"/>
  </EXERCISE>

  <EXERCISE>
    The following
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is quite useful, although obscure:
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>mystery</DECLARATION><FRAGILE/></INDEX> 
      <NAME>mystery_loop</NAME>
      <REQUIRES>mystery_loop_example_1</REQUIRES>
      <EXAMPLE>mystery_loop_example_2</EXAMPLE>
      <SCHEME>
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
      </SCHEME>
      <JAVASCRIPT>
function mystery(x) {
    function loop(x, y) {
        if (is_null(x)) {
            return y;
        } else {
            const temp = tail(x);
            set_tail(x, y);
            return loop(temp, x);
        }
    }
    return loop(x, null);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Loop</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>loop</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    uses the <QUOTE>temporary</QUOTE>
    <SPLITINLINE>
      <SCHEME>
	variable
      </SCHEME>
      <JAVASCRIPT>
	name
      </JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>temp</SCHEMEINLINE>
    to hold the old value of the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of <SCHEMEINLINE>x</SCHEMEINLINE>, since the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    on the next line destroys the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    Explain what <SCHEMEINLINE>mystery</SCHEMEINLINE> does in general.  Suppose
    <SCHEMEINLINE>v</SCHEMEINLINE> is defined by
    <SNIPPET>
      <NAME>mystery_loop_example_1</NAME>
      <SCHEME>
(define v (list 'a 'b 'c 'd))
      </SCHEME>
      <JAVASCRIPT>
const v = list("a", "b", "c", "d");
      </JAVASCRIPT>
    </SNIPPET>
    Draw the box-and-pointer diagram that represents the list to which
    <SCHEMEINLINE>v</SCHEMEINLINE> is bound.  Suppose that we now evaluate
    <SNIPPET>
      <NAME>mystery_loop_example_2</NAME>
      <REQUIRES>mystery_loop</REQUIRES>
      <SCHEME>
(define w (mystery v))
      </SCHEME>
      <JAVASCRIPT>
const w = mystery(v);
      </JAVASCRIPT>
    </SNIPPET>
    Draw box-and-pointer diagrams that show the structures
    <SCHEMEINLINE>v</SCHEMEINLINE> and <SCHEMEINLINE>w</SCHEMEINLINE> after
    evaluating this
    <SPLITINLINE>
      <SCHEME>expression.</SCHEME>
      <JAVASCRIPT>program.</JAVASCRIPT>
    </SPLITINLINE>
    What would be printed as the values of <SCHEMEINLINE>v</SCHEMEINLINE>
    and <SCHEMEINLINE>w</SCHEMEINLINE>?
    <LABEL NAME="ex:mystery"/>
  </EXERCISE>

  <INDEX>mutable data objects<SUBINDEX>list structure<CLOSE/></SUBINDEX></INDEX>
  <INDEX>list structure<SUBINDEX>mutable<CLOSE/></SUBINDEX></INDEX>
  <INDEX>mutable data objects<SUBINDEX>pairs<CLOSE/></SUBINDEX></INDEX>
  <INDEX>pair(s)<SUBINDEX>mutable<CLOSE/></SUBINDEX></INDEX>

  <SUBHEADING> 
    <NAME>Sharing and identity</NAME>
  </SUBHEADING>

  <INDEX>data<SUBINDEX>shared<OPEN/></SUBINDEX></INDEX>
  <INDEX>shared data<OPEN/></INDEX>

  <TEXT>
    We mentioned in section<SPACE/><REF NAME="sec:costs-of-assignment"/> the
    theoretical issues of
    <INDEX>sameness and change<SUBINDEX>shared data and</SUBINDEX></INDEX>
    <INDEX>change and sameness<SUBINDEX>shared data and</SUBINDEX></INDEX>
    <QUOTE>sameness</QUOTE> and <QUOTE>change</QUOTE>
    raised by the introduction of assignment.  These issues arise in practice
    when individual pairs are <EM>shared</EM> among different data objects.
    For example, consider the structure formed by
    <SNIPPET EVAL="yes">
      <NAME>pair_example1</NAME>
      <SCHEME>
(define x (list 'a 'b))
(define z1 (cons x x))
      </SCHEME>
      <JAVASCRIPT>
const x = list("a", "b");
const z1 = pair(x, x);
      </JAVASCRIPT>
    </SNIPPET>
    As shown in
    <SPLITINLINE>
      <SCHEME>
        figure<SPACE/><REF NAME="fig:identity1_scheme"/>,
      </SCHEME>
      <JAVASCRIPT>
        figure<SPACE/><REF NAME="fig:identity1"/>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>z1</SCHEMEINLINE> is a pair whose
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    both point to the same pair <SCHEMEINLINE>x</SCHEMEINLINE>.  This sharing
    of <SCHEMEINLINE>x</SCHEMEINLINE> by the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of <SCHEMEINLINE>z1</SCHEMEINLINE> is a consequence of the straightforward
    way in which
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is implemented.  In general, using
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to construct lists will result in an interlinked structure of pairs in
    which many individual pairs are shared by many different structures.
    <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE src="img_original/ch3-Z-G-17.svg"></FIGURE>
          <CAPTION>
	    The list <SCHEMEINLINE>z1</SCHEMEINLINE> formed by
	    <SCHEMEINLINE>(cons x x)</SCHEMEINLINE>.
	  </CAPTION>
          <LABEL NAME="fig:identity1_scheme"/>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE src="img_javascript/ch3-Z-G-17.svg"></FIGURE>
          <CAPTION>
	    The list <SCHEMEINLINE>z1</SCHEMEINLINE> formed by
	    <JAVASCRIPTINLINE>pair(x, x)</JAVASCRIPTINLINE>.
          </CAPTION>
          <LABEL NAME="fig:identity1"/>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
    <SPLIT>
      <SCHEME>
        <FIGURE>
          <FIGURE src="img_original/ch3-Z-G-18.svg"></FIGURE>
          <CAPTION>
	    The list <SCHEMEINLINE>z2</SCHEMEINLINE> formed by
	    <SCHEMEINLINE>(cons (list 'a 'b) (list 'a 'b))</SCHEMEINLINE>.
	  </CAPTION>
          <LABEL NAME="fig:identity2_scheme"/>
        </FIGURE>
      </SCHEME>
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE src="img_javascript/ch3-Z-G-18.svg"></FIGURE>
          <CAPTION>
	    The list <SCHEMEINLINE>z2</SCHEMEINLINE> formed by
	    <JAVASCRIPTINLINE>pair(list("a", "b"), list("a", "b"))</JAVASCRIPTINLINE>.
	  </CAPTION>
          <LABEL NAME="fig:identity2"/>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    In contrast to
    <SPLITINLINE>
      <SCHEME>
	figure<SPACE/><REF NAME="fig:identity1_scheme"/>,
	figure<SPACE/><REF NAME="fig:identity2_scheme"/>
      </SCHEME>
      <JAVASCRIPT>
	figure<SPACE/><REF NAME="fig:identity1"/>,
	figure<SPACE/><REF NAME="fig:identity2"/>
      </JAVASCRIPT>
    </SPLITINLINE>
    shows
    the structure created by
    <SNIPPET EVAL="yes">
      <NAME>pair_example2</NAME>
      <SCHEME>
(define z2 (cons (list 'a 'b) (list 'a 'b)))
      </SCHEME>
      <JAVASCRIPT>
const z2 = pair(list("a", "b"), list("a", "b"));
      </JAVASCRIPT>
    </SNIPPET>
    In this structure, the pairs in the two
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(a b)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list("a", "b")</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    lists are distinct, although
    <SPLITINLINE>
      <SCHEME>
	the actual symbols are shared.
	<FOOTNOTE>The two pairs are distinct because each call to
	<SCHEMEINLINE>cons</SCHEMEINLINE> returns a new pair.  The
        symbols are shared; in Scheme there is a
        <INDEX>symbol(s)<SUBINDEX>uniqueness of</SUBINDEX></INDEX>
	unique symbol with any given
        name.  Since Scheme provides no way to mutate a symbol, this sharing is
        undetectable.  Note also that the sharing is what enables us to
        compare symbols using <SCHEMEINLINE>eq?</SCHEMEINLINE>, which simply checks equality of
        pointers.<LABEL NAME="foot:symbol-sharing_scheme"/></FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	they contain the same strings.<FOOTNOTE>The two pairs are distinct
	because each call to <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
	returns a new pair. The strings are
        <INDEX>string(s)<SUBINDEX>uniqueness of</SUBINDEX></INDEX>
	<QUOTE>the same</QUOTE> in the sense
	that they are primitive data (just like numbers) that are composed of
	the same characters in the same order. Since JavaScript provides no way
	to mutate a string, any sharing that the designers of a JavaScript
	interpreter might decide to implement for strings is undetectable.
	We consider primitive data such as numbers, booleans and strings
	as <EM>identical</EM>, if and only if they are
	<EM>indistinguishable</EM>.
	<LABEL NAME="foot:symbol-sharing"/>
	</FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>
  <TEXT>
    When thought of as a list, <SCHEMEINLINE>z1</SCHEMEINLINE> and
    <SCHEMEINLINE>z2</SCHEMEINLINE> both represent <QUOTE>the same</QUOTE> list:
    <SNIPPET>
      <NAME>abab</NAME>
      <EXPECTED>[ [ 'a', [ 'b', null ] ], [ 'a', [ 'b', null ] ] ]</EXPECTED>
      <SCHEME>
((a b) a b)
      </SCHEME>
      <JAVASCRIPT>
list(list("a", "b"), "a", "b")
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list(list("a", "b"), "a", "b");
      </JAVASCRIPT_RUN>
    </SNIPPET>
    In general, sharing is completely undetectable if we operate on lists using
    only
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    However, if we allow mutators on list structure, sharing becomes
    significant.  As an example of the difference that sharing can make,
    consider the following
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
    <JAVASCRIPT>function,</JAVASCRIPT></SPLITINLINE>
    which modifies the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the structure to which it is applied:
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow</NAME>
      <SCHEME>
(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
      </SCHEME>
      <JAVASCRIPT>
function set_to_wow(x) {
    set_head(head(x), "wow");
    return x;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Even though <SCHEMEINLINE>z1</SCHEMEINLINE> and
    <SCHEMEINLINE>z2</SCHEMEINLINE> are <QUOTE>the same</QUOTE> structure,
    applying
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-to-wow!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_to_wow</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to them yields different results.  With <SCHEMEINLINE>z1</SCHEMEINLINE>,
    altering the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    also changes the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    because in <SCHEMEINLINE>z1</SCHEMEINLINE> the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    are the same pair.  With <SCHEMEINLINE>z2</SCHEMEINLINE>, the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    are distinct, so
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-to-wow!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_to_wow</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    modifies only the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>:</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_1</NAME>
      <REQUIRES>pair_example1</REQUIRES>
      <EXPECTED>[ [ 'a', [ 'b', null ] ], [ 'a', [ 'b', null ] ] ]</EXPECTED>
      <SCHEME>
z1
      </SCHEME>
      <SCHEMEOUTPUT>
            ((a b) a b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
z1; 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>      
[["a", ["b", null]], ["a", ["b", null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_2</NAME>
      <REQUIRES>set_to_wow</REQUIRES>
      <REQUIRES>pair_example1</REQUIRES>
      <EXPECTED>[ [ 'wow', [ 'b', null ] ], [ 'wow', [ 'b', null ] ] ]</EXPECTED>
      <SCHEME>
(set-to-wow! z1)
      </SCHEME>
      <SCHEMEOUTPUT>
((wow b) wow b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_to_wow(z1); 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[["wow", ["b", null]], ["wow", ["b", null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_3</NAME>
      <REQUIRES>pair_example2</REQUIRES>
      <EXPECTED>[ [ 'a', [ 'b', null ] ], [ 'a', [ 'b', null ] ] ]</EXPECTED>
      <SCHEME>
z2
      </SCHEME>
      <SCHEMEOUTPUT>
((a b) a b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
z2;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>>
[["a", ["b", null]], ["a", ["b", null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_4</NAME>
      <REQUIRES>set_to_wow</REQUIRES>
      <REQUIRES>pair_example2</REQUIRES>
      <EXPECTED>[ [ 'wow', [ 'b', null ] ], [ 'a', [ 'b', null ] ] ]</EXPECTED>
      <SCHEME>
(set-to-wow! z2)
      </SCHEME>
      <SCHEMEOUTPUT>
((wow b) a b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_to_wow(z2); 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[["wow", ["b", null]], ["a", ["b", null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
	One way to detect sharing in list structures is to use the predicate 
	<SCHEMEINLINE>eq?</SCHEMEINLINE>, which we introduced in
	section<SPACE/><REF NAME="sec:quotation"/> as a way to test whether two 
	symbols are equal. More generally, <SCHEMEINLINE>(eq? x y)</SCHEMEINLINE>
	tests whether <SCHEMEINLINE>x</SCHEMEINLINE> and
	<SCHEMEINLINE>y</SCHEMEINLINE> are the same object (that is, whether
	<SCHEMEINLINE>x</SCHEMEINLINE> and <SCHEMEINLINE>y</SCHEMEINLINE>
	are equal as pointers).
      </SCHEME>
      <JAVASCRIPT>
	One way to detect sharing in list structures is to use the
	<INDEX><USE>===</USE><SUBINDEX><ORDER>equality</ORDER>as equality of pointers</SUBINDEX></INDEX>
	<INDEX><USE>===</USE><SUBINDEX><ORDER>general</ORDER>as general comparison operator</SUBINDEX></INDEX>
	<INDEX><OPERATOR/><SUBINDEX><USE>===</USE> (for non-primitive values)</SUBINDEX></INDEX>
	primitive predicate <JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,	
	which we introduced in
	section<SPACE/><REF NAME="sec:conditionals"/> to test whether two numbers
	are equal 
	and extended in section<SPACE/><REF NAME="sec:strings"/> to test whether
	two strings are equal. When applied to two non-primitive values,
	<JAVASCRIPTINLINE>x === y</JAVASCRIPTINLINE>
	tests whether <SCHEMEINLINE>x</SCHEMEINLINE> and
	<SCHEMEINLINE>y</SCHEMEINLINE> are the same object (that is, whether
	<SCHEMEINLINE>x</SCHEMEINLINE> and <SCHEMEINLINE>y</SCHEMEINLINE>
	are equal as pointers).
      </JAVASCRIPT>
    </SPLIT>
    Thus, with <SCHEMEINLINE>z1</SCHEMEINLINE> and
    <SCHEMEINLINE>z2</SCHEMEINLINE> as defined in
    <SPLITINLINE>
      <SCHEME>
	figure<SPACE/><REF NAME="fig:identity1_scheme"/>
	and<SPACE/><REF NAME="fig:identity2_scheme"/>,
      </SCHEME>
      <JAVASCRIPT>
	figure<SPACE/><REF NAME="fig:identity1"/>
	and<SPACE/><REF NAME="fig:identity2"/>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(eq? (car<SPACE/>z1) (cdr<SPACE/>z1))</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head(z1) === tail(z1)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is true and
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>(eq? (car z2) (cdr z2))</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head(z2) === tail(z2)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is false.
  </TEXT>

  <TEXT>
    As will be seen in the following sections, we can exploit sharing to
    greatly extend the repertoire of data structures that can be
    represented by pairs.  On the other hand, sharing can also be
    <INDEX>mutable data objects<SUBINDEX>shared data</SUBINDEX></INDEX>
    dangerous, since modifications made to structures will also affect
    other structures that happen to share the modified parts.  The mutation
    operations
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    should be used with care; unless we have a good understanding of how our
    data objects are shared, mutation can have unanticipated
    results.<FOOTNOTE>The subtleties of dealing with sharing of mutable data
    objects reflect the underlying issues of <QUOTE>sameness</QUOTE> and
    <QUOTE>change</QUOTE> that were raised in
    section<SPACE/><REF NAME="sec:costs-of-assignment"/>.  We mentioned there
    that admitting change to our language requires that a compound object must
    have an <QUOTE>identity</QUOTE> that is something different from the pieces
    from which it is composed.  In
    <SPLITINLINE>
      <SCHEME>Lisp,</SCHEME>
      <JAVASCRIPT>JavaScript,</JAVASCRIPT>
    </SPLITINLINE>
    we consider this <QUOTE>identity</QUOTE> to be the quality that is tested by
    <SPLITINLINE><SCHEME><SCHEMEINLINE>eq?</SCHEMEINLINE>,</SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    i.e., by equality of pointers.  Since in most
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    implementations a pointer is essentially a memory address, we are
    <QUOTE>solving the problem</QUOTE> of defining the identity of objects by
    stipulating that a data object <QUOTE>itself</QUOTE> is the information
    stored in some particular set of memory locations in the computer.  This
    suffices for simple
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    programs, but is hardly a general way to resolve the issue of
    <QUOTE>sameness</QUOTE> in computational models.</FOOTNOTE>
  </TEXT>

  <EXERCISE>
    Draw box-and-pointer diagrams to explain the effect of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-to-wow!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_to_wow</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    on the structures <SCHEMEINLINE>z1</SCHEMEINLINE> and
    <SCHEMEINLINE>z2</SCHEMEINLINE> above.
  </EXERCISE>

  <EXERCISE>
    Ben Bitdiddle decides to write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to count the number of pairs in any list structure.
    <QUOTE>It<APOS/>s easy,</QUOTE> he reasons.  <QUOTE>The number of pairs in
    any structure is the number in the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    plus the number in the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    plus one more to count the current pair.</QUOTE> So Ben writes the following
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>count_pairs</DECLARATION><FRAGILE/></INDEX> 
      <SCHEME>
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
      </SCHEME>
      <JAVASCRIPT>
function count_pairs(x) {
    return ! is_pair(x)
           ? 0
           : count_pairs(head(x)) + 
             count_pairs(tail(x)) + 1;
}
      </JAVASCRIPT>
    </SNIPPET>
    Show that this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is not correct.  In particular, draw box-and-pointer diagrams representing
    list structures made up of exactly three pairs for which Ben<APOS/>s
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    would return 3; return 4; return 7; never return at all.
    <LABEL NAME="ex:count-pairs"/>
  </EXERCISE>

  <EXERCISE>
    Devise a correct version of the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>count-pairs</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>count_pairs</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of exercise<SPACE/><REF NAME="ex:count-pairs"/> that returns the number of
    distinct pairs in any structure.  (Hint: Traverse the structure, maintaining
    an auxiliary data structure that is used to keep track of which pairs have
    already been counted.)
    <LABEL NAME="ex:count-pairs2"/>
  </EXERCISE>
  
  <EXERCISE>
    Write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that examines a list and
    <INDEX>cycle in list<SUBINDEX>detecting</SUBINDEX></INDEX>
    determines whether it contains a cycle, that is,
    whether a program that tried to find the end of the list by taking
    successive
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>s</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>s</JAVASCRIPT>
    </SPLITINLINE>
    would go into an infinite loop. Exercise<SPACE/><REF NAME="ex:make-cycle"/>
    constructed such lists.
    <LABEL NAME="ex:find-cycle"/>
  </EXERCISE>

  <EXERCISE>
    Redo exercise<SPACE/><REF NAME="ex:find-cycle"/> using an algorithm that
    takes only a constant amount of space.  (This requires a very clever idea.)
  </EXERCISE>

  <INDEX>data<SUBINDEX>shared<CLOSE/></SUBINDEX></INDEX>
  <INDEX>shared data<CLOSE/></INDEX>

  <SUBHEADING> 
    <NAME>Mutation is just assignment</NAME>
  </SUBHEADING>

  <INDEX>mutable data objects<SUBINDEX>functional representation of<OPEN/></SUBINDEX></INDEX>
  <INDEX>mutable data objects<SUBINDEX>implemented with assignment<OPEN/></SUBINDEX></INDEX>
  <INDEX>pair(s)<SUBINDEX>functional representation of<OPEN/></SUBINDEX></INDEX>
  <INDEX>functional representation of data<SUBINDEX>mutable data<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    When we introduced compound data, we observed in
    section<SPACE/><REF NAME="sec:data?"/> that pairs can be represented purely
    in terms of
    <SPLITINLINE>
      <SCHEME>procedures:</SCHEME>
      <JAVASCRIPT>functions:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>pair</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>head</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>tail</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <EXAMPLE>cons_1_2_run</EXAMPLE>
      <EXPECTED>1</EXPECTED>
      <SCHEME>
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined operation - - CONS" m))))
  dispatch)

(define (car z) (z 'car))

(define (cdr z) (z 'cdr))
      </SCHEME>
      <JAVASCRIPT>
function pair(x, y) {
    function dispatch(m) {
        return m === "head"
               ? x
               : m === "tail"
               ? y
               : error(m, "undefined operation -- pair");
    }
    return dispatch;	      
}
    
function head(z) { return z("head"); }
    
function tail(z) { return z("tail"); }
      </JAVASCRIPT>
    </SNIPPET>
    The same observation is true for mutable data.  We can implement
    mutable data objects as
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    using assignment and local state. For instance, we can extend the above
    pair implementation to handle
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in a manner analogous to the way we implemented bank accounts using
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in section<SPACE/><REF NAME="sec:local-state-variables"/>:
    <SNIPPET HIDE="yes">
      <NAME>cons_1_2_run_3</NAME>
      <JAVASCRIPT>
const x = pair(1, 2);
set_head(x, 3);
head(x);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>pair</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>head</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>tail</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>set_head</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>set_tail</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <NAME>pair2</NAME>
      <EXAMPLE>cons_1_2_run_3</EXAMPLE>
      <EXPECTED>3</EXPECTED>
      <SCHEME>
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error "Undefined operation - - CONS" m))))
  dispatch)

(define (car z) (z 'car))

(define (cdr z) (z 'cdr))

(define (set-car! z new-value)
  ((z 'set-car!) new-value)
  z)

(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value)
  z)
      </SCHEME>
      <JAVASCRIPT>
function pair(x, y) {
    function set_x(v) { x = v; }
    function set_y(v) { y = v; }
    return m => m === "head"
                ? x
                : m === "tail"
                ? y
                : m === "set_head"
                ? set_x
                : m === "set_tail"
                ? set_y
                : error(m, "undefined operation -- pair");
}
    
function head(z) { return z("head"); }

function tail(z) { return z("tail"); }

function set_head(z, new_value) {
    z("set_head")(new_value);
    return z;
}

function set_tail(z, new_value) {
    z("set_tail")(new_value);
    return z;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Assignment is all that is needed, theoretically, to account for the
    behavior of mutable data.  As soon as we admit
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>assignment</JAVASCRIPT>
    </SPLITINLINE>
    to our language, we raise all the issues, not only of assignment, but of
    mutable data in general.<FOOTNOTE>On the other hand, from the viewpoint of
    implementation, assignment requires us to modify the environment, which is
    itself a mutable data structure.  Thus, assignment and mutation are
    equipotent: Each can be implemented in terms of the other.</FOOTNOTE>
  </TEXT>

  <EXERCISE>
    Draw environment diagrams to illustrate the evaluation of the sequence
    of
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <NAME>pair2_example1</NAME>
      <REQUIRES>pair2</REQUIRES>
      <SCHEME>
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)

(car x)
      </SCHEME>
      <JAVASCRIPT>
const x = pair(1, 2);
const z = pair(x, x);
set_head(tail(z), 17);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>pair2_example2</NAME>
      <REQUIRES>pair2_example1</REQUIRES>
      <EXPECTED>17</EXPECTED>
      <SCHEME>
(car x)
      </SCHEME>
      <SCHEMEOUTPUT>
            17
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
head(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
17
      </JAVASCRIPT_OUTPUT>
      </SNIPPET>
    using the 
    <SPLITINLINE>
      <SCHEME>
            procedural 
      </SCHEME>
      <JAVASCRIPT>
            functional
      </JAVASCRIPT>
    </SPLITINLINE>
    implementation of pairs given above.  (Compare
    exercise<SPACE/><REF NAME="ex:two-accounts"/>.)
    <LABEL NAME="ex:cons-with-assignment"/>
  </EXERCISE>

  <INDEX>mutable data objects<SUBINDEX>functional representation of<CLOSE/></SUBINDEX></INDEX>
  <INDEX>mutable data objects<SUBINDEX>implemented with assignment<CLOSE/></SUBINDEX></INDEX>
  <INDEX>pair(s)<SUBINDEX>functional representation of<CLOSE/></SUBINDEX></INDEX>
  <INDEX>functional representation of data<SUBINDEX>mutable data<CLOSE/></SUBINDEX></INDEX>
  <INDEX>mutable data objects<CLOSE/></INDEX>
</SUBSECTION>

