      <SUBSECTION>
        <NAME>
          Conditional Expressions and Predicates
        </NAME>
        <LABEL NAME="sec:conditionals"/>

        <SPLIT>
          <SCHEME>
            <TEXT>
              The expressive power of the class of procedures that we can define at
              this point is very limited, because we have no way to make tests and
              to perform different operations depending on the result of a test.
              For instance, we cannot define a procedure that computes the 
              <INDEX>absolute value</INDEX>
              absolute
              value of a number by testing whether the number is positive, negative,
              or zero and taking different actions in the different cases according
              to the rule
              <LATEX>
                  \[
                  |x| = \left\{ \begin{array}{rl}
                  x   &amp; \mbox{if $x&gt;0$} \\
                  0   &amp; \mbox{if $x=0$} \\
                  -x  &amp; \mbox{if $x&lt;0$}
                  \end{array}
                  \right.
                  \]
              </LATEX>
              <INDEX>case analysis<SUBINDEX>general</SUBINDEX></INDEX>
              This construct is called a <EM>case analysis</EM>, and
              there is a special form in Lisp for notating such a case
              analysis.  It is called 
              <!--\indsf*{cond} -->
              <!-- \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[cond@<SCHEMEINLINE>cond</SCHEMEINLINE>] -->
              <INDEX>conditional expression<SUBINDEX>cond@<SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
              <SCHEMEINLINE>cond</SCHEMEINLINE> (which stands for
              <QUOTE>conditional</QUOTE>), and it is used as follows:
              <SNIPPET>
                <NAME>abs_definition</NAME>
                <EXAMPLE>abs_example</EXAMPLE>
                <!--\indcode*{abs} -->
                <SCHEME>
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((&lt; x 0) (- x))))
                </SCHEME>
              </SNIPPET>
              <SNIPPET EVAL="no">
                <NAME>abs_example</NAME>
                <SCHEME>
(abs (- 5))
                </SCHEME>
              </SNIPPET>
              The general form of a conditional expression is
              <SNIPPET EVAL="no" LATEX="yes">
                <SCHEME>
(cond (^$\langle p_1 \rangle $^ ^$\langle e_1 \rangle$^)
      (^$\langle p_2 \rangle $^ ^$\langle e_2 \rangle$^)
      ^$\vdots$^
      (^$\langle p_n \rangle $^ ^$\langle e_n \rangle$^))
                </SCHEME>
              </SNIPPET>
              consisting of the symbol <SCHEMEINLINE>cond</SCHEMEINLINE> followed by
              <INDEX>parentheses<SUBINDEX><ORDER>delimiting cond</ORDER>
                  delimiting <SCHEMEINLINE>cond</SCHEMEINLINE> clauses</SUBINDEX></INDEX>
              parenthesized pairs of expressions <SCHEMEINLINE>(</SCHEMEINLINE><LATEXINLINE>$\langle p\ e \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE>
              called 
              <INDEX>clause, of a <SCHEMEINLINE>cond</SCHEMEINLINE></INDEX>
              <!-- \indsf{cond}[clause] -->
              <EM>clauses</EM>. The first expression in each pair is a 
              <INDEX>predicate<SUBINDEX><ORDER>cond</ORDER>of 
                  <SCHEMEINLINE>cond</SCHEMEINLINE> clause</SUBINDEX></INDEX>
              <EM>predicate</EM><EMDASH/>that is, an expression whose value is interpreted as
              either true or false.<FOOTNOTE>
                <INDEX>true</INDEX><INDEX>false</INDEX>
                <!-- \indcode*{\#t}\ind*{t@<SCHEMEINLINE>\#t</SCHEMEINLINE>}\indcode*{true} -->
                <!-- \indcode*{\#f}\ind*{f@<SCHEMEINLINE>\#f</SCHEMEINLINE>}\indcode*{false} -->
                <QUOTE>Interpreted as either true or false</QUOTE>
                means this: In Scheme, there are two distinguished values that are
                denoted by the constants 
                <SCHEMEINLINE>#t</SCHEMEINLINE> and <SCHEMEINLINE>#f</SCHEMEINLINE>.  
                When the interpreter
                checks a predicate<APOS/>s value, it interprets 
                <SCHEMEINLINE>#f</SCHEMEINLINE> as false.  Any other value
                is treated as true.  (Thus, providing <SCHEMEINLINE>#t</SCHEMEINLINE> is logically
                unnecessary, but it is convenient.)  In this book we will use
                names <SCHEMEINLINE>true</SCHEMEINLINE> and <SCHEMEINLINE>false</SCHEMEINLINE>, 
                which are associated
                with the values <SCHEMEINLINE>#t</SCHEMEINLINE> and 
                <SCHEMEINLINE>#f</SCHEMEINLINE> respectively.</FOOTNOTE>
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              The expressive power of the class of functions that we can declare at
              this point is very limited, because we have no way to make tests and
              to perform different operations depending on the result of a test.
              For instance, we cannot declare a function that computes the 
              <INDEX>absolute value</INDEX>
              absolute
              value of a number by testing whether the number is negative or not,
              and taking different actions in each case according
              to the rule
              <LATEX>
                  \[
                  |x| = \left\{ \begin{array}{rl}
                  x   &amp; \mbox{if $x \geq 0$} \\
                  -x  &amp; \mbox{otherwise}
                  \end{array}
                  \right.
                  \]
              </LATEX>
              This construct is a <EM>case analysis</EM> and can be expressed
	      in JavaScript using a <EM>conditional expression</EM> as follows:
              <SNIPPET>
                <NAME>abs_definition</NAME>
                <EXAMPLE>abs_example</EXAMPLE>
                <!--\indcode*{abs} -->
                <JAVASCRIPT>
function abs(x) {
    return x &gt;= 0 ? x : -x;
}
                </JAVASCRIPT>
              </SNIPPET>
              <SNIPPET HIDE="yes">
                <NAME>abs_example</NAME>
                <JAVASCRIPT>
abs(-5);
                </JAVASCRIPT>
              </SNIPPET>
              The general form of a conditional expression is
              <SNIPPET EVAL="no" LATEX="yes">
                <JAVASCRIPT>
$\textit{predicate}$ ? $\textit{consequent-expression}$ : $\textit{alternative-expression}$
                </JAVASCRIPT>
              </SNIPPET>
              Conditional expressions begin with a
              <NOBR>
              <LATEXINLINE>$\textit{predicate}$</LATEXINLINE></NOBR><EMDASH/>that is, 
              an expression whose value is interpreted as either
	      <EM>true</EM> or
	      <EM>false</EM>,
	      two distinguished
	      <EM>boolean</EM> values in JavaScript.<FOOTNOTE>
                <INDEX>true</INDEX><INDEX>false</INDEX>
                <!-- \indcode*{\#t}\ind*{t@<JAVASCRIPTINLINE>\#t</JAVASCRIPTINLINE>}\indcode*{true} -->
                <!-- \indcode*{\#f}\ind*{f@<JAVASCRIPTINLINE>\#f</JAVASCRIPTINLINE>}\indcode*{false} -->
                In JavaScript, other values are automatically converted into
	      <EM>true</EM> and
	      <EM>false</EM>
                according to <EM>conversion rules</EM>, but we choose not to make
		use of these conversion rules in this book.
              </FOOTNOTE>
	      Note that the primitive boolean expressions
	      <JAVASCRIPTINLINE>true</JAVASCRIPTINLINE> and
	      <JAVASCRIPTINLINE>false</JAVASCRIPTINLINE> trivially evaluate
	      to the boolean values <EM>true</EM> and <EM>false</EM>, respectively.
	      The <LATEXINLINE>$\textit{predicate}$</LATEXINLINE> 
              is followed by a question mark, the 
              <LATEXINLINE>$\textit{consequent-expression}$</LATEXINLINE>, 
              a colon, and finally the
              <LATEXINLINE>$\textit{alternative-expression}$</LATEXINLINE>.
            </TEXT>
          </JAVASCRIPT>
      </SPLIT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              <!--\indsf{cond}[evaluation of] -->
              <INDEX>evaluation<SUBINDEX><ORDER>of cond</ORDER>of <SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
              Conditional expressions are evaluated as follows.  The predicate
              <LATEXINLINE>$\langle p_1 \rangle$</LATEXINLINE> is evaluated first.  If its value is false, then
              <LATEXINLINE>$\langle p_2 \rangle$</LATEXINLINE> is evaluated.  
              If <LATEXINLINE>$\langle p_2 \rangle$</LATEXINLINE><APOS/>s 
              value is also false, then
              <LATEXINLINE>$\langle p_3 \rangle$</LATEXINLINE> is evaluated.  
              This process continues until a predicate is
              found whose value is true, in which case the interpreter returns the
              value of the corresponding 
              <INDEX>consequent<SUBINDEX>cond@of <SCHEMEINLINE>cond</SCHEMEINLINE> clause</SUBINDEX></INDEX>
              <EM>consequent expression</EM> <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> of the
              clause as the value of the conditional expression.  If none of the
              <LATEXINLINE>$\langle p \rangle$</LATEXINLINE><APOS/>s is found to be true, the value of the 
              <SCHEMEINLINE>cond</SCHEMEINLINE> is
              undefined.
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              To evaluate a conditional expression,
              the interpreter starts by evaluating the 
              <INDEX>predicate<SUBINDEX><ORDER>if</ORDER>of 
                  <JAVASCRIPTINLINE>if</JAVASCRIPTINLINE></SUBINDEX></INDEX>
              <LATEXINLINE>$\textit{predicate}$</LATEXINLINE> 
              part of the expression.  
              If the <LATEXINLINE>$\textit{predicate}$</LATEXINLINE> 
              evaluates to <EM>true</EM>, the interpreter evaluates
              <INDEX>consequent<SUBINDEX><ORDER>if</ORDER>of 
                  <JAVASCRIPTINLINE>if</JAVASCRIPTINLINE></SUBINDEX></INDEX>
              <LATEXINLINE>$\textit{consequent-expression}$</LATEXINLINE>.
              Otherwise it evaluates 
              <INDEX>alternative of <JAVASCRIPTINLINE>if</JAVASCRIPTINLINE></INDEX>
              <LATEXINLINE>$\textit{alternative-expression}$</LATEXINLINE>.
            </TEXT>
          </JAVASCRIPT>
        </SPLIT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              <INDEX>predicate</INDEX>
              The word <EM>predicate</EM> is used for procedures that return true
              or false, as well as for expressions that evaluate to true or false.
              The absolute-value procedure <SCHEMEINLINE>abs</SCHEMEINLINE> makes use of the 
              <!-- \indcodeplus*{&gt;}{(primitive numeric comparison predicate)}
                   \indcodeplus*{&lt;}{(primitive numeric comparison predicate)}
                   \indcodeplus*{=}{(primitive numeric equality predicate)} 
                   \ind*{primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[&gt;@<SCHEMEINLINE>&gt;</SCHEMEINLINE>]
                   \ind*{primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[&lt;@<SCHEMEINLINE>&lt;</SCHEMEINLINE>]
                   \ind*{primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[=@<SCHEMEINLINE>=</SCHEMEINLINE>] -->
              <INDEX>number(s)<SUBINDEX>comparison of</SUBINDEX></INDEX>
              <INDEX>number(s)<SUBINDEX>equality of</SUBINDEX></INDEX>
              <INDEX>equality<SUBINDEX>numbers@of numbers</SUBINDEX></INDEX>
              primitive
              predicates <SCHEMEINLINE>&gt;</SCHEMEINLINE>, 
              <SCHEMEINLINE>&lt;</SCHEMEINLINE>, and 
              <SCHEMEINLINE>=</SCHEMEINLINE>.<FOOTNOTE><SCHEMEINLINE>Abs</SCHEMEINLINE> also uses
                <!-- \indcodeplus*{-}{(primitive subtraction procedure)}[as negation]
                     \ind*{primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[-@<SCHEMEINLINE>-</SCHEMEINLINE>] -->
                the <QUOTE>minus</QUOTE> operator <SCHEMEINLINE>-</SCHEMEINLINE>, 
                which, when used with a single
                operand, as in <SCHEMEINLINE>(- x)</SCHEMEINLINE>, 
                indicates negation.</FOOTNOTE> These take two
              numbers as arguments and test whether the first number is,
              respectively, greater than, less than, or equal to the second number,
              returning true or false accordingly.
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              <INDEX>predicate</INDEX>
              The word <EM>predicate</EM> is used for functions that return
	      <EM>true</EM> or <EM>false</EM>, as well as for expressions that
	      evaluate to <EM>true</EM> or <EM>false</EM>.
              The absolute-value function <JAVASCRIPTINLINE>abs</JAVASCRIPTINLINE> 
              makes use of the 
              <!-- \indcodeplus*{&gt;}{(primitive numeric comparison predicate)}
                   \indcodeplus*{&lt;}{(primitive numeric comparison predicate)}
                   \indcodeplus*{=}{(primitive numeric equality predicate)} 
                   \ind*{primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[&gt;@<JAVASCRIPTINLINE>&gt;</JAVASCRIPTINLINE>]
                   \ind*{primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[&lt;@<JAVASCRIPTINLINE>&lt;</JAVASCRIPTINLINE>]
                   \ind*{primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[=@<JAVASCRIPTINLINE>=</JAVASCRIPTINLINE>] -->
              <INDEX>number(s)<SUBINDEX>comparison of</SUBINDEX></INDEX>
              <INDEX>number(s)<SUBINDEX>equality of</SUBINDEX></INDEX>
              <INDEX>equality<SUBINDEX>numbers@of numbers</SUBINDEX></INDEX>
              primitive
              predicate <JAVASCRIPTINLINE>&gt;=</JAVASCRIPTINLINE>.
	      This predicate takes two
              numbers as arguments and tests whether the first number is
              greater than or equal to the second number,
              returning <EM>true</EM> or <EM>false</EM> accordingly.
            </TEXT>
          </JAVASCRIPT>
        </SPLIT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              Another way to write the absolute-value procedure is
              <!-- \indcode*{abs} -->
              <SNIPPET>
                <EXAMPLE>abs_example</EXAMPLE>
                <SCHEME>
(define (abs x)
  (cond ((&lt; x 0) (- x))
    (else x)))
                </SCHEME>
              </SNIPPET>
              which could be expressed in English as 
              <QUOTE>If <LATEXINLINE>$x$</LATEXINLINE> is less than zero
                return <NOBR><LATEXINLINE>$-x$</LATEXINLINE>;</NOBR> otherwise return 
                <NOBR><LATEXINLINE>$x$</LATEXINLINE>.</NOBR>
              </QUOTE>  
              <!-- \indcodeplus*{else}{(special symbol in <SCHEMEINLINE>cond</SCHEMEINLINE>)}
                -->
              <SCHEMEINLINE>Else</SCHEMEINLINE> is a special symbol
              that can be used in place of the <LATEXINLINE>$\langle p \rangle$</LATEXINLINE> 
              in the final clause of a 
              <SCHEMEINLINE>cond</SCHEMEINLINE>.  
              This causes the <SCHEMEINLINE>cond</SCHEMEINLINE> to return as its value 
              the value of
              the corresponding <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
              whenever all previous clauses have been
              bypassed.  In fact, any expression that always evaluates to a true
              value could be used as the <LATEXINLINE>$\langle p \rangle$</LATEXINLINE> here.
            </TEXT>
          </SCHEME>
        </SPLIT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              Here is yet another way to write the absolute-value procedure:
              <!-- \indcode*{abs} -->
              <SNIPPET>
                <EXAMPLE>abs_example</EXAMPLE>
                <SCHEME>
(define (abs x)
  (if (&lt; x 0)
    (- x)
    x))
                </SCHEME>
              </SNIPPET>
              <!-- \indsf*{if}
                   \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[if@<SCHEMEINLINE>if</SCHEMEINLINE>]
                -->
              <INDEX>conditional expression<SUBINDEX><ORDER>if</ORDER>
                  <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
              This uses the special form <SCHEMEINLINE>if</SCHEMEINLINE>, a restricted 
              type of conditional that can be used when there are precisely 
              <INDEX>case analysis<SUBINDEX><ORDER>two</ORDER>with two cases 
                  (<SCHEMEINLINE>if</SCHEMEINLINE>)</SUBINDEX></INDEX>
              two cases in the case
              analysis.  The general form of an <SCHEMEINLINE>if</SCHEMEINLINE> expression is
              <SNIPPET EVAL="no"  LATEX="yes">
                <SCHEME>
                  (if ^$\langle \textit{predicate} \rangle$^ ^$\langle \textit{consequent}\rangle$^ ^$\langle \textit{alternative}\rangle$^)
                </SCHEME>
              </SNIPPET>
              <!-- \indsf{if}[evaluation of] -->
              <INDEX>evaluation<SUBINDEX><ORDER>of if</ORDER>of 
                  <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
              <!-- \indsf{if}[predicate, consequent, and alternative of] -->
              To evaluate an <SCHEMEINLINE>if</SCHEMEINLINE> expression, 
              the interpreter starts by evaluating the 
              <INDEX>predicate<SUBINDEX><ORDER>if</ORDER>of 
                  <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
              <LATEXINLINE>$\langle \textit{predicate}\rangle$</LATEXINLINE> 
              part of the expression.  
              If the <LATEXINLINE>$\langle \textit{predicate}\rangle$</LATEXINLINE> 
              evaluates to a true value, the interpreter then evaluates
              the 
              <INDEX>consequent<SUBINDEX><ORDER>if</ORDER>of 
                  <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
              <LATEXINLINE>$\langle \textit{consequent}\rangle$</LATEXINLINE> 
              and returns its value.  Otherwise it evaluates the 
              <INDEX>alternative of <SCHEMEINLINE>if</SCHEMEINLINE></INDEX>
              <LATEXINLINE>$\langle \textit{alternative}\rangle$</LATEXINLINE> 
              and returns its value.<FOOTNOTE>A minor 
                difference
                <!--
                    \indsf{if}[cond@<SCHEMEINLINE>cond</SCHEMEINLINE> vs.]
                    \indsf{cond}[if@<SCHEMEINLINE>if</SCHEMEINLINE> vs.]
                  -->
                <INDEX>sequence of expressions<SUBINDEX>in consequent of 
                    <SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
                between <SCHEMEINLINE>if</SCHEMEINLINE> and 
                <SCHEMEINLINE>cond</SCHEMEINLINE> is that the
                <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
                part of each <SCHEMEINLINE>cond</SCHEMEINLINE> 
                clause may be a sequence of expressions.
                If the corresponding <LATEXINLINE>$\langle p \rangle$</LATEXINLINE> 
                is found to be true, 
                the expressions 
                <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
                are evaluated in sequence and the value of the final
                expression in the sequence is returned as the value of the 
                <SCHEMEINLINE>cond</SCHEMEINLINE>.
                In an <SCHEMEINLINE>if</SCHEMEINLINE> expression, however, 
                the <LATEXINLINE>$\langle \textit{consequent}\rangle$</LATEXINLINE> and
                <LATEXINLINE>$\langle \textit{alternative}\rangle$</LATEXINLINE> must be single  
                expressions.<LABEL NAME="foot:cond-consequent"/></FOOTNOTE>
            </TEXT>
          </SCHEME>
        </SPLIT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              In addition to primitive
              predicates such as <SCHEMEINLINE>&lt;</SCHEMEINLINE>, <SCHEMEINLINE>=</SCHEMEINLINE>, and <SCHEMEINLINE>&gt;</SCHEMEINLINE>, there are logical
              composition operations, which enable us to construct compound
              predicates.  The three most frequently used are these:
              <UL>
                <!-- \indsf*{and} 
                     \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[and@<SCHEMEINLINE>and</SCHEMEINLINE>]
                     \indsf{and}[evaluation of]
                  -->
                <INDEX>evaluation<SUBINDEX><ORDER>of and</ORDER>of 
                    <SCHEMEINLINE>and</SCHEMEINLINE></SUBINDEX></INDEX>
                <LI><SCHEMEINLINE>(and</SCHEMEINLINE> <LATEXINLINE>$\langle e_1\rangle \ldots \langle e_n \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE><BREAK/>
                  The interpreter
                  evaluates the expressions <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> one at a time, 
                  in left-to-right order.  If
                  any <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> evaluates to false, 
                  the value of the <SCHEMEINLINE>and</SCHEMEINLINE>
                  expression is false, and the rest of the <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS/>s 
                  are not evaluated.
                  If all <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS/>s evaluate to true values, 
                  the value of the <SCHEMEINLINE>and</SCHEMEINLINE>
                  expression is the value of the last one.

                  <!-- \indsf*{or}
                       \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[or@<SCHEMEINLINE>or</SCHEMEINLINE>]
                       \indsf{or}[evaluation of]
                    -->
                </LI>
                <LI>
                  <INDEX>evaluation<SUBINDEX><ORDER>of or</ORDER>of 
                      <SCHEMEINLINE>or</SCHEMEINLINE></SUBINDEX></INDEX>
                  <SCHEMEINLINE>(or</SCHEMEINLINE> <LATEXINLINE>$\langle e_1 \rangle\ldots \langle e_n \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE><BREAK/>
                  The interpreter
                  evaluates the expressions 
                  <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> one at a time, in left-to-right order.  If
                  any <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> evaluates to a true value, that value is
                  returned as the value of the <SCHEMEINLINE>or</SCHEMEINLINE> expression,
                  and the rest of the <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS/>s are not evaluated.
                  If all <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS/>s evaluate to false,
                  the value of the <SCHEMEINLINE>or</SCHEMEINLINE> expression is false.
                </LI>
                <!--
                    \indprim*{not}
                    \ind*{primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[not@<SCHEMEINLINE>not</SCHEMEINLINE>]
                  -->
                <LI>
                  <SCHEMEINLINE>(not</SCHEMEINLINE> <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE><BREAK/>
                  The value of a <SCHEMEINLINE>not</SCHEMEINLINE> expression is true
                  when the expression <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
                  evaluates to false, and false otherwise.
                </LI>
              </UL>
              <!-- \indsf{and}[why a special form]
                   \indsf{or}[why a special form]
                -->
              Notice that <SCHEMEINLINE>and</SCHEMEINLINE> and <SCHEMEINLINE>or</SCHEMEINLINE> are special forms, not procedures,
              because the subexpressions are not necessarily all evaluated.
              <SCHEMEINLINE>Not</SCHEMEINLINE> is an ordinary procedure.
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              JavaScript
              provides a number of primitive predicates that work similar to
              <JAVASCRIPTINLINE>&gt;=</JAVASCRIPTINLINE>, including
              <JAVASCRIPTINLINE>&gt;</JAVASCRIPTINLINE>, 
              <JAVASCRIPTINLINE>&lt;</JAVASCRIPTINLINE>,
              <JAVASCRIPTINLINE>&lt;=</JAVASCRIPTINLINE>, and
              <JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>.
              In addition to these primitive
              predicates, there are logical
              composition operations, which enable us to construct compound
              predicates.  
              The three most frequently used are these:
              <UL>
                <!-- \indsf*{and} 
                     \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[and@<JAVASCRIPTINLINE>and</JAVASCRIPTINLINE>]
                     \indsf{and}[evaluation of]
                  -->
                <INDEX>evaluation<SUBINDEX><ORDER>of and</ORDER>of 
                    <JAVASCRIPTINLINE>and</JAVASCRIPTINLINE></SUBINDEX></INDEX>
                    <LI><LATEXINLINE>$ \textit{expression}_1$</LATEXINLINE> <JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE>
		    <LATEXINLINE>$\textit{expression}_2$</LATEXINLINE><BREAK/>
                  The interpreter
                  evaluates <LATEXINLINE>$\textit{expression}_1$</LATEXINLINE>.
                  If it evaluates to <EM>false</EM>, 
                  the value of the whole 
                  expression is <EM>false</EM>,
		  and <LATEXINLINE>$\textit{expression}_2$</LATEXINLINE>
                  is not evaluated.
                  If <LATEXINLINE>$\textit{expression}_1$</LATEXINLINE> evaluates
		  to <EM>true</EM>, the value of the whole expression
                  is the value of 
                  <LATEXINLINE>$\textit{expression}_2$</LATEXINLINE>.
                  <!-- \indsf*{or}
                       \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[or@<JAVASCRIPTINLINE>or</JAVASCRIPTINLINE>]
                       \indsf{or}[evaluation of]
                    -->
                </LI>
                <LI>
                  <INDEX>evaluation<SUBINDEX><ORDER>of or</ORDER>of 
                      <JAVASCRIPTINLINE>or</JAVASCRIPTINLINE></SUBINDEX></INDEX>
                  <LATEXINLINE>$\textit{expression}_1$</LATEXINLINE> 
                  <JAVASCRIPTINLINE>||</JAVASCRIPTINLINE> 
                  <LATEXINLINE>$\textit{expression}_2$</LATEXINLINE><BREAK/>
                  The interpreter evaluates 
                  <LATEXINLINE>$\textit{expression}_1$</LATEXINLINE>. If
                  it evaluates to <EM>true</EM>, 
                  the value of the whole expression is <EM>true</EM>, and 
                  <LATEXINLINE>$\textit{expression}_2$</LATEXINLINE> is not
		  evaluated.
                  If <LATEXINLINE>$\textit{expression}_1$</LATEXINLINE> evaluates
		  to <EM>false</EM>, the value of the whole expression is the
		  value of <LATEXINLINE>$\textit{expression}_2$</LATEXINLINE>.
                </LI>
                <!--
                    \indprim*{not}
                    \ind*{primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[not@<JAVASCRIPTINLINE>not</JAVASCRIPTINLINE>]
                  -->
                <LI>
                  <JAVASCRIPTINLINE>!</JAVASCRIPTINLINE> <LATEXINLINE>$\textit{expression}$</LATEXINLINE><BREAK/>
                  The value of the expression is <EM>true</EM>
                  when <LATEXINLINE>$\textit{expression}$</LATEXINLINE>
		  evaluates to <EM>false</EM>, 
                  and <EM>false</EM> otherwise.
                </LI>
              </UL>
              <!-- \indsf{and}[why a special form]
                   \indsf{or}[why a special form]
                -->
              Notice that <JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE> and 
              <JAVASCRIPTINLINE>||</JAVASCRIPTINLINE> are not evaluated like
	      arithmetic operators such as 
              <JAVASCRIPTINLINE>+</JAVASCRIPTINLINE>, because their right-hand
              expression is not always evaluated. The operator
              <JAVASCRIPTINLINE>!</JAVASCRIPTINLINE>, on the other hand, 
              follows the evaluation rule of section
	      <REF NAME="sec:evaluating-combinations"/>. 
              It is a <EM>unary</EM> operator, which means that it takes only
	      one argument, whereas the
              arithmetic operators encountered so far are <EM>binary</EM>, 
              taking two arguments. The operator
              <JAVASCRIPTINLINE>!</JAVASCRIPTINLINE> precedes its argument;
	      we call it a <EM>prefix operator</EM>.
	      Another prefix operator is
	      the unary <QUOTE>minus</QUOTE> operator, an example of
	      which is the expression <JAVASCRIPTINLINE>-x</JAVASCRIPTINLINE>
	      of the function <JAVASCRIPTINLINE>abs</JAVASCRIPTINLINE>
	      in the beginning of this section.
            </TEXT>
          </JAVASCRIPT>
        </SPLIT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              As an example of how these are used, the condition that a 
              number <LATEXINLINE>$x$</LATEXINLINE>
              be in the range <LATEXINLINE>$5 &lt; x &lt; 10$</LATEXINLINE> may be expressed as
              <SNIPPET EVAL="no">
                <SCHEME>
(and (> x 5) (&lt; x 10))
                </SCHEME>
              </SNIPPET>
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              As an example of how these predicates are used, the condition that a 
              number <LATEXINLINE>$x$</LATEXINLINE>
              be in the range <LATEXINLINE>$5 &lt; x &lt; 10$</LATEXINLINE>
	      may be expressed as
              <SNIPPET EVAL="no">
                <JAVASCRIPT>
x &gt; 5 &amp;&amp; x &lt; 10 
                </JAVASCRIPT>
              </SNIPPET>
              Note that the binary
              operator <JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE>
              has lower precedence than the comparison operators
              <JAVASCRIPTINLINE>&gt;</JAVASCRIPTINLINE> and
              <JAVASCRIPTINLINE>&lt;</JAVASCRIPTINLINE>.
            </TEXT>
          </JAVASCRIPT>
        </SPLIT>

        <SPLIT>
          <SCHEME>
            <TEXT>
              As another example, we can define a predicate to test whether one
              number is greater than or equal to another as
              <SNIPPET>
                <EXAMPLE>geq_example</EXAMPLE>
                <!-- \indcode*{>=} -->
                <SCHEME>
(define (&gt;= x y)
  (or (&gt; x y) (= x y)))
                </SCHEME>
              </SNIPPET>
              or alternatively as
              <SNIPPET>
                <!-- \indcode*{>=} -->
                <SCHEME>
(define (&gt;= x y)
  (not (&lt; x y)))
                </SCHEME>
              </SNIPPET>

              <SNIPPET HIDE="yes">
                <EXAMPLE>geq_example</EXAMPLE>
                <!-- \indcode*{>=} -->
                <SCHEME>
(&gt;= 7 4)
                </SCHEME>
              </SNIPPET>

            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              <CHANGE>
                As another example, we can declare a predicate to test whether one
                number is not equal to another number.
                <COMMENT>&gt;= already introduced above, so not_equal used here</COMMENT>
              </CHANGE>
              <SNIPPET>
                <EXAMPLE>neq_example</EXAMPLE>
                <!-- \indcode*{>=} -->
                <JAVASCRIPT>
function not_equal(x, y) {
    return x &gt; y || x &lt; y;
}
                </JAVASCRIPT>
              </SNIPPET>
              or alternatively as
              <SNIPPET>
                <EXAMPLE>neq_example</EXAMPLE>
                <!-- \indcode*{>=} -->
                <JAVASCRIPT>
function not_equal(x, y) {
    return !(x &gt;= y &amp;&amp; x &lt;= y);
}
                </JAVASCRIPT>
              </SNIPPET>

              <SNIPPET HIDE="yes">
                <NAME>neq_example</NAME>
                <JAVASCRIPT>
not_equal(7, 4);
                </JAVASCRIPT>
              </SNIPPET>


              Note that the operator <JAVASCRIPTINLINE>!==</JAVASCRIPTINLINE> when applied 
              to two numbers, behaves the same as 
              <JAVASCRIPTINLINE>not_equal</JAVASCRIPTINLINE>.
            </TEXT>
          </JAVASCRIPT>
        </SPLIT>

        <EXERCISE>
        <SPLIT>
          <SCHEME>
            <TEXT>
                Below is a sequence of expressions.  
                <CHANGE>
                  Before you click on an expression,
                  predict what the result of its evaluation will be.
                </CHANGE>
                <CHANGE><OMISSION>Omitted:
                    <QUOTE>What is the result printed by the interpreter in response to each
                      expression?  Assume that the sequence is to be evaluated in the order
                      in which it is presented.</QUOTE>
                  </OMISSION>
                </CHANGE>
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
                Below is a sequence of statements. Before you click on a statement,
                predict what the result of its evaluation will be.
            </TEXT>
          </JAVASCRIPT>
        </SPLIT>

                  <SNIPPET>
                    <SCHEME>
10
                    </SCHEME>
                  <JAVASCRIPT>
10;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                    <SCHEME>
(+ 5 3 4)
                    </SCHEME>
                  <JAVASCRIPT>
5 + 3 + 4;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                    <SCHEME>
(- 9 1)
                    </SCHEME>
                  <JAVASCRIPT>
9 - 1;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                    <SCHEME>
(/ 6 2)
                    </SCHEME>
                  <JAVASCRIPT>
6 / 2;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                    <SCHEME>
(+ (* 2 4) (- 4 6))
                    </SCHEME>
                  <JAVASCRIPT>
2 * 4 + (4 - 6);
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                  <NAME>definea</NAME>
                    <SCHEME>
(define a 3)
                    </SCHEME>
                  <JAVASCRIPT>
const a = 3;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                  <NAME>defineb</NAME>
                  <REQUIRES>definea</REQUIRES>
                    <SCHEME>
(define b (+ a 1))
                    </SCHEME>
                  <JAVASCRIPT>
const b = a + 1;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                  <REQUIRES>defineb</REQUIRES>
                    <SCHEME>
(+ a b (* a b))
                    </SCHEME>
                  <JAVASCRIPT>
a + b + a * b;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                  <REQUIRES>defineb</REQUIRES>
                    <SCHEME>
(= a b)
                    </SCHEME>
                  <JAVASCRIPT>
a === b;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                  <REQUIRES>defineb</REQUIRES>
                    <SCHEME>
(if (and (> b a) (&lt; b (* a b)))
  b
  a)
                    </SCHEME>
                  <JAVASCRIPT>
b &gt; a &amp;&amp; b &lt; a * b 
   ? b : a;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                  <REQUIRES>defineb</REQUIRES>
                    <SCHEME>
(cond ((= a 4) 6)
  ((= b 4) (+ 6 7 a))
  (else 25))
                    </SCHEME>
                  <JAVASCRIPT>
a === 4 ? 6 : b === 4 ? 6 + 7 + a : 25;
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                  <REQUIRES>defineb</REQUIRES>
                    <SCHEME>
}
(+ 2 (if (> b a) b a))
                    </SCHEME>
                  <JAVASCRIPT>
2 + (b &gt; a ? b : a);
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET>
                  <REQUIRES>defineb</REQUIRES>
                    <SCHEME>
(* (cond ((> a b) a)
     ((&lt; a b) b)
     (else -1))
   (+ a 1))
                    </SCHEME>
                  <JAVASCRIPT>
(a &gt; b
 ? a
 : a &lt; b
   ? b
   : -1)
*
(a + 1);
                </JAVASCRIPT>
              </SNIPPET>
                <SPLIT>
                  <JAVASCRIPT>
                Note that the statement
                <SNIPPET>
                  <REQUIRES>defineb</REQUIRES>
                 <JAVASCRIPT>
a === 4 ? 6 : b === 4 ? 6 + 7 + a : 25;
                  </JAVASCRIPT>
                </SNIPPET>
                consists of two conditional expressions, where the second
                one forms the alternative of the first one. If you want
                to make that clear, you can indent the lines like this:
                <SNIPPET>
                  <REQUIRES>defineb</REQUIRES>
                  <JAVASCRIPT>
a === 4
? 6
: b === 4 
  ? 6 + 7 + a
  : 25;
                  </JAVASCRIPT>
                </SNIPPET>
                  </JAVASCRIPT>
                </SPLIT>
        </EXERCISE>

        <EXERCISE>
                Translate the following expression into 
          <SPLITINLINE>
          <SCHEME>
            prefix form
          </SCHEME>
          <JAVASCRIPT>
            JavaScript
          </JAVASCRIPT>
          </SPLITINLINE>
          <LATEX>
                    \[
                    \frac{5+4+\left(2-\left(3-(6+\frac{4}{5})\right)\right)}{3 (6-2) (2-7)}
                    \]
          </LATEX>
    <SOLUTION>   
    <SNIPPET>
    <JAVASCRIPT>
(5 + 4 + (2 - (3 - (6 + 4 / 5)))) 
/
(3 * (6 - 2) * (2 - 7));
    </JAVASCRIPT>
    </SNIPPET>
  </SOLUTION>
    </EXERCISE>
        <EXERCISE>
                <SPLITINLINE>
                  <SCHEME>
                Define a 
                    procedure
                  </SCHEME>
                  <JAVASCRIPT>
		    Declare a
                    function
                  </JAVASCRIPT>
                </SPLITINLINE>
                that takes three numbers as arguments and returns
                the sum of the squares of the two larger numbers.
                <SOLUTION>
                <SNIPPET>
                  <EXAMPLE>larger_two_square_example</EXAMPLE>
                  <REQUIRES>square_definition</REQUIRES>
                  <JAVASCRIPT>
function f(x, y, z) {
   return square(x) + square(y) + square(z) -
          // subtract the square of the smallest
          square(x > y ? (y > z ? z : y) : (x > z ? z : x));
}
                  </JAVASCRIPT>
                  <SCHEME>
(define (f x y z)
   (let ((smallest (if (&gt; x y) (if (&gt; y z) z y) (if (&gt; x z) z x))))
      (- (+ (square x) (square y) (square z)) (square smallest))))
                  </SCHEME>
                </SNIPPET>
              </SOLUTION>
                <SNIPPET HIDE="yes">
                  <NAME>larger_two_square_example</NAME>
                  <SCHEME>
(f 4 7 2)
                  </SCHEME>
                  <JAVASCRIPT>
f(4, 7, 2);
                  </JAVASCRIPT>
                </SNIPPET>
        </EXERCISE>

              <EXERCISE><LABEL NAME="ex:a-plus-abs-b"/>
        <SPLIT>
          <SCHEME>
                <INDEX>combination<SUBINDEX>compound expression as operator of</SUBINDEX></INDEX>
                <INDEX>compound expression<SUBINDEX>operator@as operator of combination</SUBINDEX></INDEX>
                <INDEX>operator of a combination<SUBINDEX>compound expression as</SUBINDEX></INDEX>
                Observe that our model of evaluation allows for combinations whose
                operators are compound expressions.  Use this observation to
                describe the behavior of the following procedure:
                <SNIPPET>
                  <SCHEME>
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
                  </SCHEME>
                </SNIPPET>
          </SCHEME>
          <JAVASCRIPT>
            <INDEX>combination<SUBINDEX>compound expression as operator of</SUBINDEX></INDEX>
            <INDEX>compound expression<SUBINDEX>operator@as operator of combination</SUBINDEX></INDEX>
            <INDEX>operator of a combination<SUBINDEX>compound expression as</SUBINDEX></INDEX>
            Observe that our model of evaluation allows for application
	    combinations whose
            function expressions are compound expressions.
	    Use this observation to
            describe the behavior of the following function:
                <SNIPPET>
                  <EXAMPLE>plusminusexample</EXAMPLE>
                  <JAVASCRIPT>
function plus(a, b) { return a + b; }
function minus(a, b) { return a - b; }
function a_plus_abs_b(a, b) {
    return (b >= 0 ? plus : minus)(a, b);
}
                  </JAVASCRIPT>
                </SNIPPET>
                <SNIPPET HIDE="yes">
                  <NAME>plusminusexample</NAME>
                  <JAVASCRIPT>
a_plus_abs_b(5, -4);
                  </JAVASCRIPT>
                </SNIPPET>
                Note that in the conditional expression, we cannot directly use the operators
                <JAVASCRIPTINLINE>+</JAVASCRIPTINLINE> and
                <JAVASCRIPTINLINE>-</JAVASCRIPTINLINE> instead of the
                names
                <JAVASCRIPTINLINE>plus</JAVASCRIPTINLINE> and
                <JAVASCRIPTINLINE>minus</JAVASCRIPTINLINE> because in infix notation,
		only operator symbols are allowed in the middle,
		not compound expressions.<FOOTNOTE>
                  For an expression of the form
                  <JAVASCRIPTINLINE>a (b > 0 ? + : -) b</JAVASCRIPTINLINE>
                  the JavaScript interpreter would not know the precedence of
		  the operator
                  between <JAVASCRIPTINLINE>a</JAVASCRIPTINLINE> and 
                  <JAVASCRIPTINLINE>b</JAVASCRIPTINLINE>, and therefore
		  such expressions are not allowed.</FOOTNOTE>
          </JAVASCRIPT>
	  <SOLUTION>
	    According to section <REF NAME="sec:substitution-model"/>, evaluation
	    of a application expression
	    proceeds as follows:
              <OL>
		<LI>Evaluate the function expression 
		of the application
		combination, resulting in the function to be applied.</LI>
                <LI>Evaluate the argument expressions of the combination.</LI>
                <LI>Evaluate the return expression of the function with each
		parameter replaced by the corresponding argument.
                </LI>
              </OL>
	      Thus the evaluation of the application expression 
	      <JAVASCRIPTINLINE>a_plus_abs_b(5, -4)</JAVASCRIPTINLINE>
	      (1) evaluates <JAVASCRIPTINLINE>a_plus_abs_b</JAVASCRIPTINLINE>,
	      resulting in the function given above, and (2) the arguments are
	      already values. So we need to evaluate (3) the return expression
	      of the function,
	      with the parameters replaced by the arguments, thus:
	      <JAVASCRIPTINLINE>(-4 >= 0 ? plus : minus)(5, -4)</JAVASCRIPTINLINE>.
	      With the same rules, we need to (1) evaluate the function expression,
	      which in this case is the conditional expression
	      <JAVASCRIPTINLINE>-4 >= 0 ? plus : minus</JAVASCRIPTINLINE>. Since
	      the predicate evaluates to <EM>false</EM>, the function expression
	      evaluates to <JAVASCRIPTINLINE>minus</JAVASCRIPTINLINE>.
	      The arguments, again (2) are already values.
	      Thus we
	      end up evaluating (3) the body of
	      <JAVASCRIPTINLINE>minus</JAVASCRIPTINLINE> with
	      the parameters
	      <JAVASCRIPTINLINE>a</JAVASCRIPTINLINE> and 
	      <JAVASCRIPTINLINE>b</JAVASCRIPTINLINE> 
	      replaced by 5 and -4, respectively, resulting in
	      <JAVASCRIPTINLINE>5 - (-4)</JAVASCRIPTINLINE>, which
	      will finally evaluate to 9.
	  </SOLUTION>
        </SPLIT>
              </EXERCISE>
        <EXERCISE>
                <LABEL NAME="ex:normal-order-vs-appl-order-test"/>
                <INDEX>normal-order evaluation<SUBINDEX>applicative order vs.</SUBINDEX></INDEX>
                <INDEX>applicative-order evaluation<SUBINDEX>normal order vs.</SUBINDEX></INDEX>
                Ben Bitdiddle has invented a test to determine whether the interpreter
                he is faced with is using applicative-order evaluation or normal-order
                evaluation.  He 
                <SPLITINLINE>
                  <SCHEME>
                    defines the following two procedures
                  </SCHEME>
                  <JAVASCRIPT>
                    declares the following two functions
                  </JAVASCRIPT>
                </SPLITINLINE>:
                <SNIPPET>
                  <NAME>ptest</NAME>
                  <SCHEME>
(define (p) (p))

(define (test x y)
  (if (= x 0)
    0
    y))
                  </SCHEME>
                  <JAVASCRIPT>
function p() {
    return p();
}

function test(x, y) {
    return x === 0 ? 0 : y;
}
                  </JAVASCRIPT>
                </SNIPPET>
                Then he evaluates the 
                <SPLITINLINE><SCHEME>expression</SCHEME><JAVASCRIPT>statement</JAVASCRIPT></SPLITINLINE>
                <SNIPPET>
                  <REQUIRES>ptest</REQUIRES>
                  <SCHEME>
(test 0 (p))
                  </SCHEME>
                  <JAVASCRIPT>
test(0, p());
                  </JAVASCRIPT>
                </SNIPPET>
                What behavior will Ben observe with an interpreter that uses
                applicative-order evaluation?  What behavior will he observe with an
                interpreter that uses normal-order evaluation?  Explain your answer.
                <INDEX>normal-order evaluation<SUBINDEX>if@of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
                <!-- \indsf{if}[normal-order evaluation of] -->
                (Assume that the evaluation rule for 
                <SPLITINLINE>
                  <SCHEME>
                    the special 
                    form <SCHEMEINLINE>if</SCHEMEINLINE> 
                  </SCHEME>
                  <JAVASCRIPT>
                    conditional expressions
                  </JAVASCRIPT>
                </SPLITINLINE>
                is the
                same whether the interpreter is using normal or applicative order:
                The predicate expression is evaluated first, and the result
                determines whether to evaluate
                the consequent or the alternative expression.)
		<SOLUTION>		
		  <SPLIT>
		    <JAVASCRIPT>
		      In applicative-order evaluation of
		      <JAVASCRIPTINLINE>test(0, p())</JAVASCRIPTINLINE>,
		      we need to evaluate the
		      argument expressions
		      before we can evaluate the return expression of
		      the function <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE>.
		      The evaluation of the argument expression
		      <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE>
		      will not terminate, however: It will keep evaluating
		      application expressions of the form 
		      <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE>, and thus
		      the evaluation of
                      <JAVASCRIPTINLINE>test(0, p())</JAVASCRIPTINLINE>
		      will not produce a legitimate value.
		      In normal-order evaluation, on the other hand,
		      the function application
		      <JAVASCRIPTINLINE>test(0, p())</JAVASCRIPTINLINE>
		      would immediately evaluate the return expression of
		      the function <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE>,
		      <JAVASCRIPTINLINE>x === 0 ? 0 : y</JAVASCRIPTINLINE>
		      after replacing the parameter
		      <JAVASCRIPTINLINE>x</JAVASCRIPTINLINE> with
		      <JAVASCRIPTINLINE>0</JAVASCRIPTINLINE> and
		      <JAVASCRIPTINLINE>y</JAVASCRIPTINLINE> with
		      <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE>.
		      The result of the replacing would be
		      <JAVASCRIPTINLINE>0 === 0 ? 0 : p()</JAVASCRIPTINLINE>.
		      The evaluation of the 
		      predicate
		      <JAVASCRIPTINLINE>0 === 0</JAVASCRIPTINLINE>
		      results in <EM>true</EM> and thus the conditional
		      expression evaluates to 0, without any need to
		      evaluate 
		      <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE>.
		    </JAVASCRIPT>
		  </SPLIT>
		</SOLUTION>
	</EXERCISE>
      </SUBSECTION>
