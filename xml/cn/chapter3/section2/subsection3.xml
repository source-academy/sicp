<SUBSECTION> 
   <NAME> 帧（作为局部状态的存储库） </NAME> 

  <LABEL NAME="sec:env-local-state"></LABEL>
   <INDEX>帧 (环境模型)<SUBINDEX>作为局部状态的存储库<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>局部状态<SUBINDEX>在帧中维护<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>求值的环境模型<SUBINDEX>局部状态<OPEN></OPEN></SUBINDEX></INDEX> 

  <TEXT> 
    我们可以通过环境模型来查看
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    和赋值如何用于表示具有局部状态的对象。例如，考虑通过调用<INDEX><USE>make_withdraw</USE><SUBINDEX><ORDER>environment</ORDER>在环境模型中<OPEN></OPEN></SUBINDEX></INDEX>创建的section<SPACE></SPACE><REF NAME="sec:local-state-variables"></REF>中的<QUOTE>取款处理器</QUOTE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
<SNIPPET EVAL="yes">
      <NAME>make_withdraw2</NAME>
      <SCHEME>
(define (make-withdraw balance)
  (lambda (amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;)))
      </SCHEME>
      <JAVASCRIPT>
function make_withdraw(balance) {
    return amount =&gt; {
               if (balance &gt;= amount) {
                   balance = balance - amount;
                   return balance;
               } else {
                   return &quot;insufficient funds&quot;;
               }
           };
}
      </JAVASCRIPT>
    </SNIPPET> 
    让我们描述一下求值
     <SNIPPET EVAL="yes">
      <REQUIRES>make_withdraw2</REQUIRES>
      <NAME>make_withdraw2_w1_declare</NAME>
      <SCHEME>
(define W1 (make-withdraw 100))
      </SCHEME>
      <JAVASCRIPT>
const W1 = make_withdraw(100);
      </JAVASCRIPT>
    </SNIPPET> 
    接着是
     <SNIPPET EVAL="yes">
      <NAME>make_withdraw2_w1_example</NAME>
      <REQUIRES>make_withdraw2_w1_declare</REQUIRES>
      <EXPECTED>50</EXPECTED>
      <SCHEME>
(W1 50)
      </SCHEME>
      <SCHEMEOUTPUT>
            50
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
W1(50);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
50
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
     <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:make-withdraw_scheme"></REF>
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:make-withdraw"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    显示了
    <SPLITINLINE>
      定义
      make-withdraw
      <JAVASCRIPT>声明
      <JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    在
    <SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境中的结果。这产生了一个包含对
    <SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境的指针的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    对象。到目前为止，这与我们已经看到的例子没有什么不同，除了
    <SPLITINLINE>
      
	过程体本身是一个
	lambda
	表达式。
      
      <JAVASCRIPT>
	函数体中的返回表达式本身是一个 
	lambda 表达式。
      </JAVASCRIPT>
    </SPLITINLINE>
 <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-7.svg"></FIGURE>
          <CAPTION>
	    在全局环境中定义make-withdraw的结果。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-7.svg"></FIGURE>
          <CAPTION>
	    在程序环境中定义<JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>的结果。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
   </TEXT>

  <TEXT> 
    计算的有趣部分发生在我们应用
    <SPLITINLINE>过程
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE>
      make-withdraw
      <JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    到一个参数：
     <SNIPPET EVAL="no">
      <SCHEME>
(define W1 (make-withdraw 100))
      </SCHEME>
      <JAVASCRIPT>
const W1 = make_withdraw(100);
      </JAVASCRIPT>
    </SNIPPET>  
    我们像往常一样开始，通过设置一个环境 E1，其中的
    <SPLITINLINE>形式</SPLITINLINE> 参数
<SCHEMEINLINE>balance</SCHEMEINLINE>  
    绑定到参数 100。在这个环境中，我们对
    <SPLITINLINE>
      make-withdraw,
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    的函数体进行求值，主要是对
    <SPLITINLINE>
      lambda 表达式。这
      <JAVASCRIPT>返回语句，其中返回表达式是
      一个 lambda 表达式。对这个 lambda 表达式的求值</JAVASCRIPT>
    </SPLITINLINE>
    构造一个新的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    对象，其代码如
    <SPLITINLINE>
      lambda
      <JAVASCRIPT>lambda 表达式</JAVASCRIPT>
    </SPLITINLINE>
    中所指定，其环境是 E1，也是在这个环境中
    <SPLITINLINE>
      lambda
      <JAVASCRIPT>lambda 表达式</JAVASCRIPT>
    </SPLITINLINE>
    被求值以生成
    <SPLITINLINE>
      过程。
      <JAVASCRIPT>函数。</JAVASCRIPT>
    </SPLITINLINE>
    由调用<SPLITINLINE>
      make-withdraw
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    返回的值就是这个结果
<SCHEMEINLINE>W1</SCHEMEINLINE>  
    在<SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境中，因为<SPLITINLINE>
      define
      <JAVASCRIPT>常量声明</JAVASCRIPT>
    </SPLITINLINE>
    本身正在<SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境中被求值。
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:w1_scheme"></REF>
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:w1"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    显示了最终的环境结构。
    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-8.svg"></FIGURE>
          <CAPTION>
	    在
	    (define W1 (make-withdraw 100))
	    上求值的结果。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-8.svg"></FIGURE>
          <CAPTION>
	    在
	    <JAVASCRIPTINLINE>const W1 = make_withdraw(100);</JAVASCRIPTINLINE>
	    上求值的结果。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
   </TEXT>

  <TEXT> 
    现在我们可以分析当 
<SCHEMEINLINE>W1</SCHEMEINLINE> 
    被应用于一个参数：
<SNIPPET EVAL="no">
      <SCHEME>
(W1 50)
      </SCHEME>
      <SCHEMEOUTPUT>
            50
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
W1(50);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
50
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>  
    我们开始构造一个帧，其中
<SCHEMEINLINE>amount</SCHEMEINLINE> ，
    <SPLITINLINE>形式</SPLITINLINE>参数 
<SCHEMEINLINE>W1</SCHEMEINLINE> ，被绑定到参数 50。需要注意的关键点是，这个帧的外围环境不是<SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境，而是环境 E1，因为这是由
<SCHEMEINLINE>W1</SCHEMEINLINE>
     
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    对象。在这个新环境中，我们对
    <SPLITINLINE>
      过程：
      <JAVASCRIPT>函数：</JAVASCRIPT>
    </SPLITINLINE>
    的主体进行求值。
<SNIPPET EVAL="no">
      <SCHEME>
(if (&gt;= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    &quot;Insufficient funds&quot;)
      </SCHEME>
      <JAVASCRIPT>
if (balance &gt;= amount) {
    balance = balance - amount;
    return balance;
} else {
    return &quot;insufficient funds&quot;;
}
      </JAVASCRIPT>
    </SNIPPET> 
    生成的环境结构如
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:apply-w1_scheme"></REF>.
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:apply-w1"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
    所示。正在求值的表达式引用了两个 
<SCHEMEINLINE>amount</SCHEMEINLINE> 
   和
<SCHEMEINLINE>balance</SCHEMEINLINE>.
     
    <SPLITINLINE>
      Amount
      <JAVASCRIPT>变量 <JAVASCRIPTINLINE>amount</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    将在该环境中的第一个帧中找到，并且
<SCHEMEINLINE>balance</SCHEMEINLINE>  
将在 E1 中通过跟随外层环境指针找到。
<SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-9.svg"></FIGURE>
          <CAPTION>
	    通过应用过程对象 W1 创建的环境。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-9.svg"></FIGURE>
          <CAPTION>
	    通过应用函数对象 <JAVASCRIPTINLINE>W1</JAVASCRIPTINLINE> 创建的环境。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
</TEXT>

  <TEXT> 
    当
    <SPLITINLINE>
      set!
      <JAVASCRIPT>赋值</JAVASCRIPT>
    </SPLITINLINE>
    被执行时，绑定
<SCHEMEINLINE>balance</SCHEMEINLINE> 在 E1 中被更改。 在调用结束时 
<SCHEMEINLINE>W1</SCHEMEINLINE>, <SCHEMEINLINE>balance</SCHEMEINLINE> 在 E1 中，50，包含的帧 <SCHEMEINLINE>balance</SCHEMEINLINE> 
仍然由
<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
对象指向 
<SCHEMEINLINE>W1</SCHEMEINLINE>  
仍然由包含的帧绑定。
<SCHEMEINLINE>amount</SCHEMEINLINE> ，绑定的帧（我们执行更改的代码） 
<SCHEMEINLINE>balance</SCHEMEINLINE> 
) 不再相关，因为构造它的<SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
调用已经结束，并且没有来自环境其他部分的指向该帧的指针。下一次 
<SCHEMEINLINE>W1</SCHEMEINLINE> 
被调用时，这将构建一个新的帧，该帧绑定 
<SCHEMEINLINE>amount</SCHEMEINLINE> 
并且其外层环境是 E1。我们看到 E1 作为持有
<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>
对象的局部状态变量的<QUOTE>位置</QUOTE> 
<SCHEMEINLINE>W1</SCHEMEINLINE>.
     
<SPLITINLINE>
  
	图<SPACE></SPACE><REF NAME="fig:after-w1_scheme"></REF>
  
  <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:after-w1"></REF>
  </JAVASCRIPT>
</SPLITINLINE>
显示了调用后的情况
<SCHEMEINLINE>W1</SCHEMEINLINE>.
     
<SPLITINLINE>
  
	图<SPACE></SPACE><REF NAME="fig:after-w1_scheme"></REF>
  
  <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:after-w1"></REF>
  </JAVASCRIPT>
</SPLITINLINE>
显示了调用后的情况
<SPLIT>
  
    <FIGURE>
      <FIGURE SRC="img_original/ch3-Z-G-10.svg"></FIGURE>
      <CAPTION>
	调用<SPLITINLINE>
      W1
      <JAVASCRIPT><JAVASCRIPTINLINE>W1</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    后的环境。
</CAPTION>
      
    </FIGURE>
  
  <JAVASCRIPT>
    <FIGURE>
      <FIGURE SRC="img_javascript/ch3-Z-G-10.svg"></FIGURE>
      <CAPTION>
	调用后产生的环境。
    </CAPTION>
      
    </FIGURE>
  </JAVASCRIPT>
</SPLIT>
</TEXT>

   <PDF_ONLY>\pagebreak</PDF_ONLY> 
  <LONG_PAGE LINES="2"></LONG_PAGE>
  <TEXT> 
观察创建第二个<QUOTE>取款</QUOTE>对象时会发生什么，通过再次调用
<SPLITINLINE>
  make_withdraw:
  <JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>:
  </JAVASCRIPT>
</SPLITINLINE>
<SNIPPET EVAL="yes">
      <REQUIRES>make_withdraw2</REQUIRES>
      <NAME>make_withdraw2_w2_declare</NAME>
      <EXPECTED>20</EXPECTED>
      <SCHEME>
(define W2 (make-withdraw 100))
      </SCHEME>
      <JAVASCRIPT>
const W2 = make_withdraw(100);	
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
const W1 = make_withdraw(100);
W1(50);
const W2 = make_withdraw(100);
W2(80);	
      </JAVASCRIPT_RUN>
    </SNIPPET> 
这产生了
<SPLITINLINE>
  
	图<SPACE></SPACE><REF NAME="fig:w2_scheme"></REF>,
  
  <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:w2"></REF>,
  </JAVASCRIPT>
</SPLITINLINE>
的环境结构，显示了
<SCHEMEINLINE>W2</SCHEMEINLINE> 是一个<SPLITINLINE>过程<JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>对象，即，一个包含一些代码和一个环境的对。环境 E2【152:8†cn.txt】<SCHEMEINLINE>W2</SCHEMEINLINE> 是由调用 <SPLITINLINE> make-withdraw. <JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>. </JAVASCRIPT> </SPLITINLINE> 创建的。它包含一个帧，其中具有自己的局部绑定 【156:0†cn.txt】。<SCHEMEINLINE>balance</SCHEMEINLINE> 
这产生了
<SPLITINLINE>
  
	图<SPACE></SPACE><REF NAME="fig:w2_scheme"></REF>,
  
  <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:w2"></REF>,
  </JAVASCRIPT>
</SPLITINLINE>
的环境结构，显示了它是一个包含一些代码和环境的<SPLITINLINE>
  过程
  <JAVASCRIPT>函数</JAVASCRIPT>
</SPLITINLINE>对象。环境 E2 是由调用 <SPLITINLINE> make-withdraw. <JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>. </JAVASCRIPT> </SPLITINLINE> 创建的。它包含一个帧，其中具有自己的局部绑定。另一方面， 【152:8†cn.txt】 【156:0†cn.txt】 【160:0†cn.txt】<SCHEMEINLINE>W1</SCHEMEINLINE> 和 <SCHEMEINLINE>W2</SCHEMEINLINE> 拥有相同代码：由 <SPLITINLINE> lambda <JAVASCRIPT>lambda</JAVASCRIPT> </SPLITINLINE> 在 <SPLITINLINE><SCENEINLINE>make-withdraw&lt;/SCHEMEINLINE&gt;</SCENEINLINE><JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> 的主体中指定的代码。这是一个实现细节，无论 W1 和 W2 是否共享计算机中相同的物理代码, 还是每个保留一份代码的副本。在我们在章节 <SPACE><REF NAME="chap:meta"></REF> 中实现的解释器中，代码实际上是共享的。在这里我们看到为什么【168:0†cn.txt】。</SPACE><SCHEMEINLINE>W1</SCHEMEINLINE> 具有相同的代码：即 <SPLITINLINE> lambda <JAVASCRIPT>lambda</JAVASCRIPT> </SPLITINLINE> <SPLITINLINE><SCENEINLINE>make-withdraw&lt;/SCHEMEINLINE&gt;</SCENEINLINE><JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> 主体中指定的代码。在章节 <SPACE><REF NAME="chap:meta"></REF> 中实现说明性知识通过共享方式来实现。这是一个实现细节，无论 W1 和 W2 是否共享代码 【172:0†cn.txt】。</SPACE><SCHEMEINLINE>W2</SCHEMEINLINE> 
作为独立对象行为。调用
<SCHEMEINLINE>W1</SCHEMEINLINE> 引用状态变量<SCHEMEINLINE>balance</SCHEMEINLINE> 存储在 E1，而引用 【184:0†cn.txt】。<SCHEMEINLINE>W2</SCHEMEINLINE> 引用 <SCHEMEINLINE>balance</SCHEMEINLINE> 存储在 E2。因此，一个对象的局部状态的变化不会影响另一个对象。
<SPLIT>
  
    <FIGURE>
      <FIGURE SRC="img_original/ch3-Z-G-11.svg"></FIGURE>
      <CAPTION>
        使用(define W2 (make-withdraw 100))来创建第二个对象。
      </CAPTION>
      
    </FIGURE>
  
  <JAVASCRIPT>
    <FIGURE>
      <FIGURE SRC="img_javascript/ch3-Z-G-11.svg"></FIGURE>
      <CAPTION>
        使用<JAVASCRIPTINLINE>const W2 = make_withdraw(100);</JAVASCRIPTINLINE>来创建第二个对象。
      </CAPTION>
      
    </FIGURE>
  </JAVASCRIPT>
</SPLIT>
</TEXT>
  <LONG_PAGE LINES="2"></LONG_PAGE>

  <EXERCISE>
    <LABEL NAME="ex:local-state-variable"></LABEL> 存储在 E2。因此，一个对象的局部状态的变化不会影响另一个对象。
<SPLIT>
  
    <FIGURE>
      <FIGURE SRC="img_original/ch3-Z-G-11.svg"></FIGURE>
      <CAPTION>
        使用(define W2 (make-withdraw 100))来创建第二个对象。
      </CAPTION>
      
    </FIGURE>
  
  <JAVASCRIPT>
    <FIGURE>
      <FIGURE SRC="img_javascript/ch3-Z-G-11.svg"></FIGURE>
      <CAPTION>
        使用<JAVASCRIPTINLINE>const W2 = make_withdraw(100);</JAVASCRIPTINLINE>来创建第二个对象。
      </CAPTION>
      
    </FIGURE>
  </JAVASCRIPT>
</SPLIT>
<SCHEMEINLINE>balance</SCHEMEINLINE> 
作为<SPLITINLINE>
  make-withdraw的参数创建。
  <JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>的参数创建。
  </JAVASCRIPT>
</SPLITINLINE>
我们也可以使用<SPLITINLINE>
  显式地
  <JAVASCRIPT>分别地，</JAVASCRIPT>
</SPLITINLINE>
使用<SPLITINLINE>
  let,
  <JAVASCRIPT>我们称为<INDEX>lambda 表达式<SUBINDEX>立即调用</SUBINDEX></INDEX><INDEX>立即调用 lambda 表达式</INDEX><EM>立即调用 lambda 表达式</EM></JAVASCRIPT>
</SPLITINLINE>
创建局部状态变量，如下所示：
<SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_withdraw</DECLARATION><SUBINDEX>using immediately invoked lambda expression</SUBINDEX><FRAGILE></FRAGILE></INDEX>
      <NAME>make_withdraw3</NAME>
      <EXAMPLE>make_withdraw3_example</EXAMPLE>
      <EXPECTED>20</EXPECTED>
      <SCHEME>
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
        (lambda (amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))))
      </SCHEME>
      <JAVASCRIPT>
function make_withdraw(initial_amount) {
    return (balance =&gt; 
              amount =&gt; {
                  if (balance &gt;= amount) {
                      balance = balance - amount;
                      return balance;
                   } else {
                      return &quot;insufficient funds&quot;;
                   }
              })(initial_amount);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_withdraw3_example</NAME>
      <JAVASCRIPT>
const W1 = make_withdraw(100);
W1(80);
      </JAVASCRIPT>
    </SNIPPET>
     
<SPLIT>
  
    回忆在章节<SPACE></SPACE><REF NAME="sec:lambda"></REF>中，<INDEX>let<SUBINDEX><ORDER>语法糖</ORDER>作为语法糖</SUBINDEX></INDEX><INDEX>let<SUBINDEX>求值模型</SUBINDEX></INDEX>let只是语法糖，类似于一个 <SPLITINLINE>过程<JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE> 的调用：
    
      
(let ((var exp)) body)
      
    
    被诠释为 
      
((lambda (var) body) exp)
      
     的替代语法。
  
  <JAVASCRIPT>
    外部 lambda 表达式在评估后立即调用。其唯一目的是创建一个局部变量<JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE>并将其初始化为<JAVASCRIPTINLINE>initial_amount</JAVASCRIPTINLINE>。
  </JAVASCRIPT>
</SPLIT>
使用环境模型来分析这个替代版本 【204:0†source】【204:5†source】【204:6†source】。<SCHEMEINLINE>make_withdraw</SCHEMEINLINE> ，绘制如上图像以说明交互 <SNIPPET EVAL="yes">
      <NAME>make_withdraw3_example_2</NAME>
      <REQUIRES>make_withdraw3</REQUIRES>
      <EXPECTED>20</EXPECTED>
      <SCHEME>
(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
      </SCHEME>
      <JAVASCRIPT>
const W1 = make_withdraw(100);

W1(50);
	
const W2 = make_withdraw(100);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
const W1 = make_withdraw(100);
W1(50);
const W2 = make_withdraw(100);
W2(80);
      </JAVASCRIPT_TEST>
    </SNIPPET> 
显示两个版本的
<SPLITINLINE>
  make-withdraw
  <JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE></JAVASCRIPT>
</SPLITINLINE>
创建具有相同行为的对象。这两个版本的环境结构有何不同？
<SOLUTION>
  <UL>
    <LI>黑色显示练习 3.10 中函数的环境结构</LI>
    <LI>绿色显示原始环境结构的差异（其中<JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>被替换为图 3.9 版本）</LI>
  </UL>
  <FIGURE SRC="img_javascript/ex3-10-solution.png">
    
  </FIGURE>
</SOLUTION>
</EXERCISE>

   <INDEX>帧 (环境模型)<SUBINDEX>作为局部状态的存储库<CLOSE></CLOSE></SUBINDEX></INDEX> 
   作为<SPLITINLINE>
  make-withdraw
  <JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE></JAVASCRIPT>
</SPLITINLINE>
的参数创建。我们也可以创建局部状态变量为<SPLITINLINE>
  显式地
  <JAVASCRIPT>分别地</JAVASCRIPT>
 </SPLITINLINE>
使用<SPLITINLINE>
  let
  <JAVASCRIPT>
    ,即<I>立即调用 lambda 表达式</I>
  </JAVASCRIPT>
</SPLITINLINE>
如下：

   <INDEX>求值的环境模型<SUBINDEX>局部状态<CLOSE></CLOSE></SUBINDEX></INDEX> 
   <INDEX><USE>make_withdraw</USE><SUBINDEX><ORDER>environment</ORDER>在环境模型中<CLOSE></CLOSE></SUBINDEX></INDEX> 
</SUBSECTION>
