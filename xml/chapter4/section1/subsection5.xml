    <SUBSECTION>
      <NAME>
  Data as Programs
      </NAME>

      <LABEL NAME="sec:data-as-programs"/>
      <INDEX>program<SUBINDEX>data@as data|(</SUBINDEX></INDEX>
      <INDEX>data<SUBINDEX>program@as program|(</SUBINDEX></INDEX>

      <TEXT>
  In thinking about a <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> program that evaluates <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> expressions, an
  analogy might be helpful.  One operational view of the meaning of a
  program is that a 
  <INDEX>program<SUBINDEX>abstract@as abstract machine</SUBINDEX></INDEX>
  program is a description of an abstract (perhaps
  infinitely large) machine.  For example, consider the familiar
  program to compute factorials:

  <SNIPPET >
    <SCHEME>
(define (factorial n)
   (if (= n 1)
       1
       (* (factorial (- n 1)) n)))
    </SCHEME>
  <JAVASCRIPT>
function factorial(n) {
    return n === 1
           ? 1
           : factorial(n - 1) * n;
}
</JAVASCRIPT>
  </SNIPPET>

      </TEXT>

      <TEXT>
  <!--  \indcode{factorial}[as an abstract machine] -->
  We may regard this program as the description of a machine containing
  parts that decrement, multiply, and test for equality, together with a
  two-position switch and another factorial machine. (The factorial
  machine is infinite because it contains another factorial machine
  within it.)  Figure<SPACE/><REF NAME="fig:fact-proc-as-machine"/> is a flow diagram for the
  factorial machine, showing how the parts are wired together.

  <FIGURE>
    <FIGURE src="img_original/ch4-Z-G-2.svg"></FIGURE>
    <LABEL NAME="fig:fact-proc-as-machine"/>
    <CAPTION>The factorial program, viewed as an abstract machine.
    </CAPTION>
  </FIGURE>
      </TEXT>

      <TEXT>
  <INDEX>evaluator<SUBINDEX>abstract@as abstract machine</SUBINDEX></INDEX>
  In a similar way, we can regard the evaluator as a very special
  machine that takes as input a description of a machine.  Given this
  input, the evaluator configures itself to emulate the machine
  described.  For example, if we feed our evaluator the definition of
  <SCHEMEINLINE>factorial</SCHEMEINLINE>, as shown in Figure<SPACE/><REF NAME="fig:eval-factorial"/>, the
  evaluator will be able to compute factorials.

  <SPLIT>
    <SCHEME>
      <FIGURE>
        <FIGURE src="img_original/ch4-Z-G-3.svg"></FIGURE>
        <LABEL NAME="fig:eval-factorial"/>
        <CAPTION>The evaluator emulating a factorial machine.
        </CAPTION>
      </FIGURE>
    </SCHEME>
    <JAVASCRIPT>
      <FIGURE>
        <FIGURE src="img_javascript/ch4-Z-G-3.svg"></FIGURE>
        <LABEL NAME="fig:eval-factorial"/>
        <CAPTION>The evaluator emulating a factorial machine.
        </CAPTION>
      </FIGURE>
    </JAVASCRIPT>
  </SPLIT>
      </TEXT>

      <TEXT>
  <INDEX>evaluator<SUBINDEX>universal@as universal machine</SUBINDEX></INDEX>
  <INDEX>universal machine</INDEX>
  From this perspective, our evaluator is seen to be a <EM>universal machine</EM>.
  It mimics other machines when these are described as 
  <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> 
  programs.<FOOTNOTE>The fact that the machines are described in 
    <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> 
    is inessential.  If we give our evaluator a 
    <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> 
    program that behaves as an evaluator for
    some other language, say C, the 
    <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> 
    evaluator will emulate the C
    evaluator, which in turn can emulate any machine described as a C
    program.  Similarly, writing a 
    <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> 
    evaluator in C produces a C
    program that can execute any 
    <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> 
    program.  The deep idea here is that
    any evaluator can emulate any other.  Thus, the notion of <QUOTE>what can
      in principle be computed</QUOTE> (ignoring practicalities of time and
    memory required) is independent of the language or the computer, and
    instead reflects an underlying notion of 
    <INDEX>computability</INDEX>
    <EM>computability</EM>.  This
    was first demonstrated in a clear way by 
    <INDEX>Turing, Alan M.</INDEX>
    Alan M. Turing (1912<ENDASH/>1954),
    whose 1936 paper laid the foundations for theoretical 
    <INDEX>computer science</INDEX>
    computer science.  In the paper, Turing presented a simple computational
    model<EMDASH/>now known as a 
    <INDEX>Turing machine</INDEX>
    <EM>Turing machine</EM><EMDASH/>and argued that any
    <QUOTE>effective process</QUOTE> can be formulated as a program for such a
    machine.  (This argument is known as the 
    <INDEX>Church-Turing thesis</INDEX>
    <EM>Church-Turing thesis</EM>.)
    Turing then implemented a universal machine, i.e., a Turing machine
    that behaves as an evaluator for Turing-machine programs.  He used
    this framework to demonstrate that there are well-posed problems that
    cannot be computed by Turing machines (see
    exercise<SPACE/><REF NAME="ex:halting-theorem"/>), and so by implication cannot be
    formulated as <QUOTE>effective processes.</QUOTE>  Turing went on to make
    fundamental contributions to practical computer science as well.  For
    example, he invented the idea of 
    <INDEX>program<SUBINDEX>structured with subroutines</SUBINDEX></INDEX>
    structuring programs using
    general-purpose subroutines.  See 
    <INDEX>Hodges, Andrew</INDEX>
    <CITATION>Hodges 1983</CITATION> for a biography of
    Turing.</FOOTNOTE>
      </TEXT>

      <TEXT>
  This is striking. Try to imagine an analogous evaluator for electrical
  circuits.  This would be a circuit that takes as input a signal
  encoding the plans for some other circuit, such as a filter.  Given
  this input, the circuit evaluator would then behave like a filter with
  the same description.  Such a universal electrical circuit is
  almost unimaginably complex.  It is remarkable that the program
  evaluator is a rather simple program.<FOOTNOTE>Some people find it
    counterintuitive that an evaluator, which is implemented by a
    relatively simple
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, 
    can emulate programs that are more
    complex than the evaluator itself.  The existence of a universal
    evaluator machine is a deep and wonderful property of computation.
    <INDEX>recursion theory</INDEX>
    <EM>Recursion theory</EM>, a branch of mathematical logic, is concerned
    with logical limits of computation.  
    <INDEX>Hofstadter, Douglas R.</INDEX>
    Douglas Hofstadter<APOS/>s beautiful
    book <EM>G<OUML_LOWER/>del, Escher, Bach</EM> (1979) 
    explores some of these ideas.</FOOTNOTE>
      </TEXT>

      <TEXT>
  Another striking aspect of the evaluator is that it acts as a bridge
  between the data objects that are manipulated by our programming
  language and the programming language itself.  Imagine that the
  evaluator program (implemented in 
  <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE>) 
  is running, and that a user is
  typing expressions to the evaluator and observing the results.
  From
  the perspective of the user, an input expression such as 
  <SPLITINLINE><SCHEME><SCHEMEINLINE>(* x x)</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>x * x</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
  is an expression in the programming language, which the evaluator
  should execute.
  <SPLITINLINE>
    <SCHEME>
      From the perspective of the evaluator, however, the
      expression is simply a list (in this case, a list of three symbols:
      <SCHEMEINLINE>*</SCHEMEINLINE>, <SCHEMEINLINE>x</SCHEMEINLINE>, 
      and <SCHEMEINLINE>x</SCHEMEINLINE>) that is to be manipulated according to
      a well-defined set of rules.
    </SCHEME>
    <JAVASCRIPT>
      From the perspective of the evaluator, however, the
      expression is simply a string or<EMDASH/>after parsing<EMDASH/>a
      tagged-object representation
      that is to be manipulated according to
      a well-defined set of rules.
    </JAVASCRIPT>
  </SPLITINLINE>
      </TEXT>

      <SPLIT>
	<SCHEME>
      <TEXT>
  That the user<APOS/>s programs are the evaluator<APOS/>s data need not be a source
  of confusion.  In fact, it is sometimes convenient to ignore this
  distinction, and to give the user the ability to explicitly evaluate a
  data object as a <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> expression, by making <SCHEMEINLINE>eval</SCHEMEINLINE> available for
  use in programs.  Many <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> dialects provide a 
  <!-- \indprim*{eval}-->
  <!-- 
      \ind*{primitive
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[eval@<SCHEMEINLINE>eval</SCHEMEINLINE> (<EM>ns</EM>)]
      -->
  primitive <SCHEMEINLINE>eval</SCHEMEINLINE>
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  that takes as arguments an expression and an environment and
  evaluates the expression relative to the environment.<FOOTNOTE>Warning:
    <!-- \indcodeplus{eval}{(metacircular)}[primitive <SCHEMEINLINE>eval</SCHEMEINLINE> vs.]-->
    This <SCHEMEINLINE>eval</SCHEMEINLINE> primitive is not
    identical to the <SCHEMEINLINE>eval</SCHEMEINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    we implemented in
    section<SPACE/><REF NAME="sec:core-of-evaluator"/>, because it uses <EM>actual</EM>
    Scheme environments rather than the sample environment structures we
    built in section<SPACE/><REF NAME="sec:eval-data-structures"/>.  These actual
    environments cannot be manipulated by the user as ordinary lists; they
    must be accessed via <SCHEMEINLINE>eval</SCHEMEINLINE> or other special operations.
    <!-- \indcodeplus{apply}{(metacircular)}[primitive <SCHEMEINLINE>apply</SCHEMEINLINE> vs.]-->
    Similarly, the <SCHEMEINLINE>apply</SCHEMEINLINE> primitive we saw earlier is not identical
    to the metacircular <SCHEMEINLINE>apply</SCHEMEINLINE>, because it uses actual Scheme
    <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    rather than the
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    objects we constructed in
    sections<SPACE/><REF NAME="sec:eval-data-structures"/> and<SPACE/><REF NAME="sec:running-eval"/>.</FOOTNOTE>
  Thus,

  <SNIPPET>
    <SCHEME>
(eval '(* 5 5) user-initial-environment)
    </SCHEME>
  </SNIPPET>
  and
  <SNIPPET>
    <SCHEME>
(eval (cons '* (list 5 5)) user-initial-environment)
    </SCHEME>
  </SNIPPET>
  
  will both return 25.<FOOTNOTE>The MIT
    <INDEX>MIT Scheme<SUBINDEX>eval@<SCHEMEINLINE>eval</SCHEMEINLINE></SUBINDEX></INDEX>
    <INDEX>MIT Scheme<SUBINDEX>user-initial-environment@<SCHEMEINLINE>user-initial-environment</SCHEMEINLINE></SUBINDEX></INDEX>
    <!-- \indprim{eval}[MIT Scheme]-->
    <!-- \indcodeplus*{user-initial-environment}{(MIT Scheme)}-->
    implementation of Scheme includes <SCHEMEINLINE>eval</SCHEMEINLINE>, 
    as well as a symbol 
    <SCHEMEINLINE>user-initial-environment</SCHEMEINLINE>
    that is bound to the initial environment in
    which the user<APOS/>s input expressions are evaluated.<LABEL NAME="foot:mit-eval"/></FOOTNOTE>
  <INDEX>program<SUBINDEX>data@as data|)</SUBINDEX></INDEX>
  <INDEX>data<SUBINDEX>program@as program|)</SUBINDEX></INDEX>
      </TEXT>
	</SCHEME>
	<JAVASCRIPT>
      <TEXT>
  That the user<APOS/>s programs are the evaluator<APOS/>s data need not be a source
  of confusion.  In fact, it is sometimes convenient to ignore this
  distinction, and to give the user the ability to explicitly evaluate a
  string as a JavaScript expression, using JavaScript's primitive function
  <SCHEMEINLINE>eval</SCHEMEINLINE>
  that takes as argument a string. It parses the string and<EMDASH/>provided
  that it syntactically correct<EMDASH/>evaluates the resulting representation
  in the environment in which <SCHEMEINLINE>eval</SCHEMEINLINE> is
  applied.<FOOTNOTE>Warning:
    <!-- \indcodeplus{eval}{(metacircular)}[primitive <SCHEMEINLINE>eval</SCHEMEINLINE> vs.]-->
    This <SCHEMEINLINE>eval</SCHEMEINLINE> primitive is not
    identical to the <SCHEMEINLINE>evaluate</SCHEMEINLINE>
    function we implemented in
    section<SPACE/><REF NAME="sec:core-of-evaluator"/>, because it
    uses <EM>actual</EM> JavaScript environments rather than the sample environment
    structures we
    built in section<SPACE/><REF NAME="sec:eval-data-structures"/>.  These actual
    environments cannot be manipulated by the user as ordinary lists; they
    must be accessed via <SCHEMEINLINE>eval</SCHEMEINLINE> or other special
    operations.
    <!-- \indcodeplus{apply}{(metacircular)}[primitive <SCHEMEINLINE>apply</SCHEMEINLINE> vs.]-->
    Similarly, the <SCHEMEINLINE>apply</SCHEMEINLINE> primitive we saw
    in section<SPACE/><REF NAME="sec:data-directed"/> is not identical
    to the metacircular <SCHEMEINLINE>apply</SCHEMEINLINE>, because it uses
    actual JavaScript functions
    rather than the function
    objects we constructed in
    sections<SPACE/><REF NAME="sec:eval-data-structures"/>
    and<SPACE/><REF NAME="sec:running-eval"/>.</FOOTNOTE>
  <INDEX>program<SUBINDEX>data@as data|)</SUBINDEX></INDEX>
  <INDEX>data<SUBINDEX>program@as program|)</SUBINDEX></INDEX>
      </TEXT>
	</JAVASCRIPT>
      </SPLIT>
	
      <EXERCISE>
  <INDEX>halting problem</INDEX>
  Given a one-argument
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>p</SCHEMEINLINE> and an object <SCHEMEINLINE>a</SCHEMEINLINE>, <SCHEMEINLINE>p</SCHEMEINLINE>
  is said to <QUOTE>halt</QUOTE> on <SCHEMEINLINE>a</SCHEMEINLINE> if evaluating
  the expression
  <SPLITINLINE><SCHEME><SCHEMEINLINE>(p a)</SCHEMEINLINE></SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>p(a)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
  returns a value (as opposed to terminating with an error message
  or running forever).  Show that it is impossible to write a
  <SPLITINLINE><SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SPLITINLINE><SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE></SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE></JAVASCRIPT>
  </SPLITINLINE>
  that correctly determines whether <SCHEMEINLINE>p</SCHEMEINLINE>
  halts on <SCHEMEINLINE>a</SCHEMEINLINE> for any
  <SPLITINLINE><SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>p</SCHEMEINLINE> and object <SCHEMEINLINE>a</SCHEMEINLINE>.
  Use the following
  reasoning: If you had such a
  <SPLITINLINE><SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SPLITINLINE><SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE>,</SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE>,</JAVASCRIPT>
  </SPLITINLINE>
  you could implement the following program:
  <SNIPPET EVAL="no">
    <SCHEME>
(define (run-forever) (run-forever))

(define (try p)
   (if (halts? p p)
      (run-forever)
      'halted))
    </SCHEME>
    <JAVASCRIPT>
function run_forever() {
    return run_forever();      
}
function try(p) {
    return halts(p, p) 
           ? run_forever();
           : "halted";
}
    </JAVASCRIPT>
  </SNIPPET>
  Now consider evaluating the expression
  <SPLITINLINE><SCHEME><SCHEMEINLINE>(try try)</SCHEMEINLINE></SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>try(try)</JAVASCRIPTINLINE></JAVASCRIPT>
  </SPLITINLINE>
  and show that
  any possible outcome (either halting or running forever) violates the
  intended behavior of
  <SPLITINLINE><SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.<FOOTNOTE>Although we stipulated that
  <SPLITINLINE><SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE></SCHEME>
  <JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE></JAVASCRIPT>
</SPLITINLINE>
  is given a
  <SPLITINLINE><SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    object,
    notice that this reasoning still applies even if
    <SPLITINLINE><SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    can gain access to the
    <SPLITINLINE><SCHEME>procedure<APOS/>s</SCHEME>
    <JAVASCRIPT>function<APOS/>s</JAVASCRIPT></SPLITINLINE>
    text and its environment.
    <INDEX>Turing, Alan M.</INDEX><INDEX>Halting Theorem</INDEX>
    <INDEX>non-computable</INDEX><INDEX>computability</INDEX>
    This is Turing<APOS/>s celebrated <EM>Halting Theorem</EM>, which gave
    the first clear example of a <EM>non-computable</EM> problem, i.e., a
    well-posed task that cannot be carried out as a computational
    <SPLITINLINE><SCHEME>procedure.</SCHEME>
    <JAVASCRIPT>function.</JAVASCRIPT></SPLITINLINE>
  </FOOTNOTE>
  <LABEL NAME="ex:halting-theorem"/>
      </EXERCISE>
      <INDEX>metacircular evaluator for Scheme|)</INDEX>

    </SUBSECTION>
