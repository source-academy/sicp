<SUBSECTION>
  <LABEL NAME="sec:black-box"></LABEL>
  <NAME>
    <SPLITINLINE>
      
        Procedures
      
      <JAVASCRIPT>
        Functions
      </JAVASCRIPT>
    </SPLITINLINE>
    as Black-Box Abstractions
  </NAME>

  <SHORT_PAGE LINES="2"></SHORT_PAGE>
  <TEXT>
    <SPLITINLINE>
      Sqrt
      <JAVASCRIPT>
	The function <JAVASCRIPTINLINE>sqrt</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is our first example of a process defined by a set of mutually 
    <SPLITINLINE>
      defined procedures.
      <JAVASCRIPT>defined functions.</JAVASCRIPT>
    </SPLITINLINE>
    Notice that the 
    <SPLITINLINE>
      definition of sqrt-iter
      <JAVASCRIPT>declaration of
      <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is
    <SPLITINLINE>
      
	<INDEX>recursive procedure<SUBINDEX>recursive procedure definition</SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX>recursive function<SUBINDEX>recursive function declaration</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <EM>recursive</EM>; that is, the
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    is defined in terms of itself.  The idea of being able to define a
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    in terms of itself may be disturbing; it may seem unclear how such a
    <QUOTE>circular</QUOTE> definition could make sense at all, much less
    specify a well-defined process to be carried out by a computer.  This will
    be addressed more carefully in
    section<SPACE></SPACE><REF NAME="sec:procedures-and-processes"></REF>.  But first
    let<APOS></APOS>s consider some other important points illustrated by the
    sqrt example.
  </TEXT>
  <TEXT>
    Observe that the problem of computing square roots breaks up naturally
    into a number of subproblems:
    <INDEX>program<SUBINDEX>structure of</SUBINDEX></INDEX>
    how to tell whether a guess is good
    enough, how to improve a guess, and so on.  Each of these tasks is
    accomplished by a separate
    <SPLITINLINE>
      procedure.
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    The entire sqrt program can be viewed as a
    cluster of
    <SPLITINLINE>
      
        procedures
	(shown in figure<SPACE></SPACE><REF NAME="fig:sqrt-decomposition"></REF>)
      
      <JAVASCRIPT>
        functions
	(shown in figure<SPACE></SPACE><REF NAME="fig:sqrt-decomposition_new"></REF>)
      </JAVASCRIPT>
    </SPLITINLINE>
    that mirrors the decomposition of the problem into subproblems.
  </TEXT>
  <SPLIT>
    
      <FIGURE WEB_SCALE="0.6" SRC="img_original/ch1-Z-G-6.svg">
        <LABEL NAME="fig:sqrt-decomposition"></LABEL>
        <CAPTION>Procedural decomposition of the
	sqrt program.
        </CAPTION>
      </FIGURE>
    
    <JAVASCRIPT>
      <FIGURE>
        <FIGURE WEB_SCALE="0.6" SRC="img_javascript/ch1-Z-G-6.svg"></FIGURE>
        <LABEL NAME="fig:sqrt-decomposition_new"></LABEL>
        <CAPTION>Functional decomposition of the
        <JAVASCRIPTINLINE>sqrt</JAVASCRIPTINLINE> program.
        </CAPTION>
      </FIGURE>
    </JAVASCRIPT>
  </SPLIT>
  <TEXT>
    The importance of this
    <INDEX>decomposition of program into parts</INDEX>
    decomposition strategy is not simply that one
    is dividing the program into parts.  After all, we could take any
    large program and divide it into parts<EMDASH></EMDASH>the first ten lines, the next
    ten lines, the next ten lines, and so on.  Rather, it is crucial that
    each
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    accomplishes an identifiable task that can be used as a module in defining
    other
    <SPLITINLINE>
      procedures.
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      
	<INDEX>procedure<SUBINDEX><ORDER>black</ORDER>as black box<OPEN></OPEN></SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX><ORDER>black</ORDER>as black box<OPEN></OPEN></SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    For example, when we define the	      
    <SPLITINLINE>
      
        good-enough? procedure
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE> function
      </JAVASCRIPT>
    </SPLITINLINE>
    in terms of square, we are able to
    regard the square
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    as a
    <INDEX>black box</INDEX>
    <QUOTE>black box.</QUOTE>  We are not at that moment concerned with
    <EM>how</EM> the
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    computes its result, only with the fact <EM>that</EM> it computes the
    square.  The details of how the square is computed can be suppressed,
    to be considered at a later time.  Indeed, as far as the
    <SPLITINLINE>
      
        good-enough? procedure
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE> function
      </JAVASCRIPT>
    </SPLITINLINE>
    is concerned, square is not quite a
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    but rather an abstraction of a
    <SPLITINLINE>
      procedure,
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    a so-called
    <SPLITINLINE>
      
        <INDEX>procedural abstraction</INDEX>
        <INDEX>abstraction<SUBINDEX>procedural</SUBINDEX></INDEX>
        <EM>procedural abstraction</EM>.
      
      <JAVASCRIPT>
        <INDEX>functional abstraction</INDEX>
        <INDEX>abstraction<SUBINDEX>functional</SUBINDEX></INDEX>
        <EM>functional abstraction</EM>.
      </JAVASCRIPT>
    </SPLITINLINE>
    At this level of abstraction, any
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    that computes the square is equally good.
  </TEXT>
  <TEXT>
    Thus, considering only the values they return, the following two
    <SPLITINLINE>
      
        procedures
      
      <JAVASCRIPT>
        functions
      </JAVASCRIPT>
    </SPLITINLINE>
    squaring a number should be indistinguishable. Each takes a numerical
    argument and produces the square of that number as the value.<FOOTNOTE>It
    is not even clear which of these
    <SPLITINLINE>
      
        procedures
      
      <JAVASCRIPT>
        functions
      </JAVASCRIPT>
    </SPLITINLINE>
    is a more efficient implementation.  This depends upon the hardware
    available.  There are machines for which the <QUOTE>obvious</QUOTE>
    implementation is the less efficient one.  Consider a machine that has
    extensive tables of logarithms and antilogarithms stored in a very
    efficient manner.</FOOTNOTE>
    <SNIPPET>
      <EXAMPLE>square_example</EXAMPLE>
      
(define (square x) (* x x))
      
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <EXAMPLE>square_example</EXAMPLE>
      
(define (square x)
  (exp (double (log x))))

(define (double x) (+ x x))
      
      <JAVASCRIPT>
function square(x) {
    return math_exp(double(math_log(x)));
}
function double(x) {
    return x + x;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    So a
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    should be able to suppress detail.  The users of the
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    may not have written the
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    themselves, but may have obtained it from another programmer as a
    black box. A user should not need to know how the
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    is implemented in order to use it.
    <SPLITINLINE>
      
	<INDEX>procedure<SUBINDEX><ORDER>black</ORDER>as black box<CLOSE></CLOSE></SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX><ORDER>black</ORDER>as black box<CLOSE></CLOSE></SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <SUBHEADING>
    <NAME>Local names</NAME>
  </SUBHEADING>

  <INDEX>local name<OPEN></OPEN></INDEX>

  <TEXT>
    One detail of a
    <SPLITINLINE>
      procedure<APOS></APOS>s
      <JAVASCRIPT>function<APOS></APOS>s</JAVASCRIPT>
    </SPLITINLINE>
    implementation that should not matter to the user of the
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    is the implementer<APOS></APOS>s choice of names for the
    <SPLITINLINE>
      procedure<APOS></APOS>s formal parameters.
      <JAVASCRIPT>function<APOS></APOS>s parameters.</JAVASCRIPT>
    </SPLITINLINE>
    Thus, the following
    <SPLITINLINE>
      
        procedures
      
      <JAVASCRIPT>
        functions
      </JAVASCRIPT>
    </SPLITINLINE>
    should not be distinguishable:
    <SNIPPET>
      <EXAMPLE>square_example</EXAMPLE>
      
(define (square x) (* x x))
      
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <EXAMPLE>square_example</EXAMPLE>
      
(define (square y) (* y y))
      
      <JAVASCRIPT>
function square(y) {
    return y * y;
}
      </JAVASCRIPT>
    </SNIPPET>
    This principle<EMDASH></EMDASH>that the meaning of a
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    should be independent of the parameter names used by its
    author<EMDASH></EMDASH>seems on the surface to be self-evident, but its
    consequences are profound.  The simplest consequence is that the
    parameter names of a
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    must be local to the body of the
    <SPLITINLINE>
      
        procedure.
      
      <JAVASCRIPT>
        function.
      </JAVASCRIPT>
    </SPLITINLINE>
    For example, we used square 
    <SPLITINLINE>
      
	in the definition of	      
        good-enough?
      
      <JAVASCRIPT>
	in the declaration of	      
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    in our square-root
    <SPLITINLINE>
      
        procedure:
      
      <JAVASCRIPT>
        function:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <EXAMPLE>is_good_enough_example</EXAMPLE>
      <REQUIRES>abs_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      
(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
      
      <JAVASCRIPT>
function is_good_enough(guess, x) {
    return abs(square(guess) - x) &lt; 0.001;
}
      </JAVASCRIPT>
    </SNIPPET>
    The intention of the author of
    <SPLITINLINE>
      
        good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is to determine if the square of the first argument is within a given
    tolerance of the second argument.  We see that the author of
    <SPLITINLINE>
      
        good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    used the name guess to refer to the
    first argument and x to refer to the
    second argument.  The argument of square
    is guess.  If the author of
    square used x
    (as above) to refer to that argument, we see that the
    x in
    <SPLITINLINE>
      
        good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_@good_@enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    must be a different x than the one
    in  square. Running the
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    square must not affect the value
    of x that is used by
    <SPLITINLINE>
      
	good-enough?,
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    because that value of x may be needed by
    <SPLITINLINE>
      
        good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    after square is done computing.
  </TEXT>
  <TEXT>
    If the parameters were not local to the bodies of their respective
    <SPLITINLINE>
      procedures,
      <JAVASCRIPT>functions,</JAVASCRIPT>
    </SPLITINLINE>
    then the parameter x in
    square could be confused with the parameter
    x in
    <SPLITINLINE>
      
	good-enough?,
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>is_@good_@enough</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
      </SPLITINLINE>
    and the behavior of
    <SPLITINLINE>
      
        good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    would depend upon which version of square
    we used.  Thus, square would not be the
    black box we desired.
  </TEXT>
  <TEXT>
    A     
    <INDEX>parameters<SUBINDEX>names of</SUBINDEX></INDEX>
    <INDEX>name<SUBINDEX><ORDER>parameter</ORDER>of a parameter</SUBINDEX></INDEX>
    <SPLITINLINE>
      
	formal parameter of a procedure
      
      <JAVASCRIPT>
	parameter of a function
      </JAVASCRIPT>
    </SPLITINLINE>
    has a very special role in the
    <SPLITINLINE>
      
        procedure definition, 
      
      <JAVASCRIPT>
        function declaration,
      </JAVASCRIPT>
    </SPLITINLINE>
    in that it doesn<APOS></APOS>t matter what name the
    <SPLITINLINE>
      
	formal
      
      <JAVASCRIPT>
      </JAVASCRIPT>
    </SPLITINLINE>
    parameter has.  Such a name is called
    <SPLITINLINE>
      
	<INDEX>bound variable</INDEX>
	<INDEX>variable<SUBINDEX>bound</SUBINDEX></INDEX>
	a <EM>bound variable</EM>, and we say that the procedure definition
      
      <JAVASCRIPT>
	<INDEX>bound name</INDEX>
	<INDEX>name<SUBINDEX>bound</SUBINDEX></INDEX>
	<EM>bound</EM>, and we say that the function declaration
      </JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>bind</INDEX>
    <EM>binds</EM> its
    <SPLITINLINE>
      
	formal parameters.
      
      <JAVASCRIPT>
	parameters.
      </JAVASCRIPT>
    </SPLITINLINE>
    The meaning of a
    <SPLITINLINE>
      
        procedure definition is unchanged if a bound variable
      
      <JAVASCRIPT>
        function declaration is unchanged if a bound name
      </JAVASCRIPT>
    </SPLITINLINE>
    is consistently renamed throughout the
    <SPLITINLINE>definition<JAVASCRIPT>declaration</JAVASCRIPT></SPLITINLINE>.<FOOTNOTE>The
    concept of consistent renaming is actually subtle and difficult to
    define formally.  Famous logicians have made embarrassing errors
    here.</FOOTNOTE>
    If a
    <SPLITINLINE>
      variable
      <JAVASCRIPT>name</JAVASCRIPT>
    </SPLITINLINE>
    is not bound, we say that it is
    <SPLITINLINE>
      
	<INDEX>free variable</INDEX>
	<INDEX>variable<SUBINDEX>free</SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX>free name</INDEX>
	<INDEX>name<SUBINDEX>free</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <EM>free</EM>.  The set of
    <SPLITINLINE>
      expressions
      <JAVASCRIPT>statements</JAVASCRIPT>
    </SPLITINLINE>
    for which a binding
    <SPLITINLINE>
      defines
      <JAVASCRIPT>declares</JAVASCRIPT>
    </SPLITINLINE>
    a name is called the
    <SPLITINLINE>
      
	<INDEX>scope of a variable</INDEX>
	<INDEX>variable<SUBINDEX>scope of</SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX>scope of a name</INDEX>
	<INDEX>name<SUBINDEX>scope of</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <EM>scope</EM> of that name. In a
    <SPLITINLINE>
      
        procedure definition, the bound variables
      
      <JAVASCRIPT>
        function declaration, the bound names
      </JAVASCRIPT>
    </SPLITINLINE>
    declared as the
    <SPLITINLINE>
      
	<INDEX>formal parameters<SUBINDEX>scope of</SUBINDEX></INDEX>
	<INDEX>procedure<SUBINDEX>scope of formal parameters</SUBINDEX></INDEX>
	<INDEX>scope of a variable<SUBINDEX>procedure<APOS></APOS>s formal parameters</SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX>parameters<SUBINDEX>scope of</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>scope of parameters</SUBINDEX></INDEX>
	<INDEX>scope of a name<SUBINDEX>function<APOS></APOS>s parameters</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      
        formal parameters of the procedure
      
      <JAVASCRIPT>
        parameters of the function
      </JAVASCRIPT>
    </SPLITINLINE>
    have the body of the
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    as their scope.
  </TEXT>
  <TEXT>
    In the
    <SPLITINLINE>
      
	definition of good-enough?
      
      <JAVASCRIPT>
	declaration of <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    above,
    guess and
    x are
    bound
    <SPLITINLINE>
      
	variables
      
      <JAVASCRIPT>
	names
      </JAVASCRIPT>
    </SPLITINLINE>
    but
    <SPLITINLINE>
      
	&lt;,
        -,
      
    </SPLITINLINE>
    abs
    and square are free.
    The meaning of
    <SPLITINLINE>
      
	good-enough?
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    should be independent of the names we choose for
    guess and
    x so long as they are distinct and
    different from
    <SPLITINLINE>
      
	&lt;,
        -,
      
    </SPLITINLINE>
    abs
    and square.  (If we renamed
    guess to
    abs we would have introduced a bug by
    <SPLITINLINE>
      
	<INDEX>capturing a free variable</INDEX>
	<INDEX>bug<SUBINDEX>capturing a free variable</SUBINDEX></INDEX>
	<INDEX>free variable<SUBINDEX>capturing</SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX>capturing a free name</INDEX>
	<INDEX>bug<SUBINDEX>capturing a free name</SUBINDEX></INDEX>
	<INDEX>free name<SUBINDEX>capturing</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <EM>capturing</EM> the
    <SPLITINLINE>
      
	variable
      
      <JAVASCRIPT>
	name
      </JAVASCRIPT>
    </SPLITINLINE>
    abs.
    It would have changed from free to bound.)  The meaning of
    <SPLITINLINE>
      
	good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>	      
      </JAVASCRIPT>
    </SPLITINLINE>
    is not independent of the 
    <SPLITINLINE>
      
	names of its free variables,
      
      <JAVASCRIPT>
	choice of its free names,
      </JAVASCRIPT>
    </SPLITINLINE>
    however. It surely depends upon the fact
    <SPLITINLINE>
      
	(external to this definition)
      
      <JAVASCRIPT>
	(external to this declaration)
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      
	that the symbol abs names a procedure
      
      <JAVASCRIPT>
	that the name abs refers to a function
      </JAVASCRIPT>
    </SPLITINLINE>
    for computing the absolute value of a number.
    <SPLITINLINE>
      
        Good-enough? 
      
      <JAVASCRIPT>
	The function <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE> 
      </JAVASCRIPT>
    </SPLITINLINE>
    will compute a different function if we substitute
    <SPLITINLINE>
      
        cos
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>math_cos</JAVASCRIPTINLINE>
	(the primitive cosine function)
      </JAVASCRIPT>
    </SPLITINLINE>
    for abs in its
    <SPLITINLINE>
      
	definition.
      
      <JAVASCRIPT>
	declaration.
      </JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>local name<CLOSE></CLOSE></INDEX>
  </TEXT>

  <SUBHEADING>
    <NAME>Internal
    <SPLITINLINE>
      definitions
      <JAVASCRIPT>declarations</JAVASCRIPT>
    </SPLITINLINE>
    and block structure</NAME>
  </SUBHEADING>
  <LABEL NAME="sec:block-structure"></LABEL>

  <SHORT_PAGE LINES="3"></SHORT_PAGE>
  <TEXT>
    We have one kind of name isolation available to us so far:
    <SPLITINLINE>
      
	The formal parameters of a procedure
      
      <JAVASCRIPT>
	The parameters of a function
      </JAVASCRIPT>
    </SPLITINLINE>
    are local to the body of the
    <SPLITINLINE>
      procedure.
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    The square-root program illustrates another way in which we would like to
    control the use of names.
    <INDEX>program<SUBINDEX>structure of<OPEN></OPEN></SUBINDEX></INDEX>
    The existing program consists of separate
    <SPLITINLINE>
      
        procedures:
      
      <JAVASCRIPT>
        functions:
      </JAVASCRIPT>
      </SPLITINLINE>
      <SNIPPET>
        <LABEL NAME="sec:sqrt2"></LABEL>
        <EXAMPLE>sqrt_example_2</EXAMPLE>
        <REQUIRES>abs_definition</REQUIRES>
        <REQUIRES>square_definition</REQUIRES>
        <REQUIRES>average_definition</REQUIRES>
        
(define (sqrt x)
  (sqrt-iter 1.0 x))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))

(define (improve guess x)
  (average guess (/ x guess)))
        
        <JAVASCRIPT>
function sqrt(x) {
    return sqrt_iter(1, x);
}
function sqrt_iter(guess, x) {
    return is_good_enough(guess, x)
           ? guess
           : sqrt_iter(improve(guess, x), x);
}
function is_good_enough(guess, x) {
    return abs(square(guess) - x) &lt; 0.001;
}
function improve(guess, x) {
    return average(guess, x / guess);
}
        </JAVASCRIPT>
      </SNIPPET>
  </TEXT>
  <TEXT>
    The problem with this program is that the only
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    that is important to users of sqrt is
    sqrt.  The other
    <SPLITINLINE>
      
        procedures
      
      <JAVASCRIPT>
        functions
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      
	(sqrt-iter,
	good-enough?,
      
      <JAVASCRIPT>
	(<JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>,
	<JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    and improve) only clutter up their minds.
    They may not 
    <SPLITINLINE>
      
	define any other procedure
      
      <JAVASCRIPT>
	declare any other function
      </JAVASCRIPT>
    </SPLITINLINE>
    called
    <SPLITINLINE>
      
        good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    as part of another program to work together
    with the square-root program, because sqrt
    needs it.  The problem is especially severe in the construction of large
    systems by many separate programmers.  For example, in the construction
    of a large library of numerical
    <SPLITINLINE>
      procedures,
      <JAVASCRIPT>functions,</JAVASCRIPT>
    </SPLITINLINE>
    many numerical functions are computed as successive approximations and
    thus might have
    <SPLITINLINE>
      
        procedures
      
      <JAVASCRIPT>
        functions
      </JAVASCRIPT>
    </SPLITINLINE>
    named
    <SPLITINLINE>
      
        good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and improve as auxiliary
    <SPLITINLINE>
      procedures.
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    We would like to localize the
    <SPLITINLINE>
      subprocedures,
      <JAVASCRIPT>subfunctions,</JAVASCRIPT>
    </SPLITINLINE>
    hiding them inside sqrt so that
    sqrt could coexist with other
    successive approximations, each having its own private
    <SPLITINLINE>
      good-enough? procedure.
      
      <JAVASCRIPT><JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE> function.
      </JAVASCRIPT>
    </SPLITINLINE>
    To make this possible, we allow a
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    to have
    <INDEX>block structure<OPEN></OPEN></INDEX>
    <SPLITINLINE>
      
	<INDEX>internal definition<OPEN></OPEN></INDEX>
      
      <JAVASCRIPT>
	<INDEX>internal declaration<OPEN></OPEN></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    internal declarations that are local to that
    <SPLITINLINE>
      procedure.
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    For example, in the square-root problem we can write
    <SNIPPET PROTECT="yes">
      <EXAMPLE>sqrt_example_2</EXAMPLE>
      <EXPECTED>2.2360688956433634</EXPECTED>
      <REQUIRES>abs_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>average_definition</REQUIRES>
      
(define (sqrt x)
  (define (good-enough? guess x)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
      
      <JAVASCRIPT>
function sqrt(x) {
    function is_good_enough(guess, x) {
        return abs(square(guess) - x) &lt; 0.001;
    }
    function improve(guess, x) {
        return average(guess, x / guess);
    }
    function sqrt_iter(guess, x) {
        return is_good_enough(guess, x) 
               ? guess
               : sqrt_iter(improve(guess, x), x);
    }
    return sqrt_iter(1, x);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    <SPLITINLINE>
      
      <JAVASCRIPT>
	Any matching pair of braces designates a <EM>block</EM>, and
	declarations inside the block are local to the block.
	<INDEX>block</INDEX>
	<INDEX>syntactic forms<SUBINDEX>block</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    Such nesting of
    <SPLITINLINE>
      definitions,
      <JAVASCRIPT>declarations,</JAVASCRIPT>
    </SPLITINLINE>
    called <EM>block structure</EM>, is basically the right solution to the
    simplest name-packaging problem.  But there is a better idea lurking here.
    In addition to internalizing the 
    <SPLITINLINE>
      definitions of the auxiliary procedures,
      <JAVASCRIPT>declarations of the auxiliary functions,</JAVASCRIPT>
    </SPLITINLINE>
    we can simplify them.  Since x is bound in the
    <SPLITINLINE>
      definition
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    of sqrt, the
    <SPLITINLINE>
      
        procedures
      
      <JAVASCRIPT>
        functions
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      good-enough?,
      <JAVASCRIPT><JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    improve, and
    <SPLITINLINE>
      sqrt-iter,
      which are defined internally to
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>,
      which are declared internally to</JAVASCRIPT>
    </SPLITINLINE>
    sqrt, are in the scope of
    x. Thus, it is not necessary to pass
    x explicitly to each of these
    <SPLITINLINE>
      procedures.
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    Instead, we allow x to be a free
    <SPLITINLINE>
      
	<INDEX>internal definition<SUBINDEX>free variable in</SUBINDEX></INDEX>
	<INDEX>free variable<SUBINDEX><ORDER>internal</ORDER>in internal definition</SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX>internal declaration<SUBINDEX>free name in</SUBINDEX></INDEX>
	<INDEX>free name<SUBINDEX><ORDER>internal</ORDER>in internal declaration</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
      <SPLITINLINE>
      variable
      <JAVASCRIPT>name</JAVASCRIPT>
    </SPLITINLINE>
    in the internal
    <SPLITINLINE>
      definitions,
      <JAVASCRIPT>declarations,</JAVASCRIPT>
    </SPLITINLINE>
    as shown below. Then x gets its value from
    the argument with which the enclosing
    <SPLITINLINE>
      
        procedure
      
      <JAVASCRIPT>
        function
      </JAVASCRIPT>
    </SPLITINLINE>
    sqrt is called.  This discipline is called
    <INDEX>lexical scoping</INDEX>
    <EM>lexical scoping</EM>.<FOOTNOTE>Lexical scoping dictates that free
    <SPLITINLINE>
      
	variables in a procedure
      
      <JAVASCRIPT>
	names in a function
      </JAVASCRIPT>
    </SPLITINLINE>
    are taken to refer to bindings made by enclosing
    <SPLITINLINE>
      
        procedure definitions;
      
      <JAVASCRIPT>
        function declarations;
      </JAVASCRIPT>
    </SPLITINLINE>
    that is, they are looked up in
    <INDEX>environment<SUBINDEX>lexical scoping and</SUBINDEX></INDEX>
    the environment in which the
    <SPLITINLINE>
      
        procedure was defined.  
      
      <JAVASCRIPT>
        function was declared.
      </JAVASCRIPT>
    </SPLITINLINE>
    We will see how this works in detail in chapter<SPACE></SPACE><REF NAME="chap:state"></REF> when we
    study environments and the detailed behavior of the interpreter.</FOOTNOTE>
    <SNIPPET>
      <INDEX><DECLARATION>sqrt</DECLARATION><SUBINDEX>block structured</SUBINDEX></INDEX>
      <EXAMPLE>sqrt_example_2</EXAMPLE>
      <REQUIRES>abs_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>average_definition</REQUIRES>
      
(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
      
      <JAVASCRIPT>
function sqrt(x) {
    function is_good_enough(guess) {
        return abs(square(guess) - x) &lt; 0.001;
    }
    function improve(guess) {
        return average(guess, x / guess);
    }
    function sqrt_iter(guess) {
        return is_good_enough(guess)
               ? guess
               : sqrt_iter(improve(guess));
    }
    return sqrt_iter(1);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    We will use block structure extensively to help us break up large programs
    into tractable pieces.<FOOTNOTE>Embedded 
    <SPLITINLINE>
      
        definitions must come first in a procedure
      
      <JAVASCRIPT>
        declarations must come first in a function
      </JAVASCRIPT>
    </SPLITINLINE>
    body.
    <SPLITINLINE>
      
	<INDEX>internal definition<SUBINDEX>position of</SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX>internal declaration<SUBINDEX>position of</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    The management is not responsible for the consequences of running programs
    that intertwine
    <SPLITINLINE>
      definition
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    and use; see also
    footnotes<SPACE></SPACE><REF NAME="foot:function-decl-vs-lambda"></REF>
    and<SPACE></SPACE><REF NAME="foot:tdz"></REF>
    in section<SPACE></SPACE><REF NAME="sec:lambda"></REF>.
    <LABEL NAME="foot:management"></LABEL></FOOTNOTE>
    The idea of block structure originated with the programming language
    <INDEX>Algol<SUBINDEX>block structure</SUBINDEX></INDEX>
    Algol<SPACE></SPACE>60. It appears in most advanced programming languages and is an
    important tool for helping to organize the construction of large programs. 
    <INDEX>program<SUBINDEX>structure of<CLOSE></CLOSE></SUBINDEX></INDEX>
    <INDEX>block structure<CLOSE></CLOSE></INDEX>
    <SPLITINLINE>
      
	<INDEX>internal definition<CLOSE></CLOSE></INDEX>
      
      <JAVASCRIPT>
	<INDEX>internal declaration<CLOSE></CLOSE></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>
</SUBSECTION>
