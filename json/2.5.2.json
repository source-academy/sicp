[{"id":"/sicpjs/2.5.2","tag":"TITLE","body":"2.5.2  \n    Combining Data of Different Types"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    We have seen how to define a unified arithmetic system that\n    encompasses ordinary numbers, complex numbers, rational numbers, and\n    any other type of number we might decide to invent, but we have\n    ignored an important issue.  The operations we have defined so far\n    treat the different data types as being completely independent.  Thus,\n    there are separate packages for adding, say, two ordinary numbers, or\n    two complex numbers.  What we have not yet considered is the fact that\n    it is meaningful to define operations that cross the type boundaries,\n    such as the addition of a complex number to an ordinary number.  We\n    have gone to great pains to introduce barriers between parts of our\n    programs so that they can be developed and understood separately.  We\n    would like to introduce the cross-type operations in some carefully\n    controlled way, so that we can support them\n    without seriously violating our module boundaries.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    One way to handle\n    \n    cross-type operations is to design a different\n    function\n    for each possible combination of types for which the operation is valid.\n    For example, we could extend the complex-number package so that it\n    provides a\n    function\n    for adding complex numbers to ordinary numbers and installs this in the\n    table using the tag\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"complex\", \"javascript_number\")"},{"body":":","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/2.5.2#footnote-1"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"// to be included in the complex package\nfunction add_complex_to_javascript_num(z, x) {\n   return make_complex_from_real_imag(real_part(z) + x, imag_part(z));\n}\nput(\"add\", list(\"complex\", \"javascript_number\"),\n    (z, x) => tag(add_complex_to_javascript_num(z, x)));"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    This technique works, but it is cumbersome.  With such a system, the\n    cost of introducing a new type is not just the construction of the\n    package of\n    functions\n    for that type but also the construction and installation of the\n    functions\n    that implement the cross-type operations.  This can easily be much more\n    code than is needed to define the operations on the type itself.  The\n    method also undermines our ability to combine separate packages additively,\n    or least to limit the extent to which the implementors of the individual\n    packages need to take account of other packages.  For instance, in the\n    example above, it seems reasonable that handling mixed operations on\n    complex numbers and ordinary numbers should be the responsibility of\n    the complex-number package.  Combining rational numbers and complex\n    numbers, however, might be done by the complex package, by the rational\n    package, or by some third package that uses operations extracted from\n    these two packages.  Formulating coherent policies on the division of\n    responsibility among packages can be an overwhelming task in designing\n    systems with many packages and many cross-type operations.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Coercion","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    In the general situation of completely unrelated operations acting on\n    completely unrelated types, implementing explicit cross-type operations,\n    cumbersome though it may be, is the best that one can hope for.\n    Fortunately, we can usually do better by taking advantage of additional\n    structure that may be latent in our type system.  Often the different\n    data types are not completely independent, and there may be ways by which\n    objects of one type may be viewed as being of another type.  This process\n    is called ","tag":"#text"},{"tag":"EM","child":[{"body":"coercion","tag":"#text"}]},{"body":".  For example, if we are asked to\n    arithmetically combine an ordinary number with a complex number, we can\n    view the ordinary number as a complex number whose imaginary part is zero.\n    This transforms the problem to that of combining two complex numbers, which\n    can be handled in the ordinary way by the complex-arithmetic package.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    In general, we can implement this idea by designing\n    \n    coercion\n    functions\n    that transform an object of one type into an equivalent\n    object of another type.  Here is a typical coercion\n    function,\n    which transforms a given ordinary number to a complex number with that real\n    part and zero imaginary part:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"function javascript_number_to_complex(n) {\n    return make_complex_from_real_imag(contents(n), 0);\n}"},{"body":"\n    We install these coercion\n    functions\n    in a special coercion table, indexed under the names of the two types:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":262,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0oFA4DYCmALqAMYD2hATmQJYUB2A+vnQM6kC8ojArvnwBuPADM+jMsQaNyRAIbVmlGvSasOxABQBKUAG8coY+Sq0ZGzqB79BIgL5iJUmaAAOfYsrNrGW4gCeboQAjAA0oIHBKBF0xIQAtnqGJqB0oqBaHMy2+FoA5iTeqjL+QaERUYQoOrUGRqkmKubqbFY8bvJ01Fpt2lXhkeUxafFJYQ2NU9MzpiWtmjoiqfaghPjshPUz1CR81LLNvpbEyyaOjjjiktJMoIVeR6UDlcPJk6DXLncPzAO9mmYcUS7x2ewOoAAFoR5AATAGcIFjJYfRypL63WS-KooBFeYFJbbTXbEfayaFw-xdPJ9JEglErD4Y1y-Al4umElLE8HkmHw4jUql0GmAgm1BnnJnOTH3IpPdTAnoE9ig6bpTLZXJZMYq1WzUAksmgCSwwiiOiMQiws5TVbrTZE-WURhWYgUNzWKF87WJFU22aGiGEACOfHkeResq8-zdbjqADJ4x99Y0Q2GI8MItjhv53bVkymTAB+KMc3NxguF0AALlL8pYiqFeWVtX9jPbJkDWLlPgsjfrJxRl2ZdwAVvIAG7ydhkah0NxefgJABGND+FG8CTcRAAHlpGHqDTzQAl5ABrQib7eEHfMUTUCgJZi7cNA0-5LTO+KMYjsfc6CIAAYhzwEBQEgWRwAofYyEICIEgoKwRxdKFJy2eRPjoHcrV4PgVxoUAKAyRR8jwwgf3YNAcDArQABVoU+aVXD6NJ2EiBimHwAI1h3WCFxkSoKHYjhQHYITREUNAdGosB6K2ZDQHkNxtwCIEWBNGguItfJmHHKcZznBdFMECgAHc2L4Ni3RkxTlK4xTGG4-I6AncjGJuVxrkiITw3wNYiAScjf0IjJiAYkiyJ-UAbJYkj2Aiac0lC6FuNMmgtk2TpqHkeJFOoUjAooq4mLuJSVK0a4EvylVHSPUkITKri1OYDTqC0xgdL06dZ3nbRKry-I-RwYcStkRrVMKS05zILR3SqwbD2dV1yj+eRBs9U83DKYJVvyeahtSJbSC8ngHlmtxXh2gUFv9LtQAAQlYlrGFNc1LXha5pJTEtxua1r2s6ydusMvqJHgpTPyYb9f32-MU1rGgHx6Ppzsuy9rpVCYqymAAiRghMCsKKFhT4KGodjCAdKo2IAWhp2yVOYSaaDoMgcZA4qPNK2F4R3CIAmSOqjV+5npq0HG4VhHGIhRvnQAFpZQBGrnZHYPhly0OWBYMIWGrsibyJZmacbV5dpdAWX+dbJWnBVk8BE1q2dbukXDbFnGEgEc3Lfl63le+WRYRcx3fed49Xam1nxaDidvc0EOFaEG3OYDo9Xyy7QAC9BZd-WmbdqOcZffBmAzuPOC0bPFf9mU6HfUvFCznPw7z0XC7rtaG+oYhy6b6vbdT99GDiPhTUr5v6rG1uC+NoeR9NXvx-7lOZXkDqiHHxp9F1qfGbb421-yIhF6rpPGRs90aByiwBWXIgIg8Ug15Jh4bPvR9yEhJT4nJgBmTJNip1-mgYBv9pIr1cNOMSM0LwBAiLsSg1BYQ1S5MYO6moBB5AQWTZBX19Qlg0m9K0lZUgI1DOGLQsCIgUnhDQrQ2CkG6jwbMEsdCGG4JISYWsUCKAwMIHAyIgp2G6gcAPGUp4LyrTvoQXQtUjoW14a+W+RBPQoxxgAKmUYQdR7N-QKXwBQCgZ4+BbVgcwQYZiai1UOkwKwpstGeh4Xw1SgwBTCl6IokuWjWwkPVFkdgz1XoWitFoex8hpF1FQQGY8hDgnWhIXaDYWwokzHkewxx7BoGUP4cwEYbi8hhIiRKfU6CAmxPevQwgiDYTMOxsYAhL0zRxM4fqWs+TKnVOKY0NEkp0SjTSC6Gg2gzEWJySMKc+A+CEEPDYl0pBCkqJ4E47JLjKiCgMWQJR4SiA+JmH47I5SQkLOmTM6YmxozrM8VI++LSUydG6HiFZ5iH5dB6JYiIEypm1CxnU-U7SNlbKKV0lY-kHQpOmGkqpOCMlZPeYI9xxzdkpn2WUxpRD4TsMibcxo5zVoIvVlon5vzpj3J6KSp54zwxfLWfi5c3ikX6kSWC7FqRcXtPYR8ql0y2zTB6baVEUo7ZB3YJ0YgZBIRaE5CQu6CRrBcB4DjAxRiTE4xZfUhRyq3BqprCeOVCqLSbG7qqupJYDVDO1QjagSNJURBxhIM8+NTKyEvtlGUdNBHSN0QK1Id1hWivFaInA8iXXX3UA4ngEj0bbJkSieRDxPQhsxNcmRirDHGLcF6+Rj8E3BFdTfaN4szVGpRBA0qxABTit2ttKNe1TA-iCigj4d1yVVF2hEL8DaQIKVbddLQsIcp4UPKUhuDz+2kiSLc1h3ox2DtuZa61M6Ei2uXHCQR+RCgk0XaAd1Pa1pescApDtFE+0DqlT6482RyWLtqdMEs7Tr1zrWFasmJ7x3LtXddDdoAt3uqPb+fdYjXDsHIbsTWQ7jw7lAOo0AO5A0KQNQKQQz4qkCg6gIRQDcyBnjWjG2qYELQ-0YOGdyAd2CCtTsXLuTcw6Ty9JSbOSc+UkdrvXDOm9t53XaQxm2fS7aRrvA+J8lGO4fi1hPI05KxOMfI+Itaw9SRj2ztYzsx5TxhWYMB7uoSQMyMo2xquoAADUokdNZFY43JeXSmMKUPhvJT4K0GqZypCZgOU164hE1R8e8CYQl30wynjJgFL8ffk+euh96EJVOY52j5LybQbUy5ygf55AAQNFBk8zmNMWi0KlqzeBUj4frdQCSsFvIUyPFYIiFX2ABE4IkGTrhe07nEw1ct8hK29qLihw+6HqDmxa9J1Ij9xZ6cbovbrUhev4EUOzHz6dG5dJGzjTzZcZbx0m6h0iM3+tpdW4t-0y254KcIBNhBW2+tzcy-keTo9uUfGW7Z0762K6bem7NtLT2lueHFiFwTyHXwifNm9tDO3pYkITnoLgAA+NdkrzyXlCwDkuInIcBaOwjgTj5mDhY6sD8773+tEsaJFxSUPYe9r+9j3HH5qBRYC3dHGsImCncDQh3yyGpug4w50LDOHdAiFLbIdnSG3AUB25h7DhRZFRKK4R4jyEyO8cHnJ+eMj7M7zo-Cbj1n+lPfY5rrj-dleyckUjmnpPUs0Yk68y3xugv9LG1p+z0qnM3bV5vBLWXku5fXurgLuu7b7ed9FzXx27ue8y+p9gOX9en29Q7vjmOkfCffJD5TMWbcPMSxp4MWngNhlAy1ozJnC8yIVsT35Oe3OMFxAIlr+WPhy5oKVrYboKu7Cq8lDKdWxiNbuM11rY12udbWuLMXYOIiDcC8YZbTue4ve0DjCfH35t+YOw9n7K3zNGsX+P8Xq+0g7+IN9pf4eF57+Xwf3b4N3cndP+LJ7E2V834ckfe7w2t9U6E75t8e7bUv7mwQ5ibWAU5j7f7I5-6iZWzo5f7J7-Y07A6AGV4mB26gFw4QEW505k4M7HhM4s44xs5zIc4v6S784lrwbEFIaUBbi7hkHS6Hj4ZbhkzxAkyK6fCCZHhc7baKAOQkwv7uAdZS6Uz96yAQGp5j4gEOaa5nQezwHY4SH5D449bc67aQ7+iB4q5m4IGdwRbYFW7SF3SyGYG6F44AHX7sx24aFN5gAEY0BEZ+SK6iGKQ8xXi7iVyDCZxWKGFObaEKG-6o7z4eF6DGZBFeEATarEomDB5ZwhAhFH6dz6Y1D5Ym5AbqxuE3geERDhEZ5h7yE-6A5p5hFxHbppzr7O41AoFRHIrH7BGlExGVzJHWGpF3Cewlw0HXh7iZyeHeGu60YmE6QRbn7q4lFe534R7hFVHVHTBx4lHGZx5NEJ7GAKQxwZFdE9Gh4yr5E46mEfjDF1FgD7GTGRHEqzF6D0wLEB42EDI-yt7lad6kDVZhQ971YJDOG9oa4uwj4uZdYdG7jmw66b5L6SwTZ-E3jA5gk7hXYQ7dHZFWIw5w6SxrFZGgDhGwFL6mygmPidEQnYn-FpYwkbHoG9qmzImwmonJEP4exeyX6Qm4m0HgkEkzAok5EImU4CBkkbHonRwuRYkMlQm2p0lMnTAsnwlgEfirGQminiiHZwF+EFEo7vj0k4kRDAFOxsngHbGKFo5UkDGuZmGgA4x0mqnMn6Hk4YHbFYH05dKM7M6WiEGpDDR4Ai7tF4k3j0ExqC7BaY6QlY4KlQGQ6oJGEkC-ZakBFKmClulQk6DqFOnemSK+nm67F25BnHjGGWm7HKn4lWFOk4CPzFAtB+A4xdQGS9Q5B4SrhE6GnGksolk9QLjln4RKBuhrElq-D1jix1kgyNmVlZmMlCBAA","body":"put_coercion(\"javascript_number\", \"complex\",\n             javascript_number_to_complex); "},{"body":"\n    (We assume that there are\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"put_coercion"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"get_coercion"},{"body":"functions\n    available for manipulating this table.)  Generally some of the slots in\n    the table will be empty, because it is not generally possible to coerce\n    an arbitrary data object of each type into all other types.  For example,\n    there is no way to coerce an arbitrary complex number to an ordinary\n    number, so there will be no general\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"complex_to_javascript_number"},{"body":"function\n    included in the table.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Once the coercion table has been set up, we can handle coercion in a\n    uniform manner by modifying the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"function\n    of section ","tag":"#text"},{"tag":"REF","body":"2.4.3","href":"/sicpjs/2.4.3"},{"body":".  When asked to apply an\n    operation, we first check whether the operation is defined for the\n    arguments' types, just as before.  If so, we dispatch to the\n    function\n    found in the operation-and-type table. Otherwise, we try coercion.  For\n    simplicity, we consider only the case where there are two\n    arguments.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/2.5.2#footnote-2"},{"body":"  We check the coercion table to see if objects\n    of the first type can be coerced to the second type.  If so, we coerce the\n    first argument and try the operation again.  If objects of the first type\n    cannot in general be coerced to the second type, we try the coercion the\n    other way around to see if there is a way to coerce the second argument to\n    the type of the first argument. Finally, if there is no known way to coerce\n    either type to the other type, we give up. Here is the\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":293,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0oFA5KAPYAOApgE4CGALgJaEB2A+tZQEYA2pANKMQK7VQlBgBNQAc1LV8YAGblCAW1ABjABaVi1CqADMoABQBnUqrqN9aPdYCUOOfwbn6DYceOFVhgNakAnrzkZoTkosa2oADeOKBxoMHU-ORutMZMDPwcHIbBqqHh9vHFxQD8oE6ipHK0DKSisSUlAFygpACO-JQ5foGg6qSUooYDQ7khYRG2RU1N5aPDeQURjbPFrZQeXr4BvKy0OUuT0wDcOAC+Dk4ulkqUfizsXIaRMcX5DMZCHF7dj5ykUAAXlAHDS1EMACIAFSsAHQyG2M7FRzOCxuH6EHz8Yg7fxMACMvF6TBQr1WJQ+X1Axn4bDhXGB7k83hJRNA+xyP1UfwZpFOFOKtDkRjSTEq1Vq9RMdL502igtmiWSbglNTqomRs3ObQ4pgVa3ejGpR3EIM2LLxpL2lAOMvpT35SMVTWFovSaqliwmonlb0NTWVKQqYklGq1AZ1pD1gP9AeKQbcnPG+TCzvjoEuayz8RzcVRN1SnwoELZxIC1tAADduvx+QbZlShLSHQCmRbtmWObaub8OP8uAK1m7DGLPRr7XLyRnTNRHnbubzHdwXRm4sRbeRDGCvlb2RvaFuSSheDWOHXpiu12vk4v+1P09rdfq44amwkfe2tqyKyfu3aWynCNDRHMdQ3VaVTT9Vc1lnecckA5cYOvddN0MA8j1-U9a35K8UOvZNEIBaZH0jZ9Y2Qpo4OTU1sPPflgOzVc80zCkC3RUBRDSDdqA0QwlGnJVpBVUAVCBcTQEhTFsWISFKLKUFCCxHF5PiVoxIkyFalMchqDk-DQHKbSS1U9ZJPHeoiDIKgOIAWls7sAUhYCWMTTjuJoDQzkud8SAoGhXAHQEQTuB4+ReM53ykIQQT8mzAvCqSlJkxFIuNIQBBiqz-PRIKoWM3TUrwAhIDccBCGSVQeFEwhqXY1xjH6Sgq0BShQBqAAPSzMiUNhdEIEVKHICR+CUUgGGoYw0FkIwABUBna64OJ3IQ0g5BbGA4fw2g6qrtFcPZCHWtbPHaoa0HsAh5sBerLC0YgtqYWpxVDcgttqCQmAAK2azZVHIWhtGEbJCAAd0a-hGuoQgZvurbhAYbaJFoFq3FutGnA5I7ug4XVSDGibGoG9bWuG0bxpkAgVuEYbjF4TZQDdagBm20GKEBUwNxs0mRoJyarjRVxhGIB7-EMVF6dpwS4jcuH8WeiU3v8D7vt+4x-sBiEJZpiQIm8gXC2EURhg63h-Glj8kmDOWmCkOoAe8SEhlESFeBWwxTdAc3nUudGaTpD2zYt2WRceu2KFoR2W1d0FwUDr2BV9pahaULJ4-NhsZeE63Q-xcOHahVOOBj93Pe9-W-a4qt0+D7O3Bt-PI6hKuS7jsvE7wP2aFYDRHgkQxqH8Mg+94D4dEJ2urbcDCB6H0gR7URhx8mn2DY4wfh9YfvRBoUbJ5EsUZ53pIBMo+ZBmGY+98o1oKEULcr6UXhITYIZuwkKRxEf0B7I5Oe+6KknQWlgx4U2MIYR++9gyHzQpAs+-4chwPjLfcg98IG7yfpJV+4gt6f04hgn+DlQGE0AZ3ZOlhtKsGyKrGs6sAbaAyKNPq5AmAblUD4SgUgXiZ0WsApMnCPYWwTHXYQ1Ae7qD7lCH6tCNYMJ6swmOHVSKsWKJlKEztW67khNIv69C5zyIoDHbRatZH6KYYY2weEmg12BAAPnfh7UAABqBOyi1GQmjm7OOxiZF6MYb1Qxz8dF0M1v4hRljVw2KBPYrejiHLlwpO4oumiIQ+N0aEgx5AjHBNMWEixViShRJiQIjqoBoSuOAu4luXitE5L8Zk7JJj6nmKyREtYRSHGlLAAk1RghC73FII03xGSWmu1XKU6JnShzxDcpCUQjBBn60oTjGh6S5EtNYZQdhnDSARTIXw0SAzVkhPWQErcDAoFuGiv0vwQy1lmLOYiQwFz9YzUbqoGk0YzDQ3ILwwsjU5ChEXkoB6pBSmZOMPsw2wQ-hcwhAAL0ucLUWttxoR0djC-scKUmGERavP2tA7ifThbipFDc0UFy0kSzZhUakIo7n7IlDBaBJCqKSnhIcUXvP6RIZlrLBl0tJfi8h9cGASGeIijlIjyX2ybk7MVXAcV4oriKmknQhq7KUVKqeoBSnlI6q8glnwqH9jyKwMVWQhqbO2Vwi2ftMU0vpdES2IkFikpOCo+IBLqUkslVEF1wZkyIo9SxRlRyFDKCYA6wlJSg7OrcjPduIa2KqqZSy-gbK-WrjcncZmTBjDtF0iYdVwRxiwqGvSyITjTIlALV0UtMbiUVqFco0NqqRDit2VmtYOaaASJoCIFAo4fXNsRUEQYWLR3TLiG2g5oV54RqUEwalHbcj0yETMkRM9fnlNzRI-I4DKCWISGUw5ebjC1EMEe1tFICC1B0OQOQWzATQxJh+akxNmYc38F8fGKaDmxK1a+YROru5bIkbEyEZqO2WqybwJRLlEl9KgxOx1OKUPmBgxwIaiJx3lt0m45Dja0OCow+aka2HWm8GI3CwjqS038vQ9Bi1lHcOHN5emqodH1EKoFbHLRzGKM4ePR2wclTkPzqYIuqNqHG1GME7BsZ7T252IcZJ6T0aiU12nXwCT4bFBLpXWK+T3ysM4YKcUNdwhIiTNiepgzy7OFMFXeQddOnZnzLqM5C4OBlnUIU5R61HDbVnDXkLPzWLCCBbYcF3ZFs70TQoAwbofz0SQpRKmzhfKM1dteAGtwbrg2evzO23j7L-VuSDUiYrqWU76cjUZ-urnrPxq3WhZrR7k0ZYOQ631G6s46oYzl9lu6+1MAPVesryqKSzsNjRqdPCQMiSG5myIo3z2XtE7lm93XDb2cjZp2NCdFubp1TPPd+bC0QjrRqwRzi1X1t2d7CzKELsDoYEOvoSib23rAPeigT6qpYzfcED9Iov00h-ToJQ-7DaAby7LMR4HJGQmIFF8zurqssXcb1it6G0esePbjgj4nUnzdpfx1JBPhPUZHSTpD9Gsucb4+7VH6OqPsey1x0nPHO34-Z2xrb3HIT7aXYdiQRjqdwciSp2zAjRcyb+I27TwuFeNclwLl7cQrNHtU3Z+rhmnMubc8ojzCzvOXAi6w9nQWdl7LCxQ41Kz8ggq4B1W3tqeF3pBaEHQ4h0YAoMx+TDLGhoI3EFLvgWzYvpa9Zlh4GnZNaZU8B07Ilrki4N4r-scnn4BeEzXRDu2OJq6N2KnX-X8uSGkDchdDn1fPyl08jrP3igJYfcl3GAfYccWduN5QoKOq4vZPCskJ2BvLaz+Lstk6i3woJFWmtBlN34YRWSLXy+Azk4RQv5xS-N-b9xWSHbceDktn767sFw-eCj8r72hPDnp-E535EWy+-l-P6P20zfKFD-z9f+-gZH-sfkXqfntlkBfoPtfqALfuPlXqXp9Kuitl2rvtCIAdeMgV-hvj-iUFtsPovjgRmHgbfifiVgclXJAW7tAbAanhPsGAgc5uXpgf-qAMAOgWuMwevuwUQVNrvm-oQfGMQSATNngG3n9olo+s+sDqDkIJ+gtMYFDn+sXkLLEt2kJKBkjr3JBi7oPjHMGiIb0qkhoqRjoW7kYqYWCrhpEvPjfmPnLv3H3hYUPjYTAcfsLp4pTlCE4eYQPmYd-tYi4bAfYfaJQVfoEW4TziLlkOht4c-N4f4YUuETZsUv3EXKEc4SPhEQzs3CjDEb4ZYXEfkR1FYe0kkXrgIhQU4dQVkYYbXlJo-knpwj4ZfsURvh0vrg-gdo0f3O3Dpkklng3pJLEZEi3uUakQMWXk1ibsBGbl5ksk7tQk4R7nFqFmGg8EsYnkrsnkHK+G5BngruLs0bobYIXj5msfPBsfXpMRXrsSIvsRMYgcZoUS0c3uuq8gQPkBQKoELLSCLL7ngFwEIJ8eQN8YwEwNTCCJkNkKsaqqoFwFasCaCcwO7BbIiYFBCaAFCRwIaqqplP3l8a4LPGQOyBvKQH+CyvjBbKBB6OBF6IYNFPiSCYSaSSSXPG4XAWiWCRiTPO7CyXsGydRtDgkQIXEJycieCK2uRHAW5GKeCeCIhpcA7lctIIyUiUSaQKyWQGPq+H7AySyduOCE9EKdKSIm6itEaZSaAWQYbHqWyQaV8BaQJCaTqm6reIaRSQJKQbVpYAyR6faXOB6XfqaRfAPD2KGQuO6UKTprNhxAybKRSVuB6REHAdSYwtkKONDlMHAUtsGBZJqMxFKbQZSOlFjMQEyG6kmcoj2iIh0F0DkHydXnOPqdDMQPKAAGRtmAG1ndDql-i2lakDwkDTCAHlC+nQ6DmtmAGtBxmEAElgkJnhk5CVlVm5gGFp7BgzlznMALmykrSrxKnIphwUpNwkCSy6yoklmkl9yNQhRaDqkLxDTnnATviohMjXKnl-ybycJ6wUgjgACEjMNJVQEEwwqI0E1ZoGuc4sTgvAdwuIxCk0Z5UwLkhZq4I4XAYqzMV6UswIEk2p8k74LJ5ZIZV5W8P5GYhFbJxFYwyYpF35Omaw74lABI1Fwwj55F8YTFKArFi52F55K5TQhFBILAhALA3FIIm5TJjA6pmpZJAlxZxqHIKAIlLALFElKpYpvZ-JxJ8lOZbgAFYEwFdJ1Awl0MYlMwBk5QMq6KhgH5vJplol1AQ6zFImx+U5oABlQFYY0oTlKlJlFl+EVlucqKsq3gdlcczFewylZlJlV6bh7ld8oQ-ptlxA2l88ZFwphBkIDAR0Y0zMhA-uQKX6+opJxgRU2YqFGYbkiVW47sH5dF552B+E2VuV0g6gBV7URVAwJVc8ZV8lLElwipfsdSIyZyKlVRFy2qk+6xRR9RXRWxAiCF4CFyvAAADPuXiZpWkicg8gos8boU1fECNacswuNUUc6DgO+B8reTNS0XNWLt0YYAACy8B6DOjvhuA3XzzHW7UUCGAADsF1zshgqgvALyQAA","body":"function apply_generic(op, args) {\n    const type_tags = map(type_tag, args);\n    const fun = get(op, type_tags);\n    if (! is_undefined(fun)) {\n        return apply(fun, map(contents, args));\n    } else {\n        if (length(args) === 2) {\n            const type1 = head(type_tags);\n            const type2 = head(tail(type_tags));\n            const a1 = head(args);\n            const a2 = head(tail(args));\n            const t1_to_t2 = get_coercion(type1, type2);\n            const t2_to_t1 = get_coercion(type2, type1);\n            return ! is_undefined(t1_to_t2)\n                   ? apply_generic(op, list(t1_to_t2(a1), a2))\n                   : ! is_undefined(t2_to_t1)\n                   ? apply_generic(op, list(a1, t2_to_t1(a2)))\n                   : error(list(op, type_tags),\n                           \"no method for these types\");\n        } else {\n            return error(list(op, type_tags),\n                         \"no method for these types\");\n        }\n    }\n} "}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    This coercion scheme has many advantages over the method of defining\n    explicit cross-type operations, as outlined above.  Although we still\n    need to write coercion\n    functions\n    to relate the types (possibly ","tag":"#text"},{"body":"$n^2$","tag":"LATEX"},{"body":"functions\n    for a system with ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" types), we need to write\n    only one\n    function\n    for each pair of types rather than a different\n    function\n    for each collection of types and each generic operation.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/2.5.2#footnote-3"},{"body":"  What we are counting on here is the fact that the\n    appropriate transformation between types depends only on the types\n    themselves, not on the operation to be applied.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    On the other hand, there may be applications for which our coercion\n    scheme is not general enough.  Even when neither of the objects to be\n    combined can be converted to the type of the other it may still be\n    possible to perform the operation by converting both objects to a\n    third type.  In order to deal with such complexity and still preserve\n    modularity in our programs, it is usually necessary to build systems\n    that take advantage of still further structure in the relations among\n    types, as we discuss next.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Hierarchies of types","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    The coercion scheme presented above relied on the existence of natural\n    relations between pairs of types.  Often there is more \"","tag":"#text"},{"body":"global","tag":"#text"},{"body":"\"\n    structure in how the different types relate to each other.  For\n    instance, suppose we are building a generic arithmetic system to\n    handle integers, rational numbers, real numbers, and complex numbers.\n    In such a system, it is quite natural to regard an integer as a\n    special kind of rational number, which is in turn a special kind of\n    real number, which is in turn a special kind of complex number.  What\n    we actually have is a so-called ","tag":"#text"},{"tag":"EM","child":[{"body":"hierarchy of types","tag":"#text"}]},{"body":", in which,\n    for example, integers are a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"subtype","tag":"#text"}]},{"body":" of rational numbers (i.e.,\n    any operation that can be applied to a rational number can\n    automatically be applied to an integer).  Conversely, we say that\n    rational numbers form a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"supertype","tag":"#text"}]},{"body":" of integers.  The particular\n    hierarchy we have here is of a very simple kind, in which each type\n    has at most one supertype and at most one subtype.  Such a structure,\n    called a ","tag":"#text"},{"tag":"EM","child":[{"body":"tower","tag":"#text"}]},{"body":", is illustrated in\n    figure ","tag":"#text"},{"tag":"REF","body":"2.25","href":"/sicpjs/2.5.2#fig-2.25"},{"body":".\n    ","tag":"#text"},{"tag":"FIGURE","scale":"20%","src":"img_original/ch2-Z-G-66.svg","id":"#fig-2.25","captionHref":"/sicpjs/2.5.2#fig-2.25","captionName":"Figure 2.25 ","captionBody":[{"body":"A tower of types.\n      ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    If we have a tower structure, then we can greatly simplify the problem\n    of adding a new type to the hierarchy, for we need only specify how\n    the new type is embedded in the next supertype above it and how it is\n    the supertype of the type below it.  For example, if we want to add an\n    integer to a complex number, we need not explicitly define a special\n    coercion\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"integer_to_complex"},{"body":".\n      \n    Instead, we define how an integer can be transformed into a rational\n    number, how a rational number is transformed into a real number, and how\n    a real number is transformed into a complex number.  We then allow the\n    system to transform the integer into a complex number through these steps\n    and then add the two complex numbers.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    We can redesign our\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"function\n    in the following way: For each type, we need to supply a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"raise"},{"body":"function,\n    which \"","tag":"#text"},{"body":"raises","tag":"#text"},{"body":"\" objects of that type one level in the tower.\n    Then when the system is required to operate on objects of different types\n    it can successively raise the lower types until all the objects are at\n    the same level in the tower.  (Exercises ","tag":"#text"},{"tag":"REF","body":"2.83","href":"/sicpjs/2.5.2#ex-2.83"},{"body":"\n    and  ","tag":"#text"},{"tag":"REF","body":"2.84","href":"/sicpjs/2.5.2#ex-2.84"},{"body":"\n    concern the details of implementing such a strategy.)\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    Another advantage of a tower is that we can easily implement the notion\n    that every type \"","tag":"#text"},{"body":"inherits","tag":"#text"},{"body":"\" all operations defined on a\n    supertype.  For instance, if we do not supply a special\n    function\n    for finding the real part of an integer, we should nevertheless expect\n    that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"real_part"},{"body":"\n    will be defined for integers by virtue of the fact that integers are a\n    subtype of complex numbers.  In a tower, we can arrange for this to happen\n    in a uniform way by modifying\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":".\n      \n    If the required operation is not directly defined for the type of the\n    object given, we raise the object to its supertype and try again.  We thus\n    crawl up the tower, transforming our argument as we go, until we either\n    find a level at which the desired operation can be performed or hit the\n    top (in which case we give up).\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    Yet another advantage of a tower over a more general hierarchy is that\n    it gives us a simple way to \"","tag":"#text"},{"body":"lower","tag":"#text"},{"body":"\" a data object to the\n    simplest representation.  For example, if we add\n    ","tag":"#text"},{"body":"$2+3i$","tag":"LATEX"},{"body":" to ","tag":"#text"},{"body":"$4-3i$","tag":"LATEX"},{"body":",\n    it would be nice to obtain the answer as the integer 6 rather than as the\n    complex number ","tag":"#text"},{"body":"$6+0i$","tag":"LATEX"},{"body":".\n    Exercise ","tag":"#text"},{"tag":"REF","body":"2.85","href":"/sicpjs/2.5.2#ex-2.85"},{"body":" discusses a way to implement\n    such a lowering operation.  (The trick is that we need a general way\n    to distinguish those objects that can be lowered, such as\n    ","tag":"#text"},{"body":"$6+0i$","tag":"LATEX"},{"body":", from those that cannot, such as\n    ","tag":"#text"},{"body":"$6+2i$","tag":"LATEX"},{"body":".)\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"Inadequacies of hierarchies","tag":"#text"}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n    If the data types in our system can be naturally arranged in a tower,\n    this greatly simplifies the problems of dealing with generic operations\n    on different types, as we have seen.  Unfortunately, this is usually\n    not the case.  Figure ","tag":"#text"},{"tag":"REF","body":"2.26","href":"/sicpjs/2.5.2#fig-2.26"},{"body":"\n    illustrates a more complex arrangement of mixed types, this one showing\n    relations among different types of geometric figures.  We see that, in\n    general,\n    \n    a type may have more than one subtype.  Triangles and quadrilaterals,\n    for instance, are both subtypes of polygons.  In addition, a type may\n    have more than one supertype.  For example, an isosceles right\n    triangle may be regarded either as an isosceles triangle or as a right\n    triangle.  This multiple-supertypes issue is particularly thorny,\n    since it means that there is no unique way to \"","tag":"#text"},{"body":"raise","tag":"#text"},{"body":"\" a type\n    in the hierarchy.  Finding the \"","tag":"#text"},{"body":"correct","tag":"#text"},{"body":"\" supertype in which\n    to apply an operation to an object may involve considerable searching\n    through the entire type network on the part of a\n    function\n    such as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":".\n      \n    Since there generally are multiple subtypes for a type, there is a similar\n    problem in coercing a value \"","tag":"#text"},{"body":"down","tag":"#text"},{"body":"\" the type hierarchy.\n    Dealing with large numbers of interrelated types while still preserving\n    modularity in the design of large systems is very difficult, and is an area\n    of much current research.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/2.5.2#footnote-4"}]},{"tag":"FIGURE","scale":"70%","src":"img_original/ch2-Z-G-67.svg","id":"#fig-2.26","captionHref":"/sicpjs/2.5.2#fig-2.26","captionName":"Figure 2.26 ","captionBody":[{"body":"Relations among types of geometric figures.","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.81","id":"#ex-2.81","child":[{"body":"\n    Louis Reasoner has noticed that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"\n    may try to coerce the arguments to each other's type even if they\n    already have the same type.  Therefore, he reasons, we need to put\n    functions\n    in the coercion table to \"","tag":"#text"},{"body":"coerce","tag":"#text"},{"body":"\" arguments of each type to\n    their own type.  For example, in addition to the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"javascript_number_to_complex"},{"body":"\n    coercion shown above, he would do:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"function javascript_number_to_javascript_number(n) { return n; }\n\t\nfunction complex_to_complex(n) { return n; }\n\nput_coercion(\"javascript_number\", \"javascript_number\",\n             javascript_number_to_javascript_number);\nput_coercion(\"complex\", \"complex\", complex_to_complex);"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n        With Louis's coercion\n        functions\n        installed, what happens if\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"\n        is called with two arguments of type\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"complex\""},{"body":"\n\tor two arguments of\n        type\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"javascript_number\""},{"body":"\n\tfor an operation that is not found in the table for those types?\n\tFor example, assume that we've defined a generic exponentiation\n        operation:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"function exp(x, y) {\n    return apply_generic(\"exp\", list(x, y));\n}"},{"body":"\n        and have put a\n        function\n        for exponentiation in the\n\tJavaScript-number\n        package but not in any other package:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n// following added to JavaScript-number package\nput(\"exp\", list(\"javascript_number\", \"javascript_number\"),\n    (x, y) => tag(math_exp(x, y))); // using primitive $\\texttt{math\\char`_exp}$\n          "},{"body":"\n        What happens if we call ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"exp"},{"body":" with two\n\tcomplex numbers as arguments?\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        Is Louis correct that something had to be done about coercion with\n\targuments of the same type, or does\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"\n        work correctly as is?\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        Modify\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"\n\tso that it doesn't try coercion if the two arguments have the\n\tsame type.\n      ","tag":"#text"}]}]}],"solution":[{"tag":"OL","child":[{"tag":"LI","child":[{"body":"If Louis puts the coercion functions into the operations table,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":" will enter an infinite loop\n    ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n    Louis's code does not work. ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":" works correctly as is.\n    But we could modify it to exit with an error before attempting any same-type coercions.\n    ","tag":"#text"}]},{"tag":"LI","child":[{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":271,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0oFA5KAPYAOApgE4CGALgJaEB2A+tZQEYA2pANKMQK7VQlBgBNQAc1LV8YAGblCAW1ABjABaVi1CqADMoABQBnUqrqN9aPdYCUOOfwbn6DYceOFVhgNakAnrzkZoTkosa2oADeOKBxoMHU-ORutMZMDPwcHIbBqqHh9vHFxQD8oE6ipHK0DKSisSUlAFygpACO-JQ5foGg6qSUooYDQ7khYRG2RU1N5aPDeQURjbPFrZQeXr4BvKy0OUuT0wDcOAC+Dk4ulkqUfizsXIaRMcX5DMZCHF7dj5ykUAAXlAHDS1EMACIAFSsAHQyG2M7FRzOCxuH6EHz8Yg7fxMACMvF6TBQr1WJQ+X1Axn4bDhXGB7k83hJRNA+xyP1UfwZpFOFOKtDkRjSTEq1Vq9RMdL502igtmiWSbglNTqomRs3ObQ4pgVa3ejGpR3EIM2LLxpL2lAOMvpT35SMVTWFovSaqliwmonlb0NTWVKQqYklGq1AZ1pD1gP9AeKQbcnPG+TCzvjoEuayz8RzcVRN1SnwoELZxIC1tAADduvx+QbZlShLSHQCmRbtmWObaub8OP8uAK1m7DGLPRr7XLyRnTNRHnbubzHdwXRm4sRbeRDGCvlb2RvaFuSSheDWOHXpiu12vk4v+1P09rdfq44amwkfe2tqyKyfu3aWynCNDRHMdQ3VaVTT9Vc1lnecckA5cYOvddN0MA8j1-U9a35K8UOvZNEIBaZH0jZ9Y2Qpo4OTU1sPPflgOzVc80zCkC3RUBRDSDdqA0QwlGnJVpBVUAVCBcTQEhTFsWISFKLKUFCCxHF5PiVoxIkyFalMchqDk-DQHKbSS1U9ZJPHeoiDIKgOIAWls7sAUhYCWMTTjuJoDQzkud8SAoGhXAHQEQTuB4+ReM53ykIQQT8mzAvCqSlJkxFIuNIQBBiqz-PRIKoWM3TUrwAhIDccBCGSVQeFEwhqXY1xjH6Sgq0BShQBqAAPSzMiUNhdEIEVKHICR+CUUgGGoYw0FkIwABUBna64OJ3IQ0g5BbGA4fw2g6qrtFcPZCHWtbPHaoa0HsAh5sBerLC0YgtqYWpxVDcgttqCQmAAK2azZVHIWhtGEbJCAAd0a-hGuoQgZvurbhAYbaJFoFq3FutGnA5I7ug4XVSDGibGoG9bWuG0bxpkAgVuEYbjF4TZQDdagBm20GKEBUwNxs0mRoJyarjRVxhGIB7-EMVF6dpwS4jcuH8WeiU3v8D7vt+4x-sBiEJZpiQIm8gXC2EURhg63h-Glj8kmDOWmCkOoAe8SEhlESFeBWwxTdAc3nUudGaTpD2zYt2WRceu2KFoR2W1d0FwUDr2BV9pahaULJ4-NhsZeE63Q-xcOHahVOOBj93Pe9-W-a4qt0+D7O3Bt-PI6hKuS7jsvE7wP2aFYDRHgkQxqH8Mg+94D4dEJ2urbcDCB6H0gR7URhx8mn2DY4wfh9YfvRBoUbJ5EsUZ53pIBMo+ZBmGY+98o1oKEULcr6UXhITYIZuwkKRxEf0B7I5Oe+6KknQWlgx4U2MIYR++9gyHzQpAs+-4chwPjLfcg98IG7yfpJV+4gt6f04hgn+DlQGE0AcVMAjdVA0mjGYaG5BFrAM+O1UIi8lAPVIB1UAPU+rkGMJ3ZOlhgh-C5hCAAXlA+uudbbjQjo7QR-ZhGt13GI1eftaB3E+sIwwYjM6WxEg3aRBctLqKYAot2cdlEV34W4dRDBaBJCqFo8RwtRZSPtk3SENi7H8CqIo0RHcu4MAkM8bRr4Q4uIoVCEQQTSC+McSoqxNJOhDVIB7JxHDoSgA6vrNeQttKsGyEwPIrBAlZCGiYygqgfCUCkC8HRfs5HlN0o46IujgwLEcScViKIElqOqY0vxLS3LJjEZ0liftQrzwUMoQpgx+y9P7u3QZdc+BoXbqMtiCTPH2JSSE1cbk7jMyYMYdoTTjldGCOMIRQ0-GRAANSmRKGc5Jo5jGaOUaRLp8QAnROaa+BMyyDnqCYDQEQKAXl9LebYIIsz+lxJchshhol7iTMUEoJgxiom5Hphbf5U8VmHlyKADJgKmD5HAZQKFCQiVIsOcYWohgKUfJYgQWoOhyByAqYCaGJMPzUmJszDm-gvj4wRYbLeqSdG4r0dQHuQLxWQiKVE0p5AY4dSZRSTKUIGmmNjruBVNClUcCGoiaFVzdIfM1UYiF1zYn6vMIa41lL5n9ItYIQu1TbHbNtYqkpRqVWUq2d4hiGq3VO0CVwb1BrfWOvpuG4NxRLUTKYFMtFDT5kxztcUkafrXarhrsCAAfO-fiyLk2opmX8eZNchzxETaWlN6K+lRIzT67Nxq8JNCxcISIQIi3iqTQ2jFgSu2Mo+W5SEohGAxP1nknGMz7XRvIOUyp1SUnOhyZYWdBTiCED9cuqpNSLYsomhQBg3R6GFl4d0xFgaHEhNaW4dpIzPn5gSVE4JrwH0II6S+i9HEB3lqHf3cg2Kll4pniB7t6zr2G21dc35eyAUeq8XeyIxKaBArJQyuNcKKRjJ6a8+Duy1j7OQ9s5p6HaX0vfTsmtcR8M3vreWtN6j81-PiG5GeJLjmnKSRctVoBbmJPOSk72HaDIkpBQwMFfQ1XqopMetlHKqpYx5cEPlIoBU0iFToJQor17VIlVEL93cKlysM5CHdObeBqug7W0NcHCpmL1VZmNH4zXUFdRCK1GibXOe865-1vBnXCK8+6iQnqg22sCyapFEWUPxvs95mj0Xd1uZo2FjxTHpkseqRmmL4nij5t7cWgDOWYVVvbnRvgoaytoqA-ltLKrCvxBHT2vthm6uNs+piyDo7gLjsnXUZyFwcBbvkU1-dq6Ip8MReN0lyg2EdSm4enRLLWGhB0OIdGjUU0fgXW2uhIhxCBZWSuqQV6vmbOy6mirrHFnsazni6K7qHgNtyxIFtUbDuIhrvCmD-6bvdeBcOvrOKOPLJe1lt7gGm2BMazm2wbX4UKbAKy0956dv6aFs7BbrCuAdS0eyERZJJUQ7xV1j7lz5FEYJHch5BkIcea0WSFrjP4whdp-T9n+FOdNJJ9VhjhsWx46W0T3gAuydPZEpTu7hnHOiLpz-Bn7OFcs6hSrxnfPFeRFsprgy2v1fqoBynLIouCfi9AJLx7X6utAZLfF8jIilfQn19eW9OzWdu7XDRon3OecZl9wL43V3EVV3N+wy31vEMU6B-bj3fvQDAG9xmBPAu2cB5KEHpXevM-xiD2SeTxRFMUGU1yo66mhD8oWsYHTIqTeWHFcRoSeLTO93lfkfH7CY4jLwyG5LxtbWd6Wxm4fBOTV5udxL0nJXxW47H5HqfVvC+Zejv5qEC+Oqj8W+PjXawo8z46-3EXm+D8kWAomrIQ+d-d+fpvif++l+S9n51s3p+n8r4v6Glu6-IT37vzflvnvrMGfoWsWuHu-sTp-v3q9iiuVpWuotvl3lvhnsVkfiWjDvAXMvdkHNVnWpgfVnDp9gAcgbmvvmDmAf2nHkQW1tVoNlOiNpcPNpvitmumcButYqWiwe9nLgskHKEpDtILAWWlgU9IgSQSPkjmsqNuMlwYASIYQT1qDtigIc9kIdDnAYoSDsQZJPfkjmDtkgQPkBQKoELLSCLJtngFwEIMYeQKYYwEwNTCCJkNkOwX7KoFwGUrYfYcwO7BbN4YFE4ZwlkBwNkn7JlAtiYa4LPGQOyBvKQH+HYvjBbKBB6OBF6IYNFJEXYdEfEXEXPCvlLovFEQ4UETPO7HkXsAUcFrpsAXnkaCUb4eCEyuREUW5AEaUeCPCpcBwZININkT4TEaQPkWQKTq+H7FkXkduOCE9LUW0csu0itLMckf9qHobJMQUdMV8MsQJPMXiu0reDMUkQJCHq+oilkccVsXOMceDtLm0hfAPD2I8QuEcbUYLtjpYFkR0cwEkVuMcREEUakRkCEaOLplMEUVKsGBZJqMxK0TbkaJ8EINDMQEyO0v8R8iRssh0F0DkJUX0XOFMcifKAAGTEn67YndBDF-gbGjEDwkDTD67lAXG6Z0nEAzAGStBfGECNHLFbjJjokYm5h96QluBck8m-GGDfGOHNFhFvqSIRIkCSy6z+HpR-ybzVKNQhRaBDELxDTKnATviohMgvaKlqnzxbx6wUgjgACEjMaRVQEEwwqI0EmJreuc4sTgvAdwuIxCk0SpUwLkcJq4I4XAgSzMDKUswIEkYx8k74eRqJDx8RfclpGYcZBRCZYwyYSZFp1Waw74lABIGZwwepKZ8Y+ZKARZzxOQJZuZjYqp1ABILAhALAFZIIYpORjAQxIxCRgpTQcZKATZLAhZbZ-R3xVJVRsRvZJQQyc8w5Ek8RuA7O5Qd8oQVxhgpp2ZGpdR9RJQkIDAR0Y0zMhA22zCAq+o8RxgiI+urQtpYEDpGRDZg51AZIjJziYcBiTcppFRjZ0MLZDKdO9Mhe15oAt59pYY0oz5T5dOr5+ibi3gX5ccBZewA5v5DZDKK+wFK5W47sG5-8OZGe7Oe5B50g6gx5TCdCZ5XKc8l5U5UYMYEJ5OIkWFa5uF6pypBF+ERFokJFZFcgp5Aw551FRUTExQlwPRqiiJc6P0NY6sAM2gwJvUFArBtS4xCS4qAmNussMqZmfcUI0lf0clc4XCFAqqpxNWA+Lsv++lslmsCl3CGa1lGs8lxlQWeaiyL+CygmCcq+dItqjlhldlJlz8-ltlLlD+IB7l6BHCDk5cMBHiV+VlasTlRlo09lwVSVAVYV25RWkVxa6S3lX+3mP+uq3mIVzlqVQVkkZVKVilrl++uV6lSeBVcV7CskiVMlyVgVzWVVGVoVFVdVrWDVnWGGTArV1amWEyDlvV5VtVZBswHCHlqSY6yyE6DBM6klBS1VXVyl66shDwW1LlhgDATiUOk16VHVmV-Vv2x1spiKB1-Vg591tVR1TiDAliiKLBv5p+x1Oibkb1o2ERY5kIT1aVPVF1fVs1HF8QINSlv5MN5AzogN3JHZDAG+gBSBI+UNcQn1zZm+zofsY1D2FIYS75cFUIrVsSVW2S74lCWp+101NV3ChgAALM6O+GaEivTeDTNUzWSGcGNaoLwL6CcEAA","body":"function apply_generic(op, args) {\n    const type_tags = map(type_tag, args);\n    const fun = get(op, type_tags);\n    if (! is_undefined(fun)) {\n        return apply(fun, map(contents, args));\n    } else {\n        if (length(args) === 2) {\n            const type1 = head(type_tags);\n            const type2 = head(tail(type_tags));\n            const a1 = head(args);\n            const a2 = head(tail(args));\n            const t1_to_t2 = get_coercion(type1, type2);\n            const t2_to_t1 = get_coercion(type2, type1);\n            return type1 === type2\n                   ? error(list(op, type_tags),\n                                \"no method for these types\")\n                   : ! is_undefined(t1_to_t2)\n                   ? apply_generic(op, list(t1_to_t2(a1), a2))\n                   : ! is_undefined(t2_to_t1)\n                   ? apply_generic(op, list(a1, t2_to_t1(a2)))\n                   : error(list(op, type_tags),\n                           \"no method for these types\");\n        } else {\n            return error(list(op, type_tags),\n                         \"no method for these types\");\n        }\n    }\n} "}]}]}]},{"tag":"EXERCISE","title":"Exercise 2.82","id":"#ex-2.82","child":[{"body":"\n    Show how to generalize\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"\n    to handle coercion in the general case of multiple arguments.  One\n    strategy is to attempt to coerce all the arguments to the type of the\n    first argument, then to the type of the second argument, and so on.\n    Give an example of a situation where this strategy (and likewise the\n    two-argument version given above) is not sufficiently general.\n    (Hint: Consider the case where there are some suitable mixed-type\n    operations present in the table that will not be tried.)\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":293,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0oFA5KAPYAOApgE4CGALgJaEB2A+tZQEYA2pANKMQK7VQlBgBNQAc1LV8YAGblCAW1ABjABaVi1CqADMoABQBnUqrqN9aPdYCUOOfwbn6DYceOFVhgNakAnrzkZoTkosa2oADeOKBxoMHU-ORutMZMDPwcHIbBqqHh9vHFxQD8oE6ipHK0DKSisSUlAFygpACO-JQ5foGg6qSUooYDQ7khYRG2RU1N5aPDeQURjbPFrZQeXr4BvKy0OUuT0wDcOAC+Dk4ulkqUfizsXIaRMcX5DMZCHF7dj5ykUAAXlAHDS1EMACIAFSsAHQyG2M7FRzOCxuH6EHz8Yg7fxMACMvF6TBQr1WJQ+X1Axn4bDhXGB7k83hJRNA+xyP1UfwZpFOFOKtDkRjSTEq1Vq9RMdL502igtmiWSbglNTqomRs3ObQ4pgVa3ejGpR3EIM2LLxpL2lAOMvpT35SMVTWFovSaqliwmonlb0NTWVKQqYklGq1AZ1pD1gP9AeKQbcnPG+TCzvjoEuayz8RzcVRN1SnwoELZxIC1tAADduvx+QbZlShLSHQCmRbtmWObaub8OP8uAK1m7DGLPRr7XLyRnTNRHnbubzHdwXRm4sRbeRDGCvlb2RvaFuSSheDWOHXpiu12vk4v+1P09rdfq44amwkfe2tqyKyfu3aWynCNDRHMdQ3VaVTT9Vc1lnecckA5cYOvddN0MA8j1-U9a35K8UOvZNEIBaZH0jZ9Y2Qpo4OTU1sPPflgOzVc80zCkC3RUBRDSDdqA0QwlGnJVpBVUAVCBcTQEhTFsWISFKLKUFCCxHF5PiVoxIkyFalMchqDk-DQHKbSS1U9ZJPHeoiDIKgOIAWls7sAUhYCWMTTjuJoDQzkud8SAoGhXAHQEQTuB4+ReM53ykIQQT8mzAvCqSlJkxFIuNIQBBiqz-PRIKoWM3TUrwAhIDccBCGSVQeFEwhqXY1xjH6Sgq0BShQBqAAPSzMiUNhdEIEVKHICR+CUUgGGoYw0FkIwABUBna64OJ3IQ0g5BbGA4fw2g6qrtFcPZCHWtbPHaoa0HsAh5sBerLC0YgtqYWpxVDcgttqCQmAAK2azZVHIWhtGEbJCAAd0a-hGuoQgZvurbhAYbaJFoFq3FutGnA5I7ug4XVSDGibGoG9bWuG0bxpkAgVuEYbjF4TZQDdagBm20GKEBUwNxs0mRoJyarjRVxhGIB7-EMVF6dpwS4jcuH8WeiU3v8D7vt+4x-sBiEJZpiQIm8gXC2EURhg63h-Glj8kmDOWmCkOoAe8SEhlESFeBWwxTdAc3nUudGaTpD2zYt2WRceu2KFoR2W1d0FwUDr2BV9pahaULJ4-NhsZeE63Q-xcOHahVOOBj93Pe9-W-a4qt0+D7O3Bt-PI6hKuS7jsvE7wP2aFYDRHgkQxqH8Mg+94D4dEJ2urbcDCB6H0gR7URhx8mn2DY4wfh9YfvRBoUbJ5EsUZ53pIBMo+ZBmGY+98o1oKEULcr6UXhITYIZuwkKRxEf0B7I5Oe+6KknQWlgx4U2MIYR++9gyHzQpAs+-4chwPjLfcg98IG7yfpJV+4gt6f04hgn+DlQGE0AZ3ZOlhtKsGyKrGs6sAbaAyKNPq5AmAblUD4SgUgXiZ0WsApMnCPYWwTHXYQ1Ae7qD7lCH6tCNYMJ6swmOHVSKsWKJlKEztW67khNIv69C5zyIoDHbRatZH6KYYY2weEmg12BAAPnfh7UAABqBOyi1GQmjm7OOxiZF6MYb1Qxz8dF0M1v4hRljVw2KBPYrejiHLlwpO4oumiIQ+N0aEgx5AjHBNMWEixViShRJiQIjqoBoSuOAu4luXitE5L8Zk7JJj6nmKyREtYRSHGlLAAk1RghC73FII03xGSWmu1XKU6JnShzxDcpCUQjBBn60oTjGh6S5EtNYZQdhnDSARTIXw0SAzVkhPWQErcDAoFuGiv0vwQy1lmLOYiQwFz9YzUbqoGk0YzDQ3ILwwsjU5ChEXkoB6pBSmZOMPsw2wQ-hcwhAAL0ucLUWttxoR0djC-scKUmGERavP2tA7ifThbipFDc0UFy0kSzZhUakIo7n7IlDBaBJCqKSnhIcUXvP6RIZlrLBl0tJfi8h9cGASGeIijlIjyX2ybk7MVXAcV4oriKmknQhq7KUVKqeoBSnlI6q8glnwqH9jyKwMVWQhqbO2Vwi2ftMU0vpdES2IkFikpOCo+IBLqUkslVEF1wZkyIo9SxRlRyFDKCYA6wlJSg7OrcjPduIa2KqqZSy-gbK-WrjcncZmTBjDtF0iYdVwRxiwqGvSyITjTIlALV0UtMbiUVqFco0NqqRDit2VmtYOaaASJoCIFAo4fXNsRUEQYWLR3TLiG2g5oV54RqUEwalHbcj0yETMkRM9fnlNzRI-I4DKCWISGUw5ebjC1EMEe1tFICC1B0OQOQWzATQxJh+akxNmYc38F8fGKaDmxK1a+YROru5bIkbEyEZqO2WqybwJRLlEl9KgxOx1OKUPmBgxwIaiJx3lt0m45Dja0OCow+aka2HWm8GI3CwjqS038vQ9Bi1lHcOHN5emqodH1EKoFbHLRzGKM4ePR2wclTkPzqYIuqNqHG1GME7BsZ7T252IcZJ6T0aiU12nXwCT4bFBLpXWK+T3ysM4YKcUNdwhIiTNiepgzy7OFMFXeQddOnZnzLqM5C4OBlnUIU5R61HDbVnDXkLPzWLCCBbYcF3ZFs70TQoAwbofz0SQpRKmzhfKM1dteAGtwbrg2evzO23j7L-VuSDUiYrqWU76cjUZ-urnrPxq3WhZrR7k0ZYOQ631G6s46oYzl9lu6+1MAPVesryqKSzsNjRqdPCQMiSG5myIo3z2XtE7lm93XDb2cjZp2NCdFubp1TPPd+bC0QjrRqwRzi1X1t2d7CzKELsDoYEOvoSib23rAPeigT6qpYzfcED9Iov00h-ToJQ-7DaAby7LMR4HJGQmIFF8zurqssXcb1it6G0esePbjgj4nUnzdpfx1JBPhPUZHSTpD9Gsucb4+7VH6OqPsey1x0nPHO34-Z2xrb3HIT7aXYdiQRjqdwciSp2zAjRcyb+I27TwuFeNclwLl7cQrNHtU3Z+rhmnMubc8ojzCzvOXAi6w9nQWdl7LCxQ41Kz8ggq4B1W3tqeF3pBaEHQ4h0YAoMx+TDLGhoI3EFLvgWzYvpa9Zlh4GnZNaZU8B07Ilrki4N4r-scnn4BeEzXRDu2OJq6N2KnX-X8uSGkDchdDn1fPyl08jrP3igJYfcl3GAfYccWduN5QoKOq4vZPCskJ2BvLaz+Lstk6i3woJFWmtBlN34YRWSLXy+Azk4RQv5xS-N-b9xWSHbceDktn767sFw-eCj8r72hPDnp-E535EWy+-l-P6P20zfKFD-z9f+-gZH-sfkXqfntlkBfoPtfqALfuPlXqXp9Kuitl2rvtCIAdeMgV-hvj-iUFtsPovjgRmHgbfifiVgclXJAW7tAbAanhPsGAgc5uXpgf-qAMAOgWuMwevuwUQVNrvm-oQfGMQSATNngG3n9olo+s+sDqDkIJ+gtMYFDn+sXkLLEt2kJKBkjr3JBi7oPjHMGiIb0qkhoqRjoW7kYqYWCrhpEvPjfmPnLv3H3hYUPjYTAcfsLp4pTlCE4eYQPmYd-tYi4bAfYfaJQVfoEW4TziLlkOht4c-N4f4YUuETZsUv3EXKEc4SPhEQzs3CjDEb4ZYXEfkR1FYe0kkXrgIhQU4dQVkYYbXlJo-knpwj4ZfsURvh0vrg-gdo0f3O3Dpkklng3pJLEZEi3uUakQMWXk1ibsBGbl5ksk7tQk4R7nFqFmGg8EsYnkrsnkHK+G5BngruLs0bobYIXj5msfPBsfXpMRXrsSIvsRMYgcZoUS0c3uuq8gQPkBQKoELLSCLL7ngFwEIJ8eQN8YwEwNTCCJkNkKsaqqoFwFasCaCcwO7BbIiYFBCaAFCRwIaqqplP3l8a4LPGQOyBvKQH+CyvjBbKBB6OBF6IYNFPiSCYSaSSSXPG4XAWiWCRiTPO7CyXsGydRtDgkQIXEJycieCK2uRHAW5GKeCeCIhpcA7lctIIyUiUSaQKyWQGPq+H7AySyduOCE9EKdKSIm6itEaZSaAWQYbHqWyQaV8BaQJCaTqm6reIaRSQJKQbVpYAyR6faXOB6XfqaRfAPD2KGQuO6UKTprNhxAybKRSVuB6REHAdSYwtkKONDlMHAUtsGBZJqMxFKbQZSOlFjMQEyG6kmcoj2iIh0F0DkHydXnOPqdDMQPKAAGRtmAG1ndDql-i2lakDwkDTCAHlC+nQ6DmtmAGtBxmEAElgkJnhk5CVlVm5gGFp7BgzlznMALmykrSrxKlqAiCqnzzQzql9x0zdjDQqmklkqqCqCjSWo6CGBnlbzjq0gcDUDJHcFZzvlCAdnflGCkl9zAgSSsBXlNlzygAAA+UFAFoAAAhIzDSVUBBMMJuUyYwC+ZwjaOBSwHPCRNgTeOQHWIRRmEBVvHrD5geeqKIMebRaSVhbrEimKFiYxSsPGOUHmTfIecwIiSeYQGxbwK6f-BRcORxf0CGeRZwuxQGK0DRXRXhWQIuWxR3AeXxc5umUNLrDhf2fWLcYNloFesNHriJQIlpTZqBVpdeXPNweUFpdwdOSqWKYxUZRIMemBbpSceZaRcUFpZRYqV3LnKirKt4CQJLExTwu+FJbrEyHcLiNFeFZRUaMarwkyNcmFX-JvNJcoiOIhWBChXSaiNBNWaBrnOLE4LwHFYYMQpNIldGYWauFFVZRBWQEyPJXxfRXPCpYxPELlUhS9AVROB5dZWQMVYaJymHBSk3BlepTjK5RecNS1U6D1TOg1RmG5HfKEP6YYBldFRED5WuJCAwEdGNMzIQP7kCl+vqKScYEVExMUJcAFaqnUiMmciwIQOkc8kipJpcV0VsQIjVeAhcrwAAAz7l4nOVpInIPIKLPG6EHUvWnLMLvXpHOg4DuLGGeGQixFDFFFHF+F4Tpw37JGiLiIo440-VFH1F-U55aYUif5aouKf4ZxM2oZ9YFKH6M2Mx04Qgs3c1OZ9YkQwkHJ97MzBCapmzE3aoiQyrorqLGw4plzE37nvgfIhRHK-Vi7dGGAAAsvAegzo74bg6tDwiNMNFAhgAA7M6KLeoOLdVaPLwC8rDMbCwHbaQLsqoE7U7UiEAA","body":"function can_coerce_to(type_tags, target_type) {\n    return accumulate((type_tag, result) =>\n                        result &&\n                        (type_tag === target_type ||\n                         ! is_undefined(get_coercion(type_tag, target_type))),\n                      true,\n                      type_tags);\n}\n\nfunction find_coerced_type(type_tags) {\n    return is_null(type_tags)\n           ? undefined\n           : can_coerce_to(type_tags, head(type_tags))\n           ? head(type_tags)\n           : find_coerced_type(tail(type_tags));\n}\n\nfunction coerce_all(args, target_type) {\n    return map(arg => type_tag(arg) === target_type\n                      ? arg\n                      : get_coercion(type_tag(arg), target_type)(arg),\n               args);\n}\n\nfunction apply_generic(op, args) {\n    const type_tags = map(type_tag, args);\n    const fun = get(op, type_tags);\n    if (! is_undefined(fun)) {\n        return apply(fun, map(contents, args));\n    } else {\n        const target_type = find_coerced_type(type_tags);\n        if (! is_undefined(target_type)) {\n          return apply_generic(op, coerce_all(args, target_type));\n        } else {\n            return error(list(op, type_tags),\n                         \"no method for these types\");\n        }\n    }\n} "},{"body":"\n    A situation where this approach is not sufficient is if you have three\n    types, A, B, C where A can be coerced to B and C can be coerced to B, and\n    there is a registered operation for (A, B, B). Evaluating the operation for\n    (A, B, C) will only try (A, B, C) and (B, B, B) while you can just coerce C\n    to B and use the registered operation for (A, B, B)\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.83","id":"#ex-2.83","child":[{"body":"\n    Suppose you are designing a generic arithmetic system for dealing with\n    the tower of types shown in figure ","tag":"#text"},{"tag":"REF","body":"2.25","href":"/sicpjs/2.5.2#fig-2.25"},{"body":":\n    integer, rational, real, complex.  For\n    each type (except complex), design a\n    function\n    that raises objects of that type one level in the tower.  Show how to\n    install a generic ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"raise"},{"body":" operation that will\n    work for each type (except complex).\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":374,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0oFA5KAPYAOApgE4CGALgJaEB2A+tZQEYA2pANKMQK7VQlBgBNQAc1LV8YAGblCAW1ABjABaVi1CqADMoABQBnUqrqN9aPdYCUOOfwbn6DYceOFVhgNakAnrzkZoTkosa2oADeOKBxoMHU-ORutMZMDPwcHIbBqqHh9vHFxQD8oE6ipHK0DKSisSUlAFygpACO-JQ5foGg6qSUooYDQ7khYRG2RU1N5aPDeQURjbPFrZQeXr4BvKy0OUuT0wDcOAC+Dk4ulkqUfizsXIaRMcX5DMZCHF7dj5ykUAAXlAHDS1EMACIAFSsAHQyG2M7FRzOCxuH6EHz8Yg7fxMACMvF6TBQr1WJQ+X1Axn4bDhXGB7k83hJRNA+xyP1UfwZpFOFOKtDkRjSTEq1Vq9RMdL502igtmiWSbglNTqomRs3ObQ4pgVa3ejGpR3EIM2LLxpL2lAOMvpT35SMVTWFovSaqliwmonlb0NTWVKQqYklGq1AZ1pD1gP9AeKQbcnPG+TCzvjoEuayz8RzcVRN1SnwoELZxIC1tAADduvx+QbZlShLSHQCmRbtmWObaub8OP8uAK1m7DGLPRr7XLyRnTNRHnbubzHdwXRm4sRbeRDGCvlb2RvaFuSSheDWOHXpiu12vk4v+1P09rdfq44amwkfe2tqyKyfu3aWynCNDRHMdQ3VaVTT9Vc1lnecckA5cYOvddN0MA8j1-U9a35K8UOvZNEIBaZH0jZ9Y2Qpo4OTU1sPPflgOzVc80zCkC3RUBRDSDdqA0QwlGnJVpBVUAVCBcTQEhTFsWISFKLKUFCCxHF5PiVoxIkyFalMchqDk-DQHKbSS1U9ZJPHeoiDIKgOIAWls7sAUhYCWMTTjuJoDQzkud8SAoGhXAHQEQTuB4+ReM53ykIQQT8mzAvCqSlJkxFIuNIQBBiqz-PRIKoWM3TUrwAhIDccBCGSVQeFEwhqXY1xjH6Sgq0BShQBqAAPSzMiUNhdEIEVKHICR+CUUgGGoYw0FkIwABUBna64OJ3IQ0g5BbGA4fw2g6qrtFcPZCHWtbPHaoa0HsAh5sBerLC0YgtqYWpxVDcgttqCQmAAK2azZVHIWhtGEbJCAAd0a-hGuoQgZvurbhAYbaJFoFq3FutGnA5I7ug4XVSDGibGoG9bWuG0bxpkAgVuEYbjF4TZQDdagBm20GKEBUwNxs0mRoJyarjRVxhGIB7-EMVF6dpwS4jcuH8WeiU3v8D7vt+4x-sBiEJZpiQIm8gXC2EURhg63h-Glj8kmDOWmCkOoAe8SEhlESFeBWwxTdAc3nUudGaTpD2zYt2WRceu2KFoR2W1d0FwUDr2BV9pahaULJ4-NhsZeE63Q-xcOHahVOOBj93Pe9-W-a4qt0+D7O3Bt-PI6hKuS7jsvE7wP2aFYDRHgkQxqH8Mg+94D4dEJ2urbcDCB6H0gR7URhx8mn2DY4wfh9YfvRBoUbJ5EsUZ53pIBMo+ZBmGY+98o1oKEULcr6UXhITYIZuwkKRxEf0B7I5Oe+6KknQWlgx4U2MIYR++9gyHzQpAs+-4chwPjLfcg98IG7yfpJV+4gt6f04hgn+DlQGE0AZ3ZOlhtKsGyKrGs6sAbaAyKNPq5AmAblUD4SgUgXiZ0WsApMnCPYWwTHXYQ1Ae7qD7lCH6tCNYMJ6swmOHVSKsWKJlKEztW67khNIv69C5zyIoDHbRatZH6KYYY2weEmg12BAAPnfh7UAABqBOyi1GQmjm7OOxiZF6MYb1Qxz8dF0M1v4hRljVw2KBPYrejiHLlwpO4oumiIQ+N0aEgx5AjHBNMWEixViShRJiQIjqoBoSuOAu4luXitE5L8Zk7JJj6nmKyREtYRSHGlLAAk1RghC73FII03xGSWmu1XKU6JnShzxDcpCUQjBBn60oTjGh6S5EtNYZQdhnDSARTIXw0SAzVkhPWQErcDAoFuGiv0vwQy1lmLOYiQwFz9ZryFhIVQwxKC8DYJc0AbBgQSQAAyGWEKAVoHzhhsHpqAAApP81ebyKGfCof2eKjA-hsI4Vwi2BBag6BSN0XhhZjBsXIW4HqFBBE8OEVPfoF9BEuTJQcqoDBlDUtfLSkSyYlFMpROSw5DwbLPN4L6Gl8QuBCAkEySFIrOLKK5cGGebgwASFFaAVVyiWJd2NkwYV7dxVZzpaFeewrKVbiUWUzi412UZycaZAM5rDAZ3Kay9lSiCkGXiG6pQ1LXU2t9T03MzLDYtj1TQGxnKZkiJNeGiETrLX+rZYGyItkHWGidS661ybBGeq9dm91kQk22umXEbVAqi5xsjauNysazXkwtUW0Ama2n5uKD6v1BaU1apDRxKuVaDVRqNSJOtEaE1No7ebPNXqO2JubQ251paVHxDxRNCgcgtmAmhh+akxNmYc38F8fGvahaxMtUOy2Ilu5bIkbEyE6KGDdEUT23pqSNE1NSQ+p9z8v3F1bdYg1kzYnOwHUHJd7jPGxy0b+oxMH-2FMA8U-uYb9VgbcX0yEySP1Qhgz+gKGK-3TqMIhhxlbUOuPQ6k6pUHP34cfcXPD6In3weKB02J-byPe0ozcwZjHXDfsiQwUVkQgMCNHfG4THdlnUN-Zs7ZOKzhIrcOJ-jOQhPyp4W5a5mGBmwbo8xuVvpXkEEbqoGk0YzDQ3IMS9EjU5ChEXkoB6pBSmZNJUpj8mKhoQgAF5-IbuNCOjtghecKthvzq8-a0DuJ9Lmvn-O51toFguWkYubLCzRwwEWK4Vs4QwWgSQqhZYS6LJL9sm46YkPlwrvHMvZYuB5kQEhnh+c0yIgL5XHZNa4Ck4rkWBXGE6ENXZ56KRuVKeUjqryosopWXkVgDARocCGnJ7FuyLZ+xC-2OLxXoiXuDAsYrJxl35gFdFzh6X4t7bcsmPzx3y0HNjQoZQerBj9nO-3Qd+3p5oXbvdk9tw8sFf4EV1rF7a00AkYN3SJghvBHGKF+LkR7X5sG10eHH3Lt9ZffELui2WtCOjcayHTAaAiBQKONLO2-NBDe1j+rxQHuGye4oJQTA0tNdyPTQnw6lVoWs+Uu4zMmD5HAZQSxCQrVC6h7UQw4ucdxFXQSjdVUsYkx3UIPdC1jCHp0EoAH-DPs8++6I8Rkj72Waa1kIaz6+XxHcVty7vWLfmCt8t1ptPEfcdSxduLzv5tu5txLzHcXvcxeqyD2r7sXcLaW0H3g4fgdVG991qP3iA+Letx7hGzWGKJIwyzl7juPuwct5n93Yz2kkdiYXtnxeYs13AwXo5z22cc8W6X135ebdEa58IETSH+It9Z+zi7nPyDc6XbM+ZdRnINek2isvceWFYp2XsjzC-WGEHd6ttfuKwD4ooPRmzDUDeHKq0n3ZYOTeHbuydk-d18dX9eCb27SJ79+1r6Pz64-ufXZETPBPv3v9vygco7tTsbhDhfjVrtoLiTqLnLk-n1nbqdgciHt5rtuDjGkDjAa1nAcLsYLLqnsgRSEzhxF-vXiUkHIaibjPNLkwNDhCGjsNtSi4swfDt7ERhmPQWTgwBTn0Eoj2hSEruupumrvuhrkQCKBITrkevrqAYbGei-rLGIjeubsQNvj3qALyvfg7nTn7thpCBoRXhLuAd5t7ugRltHsYfHozFTuYZUs3tAZHs7jYdnonjVink-q4ZodnqnmHsPkXnTiXs-G4ZXrMGxmJoEXXsEQ3u3E3qkl-u3hIEYmEb3kAeLnYqRtEd-qTotn3vLsotPgsnPpcJvm4bvgpvsobJvvkE5lwB1JUetjwnik5qEDoOIOjHZqzh+F3svgjOIG4XwFsmtqSgoeQTkZQZ9tQVgXStphQbEZwp3rHlnk8n9qQWfkkWPvkRkZASIvMTkckakb4U8rsUysIQfmuoSrjF0WfiBnUc5h1FluyD5mSDQRDg8K3q9n8B9gjtthgT5gSMjumvmmYTDq8Sxm2gGJYb5kCc4iCV6jCVlmSArg-m4GGg8Q0c8bwBCe8dgZ8SPlMX8fTnCWmlCdeGCb5mSFweSUKPYeCaSQiQZEiRCaiZ-lkCLsoI8diaALibMSOocdsf3B4ZHs8UWkydeCKaDtSRKWuMQYCcCbSQGPKSiSgWie5FWJyfUS5jyXyTWvifPF8ckUPs4aDnCcALKdwTgaKRCTSbSfKYyUqYaCqUupcBcYzFcSrlukdMELutIdrrrseuMaegImDvqXSter3HepiS5jHHdhsa+uosbM7jGR1EYqmYiL3oCTiW8aJv3PcVyVidmbySid7pBtHhmc-BmZCXELqbmYPhiYWTqcWayWHlkCmU2WmVWZ2ZmZEi2fWaRhyamXWSRI4VRijB2dqV2ZJNWVmS8QOexijFqdyf2aOfnokZMYsSkd2VOeEQBtQXmUPgSUET8XEWhmOTxkwEaUKemT2ekX-oeVsT-jsZPkUSInMiUUsrNtQqmU0evp-kcr+V8USe3K+FptIJecBVubebubYDXDlo9oBZ2VeSPsabsWBfsRBTpseW3jeTuY8acdzsZmAPkBQKoELLSCLO0XgJKovGRYFNTCCJkNkIpn7KoFwCtqReQORYwEwO7BbFxTxcwIxfOixQ1h5plJyfRYwLPGQOyBvKQH+AVvjBbKBB6OBF6IYNFFJdxa4LJaQPJXPKWTQYJQxeCEyDPO7ApYZWQEpXrjWeSaZbxStFquRHiXSk5cJeCEym6X7NpZ5fpTZYpRtgKtpdZduOCE9PZe5SJIditFFSpWqX5dICwEZRFV8AlQJDFQdgyreJFcpQJGyaFSlQVelXOAVXsXSodsmHlRlRVa6Wfv5YQNJcwMpVuAVREDQWpYwtkKOHrlMDQYqqqBpeGMxG5RekaCiljMQEyIdh1QqkJHSh0F0DkNZbwGFXPASAPCQPKAAGS7VMnLXdD6V-gbW2XbXEDTBMnlDaWlXQyXVMkQopWeUJVbjJjzULVloJlE4iRNUtWvWGAvUuXTYCodZBaGAkCSy6wCXpR-ybycKNQhRaD6ULxDTQ3ATviogyoQWQ1w3zxbx6wUgjgACEjM6lVQEEwwqI0EawIcos4sTgCeyNxCk0UNUwLk41q4I4XAi2zMcuUsgKIIbxE18Q741ls1uV-8BNn1lIsNClKAEtYwNVUtCNS6aw74lABIitXyUsjEjYsNlACtII1VPY-N0NMtk11I1ABILAhALARtkgz1zVulMla1eNZIetTQYtKAttLAWtIIf1LtDAJ1ewm1FtP1wYpNYEFNml1tvt1AZI11wspWpmENxA2Gcd0M9tcuQJ9MKJj1oAUd5NYY0oCd8dQJSdYNBcuN7smtewPtWd1tcupZBdd8oQZVadod8N0Ndp+EkIbKok0g6ghAnRDm+6+oClxgRU2YnNGYbkbdW47suNClfcEQvda4-dR0Y0zMI97UY9AwE9c8U9MtLElwvlAqVAaQI2JWYcyWFWl9pgvWghxFRsOCR0CATSmstkmSwx8mpAOADutoj9hhdSIyjy8GEy9iKmBG8cQJzoIABAzsauv6v9a2M0gDV9-u+mhGM0xQkDgqpqb2ECKMvA46oqAagiAoBAGDwDmW962DvZBAeDWRsaQFhJW58cQKVDCDr9yDb2qDOy6DGGD9ae0Gb2jDYAzDkyrDyFUFp5VBoAXDzoOAGtTIsaoDpyzChgHtKjsNAKSNQq2D2jvAegzoIjcu8DYA5jvyJwQAA","body":"function raise(x) {\n    return apply_generic(\"raise\", list(x));\n}\n\n// add to Javascript-number package\nput(\"raise\", list(\"javascript_number\"),\n    x => make_rational(x, 1));\n//// add to rational package\n// put(\"raise\", list(\"rational\"),\n//     x => make_real(div, numer(x), denom(x)));\n// put(\"raise\", list(\"rational\"),\n//     x => make_complex_from_real_imag(x, 0));\n//// add to real package\n// put(\"raise\", list(\"real\"),\n//     x => make_complex_from_real_imag(x, 0)); "}]},{"tag":"EXERCISE","title":"Exercise 2.84","id":"#ex-2.84","child":[{"body":"\n    Using the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"raise"},{"body":" operation of\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.83","href":"/sicpjs/2.5.2#ex-2.83"},{"body":", modify the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"function\n    so that it coerces its arguments to have the same type by the method of\n    successive raising, as discussed in this section.  You will need to devise\n    a way to test which of two types is higher in the tower.  Do this in a\n    manner that is \"","tag":"#text"},{"body":"compatible","tag":"#text"},{"body":"\" with the rest of the system and\n    will not lead to problems in adding new levels to the tower.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.85","id":"#ex-2.85","child":[{"body":"\n    This section mentioned a method for \"","tag":"#text"},{"body":"simplifying","tag":"#text"},{"body":"\" a data object\n    by lowering it in the tower of types as far as possible.  Design a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"drop"},{"body":" that accomplishes this for the tower\n    described in exercise ","tag":"#text"},{"tag":"REF","body":"2.83","href":"/sicpjs/2.5.2#ex-2.83"},{"body":".  The key is to decide,\n    in some general way, whether an object can be lowered.  For example, the\n    complex number ","tag":"#text"},{"body":"$1.5+0i$","tag":"LATEX"},{"body":" can be lowered as far as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"real\""},{"body":",\n    the complex number ","tag":"#text"},{"body":"$1+0i$","tag":"LATEX"},{"body":" can be lowered as far\n    as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"integer\""},{"body":",\n    and the complex number ","tag":"#text"},{"body":"$2+3i$","tag":"LATEX"},{"body":" cannot be lowered\n    at all.  Here is a plan for determining whether an object can be lowered:\n    Begin by defining a generic operation ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"project"},{"body":"\n    that \"","tag":"#text"},{"body":"pushes","tag":"#text"},{"body":"\" an object down in the tower.  For example,\n    projecting a complex number would involve throwing away the imaginary part.\n    Then a number can be dropped if, when we\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"project"},{"body":" it and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"raise"},{"body":" the result back to the type we started\n    with, we end up with something equal to what we started with.  Show how to\n    implement this idea in detail, by writing a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"drop"},{"body":"function\n    that drops an object as far as possible.  You will need to design the\n    various projection operations","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/2.5.2#footnote-5"},{"body":" and install\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"project"},{"body":" as a generic operation in the system.\n    You will also need to make use of a generic equality predicate, such as\n    described in exercise ","tag":"#text"},{"tag":"REF","body":"2.79","href":"/sicpjs/2.5.1#ex-2.79"},{"body":".  Finally, use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"drop"},{"body":"\n    to rewrite\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"\n    from exercise ","tag":"#text"},{"tag":"REF","body":"2.84","href":"/sicpjs/2.5.2#ex-2.84"},{"body":" so that it\n    \"","tag":"#text"},{"body":"simplifies","tag":"#text"},{"body":"\" its answers.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.86","id":"#ex-2.86","child":[{"body":"\n    Suppose we want to handle complex numbers whose real\n    parts, imaginary parts, magnitudes, and angles can be either ordinary\n    numbers, rational numbers, or other numbers we might wish to add to\n    the system.  Describe and implement the changes to the system needed\n    to accommodate this.  You will have to define operations such as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sine"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"cosine"},{"body":"\n    that are generic over ordinary numbers and rational numbers.\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/2.5.2#footnote-link-1","child":[{"body":"We\n    also have to supply an almost identical\n    function\n    to handle the types","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(\"javascript_number\", \"complex\")"},{"body":".\n      ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/2.5.2#footnote-link-2","child":[{"body":"See exercise ","tag":"#text"},{"tag":"REF","body":"2.82","href":"/sicpjs/2.5.2#ex-2.82"},{"body":" for\n    generalizations.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/2.5.2#footnote-link-3","child":[{"body":"If we are\n    clever, we can usually get by with fewer than\n    ","tag":"#text"},{"body":"$n^2$","tag":"LATEX"},{"body":" coercion\n    functions.\n    For instance, if we know how to convert from type 1 to type 2 and from\n    type 2 to type 3, then we can use this knowledge to convert from type 1 to\n    type 3.  This can greatly decrease the number of coercion\n    functions\n    we need to supply explicitly when we add a new type to the system.  If we\n    are willing to build the required amount of sophistication into our system,\n    we can have it search the \"","tag":"#text"},{"body":"graph","tag":"#text"},{"body":"\" of relations among types and\n    automatically generate those coercion\n    functions\n    that can be inferred from the ones that are supplied\n    explicitly.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/2.5.2#footnote-link-4","child":[{"body":"This statement, which also appears in\n    the first edition of this book, is just as true now as it was when we wrote\n    it\n    in 1984.\n    Developing a useful, general framework for expressing\n    the relations among different types of entities (what philosophers call\n    \"","tag":"#text"},{"body":"ontology","tag":"#text"},{"body":"\") seems intractably difficult.  The main difference\n    between the confusion that existed\n    in 1984\n    and the confusion that\n    exists now is that now a variety of inadequate ontological theories have\n    been embodied in a plethora of correspondingly inadequate programming\n    languages.  For example, much of the complexity of\n    \n    object-oriented programming languages—and the subtle and confusing\n    differences among contemporary object-oriented\n    languages—centers on the treatment of generic operations on\n    interrelated types.  Our own discussion of computational objects in\n    chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":" avoids these issues entirely.  Readers familiar with\n    object-oriented programming will notice that we have much to say in\n    chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":" about local state, but we do not even mention\n    \"","tag":"#text"},{"body":"classes","tag":"#text"},{"body":"\" or \"","tag":"#text"},{"body":"inheritance.","tag":"#text"},{"body":"\"  In fact, we suspect\n    that these problems cannot be adequately addressed in terms of\n    computer-language design alone, without also drawing on work in knowledge\n    representation and automated reasoning.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/2.5.2#footnote-link-5","child":[{"body":"A real number can be projected to\n    an integer using the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"math_round"},{"body":"\n    primitive, which returns the closest integer\n    to its argument.","tag":"#text"}]}]