<SUBSECTION>
  <NAME>
    Compiling
    <SPLITINLINE>
      <SCHEME>Expressions</SCHEME>
      <JAVASCRIPT>Components</JAVASCRIPT>
    </SPLITINLINE>
  </NAME>

  <LABEL NAME="sec:compiling-components"/>  
  <TEXT>
    In this section and the next we implement the code generators to which the
    <SCHEMEINLINE>compile</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    dispatches.
  </TEXT>

  <SUBHEADING>
    <NAME>Compiling linkage code</NAME>
  </SUBHEADING>

  <TEXT>
    <INDEX>compiler for JavaScript<SUBINDEX>linkage code</SUBINDEX></INDEX>
    In general, the output of each code generator will end with
    instructions<EMDASH/>generated by the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-linkage</SCHEMEINLINE><EMDASH/>that</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compile_linkage</JAVASCRIPTINLINE><EMDASH/>that
      </JAVASCRIPT>
    </SPLITINLINE>
    implement the required linkage.  If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    then
    we must generate the instruction
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    This needs the <SCHEMEINLINE>continue</SCHEMEINLINE> register and does not
    modify any registers.
    <SPLIT>
      <JAVASCRIPT>
	If the linkage is <JAVASCRIPTINLINE>"return_undefined"</JAVASCRIPTINLINE>,
	we insert an assignment instruction before the
	<JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE>, which assigns the
  the constant <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> to
	the current target register. The target register
	must be treated as modified in this case.
      </JAVASCRIPT>
    </SPLIT>
    If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    then we needn<APOS/>t include any additional instructions.  Otherwise, the
    linkage is a label, and we generate a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to that label, an instruction that does not need or modify
    any registers.<SPLITINLINE><SCHEME><FOOTNOTE>This procedure
    uses a feature of Lisp
    called
    <INDEX>list(s)<SUBINDEX>backquote with</SUBINDEX></INDEX>
    <INDEX>backquote</INDEX><INDEX>quasiquote</INDEX>
    <INDEX><USE>`</USE> (backquote)</INDEX>
    <INDEX><USE>,</USE> (comma, used with backquote)</INDEX>
    <INDEX>comma, used with backquote</INDEX>
    <EM>backquote</EM> (or <EM>quasiquote</EM>) that is handy for constructing
    lists. Preceding a list with a backquote symbol is much like quoting it,
    except that anything in the list that is flagged with a comma is
    evaluated.
    <P/>
    For example, if the value of <SCHEMEINLINE>linkage</SCHEMEINLINE> is the
    symbol <SCHEMEINLINE>branch25</SCHEMEINLINE>,
    then the expression
    <SCHEMEINLINE>`((goto (label ,linkage)))</SCHEMEINLINE>
    evaluates to the list
    <SCHEMEINLINE>((goto (label branch25)))</SCHEMEINLINE>.
    Similarly, if the value of <SCHEMEINLINE>x</SCHEMEINLINE> is the list
    <SCHEMEINLINE>(a b c)</SCHEMEINLINE>,
    then
    <SCHEMEINLINE>`(1 2 ,x)</SCHEMEINLINE>
    evaluates to the list
    <SCHEMEINLINE>(1 2 a)</SCHEMEINLINE>.</FOOTNOTE></SCHEME></SPLITINLINE>
    <INDEX><DECLARATION>compile_linkage</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>compile_linkage</NAME>
      <SCHEME>
      (define (compile-linkage linkage)
      (cond ((eq? linkage 'return)
            (make-instruction-sequence '(continue) '()
            '((goto (reg continue)))))
            ((eq? linkage 'next)
            (empty-instruction-sequence))
            (else
            (make-instruction-sequence '() '()
            ` ((goto (label ,linkage)))))))
      </SCHEME>
      <JAVASCRIPT>
function compile_linkage(target, linkage) {
    return linkage === "return"
           ? make_instruction_sequence(list("continue"), 
                                       null,
                                       list(go_to(reg("continue"))))
           : linkage === "return_undefined"
           ? make_instruction_sequence(null, 
                                       list(target),
                                       list(assign(target, constant(undefined)),
                                            restore_marker(),
                                            restore("continue"),
                                            go_to(reg("continue"))))
           : linkage === "next"
           ? empty_instruction_sequence()
           : make_instruction_sequence(null, null, list(go_to(label(linkage))));
      </JAVASCRIPT>
    </SNIPPET>

    The linkage code is appended to an instruction sequence by
    <SCHEMEINLINE>preserving</SCHEMEINLINE> the
    <SCHEMEINLINE>continue</SCHEMEINLINE> register, since a
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    linkage will
    require the <SCHEMEINLINE>continue</SCHEMEINLINE> register:
    If the given instruction sequence modifies
    <SCHEMEINLINE>continue</SCHEMEINLINE> and the linkage code needs it,
    <SCHEMEINLINE>continue</SCHEMEINLINE> will be saved and restored.
    <INDEX><DECLARATION>end_with_linkage</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>end_with_linkage</NAME>
      <SCHEME>
      (define (end-with-linkage linkage instruction-sequence)
      (preserving '(continue)
      instruction-sequence
      (compile-linkage linkage)))
      </SCHEME>
      <JAVASCRIPT>
function end_with_linkage(target, linkage, instruction_sequence) {
    return preserving(list("continue"),
                      instruction_sequence,
                      compile_linkage(target, linkage));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Compiling simple expressions</NAME>
  </SUBHEADING>

  <TEXT>
    <INDEX>compiler for JavaScript<SUBINDEX>literals</SUBINDEX></INDEX>
    <INDEX>compiler for JavaScript<SUBINDEX>names</SUBINDEX></INDEX>
    The code generators for 
    <SPLITINLINE>
      <SCHEME>self-evaluating expressions, quotations, and variables</SCHEME>
      <JAVASCRIPT>literal expressions and names</JAVASCRIPT>
    </SPLITINLINE>
    construct instruction
    sequences that assign the required value to the target register
    and then proceed as specified by the linkage descriptor.
    <INDEX><DECLARATION>compile_literal</DECLARATION></INDEX> 
    <INDEX><DECLARATION>compile_name</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>compile_literal</NAME>
      <SCHEME>
      (define (compile-self-evaluating exp target linkage)
      (end-with-linkage linkage
      (make-instruction-sequence '() (list target)
      `((assign ,target (const ,exp))))))

      (define (compile-quoted exp target linkage)
      (end-with-linkage linkage
      (make-instruction-sequence '() (list target)
      `((assign ,target (const ,(text-of-quotation exp)))))))

      (define (compile-variable exp target linkage)
      (end-with-linkage linkage
      (make-instruction-sequence '(env) (list target)
      `((assign ,target
            (op lookup-variable-value)
            (const ,exp)
            (reg env))))))
    </SCHEME>
    <JAVASCRIPT>
function compile_literal(component, target, linkage) {
    return end_with_linkage(target, linkage,
               make_instruction_sequence(
                   null,
                   list(target),
                   list(assign(target, constant(literal_value(component))))));
}

function compile_name(component, target, linkage) {
    return end_with_linkage(target, linkage,
               make_instruction_sequence(list("env"), list(target),
                   list(assign(target, 
                        list(op("lookup_symbol_value"), 
                             constant(symbol_of_name(component)), 
                             reg("env"))))));
}
    </JAVASCRIPT>
    </SNIPPET>

    All these assignment instructions modify the target register,
    and the one that looks up a
    <SPLITINLINE>
      <SCHEME>
	variable
      </SCHEME>
      <JAVASCRIPT>
	name
      </JAVASCRIPT>
    </SPLITINLINE>
    needs the <SCHEMEINLINE>env</SCHEMEINLINE> register.
  </TEXT>

  <TEXT>
    <INDEX>compiler for JavaScript<SUBINDEX>assignments</SUBINDEX></INDEX>
    <INDEX>compiler for JavaScript<SUBINDEX>declarations</SUBINDEX></INDEX>
    Assignments and
    <SPLITINLINE>
      <SCHEME>definitions</SCHEME>
      <JAVASCRIPT>the two kinds of declarations</JAVASCRIPT>
    </SPLITINLINE>
    are handled much as they are in the
    interpreter.
    <SPLIT>
      <JAVASCRIPT>
	The two functions use the function
	<JAVASCRIPTINLINE>compile_assignment_returning</JAVASCRIPTINLINE>,
	whose parameter
	<JAVASCRIPTINLINE>return_val</JAVASCRIPTINLINE> lets declarations
	return <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> and assignments
	return the assigned value.
      </JAVASCRIPT>
    </SPLIT>
    We recursively generate code that computes the value to be assigned to the variable, and
    <SPLITINLINE><JAVASCRIPT>use <JAVASCRIPTINLINE>compile_assignment_returning</JAVASCRIPTINLINE> to</JAVASCRIPT></SPLITINLINE>
    append to it a two-instruction sequence that actually sets
    <SPLITINLINE>
      <SCHEME>or defines</SCHEME>
    </SPLITINLINE>
    the variable and assigns the
    value of the whole
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
      <JAVASCRIPT>statement</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	(the symbol <SCHEMEINLINE>ok</SCHEMEINLINE>)
      </SCHEME>
    </SPLITINLINE>
    to the target register.  The recursive compilation has target
    <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    so that the code will put its result into
    <SCHEMEINLINE>val</SCHEMEINLINE> and continue with the code that is appended
    after it.  The appending is done preserving <SCHEMEINLINE>env</SCHEMEINLINE>,
    since the environment is needed for setting <SPLITINLINE><SCHEME>or defining</SCHEME></SPLITINLINE> the variable and the
    code for the variable value could be the compilation of a complex expression
    that might modify the registers in arbitrary ways.
    <INDEX><DECLARATION>compile_assignment</DECLARATION></INDEX> 
    <INDEX><DECLARATION>compile_declaration</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>compile_assignment</NAME>
      <SCHEME>
      (define (compile-assignment exp target linkage)
      (let ((var (assignment-variable exp))
            (get-value-code
            (compile (assignment-value exp) 'val 'next)))
      (end-with-linkage linkage
      (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
      `((perform (op set-variable-value!)
            (const ,var)
            (reg val)
            (reg env))
            (assign ,target (const ok))))))))

      (define (compile-definition exp target linkage)
      (let ((var (definition-variable exp))
            (get-value-code
            (compile (definition-value exp) 'val 'next)))
      (end-with-linkage linkage
      (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
      `((perform (op define-variable!)
            (const ,var)
            (reg val)
            (reg env))
            (assign ,target (const ok))))))))
      </SCHEME>
      <JAVASCRIPT>
function compile_assignment(component, target, linkage) {
    const symbol = assignment_symbol(component);
    const value_code =
              compile(assignment_value_expression(component), "val", "next");
    return compile_assignment_returning(symbol,
               value_code, target, linkage, reg("val"));
}

function compile_declaration(component, target, linkage) {
    const symbol = declaration_symbol(component);
    const value_code = compile(declaration_value_expression(component), "val", "next");
    return compile_assignment_returning(symbol,
               value_code, target, linkage, constant(undefined));
}

function compile_assignment_returning(symbol, value_code, target,
                                      linkage, return_val) {
    return end_with_linkage(target, linkage,
               preserving(
                   list("env"),
                   value_code,
                   make_instruction_sequence(
                       list("env", "val"),
                       list(target),
                       list(perform(
                                list(op("assign_symbol_value"),
                                     constant(symbol),
                                     reg("val"),
                                     reg("env"))),
                            assign(target, return_val)))));
}
      </JAVASCRIPT>
    </SNIPPET>

    The appended two-instruction sequence requires
    <SCHEMEINLINE>env</SCHEMEINLINE> and <SCHEMEINLINE>val</SCHEMEINLINE>
    and modifies the target.  Note that although we preserve
    <SCHEMEINLINE>env</SCHEMEINLINE> for this sequence, we do not preserve
    <SCHEMEINLINE>val</SCHEMEINLINE>, because the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-value-code</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>value_code</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is designed to explicitly place its result in
    <SCHEMEINLINE>val</SCHEMEINLINE> for use by this sequence.
    (In fact, if we did preserve <SCHEMEINLINE>val</SCHEMEINLINE>, we would
    have a bug, because this would cause the previous contents of
    <SCHEMEINLINE>val</SCHEMEINLINE> to be restored right after the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-value-code</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>value_code</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is run.)
  </TEXT>

  <SUBHEADING>
    <NAME>Compiling 
    <SPLITINLINE>
      <SCHEME>
        conditional expressions
      </SCHEME>
      <JAVASCRIPT>
        conditionals
      </JAVASCRIPT>
    </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    <INDEX>compiler for JavaScript<SUBINDEX>conditionals</SUBINDEX></INDEX>
    The code for 
    <SPLITINLINE>
      <SCHEME>
	an <SCHEMEINLINE>if expression</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	a conditional
      </JAVASCRIPT>
    </SPLITINLINE>
    compiled with a given target and linkage has the form
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      ^compilation of predicate, target^ val^, linkage^ next
      (test (op false?) (reg val))
      (branch (label false-branch))
      true-branch
      ^compilation of consequent with given target and given linkage or^ after-if
      false-branch
      ^compilation of alternative with given target and linkage^
      after-if
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>compilation of predicate, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>next</JAVASCRIPTINLINE></METAPHRASE>
  test(list(op("is_falsy"), reg("val"))),
  branch(label("false_branch")),
"true_branch",
  <METAPHRASE>compilation of consequent with given target and given linkage or <JAVASCRIPTINLINE>after_cond</JAVASCRIPTINLINE></METAPHRASE>
"false_branch",
  <METAPHRASE>compilation of alternative with given target and linkage</METAPHRASE>
"after_cond"
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    To generate this code, we compile the predicate, consequent,
    and alternative, and combine the resulting code with instructions
    to test the predicate result and with newly generated labels to mark the
    true and false branches and the end of the 
    conditional.<FOOTNOTE>We can<APOS/>t just use the labels
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>true-branch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>true_branch</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>false-branch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>false_branch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>after-if</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>after_cond</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    as shown above, because there might be more than one
    <SPLITINLINE><SCHEME><SCHEMEINLINE>if</SCHEMEINLINE></SCHEME><JAVASCRIPT>conditional</JAVASCRIPT></SPLITINLINE>
    in the program.
    <INDEX>compiler for JavaScript<SUBINDEX>label generation</SUBINDEX></INDEX>
    The compiler uses the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-label</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_label</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to generate labels.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-label</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_label</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    takes a <SPLITINLINE><SCHEME>symbol</SCHEME><JAVASCRIPT>string</JAVASCRIPT></SPLITINLINE> as argument and returns a new
    <SPLITINLINE><SCHEME>symbol</SCHEME><JAVASCRIPT>string</JAVASCRIPT></SPLITINLINE> that begins with the
    given <SPLITINLINE><SCHEME>symbol</SCHEME><JAVASCRIPT>string</JAVASCRIPT></SPLITINLINE>.  For example, successive calls to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(make-label 'a)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_label("a")</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    would return
    <SPLITINLINE><SCHEME><SCHEMEINLINE>a1</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>"a1"</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
    <SPLITINLINE><SCHEME><SCHEMEINLINE>a2</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>"a2"</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
    and so on.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-label</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_label</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    can be implemented similarly to the generation of unique variable names in
    the query language, as follows:
    <SPLITINLINE>
      <SCHEME>
	<INDEX>character strings<SUBINDEX>primitive procedures for</SUBINDEX></INDEX>
      </SCHEME>
    </SPLITINLINE>
    <INDEX><DECLARATION>make_label</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>make_label</NAME>
      <SCHEME>
        (define label-counter 0)

        (define (new-label-number)
        (set! label-counter (+ 1 label-counter))
        label-counter)

        (define (make-label name)
        (string-&gt;symbol
        (string-append (symbol-&gt;string name)
              (number-&gt;string (new-label-number)))))
      </SCHEME>
      <JAVASCRIPT>
let label_counter = 0;

function new_label_number() {
    label_counter = label_counter + 1;
    return label_counter;
}

function make_label(name) {
    return name + stringify(new_label_number());
}
      </JAVASCRIPT>
    </SNIPPET></FOOTNOTE>
    In this arrangement of code, we must branch around the true branch
    if the test is false.  The only slight complication is in how the
    linkage for the true branch should be handled.  If the linkage for the
    conditional is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    or a label, then the
    true and false branches will both use this same linkage.  If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    the true branch ends with a jump around
    the code for the false branch to the label at the end of the conditional.
    <INDEX><DECLARATION>compile_conditional</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>compile_conditional</NAME>
      <SCHEME>
      (define (compile-if exp target linkage)
      (let ((t-branch (make-label 'true-branch))
            (f-branch (make-label 'false-branch))                    
            (after-if (make-label 'after-if)))
      (let ((consequent-linkage
            (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
            (compile
            (if-consequent exp) target consequent-linkage))
            (a-code
            (compile (if-alternative exp) target linkage)))
            (preserving '(env continue)
            p-code
            (append-instruction-sequences
            (make-instruction-sequence '(val) '()
            `((test (op false?) (reg val))
            (branch (label ,f-branch))))
            (parallel-instruction-sequences
            (append-instruction-sequences t-branch c-code)
            (append-instruction-sequences f-branch a-code))
            after-if))))))
      </SCHEME>
      <JAVASCRIPT>
function compile_conditional(component, target, linkage) {
    const t_branch = make_label("true_branch");
    const f_branch = make_label("false_branch");
    const after_cond = make_label("after_cond");
    const consequent_linkage =
            linkage === "next" ? after_cond : linkage;
    const p_code = compile(conditional_predicate(component), "val", "next");
    const c_code = compile(conditional_consequent(component),
                         target, consequent_linkage);
    const a_code = compile(conditional_alternative(component),
                         target, linkage);
    return preserving(
               list("env", "continue"),
               p_code,
               append_instruction_sequences(
                   make_instruction_sequence(
                       list("val"),
                       null,
                       list(test(list(op("is_falsy"), reg("val"))),
                            branch(label(f_branch)))),
                   append_instruction_sequences(
                       parallel_instruction_sequences(
                           append_instruction_sequences(t_branch, c_code),
                           append_instruction_sequences(f_branch, a_code)),
                       after_cond)));
}
      </JAVASCRIPT>
    </SNIPPET>

    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Env</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	The register
	<SCHEMEINLINE>env</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is preserved around the predicate code
    because it could be needed by the true and false branches, and
    <SCHEMEINLINE>continue</SCHEMEINLINE> is preserved because it could
    be needed by the linkage code in those branches.  The code for the true and
    false branches (which are not executed sequentially) is appended using a
    special combiner
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>parallel-instruction-sequences</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>parallel_instruction_sequences</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    described in
    section<SPACE/><REF NAME="sec:combining-instruction-sequences"/>.
  </TEXT>

  <SPLIT>
    <SCHEME>
      <TEXT>
	Note that <SCHEMEINLINE>cond</SCHEMEINLINE> is a derived expression,
	so all that the compiler needs to do handle it is to apply the
	<SCHEMEINLINE>cond-&gt;if</SCHEMEINLINE> transformer
	(from section<SPACE/><REF NAME="sec:representing-expressions"/>) and
	compile the resulting <SCHEMEINLINE>if</SCHEMEINLINE> expression.
      </TEXT>
    </SCHEME>
  </SPLIT>
  
  <SUBHEADING>
    <NAME>Compiling sequences</NAME>
  </SUBHEADING>

  <TEXT>
    <INDEX>compiler for JavaScript<SUBINDEX>sequences of statements</SUBINDEX></INDEX>
    The compilation of 
    <SPLITINLINE>
      <SCHEME>
        sequences (from procedure bodies or explicit <SCHEMEINLINE>begin</SCHEMEINLINE> expressions)
      </SCHEME>
      <JAVASCRIPT>
        statement sequences
      </JAVASCRIPT>
    </SPLITINLINE>
    parallels their evaluation<SPLITINLINE><JAVASCRIPT> in the explicit-control evaluator with one exception: if a return statement appears in the middle of a sequence, we treat it as if it were the last statement in the sequence</JAVASCRIPT></SPLITINLINE>.
    <SPLITINLINE><SCHEME>Each</SCHEME><JAVASCRIPT>Each</JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        expression
      </SCHEME>
      <JAVASCRIPT>
        statement
      </JAVASCRIPT>
    </SPLITINLINE>
    of the sequence is compiled<EMDASH/>the last
    <SPLITINLINE>
      <SCHEME>
        expression
      </SCHEME>
      <JAVASCRIPT>
        statement (or a return statement)
      </JAVASCRIPT>
    </SPLITINLINE>
    with
    the linkage specified for the sequence, and the other
    <SPLITINLINE>
      <SCHEME>
        expressions
      </SCHEME>
      <JAVASCRIPT>
        statements
      </JAVASCRIPT>
    </SPLITINLINE>
    with
    linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    (to execute the rest of the
    sequence). The instruction sequences for the individual
    <SPLITINLINE>
      <SCHEME>
        expressions
      </SCHEME>
      <JAVASCRIPT>
        statements
      </JAVASCRIPT>
    </SPLITINLINE>
    are
    appended to form a single instruction sequence, such that
    <SCHEMEINLINE>env</SCHEMEINLINE> (needed for the rest of the sequence) and
    <SCHEMEINLINE>continue</SCHEMEINLINE> (possibly needed for the linkage at
    the end of the sequence) are preserved.
    <INDEX><DECLARATION>compile_sequence</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>compile_sequence</NAME>
      <SCHEME>
      (define (compile-sequence seq target linkage)
      (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
      (compile (first-exp seq) target 'next)
      (compile-sequence (rest-exps seq) target linkage))))
      </SCHEME>
      <JAVASCRIPT>
function compile_sequence(seq, target, linkage) {
    return is_last_statement(seq) || is_return_statement(first_statement(seq))
           ? compile(first_statement(seq), target, linkage)
           : preserving(
                 list("env", "continue"),
                 compile(first_statement(seq), target, "next"),
                 compile_sequence(rest_statements(seq), target, linkage));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      <JAVASCRIPT>
    Treating return statements as if they always appear as the last statement in a sequence
    avoids compiling the
    <QUOTE>dead code</QUOTE> after the return statement that can
    never be executed. Not compiling dead<FOOTNOTE>Our compiler does not detect all dead code. For example,
    one or more conditionals that guarantee the execution of a return
    statement will not prevent subsequent statements from being compiled. See exercise<SPACE/><REF NAME="ex:dead-code"/>.
    <LABEL NAME="foot:dead-code"/></FOOTNOTE> is good for
    several reasons: it shortens the compilation time, it reduces the size of
    the object code, and it removes possible
    security hazards if a malicious user could trick the program into executing the
    dead code. Removing the check does not change the semantics of the program.
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <SUBHEADING>
    <NAME>Compiling
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>lambda</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	lambda
      </JAVASCRIPT>
    </SPLITINLINE>
    expressions</NAME>
  </SUBHEADING>

  <TEXT>
    <INDEX>compiler for JavaScript<SUBINDEX>lambda expressions</SUBINDEX></INDEX>
    Lambda expressions construct
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    The object code for a lambda expression must have the form
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      ^construct procedure object and assign it to target register^
      ^linkage^
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>construct function object and assign it to target register</METAPHRASE>
<METAPHRASE>linkage</METAPHRASE>
      </JAVASCRIPT>
    </SNIPPET>

    When we compile the lambda expression, we also generate the code for the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body. Although the body won<APOS/>t be executed at the time of
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    construction, it is convenient to insert it into the object code right after
    the code for the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT>lambda expression.</JAVASCRIPT>
    </SPLITINLINE>
    If the linkage for the lambda expression is a label or
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    this is fine.  But if the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    we will need to skip around the code for
    the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body by using a linkage that jumps to a label that is inserted after the
    body.  The object code thus has the form
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      ^construct procedure object and assign it to target register^
      ^code for given linkage <EM>or</EM>^ (goto (label after-lambda))
      ^compilation of procedure body^
      after-lambda
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>construct function object and assign it to target register</METAPHRASE>
<METAPHRASE>code for given linkage</METAPHRASE> <META>or</META> go_to(label("after_lambda"))
<METAPHRASE>compilation of function body</METAPHRASE>
"after_lambda"
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Compile-lambda</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	The function
      <JAVASCRIPTINLINE>compile_lambda</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    generates the code for constructing the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    object followed by the code for the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body. The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    object will be constructed at run time by combining the current environment
    (the environment at the point of definition) with the entry point to the
    compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body (a newly generated label).<FOOTNOTE>We need machine operations to
    implement a data structure for representing compiled
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <JAVASCRIPT>functions,</JAVASCRIPT>
    </SPLITINLINE>
    analogous to the structure for compound
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    described in section<SPACE/><REF NAME="sec:eval-data-structures"/>:
    <INDEX><DECLARATION>make_compiled_function</DECLARATION></INDEX> 
    <INDEX><DECLARATION>is_compiled_function</DECLARATION></INDEX> 
    <INDEX><DECLARATION>compiled_function_entry</DECLARATION></INDEX> 
    <INDEX><DECLARATION>compiled_function_env</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>make_compiled_function</NAME>
      <SCHEME>
        (define (make-compiled-procedure entry env)
        (list 'compiled-procedure entry env))

        (define (compiled-procedure? proc)
        (tagged-list? proc 'compiled-procedure))

        (define (compiled-procedure-entry c-proc) (cadr c-proc))

        (define (compiled-procedure-env c-proc) (caddr c-proc))
      </SCHEME>
      <JAVASCRIPT>
function make_compiled_function(entry, env) {
    return list("compiled_function", entry, env);
}

function is_compiled_function(proc) {
    return is_tagged_list(proc, "compiled_function");
} 

function compiled_function_entry(c_proc) {
    return head(tail(c_proc));
}

function compiled_function_env(c_proc) {
    return head(tail(tail(c_proc)));
}
      </JAVASCRIPT>
    </SNIPPET>
    <LABEL NAME="foot:compiler-ops"/></FOOTNOTE>
    <INDEX><DECLARATION>compile_lambda_expression</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <NAME>compile_lambda</NAME>
      <SCHEME>
      (define (compile-lambda exp target linkage)
      (let ((proc-entry (make-label 'entry))
            (after-lambda (make-label 'after-lambda)))
      (let ((lambda-linkage
            (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
      (tack-on-instruction-sequence
            (end-with-linkage lambda-linkage
            (make-instruction-sequence '(env) (list target)
            `((assign ,target
            (op make-compiled-procedure)
            (label ,proc-entry)
            (reg env)))))
            (compile-lambda-body exp proc-entry))
      after-lambda))))
      </SCHEME>
      <JAVASCRIPT>
function compile_lambda_expression(exp, target, linkage) {
    const fun_entry = make_label("entry");
    const after_lambda = make_label("after_lambda"); 
    const lambda_linkage =
            linkage === "next" ? after_lambda : linkage;
    return append_instruction_sequences(
               tack_on_instruction_sequence(
                   end_with_linkage(target, lambda_linkage,
                       make_instruction_sequence(list("env"), list(target),
                           list(assign(target, 
                                       list(op("make_compiled_function"),
                                            label(fun_entry), reg("env")))))),
                   compile_lambda_body(exp, fun_entry)),
               after_lambda);
}
      </JAVASCRIPT>
    </SNIPPET>

    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Compile-lambda</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>compile_lambda_expression</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    uses the special combiner
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>tack-on-instruction-sequence</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>tack_on_instruction_sequence</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    (section<SPACE/><REF NAME="sec:combining-instruction-sequences"/>) rather
    than
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>append-instruction-sequences</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>append_instruction_sequences</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to append the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body to the <SCHEMEINLINE>lambda</SCHEMEINLINE> expression code, because the
    body is not part of the sequence of instructions that will be executed when
    the combined sequence is entered; rather, it is in the sequence only because
    that was a convenient place to put it.
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Compile-lambda-body</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>compile_lambda_body</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    constructs the code for the body of the
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    This code begins with a label for the entry point.  Next come instructions
    that will cause the runtime evaluation environment to switch to the correct
    environment for evaluating the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body<EMDASH/>namely, the definition environment of the
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    extended to include the bindings of the
    <SPLITINLINE>
      <SCHEME>formal</SCHEME>
    </SPLITINLINE>
    parameters to the arguments
    with which the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is called.  After this comes the code for the 
    <SPLITINLINE>
      <SCHEME>
	sequence of expressions that makes up the
      </SCHEME>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body.
    <SPLIT>
      <SCHEME>
	The sequence is compiled with linkage
	<SCHEMEINLINE>return</SCHEMEINLINE>
	and target <SCHEMEINLINE>val</SCHEMEINLINE>
	so that it will end by returning from the
	procedure with the
	procedure 
	result in <SCHEMEINLINE>val</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	The body is compiled with linkage
	<JAVASCRIPTINLINE>"return_undefined"</JAVASCRIPTINLINE>
	so that it will end by returning from the function
	with the return value <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>
	unless a return statement is executed
  before reaching the end of the function.
	The target is <SCHEMEINLINE>val</SCHEMEINLINE>
	so that the return value (or
	<JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>)
	will be in <SCHEMEINLINE>val</SCHEMEINLINE>.
      </JAVASCRIPT>
    </SPLIT>
    <SNIPPET EVAL="no">
      <NAME>compile_lambda_body</NAME>
      <SCHEME>
      (define (compile-lambda-body exp proc-entry)
      (let ((formals (lambda-parameters exp)))
      (append-instruction-sequences
      (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
            (assign env 
                    (op compiled-procedure-env) 
                    (reg proc))
            (assign env
                    (op extend-environment)
                    (const ,formals)
                    (reg argl)
                    (reg env))))
      (compile-sequence (lambda-body exp) 'val 'return))))
      </SCHEME>
      <JAVASCRIPT>
function compile_lambda_body(exp, fun_entry) {
    const params  = lambda_parameter_symbols(exp);
    return append_instruction_sequences(
        make_instruction_sequence(
            list("env", "fun", "argl"),
            list("env"),
            list(fun_entry,
                 assign("env", list(op("compiled_function_env"), 
                                    reg("fun"))),
                 assign("env", list(op("extend_environment"), 
                                    constant(params),
                                    reg("argl"), 
                                    reg("env"))))),
        compile(lambda_body(exp), "val", "return_undefined"));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SPLIT>
    <JAVASCRIPT>
      <SUBHEADING>
	<NAME>
	  Compiling return statements
	</NAME>
      </SUBHEADING>

      <TEXT>
	<INDEX>compiler for JavaScript<SUBINDEX>return statements</SUBINDEX></INDEX>
	JavaScript's return statements are compiled such that the compiled code
	returns  to the caller of the current function the result of running the
	code of the return expression, ignoring the current linkage. 
	<SNIPPET EVAL="no">
	  <NAME>compile_return</NAME>
	  <JAVASCRIPT>
function compile_return_statement(stmt, target, linkage) {
    return append_instruction_sequences(
        make_instruction_sequence(
            null,
            null,
            list(restore_marker(), restore("continue"))),
        compile(return_expression(stmt), target, "return"));
}
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>

      <SUBHEADING>
	<NAME>
	  Compiling blocks
	</NAME>
      </SUBHEADING>

      <TEXT>
	<INDEX>compiler for JavaScript<SUBINDEX>blocks</SUBINDEX></INDEX>
	A block is compiled by prepending an assignment instruction to the compiled
	body of the block. The assignment extends the current environment with bindings
	of the declared names of the block to the value 
	<JAVASCRIPTINLINE>"*unassigned*"</JAVASCRIPTINLINE>. This affects neither
	the target nor the linkage.
        <INDEX>scanning out declarations<SUBINDEX>in compiler</SUBINDEX></INDEX>	
	<SNIPPET EVAL="no">
	  <NAME>compile_block</NAME>
	  <JAVASCRIPT>
function compile_block(stmt, target, linkage) {
    const body = block_body(stmt);
    const locals = scan_out_declarations(body);
    const unassigneds = list_of_unassigned(locals);
    return append_instruction_sequences(
               make_instruction_sequence(
                   list("env"),
                   list("env"),
                   list(assign("env", list(op("extend_environment"), 
                                           constant(locals),
                                           constant(unassigneds),
                                           reg("env"))))),
               compile(body, target, linkage));
}
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>


    </JAVASCRIPT>
  </SPLIT>
</SUBSECTION>
