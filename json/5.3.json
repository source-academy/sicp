[{"id":"/sicpjs/5.3","tag":"TITLE","body":"5.3  Storage Allocation and Garbage Collection"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"5.4","href":"/sicpjs/5.4"},{"body":", we will show how to implement a\n    JavaScript      \n    evaluator as a register machine.  In order to simplify the discussion, we\n    will assume that our register machines can be equipped with a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"list-structured memory","tag":"#text"}]},{"body":", in which the basic operations for\n    manipulating list-structured data are primitive.  Postulating the existence\n    of such a memory is a useful abstraction when one is focusing on the\n    mechanisms of control in\n    an\n    interpreter, but this does not reflect a realistic view of the actual\n    primitive data operations of contemporary computers.  To obtain a more\n    complete picture of how \n    systems can support list-structured memory\n      efficiently,\n    we must investigate how list structure can be represented in a way that is\n    compatible with conventional computer memories.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    There are two considerations in implementing list structure.  The first is\n    purely an issue of representation: how to represent the\n    \"","tag":"#text"},{"body":"box-and-pointer","tag":"#text"},{"body":"\" structure of\n    \n    pairs, using only the storage and addressing capabilities of typical computer\n    memories.  The second issue concerns the management of memory as a\n    computation proceeds. The operation of a\n    JavaScript\n    system depends crucially on the ability to\n    continually create new data objects.  These include objects that are\n    explicitly created by the\n    JavaScriptfunctions\n    being interpreted as well as structures created by the interpreter itself,\n    such as environments and argument lists.  Although the constant creation of\n    new data objects would pose no problem on a computer with an infinite amount\n    of rapidly addressable memory, computer memories are available only in\n    finite sizes (more's the pity).\n    JavaScript\n    thus provide an \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"automatic storage allocation","tag":"#text"}]},{"body":" facility to\n    support the illusion of an infinite memory.  When a data object is no longer\n    needed, the memory allocated to it is automatically recycled and used to\n    construct new data objects.  There are various techniques for providing such\n    automatic storage allocation.  The method we shall discuss in this section\n    is called ","tag":"#text"},{"tag":"EM","child":[{"body":"garbage collection","tag":"#text"}]},{"body":".\n  ","tag":"#text"}]}]