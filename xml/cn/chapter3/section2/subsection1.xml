<SUBSECTION> 
   <NAME>
    求值规则
  </NAME> 

  <LABEL NAME="sec:env-model-rules"></LABEL>
   <INDEX>求值的环境模型<SUBINDEX>求值规则<OPEN></OPEN></SUBINDEX></INDEX> 

  <LONG_PAGE LINES="2"></LONG_PAGE>
  <TEXT> 
    关于解释器如何
    <INDEX>函数应用<SUBINDEX>环境模型的</SUBINDEX></INDEX>
    <INDEX>求值的环境模型<SUBINDEX>函数应用</SUBINDEX></INDEX>
    对
    <SPLITINLINE>
      
	组合式
      
      <JAVASCRIPT>
	函数应用
      </JAVASCRIPT>
    </SPLITINLINE>
    的求值的总体规范保持不变，如我们在<SECTION><SPACE></SPACE><REF NAME="sec:compound-procedures"></REF>中首次介绍的那样:
 </SECTION><UL>
      <LI> 
        对
	<SPLITINLINE>
	  
	    组合式进行求值:
	  
	  <JAVASCRIPT>
	    函数应用进行求值:
	  </JAVASCRIPT>
	</SPLITINLINE>
         <OL>
	   <LI>
	    对
	    <SPLITINLINE>
	      
		组合式的子表达式求值。<FOOTNOTE>赋值在求值规则的第1步中引入了微妙之处。如练习<SPACE></SPACE><REF NAME="ex:order-of-evaluation"></REF>所示，赋值的存在使我们能够编写根据子表达式在组合式中求值的<INDEX>求值顺序<SUBINDEX>与实现相关</SUBINDEX></INDEX>不同而产生不同值的表达式。因此，为了精确起见，我们应该在第1步中指定一个求值顺序（例如，从左到右或从右到左）。然而，这种顺序应该始终被视为一种实现细节，绝不应编写依赖某种特定顺序的程序。例如，一个复杂的编译器可能通过改变子表达式的求值顺序来优化程序。ECMAScript标准指定从左到右对子表达式进行求值。</FOOTNOTE>
	      
	      <JAVASCRIPT>
		应用的子表达式求值。<FOOTNOTE>赋值在求值规则的第1步中引入了一种微妙之处。如练习<SPACE></SPACE><REF NAME="ex:order-of-evaluation"></REF>所示，赋值的存在使我们能够编写根据组合式中子表达式的求值顺序产生不同值的表达式。为了消除这种歧义，<INDEX>求值顺序<SUBINDEX><ORDER>JavaScript</ORDER>在JavaScript中</SUBINDEX></INDEX> JavaScript指定组合式的子表达式和应用的参数表达式的从左到右求值。</FOOTNOTE>
	      </JAVASCRIPT>
	    </SPLITINLINE>
	  </LI>
            <LI>
	    将
	    <SPLITINLINE>
	      
		运算符
	      
	      <JAVASCRIPT>
		函数
	      </JAVASCRIPT>
	    </SPLITINLINE>
	    子表达式的值应用到
	    <SPLITINLINE>
	      
		操作数
	      
	      <JAVASCRIPT>
		参数
	      </JAVASCRIPT>
	    </SPLITINLINE>
	    子表达式的值上。
	  </LI>
         </OL>
      </LI>
    </UL> 
    求值的环境模型替代了代换模型，用于指定应用复合函数的含义
      <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    到参数。
   </TEXT>

  <TEXT> 
    在求值的环境模型中，
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    始终是由一些代码和一个指向环境的指针组成的组合体。
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的创建只有一种方式：通过对
    <SPLITINLINE>
      lambda
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>	
    表达式求值。
    <INDEX><FUNCTION></FUNCTION><SUBINDEX>与<SPLITINLINE>lambda<JAVASCRIPT>lambda 表达式</JAVASCRIPT></SPLITINLINE>一起创建</SUBINDEX></INDEX>
    这产生了一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    其代码是从
    <SPLITINLINE>
      lambda
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>	
    表达式的文本中获得的，其环境是对
    <SPLITINLINE>
      lambda
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>	
    表达式进行求值以生成
    <SPLITINLINE>
      过程。
      <JAVASCRIPT>函数。</JAVASCRIPT>
    </SPLITINLINE>
    例如，考虑以下
    <SPLITINLINE>
      过程定义。
      <JAVASCRIPT>函数声明。</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>square</USE><SUBINDEX><ORDER>环境</ORDER>在环境模型中<OPEN></OPEN></SUBINDEX></INDEX>
     <SNIPPET EVAL="yes">
      <EXAMPLE>square_example</EXAMPLE>
      <EXPECTED>196</EXPECTED>
      <SCHEME>
(define (square x)
  (* x x))
      </SCHEME>
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET> 
    在
    <SPLITINLINE>
      
	全局
      
      <JAVASCRIPT>
	程序
      </JAVASCRIPT>
    </SPLITINLINE>
    环境中求值。
    <SPLITINLINE>
      过程定义
      <JAVASCRIPT>函数声明</JAVASCRIPT>
    </SPLITINLINE>
    语法是
    <SPLITINLINE>
      只是语法糖
      <JAVASCRIPT>
	等同于
      </JAVASCRIPT>
    </SPLITINLINE>
    底层隐式
    <SPLITINLINE>
      lambda
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>
    表达式的语法形式。
    这将等同于使用<FOOTNOTE>
	脚注<SPACE></SPACE><REF NAME="foot:function-decl-vs-lambda"></REF>在第 1 章中
	提到在完整的 JavaScript 中二者之间的微妙差别，我们将在本书中忽略这些差别。</FOOTNOTE>
     <SNIPPET EVAL="yes">
      <EXAMPLE>square_example</EXAMPLE>
      <EXPECTED>196</EXPECTED>
      <SCHEME>
(define square
  (lambda (x) (* x x)))
      </SCHEME>
      <JAVASCRIPT>
const square = x =&gt; x * x;
      </JAVASCRIPT>
    </SNIPPET> 
    对
    <SPLITINLINE>
      (lambda (x) (* x x))
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>x =&gt; x * x</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    求值并绑定
    <SCHEMEINLINE>square</SCHEMEINLINE> 绑定到结果值，全部在
    <SPLITINLINE>
      
	全局
      
      <JAVASCRIPT>
	程序
      </JAVASCRIPT>
    </SPLITINLINE>
    环境中。
   </TEXT>

  <TEXT>
     <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:evaluating-square_scheme"></REF>
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:evaluating-square"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    显示了评估此
    <INDEX>声明<SUBINDEX>环境模型的</SUBINDEX></INDEX>
    <SPLITINLINE>
      define 表达式。
      <JAVASCRIPT>声明语句。</JAVASCRIPT>
    </SPLITINLINE>
    <SPLIT>
      
      
      <JAVASCRIPT>
	全局环境包围程序环境。为了减少混乱，在这幅图之后我们将不再显示全局环境（因为它始终相同），但我们通过程序环境向上的指针提醒其存在。
      </JAVASCRIPT>
    </SPLIT>
    这个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    对象是一个组合体，其代码指定
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    具有一个
    <SPLITINLINE>形式</SPLITINLINE>
    参数，即
<SCHEMEINLINE>x</SCHEMEINLINE> , 和
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    体
    <SPLITINLINE>
      (* x x).
      <JAVASCRIPT><JAVASCRIPTINLINE>return x * x;</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    这个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的环境部分是指向程序环境的指针，因为这是求值
    <SPLITINLINE>
      lambda
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>
    表达式以产生
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的环境。<SPACE></SPACE>一个新的绑定，它将
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    对象与一个
    <SPLITINLINE>
      
	符号
      
      <JAVASCRIPT>
	名称
      </JAVASCRIPT>
    </SPLITINLINE>
   <SCHEMEINLINE>square</SCHEMEINLINE> ，已添加到程序帧中。
    <SPLIT>
      
        一般而言，define 通过
	将绑定添加到帧来创建定义。
      
      <JAVASCRIPT>
      </JAVASCRIPT>
    </SPLIT>

    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-3.svg" SPLIT_SCALE="0.75"></FIGURE>
          
          <CAPTION>
	    在全局环境中评估
	  (define (square x) (* x x)) 产生的
	  环境结构。
	  </CAPTION>
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-3.svg" SPLIT_SCALE="0.75" WEB_SCALE="0.5"></FIGURE>
          
          <CAPTION>
	    在程序环境中评估
	    <JAVASCRIPTINLINE>function square(x) { return x * x; }</JAVASCRIPTINLINE>
	    产生的环境结构。
	  </CAPTION>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
   </TEXT>

   <SPLIT>
    
    
    <JAVASCRIPT>
      <TEXT>
	通常，<JAVASCRIPTINLINE>const</JAVASCRIPTINLINE>，
	<JAVASCRIPTINLINE>function</JAVASCRIPTINLINE>和
	<JAVASCRIPTINLINE>let</JAVASCRIPTINLINE>
	会将绑定添加到帧中。
	对常量的赋值是被禁止的，因此我们的环境模型需要将指向常量的名称与指向变量的名称区分开来。我们通过在冒号后面添加一个等号来表示名称是一个常量。
	我们将函数声明视为与常量声明等效；<FOOTNOTE>我们在第 1 章的脚注<SPACE></SPACE><REF NAME="foot:function-decl-vs-lambda"></REF>中提到，在完整的 JavaScript 语言中允许对函数声明的名称进行赋值。</FOOTNOTE>请注意图<SPACE></SPACE><REF NAME="fig:evaluating-square"></REF>中冒号后的等号。
      </TEXT>
    </JAVASCRIPT>
  </SPLIT> 
   <TEXT>
    现在我们已经看到了
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    是如何创建的，我们可以描述
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    是如何应用的。环境模型规定：要将
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    应用于参数，创建一个新的环境，其中包含一个绑定参数到参数值的帧。这个帧的外围环境是由
    <SPLITINLINE>
      过程。
    <JAVASCRIPT>函数。</JAVASCRIPT></SPLITINLINE>
    指定的环境。现在，在这个新环境中，评估
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    体。
  </TEXT> 

  <TEXT> 
要显示如何遵循这一规则，
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:square5-eval_scheme"></REF>
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:square5-eval"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    说明了通过求值表达式
    <SPLITINLINE>
      (square 5)
      <JAVASCRIPT><JAVASCRIPTINLINE>square(5)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    在
    <SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境中创建的环境结构，在哪里
<SCHEMEINLINE>square</SCHEMEINLINE>  是在
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    中生成的
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:evaluating-square_scheme"></REF>.
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:evaluating-square"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
    应用
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    结果是产生一个新环境，图中标记为 E1，其始于一个框架，其中 
<SCHEMEINLINE>x</SCHEMEINLINE> ，
    <SPLITINLINE>
      形式
    </SPLITINLINE>
    参数在
    <SPLITINLINE>
      过程中,
      <JAVASCRIPT>函数中,</JAVASCRIPT>
    </SPLITINLINE>
    被绑定到参数5。
    <SPLITINLINE>
      <JAVASCRIPT>
	请注意，环境 E1 中的名称 x 后面跟有一个冒号，但没有等号，指示参数 x 被视为变量。<FOOTNOTE>该例子并未利用该参数是变量这一事实，但请回忆在第<SPACE></SPACE><REF NAME="sec:local-state-variables"></REF>节中的函数 <JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE> 依赖于其参数是变量。
	</FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    从该框架向上的指针表明该框架的外围环境是
    <SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境。选择
    <SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境是因为这是指示为一部分的环境 
<SCHEMEINLINE>square</SCHEMEINLINE>
     <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    对象。在 E1 中，我们求值
    <SPLITINLINE>
      过程,
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      (* x x).
      <JAVASCRIPT><JAVASCRIPTINLINE>return x * x;</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    体。由于 
<SCHEMEINLINE>x</SCHEMEINLINE>  在 E1 中是 5，结果是
    <SPLITINLINE>
      (*<SPACE></SPACE>5<SPACE></SPACE>5),
      <JAVASCRIPT><JAVASCRIPTINLINE>5 * 5</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    或<SPACE></SPACE>25。
    <INDEX><USE>square</USE><SUBINDEX><ORDER>环境</ORDER>在环境模型中<CLOSE></CLOSE></SUBINDEX></INDEX>
    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-4.svg"></FIGURE>
          
          <CAPTION>
	    在全局环境中求值
	    (square 5)所创建的环境。
	  </CAPTION>
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-4.svg"></FIGURE>
          
          <CAPTION>
	    在程序环境中求值
	    <JAVASCRIPTINLINE>square(5)</JAVASCRIPTINLINE>
	    所创建的环境。
	  </CAPTION>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
   </TEXT>

  <TEXT> 
    求值的环境模型
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    应用可归纳为两个规则:
      <UL>
      <LI>
	A
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	对象是通过构建一个帧来应用于一组参数的，
	<SPLITINLINE>
	  将该过程的形式参数绑定到调用的参数
	  <JAVASCRIPT>将函数的参数绑定到调用的参数</JAVASCRIPT>
	</SPLITINLINE>
	，然后在新构造的环境中评估
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	体。新框架的外围环境是所应用的
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	对象的环境部分。
	应用的结果是在评估函数体时遇到的第一个返回语句的返回表达式的评估结果。
      </LI>
      <LI>
	A
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	是通过在给定环境中评估
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>与<SPLITINLINE>lambda<JAVASCRIPT>lambda 表达式</JAVASCRIPT></SPLITINLINE>一起创建</SUBINDEX></INDEX>
	<SPLITINLINE>
	  lambda
	  <JAVASCRIPT>lambda</JAVASCRIPT>
	</SPLITINLINE>
	表达式创建的。结果的
	<INDEX>lambda 表达式<SUBINDEX>值</SUBINDEX></INDEX>
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	对象是由
	<SPLITINLINE>
	  lambda
	  <JAVASCRIPT>lambda</JAVASCRIPT>
	</SPLITINLINE>
	表达式的文本和一个指向创建该
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	环境的指针组成的组合体。
      </LI>
    </UL>
   </TEXT>

  <TEXT>
     <SPLIT>
      
	<INDEX>define<SUBINDEX>环境模型的</SUBINDEX></INDEX>
	我们也指定使用define定义一个符号在当前环境帧中创建一个绑定，并将指示的值赋给该符号。
      
      <JAVASCRIPT>
	<COMMENT>
	  我们在 JavaScript 版本中省略这一点，因为在第<SPACE></SPACE><REF NAME="sec:env-internal-def"></REF>节中有更详细的讨论。
	</COMMENT>
      </JAVASCRIPT>
    </SPLIT>
      <SPLIT>
      
	<INDEX>define<SUBINDEX>环境模型的</SUBINDEX></INDEX>
	对表达式(set! 
	variable value)
	在某个环境中进行求值会定位到环境中变量的绑定。为此，需要找到环境中包含该变量绑定的第一个帧并对其进行修改。如果变量在环境中没有绑定，则set!会发出错误信号。
      
      <JAVASCRIPT>
	<INDEX>赋值<SUBINDEX>求值的</SUBINDEX></INDEX>
	最后，我们规定了赋值的行为，这个操作最初迫使我们引入了环境模型。对表达式
	<META>name</META><SPACE></SPACE><JAVASCRIPTINLINE>=</JAVASCRIPTINLINE><SPACE></SPACE><META>value</META>
	在某个环境中的求值会定位到环境中名称的绑定。也就是说，需要找到环境中包含该名称绑定的第一个帧。
	如果绑定是变量绑定——在帧中用名称后仅有<JAVASCRIPTINLINE>:</JAVASCRIPTINLINE>表示——该绑定会被改变以反映变量的新值。
	否则，如果帧中的绑定是常量绑定——在帧中用名称后紧跟<JAVASCRIPTINLINE>:=</JAVASCRIPTINLINE>表示——赋值会发出<JAVASCRIPTINLINE>&quot;assignment to constant&quot;</JAVASCRIPTINLINE>错误信号。
	如果名称在环境中没有绑定，则赋值会发出<JAVASCRIPTINLINE>&quot;variable undeclared&quot;</JAVASCRIPTINLINE>错误信号。
      </JAVASCRIPT>
    </SPLIT>
   </TEXT>

   <TEXT>
    尽管这些求值规则比代换模型复杂得多，但仍然相当简单。此外，尽管求值模型是抽象的，但它正确描述了解释器如何对表达式求值。在第<SPACE></SPACE><REF NAME="chap:meta"></REF>章中，我们将看到这个模型如何可以作为实现有效解释器的蓝图。以下各节通过分析一些示例程序来详细说明该模型的细节。
    <INDEX>求值的环境模型<SUBINDEX>求值规则<CLOSE></CLOSE></SUBINDEX></INDEX>
  </TEXT> 
</SUBSECTION>
