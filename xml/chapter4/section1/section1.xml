<SECTION>
  <NAME>The Metacircular Evaluator</NAME>

  <SECTIONCONTENT/>

  <LABEL NAME="sec:mc-eval"/>

  <INDEX>metacircular evaluator for JavaScript<OPEN/></INDEX>

  <TEXT>
    Our evaluator for 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <PYTHON>JavaScript</PYTHON>
    </SPLITINLINE> 
    will be implemented as a 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <PYTHON>JavaScript</PYTHON>
    </SPLITINLINE> 
    program.  It may
    seem circular to think about evaluating 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <PYTHON>JavaScript</PYTHON>
    </SPLITINLINE> 
    programs using an evaluator that is itself implemented in 
    <SPLITINLINE>
      <SCHEME>Lisp.</SCHEME>
      <PYTHON>JavaScript.</PYTHON>
    </SPLITINLINE>
    However, evaluation is a process, so it is appropriate to describe the
    evaluation process using
    <SPLITINLINE>
      <SCHEME>Lisp,</SCHEME>
      <PYTHON>JavaScript,</PYTHON>
    </SPLITINLINE>
    which, after all, is our tool for describing processes.<FOOTNOTE>Even so,
    there will remain important aspects of the evaluation process that are not
    elucidated by our evaluator.  The most important of these are the detailed
    mechanisms by which
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    call other
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    and return values to their callers. We will address these issues in
    chapter<SPACE/><REF NAME="chap:reg"></REF>, where we take a closer look at the evaluation process by
    implementing the evaluator as a simple register machine.</FOOTNOTE>  
    An evaluator that is written in the same language
    that it evaluates is said to be
    <INDEX>metacircular evaluator</INDEX>
    <INDEX>evaluator<SUBINDEX>metacircular</SUBINDEX></INDEX>
    <EM>metacircular</EM>.
  </TEXT>

  <TEXT>
    The metacircular evaluator is essentially a 
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <PYTHON>JavaScript</PYTHON>
    </SPLITINLINE>
    formulation of the
    <INDEX>environment model of evaluation<SUBINDEX>metacircular evaluator and</SUBINDEX></INDEX>
    <INDEX>metacircular evaluator for JavaScript<SUBINDEX>environment model of evaluation in</SUBINDEX></INDEX>
    environment model of evaluation described in
    section<SPACE/><REF NAME="sec:environment-model"/>.
    <SPLITINLINE>
      <SCHEME>Recall that the model has two basic parts:</SCHEME>
      <PYTHON>
	Recall that the model specifies the
	evaluation of function application in two basic steps:
      </PYTHON>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    <OL>
      <LI> 
	<SPLIT>
	  <SCHEME>
            To evaluate a combination (a compound expression other than a 
            special form), evaluate the subexpressions and then apply the value
	    of the operator subexpression to the values of the operand
            subexpressions.
	  </SCHEME>
	  <PYTHON>
	    To evaluate a function application, evaluate the 
	    subexpressions and then apply the
	    value of the function subexpression to the values of the argument
            subexpressions.
	  </PYTHON>
	</SPLIT>
      </LI>
      <LI>
        To apply a compound
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	to a set of arguments, evaluate the
        body of the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	in a new environment.  To construct this
        environment, extend the environment part of the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	object by a
        frame in which the
	<SPLITINLINE>
	  <SCHEME>formal</SCHEME>
	</SPLITINLINE>
	parameters of the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	are bound to
	the arguments to which the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	is applied.
      </LI>
    </OL>
  </TEXT>

  <TEXT>
    These two rules describe the essence of the evaluation process, a basic
    <SPLITINLINE>
      <SCHEME>
      <INDEX>metacircular evaluator for Scheme<SUBINDEX><ORDER>eval</ORDER><SCHEMEINLINE>eval</SCHEMEINLINE><ENDASH/><SCHEMEINLINE>apply</SCHEMEINLINE> cycle</SUBINDEX></INDEX>
      </SCHEME>
      <PYTHON>
      <INDEX>metacircular evaluator for JavaScript<SUBINDEX><ORDER>evaluate</ORDER><PYTHONINLINE>evaluate</PYTHONINLINE><ENDASH/><PYTHONINLINE>apply</PYTHONINLINE> cycle</SUBINDEX></INDEX>
      </PYTHON>
    </SPLITINLINE>
    cycle in which 
    <SPLITINLINE><PYTHON>statements and</PYTHON></SPLITINLINE>
    expressions to be evaluated in environments are reduced to
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    to be applied to arguments, which in turn are reduced to new 
    <SPLITINLINE>
      <PYTHON>statements and</PYTHON>
    </SPLITINLINE>
    expressions to be evaluated in new environments, and so on, until we get
    down to
    <SPLITINLINE>
      <SCHEME>
	symbols,
      </SCHEME>
      <PYTHON>
	names,
      </PYTHON>
    </SPLITINLINE>
    whose values are looked up in the environment, and to 
    <SPLITINLINE>
      <SCHEME>primitive procedures,</SCHEME>
      <PYTHON>operators and primitive functions,</PYTHON>
    </SPLITINLINE>
    which are applied directly (see
    figure<SPACE/><REF NAME="fig:eval-apply"/>).<FOOTNOTE>If we grant ourselves
    the ability to apply primitives,
    then what remains for us to implement in the evaluator?  The
    <INDEX>metacircular evaluator for JavaScript<SUBINDEX>job of</SUBINDEX></INDEX>
    job of the
    evaluator is not to specify the primitives of the language, but rather to
    provide the connective tissue<EMDASH/>the means of combination and the means
    of abstraction<EMDASH/>that binds a collection of primitives to form a
    language.  Specifically:
    <UL>
      <LI>
	The evaluator enables us to deal with nested expressions. For example,
	although simply applying primitives would suffice for evaluating the
	expression
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(+ 1 6)</SCHEMEINLINE>,</SCHEME>
	  <PYTHON><PYTHONINLINE>2 * 6</PYTHONINLINE>,</PYTHON>
	</SPLITINLINE>
	it is not adequate for handling 
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(+ 1 (* 2 3))</SCHEMEINLINE>.</SCHEME>
	  <PYTHON><PYTHONINLINE>2 * (1 + 5)</PYTHONINLINE>.
	  </PYTHON>
	</SPLITINLINE>
	As far as the 
	<SPLITINLINE>
	  <SCHEME>
	    primitive procedure
	    <SCHEMEINLINE>+</SCHEMEINLINE>
	  </SCHEME>
	  <PYTHON>
	    operator
	    <SCHEMEINLINE>*</SCHEMEINLINE>
	  </PYTHON>
	</SPLITINLINE>
	is concerned, its arguments must be numbers, and it would choke if we
	passed it the expression
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(* 2 3)</SCHEMEINLINE></SCHEME>
	  <PYTHON><PYTHONINLINE>1 + 5</PYTHONINLINE></PYTHON>
	</SPLITINLINE>
	as an argument.	One important role of the evaluator is to choreograph
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON></PYTHON>
	</SPLITINLINE>
	composition so that
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(* 2 3)</SCHEMEINLINE></SCHEME>
	  <PYTHON><PYTHONINLINE>1 + 5</PYTHONINLINE></PYTHON>
	</SPLITINLINE>
	is reduced to 6 before being passed as an 
	<SPLITINLINE>
	  <SCHEME>
	    argument to<SPACE/><SCHEMEINLINE>+</SCHEMEINLINE>.
	  </SCHEME>
	  <PYTHON>
	    argument to<SPACE/><PYTHONINLINE>*</PYTHONINLINE>.
	  </PYTHON>
	</SPLITINLINE>
      </LI>
      <LI>
	The evaluator allows us to use
	<SPLITINLINE>
	  <SCHEME>variables.</SCHEME>
	  <PYTHON>names.</PYTHON>
	</SPLITINLINE>
	For example, the 
	<SPLITINLINE>
	  <SCHEME>primitive procedure for addition</SCHEME>
	  <PYTHON>addition operator</PYTHON>
	</SPLITINLINE>
	has no way to deal with expressions such as
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(+ x 1)</SCHEMEINLINE>.</SCHEME>
	  <PYTHON><PYTHONINLINE>x + 1</PYTHONINLINE>.</PYTHON>
	</SPLITINLINE>
	We need an evaluator to keep track of
	<SPLITINLINE>
	  <SCHEME>variables</SCHEME>
	  <PYTHON>names</PYTHON>
	</SPLITINLINE>
	and obtain their values before invoking the 
	<SPLITINLINE>
	  <SCHEME>primitive procedures.</SCHEME>
	  <PYTHON>operators.</PYTHON>
	</SPLITINLINE>
      </LI>
      <LI>
	The evaluator allows us to define compound
	<SPLITINLINE>
	  <SCHEME>procedures.</SCHEME>
	  <PYTHON>functions.</PYTHON>
	</SPLITINLINE>
	<SPLITINLINE>
	  <SCHEME>
	    This involves keeping track of procedure definitions, knowing
	    how to use these definitions in evaluating
	    expressions, and providing a mechanism that enables
	    procedures to accept arguments.
	  </SCHEME>
	  <PYTHON>
	    This involves knowing how to use these functions in evaluating 
	    expressions and providing a mechanism that enables functions
	    to accept arguments.
	  </PYTHON>
	</SPLITINLINE>
      </LI>
      <LI>
	<SPLITINLINE>
	  <SCHEME>The evaluator provides the special forms, which must be
	  evaluated differently from procedure calls.</SCHEME>
	  <PYTHON>The evaluator provides the other syntactic forms of
	  the language such as conditionals and blocks.
	</PYTHON></SPLITINLINE>
      </LI>
    </UL></FOOTNOTE>
    This evaluation cycle will be embodied by the interplay between the two
    critical
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    in the evaluator,
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <PYTHON><SCHEMEINLINE>evaluate</SCHEMEINLINE></PYTHON>
    </SPLITINLINE>
    and <SCHEMEINLINE>apply</SCHEMEINLINE>, which are described in
    section<SPACE/><REF NAME="sec:core-of-evaluator"/>
    (see figure<SPACE/><REF NAME="fig:eval-apply"/>).
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	The implementation of the evaluator will depend upon procedures
	that define the <EM>syntax</EM> of the expressions to be evaluated.
	We will use
	<INDEX>metacircular evaluator for Scheme<SUBINDEX>data abstraction in</SUBINDEX></INDEX>
	data abstraction to make the evaluator independent of the representation of
	the language.  For example, rather than committing to a choice that an
	assignment is to be represented by a list beginning with the 
	symbol <SCHEMEINLINE>set!</SCHEMEINLINE> we use an abstract predicate
	<SCHEMEINLINE>assignment?</SCHEMEINLINE>
	to test for an assignment, and we use abstract selectors
	<SCHEMEINLINE>assignment-variable</SCHEMEINLINE> and 
	<SCHEMEINLINE>assignment-value</SCHEMEINLINE>
	to access the parts of an assignment.
	Implementation of expressions will be described in detail in
	section<SPACE/><REF NAME="sec:representing-expressions"/>. 	
      </SCHEME>
      <PYTHON>
	The implementation of the evaluator will depend upon functions that
	define the <EM>syntax</EM> of the statements and
	expressions to be evaluated.
	We will use
	<INDEX>metacircular evaluator for JavaScript<SUBINDEX>data abstraction in</SUBINDEX></INDEX>
	data abstraction to make the evaluator independent of the
	representation of the language.
	For example, rather than committing
	to a choice that an assignment is to be represented by a 
	string beginning with a name followed by
	<PYTHONINLINE>=</PYTHONINLINE>, we use an abstract predicate
	<PYTHONINLINE>is_assignment</PYTHONINLINE> to test for an
	assignment, and we use abstract
	selectors <PYTHONINLINE>assignment_symbol</PYTHONINLINE> and
	<PYTHONINLINE>assignment_value_expression</PYTHONINLINE> to
	access the parts of an assignment.
	The data abstraction layers presented in
	section<SPACE/><REF NAME="sec:representing-expressions"/>
	will allow the evaluator to remain independent of concrete syntactic
	issues, such as the keywords of the interpreted language, and of the
	choice of data structures that represent the program components.
      </PYTHON>
    </SPLITINLINE>
    There are also
    operations, described in
    section<SPACE/><REF NAME="sec:eval-data-structures"/>, that specify the
    representation of
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    and environments.  For example,
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-procedure</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_function</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    constructs compound
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <PYTHON>functions,</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>lookup-variable-value</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>lookup_symbol_value</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    accesses the values of
    <SPLITINLINE>
      <SCHEME>variables,</SCHEME>
      <PYTHON>names,</PYTHON>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-primitive-procedure</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>apply_primitive_function</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    applies a primitive
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
    <PYTHON>function</PYTHON></SPLITINLINE>
    to a given list of arguments.
  </TEXT>

  <!-- Subsection 1 : The Core of the Evaluator -->
  &amp;subsection4.1.1;

  <!-- Subsection 2 : Representing Expressions -->
  &amp;subsection4.1.2;

  <!-- Subsection 3 : Evaluator Data Structures -->
  &amp;subsection4.1.3;

  <!-- Subsection 4 : Running the Evaluator as a Program -->
  &amp;subsection4.1.4;
  
  <!-- Subsection 5 : Data as Programs -->
  &amp;subsection4.1.5;

  <!-- Subsection 6 : Internal Definitions -->
  &amp;subsection4.1.6;

  <!-- Subsection 7 : Separating Syntactic Analysis from Execution -->
  &amp;subsection4.1.7;

</SECTION>
