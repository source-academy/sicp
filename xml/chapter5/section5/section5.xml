  <SECTION WIP="yes">
    <NAME>Compilation</NAME>

    <SECTIONCONTENT/>

    <LABEL NAME="sec:compilation"/>
    <INDEX>compiler|(</INDEX>
    <TEXT>
      The explicit-control evaluator of section<SPACE/><REF NAME="sec:eceval"/> is a
      register machine whose controller interprets <SPLIT><SCHEME>Scheme</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLIT> programs.  In this
      section we will see how to run <SPLIT><SCHEME>Scheme</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLIT> programs on a register machine
      whose controller is not a <SPLIT><SCHEME>Scheme</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLIT> interpreter.
    </TEXT>

    <TEXT>
      <INDEX>universal machine<SUBINDEX>explicit-control evaluator as</SUBINDEX></INDEX>
      <INDEX>explicit-control evaluator for Scheme<SUBINDEX>universal@as universal machine</SUBINDEX></INDEX>
      The explicit-control evaluator machine is universal<EMDASH/>it can carry out
      any computational process that can be described in <SPLIT><SCHEME>Scheme</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLIT>.  The
      evaluator<APOS/>s controller orchestrates the use of its data paths to
      perform the desired computation.  Thus, the evaluator<APOS/>s data paths are
      universal: They are sufficient to perform any computation we desire,
      given an appropriate 
      controller.<FOOTNOTE>This is a theoretical statement.  We are not claiming
  that the evaluator<APOS/>s data paths are a particularly convenient or
  efficient set of data paths for a general-purpose computer.  For example,
  they are not very good for implementing high-performance floating-point
  calculations or calculations that intensively manipulate bit vectors.</FOOTNOTE>
    </TEXT>

    <TEXT>
      <INDEX>universal machine<SUBINDEX>general-purpose computer as</SUBINDEX></INDEX>
      <INDEX>general-purpose computer, as universal machine</INDEX>
      Commercial general-purpose computers are register machines organized
      around a collection of registers and operations that constitute
      an efficient and convenient universal set of data paths.
      The controller for a general-purpose machine is an interpreter for
      a register-machine language like the one we have been using.  This
      language is called the 
      <INDEX>native language of machine</INDEX>
      <EM>native language</EM> of the machine, or simply
      <INDEX>machine language</INDEX>
      <EM>machine language</EM>.  Programs written in machine language are
      sequences of instructions that use the machine<APOS/>s data paths.
      For example, the 
      <INDEX>explicit-control evaluator for Scheme<SUBINDEX>machine@as machine-language program</SUBINDEX></INDEX>
      explicit-control evaluator<APOS/>s instruction sequence
      can be thought of as a machine-language program for a general-purpose
      computer rather than as the controller for a specialized interpreter
      machine.
    </TEXT>

    <TEXT>
      <INDEX>compiler<SUBINDEX>interpreter vs.|(</SUBINDEX></INDEX>
      <INDEX>interpreter<SUBINDEX>compiler vs.|(</SUBINDEX></INDEX>
      There are two common strategies for bridging the gap between
      higher-level languages and register-machine languages.  The
      explicit-control evaluator illustrates the
      strategy of interpretation.  An interpreter written in the native
      language of a machine configures the machine to execute programs
      written in a language (called the 
      <INDEX>source language</INDEX>
      <EM>source language</EM>) that may
      differ from the native language of the machine performing the
      evaluation.  The primitive
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      of the source language are
      implemented as a library of subroutines written in the native language
      of the given machine.  A program to be interpreted (called the 
      <INDEX>source program</INDEX>
      <EM>
  source program</EM>) is represented as a data structure.  The interpreter
      traverses this data structure, analyzing the source program.  As it
      does so, it simulates the intended behavior of the source program by
      calling appropriate primitive subroutines from the library.
    </TEXT>

    <TEXT>
      In this section, we explore the alternative strategy of <EM>
  compilation</EM>.  A compiler for a given source language and machine
      translates a source program into an equivalent program (called the
      <INDEX>object program</INDEX>
      <EM>object program</EM>) written in the machine<APOS/>s native language.  The
      compiler that we implement in this section translates programs written
      in <SPLIT><SCHEME>Scheme</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLIT> into sequences of instructions to be executed using
      the explicit-control evaluator machine<APOS/>s data 
      paths.<FOOTNOTE>Actually, the machine that runs
  compiled code can be simpler than the interpreter machine, because we
  <INDEX>compiler for Scheme<SUBINDEX>register use</SUBINDEX></INDEX>
  won<APOS/>t use the <SCHEMEINLINE>exp</SCHEMEINLINE> and <SCHEMEINLINE>unev</SCHEMEINLINE> registers.  The interpreter
  used these to hold pieces of unevaluated expressions.  With the
  compiler, however, these expressions get built into the
  compiled code that the register machine will run.  For the same
  reason, 
  <INDEX>compiler for Scheme<SUBINDEX>machine-operation use</SUBINDEX></INDEX>
  we don<APOS/>t need the machine operations that deal with expression
  syntax.  But compiled code will use a few additional machine
  operations (to represent compiled
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  objects) that didn<APOS/>t
  appear in the explicit-control evaluator machine.</FOOTNOTE>
    </TEXT>

    <TEXT>
      Compared with interpretation, compilation can provide a great increase
      in the efficiency of program execution, as we will explain below in
      the overview of the compiler.  On the other hand, an interpreter
      provides a more powerful environment for interactive program
      development and debugging, because the source program being executed
      is available at run time to be examined and modified.  In addition,
      because the entire library of primitives is present, new programs can
      be constructed and added to the system during debugging.
    </TEXT>

    <TEXT>
      In view of the complementary advantages of compilation and
      interpretation, modern program-development environments pursue a mixed
      strategy.  <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> interpreters are generally organized so that
      interpreted
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      and compiled
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      can call each other.
      This enables a programmer to compile those parts of a program that are
      assumed to be debugged, thus gaining the efficiency advantage of
      compilation, while retaining the interpretive mode of execution for
      those parts of the program that are in the flux of interactive
      development and debugging.  In
      section<SPACE/><REF NAME="sec:interfacing-compiled-code"/>, after we have implemented
      the compiler, we will show how to interface it with our interpreter to
      produce an integrated interpreter-compiler development system.
      <INDEX>compiler<SUBINDEX>interpreter vs.|)</SUBINDEX></INDEX>
      <INDEX>interpreter<SUBINDEX>compiler vs.|)</SUBINDEX></INDEX>
      <INDEX>compiler|)</INDEX>
    </TEXT>

    <SUBHEADING>
      <NAME>An overview of the compiler</NAME>
    </SUBHEADING>

    <INDEX>compiler for Scheme|(</INDEX>
    <INDEX>compiler for Scheme<SUBINDEX>explicit-control evaluator vs.|(</SUBINDEX></INDEX>

    <TEXT>
      Our compiler is much like our interpreter, both in its structure and in
      the function it performs.  Accordingly, the mechanisms used by the
      compiler for analyzing expressions will be similar to those used by
      the interpreter.  Moreover, to make it easy to interface compiled and
      interpreted code, we will design the compiler to generate code that
      obeys the same conventions of 
      <INDEX>compiler for Scheme<SUBINDEX>register use</SUBINDEX></INDEX>
      register usage as the interpreter: The
      environment will be kept in the <SCHEMEINLINE>env</SCHEMEINLINE> register, argument lists
      will be accumulated in <SCHEMEINLINE>argl</SCHEMEINLINE>, a
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      to be applied will be
      in <SCHEMEINLINE>proc</SCHEMEINLINE>,
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      will return their answers in <SCHEMEINLINE>val</SCHEMEINLINE>,
      and the location to which a
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      should return will be kept in
      <SCHEMEINLINE>continue</SCHEMEINLINE>.
      In general, the compiler translates a source program into an object
      program that performs essentially the same register operations as
      would the interpreter in evaluating the same source program.
    </TEXT>

    <TEXT>
      This description suggests a strategy for implementing a rudimentary
      compiler: We traverse the expression in the same way the
      interpreter does.  When we encounter a register instruction that the
      interpreter would perform in evaluating the expression, we do not
      execute the instruction but instead accumulate it into a sequence.  The
      resulting sequence of instructions will be the object code.  Observe
      the 
      <INDEX>efficiency<SUBINDEX>compilation@of compilation</SUBINDEX></INDEX>
      <INDEX>compiler for Scheme<SUBINDEX>efficiency|(</SUBINDEX></INDEX>
      efficiency advantage of compilation over interpretation.  Each
      time the interpreter evaluates an expression<EMDASH/>for example,
      <SPLITINLINE><SCHEME><SCHEMEINLINE>(f 84 96)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>f(84, 96)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE><EMDASH/>it performs the work of
      classifying the expression (discovering that this
      is a
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      application) and testing for the end of the operand list
      (discovering that there are two operands).  With a
      compiler, the expression is analyzed only once, when the
      instruction sequence is generated at compile time.  The object code
      produced by the compiler contains only the instructions that evaluate
      the operator and the two operands, assemble the argument list,
      and apply the
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      (in <SCHEMEINLINE>proc</SCHEMEINLINE>) to the arguments (in <SCHEMEINLINE>argl</SCHEMEINLINE>).
    </TEXT>

    <TEXT>
      <INDEX>compiler for Scheme<SUBINDEX>analyzing evaluator vs.</SUBINDEX></INDEX>
      This is the same kind of optimization we implemented in the
      analyzing evaluator of section<SPACE/><REF NAME="sec:separating-analysis"/>.
      But there are further opportunities to gain efficiency in compiled code.
      As the interpreter runs, it follows a process that must be applicable
      to any expression in the language.  In contrast, a given segment of
      compiled code is meant to execute some particular expression.  This
      can make a big difference, for example in the use of the stack to
      save registers.  When the interpreter evaluates an expression, it must
      be prepared for any contingency.  Before evaluating a subexpression,
      the interpreter saves all
      registers that will be needed later, because
      the subexpression might require an arbitrary evaluation.
      A compiler, on the other hand, can exploit the structure of the
      particular expression it is processing to generate code that avoids
      unnecessary stack operations.
    </TEXT>

    <TEXT>
      As a case in point, consider the combination <SPLITINLINE><SCHEME><SCHEMEINLINE>(f 84 96)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>f(84, 96)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  Before
      the interpreter evaluates the operator of the combination, it prepares
      for this evaluation by saving the registers containing the operands
      and the environment, whose values will be needed later.  The
      interpreter then evaluates the operator to obtain the result in <SCHEMEINLINE>val</SCHEMEINLINE>, restores the saved registers, and finally moves the result from
      <SCHEMEINLINE>val</SCHEMEINLINE> to <SCHEMEINLINE>proc</SCHEMEINLINE>.  However, in the particular expression we are
      dealing with, the operator is the symbol <SCHEMEINLINE>f</SCHEMEINLINE>, whose evaluation is
      accomplished by the machine operation <SPLITINLINE><SCHEME><SCHEMEINLINE>lookup-variable-value</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>lookup_variable_value</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
      which does not alter any registers.  The compiler that we implement in
      this section will take advantage of this fact and generate code that
      evaluates the operator using the instruction
      <SNIPPET EVAL="no">
  <SCHEME>
    (assign proc (op lookup-variable-value) (const f) (reg env))
  </SCHEME>
  <JAVASCRIPT>
assign("proc", op("lookup_variable_value"), constant("f"), reg("env"));
  </JAVASCRIPT>
      </SNIPPET>
      This code not only avoids the unnecessary saves and
      restores but also assigns the value of the lookup directly to
      <SCHEMEINLINE>proc</SCHEMEINLINE>, whereas the interpreter would obtain the result in <SCHEMEINLINE>val</SCHEMEINLINE>
      and then move this to <SCHEMEINLINE>proc</SCHEMEINLINE>.
    </TEXT>

    <TEXT>
      A compiler can also optimize access to the environment.  Having
      analyzed the code, the compiler can in many cases know in which frame
      a particular variable will be located and access that frame directly,
      rather than performing the <SPLITINLINE><SCHEME><SCHEMEINLINE>lookup-variable-value</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>lookup_variable_value</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> search.  We
      will discuss how to implement such variable access in
      section<SPACE/><REF NAME="sec:lexical-addressing"/>.  Until then, however, we will
      focus on the kind of register and stack optimizations described above.
      There are many other optimizations that can be performed by a
      compiler, such as coding primitive operations <QUOTE>in line</QUOTE> instead of
      using a general <SCHEMEINLINE>apply</SCHEMEINLINE> mechanism (see
      exercise<SPACE/><REF NAME="ex:open-code"/>); but we will not emphasize these here.
      Our main goal in this section is to illustrate the compilation process
      in a simplified (but still interesting) context.
      <INDEX>compiler for Scheme<SUBINDEX>efficiency|)</SUBINDEX></INDEX>
      <INDEX>compiler for Scheme<SUBINDEX>explicit-control evaluator vs.|)</SUBINDEX></INDEX>
    </TEXT>

    <!-- Subsection 1 : Structure of the Compiler -->
    &subsection5.5.1;

    <!-- Subsection 2 : Compiling Expressions -->
    &subsection5.5.2;

    <!-- Subsection 3 : Compiling Combinations -->
    &subsection5.5.3;

    <!-- Subsection 4 : Combining Instruction Sequences -->
    &subsection5.5.4;

    <!-- Subsection 5 : An Example of Compiled Code -->
    &subsection5.5.5;

    <!-- Subsection 6 : Lexical Addressing -->
    &subsection5.5.6;

    <!-- Subsection 7 : Interfacing Compiled Code to the Evaluator -->
    &subsection5.5.7;

  </SECTION>
