[{"id":"/sicpjs/5.4.3","tag":"TITLE","body":"5.4.3  \n    \n      \n      \n        Blocks, Assignments, and Declarations"},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Blocks","tag":"#text"}]},{"tag":"TEXT","id":"#p1","child":[{"body":"\n        The body of a block is evaluated with respect to the current environment\n\textended by a frame that binds all local names to the value\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"*unassigned*\""},{"body":". We temporarily\n        make use of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" register to\n\thold the list of all variables declared in the block, which is obtained\n\tby \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"scan_out_declarations"},{"body":"\n\tfrom section ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":". The functions\n  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"scan_out_declarations"},{"body":" and\n  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list_of_unassigned"},{"body":" are assumed\n  to be available as machine operations.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.4.3#footnote-1"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n\"ev_block\",\n  assign(\"comp\", list(op(\"block_body\"), reg(\"comp\"))),\n  assign(\"val\", list(op(\"scan_out_declarations\"), reg(\"comp\"))),\n\n  save(\"comp\"),    // so we can use it to temporarily hold $\\texttt{*unassigned*}$ values\n  assign(\"comp\", list(op(\"list_of_unassigned\"), reg(\"val\"))),\n  assign(\"env\", list(op(\"extend_environment\"),\n                     reg(\"val\"), reg(\"comp\"), reg(\"env\"))),\n  restore(\"comp\"), // the block body\n  go_to(label(\"eval_dispatch\")),\n\t  "}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"\n      Assignments and\n      declarations","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Assignments\n    \n    are handled by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_assignment"},{"body":",\n      \n    reached from\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":"\n    with the assignment expression in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":". The\n    code at\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_assignment"},{"body":"\n    first evaluates the value part of the expression and then installs the new\n    value in the environment.\n    \n\tThe function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assign_symbol_value"},{"body":"\n    is assumed to be available as a machine operation.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"\"ev_assignment\",\n  assign(\"unev\", list(op(\"assignment_symbol\"), reg(\"comp\"))),\n  save(\"unev\"), // save variable for later\n  assign(\"comp\", list(op(\"assignment_value_expression\"), reg(\"comp\"))),\n  save(\"env\"),\n  save(\"continue\"),\n  assign(\"continue\", label(\"ev_assignment_install\")),\n  go_to(label(\"eval_dispatch\")), // evaluate assignment value\n\"ev_assignment_install\",\n  restore(\"continue\"),\n  restore(\"env\"),\n  restore(\"unev\"),\n  perform(list(op(\"assign_symbol_value\"),\n               reg(\"unev\"), reg(\"val\"), reg(\"env\"))),\n  go_to(reg(\"continue\")),"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n        Declarations\n\t\n\tof variables and constants are handled in a similar way.\n        Note that whereas the value of an assignment is the value that was assigned,\n        the value of a declaration is\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":". This is handled by\n        setting ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":" before continuing. \n        As in the metacircular evaluator, we transform a function declaration\n        into a constant declaration whose value expression is a lambda expression. This happens at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_function_declaration"},{"body":", which makes the\n        transformation in place in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":" and\n        falls through to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_declaration"},{"body":".\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"\"ev_function_declaration\",\n  assign(\"comp\", \n         list(op(\"function_decl_to_constant_decl\"), reg(\"comp\"))),\n\"ev_declaration\",\n  assign(\"unev\", list(op(\"declaration_symbol\"), reg(\"comp\"))),\n  save(\"unev\"), // save declared name\n  assign(\"comp\",\n         list(op(\"declaration_value_expression\"), reg(\"comp\"))),\n  save(\"env\"),\n  save(\"continue\"),\n  assign(\"continue\", label(\"ev_declaration_assign\")),\n  go_to(label(\"eval_dispatch\")), // evaluate declaration value\n\"ev_declaration_assign\",\n  restore(\"continue\"),\n  restore(\"env\"),\n  restore(\"unev\"),\n  perform(list(op(\"assign_symbol_value\"),\n               reg(\"unev\"), reg(\"val\"), reg(\"env\"))),\n  assign(\"val\", constant(undefined)),\n  go_to(reg(\"continue\")),"}]},{"tag":"EXERCISE","title":"Exercise 5.25","id":"#ex-5.25","child":[{"body":"\n\tExtend the evaluator to handle\n\t\n\twhile loops, by translating them to applications of a function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"while_loop"},{"body":", as shown in\n\texercise ","tag":"#text"},{"tag":"REF","body":"4.7","href":"/sicpjs/4.1.2#ex-4.7"},{"body":".\n\tYou can paste the declaration of the function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"while_loop"},{"body":" in front of user programs.\n\tYou may \"","tag":"#text"},{"body":"cheat","tag":"#text"},{"body":"\" by assuming that the syntax transformer\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"while_to_application"},{"body":" is available\n\tas a machine operation. Refer to\n\texercise ","tag":"#text"},{"tag":"REF","body":"4.7","href":"/sicpjs/4.1.2#ex-4.7"},{"body":" to discuss whether\n\tthis approach works if return, break, and continue statements are allowed\n\tinside the while loop. If not,\n\thow can you modify the explicit-control evaluator to run programs \n\twith while loops that include these statements?\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.26","id":"#ex-5.26","child":[{"body":"\n    Modify the evaluator so that it uses\n    \n    normal-order evaluation,\n    based on the lazy evaluator of\n    section ","tag":"#text"},{"tag":"REF","body":"4.2","href":"/sicpjs/4.2"},{"body":".\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.4.3#footnote-link-1","child":[{"body":"\n\tFootnote ","tag":"#text"},{"tag":"REF","body":2,"href":"/sicpjs/5.4.2#footnote-2"},{"body":"\n\tsuggests that an actual implementation would perform\n\tsyntax transformations before program execution.\n  In the same vein, names declared in blocks should be scanned out\n  in a preprocessing step rather than each time a block is evaluated.\n\t","tag":"#text"}]}]