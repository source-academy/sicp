    <SUBSECTION>
      <NAME>
        Representations for Complex Numbers
      </NAME>

      <LABEL NAME="sec:representations-complex-numbers"/>

      <TEXT>
      <INDEX>complex numbers<SUBINDEX>rectangular vs.\ polar form|(</SUBINDEX></INDEX>
      We will develop a system that performs arithmetic operations on
      complex numbers as a simple but unrealistic example of a program that
      uses generic operations.  We begin by discussing two plausible
      representations for complex numbers as ordered pairs: rectangular form
      (real part and imaginary part) and polar form (magnitude and
      angle).<FOOTNOTE>In actual computational systems, rectangular form is
        preferable to polar form most of the time because of 
        <INDEX>roundoff error</INDEX>
        roundoff errors
        in conversion between rectangular and polar form.  This is why the
        complex-number example is unrealistic.  Nevertheless, it provides a
        clear illustration of the design of a system using generic operations
        and a good introduction to the more substantial systems to be
        developed later in this chapter.</FOOTNOTE>  Section<SPACE/><REF NAME="sec:manifest-types"/>
      will show how both representations can be made to coexist in a single
      system through the use of type tags and generic operations.
      </TEXT>
      <TEXT>
      Like rational numbers, complex numbers are naturally represented as
      ordered pairs.  The set of complex numbers can be thought of as a
      two-dimensional space with two orthogonal axes, the <QUOTE>real</QUOTE> axis and
      the <QUOTE>imaginary</QUOTE> axis. (See figure<SPACE/><REF NAME="fig:complex-plane"/>.)  From
      this point of view, the complex number <LATEXINLINE>$z=x+iy$</LATEXINLINE>
      (where <LATEXINLINE>$i^{2} =-1$</LATEXINLINE>)
      can be thought of as the point in the plane whose real coordinate is
      <LATEXINLINE>$x$</LATEXINLINE> and whose imaginary coordinate is <LATEXINLINE>$y$</LATEXINLINE>.
      Addition of complex numbers reduces in
      this representation to addition of coordinates:

      <LATEX>
\begin{eqnarray*}
\mbox{Real-part}(z_{1}+z_{2}) &amp; = &amp; \mbox{Real-part}(z_{1})+\mbox{Real-part}(z_{2})\\
\mbox{Imaginary-part}(z_{1} +z_{2}) &amp; = &amp; \mbox{Imaginary-part}(z_1)+\mbox{Imaginary-part}(z_2)
\end{eqnarray*}
      </LATEX>
      </TEXT>
      <TEXT>
      When multiplying complex numbers, it is more natural to think in terms
      of representing a complex number in polar form, as a magnitude and an
      angle (<LATEXINLINE>$r$</LATEXINLINE> and <LATEXINLINE>$A$</LATEXINLINE> in figure<SPACE/><REF NAME="fig:complex-plane"/>).
      The product of two complex numbers is the vector obtained by
      stretching one complex number by the length of the other and then
      rotating it through the angle of the other:


      <LATEX>
\begin{eqnarray*}
\mbox{Magnitude}(z_{1}\cdot z_{2}) & = & \mbox{Magnitude}(z_{1})\cdot\mbox{Magnitude}(z_{2})\\
\mbox{Angle}(z_{1}\cdot z_{2}) & = & \mbox{Angle}(z_{1})+\mbox{Angle}(z_{2})
\end{eqnarray*}
      </LATEX>
      <INDEX>complex numbers<SUBINDEX>rectangular vs.\ polar form|)</SUBINDEX></INDEX>
      </TEXT>
      <TEXT>
      Thus, there are two different representations for complex numbers,
      which are appropriate for different operations.  Yet, from the
      viewpoint of someone writing a program that uses complex numbers, the
      principle of data abstraction suggests that all the operations for
      manipulating complex numbers should be available regardless of which
      representation is used by the computer.  For example, it is often
      useful to be able to find the magnitude of a complex number that is
      specified by rectangular coordinates.  Similarly, it is often useful
      to be able to determine the real part of a complex number that is
      specified by polar coordinates.
      <FIGURE>
        <FIGURE src="img_original/ch2-Z-G-59.svg"></FIGURE>
        <CAPTION>Complex numbers as points in the plane.</CAPTION>
        <LABEL NAME="fig:complex-plane"/>
      </FIGURE>
      </TEXT>
      <TEXT>
      To design such a system, we can follow the same 
      <INDEX>data abstraction</INDEX>
      data-abstraction
      strategy we followed in designing the rational-number package in
      section<SPACE/><REF NAME="sec:rationals"/>.  Assume that the operations on complex numbers are
      implemented in terms of four selectors: <SPLITINLINE><SCHEME><SCHEMEINLINE>real-part</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
      <SPLITINLINE><SCHEME><SCHEMEINLINE>imag-part</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>imag_part</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>magnitude</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>magnitude</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and <SPLITINLINE><SCHEME><SCHEMEINLINE>angle</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>angle</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  Also assume that
      we have two
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      for constructing complex numbers: <SPLITINLINE><SCHEME><SCHEMEINLINE>make-from-real-imag</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> returns a complex number with specified real and
      imaginary parts, and <SPLITINLINE><SCHEME><SCHEMEINLINE>make-from-mag-ang</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_from_mag_ang</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> returns a complex number with
      specified magnitude and angle.  These
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      have the property that,
      for any complex number <SPLITINLINE><SCHEME><SCHEMEINLINE>z</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>z</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, both
      <SNIPPET EVAL="no">
        <SCHEME>
(make-from-real-imag (real-part z) (imag-part z))
        </SCHEME>
        <JAVASCRIPT>
make_from_real_imag(real_part(z),imag_part(z));
      </JAVASCRIPT>
      </SNIPPET>
      and
      <SNIPPET EVAL="no">
        <SCHEME>
(make-from-mag-ang (magnitude z) (angle z))
        </SCHEME>
        <JAVASCRIPT>
make_from_mag_ang(magnitude(z), angle(z));
      </JAVASCRIPT>
      </SNIPPET>
      produce complex numbers that are equal to <SPLITINLINE><SCHEME><SCHEMEINLINE>z</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>z</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.
      </TEXT>
      <TEXT>
      Using these constructors and selectors, we can implement
      arithmetic on complex numbers using the <QUOTE>abstract data</QUOTE> specified by
      the constructors and selectors, just as we did for rational numbers in
      section<SPACE/><REF NAME="sec:rationals"/>.  As shown in the formulas above, we can add and
      subtract complex numbers in terms of real and imaginary parts while
      multiplying and dividing complex numbers in terms of magnitudes and
      angles:

      <SNIPPET EVAL="no">
        <NAME>complex_number_calculation</NAME>
        <SCHEME>
          <!-- \indcode*{add-complex} -->
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))

          <!-- \indcode*{sub-complex} -->
(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))

          <!-- \indcode*{mul-complex} -->
(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))

          <!-- \indcode*{div-complex} -->
(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
        </SCHEME>
        <JAVASCRIPT>
function add_complex(z1, z2) {
    return make_from_real_imag(
               real_part(z1) + real_part(z2),
               imag_part(z1) + imag_part(z2));
}
function sub_complex(z1, z2) {
    return make_from_real_imag(
               real_part(z1) - real_part(z2),
               imag_part(z1) - imag_part(z2));
}
function mul_complex(z1, z2) {
    return make_from_mag_ang(
               magnitude(z1) * magnitude(z2),
               angle(z1) + angle(z2));
}
function div_complex(z1, z2) {
    return make_from_mag_ang(
               magnitude(z1) / magnitude(z2),
               angle(z1) - angle(z2));
}
        </JAVASCRIPT>
      </SNIPPET>
      </TEXT>
      <TEXT>
      To complete the complex-number package, we must choose a
      representation and we must implement the constructors and selectors in
      terms of primitive numbers and primitive list structure.
      There are two obvious ways to do this: We can represent a complex
      number in <QUOTE>rectangular form</QUOTE> as a pair (real part, imaginary part)
      or in <QUOTE>polar form</QUOTE> as a pair (magnitude, angle).  Which shall we
      choose?
      </TEXT>
      <TEXT>
      In order to make the different choices concrete, imagine that there
      are two programmers, Ben Bitdiddle and Alyssa P. Hacker, who are
      independently designing representations for the complex-number system.
      <INDEX>complex numbers<SUBINDEX>rectangular representation</SUBINDEX></INDEX>
      Ben chooses to represent complex numbers in rectangular form.  With
      this choice, selecting the real and imaginary parts of a complex
      number is straightforward, as is constructing a complex number with
      given real and imaginary parts.  To find the magnitude and the angle,
      or to construct a complex number with a given magnitude and angle, he
      uses the trigonometric relations

      <LATEX>
	\begin{eqnarray*}
         x = r\ \cos A\qquad\qquad r = \sqrt{x^2 +y^2} \\
         y = r\ \sin A\qquad\qquad A = \arctan (y,x)
	 \end{eqnarray*}
    </LATEX>

      which relate the real and imaginary parts (<LATEXINLINE>$x$</LATEXINLINE>, <LATEXINLINE>$y$</LATEXINLINE>) to the magnitude
      and the angle <LATEXINLINE>$(r, A)$</LATEXINLINE>.<FOOTNOTE>The arctangent function referred to
        <INDEX>arctangent</INDEX>
        <!--\indprim*{atan}-->
        <!--\ind*{primitive
            <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
            (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[atan@<SCHEMEINLINE>atan</SCHEMEINLINE>]
            -->
            here,
	    <SPLITINLINE>
	      <SCHEME>
		computed by Scheme<APOS/>s <SCHEMEINLINE>atan</SCHEMEINLINE> procedure,
	      </SCHEME>
	      <JAVASCRIPT>
		computed by JavaScript<APOS/>s <JAVASCRIPTINLINE>math_atan2</JAVASCRIPTINLINE> function,
	      </JAVASCRIPT>
	    </SPLITINLINE>
        is defined so as to take two arguments <LATEXINLINE>$y$</LATEXINLINE><SPACE/>and <LATEXINLINE>$x$</LATEXINLINE> and to return
        the angle whose tangent is <LATEXINLINE>$y/x$</LATEXINLINE>.  The signs of the arguments
        determine the quadrant of the angle.</FOOTNOTE> Ben<APOS/>s representation is
      therefore given by the following selectors and constructors:

      <SNIPPET>
        <NAME>make_complex_number1</NAME>
        <REQUIRES>complex_number_calculation</REQUIRES>
        <REQUIRES>square_definition</REQUIRES>
        <EXAMPLE>make_complex_number_example</EXAMPLE>
        <SCHEME>
          <!-- \indcode*{real-part}[rectangular representation] -->
(define (real-part z) (car z))

          <!-- \indcode*{imag-part}[rectangular representation] -->
(define (imag-part z) (cdr z))

          <!-- \indcode*{magnitude}[rectangular representation] -->
(define (magnitude z)
  (sqrt (+ (square (real-part z)) (square (imag-part z)))))

          <!-- \indcode*{angle}[rectangular representation] -->
(define (angle z)
  (atan (imag-part z) (real-part z)))

          <!-- \indcode*{make-from-real-imag}[rectangular representation] -->
(define (make-from-real-imag x y) (cons x y))

          <!-- \indcode*{make-from-mag-ang}[rectangular representation] -->
(define (make-from-mag-ang r a) 
  (cons (* r (cos a)) (* r (sin a))))
        </SCHEME>
        <JAVASCRIPT>
function real_part(z) {
    return head(z);
}
function imag_part(z) {
    return tail(z);
}
function magnitude(z) {
    return math_sqrt(
               square(real_part(z)) + 
               square(imag_part(z)));
}
function angle(z) {
    return math_atan2(imag_part(z),real_part(z));
}
function make_from_real_imag(x, y) {
    return pair(x, y);
}
function make_from_mag_ang(r, a) {
    return pair(r * math_cos(a), r * math_sin(a));
}
        </JAVASCRIPT>
      </SNIPPET>

      <SNIPPET HIDE="yes">
        <NAME>make_complex_number_example</NAME>
	<JAVASCRIPT>
const my_co_num_1 = make_from_real_imag(2.5, -0.5);
const my_co_num_2 = make_from_real_imag(2.5, -0.5);

const result = add_complex(my_co_num_1, 
                   mul_complex(my_co_num_2, 
                       my_co_num_2));

imag_part(result);		       
	</JAVASCRIPT>
      </SNIPPET>
      
      </TEXT>
      <TEXT>
      <INDEX>complex numbers<SUBINDEX>polar representation</SUBINDEX></INDEX>
      Alyssa, in contrast, chooses to represent complex numbers in polar
      form.  For her, selecting the magnitude and angle is straightforward,
      but she has to use the 
      <INDEX>trigonometric relations</INDEX>
      trigonometric relations to obtain the real and
      imaginary parts.  Alyssa<APOS/>s representation is:

      <SNIPPET>
        <NAME>make_complex_number2</NAME>
        <REQUIRES>complex_number_calculation</REQUIRES>
        <REQUIRES>square_definition</REQUIRES>
        <EXAMPLE>make_complex_number_example</EXAMPLE>
        <SCHEME>
          <!-- \indcode*{real-part}[polar representation] -->
(define (real-part z)
  (* (magnitude z) (cos (angle z))))

          <!-- \indcode*{imag-part}[polar representation] -->
(define (imag-part z)
  (* (magnitude z) (sin (angle z))))

          <!-- \indcode*{magnitude}[polar representation] -->
(define (magnitude z) (car z))

          <!-- \indcode*{angle}[polar representation] -->
(define (angle z) (cdr z))

          <!-- \indcode*{make-from-real-imag}[polar representation] -->
(define (make-from-real-imag x y) 
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))

          <!-- \indcode*{make-from-mag-ang}[polar representation] -->
(define (make-from-mag-ang r a) (cons r a))
        </SCHEME>
        <JAVASCRIPT>
function real_part(z) {
    return magnitude(z) * math_cos(angle(z));
}
function imag_part(z) {
    return magnitude(z) * math_sin(angle(z));
}
function magnitude(z) {
    return head(z);
}
function angle(z) {
    return tail(z);
}
function make_from_real_imag(x, y) {
    return pair(math_sqrt(square(x) + square(y)),
                math_atan2(y, x));
}
function make_from_mag_ang(r, a) {
    return pair(r, a);
}
      </JAVASCRIPT>
      </SNIPPET>

      The discipline of data abstraction ensures that the same implementation of
      <SPLITINLINE><SCHEME><SCHEMEINLINE>add-complex</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>add_complex</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>sub-complex</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>sub_complex</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>mul-complex</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>mul_complex</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and <SPLITINLINE><SCHEME><SCHEMEINLINE>div-complex</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>div_complex</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> will work with either Ben<APOS/>s representation or Alyssa<APOS/>s
      representation. 
      </TEXT>
    </SUBSECTION>
