[{"id":"/sicpjs/5.5.3","tag":"TITLE","body":"5.5.3  \n    Compiling\n    \n      \n      \n\tApplications and Return Statements"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    The essence of the compilation process is the compilation of\n    function\n    applications. The code for\n    an application\n    compiled with a given target and\n    linkage has the form\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\langle{}$compilation of function expression, target fun, linkage \"next\"$\\rangle$\n$\\langle{}$evaluate argument expressions and construct argument list in argl$\\rangle$\n$\\langle{}$compilation of function call with given target and linkage$\\rangle$\n      "},{"body":"\n\n    The registers ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":",\n      \n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" may\n    have to be saved and restored during evaluation of the\n    \n\tfunction and argument expressions.\n      \n    Note that this is the only place in the compiler where a target other\n    than ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" is specified.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The required code is generated by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_application"},{"body":".\n      \n    This recursively compiles the\n    function expression,\n    to produce code that puts the\n    function\n    to be applied into\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":",\n      \n    and compiles the\n    argument expressions,\n    to produce code that evaluates the individual\n    argument expressions\n    of the\n    application.  The instruction sequences for the\n    argument expressions\n    are combined\n    (by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"construct_arglist"},{"body":")\n      \n    with code that constructs the list of\n    arguments in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":", and the resulting\n    argument-list code is combined with the\n    function\n    code and the code that performs the\n    function\n    call (produced by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_function_call"},{"body":").\n      \n    In appending the code sequences, the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":"\n    register must be preserved around the evaluation of the\n    function expression\n    (since\n    evaluating the\n    function expression\n    might modify ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":", which\n    will be needed to evaluate the\n    argument expressions),\n    and the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":"\n    register must be preserved around the\n    construction of the argument list (since evaluating the\n    argument expressions\n    might\n    modify\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":",\n      \n    which will be needed for the actual\n    function\n    application). \n        The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register\n      \n    must also be preserved throughout, since\n    it is needed for the linkage in the\n    function\n    call.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"function compile_application(exp, target, linkage) {\n    const fun_code = compile(function_expression(exp), \"fun\", \"next\");\n    const argument_codes = map(arg => compile(arg, \"val\", \"next\"),\n                               arg_expressions(exp));\n    return preserving(list(\"env\", \"continue\"),\n                      fun_code,\n                      preserving(list(\"fun\", \"continue\"),\n                          construct_arglist(argument_codes),\n                          compile_function_call(target, linkage)));\n}"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    The code to construct the argument list will evaluate each\n    \n\targument expression\n      \n    into\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and then\n    \n\tcombine\n\tthat value with the argument list being accumulated in\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":"\n\tusing ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":".\n      \n    Since we\n    \n\tadjoin the arguments to the front of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":"\n\tin sequence,\n      \n    we must start with the last argument and end with the first, so that the\n    arguments will appear in order from first to last in the resulting list.\n    Rather than waste an instruction by initializing\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" to the empty list\n    to set up for this sequence of evaluations,\n    we make the first code sequence construct the initial\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":".\n    The general form of the argument-list construction is thus as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\langle{}$compilation of last argument, targeted to val$\\rangle$\nassign(\"argl\", list(op(\"list\"), reg(\"val\"))),\n$\\langle{}$compilation of next argument, targeted to val$\\rangle$\nassign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))),\n$\\ldots$\n$\\langle{}$compilation of first argument, targeted to val$\\rangle$\nassign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))),\n      "},{"body":"\n\tThe ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" register\n\tmust be preserved around each argument\n      \n    evaluation except the first (so that arguments accumulated so far\n    won't be lost), and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" must be\n    preserved around each\n    \n\targument evaluation except the last (for use by subsequent argument evaluations).\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Compiling this argument code is a bit tricky, because of the special\n    treatment of the first\n    argument expression\n    to be evaluated and the need to preserve\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" in\n    different places. The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"construct_arglist"},{"body":"function\n    takes as arguments the code that evaluates the individual\n    argument expressions.\n    If there are no\n    argument expressions\n    at all, it simply emits the instruction\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"assign(argl, constant(null))"},{"body":"\n    Otherwise,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"construct_arglist"},{"body":"\n    creates code that initializes ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" with the\n    last argument, and appends code that evaluates the rest of the arguments and\n    adjoins them to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" in succession.  In order\n    to process the arguments from last to first, we must reverse the list of\n    argument\n    code sequences from the order supplied by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_application"},{"body":".\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"function construct_arglist(arg_codes) {\n    if (is_null(arg_codes)) {\n        return make_instruction_sequence(null, list(\"argl\"),\n                   list(assign(\"argl\", constant(null))));\n    } else {\n        const rev_arg_codes = reverse(arg_codes);\n        const code_to_get_last_arg =\n            append_instruction_sequences(\n                head(rev_arg_codes),\n                make_instruction_sequence(list(\"val\"), list(\"argl\"),\n                    list(assign(\"argl\", \n                                list(op(\"list\"), reg(\"val\"))))));\n        return is_null(tail(rev_arg_codes))\n               ? code_to_get_last_arg\n               : preserving(list(\"env\"),\n                     code_to_get_last_arg,\n                     code_to_get_rest_args(tail(rev_arg_codes)));\n    }\n}\nfunction code_to_get_rest_args(arg_codes) {\n    const code_for_next_arg =\n        preserving(list(\"argl\"),\n            head(arg_codes),\n            make_instruction_sequence(list(\"val\", \"argl\"), list(\"argl\"),\n                list(assign(\"argl\", list(op(\"pair\"),\n                                         reg(\"val\"), reg(\"argl\"))))));\n    return is_null(tail(arg_codes))\n           ? code_for_next_arg\n           : preserving(list(\"env\"),\n                        code_for_next_arg,\n                        code_to_get_rest_args(tail(arg_codes)));\n}"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"\n      Applying\n      functions","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    After evaluating the elements of a\n    function application,\n    the compiled code must apply the\n    function\n    in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":"\n    to the arguments in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":".  The code performs essentially the same\n    dispatch as the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply"},{"body":"function\n    in the metacircular evaluator of\n    section ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":" or the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_dispatch"},{"body":"\n    entry point in the explicit-control evaluator of\n    section ","tag":"#text"},{"tag":"REF","body":"5.4.2","href":"/sicpjs/5.4.2"},{"body":".  It checks whether\n    the\n    function\n    to be applied is a primitive\n    function\n    or a compiled\n    function.\n    For a primitive\n    function,\n    it uses\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_primitive_function"},{"body":";\n      \n    we will see shortly how it handles compiled\n    functions.\n    The\n    function-application\n    code has the following form:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":""},{"body":"\n    Observe that the compiled branch must skip around the primitive\n    branch.  Therefore, if the linkage for the original\n    function\n    call was\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":",\n      \n    the compound branch must use a\n    linkage that jumps to a label that is inserted after the primitive branch.\n    (This is similar to the linkage used for the true branch in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_conditional"},{"body":".)","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"function compile_function_call(target, linkage) {\n    const primitive_branch = make_label(\"primitive_branch\");\n    const compiled_branch = make_label(\"compiled_branch\");\n    const after_call = make_label(\"after_call\");\n    const compiled_linkage = linkage === \"next\" ? after_call : linkage;\n    return append_instruction_sequences(\n        make_instruction_sequence(list(\"fun\"), null,\n            list(test(list(op(\"is_primitive_function\"), reg(\"fun\"))),\n                 branch(label(primitive_branch)))),\n        append_instruction_sequences(\n            parallel_instruction_sequences(\n                append_instruction_sequences(\n                    compiled_branch,\n                    compile_fun_appl(target, compiled_linkage)),\n                append_instruction_sequences(\n                    primitive_branch,\n                    end_with_linkage(linkage,\n                        make_instruction_sequence(list(\"fun\", \"argl\"),\n                                                  list(target),\n                            list(assign(\n                                   target,\n                                   list(op(\"apply_primitive_function\"),\n                                        reg(\"fun\"), reg(\"argl\")))))))),\n            after_call));\n}"},{"body":"\n    The primitive and compound branches, like the true\n    and false branches in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_conditional"},{"body":",\n    are appended using\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"parallel_instruction_sequences"},{"body":"\n    rather than the ordinary\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_instruction_sequences"},{"body":",\n      \n    because they will not be executed sequentially.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"\n      Applying compiled\n    functions","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"The handling of function\n    application\n    \n        and return\n      \n      is the most subtle part of the\n      \n          compiler.\n        \n      A compiled\n    function\n    (as constructed by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_expression"},{"body":")\n      \n    has an entry point, which is a label that designates where the code for the\n    function\n    starts. The code at this entry point computes a result in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":"and ends by executing the instructions from a compiled return statement.","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n        The code for a compiled-function application uses the\n        stack in the same way as the explicit-control evaluator\n        (section ","tag":"#text"},{"tag":"REF","body":"5.4.2","href":"/sicpjs/5.4.2"},{"body":"):\n        before jumping to the compiled function's entry point, it\n        saves the continuation of the function call to the stack,\n        followed by a mark that allows reverting the stack to the\n        state right before the call with the continuation on top.\n      ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\texttt{ }\\texttt{ }$// set up for return from function\n  save(\"continue\"),\n  push_marker_to_stack(),\n  // jump to the function's entry point\n  assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\n  go_to(reg(\"val\")),\n        "},{"body":"\n        Compiling a return statement (with\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_return_statement"},{"body":")\n        generates corresponding code for reverting the stack and restoring\n        and jumping to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":".\n        ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\texttt{ }\\texttt{ }$revert_stack_to_marker(),\n  restore(\"continue\"),\n  $\\langle{}$evaluate the return expression and store the result in val$\\rangle$\n  go_to(reg(\"continue\")), // $\\texttt{\"return\"}$-linkage code\n         "},{"body":"\n       Unless a function enters an infinite loop,\n       it will end by executing the above return code,\n       resulting from either a return statement in the program\n       or one inserted by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_body"},{"body":"\n       to return ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.5.3#footnote-1"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"Straightforward code for a compiled-function application with a\n        given target and linkage would set up ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" to make the function\n        return to a local label instead of to the final linkage,\n        to copy the function value from ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" to the target register if necessary.\n        It would look like this if the linkage is a label:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\texttt{ }\\texttt{ }$assign(\"continue\", label(\"fun_return\")), // where function should return to\n  save(\"continue\"),       // will be restored by the function\n  push_marker_to_stack(), // allows the function to revert stack to find $\\texttt{fun\\_return}$\n  assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\n  go_to(reg(\"val\")),    // eventually reverts stack, restores and jumps to $\\texttt{continue}$\n\"fun_return\",             // the function returns to here\n  assign($\\mathit{target}$, reg(\"val\")), // included if target is not $\\texttt{val}$\n  go_to(label($linkage$)),   // linkage code\n      "},{"body":"\n    or like\n    \n        this—saving the caller's continuation at the start in\n        order to restore and go to it at the\n        end—if the linkage is ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":" (that is, if the application is in a return statement and its value is the result to be returned):\n      ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\texttt{ }\\texttt{ }$save(\"continue\"),       // save the caller's continuation\n  assign(\"continue\", label(\"fun_return\")), // where function should return to\n  save(\"continue\"),       // will be restored by the function\n  push_marker_to_stack(), // allows the function to revert stack to find $\\texttt{fun\\_return}$\n  assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\n  go_to(reg(\"val\")),    // eventually reverts stack, restores and jumps to $\\texttt{continue}$\n\"fun_return\",             // the function returns to here\n  assign($\\mathit{target}$, reg(\"val\")), // included if target is not $\\texttt{val}$\n  restore(\"continue\"),    // restore the caller's continuation\n  go_to(reg(\"continue\")), // linkage code\n      "},{"body":"\n    This code sets up ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" so that the\n    function\n    will return to a label\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun_return"},{"body":"\n    and jumps to the\n    function's\n    entry point. The code at\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun_return"},{"body":"\n    transfers the\n    function's\n    result from ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" to the target register (if\n    necessary) and then jumps to the location specified by the linkage.\n    (The linkage is always\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n    or a label,\n    because\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_function_call"},{"body":"\n    replaces a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":"\n    linkage for the\n    \n\tcompound-function branch by an\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"after_call"},{"body":"\n    label.)\n\n    \n        Before jumping to the function's entry point, we\n        save ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" and\n        execute ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"push_marker_to_stack()"},{"body":" to enable\n        the function to return to the intended location in the program with the expected stack. Matching\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"revert_stack_to_marker()"},{"body":" and\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore(\"continue\")"},{"body":" instructions\n        are generated by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_return_statement"},{"body":" for each return statement in the body of the\n        function.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.5.3#footnote-2"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    In fact, if\n    the target is not ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":",\n    the above is\n    exactly the code our compiler will generate.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/5.5.3#footnote-3"},{"body":"\n    Usually, however, the target is ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" (the only\n    time the compiler specifies a different register is when targeting the\n    evaluation of\n    a function expression\n    to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":"),\n      \n    so the\n    function\n    result is put directly into\n    the target register and there is no need to\n    jump\n    to a special\n    location that copies it. Instead we simplify the code by\n    setting up ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" so that the\n    called function\n    will\n    \"","tag":"#text"},{"body":"return","tag":"#text"},{"body":"\"\n    directly to the place specified by the caller's linkage:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\langle{}$set up continue for linkage and push the marker$\\rangle$\nassign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\ngo_to(reg(\"val\")),\n      "},{"body":"\n    If the linkage is a label, we set up ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":"\n    so that the\n    function\n    will continue at\n    that label.  (That is, the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"go_to(reg(\"continue\"))"},{"body":"\n    the\n    called function\n    ends with becomes equivalent to the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"go_to(label("},{"tag":"META","body":"linkage"},{"tag":"JAVASCRIPTINLINE","body":"))"},{"body":"\n    at\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun_return"},{"body":"\n    above.)\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nassign(\"continue\", label($linkage$)),\nsave(\"continue\"),\npush_marker_to_stack(),\nassign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\ngo_to(reg(\"val\")),\n      "},{"body":"\n    If the linkage is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":",\n      \n    we don't need to \n\n    assign ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":":\n\n    It already holds the desired location.\n    (That is, the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"go_to(reg(\"continue\"))"},{"body":"\n    the\n    called function\n    ends with goes directly to the\n    place where the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"go_to(reg(\"continue\"))"},{"body":"\n    at\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun_"},{"body":"{\\hspace{0pt}}","tag":"#text"},{"tag":"TT","child":[{"body":"return","tag":"#text"}]},{"body":" \n    would have gone.)\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"save(\"continue\"),\npush_marker_to_stack(),\nassign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\ngo_to(reg(\"val\")),"},{"body":"\n    With this implementation of the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n    linkage,\n    the compiler generates\n    \n    tail-recursive code.\n    A function call in a return statement whose value is the result to be returned\n    does a direct transfer, without saving\n    unnecessary information on the stack.","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    Suppose instead that we had handled the case of a\n    function\n    call with a\n    linkage of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":" and a target of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" in the same way as for a\n    non-","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" target. This would destroy tail\n    recursion. Our system would still\n    \n\t      return\n      \n      the same value for any\n    \n\tfunction call.\n      \n    But each time we called a\n    function,\n    we would save\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" \n      and return after the call to undo the (useless) save. These extra\n    saves would accumulate during a nest of\n    function\n    calls.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/5.5.3#footnote-4"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_fun_appl"},{"body":"\n    generates the above\n    function-application\n    code by considering four cases,\n    depending on whether the target for the call\n    is ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and whether the linkage is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":".\n      \n    Observe that the instruction sequences\n    are declared to modify all the registers, since executing the\n    function\n    body can change the registers in arbitrary ways.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/5.5.3#footnote-5"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction compile_fun_appl(target, linkage) {\n    const fun_return = make_label(\"fun_return\");\n    return target === \"val\" && linkage !== \"return\"\n           ? make_instruction_sequence(list(\"fun\"), all_regs,\n                 list(assign(\"continue\", label(linkage)),\n                      save(\"continue\"),\n                      push_marker_to_stack(),\n                      assign(\"val\", list(op(\"compiled_function_entry\"),\n                                         reg(\"fun\"))),\n                      go_to(reg(\"val\"))))\n           : target !== \"val\" && linkage !== \"return\"\n           ? make_instruction_sequence(list(\"fun\"), all_regs,\n                 list(assign(\"continue\", label(fun_return)),\n                      save(\"continue\"),\n                      push_marker_to_stack(),\n                      assign(\"val\", list(op(\"compiled_function_entry\"),\n                                         reg(\"fun\"))),\n                      go_to(reg(\"val\")),\n                      fun_return,\n                      assign(target, reg(\"val\")),\n                      go_to(label(linkage))))\n           : target === \"val\" && linkage === \"return\"\n           ? make_instruction_sequence(list(\"fun\", \"continue\"),\n                                       all_regs,\n                 list(save(\"continue\"),\n                      push_marker_to_stack(),\n                      assign(\"val\", list(op(\"compiled_function_entry\"),\n                                         reg(\"fun\"))),\n                      go_to(reg(\"val\"))))\n           : // $\\texttt{target !== \"val\" \\&\\& linkage === \"return\"}$\n             error(target, \"return linkage, target not val -- compile\");\n}\n      "}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n  We have shown how to generate tail-recursive linkage code for a\n  function application when the linkage is ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"—that is, when the application is in a return statement\nand its value is the result to be returned. Similarly, as explained in\n  section ","tag":"#text"},{"tag":"REF","body":"5.4.2","href":"/sicpjs/5.4.2"},{"body":", the stack-marker mechanism used here (and in the\n  explicit-control evaluator) for the call and return produces\n  \n  tail-recursive behavior only in that situation. These two aspects of the code generated for function\n  application combine to ensure that when a function ends by returning\n  the value of a function call, no stack accumulates.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"\n          Compiling return statements\n        ","tag":"#text"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n        The code for a\n        \n\treturn statement takes the following form, regardless of the given linkage and target:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nrevert_stack_to_marker(),\nrestore(\"continue\"),   // saved by $\\texttt{compile\\char`_fun\\char`_appl}$\n$\\langle{}$evaluate the return expression and store the result in val$\\rangle$\ngo_to(reg(\"continue\")) // $\\texttt{\"return\"}$-linkage code\n          "},{"body":"\n        The instructions to revert the stack using the marker and then restore \n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" correspond to the\n        instructions generated by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_fun_appl"},{"body":"\n        to save ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" and mark the stack.\n        The final jump to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" is\n        generated by the use of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n        linkage when compiling the return expression.\n        The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_return_statement"},{"body":"\n        is different from all other code generators in that it ignores the target \n        and linkage arguments—it always compiles the return expression with\n        target ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and linkage \n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":".\n         ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"function compile_return_statement(stmt, target, linkage) {\n    return append_instruction_sequences(\n               make_instruction_sequence(null, list(\"continue\"),\n                   list(revert_stack_to_marker(),\n                        restore(\"continue\"))),\n               compile(return_expression(stmt), \"val\", \"return\"));\n}"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.5.3#footnote-link-1","child":[{"body":"\n       Because the execution of a function body always ends with a return,\n       there is no need here for a mechanism like the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return_undefined"},{"body":"\n       entry point from section ","tag":"#text"},{"tag":"REF","body":"5.4.2","href":"/sicpjs/5.4.2"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.5.3#footnote-link-2","child":[{"body":"Elsewhere in the compiler, all saves and restores of registers\nare generated by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":"\nto preserve a register's value across a sequence of instructions\nby saving it before those instructions and restoring it\nafter—for example over the evaluation of the predicate of a\nconditional. But this mechanism cannot generate instructions to\nsave and restore ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" for a function application and the\ncorresponding return, because these are compiled separately and\nare not contiguous. Instead, these saves and restores must be\nexplicitly generated by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_fun_appl"},{"body":" and\n","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_return_statement"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/5.5.3#footnote-link-3","child":[{"body":"Actually, we signal\n    an error when the target is not ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and the\n    linkage is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":",\n      \n    since the only place we request\n    \n        a ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":" linkage\n      \n    is in compiling\n    return expressions,\n    and our convention is that\n    functions\n    return their values in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/5.5.3#footnote-link-4","child":[{"body":"Making a\n    \n    compiler generate tail-recursive\n    \n        code is desirable, especially in the functional paradigm.\n      \n    However, compilers for common languages,\n    including\n    C and C++,\n    do not always do this, and therefore these languages\n    cannot represent iterative processes in terms of\n    function\n    call alone. The difficulty with\n    \n    tail recursion in these languages is that their\n    implementations use the stack to store\n    function\n    arguments and local\n    names\n    as well as return addresses.  The\n    \n\tJavaScript\n      \n    implementations described in this book store arguments and\n    names\n    in memory to be garbage-collected.  The reason for using the stack for\n    names\n    and arguments is that it avoids the need for garbage collection\n    in languages that would not otherwise require it, and is generally\n    believed to be more efficient.  Sophisticated\n    \n    compilers can, in fact, use the stack for arguments without destroying tail\n    recursion. (See\n    Hanson 1990 for a description.)  There is also some\n    debate about whether stack allocation is actually more efficient than garbage\n    collection in the first place, but the details seem to hinge on fine\n    points of computer architecture.  (See\n    Appel 1987 and\n    Miller and Rozas 1994\n    for opposing views on this issue.)","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/5.5.3#footnote-link-5","child":[{"body":"The\n    constant","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"all_regs"},{"body":"\n    is bound to the list of names of all the registers:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"const all_regs = list(\"env\", \"fun\", \"val\", \"argl\", \"continue\");"}]}]