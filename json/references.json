[{"id":"/sicpjs/references","tag":"TITLE","body":"References"},{"tag":"REFERENCE","child":[{"body":"\n    Abelson, Harold, Andrew Berlin, Jacob Katzenelson,\n    William McAllister,\n    Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992.  The\n    Supercomputer Toolkit: A general framework for special-purpose\n    computing.  ","tag":"#text"},{"tag":"EM","child":[{"body":"International Journal of High-Speed Electronics","tag":"#text"}]},{"body":"\n    3(3):337–361.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"\n    Allen, John.  1978.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Anatomy of Lisp.","tag":"#text"}]},{"body":" New York: McGraw-Hill.\n  ","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Appel, Andrew W.  1987.  Garbage collection can be faster than stack\n    allocation.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Information Processing Letters","tag":"#text"}]},{"body":" 25(4):275–279.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Backus, John.  1978.  Can programming be liberated from the von\n    Neumann style?  ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications of the ACM","tag":"#text"}]},{"body":" 21(8):613–641.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Baker, Henry G., Jr.  1978.  List processing in real time on a serial\n    computer.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications of the ACM","tag":"#text"}]},{"body":" 21(4):280–293.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and\n    Daniel Weise.  1982.  The Scheme-81 architecture—System and chip.\n    In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of the MIT Conference on Advanced Research in\n      VLSI,","tag":"#text"}]},{"body":" edited by Paul Penfield, Jr. Dedham, MA: Artech House.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Borning, Alan.  1977.  ThingLab—An object-oriented system for\n    building simulations using constraints. In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of the 5th\n      International Joint Conference on Artificial Intelligence.","tag":"#text"}]}]},{"tag":"REFERENCE","child":[{"body":"Borodin, Alan, and Ian Munro.  1975.  ","tag":"#text"},{"tag":"EM","child":[{"body":"The Computational\n      Complexity of Algebraic and Numeric Problems.","tag":"#text"}]},{"body":" New York: American\n    Elsevier.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Chaitin, Gregory J.  1975.  Randomness and mathematical proof.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Scientific American","tag":"#text"}]},{"body":" 232(5):47–52.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Church, Alonzo.  1941.  ","tag":"#text"},{"tag":"EM","child":[{"body":"The Calculi of Lambda-Conversion.","tag":"#text"}]},{"body":"\n    Princeton, N.J.: Princeton University Press.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Clark, Keith L.  1978.  Negation as failure.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Logic and Data\n      Bases.","tag":"#text"}]},{"body":" New York: Plenum Press, pp. 293–322.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Clinger, William.  1982.  Nondeterministic call by need is neither\n    lazy nor by name. In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of the ACM Symposium on Lisp and\n      Functional Programming,","tag":"#text"}]},{"body":" pp. 226–234.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un système\n    de communication homme-machine en français.  Technical report,\n    Groupe d'Intelligence Artificielle, Université d'Aix-Marseille II,\n    Luminy.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.  2022. ","tag":"#text"},{"tag":"EM","child":[{"body":"Introduction to Algorithms.","tag":"#text"}]},{"body":" 4th edition. Cambridge, MA: MIT Press.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Crockford, Douglas.  2008.  ","tag":"#text"},{"tag":"EM","child":[{"body":"JavaScript: The Good Parts.","tag":"#text"}]},{"body":"\n    Sebastopol, CA: O'Reilly Media.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Darlington, John, Peter Henderson, and David Turner.  1982.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Functional Programming and Its Applications.","tag":"#text"}]},{"body":" New York: Cambridge\n    University Press.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Dijkstra, Edsger W. 1968a.  The structure of the \"","tag":"#text"},{"body":"THE","tag":"#text"},{"body":"\"\n    multiprogramming system.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications of the ACM","tag":"#text"}]},{"body":"\n    11(5):341–346.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Dijkstra, Edsger W. 1968b.  Cooperating sequential processes.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Programming Languages","tag":"#text"}]},{"body":", edited by F. Genuys. New York: Academic Press, pp.\n    43–112.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Dinesman, Howard P.  1968.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Superior Mathematical Puzzles","tag":"#text"}]},{"body":".  New\n    York: Simon and Schuster.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"de Kleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.\n    AMORD: Explicit control of reasoning.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of the ACM\n      Symposium on Artificial Intelligence and Programming Languages,","tag":"#text"}]},{"body":" pp.\n    116–125.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Doyle, Jon. 1979. A truth maintenance system. ","tag":"#text"},{"tag":"EM","child":[{"body":"Artificial\n      Intelligence","tag":"#text"}]},{"body":" 12:231–272.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"ECMA.  1997. ECMAScript: A general purpose,\ncross-platform programming\nlanguage. 1st edition, edited by Guy L. Steele Jr.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Ecma International.","tag":"#text"}]}]},{"tag":"REFERENCE","child":[{"body":"ECMA.  2015. ECMAScript: A general purpose, cross-platform programming\nlanguage. 6th edition, edited by Allen Wirfs-Brock.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Ecma International.","tag":"#text"}]}]},{"tag":"REFERENCE","child":[{"body":"ECMA.  2020. ECMAScript: A general purpose, cross-platform programming\nlanguage. 11th edition, edited by Jordan Harband.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Ecma International.","tag":"#text"}]}]},{"tag":"REFERENCE","child":[{"body":"Edwards, A. W. F. 2019. ","tag":"#text"},{"tag":"EM","child":[{"body":"Pascal's Arithmetical Triangle","tag":"#text"}]},{"body":". Mineola, New York: Dover Publications.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Feeley, Marc.  1986.  Deux approches à l'implantation du\n    language Scheme.  Masters thesis, Université de Montréal.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Feeley, Marc and Guy Lapalme.  1987.  Using closures for code\n    generation.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Journal of Computer Languages","tag":"#text"}]},{"body":" 12(1):47–66.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National\n    Fifth Generation Project: Introduction, survey, and evaluation.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Future Generation Computer Systems,","tag":"#text"}]},{"body":" vol. 9, pp. 105–117.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Feller, William.  1957.  ","tag":"#text"},{"tag":"EM","child":[{"body":"An Introduction to Probability Theory\n      and Its Applications,","tag":"#text"}]},{"body":" volume 1. New York: John Wiley &amp; Sons.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Fenichel, R., and J. Yochelson.  1969.  A Lisp garbage collector for\n    virtual memory computer systems.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications of the ACM","tag":"#text"}]},{"body":"\n    12(11):611–612.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Floyd, Robert. 1967. Nondeterministic algorithms. ","tag":"#text"},{"tag":"EM","child":[{"body":"JACM,","tag":"#text"}]},{"body":" 14(4):636–644.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Forbus, Kenneth D., and Johan de Kleer.  1993. ","tag":"#text"},{"tag":"EM","child":[{"body":"Building Problem\n      Solvers.","tag":"#text"}]},{"body":" Cambridge, MA: MIT Press.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Friedman, Daniel P., and David S. Wise.  1976.  CONS should not\n    evaluate its arguments. In ","tag":"#text"},{"tag":"EM","child":[{"body":"Automata, Languages, and Programming:\n      Third International Colloquium,","tag":"#text"}]},{"body":" edited by S. Michaelson and R.\n    Milner, pp. 257–284.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Essentials of Programming Languages.","tag":"#text"}]},{"body":"  Cambridge, MA: MIT\n    Press/McGraw-Hill.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Gabriel, Richard P. 1988.  The Why of ","tag":"#text"},{"tag":"EM","child":[{"body":"Y","tag":"#text"}]},{"body":".  ","tag":"#text"},{"tag":"EM","child":[{"body":"Lisp Pointers","tag":"#text"}]},{"body":"\n    2(2):15–25.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Goldberg, Adele, and David Robson.  1983.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Smalltalk-80: The\n      Language and Its Implementation.","tag":"#text"}]},{"body":" Reading, MA: Addison-Wesley.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Gordon, Michael, Robin Milner, and Christopher Wadsworth.  1979.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Edinburgh LCF.","tag":"#text"}]},{"body":" Lecture Notes in Computer Science, volume 78. New\n    York: Springer-Verlag.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Gray, Jim, and Andreas Reuter. 1993. ","tag":"#text"},{"tag":"EM","child":[{"body":"Transaction Processing:\n      Concepts and Models.","tag":"#text"}]},{"body":" San Mateo, CA: Morgan-Kaufman.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Green, Cordell.  1969.  Application of theorem proving to problem\n    solving.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of the International Joint Conference on\n      Artificial Intelligence,","tag":"#text"}]},{"body":" pp. 219–240.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Green, Cordell, and Bertram Raphael.  1968.  The use of\n    theorem-proving techniques in question-answering systems.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of the ACM National Conference,","tag":"#text"}]},{"body":" pp. 169–181.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Guttag, John V.  1977.  Abstract data types and the development of\n    data structures.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications of the ACM","tag":"#text"}]},{"body":" 20(6):397–404.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hamming, Richard W.  1980.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Coding and Information Theory.","tag":"#text"}]},{"body":"\n    Englewood Cliffs, N.J.: Prentice-Hall.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hanson, Christopher P.  1990.  Efficient stack allocation for\n    tail-recursive languages.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of ACM Conference on\n      Lisp and Functional Programming,","tag":"#text"}]},{"body":" pp. 106–118.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hanson, Christopher P.  1991.  A syntactic closures macro facility.\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Lisp Pointers,","tag":"#text"}]},{"body":" 4(4):9–16.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hardy, Godfrey H.  1921.  Srinivasa Ramanujan.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of\n      the London Mathematical Society","tag":"#text"}]},{"body":" XIX(2).","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hardy, Godfrey H., and E. M. Wright.  1960.  ","tag":"#text"},{"tag":"EM","child":[{"body":"An Introduction to\n      the Theory of Numbers.","tag":"#text"}]},{"body":"  4th edition.  New York: Oxford University\n    Press.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. ","tag":"#text"},{"tag":"EM","child":[{"body":"IBM Systems Journal","tag":"#text"}]},{"body":" 7(2):74–84.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Henderson, Peter. 1980.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Functional Programming: Application and\n      Implementation.","tag":"#text"}]},{"body":" Englewood Cliffs, N.J.: Prentice-Hall.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Henderson. Peter. 1982. Functional Geometry. In ","tag":"#text"},{"tag":"EM","child":[{"body":"Conference Record\n      of the 1982 ACM Symposium on Lisp and Functional Programming,","tag":"#text"}]},{"body":"\n    pp. 179–187.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hewitt, Carl E.  1969.  PLANNER: A language for proving theorems in\n    robots.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of the International Joint Conference on\n      Artificial Intelligence,","tag":"#text"}]},{"body":" pp. 295–301.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hewitt, Carl E.  1977.  Viewing control structures as patterns of\n    passing messages.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Journal of Artificial Intelligence","tag":"#text"}]},{"body":"\n    8(3):323–364.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hoare, C. A. R. 1972.  Proof of correctness of data representations.\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Acta Informatica","tag":"#text"}]},{"body":" 1(1):271–281.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hodges, Andrew. 1983.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Alan Turing: The Enigma.","tag":"#text"}]},{"body":" New York: Simon\n    and Schuster.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hofstadter, Douglas R.  1979.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Gödel, Escher, Bach: An Eternal\n      Golden Braid.","tag":"#text"}]},{"body":" New York: Basic Books.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Hughes, R. J. M.  1990.  Why functional programming matters.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Research Topics in Functional Programming","tag":"#text"}]},{"body":", edited by David Turner.\n    Reading, MA: Addison-Wesley, pp. 17–42.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"IEEE Std 1178-1990.  1990.  ","tag":"#text"},{"tag":"EM","child":[{"body":"IEEE Standard for the Scheme\n      Programming Language.","tag":"#text"}]}]},{"tag":"REFERENCE","child":[{"body":"Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig;\n    assisted by M. Lind, Herbert Kanner, and Robert Floyd.  1960.  THUNKS:\n    A way of compiling procedure statements, with some comments on\n    procedure declarations.  Unpublished manuscript.  (Also, private\n    communication from Wallace Feurzeig.)","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Jaffar, Joxan, and Peter J. Stuckey. 1986. Semantics of infinite tree\n    logic programming. ","tag":"#text"},{"tag":"EM","child":[{"body":"Theoretical Computer Science","tag":"#text"}]},{"body":" 46:141–158.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Kaldewaij, Anne. 1990.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Programming: The Derivation of\n      Algorithms.","tag":"#text"}]},{"body":" New York: Prentice-Hall.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Knuth, Donald E.  1997a.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Fundamental Algorithms.","tag":"#text"}]},{"body":" Volume 1 of\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"The Art of Computer Programming.","tag":"#text"}]},{"body":"  3rd edition. Reading, MA:\n    Addison-Wesley.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Knuth, Donald E.  1997b.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Seminumerical Algorithms.","tag":"#text"}]},{"body":" Volume 2 of\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"The Art of Computer Programming.","tag":"#text"}]},{"body":"  3rd edition. Reading, MA:\n    Addison-Wesley.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Konopasek, Milos, and Sundaresan Jayaraman.  1984.  ","tag":"#text"},{"tag":"EM","child":[{"body":"The TK!Solver\n      Book: A Guide to Problem-Solving in Science, Engineering, Business,\n      and Education.","tag":"#text"}]},{"body":" Berkeley, CA: Osborne/McGraw-Hill.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Kowalski, Robert.  1973.  Predicate logic as a programming language.\n    Technical report 70, Department of Computational Logic, School of\n    Artificial Intelligence, University of Edinburgh.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Kowalski, Robert.  1979.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Logic for Problem Solving.","tag":"#text"}]},{"body":" New York:\n    North-Holland.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Lamport, Leslie. 1978.  Time, clocks, and the ordering of events in a\n    distributed system.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications of the ACM","tag":"#text"}]},{"body":" 21(7):558–565.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Lampson, Butler, J. J. Horning, R.  London, J. G. Mitchell, and G. K.\n    Popek.  1981.  Report on the programming language Euclid.  Technical\n    report, Computer Systems Research Group, University of Toronto.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Landin, Peter.  1965.  A correspondence between Algol 60 and Church's\n    lambda notation: Part I.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications of the ACM","tag":"#text"}]},{"body":"\n    8(2):89–101.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage\n    collector based on the lifetimes of objects. ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications of\n      the ACM","tag":"#text"}]},{"body":" 26(6):419–429.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Liskov, Barbara H., and Stephen N. Zilles.  1975.  Specification\n    techniques for data abstractions.  ","tag":"#text"},{"tag":"EM","child":[{"body":"IEEE Transactions on Software\n      Engineering","tag":"#text"}]},{"body":" 1(1):7–19.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"McAllester, David Allen.  1978.  A three-valued truth-maintenance\n    system.  Memo 473, MIT Artificial Intelligence Laboratory.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"McAllester, David Allen.  1980.  An outlook on truth maintenance.\n    Memo 551, MIT Artificial Intelligence Laboratory.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"McCarthy, John.  1967.  A basis for a mathematical theory of\n    computation.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Computer Programing and Formal Systems","tag":"#text"}]},{"body":", edited\n    by P. Braffort and D. Hirschberg.  North-Holland, pp. 33–70.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"McDermott, Drew, and Gerald Jay Sussman.  1972. Conniver reference\n    manual.  Memo 259, MIT Artificial Intelligence Laboratory.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Miller, Gary L.  1976.  Riemann's Hypothesis and tests for primality.\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Journal of Computer and System Sciences","tag":"#text"}]},{"body":" 13(3):300–317.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Miller, James S., and Guillermo J. Rozas. 1994.  Garbage collection is\n    fast, but a stack is faster.  Memo 1462, MIT Artificial Intelligence\n    Laboratory.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Moon, David.  1978.  MacLisp reference manual, Version 0.  Technical\n    report, MIT Laboratory for Computer Science.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Morris, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience\n    with an applicative string processing language.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings\n      of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of\n      Programming Languages.","tag":"#text"}]}]},{"tag":"REFERENCE","child":[{"body":"Phillips, Hubert.  1934. ","tag":"#text"},{"tag":"EM","child":[{"body":"The Sphinx Problem Book","tag":"#text"}]},{"body":".  London: Faber\n    and Faber.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Phillips, Hubert.  1961. ","tag":"#text"},{"tag":"EM","child":[{"body":"My Best Puzzles in Logic and Reasoning","tag":"#text"}]},{"body":".\n    New York: Dover Publications.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Journal of Number Theory","tag":"#text"}]},{"body":" 12:128–138.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Raymond, Eric.  1996. ","tag":"#text"},{"tag":"EM","child":[{"body":"The New Hacker's Dictionary.","tag":"#text"}]},{"body":" 3rd edition.\n    Cambridge, MA: MIT Press.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Raynal, Michel. 1986. ","tag":"#text"},{"tag":"EM","child":[{"body":"Algorithms for Mutual Exclusion.","tag":"#text"}]},{"body":"\n    Cambridge, MA: MIT Press.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Rees, Jonathan A., and Norman I. Adams IV. 1982.  T: A dialect of Lisp\n    or, lambda: The ultimate software tool.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Conference Record of\n    the 1982 ACM Symposium on Lisp and Functional Programming,","tag":"#text"}]},{"body":" pp.\n    114–122.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Rivest, Ronald L., Adi Shamir, and Leonard M. Adleman. 1978. A method for\n\tobtaining digital signatures and public-key cryptosystems. ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications\n\tof the ACM,","tag":"#text"}]},{"body":" 21(2):120–126.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Robinson, J. A. 1965.  A machine-oriented logic based on the\n    resolution principle.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Journal of the ACM","tag":"#text"}]},{"body":" 12(1):23.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Robinson, J. A. 1983.  Logic programming—Past, present, and future.\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"New Generation Computing","tag":"#text"}]},{"body":" 1:107–124.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Sagade, Y. 2015. ","tag":"#text"},{"tag":"LINK","body":"SICP exercise 1.14","href":"http://www.ysagade.nl/2015/04/12/sicp-change-growth/"}]},{"tag":"REFERENCE","child":[{"body":"Spafford, Eugene H.  1989.  The Internet Worm: Crisis and aftermath.\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Communications of the ACM","tag":"#text"}]},{"body":" 32(6):678–688.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Steele, Guy Lewis, Jr.  1977.  Debunking the \"","tag":"#text"},{"body":"expensive procedure\n      call","tag":"#text"},{"body":"\" myth.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of the National Conference of the\n      ACM,","tag":"#text"}]},{"body":" pp. 153–162.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Steele, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An\n    interpreter for the extended lambda calculus.  Memo 349, MIT\n    Artificial Intelligence Laboratory.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.\n    Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  ","tag":"#text"},{"tag":"EM","child":[{"body":"The Hacker's Dictionary.","tag":"#text"}]},{"body":" New York: Harper \n&amp; Row.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Stoy, Joseph E.  1977.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Denotational Semantics.","tag":"#text"}]},{"body":" Cambridge, MA:\n    MIT Press.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Sussman, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic\n    techniques in computer-aided circuit analysis.  ","tag":"#text"},{"tag":"EM","child":[{"body":"IEEE Transactions\n      on Circuits and Systems","tag":"#text"}]},{"body":" CAS-22(11):857–865.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Sussman, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints—A\n    language for expressing almost-hierarchical descriptions.  ","tag":"#text"},{"tag":"EM","child":[{"body":"AI\n      Journal","tag":"#text"}]},{"body":" 14:1–39.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Sussman, Gerald Jay, and Jack Wisdom.  1992. Chaotic evolution of the\n    solar system.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Science","tag":"#text"}]},{"body":" 257:256–262.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.\n    Microplanner reference manual.  Memo 203A, MIT Artificial Intelligence\n    Laboratory.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Sutherland, Ivan E.  1963.  SKETCHPAD: A man-machine graphical\n    communication system.  Technical report 296, MIT Lincoln Laboratory.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978.\n    Data type specification: Parameterization and the power of\n    specification techniques. In ","tag":"#text"},{"tag":"EM","child":[{"body":"Conference Record of the Tenth Annual ACM\n      Symposium on Theory of Computing","tag":"#text"}]},{"body":", pp. 119–132.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Turner, David.  1981.  The future of applicative languages.  In ","tag":"#text"},{"tag":"EM","child":[{"body":"Proceedings of the 3rd European Conference on Informatics,","tag":"#text"}]},{"body":" Lecture\n    Notes in Computer Science, volume 123. New York: Springer-Verlag, pp.\n    334–348.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Wand, Mitchell.  1980.  Continuation-based program transformation\n    strategies.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Journal of the ACM","tag":"#text"}]},{"body":" 27(1):164–180.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Waters, Richard C.  1979.  A method for analyzing loop programs.  ","tag":"#text"},{"tag":"EM","child":[{"body":"IEEE Transactions on Software Engineering","tag":"#text"}]},{"body":" 5(3):237–247.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Winston, Patrick. 1992. ","tag":"#text"},{"tag":"EM","child":[{"body":"Artificial Intelligence","tag":"#text"}]},{"body":".  3rd edition.\n    Reading, MA: Addison-Wesley.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Zabih, Ramin, David McAllester, and David Chapman.  1987.\n    Non-deterministic Lisp with dependency-directed backtracking.\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"AAAI-87","tag":"#text"}]},{"body":", pp. 59–64.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Zippel, Richard.  1979.  Probabilistic algorithms for sparse\n    polynomials.  Ph.D. dissertation, Department of Electrical Engineering\n    and Computer Science, MIT.","tag":"#text"}]},{"tag":"REFERENCE","child":[{"body":"Zippel, Richard.  1993.  ","tag":"#text"},{"tag":"EM","child":[{"body":"Effective Polynomial Computation.","tag":"#text"}]},{"body":"\n    Boston, MA: Kluwer Academic Publishers.","tag":"#text"}]}]