// do not know why, I can not run yarn test on my device which leads to binding error.
// this file is meant to be temporary


/* todos and issues: 
 propably need to modify the frontend to enable link to snippets
works fine for things like <= (numeric comparison operator), but not for || (logical disjunction); could not test for " (double quote)
did not process the "seexml" file, so no see also in index
did not process the latex, roman, italic, etc.
*/

/*
abs, 14
absolute value, 13
abstract data, 72, see also data abstraction abstraction, see also data abstraction;
higher-order functions; means of
abstraction
common pattern and, 50
functional, 22
metalinguistic, 318
in register-machine design, 456–457 of search in nondeterministic
programming, 378
abstraction barriers, 71, 76–78, 147
in complex-number system, 148
in generic arithmetic system, 164
in query language, 437
in representing JavaScript syntax, 329
abstract models for data, 78 n abstract syntax
in metacircular evaluator, 322
in query interpreter, 425 accelerated_sequence, 297 accumulate, 53 (ex. 1.32), 100
same as fold_right, 105 (ex. 2.38) accumulate_n, 104 (ex. 2.36) accumulator, 100, 196 (ex. 3.1) Ackermann’s function, 31 (ex. 1.10) acquire a mutex, 276
actions, in register machine, 454–455
actual_value, 364
Ada, 411 (ex. 4.61)
Adams, Norman I., IV, 356 n add (generic), 165
used for polynomial coefficients, 179, 180
add_action, 244, 247
add_complex, 150 add_complex_to_javascript_num, 169 addend, 128
adder (primitive constraint), 256 adder
full, 243
half, 242
ripple-carry, 245 (ex. 3.30)
add_interval, 81
additivity, 72, 147, 156–162, 166 add_lists, 371
add_poly, 178
add_rat, 73
address, 488
address arithmetic, 488 add_rule_or_assertion, 434 add_streams, 290
add_terms, 179 add_to_agenda, 248, 251 add_vect, 118 (ex. 2.46) adjoin_arg, 505 n
adjoining to a list with pair, 88 adjoin_set, 131
binary-tree representation, 136 ordered-list representation, 135 (ex.
2.61)
unordered-list representation, 132 for weighted sets, 145
adjoin_term, 179, 182
Adleman, Leonard, 46 n
administrative assistant, importance of,
403 advance_pc, 479
after_delay, 244, 248
agenda, see digital-circuit simulation A’h-mose, 40 n
algebra, symbolic, see symbolic algebra algebraic expression, 176
differentiating, 126–131 representing, 128–131 simplifying, 129–130
algebraic specification for data, 79 n
Algol
block structure, 26
call-by-name argument passing, 286 n,
363 n
thunks, 286 n, 363 n
algorithm
optimal, 104 n probabilistic, 45–46, 188 n
aliasing, 204 n
Al-Karaji, 36 n
Allen, John, 494 n all_regs (compiler), 542 n alternative
of conditional expression, 14
of conditional statement, 57 always_true, 428
amb, 374
amb evaluator, see nondeterministic
evaluator ambeval, 388
analog computer, 306 (fig. 3.34)
analyze
metacircular, 356
nondeterministic, 387
analyze_...
metacircular, 356–359, 360 (ex. 4.21)
nondeterministic, 389–392 analyze_amb, 394
analyzing evaluator, 355–360
as basis for nondeterministic evaluator, 386
and (query language), 405
evaluation of, 413, 426, 446 (ex. 4.73)
and-gate, 241 and_gate, 245
an_element_of, 375 angle
data-directed, 160
polar representation, 152 rectangular representation, 151 with tagged data, 154
angle_polar, 154 angle_rectangular, 153 an_integer_starting_from, 375 Appel, Andrew W., 541 n
append, 88, 225 (ex. 3.12)
as accumulation, 103 (ex. 2.33) append_mutator vs., 225 (ex. 3.12) as register machine, 492 (ex. 5.21) “what is” (rules) vs. “how to”
(function), 399–400
append_instruction_sequences, 524, 544
append_mutator, 225 (ex. 3.12)
as register machine, 492 (ex. 5.21)
append_to_form (rules), 410 applicative-order evaluation, 13
in JavaScript, 13
normal order vs., 17 (ex. 1.5), 43 (ex.
1.20), 361–362 apply (lazy), 364
apply (metacircular), 324 tail recursion and, 324 n
apply (primitive method), 346 n apply_a_rule, 430 apply_dispatch, 507
modified for compiled code, 558 apply_generic, 160
with coercion, 171, 174 (ex. 2.81)
with coercion by raising, 175 (ex. 2.84) with coercion of multiple arguments,
175 (ex. 2.82)
with coercion to simplify, 176 (ex.
2.85)
with message passing, 163 with tower of types, 173
apply_in_underlying_javascript, 159 n, 346 n
apply_primitive_function, 324, 340, 346
apply_rules, 430 arbiter, 278 n arctangent, 151 n arg_expressions, 331 argl register, 500 argument(s), 9
arbitrary number of, 276
delayed, 306
argument passing, see call-by-name
argument passing; call-by-need
argument passing Aristotle’s De caelo (Buridan’s
commentary on), 278 n arithmetic
address arithmetic, 488 generic, 163, see also generic
arithmetic operations
on complex numbers, 148
on intervals, 81–84
on polynomials, see polynomial
arithmetic
on power series, 294 (ex. 3.60), 295
(ex. 3.62)
on rational numbers, 72–76
operators for, 4
array, see vector (data structure) arrow function, see lambda expression articles, 381
ASCII code, 140
assemble, 474, 475 n
assembler, 470, 474–477
assert (query interpreter), 419 assertion, 401
implicit, 407 assertion_body, 443
assign (in register machine), 453
instruction constructor, 478 simulating, 478
storing label in register, 459
assignment, 190–206
assignment expression, 192 assignment operation, 190
benefits of, 197–200
bugs associated with, 204 n, 205 constant/variable declaration vs., 192 n costs of, 200–206
equality test vs., 192 n
evaluation of, 210
parsing of, 333
value of, 192 n
assignment_symbol, 333 assignment_value_expression, 333 assign_reg_name, 478 assign_symbol_value, 341, 342 assign_value_exp, 478
assoc, 236 associativity
of conditional expression, 14
of operators, 5
atomic operations supported in hardware,
278 n
atomic requirement for test_and_set, 277 attach_tag, 152
using JavaScript data types, 168 (ex. 2.78)
augend, 128
automagically, 376
automatic search, 373, see also search
history of, 376 n
automatic storage allocation, 487 average, 19
average_damp, 63
average damping, 61
averager (constraint), 261 (ex. 3.33)
*/

// I include 2 out of the 5 columns of all the index with A here.

// manually tested the exercise urls to accumulate and accumulate_n, they are correct
import { indexTrie, search, getUrl, autoComplete } from "./searchRewrite"
import fs from "fs";

const indexSearchTestCase = {
   "abs": 1,
   "absolute value": 1,
    "abstract data": 1,
    "abstraction": 6,
    "abstraction barriers": 8,
    "abstract models for data": 1,
    "abstract syntax": 2,
    "accelerated_sequence": 1,
    "accumulate": 3,
    "accumulate_n": 1,
    "accumulator": 2,
    "Ackermann's function": 1,
    "acquire a mutex": 1,
    "actions, in register machine": 2,
    "actual_value": 1,
    "Ada": 1,
    "Adams, Norman I., IV": 1,
    "add (generic)": 1,
    "add_action": 2,
    "add_complex": 1,
    "add_complex_to_javascript_num": 1,
    "addend": 1,
    "adder (primitive constraint)": 1,
    "adder": 3,
    "add_interval": 1,
    "additivity": 5,
    "add_lists": 1,
    "add_poly": 1,
    "add_rat": 1,
    "address": 1,
    "address arithmetic": 1,
    "add_rule_or_assertion": 1,
    "add_streams": 1,
    "add_terms": 1,
    "add_to_agenda": 2,
    "add_vect": 1,
    "adjoin_arg": 1,
    "adjoining to a list with pair": 1,
    "adjoin_set": 5,
    "adjoin_term": 2,
    "Adleman, Leonard": 1,
    "administrative assistant, importance of": 1,
    "advance_pc": 1,
    "after_delay": 2,
    "A'h-mose": 1,
    "algebraic expression": 7,
    "algebraic specification for data": 1,
}

const failedTests = [];
const urls = {};
const writeFailureMessage = (key, searchResult) => {
    failedTests.push(`${key}: result is ${searchResult}, expected occuer number is: ${indexSearchTestCase[key]}`);
}

export async function testIndexSearch() {
    for (const [key, value] of Object.entries(indexSearchTestCase)) {
        const result = search(key, indexTrie);
        //console.log(result);
        if (result === null) {
            writeFailureMessage(key, "null");
            continue;
        }
        
        urls[key] = result.map(getUrl);

        if (result.length < value) {
            writeFailureMessage(key, result.length);
            continue;
        }  
    }
    
    console.log(autoComplete("||", indexTrie));
    console.log(search("|| (logical disjunction)", indexTrie));

    async function testURLs() {
        console.log("Testing urls");
        for (const [key, urlArray] of Object.entries(urls)) {
            for (const url of urlArray) {
                try {
                  const response = await fetch(url);
            
                  if (!response.ok) {
                    console.log(key + ": " + url + " is not working");
                  }
      
                } catch (error) {
                  console.error(key + ": " + url + " is not working");
                }
              }
        }
        console.log("Done testing urls");       
    }
      
    await testURLs();

    fs.writeFileSync("failedTests.txt", failedTests.join("\n"));
    fs.writeFileSync("urls.txt", JSON.stringify(urls));
}

