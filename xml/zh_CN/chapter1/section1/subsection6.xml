<SUBSECTION>
   <NAME>
    条件表达式和谓词
  </NAME> 
  <LABEL NAME="sec:conditionals"></LABEL>

  <TEXT> 
    我们此时可以定义的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    类的表达能力非常有限，因为我们无法进行测试，也无法根据测试结果执行不同的操作。
     <SPLIT>
      <SCHEME>
        For instance, we cannot define a procedure that computes the 
        <INDEX>absolute value</INDEX>
        absolute
        value of a number by testing whether the number is positive, negative,
        or zero and taking different actions in the different cases according
        to the rule
        <LATEX>
      \[\begin{array}{lll}
          |x| &amp; = &amp; \left\{ \begin{array}{rl}
          x   &amp; \mbox{if $x&gt;0$} \\
          0   &amp; \mbox{if $x=0$} \\
          -x  &amp; \mbox{if $x&lt;0$}
          \end{array}
          \right.
      \end{array}\]
        </LATEX>
        This construct is called a
        <INDEX>case analysis<SUBINDEX>general</SUBINDEX></INDEX>
	<EM>case analysis</EM>, and
        there is a special form in Lisp for notating such a case
        analysis.  It is called 
        <INDEX><DECLARATION>cond</DECLARATION></INDEX> 
        <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>cond</ORDER><SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX>conditional expression<SUBINDEX><ORDER>cond</ORDER><SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
        <SCHEMEINLINE>cond</SCHEMEINLINE> (which stands for
        <QUOTE>conditional</QUOTE>), and it is used as follows:
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX> 
          <NAME>abs_definition</NAME>
          <EXAMPLE>abs_example</EXAMPLE>
          <SCHEME>
(define (abs x)
  (cond ((&gt; x 0) x)
        ((= x 0) 0)
        ((&lt; x 0) (- x))))
          </SCHEME>
        </SNIPPET>
        <SNIPPET EVAL="no">
          <NAME>abs_example</NAME>
          <SCHEME>
(abs (- 5))
          </SCHEME>
        </SNIPPET>
        The general form of a conditional expression is
        <SNIPPET EVAL="no" LATEX="yes">
          <SCHEME>
(cond ($\langle p_1 \rangle $ $\langle e_1 \rangle$)
      ($\langle p_2 \rangle $ $\langle e_2 \rangle$)
      $\vdots$
      ($\langle p_n \rangle $ $\langle e_n \rangle$))
          </SCHEME>
        </SNIPPET>
        consisting of the symbol <SCHEMEINLINE>cond</SCHEMEINLINE> followed by
        <INDEX>parentheses<SUBINDEX><ORDER>delimiting cond</ORDER>delimiting <SCHEMEINLINE>cond</SCHEMEINLINE> clauses</SUBINDEX></INDEX>
        parenthesized pairs of expressions
	<SCHEMEINLINE>(</SCHEMEINLINE><LATEXINLINE>$\langle p\ e \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE>
        called 
        <INDEX>clause, of a <SCHEMEINLINE>cond</SCHEMEINLINE></INDEX>
        <INDEX><DECLARATION>cond</DECLARATION><SUBINDEX>clause</SUBINDEX></INDEX>
        <EM>clauses</EM>. The first expression in each pair is a 
        <INDEX>predicate<SUBINDEX><ORDER>cond</ORDER>of <SCHEMEINLINE>cond</SCHEMEINLINE> clause</SUBINDEX></INDEX>
	<INDEX>conditional expression<SUBINDEX>predicate, consequent, alternative of</SUBINDEX></INDEX>
        <EM>predicate</EM><EMDASH></EMDASH>that is, an expression whose value is
	interpreted as either true or false.<FOOTNOTE>
        <QUOTE>Interpreted as either
        <INDEX>true</INDEX>
	<INDEX>false</INDEX>
        <INDEX><DECLARATION>\#t</DECLARATION></INDEX>
	<INDEX><DECLARATION>true</DECLARATION></INDEX>
        <INDEX><DECLARATION>\#f</DECLARATION></INDEX>
	<INDEX><DECLARATION>false</DECLARATION></INDEX> 
	true or false</QUOTE>
        means this: In Scheme, there are two distinguished values that are
        denoted by the constants 
        <SCHEMEINLINE>#t</SCHEMEINLINE> and <SCHEMEINLINE>#f</SCHEMEINLINE>.  
        When the interpreter checks a predicate<APOS></APOS>s value, it interprets 
        <SCHEMEINLINE>#f</SCHEMEINLINE> as false.  Any other value
        is treated as true.  (Thus, providing <SCHEMEINLINE>#t</SCHEMEINLINE>
	is logically unnecessary, but it is convenient.)  In this book we will
	use names <SCHEMEINLINE>true</SCHEMEINLINE> and
	<SCHEMEINLINE>false</SCHEMEINLINE>, 
        which are associated with the values <SCHEMEINLINE>#t</SCHEMEINLINE> and 
        <SCHEMEINLINE>#f</SCHEMEINLINE> respectively.</FOOTNOTE>
      </SCHEME>
       <JAVASCRIPT>
	<COMMENT>
	  我们这里从条件表达式开始，因为它们更适合替换模型。注意第1.1.1节到第1.1.7节中的所有函数体都只有一个返回语句，这强调了条件表达式。条件语句将在第1.3.2节介绍。
	</COMMENT>
        例如，我们不能通过测试数字是否非负数，并根据规则对每种情况采取不同的操作来声明一个计算数字
        <INDEX>绝对值</INDEX>
        绝对值的函数，
        <LATEX>
      \[\begin{array}{lll}
          |x| &amp; = &amp; \left\{ \begin{array}{rl}
          x   &amp; \mbox{如果 $x \geq 0$} \\
          -x  &amp; \mbox{否则}
          \end{array}
          \right.
      \end{array}\]
        </LATEX>
	<COMMENT>
	  我们简化这个例子，这样只需一个条件表达式就够了。
	</COMMENT>
        这个结构是一个
	<INDEX>情况分析</INDEX>
	<EM>情况分析</EM>，可以用JavaScript中的
	<EM>条件表达式</EM>写成
        <SNIPPET>
	  <INDEX><DECLARATION>abs</DECLARATION></INDEX>
          <NAME>abs_definition</NAME>
          <EXAMPLE>abs_example</EXAMPLE>
          <JAVASCRIPT>
function abs(x) {
    return x &gt;= 0 ? x : - x;
}
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <NAME>abs_example</NAME>
	  <REQUIRES>abs_definition</REQUIRES>
	  <EXPECTED>5</EXPECTED>
          <JAVASCRIPT>
abs(-5);
          </JAVASCRIPT>
        </SNIPPET>
	用英语可以表达为<QUOTE>如果 <LATEXINLINE>$x$</LATEXINLINE> 大于等于零，则返回<SPACE></SPACE><LATEXINLINE>$x$</LATEXINLINE>；否则返回 <LATEXINLINE>$- x$</LATEXINLINE>。</QUOTE>
        条件表达式的一般形式是
        <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
<META>谓词</META> ? <META>结果表达式</META> : <META>备选表达式</META>
          </JAVASCRIPT>
        </SNIPPET>
        条件
	<INDEX>条件表达式</INDEX>
	<INDEX>语法形式<SUBINDEX>条件表达式</SUBINDEX></INDEX>
	<INDEX><JAVASCRIPTINLINE>?</JAVASCRIPTINLINE><SPACE></SPACE><JAVASCRIPTINLINE>:</JAVASCRIPTINLINE><ORDER>;3</ORDER></INDEX>
	<INDEX>谓词<SUBINDEX><ORDER>条件表达式之条件</ORDER></SUBINDEX></INDEX>
	<INDEX><ORDER>true</ORDER><USE>true</USE>（关键字）</INDEX>
	<INDEX><ORDER>false</ORDER><USE>false</USE>（关键字）</INDEX>
	<INDEX>关键字<SUBINDEX><ORDER>true</ORDER><USE>true</USE></SUBINDEX></INDEX>
	<INDEX>关键字<SUBINDEX><ORDER>false</ORDER><USE>false</USE></SUBINDEX></INDEX>
	<INDEX>表达式<SUBINDEX>原始布尔型</SUBINDEX></INDEX>
	<INDEX>布尔值（true, false）</INDEX>
	表达式以
        <META>谓词</META><EMDASH></EMDASH>即一个值为
	<EM>true</EM> 或 <EM>false</EM>的表达式开始，这是JavaScript中的
	两个区分的<EM>布尔</EM>值。
	原始布尔表达式
	<JAVASCRIPTINLINE>true</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>false</JAVASCRIPTINLINE> 分别简单地求值为布尔值true和false。
	<META>谓词</META>
        后接问号，
        <META>结果表达式</META>，
        冒号，最后是
        <META>备选表达式</META>。
      </JAVASCRIPT>
     </SPLIT>
  </TEXT>
   <SPLIT>
    <SCHEME>
      <TEXT>
        条件表达式的
        <INDEX><DECLARATION>cond</DECLARATION><SUBINDEX>求值</SUBINDEX></INDEX>
        <INDEX>求值<SUBINDEX><ORDER>cond 的求值</ORDER>的 <SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
	评估过程如下。先对谓词
        <LATEXINLINE>$\langle p_1 \rangle$</LATEXINLINE>进行求值。
	如果其值为 false，则对
        <LATEXINLINE>$\langle p_2 \rangle$</LATEXINLINE> 进行求值。
        如果&lt; LATEXINLINE&gt;$\langle p_2 \rangle$&lt;/LATEXINLINE&gt; 的值也为 false，则对
        <LATEXINLINE>$\langle p_3 \rangle$</LATEXINLINE>进行求值。
        该过程会持续，直到找到一个其值为 true 的谓词，届时解释器返回该子句对应的
        <INDEX>后续项<SUBINDEX><ORDER>cond</ORDER>的 <SCHEMEINLINE>cond</SCHEMEINLINE> 子句</SUBINDEX></INDEX>
        <EM>后续表达式</EM>
	<LATEXINLINE>$\langle e \rangle$</LATEXINLINE>的值作为条件表达式的值。如果没有任何
        <LATEXINLINE>$\langle p \rangle$</LATEXINLINE> 的值为 true，则该
        <SCHEMEINLINE>cond</SCHEMEINLINE> 的值未定义。
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <TEXT>
        要
	<INDEX>求值<SUBINDEX>条件表达式求值</SUBINDEX></INDEX>
	<INDEX>条件表达式<SUBINDEX>求值</SUBINDEX></INDEX>
	对条件表达式求值，
	解释器先对表达式的
        <META>谓词</META>
        进行求值。如果该
	<META>谓词</META>
        的值为 true，则解释器对
        <INDEX>后续项<SUBINDEX><ORDER>条件表达式</ORDER>的条件表达式的后续项</SUBINDEX></INDEX>
        <META>后续表达式</META>求值，并返回其值作为条件表达式的值。
        如果该
	<META>谓词</META>
	的值为 false，则解释器求值
        <INDEX>备选项<SUBINDEX><ORDER>条件表达式</ORDER>的条件表达式的备选项</SUBINDEX></INDEX>
        <META>备选表达式</META>，并返回其值作为该条件表达式的值。<FOOTNOTE>
	<INDEX>条件表达式<SUBINDEX>非布尔值谓词</SUBINDEX></INDEX>
	在完整的 JavaScript 中，条件表达式接受任何值，而不仅仅是布尔值，作为求值谓词的结果（详见第<SPACE></SPACE><REF NAME="foot:truthy"></REF>注释，
	以及第<SPACE></SPACE><REF NAME="sec:eval-data-structures"></REF>节）。本书中的程序仅使用布尔值作为条件表达式的谓词。
      </FOOTNOTE>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT> 
   <SPLIT>
    <SCHEME>
      <TEXT>
        术语
        <INDEX>谓词</INDEX>
	<EM>谓词</EM>用于表示返回true或false的过程，也用于表示求值为true或false的表达式。
	取绝对值的过程<SCHEMEINLINE>abs</SCHEMEINLINE>使用了
        <INDEX><USE>&gt;</USE>（原始数字比较谓词）</INDEX>   
        <INDEX><USE>&lt;</USE>（原始数字比较谓词）</INDEX>   
        <INDEX><USE>=</USE>（原始数字相等谓词）</INDEX>   
        <INDEX><USE>原始过程（标记为<EM>ns</EM>的非IEEE Scheme标准）</USE><SUBINDEX><ORDER>&gt;</ORDER><SCHEMEINLINE>&gt;</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX><USE>原始过程（标记为<EM>ns</EM>的非IEEE Scheme标准）</USE><SUBINDEX><ORDER>&lt;</ORDER><SCHEMEINLINE>&lt;</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX><USE>原始过程（标记为<EM>ns</EM>的非IEEE Scheme标准）</USE><SUBINDEX><ORDER>=</ORDER><SCHEMEINLINE>=</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX>数字<SUBINDEX>比较</SUBINDEX></INDEX>
        <INDEX>数字<SUBINDEX>相等比较</SUBINDEX></INDEX>
        <INDEX>相等<SUBINDEX><ORDER>数值</ORDER>数值的相等</SUBINDEX></INDEX>
        原始谓词<SCHEMEINLINE>&gt;</SCHEMEINLINE>、 
        <SCHEMEINLINE>&lt;</SCHEMEINLINE> 以及 
        <SCHEMEINLINE>=</SCHEMEINLINE>。<FOOTNOTE>
	<SCHEMEINLINE>abs</SCHEMEINLINE>还使用了
        <INDEX><USE>-</USE>（原始减法过程）<SUBINDEX>作为取负</SUBINDEX></INDEX>
        <INDEX><USE>原始过程（标记为<EM>ns</EM>的非IEEE Scheme标准）</USE><SUBINDEX><ORDER>-</ORDER><SCHEMEINLINE>-</SCHEMEINLINE></SUBINDEX></INDEX>
        <QUOTE>减号</QUOTE>操作符<SCHEMEINLINE>-</SCHEMEINLINE>，当仅有一个操作数时，如<SCHEMEINLINE>(- x)</SCHEMEINLINE>，表示取负值。</FOOTNOTE>
        这些谓词接受两个数字作为参数，测试第一个数字是否分别大于、小于或等于第二个数字，并相应地返回true或false。
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <TEXT>
        术语
        <INDEX>谓词</INDEX>
	<EM>谓词</EM>用于返回true或false的操作符和函数，也用于求值为true或false的表达式。取绝对值函数
	<JAVASCRIPTINLINE>abs</JAVASCRIPTINLINE>使用了
	<INDEX><USE>&gt;=</USE>（数字比较操作符）</INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>&gt;=</USE>（数字比较）</SUBINDEX><FRAGILE></FRAGILE></INDEX>
        <INDEX>数字<SUBINDEX>比较</SUBINDEX></INDEX>
        <INDEX>数字<SUBINDEX>相等比较</SUBINDEX></INDEX>
        原始谓词<JAVASCRIPTINLINE>&gt;=</JAVASCRIPTINLINE>，
	该操作符接受两个数字作为参数，测试第一个数字是否大于或等于第二个数字，并相应地返回true或false。
      </TEXT>
    </JAVASCRIPT>
  </SPLIT> 
   <SPLIT>
    <SCHEME>
      <TEXT>
        写出取绝对值过程的另一种方式是
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX> 
          <EXAMPLE>abs_example</EXAMPLE>
          <SCHEME>
(define (abs x)
  (cond ((&lt; x 0) (- x))
    (else x)))
          </SCHEME>
        </SNIPPET>
        它可以用英语描述为 
        <QUOTE>如果 <LATEXINLINE>$x$</LATEXINLINE> 小于零
        返回 <LATEXINLINE>$- x$</LATEXINLINE>；否则返回 
        <LATEXINLINE>$x$</LATEXINLINE>。</QUOTE>  
        <INDEX><DECLARATION>else</DECLARATION>（<SCHEMEINLINE>cond</SCHEMEINLINE>中的特殊符号）</INDEX>
        <SCHEMEINLINE>Else</SCHEMEINLINE> 是一个特殊符号，可以替代
	<LATEXINLINE>$\langle p \rangle$</LATEXINLINE> 用于
	<SCHEMEINLINE>cond</SCHEMEINLINE> 的最后一个子句。  
        这使得 <SCHEMEINLINE>cond</SCHEMEINLINE> 当所有先前的子句都被跳过时，
	返回对应的
	<LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 的值。实际上，任何
	总是求值为true的表达式都可以用作此处的
	<LATEXINLINE>$\langle p \rangle$</LATEXINLINE>。
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
    </JAVASCRIPT>
  </SPLIT> 
  <SPLIT>
    <SCHEME>
      <TEXT>
        Here is yet another way to write the absolute-value procedure:
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX> 
          <EXAMPLE>abs_example</EXAMPLE>
          <SCHEME>
(define (abs x)
  (if (&lt; x 0)
    (- x)
    x))
          </SCHEME>
        </SNIPPET>
        <INDEX>conditional expression<SUBINDEX><ORDER>if</ORDER><SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        This uses the
        <INDEX><DECLARATION>if</DECLARATION></INDEX>
        <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>if</ORDER><SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
	special form <SCHEMEINLINE>if</SCHEMEINLINE>, a restricted 
        type of conditional that can be used when there are precisely 
        <INDEX>case analysis<SUBINDEX><ORDER>two</ORDER>with two cases (<SCHEMEINLINE>if</SCHEMEINLINE>)</SUBINDEX></INDEX>
        two cases in the case
        analysis.  The general form of an <SCHEMEINLINE>if</SCHEMEINLINE>
	expression is
        <SNIPPET EVAL="no" LATEX="yes">
          <SCHEME>
(if $\langle \textit{predicate} \rangle$ $\langle \textit{consequent}\rangle$ $\langle \textit{alternative}\rangle$)
          </SCHEME>
        </SNIPPET>
        To
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
        <INDEX>evaluation<SUBINDEX><ORDER>of if</ORDER>of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX>predicate, consequent, and alternative of</SUBINDEX></INDEX>
	evaluate an <SCHEMEINLINE>if</SCHEMEINLINE> expression, 
        the interpreter starts by evaluating the 
        <INDEX>predicate<SUBINDEX><ORDER>if</ORDER>of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        <LATEXINLINE>$\langle \textit{predicate}\rangle$</LATEXINLINE> 
        part of the expression.  
        If the <LATEXINLINE>$\langle \textit{predicate}\rangle$</LATEXINLINE> 
        evaluates to a true value, the interpreter then evaluates the 
        <INDEX>consequent<SUBINDEX><ORDER>if</ORDER>of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        <LATEXINLINE>$\langle \textit{consequent}\rangle$</LATEXINLINE> 
        and returns its value.  Otherwise it evaluates the 
        <INDEX>alternative of <SCHEMEINLINE>if</SCHEMEINLINE></INDEX>
        <LATEXINLINE>$\langle \textit{alternative}\rangle$</LATEXINLINE> 
        and returns its value.<FOOTNOTE>A minor 
        difference
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX><ORDER>cond</ORDER><SCHEMEINLINE>cond</SCHEMEINLINE> vs.</SUBINDEX></INDEX>
        <INDEX><DECLARATION>cond</DECLARATION><SUBINDEX><ORDER>if</ORDER><SCHEMEINLINE>if</SCHEMEINLINE> vs.</SUBINDEX></INDEX>
        <INDEX>sequence of expressions<SUBINDEX>in consequent of <SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
	between <SCHEMEINLINE>if</SCHEMEINLINE> and 
        <SCHEMEINLINE>cond</SCHEMEINLINE> is that the
        <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
        part of each <SCHEMEINLINE>cond</SCHEMEINLINE> 
        clause may be a sequence of expressions.
        If the corresponding <LATEXINLINE>$\langle p \rangle$</LATEXINLINE> 
        is found to be true, 
        the expressions 
        <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
        are evaluated in sequence and the value of the final
        expression in the sequence is returned as the value of the 
        <SCHEMEINLINE>cond</SCHEMEINLINE>.
        In an <SCHEMEINLINE>if</SCHEMEINLINE> expression, however, 
        the <LATEXINLINE>$\langle \textit{consequent}\rangle$</LATEXINLINE> and
        <LATEXINLINE>$\langle \textit{alternative}\rangle$</LATEXINLINE> must
	be single expressions.<LABEL NAME="foot:cond-consequent"></LABEL></FOOTNOTE>
      </TEXT>
    </SCHEME>
     <JAVASCRIPT>
      <LONG_PAGE LINES="1"></LONG_PAGE>
      <TEXT>
      如果我们想单独处理零的情况，我们可以通过书写计算一个数的绝对值的函数来指定它
        <LATEX>
      \[\begin{array}{lll}
          |x| &amp;=&amp; \left\{ \begin{array}{rl}
          x   &amp; \mbox{如果 $x &gt; 0$} \\
          0   &amp; \mbox{如果 $x = 0$} \\
          -x  &amp; \mbox{否则}
          \end{array}
          \right.
          \end{array}\]
        </LATEX>
	在 JavaScript 中，我们通过将条件表达式作为其他条件表达式中的备选表达式嵌套，
	来表示多分支的条件分析：
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX>
          <EXAMPLE>abs_example</EXAMPLE>
          <JAVASCRIPT>
function abs(x) {
    return x &gt; 0
           ? x
           : x === 0
           ? 0
           : - x;
}
	  </JAVASCRIPT>
        </SNIPPET>
	备选表达式
	<JAVASCRIPTINLINE>x === 0 ? 0 : - x</JAVASCRIPTINLINE> 不需要加括号，因为条件表达式的语法形式
	<INDEX>条件表达式<SUBINDEX><ORDER>条件表达式的备选表达式</ORDER></SUBINDEX></INDEX>
	<INDEX>结合性<SUBINDEX><ORDER>条件表达式的结合性</ORDER></SUBINDEX></INDEX>
	<INDEX>条件表达式<SUBINDEX>右结合性</SUBINDEX></INDEX>
	<INDEX>右结合</INDEX>
	是右结合的。
	解释器忽略此处为可读性而插入的空格和换行，
	使得
	<JAVASCRIPTINLINE>?</JAVASCRIPTINLINE><APOS></APOS>和<JAVASCRIPTINLINE>:</JAVASCRIPTINLINE><APOS></APOS>对齐于多分支条件的第一个判断条件之下。
	多分支条件的一般形式是
  <DO_BREAK_PAGE></DO_BREAK_PAGE>
	<SNIPPET LATEX="yes" EVAL="no">
	  <JAVASCRIPT>
<META>p</META>$_1$
? <META>e</META>$_1$
: <META>p</META>$_2$
? <META>e</META>$_2$
$\vdots$
: <META>p</META>$_n$
? <META>e</META>$_n$
: <META>最终备选表达式</META>
	  </JAVASCRIPT>
	</SNIPPET>
	我们称判断条件 <LATEXINLINE>$p_i$</LATEXINLINE> 及其对应表达式 
	<LATEXINLINE>$e_i$</LATEXINLINE>
	为多分支条件的
	<INDEX>子句</INDEX>。
	多分支条件可以视为一系列子句，后跟一个最终备选表达式。
	<INDEX>多分支条件<SUBINDEX><ORDER>作为子句序列</ORDER></SUBINDEX></INDEX>
	根据条件表达式的求值规则，
	多分支条件首先求值判断条件 
	<META>p</META><LATEXINLINE>$_1$</LATEXINLINE>。
	如果其值为假，则继续求值
	<META>p</META><LATEXINLINE>$_2$</LATEXINLINE>。
	如果 
	<META>p</META><LATEXINLINE>$_2$</LATEXINLINE> 的值也为假，
	则继续求值 
	<META>p</META><LATEXINLINE>$_3$</LATEXINLINE>。
	如此继续，直到找到一个值为真的判断条件，
	此时解释器返回对应子句的
	<INDEX>结论表达式</INDEX>
	<META>e</META> 的值作为多分支条件的值。
	若所有 
	<META>p</META> 判断条件都为假，多分支条件的值即为最终备选表达式的值。
      </TEXT>
    </JAVASCRIPT>
   </SPLIT>
  <SPLIT>
    <SCHEME>
      <TEXT>
        In addition to primitive predicates such as
	<SCHEMEINLINE>&lt;</SCHEMEINLINE>,
	<SCHEMEINLINE>=</SCHEMEINLINE>, and <SCHEMEINLINE>&gt;</SCHEMEINLINE>,
	there are logical composition operations, which enable us to construct
	compound predicates.  The three most frequently used are these:
        <UL>
          <LI>
            <INDEX><DECLARATION>and</DECLARATION></INDEX> 
            <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>and</ORDER><SCHEMEINLINE>and</SCHEMEINLINE></SUBINDEX></INDEX>
            <INDEX><DECLARATION>and</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
            <INDEX>evaluation<SUBINDEX><ORDER>of and</ORDER>of <SCHEMEINLINE>and</SCHEMEINLINE></SUBINDEX></INDEX>
	    <SCHEMEINLINE>(and</SCHEMEINLINE>
	    <LATEXINLINE>$\langle e_1\rangle \ldots \langle e_n \rangle$
	    </LATEXINLINE>
	    <SCHEMEINLINE>)</SCHEMEINLINE><BR></BR>
            The interpreter evaluates the expressions
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> one at a time, 
            in left-to-right order.  If any
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> evaluates to false, 
            the value of the <SCHEMEINLINE>and</SCHEMEINLINE> expression is
	    false, and the rest of the
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS></APOS>s 
            are not evaluated. If all
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS></APOS>s
	    evaluate to true values, the value of the
	    <SCHEMEINLINE>and</SCHEMEINLINE>
            expression is the value of the last one.
          </LI>
          <LI>
            <INDEX><DECLARATION>or</DECLARATION></INDEX> 
            <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>or</ORDER><SCHEMEINLINE>or</SCHEMEINLINE></SUBINDEX></INDEX>
            <INDEX><DECLARATION>or</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
            <INDEX>evaluation<SUBINDEX><ORDER>of or</ORDER>of <SCHEMEINLINE>or</SCHEMEINLINE></SUBINDEX></INDEX>
            <SCHEMEINLINE>(or</SCHEMEINLINE> <LATEXINLINE>$\langle e_1 \rangle\ldots \langle e_n \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE><BR></BR>
            The interpreter evaluates the expressions 
            <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> one at a time, in
	    left-to-right order.  If any
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE>
	    evaluates to a true value, that value is returned as the value of the
	    <SCHEMEINLINE>or</SCHEMEINLINE> expression, and the rest of the
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS></APOS>s are not
	    evaluated. If all
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS></APOS>s
	    evaluate to false, the value of the
	    <SCHEMEINLINE>or</SCHEMEINLINE> expression is false.
          </LI>
          <LI>
            <INDEX><DECLARATION>not</DECLARATION></INDEX> 
            <INDEX><DECLARATION>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>not</ORDER><SCHEMEINLINE>not</SCHEMEINLINE></SUBINDEX></INDEX>
            <SCHEMEINLINE>(not</SCHEMEINLINE>
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><SCHEMEINLINE>)
	    </SCHEMEINLINE><BR></BR>
            The value of a <SCHEMEINLINE>not</SCHEMEINLINE> expression is true
            when the expression <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
            evaluates to false, and false otherwise.
          </LI>
        </UL>
        <INDEX><DECLARATION>and</DECLARATION><SUBINDEX>why a special form</SUBINDEX></INDEX>
        <INDEX><DECLARATION>or</DECLARATION><SUBINDEX>why a special form</SUBINDEX></INDEX>
        Notice that <SCHEMEINLINE>and</SCHEMEINLINE> and
	<SCHEMEINLINE>or</SCHEMEINLINE> are special forms, not procedures,
        because the subexpressions are not necessarily all evaluated.
        <SCHEMEINLINE>Not</SCHEMEINLINE> is an ordinary procedure.
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <LONG_PAGE LINES="1"></LONG_PAGE>
      <TEXT> 
        除了原始谓词，比如
	<INDEX><USE>&gt;</USE>（数字比较运算符）</INDEX>
        <INDEX><ORDER>&gt;=0</ORDER><JAVASCRIPTINLINE>&lt;</JAVASCRIPTINLINE>（数字比较运算符）</INDEX> 
	<INDEX><ORDER>&gt;=1</ORDER><JAVASCRIPTINLINE>&lt;=</JAVASCRIPTINLINE>（数字比较运算符）</INDEX>
	<INDEX><USE>===</USE><SUBINDEX><ORDER>数字</ORDER>作为数字相等运算符</SUBINDEX></INDEX>
	<INDEX><USE>&quot;!==</USE><ORDER>;4</ORDER><SUBINDEX>作为数字比较运算符<ORDER>数字</ORDER></SUBINDEX></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>&gt;</USE>（数字比较）</SUBINDEX></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><ORDER>===1</ORDER><USE>&lt;</USE>（数字比较）</SUBINDEX></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><ORDER>===2</ORDER><USE>&lt;=</USE>（数字比较）</SUBINDEX></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>===</USE>（用于数字比较）</SUBINDEX></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>&quot;!==</USE>（用于数字比较）<ORDER>;4</ORDER></SUBINDEX></INDEX>
        <INDEX>相等<SUBINDEX><ORDER>数字</ORDER>的数字</SUBINDEX></INDEX>
        <JAVASCRIPTINLINE>&gt;=</JAVASCRIPTINLINE>、 
        <JAVASCRIPTINLINE>&gt;</JAVASCRIPTINLINE>、 
        <JAVASCRIPTINLINE>&lt;</JAVASCRIPTINLINE>、 
        <JAVASCRIPTINLINE>&lt;=</JAVASCRIPTINLINE>、 
        <JAVASCRIPTINLINE>===</JAVASCRIPTINLINE> 和
        <JAVASCRIPTINLINE>!==</JAVASCRIPTINLINE> 应用于数字，<FOOTNOTE>目前，我们将这些运算符限定为数字参数。在章节<SPACE></SPACE><REF NAME="sec:strings"></REF>
和<SPACE></SPACE><REF NAME="sec:mutable-list-structure"></REF>中，我们将推广相等和不等谓词
<JAVASCRIPTINLINE>===</JAVASCRIPTINLINE> 和
<JAVASCRIPTINLINE>!==</JAVASCRIPTINLINE>。</FOOTNOTE> 
还有逻辑组合操作，可以用来构造复合谓词。使用最频繁的三个是：
          
        <UL>
          <LI>
	    <META>表达式</META><LATEXINLINE>$_1$</LATEXINLINE> <JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE>
	    <META>表达式</META><LATEXINLINE>$_2$</LATEXINLINE><BR></BR>
	    该操作表示
	    <INDEX>语法糖<SUBINDEX><ORDER>;1</ORDER><JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE> 和 {\tt &quot;|&quot;|} 作为</SUBINDEX></INDEX>
	    <INDEX><USE>&amp;&amp;</USE>（逻辑与）<ORDER>;1</ORDER><FRAGILE></FRAGILE></INDEX>
	    <INDEX><USE>&amp;&amp;</USE>（逻辑与）<SUBINDEX>的求值</SUBINDEX><ORDER>;1</ORDER><FRAGILE></FRAGILE></INDEX>
	    <INDEX>语法形式<SUBINDEX>逻辑与（<JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE>）</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <INDEX>逻辑与<FRAGILE></FRAGILE></INDEX>
	    <INDEX>合取</INDEX>
            <INDEX>求值<SUBINDEX>对 <JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE> 的</SUBINDEX><ORDER>;1</ORDER><FRAGILE></FRAGILE></INDEX>
	    <EM>逻辑与</EM>，其意义大致相当于英语中的“and”。
	    我们假定<FOOTNOTE>此假定基于脚注<SPACE></SPACE><REF NAME="foot:any-value-as-predicate"></REF>中提到的限制。完整的 JavaScript 
	    需要考虑当&lt; META &gt;表达式&lt; / META &gt;&lt; LATEXINLINE &gt;$_1$&lt; / LATEXINLINE &gt;求值结果既不为 true 也不为 false 的情况。</FOOTNOTE>该语法形式为
	    <FOOTNOTE>语法形式仅为那些可以用更加统一方式书写的内容提供方便的替代表面结构，有时称为<EM>语法糖</EM>，该术语由
            <INDEX>Peter Landin</INDEX>提出。
            <INDEX>语法糖</INDEX>
	    Peter Landin。	    
	    </FOOTNOTE> 
	    <META>表达式</META><LATEXINLINE>$_1$</LATEXINLINE> <JAVASCRIPTINLINE>?</JAVASCRIPTINLINE>
	    <META>表达式</META><LATEXINLINE>$_2$</LATEXINLINE> <JAVASCRIPTINLINE>:</JAVASCRIPTINLINE>
	    <JAVASCRIPTINLINE>false</JAVASCRIPTINLINE>。
          </LI>
          <LI>
            <META>表达式</META><LATEXINLINE>$_1$</LATEXINLINE>
            <JAVASCRIPTINLINE>||</JAVASCRIPTINLINE>
            <META>表达式</META><LATEXINLINE>$_2$</LATEXINLINE><BR></BR>
	    该操作表示
	    <INDEX>{\tt &quot;|&quot;|}（逻辑或）<ORDER>;2</ORDER><FRAGILE></FRAGILE></INDEX>
	    <INDEX>{\tt &quot;|&quot;|}（逻辑或）<ORDER>;2</ORDER><SUBINDEX>的求值</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <INDEX>语法形式<SUBINDEX>逻辑或（{\tt &quot;|&quot;|}）</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <INDEX>逻辑或<FRAGILE></FRAGILE></INDEX>
	    <INDEX>析取</INDEX>
            <INDEX>求值<SUBINDEX>对 {\tt &quot;|&quot;|} 的</SUBINDEX><ORDER>;2</ORDER><FRAGILE></FRAGILE></INDEX>
	    <EM>逻辑或</EM>，其意义大致相当于英语中的“or”。
	    我们假定该语法形式为
	    <META>表达式</META><LATEXINLINE>$_1$</LATEXINLINE> <JAVASCRIPTINLINE>?</JAVASCRIPTINLINE>
	    <JAVASCRIPTINLINE>true</JAVASCRIPTINLINE> <JAVASCRIPTINLINE>:</JAVASCRIPTINLINE>
	    <META>表达式</META><LATEXINLINE>$_2$</LATEXINLINE> 的语法糖。

          </LI>
          <LI>
            <JAVASCRIPTINLINE>!</JAVASCRIPTINLINE>
	    <META>表达式</META><BR></BR>
	    该操作表示
	    <INDEX><USE>&quot;!&quot;</USE>（逻辑非操作符）<ORDER>;399</ORDER></INDEX>
	    <INDEX><OPERATOR></OPERATOR><SUBINDEX><ORDER>;399</ORDER><USE>&quot;!&quot;（逻辑非）</USE></SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <INDEX>取反<SUBINDEX>逻辑（<JAVASCRIPTINLINE>&quot;!&quot;</JAVASCRIPTINLINE>）</SUBINDEX></INDEX>
	    <EM>逻辑非</EM>，其意义大致相当于英语中的“not”。
            当<META>表达式</META>求值为 false 时，该表达式的值为 true；当<META>表达式</META>求值为 true 时，该表达式的值为 false。
          </LI>
        </UL>
        注意 <JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE> 和 
        <JAVASCRIPTINLINE>||</JAVASCRIPTINLINE> 是语法形式，而非操作符；
	<INDEX><USE>&amp;&amp;</USE>（逻辑与）<ORDER>;1</ORDER><SUBINDEX>为何是语法形式</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX>{\tt &quot;|&quot;|}（逻辑或）<ORDER>;2</ORDER><SUBINDEX>为何是语法形式</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	它们的右侧表达式并不总是被求值。另一方面，操作符
        <JAVASCRIPTINLINE>!</JAVASCRIPTINLINE> 遵循第 
	<REF NAME="sec:evaluating-combinations"></REF>。
        它是一个<EM>一元</EM>操作符，这意味着它只接受一个参数，而到目前为止讨论的算术操作符和原始谓词是<EM>二元</EM>的，接受两个参数。操作符
        <JAVASCRIPTINLINE>!</JAVASCRIPTINLINE> 位于其参数之前；我们称之为
        <INDEX><USE>-</USE><SUBINDEX>作为数值取反操作符</SUBINDEX></INDEX>
        <INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>-</USE>（数值取反操作符）</SUBINDEX></INDEX>
        <INDEX>取反<SUBINDEX>数值（<JAVASCRIPTINLINE>-</JAVASCRIPTINLINE>）</SUBINDEX></INDEX>
        <INDEX>二元操作符</INDEX>
        <INDEX>一元操作符</INDEX>
        <INDEX>前缀操作符</INDEX>
        <EM>前缀操作符</EM>。另一个前缀操作符是数值取反操作符，其例子是上面<JAVASCRIPTINLINE>abs</JAVASCRIPTINLINE>函数中的表达式<JAVASCRIPTINLINE>- x</JAVASCRIPTINLINE>。
       </TEXT>
    </JAVASCRIPT>
  </SPLIT>

   <SPLIT>
    <SCHEME>
      <TEXT>
        作为这些用法的一个例子，数字
        <LATEXINLINE>$x$</LATEXINLINE> 在范围
        <LATEXINLINE>$5 &lt; x &lt; 10$</LATEXINLINE> 内的条件可以表示为
        <SNIPPET EVAL="no">
          <SCHEME>
(and (&gt; x 5) (&lt; x 10))
          </SCHEME>
        </SNIPPET>
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <TEXT>
        作为这些谓词使用的一个例子，数字
        <LATEXINLINE>$x$</LATEXINLINE> 在范围
        <LATEXINLINE>$5 &lt; x &lt; 10$</LATEXINLINE> 内的条件可以表示为
        <SNIPPET EVAL="no">
          <JAVASCRIPT>
x &gt; 5 &amp;&amp; x &lt; 10 
          </JAVASCRIPT>
        </SNIPPET>
        语法形式
        <JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE>
        的优先级低于比较操作符
        <JAVASCRIPTINLINE>&gt;</JAVASCRIPTINLINE>
        和 <JAVASCRIPTINLINE>&lt;</JAVASCRIPTINLINE>，而条件表达式语法形式
        <LATEXINLINE>$\cdots$</LATEXINLINE><JAVASCRIPTINLINE>?</JAVASCRIPTINLINE><LATEXINLINE>$\cdots$</LATEXINLINE><JAVASCRIPTINLINE>:</JAVASCRIPTINLINE><LATEXINLINE>$\cdots$</LATEXINLINE>
        的优先级低于我们迄今遇到的任何其他操作符，这是我们在上面
        <JAVASCRIPTINLINE>abs</JAVASCRIPTINLINE> 函数中使用过的一个属性。
      </TEXT>
    </JAVASCRIPT>
  </SPLIT> 
   <TEXT>
    作为另一个例子，我们可以
    <SPLITINLINE>
      <SCHEME>
	define
      </SCHEME>
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    一个谓词来测试一个数字是否
    <SPLITINLINE>
      <SCHEME>
	<INDEX><USE>&gt;=</USE></INDEX> 
      </SCHEME>
    </SPLITINLINE>
    大于或等于另一个数字，如    
    <SNIPPET>
      <EXAMPLE>geq_example</EXAMPLE>
      <SCHEME>
(define (&gt;= x y)
  (or (&gt; x y) (= x y)))
      </SCHEME>
      <JAVASCRIPT>
function greater_or_equal(x, y) {
    return x &gt; y || x === y;
}
      </JAVASCRIPT>
    </SNIPPET>
    或者也可以表示为
    <SPLITINLINE>
      <SCHEME>
	<INDEX><USE>&gt;=</USE></INDEX> 
      </SCHEME>
    </SPLITINLINE>
    <SNIPPET>
      <EXAMPLE>geq_example</EXAMPLE>
      <SCHEME>
(define (&gt;= x y)
  (not (&lt; x y)))
      </SCHEME>
      <JAVASCRIPT>
function greater_or_equal(x, y) {
    return ! (x &lt; y);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>geq_example</NAME>
      <SCHEME>
(&gt;= 7 4)
      </SCHEME>
      <JAVASCRIPT>
greater_or_equal(7, 4);
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
      </SCHEME>
      <JAVASCRIPT>
        函数 <JAVASCRIPTINLINE>greater_or_equal</JAVASCRIPTINLINE>，
	当应用于两个数字时，其行为与操作符
	<JAVASCRIPTINLINE>&gt;=</JAVASCRIPTINLINE>相同。一元操作符具有
        <INDEX>优先级<SUBINDEX><ORDER>一元操作符优先级</ORDER></SUBINDEX></INDEX>
	高于二元操作符，这使得本例中的括号是必要的。
      </JAVASCRIPT>
    </SPLIT>
  </TEXT> 

  <LONG_PAGE LINES="1"></LONG_PAGE>
   <EXERCISE>
    下面是一系列
    <SPLITINLINE>
      <SCHEME>
	表达式。
      </SCHEME>
      <JAVASCRIPT>
	语句。
      </JAVASCRIPT>
    </SPLITINLINE>
    解释器对每个
    <SPLITINLINE>
      <SCHEME>
	表达式的
      </SCHEME>
      <JAVASCRIPT>
	语句的
      </JAVASCRIPT>
    </SPLITINLINE>
    响应打印的结果是什么？
    假设这些序列按所给顺序执行。
    <SNIPPET>
      <NAME>ten</NAME>
      <EXPECTED>10</EXPECTED>
      <SCHEME>
10
      </SCHEME>
      <JAVASCRIPT>
10;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>five_plus_three_plus_four</NAME>
      <EXPECTED>12</EXPECTED>
      <SCHEME>
(+ 5 3 4)
      </SCHEME>
      <JAVASCRIPT>
5 + 3 + 4;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>nine_minus_one</NAME>
      <EXPECTED>8</EXPECTED>
      <SCHEME>
(- 9 1)
      </SCHEME>
      <JAVASCRIPT>
9 - 1;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>six_over_two</NAME>
      <EXPECTED>3</EXPECTED>
      <SCHEME>
(/ 6 2)
      </SCHEME>
      <JAVASCRIPT>
6 / 2;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>two_times_four_etc</NAME>
      <EXPECTED>6</EXPECTED>
      <SCHEME>
(+ (* 2 4) (- 4 6))
      </SCHEME>
      <JAVASCRIPT>
2 * 4 + (4 - 6);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>definea</NAME>
      <EXPECTED>undefined</EXPECTED>
      <SCHEME>
(define a 3)
      </SCHEME>
      <JAVASCRIPT>
const a = 3;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>defineb</NAME>
      <REQUIRES>definea</REQUIRES>
      <EXPECTED>undefined</EXPECTED>
      <SCHEME>
(define b (+ a 1))
      </SCHEME>
      <JAVASCRIPT>
const b = a + 1;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_plus_b_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>19</EXPECTED>
      <SCHEME>
(+ a b (* a b))
      </SCHEME>
      <JAVASCRIPT>
a + b + a * b;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_equal_b</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>false</EXPECTED>
      <SCHEME>
(= a b)
      </SCHEME>
      <JAVASCRIPT>
a === b;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>b_gt_a_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>4</EXPECTED>
      <SCHEME>
(if (and (&gt; b a) (&lt; b (* a b)))
  b
  a)
      </SCHEME>
      <JAVASCRIPT>
b &gt; a &amp;&amp; b &lt; a * b ? b : a;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_equal_four_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>16</EXPECTED>
      <SCHEME>
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
      </SCHEME>
      <JAVASCRIPT>
a === 4
? 6
: b === 4
? 6 + 7 + a
: 25;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>two_plus_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>6</EXPECTED>
      <SCHEME>
(+ 2 (if (&gt; b a) b a))
      </SCHEME>
      <JAVASCRIPT>
2 + (b &gt; a ? b : a);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_greater_b_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>16</EXPECTED>
      <SCHEME>
(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))
      </SCHEME>
      <JAVASCRIPT>
(a &gt; b
 ? a
 : a &lt; b
 ? b
 : -1)
*
(a + 1);
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      <JAVASCRIPT>
	在最后两个语句中，条件表达式周围需要括号，
	因为条件表达式的
	<INDEX>优先级<SUBINDEX><ORDER>条件表达式优先级</ORDER></SUBINDEX></INDEX>
	低于算术运算符
	<JAVASCRIPTINLINE>+</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>*</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLIT>
    <LABEL NAME="ex:1_1"></LABEL>
    <SOLUTION>
      由 GitHub 用户 Emekk 提供的解答
      <OL>
	<LI>10</LI>
	<LI>12</LI>
	<LI>8</LI>
	<LI>3</LI>
	<LI>6</LI>
	<LI>3</LI>
	<LI>4</LI>
	<LI>19</LI>
	<LI>false</LI>
	<LI>4</LI>
	<LI>16</LI>
	<LI>6</LI>
	<LI>16</LI>
      </OL>
    </SOLUTION>
  </EXERCISE> 

   <EXERCISE>
    将下列表达式翻译成
    <SPLITINLINE>
      <SCHEME>
        前缀形式
      </SCHEME>
      <JAVASCRIPT>
        JavaScript
      </JAVASCRIPT>
    </SPLITINLINE>
    <PDF_ONLY>
      \par\medskip
    </PDF_ONLY>
    <LATEX>
      $\begin{array}{l}
      \quad~~\dfrac{5+4+\left(2-\left(3-(6+\frac{4}{5})\right)\right)}{3 (6-2) (2-7)}
      \end{array}$
    </LATEX>
    <SOLUTION>   
      <SNIPPET>
	<JAVASCRIPT>
(5 + 4 + (2 - (3 - (6 + 4 / 5)))) 
/
(3 * (6 - 2) * (2 - 7));
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:1_2"></LABEL>
  </EXERCISE> 
   <EXERCISE>
    <SPLITINLINE>
      <SCHEME>
        定义一个过程
      </SCHEME>
      <JAVASCRIPT>
	声明一个函数
      </JAVASCRIPT>
    </SPLITINLINE>
    接受三个数字作为参数并返回
    两个较大数字的平方和。
    <SOLUTION>
      <SNIPPET>
        <EXAMPLE>larger_two_square_example</EXAMPLE>
        <REQUIRES>square_definition</REQUIRES>
        <JAVASCRIPT>
function f(x, y, z) {
   return square(x) + square(y) + square(z) -
          // 减去最小值的平方
          square(x &gt; y ? (y &gt; z ? z : y) : (x &gt; z ? z : x));
}
        </JAVASCRIPT>
        <SCHEME>
(define (f x y z)
   (let ((smallest (if (&gt; x y) (if (&gt; y z) z y) (if (&gt; x z) z x))))
      (- (+ (square x) (square y) (square z)) (square smallest))))
        </SCHEME>
      </SNIPPET>
    </SOLUTION>
    <SNIPPET HIDE="yes">
      <NAME>larger_two_square_example</NAME>
      <SCHEME>
(f 4 7 2)
      </SCHEME>
      <JAVASCRIPT>
f(4, 7, 2);
      </JAVASCRIPT>
    </SNIPPET>
    <LABEL NAME="ex:1_3"></LABEL>
  </EXERCISE> 

   <EXERCISE>
    <LABEL NAME="ex:a-plus-abs-b"></LABEL>
    <SPLIT>
      <SCHEME>
	注意我们的求值模型允许
	<INDEX>组合<SUBINDEX>作为操作符的复合表达式</SUBINDEX></INDEX>
	<INDEX>复合表达式<SUBINDEX><ORDER>作为组合的操作符</ORDER></SUBINDEX></INDEX>
	<INDEX>组合的操作符<SUBINDEX>作为复合表达式</SUBINDEX></INDEX>
	操作符为复合表达式的组合。利用这一观察来描述以下过程的行为：
	<SNIPPET>
          <SCHEME>
(define (a-plus-abs-b a b)
  ((if (&gt; b 0) + -) a b))
          </SCHEME>
	</SNIPPET>
      </SCHEME>
      <JAVASCRIPT>
	注意我们的求值模型允许
	<INDEX>函数应用<SUBINDEX>作为函数表达式的复合表达式</SUBINDEX></INDEX>
	<INDEX>复合表达式<SUBINDEX><ORDER>作为应用的函数表达式</ORDER></SUBINDEX></INDEX>
	<INDEX>函数表达式<SUBINDEX>作为复合表达式</SUBINDEX></INDEX>
	函数表达式为复合表达式的应用。利用这一观察描述 <JAVASCRIPTINLINE>a_plus_abs_b</JAVASCRIPTINLINE> 的行为：
	<SNIPPET POSTPADDING="no">
          <EXAMPLE>plusminusexample</EXAMPLE>
          <JAVASCRIPT>
function plus(a, b) { return a + b; }
<SHORT_SPACE></SHORT_SPACE>
function minus(a, b) { return a - b; }
<SHORT_SPACE></SHORT_SPACE>
function a_plus_abs_b(a, b) {
    return (b &gt;= 0 ? plus : minus)(a, b);
}
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET HIDE="yes">
          <NAME>plusminusexample</NAME>
          <JAVASCRIPT>
a_plus_abs_b(5, -4);
          </JAVASCRIPT>
	</SNIPPET>
	<COMMENT>
	  注意，在 JavaScript 的条件表达式中，我们不能像 Scheme 中那样直接使用操作符 <JAVASCRIPTINLINE>+</JAVASCRIPTINLINE> 和 <JAVASCRIPTINLINE>-</JAVASCRIPTINLINE>，而必须使用名称 <JAVASCRIPTINLINE>plus</JAVASCRIPTINLINE> 和 <JAVASCRIPTINLINE>minus</JAVASCRIPTINLINE>，因为在中缀表示法中，只允许操作符符号处于中间位置，而不允许复合表达式。
	</COMMENT>
	<SOLUTION>
	  根据<SPACE></SPACE><REF NAME="sec:substitution-model"></REF> 节，应用的求值过程如下：
	  <OL>
	    <LI>求值应用的子表达式。
	    </LI>
            <LI>用各参数替换对应参数表达式结果，求值函数表达式的返回表达式。
            </LI>
	  </OL>
	  因此求值应用 <JAVASCRIPTINLINE>a_plus_abs_b(5, -4)</JAVASCRIPTINLINE> 时，
	  (1) 求值 <JAVASCRIPTINLINE>a_plus_abs_b</JAVASCRIPTINLINE>，
	  得到上面给出的函数，参数本身已是值。接着需要 (2) 求值函数的返回表达式，参数替换后为：
	  <JAVASCRIPTINLINE>(-4 &gt;= 0 ? plus : minus)(5, -4)</JAVASCRIPTINLINE>。
	  依据相同规则，先 (1) 求值函数表达式，
	  这里是条件表达式 <JAVASCRIPTINLINE>-4 &gt;= 0 ? plus : minus</JAVASCRIPTINLINE>。由于条件为假，函数表达式求值结果为 <JAVASCRIPTINLINE>minus</JAVASCRIPTINLINE>。参数 (1) 已是值。
	  因此最终 (2) 求值 <JAVASCRIPTINLINE>minus</JAVASCRIPTINLINE> 函数体，参数 <JAVASCRIPTINLINE>a</JAVASCRIPTINLINE> 和 <JAVASCRIPTINLINE>b</JAVASCRIPTINLINE> 分别替换为 5 和 -4，结果为
	  <JAVASCRIPTINLINE>5 - (-4)</JAVASCRIPTINLINE>，最终求值为 9。
	</SOLUTION>
      </JAVASCRIPT>
    </SPLIT>
  </EXERCISE> 

   <EXERCISE>
    <LABEL NAME="ex:normal-order-vs-appl-order-test"></LABEL>
    本·比特迪德发明了一个测试来确定他所面对的解释器是使用
    <INDEX>正常序求值<SUBINDEX>应用序与</SUBINDEX></INDEX>
    <INDEX>应用序求值<SUBINDEX>正常序与</SUBINDEX></INDEX>
    应用序求值还是正常序求值。他
    <SPLITINLINE>
      <SCHEME>
	定义以下两个过程：
      </SCHEME>
      <JAVASCRIPT>
	声明以下两个函数：
      </JAVASCRIPT>
    </SPLITINLINE>
      <SNIPPET>
	<NAME>ptest</NAME>
	<SCHEME>
(define (p) (p))

(define (test x y)
  (if (= x 0)
    0
    y))
	</SCHEME>
	<JAVASCRIPT>
function p() { return p(); }

function test(x, y) {
    return x === 0 ? 0 : y;
}
	</JAVASCRIPT>
      </SNIPPET>
      <START_KEEP_TOGETHER></START_KEEP_TOGETHER><NOINDENT></NOINDENT>
      然后他求值
      <SPLITINLINE>
	<SCHEME>表达式</SCHEME>
	<JAVASCRIPT>语句</JAVASCRIPT>
      </SPLITINLINE>
      <SNIPPET>
	<REQUIRES>ptest</REQUIRES>
	<SCHEME>
(test 0 (p))
	</SCHEME>
	<JAVASCRIPT>
test(0, p());
	</JAVASCRIPT>
      </SNIPPET>
      <STOP_KEEP_TOGETHER></STOP_KEEP_TOGETHER>
      在使用应用序求值的解释器中，本将观察到什么行为？在使用正常序求值的解释器中，他将观察到什么行为？请解释你的答案。
      <INDEX>正常序求值<SUBINDEX><ORDER>条件表达式的条件</ORDER></SUBINDEX></INDEX>
      <INDEX>条件表达式<SUBINDEX>正常序求值的</SUBINDEX></INDEX>
      （假设
      <SPLITINLINE>
	<SCHEME>
          特殊形式 <SCHEMEINLINE>if</SCHEMEINLINE> 的
	</SCHEME>
	<JAVASCRIPT>
          条件表达式的求值规则
	</JAVASCRIPT>
      </SPLITINLINE>
      无论解释器使用正常序还是应用序均相同：
      先求值谓词表达式，其结果决定是否求值后继或备选表达式。）
      <SOLUTION>		
	<SPLIT>
	  <JAVASCRIPT>
	    对于 <JAVASCRIPTINLINE>test(0, p())</JAVASCRIPTINLINE> 的应用序求值，
	    我们需要先求值参数表达式，然后才能求值函数 <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE> 的返回表达式。
	    其中参数表达式 <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE> 的求值不会终止：
	    它会不断求值形式为 <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE> 的应用表达式，
	    因此对 <JAVASCRIPTINLINE>test(0, p())</JAVASCRIPTINLINE> 的求值不会产生一个合理的值。
	    另一方面，在正常序求值中，函数应用 <JAVASCRIPTINLINE>test(0, p())</JAVASCRIPTINLINE> 会立即求值函数 <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE> 的返回表达式
	    <JAVASCRIPTINLINE>x === 0 ? 0 : y</JAVASCRIPTINLINE>，
	    其中参数 <JAVASCRIPTINLINE>x</JAVASCRIPTINLINE> 被替换为 <JAVASCRIPTINLINE>0</JAVASCRIPTINLINE>，
	    参数 <JAVASCRIPTINLINE>y</JAVASCRIPTINLINE> 被替换为 <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE>。
	    替换后结果是 <JAVASCRIPTINLINE>0 === 0 ? 0 : p()</JAVASCRIPTINLINE>。
	    谓词表达式 <JAVASCRIPTINLINE>0 === 0</JAVASCRIPTINLINE> 的求值结果为真，
	    因此条件表达式的值为 0，无需求值 <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE>。
	  </JAVASCRIPT>
	</SPLIT>
      </SOLUTION>
  </EXERCISE> 
</SUBSECTION>
