<SUBSECTION>
  <NAME>
    Compiling
    <SPLITINLINE>
      <SCHEME>Expressions</SCHEME>
      <JAVASCRIPT>Components</JAVASCRIPT>
    </SPLITINLINE>
  </NAME>

  <LABEL NAME="sec:compiling-components"/>
  <TEXT>
    In this section and the next we implement the code generators to which the
    <SCHEMEINLINE>compile</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    dispatches.
  </TEXT>

  <SUBHEADING>
    <NAME>Compiling linkage code</NAME>
  </SUBHEADING>

  <TEXT>
    In general, the output of each code generator will end with
    instructions<EMDASH/>generated by the
    <INDEX>compiler for JavaScript<SUBINDEX>linkage code</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-linkage</SCHEMEINLINE><EMDASH/>that</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compile_linkage</JAVASCRIPTINLINE><EMDASH/>that
      </JAVASCRIPT>
    </SPLITINLINE>
    implement the required linkage.  If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    then
    we must generate the instruction
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    This needs the <SCHEMEINLINE>continue</SCHEMEINLINE> register and does not
    modify any registers.
    If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    then we needn<APOS/>t include any additional instructions.  Otherwise, the
    linkage is a label, and we generate a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to that label, an instruction that does not need or modify
    any registers.<SPLITINLINE><SCHEME><FOOTNOTE>This procedure
    uses a feature of Lisp called
    <INDEX>list(s)<SUBINDEX>backquote with</SUBINDEX></INDEX>
    <INDEX>backquote</INDEX>
    <INDEX>quasiquote</INDEX>
    <INDEX><USE>`</USE> (backquote)</INDEX>
    <INDEX><USE>,</USE> (comma, used with backquote)</INDEX>
    <INDEX>comma, used with backquote</INDEX>
    <EM>backquote</EM> (or <EM>quasiquote</EM>) that is handy for constructing
    lists. Preceding a list with a backquote symbol is much like quoting it,
    except that anything in the list that is flagged with a comma is
    evaluated.
    <P/>
    For example, if the value of <SCHEMEINLINE>linkage</SCHEMEINLINE> is the
    symbol <SCHEMEINLINE>branch25</SCHEMEINLINE>,
    then the expression
    <SCHEMEINLINE>`((goto (label ,linkage)))</SCHEMEINLINE>
    evaluates to the list
    <SCHEMEINLINE>((goto (label branch25)))</SCHEMEINLINE>.
    Similarly, if the value of <SCHEMEINLINE>x</SCHEMEINLINE> is the list
    <SCHEMEINLINE>(a b c)</SCHEMEINLINE>,
    then
    <SCHEMEINLINE>`(1 2 ,x)</SCHEMEINLINE>
    evaluates to the list
    <SCHEMEINLINE>(1 2 a)</SCHEMEINLINE>.</FOOTNOTE></SCHEME></SPLITINLINE>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_linkage</DECLARATION></INDEX>
      <NAME>compile_linkage</NAME>
      <SCHEME>
      (define (compile-linkage linkage)
      (cond ((eq? linkage 'return)
            (make-instruction-sequence '(continue) '()
            '((goto (reg continue)))))
            ((eq? linkage 'next)
            (empty-instruction-sequence))
            (else
            (make-instruction-sequence '() '()
            ` ((goto (label ,linkage)))))))
      </SCHEME>nn
      <JAVASCRIPT>
function compile_linkage(linkage) {
    return linkage === "return"
           ? make_instruction_sequence(list("continue"), null,
                                       list(go_to(reg("continue"))))
           : linkage === "next"
           ? empty_instruction_sequence()
           : make_instruction_sequence(null, null, 
                                       list(go_to(label(linkage))));
}
      </JAVASCRIPT>
    </SNIPPET>
    The linkage code is appended to an instruction sequence by
    <SCHEMEINLINE>preserving</SCHEMEINLINE> the
    <SCHEMEINLINE>continue</SCHEMEINLINE> register, since a
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    linkage will
    require the <SCHEMEINLINE>continue</SCHEMEINLINE> register:
    If the given instruction sequence modifies
    <SCHEMEINLINE>continue</SCHEMEINLINE> and the linkage code needs it,
    <SCHEMEINLINE>continue</SCHEMEINLINE> will be saved and restored.
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>end_with_linkage</DECLARATION></INDEX>
      <NAME>end_with_linkage</NAME>
      <SCHEME>
      (define (end-with-linkage linkage instruction-sequence)
      (preserving '(continue)
      instruction-sequence
      (compile-linkage linkage)))
      </SCHEME>
      <JAVASCRIPT>
function end_with_linkage(linkage, instruction_sequence) {
    return preserving(list("continue"),
                      instruction_sequence,
                      compile_linkage(linkage));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Compiling simple
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	components
      </JAVASCRIPT>
    </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    The code generators for
    <INDEX>compiler for JavaScript<SUBINDEX>literals</SUBINDEX></INDEX>
    <INDEX>compiler for JavaScript<SUBINDEX>names</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>self-evaluating expressions, quotations, and variables</SCHEME>
      <JAVASCRIPT>literal expressions and names</JAVASCRIPT>
    </SPLITINLINE>
    construct instruction
    sequences that assign the required value to the target register
    and then proceed as specified by the linkage descriptor.
  </TEXT>
  <SPLIT>
    <JAVASCRIPT>
      <TEXT>
        The literal value is extracted at compile time from the component being
        compiled and put into the constant part of the
        <JAVASCRIPTINLINE>assign</JAVASCRIPTINLINE> instruction. For a name, an
        instruction is generated to use the
        <JAVASCRIPTINLINE>lookup_symbol_value</JAVASCRIPTINLINE> operation when
        the compiled program is run, to look up the value associated with a
        symbol in the current environment. Like a literal value, the symbol is
        extracted at compile time from the component being compiled. Thus
        <JAVASCRIPTINLINE>symbol_of_name(component)</JAVASCRIPTINLINE> is
        executed only once, when the program is being compiled, and the symbol
        appears as a constant in the
        <JAVASCRIPTINLINE>assign</JAVASCRIPTINLINE> instruction.
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>
  <TEXT>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_literal</DECLARATION></INDEX>
      <INDEX><DECLARATION>compile_name</DECLARATION></INDEX>
      <NAME>compile_literal</NAME>
      <SCHEME>
      (define (compile-self-evaluating exp target linkage)
      (end-with-linkage linkage
      (make-instruction-sequence '() (list target)
      `((assign ,target (const ,exp))))))

      (define (compile-quoted exp target linkage)
      (end-with-linkage linkage
      (make-instruction-sequence '() (list target)
      `((assign ,target (const ,(text-of-quotation exp)))))))

      (define (compile-variable exp target linkage)
      (end-with-linkage linkage
      (make-instruction-sequence '(env) (list target)
      `((assign ,target
            (op lookup-variable-value)
            (const ,exp)
            (reg env))))))
      </SCHEME>
      <JAVASCRIPT>
function compile_literal(component, target, linkage) {
    const literal = literal_value(component);
    return end_with_linkage(linkage,
               make_instruction_sequence(null, list(target),
                   list(assign(target, constant(literal)))));
}

function compile_name(component, target, linkage) {
    const symbol = symbol_of_name(component);
    return end_with_linkage(linkage,
               make_instruction_sequence(list("env"), list(target),
                   list(assign(target,
                        list(op("lookup_symbol_value"),
                             constant(symbol),
                             reg("env"))))));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME>All these</SCHEME>
      <JAVASCRIPT>These</JAVASCRIPT>
    </SPLITINLINE>
    <JAVASCRIPTINLINE>assign</JAVASCRIPTINLINE> instructions modify the target register,
    and the one that looks up a
    <SPLITINLINE>
      <SCHEME>
	variable
      </SCHEME>
      <JAVASCRIPT>
	symbol
      </JAVASCRIPT>
    </SPLITINLINE>
    needs the <SCHEMEINLINE>env</SCHEMEINLINE> register.
  </TEXT>

  <TEXT>
    Assignments and
    <INDEX>compiler for JavaScript<SUBINDEX>assignments</SUBINDEX></INDEX>
    <INDEX>compiler for JavaScript<SUBINDEX>declarations</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>definitions</SCHEME>
      <JAVASCRIPT>declarations</JAVASCRIPT>
    </SPLITINLINE>
    are handled much as they are in the
    interpreter.
    We recursively generate code that computes the value to be
    <SPLITINLINE>
      <SCHEME>assigned to the variable,</SCHEME>
    <JAVASCRIPT>associated with the symbol,</JAVASCRIPT></SPLITINLINE>
    and
    <SPLITINLINE>
      <JAVASCRIPT>
	use <JAVASCRIPTINLINE>compile_assignment_returning</JAVASCRIPTINLINE> to
      </JAVASCRIPT>
    </SPLITINLINE>
    append to it a two-instruction sequence that
    <SPLITINLINE>
      <SCHEME>
        actually sets or defines the variable
      </SCHEME>
      <JAVASCRIPT>
        updates the value associated with the symbol in the environment
      </JAVASCRIPT>
    </SPLITINLINE>
    and assigns the
    value of the whole
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
      <JAVASCRIPT>component</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	(the symbol <SCHEMEINLINE>ok</SCHEMEINLINE>)
      </SCHEME>
    </SPLITINLINE>
    to the target register.  The recursive compilation has target
    <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    so that the code will put its result into
    <SCHEMEINLINE>val</SCHEMEINLINE> and continue with the code that is appended
    after it.  The appending is done preserving <SCHEMEINLINE>env</SCHEMEINLINE>,
    since the environment is needed for
    <SPLITINLINE>
      <SCHEME>setting or defining the variable</SCHEME>
      <JAVASCRIPT>updating the symbol-value association</JAVASCRIPT>
    </SPLITINLINE>
    and the code for
    <SPLITINLINE>
      <SCHEME>the variable</SCHEME>
      <JAVASCRIPT>computing the</JAVASCRIPT>
    </SPLITINLINE>
    value could be the compilation of a complex expression
    that might modify the registers in arbitrary ways.
    <SPLIT>
      <JAVASCRIPT>
	The parameter <JAVASCRIPTINLINE>return_val</JAVASCRIPTINLINE>
        of <JAVASCRIPTINLINE>compile_assignment_returning</JAVASCRIPTINLINE>
	lets declarations return <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> and assignments
	return the assigned value.
      </JAVASCRIPT>
    </SPLIT>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_assignment</DECLARATION></INDEX>
      <INDEX><DECLARATION>compile_declaration</DECLARATION></INDEX>
      <NAME>compile_assignment</NAME>
      <SCHEME>
      (define (compile-assignment exp target linkage)
      (let ((var (assignment-variable exp))
            (get-value-code
            (compile (assignment-value exp) 'val 'next)))
      (end-with-linkage linkage
      (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
      `((perform (op set-variable-value!)
            (const ,var)
            (reg val)
            (reg env))
            (assign ,target (const ok))))))))

      (define (compile-definition exp target linkage)
      (let ((var (definition-variable exp))
            (get-value-code
            (compile (definition-value exp) 'val 'next)))
      (end-with-linkage linkage
      (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
      `((perform (op define-variable!)
            (const ,var)
            (reg val)
            (reg env))
            (assign ,target (const ok))))))))
      </SCHEME>
      <JAVASCRIPT>
function compile_assignment(component, target, linkage) {
    const symbol = assignment_symbol(component);
    const value_code = compile(
              assignment_value_expression(component), "val", "next");
    return compile_assignment_returning(symbol,
               value_code, target, linkage, reg("val"));
}

function compile_declaration(component, target, linkage) {
    const symbol = declaration_symbol(component);
    const value_code = compile(
              declaration_value_expression(component), "val", "next");
    return compile_assignment_returning(symbol,
               value_code, target, linkage, constant(undefined));
}

function compile_assignment_returning(symbol, value_code, target,
                                      linkage, return_val) {
    return end_with_linkage(linkage,
               preserving(
                   list("env"),
                   value_code,
                   make_instruction_sequence(list("env", "val"), list(target),
                       list(perform(
                                list(op("assign_symbol_value"),
                                     constant(symbol),
                                     reg("val"),
                                     reg("env"))),
                            assign(target, return_val)))));
}
      </JAVASCRIPT>
    </SNIPPET>
    The appended two-instruction sequence requires
    <SCHEMEINLINE>env</SCHEMEINLINE> and <SCHEMEINLINE>val</SCHEMEINLINE>
    and modifies the target.  Note that although we preserve
    <SCHEMEINLINE>env</SCHEMEINLINE> for this sequence, we do not preserve
    <SCHEMEINLINE>val</SCHEMEINLINE>, because the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-value-code</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>value_code</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is designed to explicitly place its result in
    <SCHEMEINLINE>val</SCHEMEINLINE> for use by this sequence.
    (In fact, if we did preserve <SCHEMEINLINE>val</SCHEMEINLINE>, we would
    have a bug, because this would cause the previous contents of
    <SCHEMEINLINE>val</SCHEMEINLINE> to be restored right after the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-value-code</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>value_code</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is run.)
  </TEXT>

  <SUBHEADING>
    <NAME>Compiling
    <SPLITINLINE>
      <SCHEME>
        conditional expressions
      </SCHEME>
      <JAVASCRIPT>
        conditionals
      </JAVASCRIPT>
    </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    The code for
    <INDEX>compiler for JavaScript<SUBINDEX>conditionals</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	an <SCHEMEINLINE>if expression</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	a conditional
      </JAVASCRIPT>
    </SPLITINLINE>
    compiled with a given target and linkage has the form
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      ^compilation of predicate, target^ val^, linkage^ next
      (test (op false?) (reg val))
      (branch (label false-branch))
      true-branch
      ^compilation of consequent with given target and given linkage or^ after-if
      false-branch
      ^compilation of alternative with given target and linkage^
      after-if
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>compilation of predicate, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE></METAPHRASE>
  test(list(op("is_falsy"), reg("val"))),
  branch(label("false_branch")),
"true_branch",
  <METAPHRASE>compilation of consequent with given target and given linkage or <JAVASCRIPTINLINE>after_cond</JAVASCRIPTINLINE></METAPHRASE>
"false_branch",
  <METAPHRASE>compilation of alternative with given target and linkage</METAPHRASE>
"after_cond"
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    To generate this code, we compile the predicate, consequent,
    and alternative, and combine the resulting code with instructions
    to test the predicate result and with newly generated labels to mark the
    true and false branches and the end of the
    conditional.<FOOTNOTE>We can<APOS/>t just use the labels
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>true-branch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>true_branch</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>false-branch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>false_branch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>after-if</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>after_cond</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    as shown above, because there might be more than one
    <SPLITINLINE><SCHEME><SCHEMEINLINE>if</SCHEMEINLINE></SCHEME><JAVASCRIPT>conditional</JAVASCRIPT></SPLITINLINE>
    in the program.
    <INDEX>compiler for JavaScript<SUBINDEX>label generation</SUBINDEX></INDEX>
    The compiler uses the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-label</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_label</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to generate labels.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-label</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_label</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    takes a <SPLITINLINE><SCHEME>symbol</SCHEME><JAVASCRIPT>string</JAVASCRIPT></SPLITINLINE> as argument and returns a new
    <SPLITINLINE><SCHEME>symbol</SCHEME><JAVASCRIPT>string</JAVASCRIPT></SPLITINLINE> that begins with the
    given <SPLITINLINE><SCHEME>symbol</SCHEME><JAVASCRIPT>string</JAVASCRIPT></SPLITINLINE>.  For example, successive calls to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(make-label 'a)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_label("a")</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    would return
    <SPLITINLINE><SCHEME><SCHEMEINLINE>a1</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>"a1"</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
    <SPLITINLINE><SCHEME><SCHEMEINLINE>a2</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>"a2"</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
    and so on.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-label</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_label</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    can be implemented similarly to the generation of unique variable names in
    the query language, as follows:
    <SPLITINLINE>
      <SCHEME>
	<INDEX>character strings<SUBINDEX>primitive procedures for</SUBINDEX></INDEX>
      </SCHEME>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>make_label</DECLARATION></INDEX>
      <NAME>make_label</NAME>
      <SCHEME>
        (define label-counter 0)

        (define (new-label-number)
        (set! label-counter (+ 1 label-counter))
        label-counter)

        (define (make-label name)
        (string-&gt;symbol
        (string-append (symbol-&gt;string name)
              (number-&gt;string (new-label-number)))))
      </SCHEME>
      <JAVASCRIPT>
let label_counter = 0;

function new_label_number() {
    label_counter = label_counter + 1;
    return label_counter;
}

function make_label(string) {
    return string + stringify(new_label_number());
}
      </JAVASCRIPT>
    </SNIPPET></FOOTNOTE>
    In this arrangement of code, we must branch around the true branch
    if the test is false.  The only slight complication is in how the
    linkage for the true branch should be handled.  If the linkage for the
    conditional is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    or a label, then the
    true and false branches will both use this same linkage.  If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    the true branch ends with a jump around
    the code for the false branch to the label at the end of the conditional.
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_conditional</DECLARATION></INDEX>
      <NAME>compile_conditional</NAME>
      <SCHEME>
      (define (compile-if exp target linkage)
      (let ((t-branch (make-label 'true-branch))
            (f-branch (make-label 'false-branch))
            (after-if (make-label 'after-if)))
      (let ((consequent-linkage
            (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
            (compile
            (if-consequent exp) target consequent-linkage))
            (a-code
            (compile (if-alternative exp) target linkage)))
            (preserving '(env continue)
            p-code
            (append-instruction-sequences
            (make-instruction-sequence '(val) '()
            `((test (op false?) (reg val))
            (branch (label ,f-branch))))
            (parallel-instruction-sequences
            (append-instruction-sequences t-branch c-code)
            (append-instruction-sequences f-branch a-code))
            after-if))))))
      </SCHEME>
      <JAVASCRIPT>
function compile_conditional(component, target, linkage) {
    const t_branch = make_label("true_branch");
    const f_branch = make_label("false_branch");
    const after_cond = make_label("after_cond");
    const consequent_linkage =
            linkage === "next" ? after_cond : linkage;
    const p_code = compile(conditional_predicate(component), "val", "next");
    const c_code = compile(conditional_consequent(component),
                         target, consequent_linkage);
    const a_code = compile(conditional_alternative(component),
                         target, linkage);
    return preserving(
               list("env", "continue"),
               p_code,
               append_instruction_sequences(
                   make_instruction_sequence(list("val"), null,
                       list(test(list(op("is_falsy"), reg("val"))),
                            branch(label(f_branch)))),
                   append_instruction_sequences(
                       parallel_instruction_sequences(
                           append_instruction_sequences(t_branch, c_code),
                           append_instruction_sequences(f_branch, a_code)),
                       after_cond)));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Env</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	The register
	<SCHEMEINLINE>env</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is preserved around the predicate code
    because it could be needed by the true and false 
      branches, and <SCHEMEINLINE>continue</SCHEMEINLINE> is preserved because it could
    be needed by the linkage code in those branches.
  The code for the true and
    false branches (which are not executed sequentially) is appended using a
    special combiner
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>parallel-instruction-sequences</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>parallel_instruction_sequences</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    described in
    section<SPACE/><REF NAME="sec:combining-instruction-sequences"/>.
  </TEXT>

  <SPLIT>
    <SCHEME>
      <TEXT>
	Note that <SCHEMEINLINE>cond</SCHEMEINLINE> is a derived expression,
	so all that the compiler needs to do to handle it is to apply the
	<SCHEMEINLINE>cond-&gt;if</SCHEMEINLINE> transformer
	(from section<SPACE/><REF NAME="sec:representing-expressions"/>) and
	compile the resulting <SCHEMEINLINE>if</SCHEMEINLINE> expression.
      </TEXT>
    </SCHEME>
  </SPLIT>

  <SUBHEADING>
    <NAME>Compiling sequences</NAME>
  </SUBHEADING>

  <TEXT>
    The compilation of
    <INDEX>compiler for JavaScript<SUBINDEX>sequences of statements</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
        sequences (from procedure bodies or explicit <SCHEMEINLINE>begin</SCHEMEINLINE>
	expressions)
	parallels their evaluation.
      </SCHEME>
      <JAVASCRIPT>
        statement sequences
	parallels their evaluation
	in the explicit-control evaluator with one exception: If a return statement
	appears in the middle of a sequence, we treat it as if it were the last statement
	in the sequence.
      </JAVASCRIPT>
    </SPLITINLINE>
    Each
    <SPLITINLINE>
      <SCHEME>
        expression
      </SCHEME>
      <JAVASCRIPT>
        statement
      </JAVASCRIPT>
    </SPLITINLINE>
    of the sequence is compiled<EMDASH/>the last
    <SPLITINLINE>
      <SCHEME>
        expression
      </SCHEME>
      <JAVASCRIPT>
        statement (or a return statement)
      </JAVASCRIPT>
    </SPLITINLINE>
    with
    the linkage specified for the sequence, and the other
    <SPLITINLINE>
      <SCHEME>
        expressions
      </SCHEME>
      <JAVASCRIPT>
        statements
      </JAVASCRIPT>
    </SPLITINLINE>
    with
    linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    (to execute the rest of the
    sequence). The instruction sequences for the individual
    <SPLITINLINE>
      <SCHEME>
        expressions
      </SCHEME>
      <JAVASCRIPT>
        statements
      </JAVASCRIPT>
    </SPLITINLINE>
    are
    appended to form a single instruction sequence, such that
    <SCHEMEINLINE>env</SCHEMEINLINE> (needed for the rest of the
    sequence)<SPLITINLINE>
    <SCHEME>
      and <SCHEMEINLINE>continue</SCHEMEINLINE> (possibly needed
      for the linkage at the end of the sequence) are 
    </SCHEME>
    <JAVASCRIPT>
      is 
    </JAVASCRIPT>
  </SPLITINLINE>
  preserved.
  <SNIPPET EVAL="no">
    <INDEX><DECLARATION>compile_sequence</DECLARATION></INDEX>
    <NAME>compile_sequence</NAME>
    <SCHEME>
      (define (compile-sequence seq target linkage)
      (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
      (compile (first-exp seq) target 'next)
      (compile-sequence (rest-exps seq) target linkage))))
    </SCHEME>
    <JAVASCRIPT>
function compile_sequence(seq, target, linkage) {
    return is_empty_sequence(seq)
           ? empty_instruction_sequence()
           : is_last_statement(seq) || is_return_statement(first_statement(seq))
           ? compile(first_statement(seq), target, linkage)
           : preserving(
                 list("env"),
                 compile(first_statement(seq), target, "next"),
                 compile_sequence(rest_statements(seq), target, linkage));
}
    </JAVASCRIPT>
  </SNIPPET>
  <SPLIT>
    <JAVASCRIPT>
      Treating a return statement as if it were the last statement in a sequence
      avoids compiling any <QUOTE>dead code</QUOTE> after the return statement that can
      never be executed.<FOOTNOTE>Our compiler does not detect all dead code. For example,
      a conditional statement whose consequent and alternative branches both end in a return
      statement will not stop subsequent statements from being compiled. See
      exercises<SPACE/><REF NAME="ex:dead-code"/> and <REF NAME="ex:append_return_undefined"/>.
      <LABEL NAME="foot:dead-code"/></FOOTNOTE>
      Removing the <JAVASCRIPTINLINE>is_return_statement</JAVASCRIPTINLINE> check does not change the behavior
      of the program; however,
      there are many reasons not to compile dead code, which are beyond the scope of this book
      (security, compilation time, size of the object code, etc.),
      and many compilers give warnings for dead code.
    </JAVASCRIPT>
  </SPLIT>
  </TEXT>

  <SPLIT>
    <JAVASCRIPT>
      <!-- FIXME: This SPLIT.JAVASCRIPT contains a lot of SCHEME. Remove. -->
      <SUBHEADING>
	<NAME>
	  Compiling blocks
	</NAME>
      </SUBHEADING>

      <TEXT>
	A
	<INDEX>compiler for JavaScript<SUBINDEX>blocks</SUBINDEX></INDEX>
	block is compiled by prepending an <JAVASCRIPTINLINE>assign</JAVASCRIPTINLINE> instruction to the compiled
	body of the block. The assignment extends the current environment with bindings
	of the declared names of the block to the value
	<JAVASCRIPTINLINE>"*unassigned*"</JAVASCRIPTINLINE>. This operation
	both needs and modifies the <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> register.
	<SNIPPET EVAL="no">
          <INDEX><DECLARATION>compile_block</DECLARATION></INDEX>
          <INDEX>scanning out declarations<SUBINDEX>in compiler</SUBINDEX></INDEX>
	  <NAME>compile_block</NAME>
	  <JAVASCRIPT>
function compile_block(stmt, target, linkage) {
    const body = block_body(stmt);
    const locals = scan_out_declarations(body);
    const unassigneds = list_of_unassigned(locals);
    return append_instruction_sequences(
               make_instruction_sequence(list("env"), list("env"),
                   list(assign("env", list(op("extend_environment"),
                                           constant(locals),
                                           constant(unassigneds),
                                           reg("env"))))),
               compile(body, target, linkage));
}
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>

      <SUBHEADING>
	<NAME>Compiling
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>lambda</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    lambda
	  </JAVASCRIPT>
	</SPLITINLINE>
	expressions</NAME>
      </SUBHEADING>

      <TEXT>
	Lambda expressions
	<INDEX>compiler for JavaScript<SUBINDEX>lambda expressions</SUBINDEX></INDEX>
	construct
	<SPLITINLINE>
	  <SCHEME>procedures.</SCHEME>
	  <JAVASCRIPT>functions.</JAVASCRIPT>
	</SPLITINLINE>
	The object code for a lambda expression must have the form
	<SNIPPET EVAL="no" LATEX="yes">
	  <SCHEME>
      ^construct procedure object and assign it to target register^
      ^linkage^
	  </SCHEME>
	  <JAVASCRIPT>
<METAPHRASE>construct function object and assign it to target register</METAPHRASE>
<METAPHRASE>linkage</METAPHRASE>
	  </JAVASCRIPT>
	</SNIPPET>
	When we compile the lambda expression, we also generate the code for the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	body. Although the body won<APOS/>t be executed at the time of
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	construction, it is convenient to insert it into the object code right after
	the code for the
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE>.</SCHEME>
	  <JAVASCRIPT>lambda expression.</JAVASCRIPT>
	</SPLITINLINE>
	If the linkage for the lambda expression is a label or
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>return</SCHEMEINLINE>,
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>,
	  </JAVASCRIPT>
	</SPLITINLINE>
	this is fine.  But if the linkage is
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>next</SCHEMEINLINE>,
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>,
	  </JAVASCRIPT>
	</SPLITINLINE>
	we will need to skip around the code for
	the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	body by using a linkage that jumps to a label that is inserted after the
	body.  The object code thus has the form
	<SNIPPET EVAL="no" LATEX="yes">
	  <SCHEME>
      ^construct procedure object and assign it to target register^
      ^code for given linkage <EM>or</EM>^ (goto (label after-lambda))
      ^compilation of procedure body^
      after-lambda
	  </SCHEME>
	  <JAVASCRIPT>
<METAPHRASE>construct function object and assign it to target register</METAPHRASE>
<METAPHRASE>code for given linkage</METAPHRASE> <META>or</META> go_to(label("after_lambda"))
<METAPHRASE>compilation of function body</METAPHRASE>
"after_lambda"
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>

      <TEXT>
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>Compile-lambda</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    The function
	  <JAVASCRIPTINLINE>compile_lambda_expression</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	generates the code for constructing the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	object followed by the code for the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	body. The
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	object will be constructed at run time by combining the current environment
	(the environment at the point of <SPLITINLINE><SCHEME>definition</SCHEME><JAVASCRIPT>declaration</JAVASCRIPT></SPLITINLINE>) with the entry point to the
	compiled
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	body (a newly generated label).<FOOTNOTE>We need machine operations to
	implement a data structure for representing compiled
	<SPLITINLINE>
	  <SCHEME>procedures,</SCHEME>
	  <JAVASCRIPT>functions,</JAVASCRIPT>
	</SPLITINLINE>
	analogous to the structure for compound
	<SPLITINLINE>
	  <SCHEME>procedures</SCHEME>
	  <JAVASCRIPT>functions</JAVASCRIPT>
	</SPLITINLINE>
	described in section<SPACE/><REF NAME="sec:eval-data-structures"/>:
	<SNIPPET EVAL="no">
	  <INDEX><DECLARATION>make_compiled_function</DECLARATION></INDEX>
	  <INDEX><DECLARATION>is_compiled_function</DECLARATION></INDEX>
	  <INDEX><DECLARATION>compiled_function_entry</DECLARATION></INDEX>
	  <INDEX><DECLARATION>compiled_function_env</DECLARATION></INDEX>
	  <NAME>make_compiled_function</NAME>
	  <SCHEME>
        (define (make-compiled-procedure entry env)
        (list 'compiled-procedure entry env))

        (define (compiled-procedure? proc)
        (tagged-list? proc 'compiled-procedure))

        (define (compiled-procedure-entry c-proc) (cadr c-proc))

        (define (compiled-procedure-env c-proc) (caddr c-proc))
	  </SCHEME>
	  <JAVASCRIPT>
function make_compiled_function(entry, env) {
    return list("compiled_function", entry, env);
}

function is_compiled_function(fun) {
    return is_tagged_list(fun, "compiled_function");
}

function compiled_function_entry(c_fun) {
    return head(tail(c_fun));
}

function compiled_function_env(c_fun) {
    return head(tail(tail(c_fun)));
}
	  </JAVASCRIPT>
	</SNIPPET>
	<LABEL NAME="foot:compiler-ops"/></FOOTNOTE>
	<SNIPPET EVAL="no">
	  <INDEX><DECLARATION>compile_lambda_expression</DECLARATION></INDEX>
	  <NAME>compile_lambda</NAME>
	  <SCHEME>
      (define (compile-lambda exp target linkage)
      (let ((proc-entry (make-label 'entry))
            (after-lambda (make-label 'after-lambda)))
      (let ((lambda-linkage
            (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
      (tack-on-instruction-sequence
            (end-with-linkage lambda-linkage
            (make-instruction-sequence '(env) (list target)
            `((assign ,target
            (op make-compiled-procedure)
            (label ,proc-entry)
            (reg env)))))
            (compile-lambda-body exp proc-entry))
      after-lambda))))
	  </SCHEME>
	  <JAVASCRIPT>
function compile_lambda_expression(exp, target, linkage) {
    const fun_entry = make_label("entry");
    const after_lambda = make_label("after_lambda");
    const lambda_linkage =
            linkage === "next" ? after_lambda : linkage;
    return append_instruction_sequences(
               tack_on_instruction_sequence(
                   end_with_linkage(lambda_linkage,
                       make_instruction_sequence(list("env"), list(target),
                           list(assign(target,
                                       list(op("make_compiled_function"),
                                            label(fun_entry), reg("env")))))),
                   compile_lambda_body(exp, fun_entry)),
               after_lambda);
}
	  </JAVASCRIPT>
	</SNIPPET>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>Compile-lambda</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    The function
	    <JAVASCRIPTINLINE>compile_lambda_expression</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	uses the special combiner
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>tack-on-instruction-sequence</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>tack_on_instruction_sequence</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	(section<SPACE/><REF NAME="sec:combining-instruction-sequences"/>) rather
	than
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>append-instruction-sequences</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>append_instruction_sequences</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	to append the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	body to the <SCHEMEINLINE>lambda</SCHEMEINLINE> expression code, because the
	body is not part of the sequence of instructions that will be executed when
	the combined sequence is entered; rather, it is in the sequence only because
	that was a convenient place to put it.
      </TEXT>

      <TEXT>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>Compile-lambda-body</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    The function
	    <JAVASCRIPTINLINE>compile_lambda_body</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	constructs the code for the body of the
	<SPLITINLINE>
	  <SCHEME>procedure.</SCHEME>
	  <JAVASCRIPT>function.</JAVASCRIPT>
	</SPLITINLINE>
	This code begins with a label for the entry point.  Next come instructions
	that will cause the runtime evaluation environment to switch to the correct
	environment for evaluating the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	body<EMDASH/>namely, the
	<SPLITINLINE><SCHEME>definition</SCHEME></SPLITINLINE>
	environment of the
	<SPLITINLINE>
	  <SCHEME>procedure,</SCHEME>
	  <JAVASCRIPT>function,</JAVASCRIPT>
	</SPLITINLINE>
	extended to include the bindings of the
	<SPLITINLINE>
	  <SCHEME>formal</SCHEME>
	</SPLITINLINE>
	parameters to the arguments
	with which the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	is called.  After this comes the code for the
	
	<SPLITINLINE>
	  <SCHEME>
	    sequence of expressions that makes up the
	  </SCHEME>
	</SPLITINLINE>
	<SPLITINLINE>
	  <SCHEME>procedure body.</SCHEME>
	  <JAVASCRIPT>
            function body, augmented to ensure that it ends with a return statement.
	  </JAVASCRIPT>
	</SPLITINLINE>
	<SPLIT>
	  <SCHEME>
	    The sequence is compiled with linkage return and target
	    <SCHEMEINLINE>val</SCHEMEINLINE> so that it will end by returning from
	    the procedure with the procedure result in
	    <SCHEMEINLINE>val</SCHEMEINLINE>.
	  </SCHEME>
	  <JAVASCRIPT>
            The
            augmented body is compiled with target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> so that its return value will be
            placed in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>.  The linkage descriptor passed to this compilation is
            irrelevant, as it will be ignored.<FOOTNOTE>
            The augmented function body is a sequence ending with a return statement.
            Compilation of a sequence of statements
            uses the linkage <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE> for all its component statements except the last,
            for which it uses the given linkage.
            In this case, the last statement is a return statement, and
            as we will see in section<SPACE/><REF NAME="sec:compiling-combinations"/>,
            return statements always use the
	    <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE> linkage
	    descriptor for their return expressions. Thus all function bodies will end with a
	    <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
	    linkage, not the <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE> we
	    pass as the linkage argument to <JAVASCRIPTINLINE>compile</JAVASCRIPTINLINE> in
	    <JAVASCRIPTINLINE>compile_lambda_body</JAVASCRIPTINLINE>.</FOOTNOTE>
	    Since a linkage argument is required, we arbirarily pick <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>.
	  </JAVASCRIPT>
	</SPLIT>
	<SNIPPET EVAL="no">
	  <NAME>compile_lambda_body</NAME>
	  <REQUIRES>append_return_undefined</REQUIRES>
	  <SCHEME>
      (define (compile-lambda-body exp proc-entry)
      (let ((formals (lambda-parameters exp)))
      (append-instruction-sequences
      (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
            (assign env
                    (op compiled-procedure-env)
                    (reg proc))
            (assign env
                    (op extend-environment)
                    (const ,formals)
                    (reg argl)
                    (reg env))))
      (compile-sequence (lambda-body exp) 'val 'return))))
	  </SCHEME>
	  <JAVASCRIPT>
function compile_lambda_body(exp, fun_entry) {
    const params  = lambda_parameter_symbols(exp);
    return append_instruction_sequences(
        make_instruction_sequence(
            list("env", "fun", "argl"),
            list("env"),
            list(fun_entry,
                 assign("env", list(op("compiled_function_env"),
                                    reg("fun"))),
                 assign("env", list(op("extend_environment"),
                                    constant(params),
                                    reg("argl"),
                                    reg("env"))))),
        compile(append_return_undefined(lambda_body(exp)), "val", "next"));
}
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>

      <SPLIT>
	<JAVASCRIPT>
	  <TEXT>
	    To ensure that every function ends by executing a return statement,
	    <JAVASCRIPTINLINE>compile_lambda_body</JAVASCRIPTINLINE>
	    appends a return statement whose return expression is the literal
	    <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>
	    to the lambda body. To do so, it uses the function <JAVASCRIPTINLINE>append_return_undefined</JAVASCRIPTINLINE>,
	    which constructs the parser<APOS/>s tagged-list representation (from section<SPACE/><REF NAME="sec:representing-expressions"/>) of a 
	    sequence consisting of the body and a <JAVASCRIPTINLINE>return undefined;</JAVASCRIPTINLINE> statement.
	    <SNIPPET EVAL="no">
	      <NAME>append_return_undefined</NAME>
	      <JAVASCRIPT>
function append_return_undefined(body) {
    return list("sequence", list(body,
                                 list("return_statement",
                                      list("literal", undefined))));
}
	      </JAVASCRIPT>
	    </SNIPPET>
	    This simple transformation of lambda bodies is a third way to ensure that a
	    function that does not return explicitly has the return value
	    <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>.
	    In the metacircular evaluator, we used a return-value object, which also played a
	    role in stopping a sequence evaluation.
	    In the explicit-control evaluator, functions that did not return explicitly continued
	    to an entry point that stored <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>
	    in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>.
	    See exercise<SPACE/><REF NAME="ex:append_return_undefined"/> for a more elegant way
	    to handle insertion of return statements.
	    <LABEL NAME="sec:append_return_undefined"/>
	  </TEXT>
	</JAVASCRIPT>
      </SPLIT>

      <EXERCISE>
	<LABEL NAME="ex:dead-code"/>
	Footnote<SPACE/><REF NAME="foot:dead-code"/> explained that the compiler does not
	identify all instances of
	<INDEX>compiler for JavaScript<SUBINDEX>dead code analysis</SUBINDEX></INDEX>
	dead code. What would be required of a compiler to
	detect all instances of dead code?
	<TEXT>
	  Hint: the answer depends on how we define dead code. One possible (and useful)
	  definition is <QUOTE>code following a return statement in a sequence</QUOTE><EMDASH/>but
	  what about code in the consequent
	  branch of <JAVASCRIPTINLINE>if (false) </JAVASCRIPTINLINE><LATEXINLINE>$\ldots$</LATEXINLINE> or
	  code following a
	  call to <JAVASCRIPTINLINE>run_forever()</JAVASCRIPTINLINE> in exercise<SPACE/><REF NAME="ex:halting-theorem"/>?
	</TEXT>
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>

  <SPLIT>
    <JAVASCRIPT>
      <EXERCISE>
        The current design of <JAVASCRIPTINLINE>append_return_undefined</JAVASCRIPTINLINE>
        is very simplistic: it always appends a
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> <JAVASCRIPTINLINE>undefined;</JAVASCRIPTINLINE> to a lambda body, even if there is already a return statement in every execution
	path of the body. Change
        <JAVASCRIPTINLINE>append_return_undefined</JAVASCRIPTINLINE> to insert
        <JAVASCRIPTINLINE>return undefined;</JAVASCRIPTINLINE> at the end of only
	those paths that do not contain a return statement. Test your
        solution on the functions below, substituting any expressions for
        <LATEXINLINE>$e_1$</LATEXINLINE> and
        <LATEXINLINE>$e_2$</LATEXINLINE>
        and any (non-return) statements for
        <LATEXINLINE>$s_1$</LATEXINLINE> and
	<LATEXINLINE>$s_2$</LATEXINLINE>.
        In <JAVASCRIPTINLINE>t1</JAVASCRIPTINLINE>, a return statement should be
	added either at both <JAVASCRIPTINLINE>(*)</JAVASCRIPTINLINE>'s or just at
	<JAVASCRIPTINLINE>(**)</JAVASCRIPTINLINE>.
        In <JAVASCRIPTINLINE>t2</JAVASCRIPTINLINE> and
	<JAVASCRIPTINLINE>t4</JAVASCRIPTINLINE>, a return statement should be added
	at one of the <JAVASCRIPTINLINE>(*)</JAVASCRIPTINLINE>'s.
        In <JAVASCRIPTINLINE>t3</JAVASCRIPTINLINE>, no return statement should be added.
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
function t1(b) {    function t2(b) {    function t3(b) {    function t4(b1, b2) {
    if (b) {            if (b) {            if (b) {            if (b1) {
        $s_1~~$                 return $e_1;~$          return $e_1;~$          return $e_1$;
        (*)                                                     } else {
    } else {            } else {            } else {                if (b2) {
        $s_2~~$                 $s_1~~$                 return $e_2$;              $s_1$
        (*)                 (*)                                         (*)
    }                   }                   }                       } else {
    (**)                (*)                                             return $e_2$;
}                   }                   }                           }
                                                                    (*)
                                                                }
                                                                (*)
                                                            }
	  </JAVASCRIPT>
	</SNIPPET>
	<LABEL NAME="ex:append_return_undefined"/>
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>
</SUBSECTION>
