<SUBSECTION>
  <NAME>
    Local State Variables
  </NAME>

  <LABEL NAME="sec:local-state-variables"/>
  <INDEX>local state variable<OPEN/></INDEX>
  <INDEX>state variable<SUBINDEX>local<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    To illustrate what we mean by having a computational object with
    <INDEX>object(s)<SUBINDEX>with time-varying state</SUBINDEX></INDEX>
    time-varying state, let us model the situation of withdrawing money
    from a
    <INDEX>bank account</INDEX>
    bank account.  We will do this using a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SCHEMEINLINE>withdraw</SCHEMEINLINE>, which takes as argument an
    <SCHEMEINLINE>amount</SCHEMEINLINE> to be withdrawn.
    If there is enough money in the account to accommodate the withdrawal,
    then <SCHEMEINLINE>withdraw</SCHEMEINLINE> should return the balance
    remaining after the withdrawal.  Otherwise,
    <SCHEMEINLINE>withdraw</SCHEMEINLINE> should return the message
    <EM>Insufficient funds.</EM> For example, if we begin with <DOLLAR/>100
    in the account, we should obtain the following sequence of responses
    using
    <SCHEMEINLINE>withdraw</SCHEMEINLINE>:
    <SNIPPET EVAL="yes">
      <NAME>withdraw_example</NAME>
      <EXPECTED>75</EXPECTED>
      <REQUIRES>withdraw</REQUIRES>
      <SCHEME>
(withdraw 25)
      </SCHEME>
      <SCHEMEOUTPUT>
75
      </SCHEMEOUTPUT>
      <PYTHON>
withdraw(25);
      </PYTHON>
      <PYTHON_OUTPUT>
75
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>withdraw_example2</NAME>
      <REQUIRES>withdraw</REQUIRES>
      <REQUIRES>withdraw_example</REQUIRES>
      <EXPECTED>50</EXPECTED>
      <SCHEME>
(withdraw 25)
      </SCHEME>
      <SCHEMEOUTPUT>
50
      </SCHEMEOUTPUT>
      <PYTHON>
withdraw(25);
      </PYTHON>
      <PYTHON_OUTPUT>
50
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>withdraw_example3</NAME>
      <REQUIRES>withdraw</REQUIRES>
      <REQUIRES>withdraw_example</REQUIRES>
      <REQUIRES>withdraw_example2</REQUIRES>
      <EXPECTED>'Insufficient funds'</EXPECTED>
      <SCHEME>
(withdraw 60)
      </SCHEME>
      <SCHEMEOUTPUT>
"Insufficient funds"
      </SCHEMEOUTPUT>
      <PYTHON>
withdraw(60);
      </PYTHON>
      <PYTHON_OUTPUT>
"Insufficient funds"
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>withdraw_example4</NAME>
      <REQUIRES>withdraw</REQUIRES>
      <REQUIRES>withdraw_example</REQUIRES>
      <REQUIRES>withdraw_example2</REQUIRES>
      <REQUIRES>withdraw_example3</REQUIRES>
      <EXPECTED>35</EXPECTED>
      <SCHEME>
(withdraw 15)
      </SCHEME>
      <SCHEMEOUTPUT>
35
      </SCHEMEOUTPUT>
      <PYTHON>
withdraw(15);
      </PYTHON>
      <PYTHON_OUTPUT>
35
      </PYTHON_OUTPUT>
    </SNIPPET>
    Observe that the expression
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(withdraw 25)</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>withdraw(25)</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    evaluated twice, yields different values.  This is a new kind of
    behavior for a
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
    <PYTHON>function.</PYTHON></SPLITINLINE>
    Until now, all our
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>JavaScript functions</PYTHON>
    </SPLITINLINE>
    could be viewed as specifications for computing mathematical functions.
    A call to a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    computed the value of the function applied to the given arguments,
    and two calls to the same
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    with the same arguments always produced the same
    result.<FOOTNOTE>Actually, this is not quite true. One exception was the 
    <INDEX><USE>math_random</USE> (primitive function)<SUBINDEX>assignment needed for</SUBINDEX></INDEX>
    <INDEX>random-number generator</INDEX>
    random-number generator
    in section<SPACE/><REF NAME="sec:primality"/>.  Another exception
    involved the
    <INDEX>operation-and-type table<SUBINDEX>assignment needed for</SUBINDEX></INDEX>
    operation/type tables we introduced in
    section<SPACE/><REF NAME="sec:data-directed"/>, where the values of two
    calls to <SCHEMEINLINE>get</SCHEMEINLINE> with the same arguments
    depended on intervening calls to <SCHEMEINLINE>put</SCHEMEINLINE>.
    On the other hand, until we introduce assignment, we have no way to
    create such
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    ourselves.</FOOTNOTE>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
        To implement <SCHEMEINLINE>withdraw</SCHEMEINLINE>, we can use a
	variable <SCHEMEINLINE>balance</SCHEMEINLINE> to indicate the balance of
	money in the account and define <SCHEMEINLINE>withdraw</SCHEMEINLINE>
	as a
        <SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
        that accesses <SCHEMEINLINE>balance</SCHEMEINLINE>.
      </SCHEME>
      <PYTHON>
	So far, all our names have been <EM>immutable</EM>. 
	When a function was applied, the values that its parameters
	referred to never changed, and once a declaration was evaluated,
	the declared name never changed its value.
        To implement functions like
	<SCHEMEINLINE>withdraw</SCHEMEINLINE>, we introduce
	<INDEX>variable<SUBINDEX>declaration</SUBINDEX></INDEX>
	<INDEX>syntactic forms<SUBINDEX>variable declaration</SUBINDEX><FRAGILE/></INDEX>
	<INDEX>declaration<SUBINDEX><ORDER>variable</ORDER>of variable (<PYTHONINLINE>let</PYTHONINLINE>)</SUBINDEX></INDEX>
	<EM>variable declarations</EM>, which use the keyword
	<INDEX><USE>let</USE> (keyword)</INDEX>
	<INDEX>keywords<SUBINDEX><ORDER>let</ORDER><USE>let</USE></SUBINDEX></INDEX>
	<PYTHONINLINE>let</PYTHONINLINE>, in addition to constant
	declarations, which use the keyword
	<PYTHONINLINE>const</PYTHONINLINE>.
        We can declare a variable
	<PYTHONINLINE>balance</PYTHONINLINE>
	to indicate the balance of money	
	in the account and define
	<SCHEMEINLINE>withdraw</SCHEMEINLINE> as a function that accesses
	<SCHEMEINLINE>balance</SCHEMEINLINE>.
      </PYTHON>
    </SPLIT>
    The <SCHEMEINLINE>withdraw</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    checks to see if <SCHEMEINLINE>balance</SCHEMEINLINE> is at least as large
    as the requested <SCHEMEINLINE>amount</SCHEMEINLINE>.  If so,
    <SCHEMEINLINE>withdraw</SCHEMEINLINE> decrements
    <SCHEMEINLINE>balance</SCHEMEINLINE> by <SCHEMEINLINE>amount</SCHEMEINLINE>
    and returns the new value of <SCHEMEINLINE>balance</SCHEMEINLINE>. Otherwise,
    <SCHEMEINLINE>withdraw</SCHEMEINLINE> returns the <EM>Insufficient funds</EM>
    message. Here are the
    <SPLITINLINE>
      <SCHEME>definitions</SCHEME>
      <PYTHON>declarations</PYTHON>
    </SPLITINLINE>
    of <SCHEMEINLINE>balance</SCHEMEINLINE> and
    <SCHEMEINLINE>withdraw</SCHEMEINLINE>:
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>withdraw</DECLARATION></INDEX>
      <NAME>withdraw</NAME>
      <EXAMPLE>withdraw_example</EXAMPLE>
      <SCHEME>
(define balance 100)

(define (withdraw amount)
   (if (&gt;= balance amount)
     (begin (set! balance (- balance amount))
            balance)
     "Insufficient funds"))
      </SCHEME>
      <PYTHON>
let balance = 100;

function withdraw(amount) {
    if (balance &gt;= amount) {
        balance = balance - amount;
        return balance;
    } else {
        return "Insufficient funds";
    }
}
      </PYTHON>
    </SNIPPET>
    Decrementing <SCHEMEINLINE>balance</SCHEMEINLINE> is accomplished by the 
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
    <PYTHON>expression statement</PYTHON></SPLITINLINE>
    <DONT_BREAK_PAGE/>
    <SNIPPET EVAL="no">
      <SCHEME>
(set! balance (- balance amount))
      </SCHEME>
      <PYTHON>
balance = balance - amount;
      </PYTHON>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
        This uses the <SCHEMEINLINE>set!</SCHEMEINLINE> special form, whose
	syntax is
	<SNIPPET EVAL="no" LATEX="yes">
	  <SCHEME>
(set! $\langle \textit{name} \rangle$ $\langle \textit{new-value}\rangle$)
	  </SCHEME>
	</SNIPPET>
      </SCHEME>
      <PYTHON>
	The syntax of
	<INDEX>assignment</INDEX>
	<INDEX>assignment<SUBINDEX>assignment expression</SUBINDEX></INDEX>
	<INDEX>variable<SUBINDEX>assignment to</SUBINDEX></INDEX>
	<INDEX>syntactic forms<SUBINDEX>assignment</SUBINDEX></INDEX>
	<INDEX><ORDER>=</ORDER><PYTHONINLINE>=</PYTHONINLINE></INDEX>
	<EM>assignment</EM> expressions is
    <SNIPPET EVAL="no" LATEX="yes">
      <PYTHON>
<META>name</META> = <META>new-value</META>
      </PYTHON>
    </SNIPPET>
      </PYTHON>
    </SPLIT>
    Here
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{name} \rangle$</LATEXINLINE>
	is a symbol 
      </SCHEME>
      <PYTHON>
	<META>name</META>
	has been declared with
	<INDEX>variable<SUBINDEX>parameter as</SUBINDEX></INDEX>
	<PYTHONINLINE>let</PYTHONINLINE> or
	as a
	<INDEX>parameters<SUBINDEX><ORDER>variable</ORDER>as variables</SUBINDEX></INDEX>
	function parameter
      </PYTHON>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{new-value} \rangle$</LATEXINLINE>
      </SCHEME>
      <PYTHON>
	<META>new-value</META>
      </PYTHON>
    </SPLITINLINE>
    is any expression.  
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Set!</SCHEMEINLINE></SCHEME>
      <PYTHON>The assignment</PYTHON>
    </SPLITINLINE> 
    changes
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{name} \rangle$</LATEXINLINE>
      </SCHEME>
      <PYTHON>
	<META>name</META>
      </PYTHON>
    </SPLITINLINE>
    so that its value is the
    result obtained by evaluating
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{new-value}\rangle$</LATEXINLINE>.
      </SCHEME>
      <PYTHON>
	<META>new-value</META>.
      </PYTHON>
    </SPLITINLINE>
    In the case at hand, we are changing <SCHEMEINLINE>balance</SCHEMEINLINE> so
    that its new value will be the result of subtracting
    <SCHEMEINLINE>amount</SCHEMEINLINE> from the previous value of
    <SCHEMEINLINE>balance</SCHEMEINLINE>.<FOOTNOTE>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>unspecified values<SUBINDEX><ORDER>set</ORDER><SCHEMEINLINE>set!</SCHEMEINLINE></SUBINDEX></INDEX>
	The value of a <SCHEMEINLINE>set!</SCHEMEINLINE> expression is
	implementation-dependent. <SCHEMEINLINE>Set!</SCHEMEINLINE> should be
	used only for its effect, not for its value.
	<INDEX>naming conventions<SUBINDEX><ORDER>!</ORDER><SCHEMEINLINE>!</SCHEMEINLINE> for assignment and mutation</SUBINDEX></INDEX>
	<INDEX>exclamation point in names</INDEX>
	<INDEX><USE>!</USE><SUBINDEX>in names</SUBINDEX></INDEX> 
	The name <SCHEMEINLINE>set!</SCHEMEINLINE> reflects a naming convention
	used in Scheme: Operations that change the values of variables (or that
	change data structures, as we will see in
	section<SPACE/><REF NAME="sec:mutable-data"/>) are given names that end
	with an exclamation point.  This is similar to the convention of
	designating predicates by names that end with a question mark.
      </SCHEME>
      <PYTHON>
	The
	<INDEX>assignment<SUBINDEX>value of</SUBINDEX></INDEX>
	value of an assignment is the value being assigned to the name.
	Assignment expression statements
	<INDEX>assignment<SUBINDEX>constant/variable declaration vs.</SUBINDEX></INDEX>
	look similar to and should not be
	confused with constant and variable declarations of the form
	<SNIPPET EVAL="no" LATEX="yes">
          <PYTHON>
const $name$ = $value$;
          </PYTHON>
	</SNIPPET>
	and
	<SNIPPET EVAL="no" LATEX="yes">
          <PYTHON>
let $name$ = $value$;
          </PYTHON>
	</SNIPPET>
	in which a newly declared <META>name</META>
	is associated with a <META>value</META>. 
	Assignment expressions look similar to and should not be confused with
	<INDEX>assignment<SUBINDEX>equality test vs.</SUBINDEX></INDEX>
	expressions of the form 
	<SNIPPET EVAL="no" LATEX="yes">
          <PYTHON>
$expression_1$ === $expression_2$
          </PYTHON>
	</SNIPPET>
	which evaluate to <PYTHONINLINE>true</PYTHONINLINE>
	if <META>expression</META><LATEXINLINE>$_1$</LATEXINLINE> evaluates to the
	same value as <META>expression</META><LATEXINLINE>$_2$</LATEXINLINE> and to
	<PYTHONINLINE>false</PYTHONINLINE> otherwise.
      </PYTHON>
    </SPLITINLINE></FOOTNOTE>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
	<INDEX>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)<SUBINDEX>begin</SUBINDEX></INDEX>
	<SCHEMEINLINE>Withdraw</SCHEMEINLINE> also uses the
	<SCHEMEINLINE>begin</SCHEMEINLINE> 
	special form to cause two expressions to be evaluated in the case where
	the <SCHEMEINLINE>if</SCHEMEINLINE> test is true: first decrementing 
	<SCHEMEINLINE>balance</SCHEMEINLINE> and then returning the value of 
	<SCHEMEINLINE>balance</SCHEMEINLINE>. In general, evaluating the
	expression
	<SNIPPET EVAL="no">
          <SCHEME>
(begin $\textit{exp}_{1}$ $\textit{exp}_{2}$ $\ldots$ $\textit{exp}_{k}$)
          </SCHEME>
	</SNIPPET>
	causes the expressions <LATEXINLINE>$\textit{exp}_{1}$</LATEXINLINE>
	through <LATEXINLINE>$\textit{exp}_{k}$</LATEXINLINE> to be evaluated in
	sequence and the value of the final expression
	<LATEXINLINE>$\textit{exp}_{k}$</LATEXINLINE> to be returned as the
	value of the entire <SCHEMEINLINE>begin</SCHEMEINLINE>
	form.<FOOTNOTE>We have already used 
	<INDEX>begin<SUBINDEX>implicit in consequent of conditional</SUBINDEX></INDEX>
	    <SCHEMEINLINE>cond</SCHEMEINLINE> and in 
	<SCHEMEINLINE>begin</SCHEMEINLINE> implicitly in our programs, because in
	Scheme the body of a procedure can be a sequence of expressions.  Also,
	the <LATEXINLINE>consequent</LATEXINLINE> part of each clause in a
	<INDEX>cond<SUBINDEX><ORDER>implicit begin</ORDER>implicit <SCHEMEINLINE>begin</SCHEMEINLINE> in consequent</SUBINDEX></INDEX>
	<SCHEMEINLINE>cond</SCHEMEINLINE> expression can be a sequence of
	expressions rather than a single expression.</FOOTNOTE>
      </SCHEME>
      <PYTHON>
	The function <PYTHONINLINE>withdraw</PYTHONINLINE> also uses a
	<INDEX>sequence of statements</INDEX>
	<EM>sequence of statements</EM> to cause two statements to be evaluated
	in the case where the <PYTHONINLINE>if</PYTHONINLINE> test is
	true: first decrementing  <PYTHONINLINE>balance</PYTHONINLINE>
	and then returning the value of
	<PYTHONINLINE>balance</PYTHONINLINE>.  
	In general, executing a sequence
	<SNIPPET EVAL="no" LATEX="yes">
          <PYTHON>
<META>stmt</META>$_{1}$ <META>stmt</META>$_{2} \ldots$<META>stmt</META>$_{n}$
          </PYTHON>
        </SNIPPET>
        causes the statements <META>stmt</META><LATEXINLINE>$_{1}$</LATEXINLINE>
	through
	<META>stmt</META><LATEXINLINE>$_{n}$</LATEXINLINE> to be evaluated in
	sequence.<FOOTNOTE>We have already used 
        <INDEX>sequence of statements<SUBINDEX><ORDER>block</ORDER>in block</SUBINDEX></INDEX>
        sequences implicitly in our programs, because in
	JavaScript the body block
	of a function can contain a sequence of function declarations
	followed by a return statement, not
	just a single return statement,
	as discussed in
	section<SPACE/><REF NAME="sec:block-structure"/>.</FOOTNOTE>
	<COMMENT>
	  In JavaScript, the return value of functions is determined by
	  return statements, which
	  can appear in the first statement of a sequence. To make matters
	  even more complex, at JavaScript top level, the value of a sequence is
	  the value of the first component, if the second component is not
	  value-producing. Thus in JavaScript,
	  <SNIPPET EVAL="no">
	    <PYTHON>
1; const x = 2;
	    </PYTHON>
	  </SNIPPET>
	  evaluates to the value 1. We decide to ignore the subtleties of the
	  JavaScript top level here. The return value of non-top-level sequences
	  are determined by the placement of return statements, which we will
	  explain later.
	</COMMENT>
      </PYTHON>
    </SPLIT>
  </TEXT>

  <TEXT>
    Although <SCHEMEINLINE>withdraw</SCHEMEINLINE> works as desired, the
    variable <SCHEMEINLINE>balance</SCHEMEINLINE> presents a problem.  As
    specified above, <SCHEMEINLINE>balance</SCHEMEINLINE> is a name defined
    in the
    <SPLITINLINE>
      <SCHEME>global</SCHEME>
      <PYTHON>program</PYTHON>
      </SPLITINLINE> environment and is freely accessible to be examined or
      modified by any
      <SPLITINLINE>
	<SCHEME>procedure.</SCHEME>
	<PYTHON>function.</PYTHON>
      </SPLITINLINE>
      It would be much better if we could somehow make
      <SCHEMEINLINE>balance</SCHEMEINLINE> internal to
      <SCHEMEINLINE>withdraw</SCHEMEINLINE>, so that
      <SCHEMEINLINE>withdraw</SCHEMEINLINE> would be the only
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<PYTHON>function</PYTHON>
      </SPLITINLINE>
      that could access <SCHEMEINLINE>balance</SCHEMEINLINE> directly and
      any other
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<PYTHON>function</PYTHON>
      </SPLITINLINE>
      could access <SCHEMEINLINE>balance</SCHEMEINLINE> only indirectly
      (through calls to <SCHEMEINLINE>withdraw</SCHEMEINLINE>).  This would
      more accurately model the notion that
      <SCHEMEINLINE>balance</SCHEMEINLINE> is a local state variable used by
      <SCHEMEINLINE>withdraw</SCHEMEINLINE> to keep track of the state of the
      account.
  </TEXT>

  <DO_BREAK_PAGE/>
  <TEXT>
    We can make <SCHEMEINLINE>balance</SCHEMEINLINE> internal to
    <SCHEMEINLINE>withdraw</SCHEMEINLINE> by rewriting the definition as
    follows:
    <SNIPPET HIDE="yes">
      <NAME>new_withdraw_example</NAME>
      <PYTHON>
new_withdraw(60);
new_withdraw(60);
      </PYTHON>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>new_withdraw</DECLARATION></INDEX>
      <NAME>new_withdraw</NAME>
      <EXAMPLE>new_withdraw_example</EXAMPLE>
      <SCHEME>
(define new-withdraw
  (let ((balance 100))
    (lambda (amount)
      (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))))
      </SCHEME>v
      <PYTHON>
function make_withdraw_balance_100() {
    let balance = 100;
    return amount => {
               if (balance &gt;= amount) {
                   balance = balance - amount;
                   return balance;
               } else {
                   return "Insufficient funds";
               }
           };
}
const new_withdraw = make_withdraw_balance_100();
      </PYTHON>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
        What we have done here is use <SCHEMEINLINE>let</SCHEMEINLINE> to
	establish an environment with a local variable
	<SCHEMEINLINE>balance</SCHEMEINLINE>, bound to the initial value 100.
        Within this local environment, we use
	<SCHEMEINLINE>lambda</SCHEMEINLINE> to create a procedure that takes
	<SCHEMEINLINE>amount</SCHEMEINLINE> as an argument and behaves like our
        previous <SCHEMEINLINE>withdraw</SCHEMEINLINE> procedure.  This
        procedure<EMDASH/>returned as the result of evaluating the
	<SCHEMEINLINE>let</SCHEMEINLINE> expression<EMDASH/>is
	<SCHEMEINLINE>new-withdraw</SCHEMEINLINE>,
        which behaves in precisely the same way as
	<SCHEMEINLINE>withdraw</SCHEMEINLINE> but whose variable
	<SCHEMEINLINE>balance</SCHEMEINLINE> is not accessible by any other
        procedure.<FOOTNOTE>In programming-language jargon, the variable
	<SCHEMEINLINE>balance</SCHEMEINLINE> is said to be 
        <INDEX>encapsulated name</INDEX>
        <INDEX>name<SUBINDEX>encapsulated</SUBINDEX></INDEX>
        <EM>encapsulated</EM> within the
	<SCHEMEINLINE>new-withdraw</SCHEMEINLINE>
        procedure. Encapsulation reflects the general system-design principle
	known as the 
        <INDEX>hiding principle</INDEX>
        <INDEX>modularity<SUBINDEX>hiding principle</SUBINDEX></INDEX>
        <EM>hiding principle</EM>: One can make a system more modular and robust
	by protecting parts of the system from each other; that is, by providing
	information access only to those parts of the system that have a
	<QUOTE>need to know.</QUOTE></FOOTNOTE>
      </SCHEME>
      <PYTHON>
        What we have done here is use <PYTHONINLINE>let</PYTHONINLINE>
	to establish an environment with a local variable
	<PYTHONINLINE>balance</PYTHONINLINE>, bound to the initial
	value 100. Within this local environment, we use a lambda
	expression<FOOTNOTE>Blocks as bodies of lambda expressions were
	introduced in section<SPACE/><REF NAME="sec:graphics"/>.</FOOTNOTE> to
	create a function that takes <PYTHONINLINE>amount</PYTHONINLINE>
	as an argument and behaves like our previous
	<PYTHONINLINE>withdraw</PYTHONINLINE> function.  This
	function<EMDASH/>returned as the result of evaluating the body of the
	<PYTHONINLINE>make_withdraw_balance_100</PYTHONINLINE>
	function<EMDASH/>behaves in precisely the same way as
	<PYTHONINLINE>withdraw</PYTHONINLINE>, but its variable
	<PYTHONINLINE>balance</PYTHONINLINE> is not accessible by any
	other function.<FOOTNOTE>In programming-language jargon, the variable
	<PYTHONINLINE>balance</PYTHONINLINE> is said to be 
        <INDEX>encapsulated name</INDEX>
        <INDEX>name<SUBINDEX>encapsulated</SUBINDEX></INDEX>
        <EM>encapsulated</EM> within the
	<PYTHONINLINE>new_withdraw</PYTHONINLINE> function.
	Encapsulation reflects the general system-design principle known as the 
        <INDEX>hiding principle</INDEX>
        <INDEX>modularity<SUBINDEX>hiding principle</SUBINDEX></INDEX>
        <EM>hiding principle</EM>: One can
        make a system more modular and robust by protecting parts of the
        system from each other; that is, by providing information access only
        to those parts of the system that have a <QUOTE>need to
	know.</QUOTE></FOOTNOTE>
      </PYTHON>
    </SPLIT>
  </TEXT>

  <SHORT_PAGE lines="5"/>
  <TEXT>
    Combining 
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>set!</SCHEMEINLINE> 
        with local variables 
      </SCHEME>
      <PYTHON>
        assignments with variable declarations
      </PYTHON>
    </SPLITINLINE>
    is the general programming
    technique we will use for constructing computational objects with
    local state.  Unfortunately, using this technique raises a serious
    problem: When we first introduced
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <PYTHON>functions,</PYTHON>
    </SPLITINLINE>
    we also introduced the substitution model of evaluation
    (section<SPACE/><REF NAME="sec:substitution-model"/>) to provide an
    interpretation of what
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    application means.  We said that applying a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function whose body is a return statement</PYTHON>
    </SPLITINLINE>
    should be interpreted as evaluating the
    <SPLITINLINE>
      <SCHEME>body of the procedure</SCHEME>
      <PYTHON>return expression of the function</PYTHON>
    </SPLITINLINE>
    with the
    <SPLITINLINE>
      <SCHEME>formal</SCHEME>
    </SPLITINLINE>
    parameters replaced by their values.
    <SPLITINLINE>
      <PYTHON>
	For functions with more complex
	bodies, we need to evaluate the whole body with the
	parameters replaced by their values.
      </PYTHON>
    </SPLITINLINE>
    The trouble is that,
    as soon as we introduce assignment into our language, substitution is no
    longer an adequate model of
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    application.  (We will see why this is so in
    section<SPACE/><REF NAME="sec:costs-of-assignment"/>.)  As a consequence, we
    technically have at this point no way to understand why the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-withdraw</SCHEMEINLINE></SCHEME>
      <PYTHON>
	<PYTHONINLINE>new_withdraw</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    behaves as claimed above.  In order to really understand a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    such as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-withdraw</SCHEMEINLINE>,</SCHEME>
      <PYTHON>
	<PYTHONINLINE>new_withdraw</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    we will need to develop a new model of
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    application.  In section<SPACE/><REF NAME="sec:environment-model"/> we will
    introduce such a model, together with an explanation of 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set!</SCHEMEINLINE> and local variables.</SCHEME>
      <PYTHON>assignments and variable declarations.</PYTHON>
    </SPLITINLINE>
    First, however, we examine some variations on the theme established by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-withdraw</SCHEMEINLINE>.</SCHEME>
      <PYTHON><PYTHONINLINE>new_withdraw</PYTHONINLINE>.
      </PYTHON>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <PYTHON>
	Parameters of functions as well as names declared with
	<PYTHONINLINE>let</PYTHONINLINE> are
	<INDEX>parameters<SUBINDEX><ORDER>variable</ORDER>as variables</SUBINDEX></INDEX>
	variables.
      </PYTHON>
    </SPLITINLINE>
    The following
    <SPLITINLINE>
      <SCHEME>
	procedure, <SCHEMEINLINE>make-withdraw</SCHEMEINLINE>,
      </SCHEME>
      <PYTHON>
	function, <PYTHONINLINE>make_withdraw</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    creates <QUOTE>withdrawal processors.</QUOTE>
    The <SPLITINLINE><SCHEME>formal</SCHEME></SPLITINLINE> parameter
    <SCHEMEINLINE>balance</SCHEMEINLINE> in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-withdraw</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_withdraw</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    specifies the initial amount of money in the
    account.<FOOTNOTE>
    <LABEL NAME="foot:make_withdraw"/>
    In contrast with
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>new-withdraw</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<SCHEMEINLINE>make_withdraw_balance_100</SCHEMEINLINE>
      </PYTHON>
    </SPLITINLINE>
    above, we do not have to use
    <SCHEMEINLINE>let</SCHEMEINLINE>
    to make <SCHEMEINLINE>balance</SCHEMEINLINE> a local variable, since
    <SPLITINLINE>
      <SCHEME>formal</SCHEME>
    </SPLITINLINE>
    parameters are already
    local. This will be clearer after the discussion of the environment
    model of evaluation in
    section<SPACE/><REF NAME="sec:environment-model"/>.
    (See also
    exercise<SPACE/><REF NAME="ex:local-state-variable"/>.)</FOOTNOTE>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_withdraw</DECLARATION></INDEX> 
      <NAME>make_withdraw</NAME>
      <EXAMPLE>make_withdraw_define</EXAMPLE>
      <SCHEME>
(define (make-withdraw balance)
   (lambda (amount)
      (if (&gt;= balance amount)
         (begin (set! balance (- balance amount))
                balance)
         "Insufficient funds")))
      </SCHEME>
      <PYTHON>
function make_withdraw(balance) {
    return amount => {
               if (balance &gt;= amount) {
                   balance = balance - amount;
                   return balance;
               } else {
                   return "Insufficient funds";
               }
           };
}
      </PYTHON>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-withdraw</SCHEMEINLINE></SCHEME>
      <PYTHON>
	The function <PYTHONINLINE>make_withdraw</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    can be used as follows to create two objects <SCHEMEINLINE>W1</SCHEMEINLINE>
    and<SPACE/><SCHEMEINLINE>W2</SCHEMEINLINE>:
    <SNIPPET EVAL="yes">
      <NAME>make_withdraw_define</NAME>
      <REQUIRES>make_withdraw</REQUIRES>
      <SCHEME>
(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))
      </SCHEME>
      <PYTHON>
const W1 = make_withdraw(100);
const W2 = make_withdraw(100);
      </PYTHON>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_withdraw_example1</NAME>
      <REQUIRES>make_withdraw_define</REQUIRES>
      <EXPECTED>50</EXPECTED>
      <SCHEME>
(W1 50)
      </SCHEME>
      <SCHEMEOUTPUT>
50
      </SCHEMEOUTPUT>
      <PYTHON>
W1(50);
      </PYTHON>
      <PYTHON_OUTPUT>
50
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_withdraw_example1</REQUIRES>
      <NAME>make_withdraw_example2</NAME>
      <EXPECTED>30</EXPECTED>
      <SCHEME>
(W2 70)
      </SCHEME>
      <SCHEMEOUTPUT>
30
      </SCHEMEOUTPUT>
      <PYTHON>
W2(70);
      </PYTHON>
      <PYTHON_OUTPUT>
30
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_withdraw_example3</NAME>
      <REQUIRES>make_withdraw_example2</REQUIRES>
      <EXPECTED>'Insufficient funds'</EXPECTED>
      <SCHEME>
(W2 40)
      </SCHEME>
      <SCHEMEOUTPUT>
"Insufficient funds"
      </SCHEMEOUTPUT>
      <PYTHON>
W2(40);
      </PYTHON>
      <PYTHON_OUTPUT>
"Insufficient funds"
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_withdraw_example4</NAME>
      <REQUIRES>make_withdraw_example3</REQUIRES>
      <EXPECTED>10</EXPECTED>
      <SCHEME>
(W1 40)
      </SCHEME>
      <SCHEMEOUTPUT>
10
      </SCHEMEOUTPUT>
      <PYTHON>
W1(40); 
      </PYTHON>
      <PYTHON_OUTPUT>
10
      </PYTHON_OUTPUT>
    </SNIPPET>
    Observe that <SCHEMEINLINE>W1</SCHEMEINLINE> and 
    <SCHEMEINLINE>W2</SCHEMEINLINE> are completely independent objects, each
    with its own local state variable <SCHEMEINLINE>balance</SCHEMEINLINE>.
    Withdrawals from one do not affect the other.
  </TEXT>

  <TEXT>
    We can also create objects that handle
    <INDEX><DECLARATION>deposit</DECLARATION> message for bank account</INDEX>
    deposits as well as
    withdrawals, and thus we can represent simple bank accounts.  Here is
    a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    that returns a <QUOTE>bank-account object</QUOTE> with a specified initial
    balance:
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_account</DECLARATION></INDEX> 
      <NAME>make_account</NAME>
      <EXAMPLE>make_account_example_my</EXAMPLE>
      <SCHEME>
(define (make-account balance)
   (define (withdraw amount)
      (if (&gt;= balance amount)
         (begin (set! balance (- balance amount))
                balance)
            "Insufficient funds"))
   (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
   (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request - - MAKE-ACCOUNT"
                   m))))
   dispatch)
      </SCHEME>
      <PYTHON>
function make_account(balance) {
    function withdraw(amount) {
        if (balance &gt;= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "Insufficient funds";
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    function dispatch(m) {
        return m === "withdraw"
               ? withdraw
               : m === "deposit"
               ? deposit
               : error(m, "unknown request -- make_account");
    }
    return dispatch;
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_account_example_my</NAME>
      <SCHEME>
(define acc (make-account 100))
((acc 'withdraw) 50)
      </SCHEME>
      <PYTHON>
const acc = make_account(100);

acc("withdraw")(50);
      </PYTHON>
    </SNIPPET>
    Each call to <SCHEMEINLINE>make_account</SCHEMEINLINE> sets up an
    environment with a local state variable <SCHEMEINLINE>balance</SCHEMEINLINE>.
    Within this environment, <SCHEMEINLINE>make_account</SCHEMEINLINE> defines
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    <SCHEMEINLINE>deposit</SCHEMEINLINE> and
    <SCHEMEINLINE>withdraw</SCHEMEINLINE> that access
    <SCHEMEINLINE>balance</SCHEMEINLINE> and an additional
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SCHEMEINLINE>dispatch</SCHEMEINLINE>
    that takes a <QUOTE>message</QUOTE> as input and returns one of the two local
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <PYTHON>functions.</PYTHON>
    </SPLITINLINE>
    The <SCHEMEINLINE>dispatch</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    itself is returned as the value that represents the bank-account object.
    This is precisely the 
    <INDEX>message passing<SUBINDEX>in bank account</SUBINDEX></INDEX>
    <EM>message-passing</EM> style of programming that we saw in
    section<SPACE/><REF NAME="sec:data-directed"/>, although here we are using
    it in conjunction with the ability to modify local variables.
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Make-account</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	The function
	<PYTHONINLINE>make_account</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    can be used as follows:
    <SNIPPET EVAL="yes">
      <NAME>make_account_example</NAME>
      <REQUIRES>make_account</REQUIRES>
      <SCHEME>
            (define acc (make-account 100))
      </SCHEME>
      <PYTHON>
const acc = make_account(100);
      </PYTHON>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_account_example1</NAME>
      <REQUIRES>make_account_example</REQUIRES>
      <EXPECTED>50</EXPECTED>
      <SCHEME>
((acc 'withdraw) 50)
      </SCHEME>
      <SCHEMEOUTPUT>
50
      </SCHEMEOUTPUT>
      <PYTHON>
acc("withdraw")(50);
      </PYTHON>
      <PYTHON_OUTPUT>
50
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account_example1</REQUIRES>
      <NAME>make_account_example2</NAME>
      <EXPECTED>'Insufficient funds'</EXPECTED>
      <SCHEME>
((acc 'withdraw) 60)
      </SCHEME>
      <SCHEMEOUTPUT>
"Insufficient funds"
      </SCHEMEOUTPUT>
      <PYTHON>
acc("withdraw")(60);
      </PYTHON>
      <PYTHON_OUTPUT>
"Insufficient funds"
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account_example2</REQUIRES>
      <NAME>make_account_example3</NAME>
      <EXPECTED>90</EXPECTED>
      <SCHEME>
((acc 'deposit) 40)
      </SCHEME>
      <SCHEMEOUTPUT>
90
      </SCHEMEOUTPUT>
      <PYTHON>
acc("deposit")(40);
      </PYTHON>
      <PYTHON_OUTPUT>
90
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account_example3</REQUIRES>
      <NAME>make_account_example4</NAME>
      <EXPECTED>30</EXPECTED>
      <SCHEME>
((acc 'withdraw) 60)
      </SCHEME>
      <SCHEMEOUTPUT>
30
      </SCHEMEOUTPUT>
      <PYTHON>
acc("withdraw")(60);
      </PYTHON>
      <PYTHON_OUTPUT>
30
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SHORT_PAGE lines="4"/>Each call to <SCHEMEINLINE>acc</SCHEMEINLINE> returns the locally defined
    <SCHEMEINLINE>deposit</SCHEMEINLINE> or <SCHEMEINLINE>withdraw</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <PYTHON>function,</PYTHON>
    </SPLITINLINE>
    which is then applied to the specified <SCHEMEINLINE>amount</SCHEMEINLINE>.
    As was the case with
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>make-withdraw</SCHEMEINLINE>, another
	call to <SCHEMEINLINE>make-account</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>make_withdraw</PYTHONINLINE>, another
	call to <PYTHONINLINE>make_account</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account</REQUIRES>
      <SCHEME>
(define acc2 (make-account 100))
      </SCHEME>
      <PYTHON>
const acc2 = make_account(100);
      </PYTHON>
    </SNIPPET>
    will produce a completely separate account object, which maintains its
    own local <SCHEMEINLINE>balance</SCHEMEINLINE>.
  </TEXT>

  <EXERCISE>
    <LABEL NAME="ex:make-accumulator"/>
    An 
    <INDEX>accumulator</INDEX>
    <EM>accumulator</EM> is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    that is called repeatedly with a single numeric argument and accumulates its
    arguments into a sum. Each time it is called, it returns the currently
    accumulated sum. Write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <INDEX><USE>make_accumulator</USE></INDEX> 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-accumulator</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_accumulator</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    that generates accumulators, each maintaining an independent sum.  The
    input to 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-accumulator</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_accumulator</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    should specify the initial value of the sum; for example
    <SNIPPET EVAL="yes">
      <NAME>make_accumulator_example</NAME>
      <SCHEME>
(define A (make-accumulator 5))
      </SCHEME>
      <PYTHON>
const a = make_accumulator(5);
      </PYTHON>
      <PYTHON_RUN>
// make_accumulator to be written by students
const a = make_accumulator(5);
      </PYTHON_RUN>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_accumulator_example1</NAME>
      <REQUIRES>make_accumulator_example</REQUIRES>
      <SCHEME>
(A 10)
      </SCHEME>
      <SCHEMEOUTPUT>
15
      </SCHEMEOUTPUT>
      <PYTHON>
a(10);
      </PYTHON>
      <PYTHON_OUTPUT>
15
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes" POSTPADDING="no">
      <NAME>make_accumulator_example2</NAME>
      <REQUIRES>make_accumulator_example1</REQUIRES>
      <SCHEME>
(A 10)
      </SCHEME>
      <SCHEMEOUTPUT>
25
      </SCHEMEOUTPUT>
      <PYTHON>
a(10);
      </PYTHON>
      <PYTHON_OUTPUT>
25
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_accumulator_example_solution</NAME>
      <SCHEME>
(A 10)
      </SCHEME>
      <SCHEMEOUTPUT>
25
      </SCHEMEOUTPUT>
      <PYTHON>
const a = make_accumulator(5);
a(10);
a(10);
      </PYTHON>
      <PYTHON_OUTPUT>
25
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>make_accumulator_solution</NAME>
	<EXAMPLE>make_accumulator_example_solution</EXAMPLE>
	<EXPECTED>25</EXPECTED>
	<PYTHON>
function make_accumulator(current) {
    function add(arg) {
        current = current + arg;
        return current;
    }
    return add;
}
	</PYTHON>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:make-monitored"/>
    In software-testing applications, it is useful to be able to count the
    number of times a given
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    is called during the course of a computation.  Write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <INDEX><USE>make_monitored</USE></INDEX> 
    <INDEX>monitored <SPLITINLINE><SCHEME>procedure</SCHEME><PYTHON>function</PYTHON></SPLITINLINE></INDEX>
    <INDEX><FUNCTION/><SUBINDEX>monitored</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-monitored</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_monitored</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    that takes as input a
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <PYTHON>function,</PYTHON>
    </SPLITINLINE>
    <SCHEMEINLINE>f</SCHEMEINLINE>, that itself takes one input.  The result
    returned by 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-monitored</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_monitored</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    is a third
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <PYTHON>function,</PYTHON>
    </SPLITINLINE>
    say <SCHEMEINLINE>mf</SCHEMEINLINE>, that keeps track of the number of times
    it has been called by maintaining an internal counter. If the input to
    <SCHEMEINLINE>mf</SCHEMEINLINE> is the
    <SPLITINLINE>
      <SCHEME>special symbol <SCHEMEINLINE>how-many-calls</SCHEMEINLINE>,
      </SCHEME>
      <PYTHON>string <PYTHONINLINE>"how many calls"</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    then <SCHEMEINLINE>mf</SCHEMEINLINE> returns the value of the counter.  If
    the input is the 
    <SPLITINLINE>
      <SCHEME>special symbol <SCHEMEINLINE>reset-count</SCHEMEINLINE>,</SCHEME>
      <PYTHON>string <PYTHONINLINE>"reset count"</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    then <SCHEMEINLINE>mf</SCHEMEINLINE> resets the counter to zero.  For any
    other input, <SCHEMEINLINE>mf</SCHEMEINLINE> returns the result of calling
    <SCHEMEINLINE>f</SCHEMEINLINE> on that input and increments the counter.
    For instance, we could make a monitored version of the
    <SCHEMEINLINE>sqrt</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <PYTHON>function:</PYTHON>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <NAME>make_monitored_example</NAME>
      <SCHEME>
    (define s (make-monitored sqrt))
      </SCHEME>
      <PYTHON>
const s = make_monitored(math_sqrt);
      </PYTHON>
      <PYTHON_RUN>
// make_monitored function to be written by students
const s = make_monitored(math_sqrt);
      </PYTHON_RUN>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_monitored_example</REQUIRES>
      <NAME>make_monitored_example1</NAME>
      <SCHEME>
(s 100)
      </SCHEME>
      <SCHEMEOUTPUT>
10
      </SCHEMEOUTPUT>
      <PYTHON>
s(100);
      </PYTHON>
      <PYTHON_OUTPUT>
10
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes" POSTPADDING="no">
      <REQUIRES>make_monitored_example1</REQUIRES>
      <NAME>make_monitored_example2</NAME>
      <SCHEME>
(s 'how-many-calls?)
      </SCHEME>
      <SCHEMEOUTPUT>
1
      </SCHEMEOUTPUT>
      <PYTHON>
s("how many calls");
      </PYTHON>
      <PYTHON_OUTPUT>
1
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>make_monitored_example3</NAME>
	<PYTHON>
const s = make_monitored(math_sqrt);
s(100);
display(s("how many calls"));
s(5);
display(s("how many calls"));
        </PYTHON>
	<PYTHON_TEST>
const s = make_monitored(math_sqrt);
s(100);
s("how many calls");
s(5);
s("how many calls");
	</PYTHON_TEST>
      </SNIPPET>
      <SNIPPET>
	<EXAMPLE>make_monitored_example3</EXAMPLE>
	<EXPECTED>2</EXPECTED>
	<PYTHON>
function make_monitored(f) {
    let counter = 0; //initialized to 0
    function mf(cmd) {
        if (cmd === "how many calls") {
            return counter;
        } else if (cmd === "reset count") {
            counter = 0;
            return counter;
        } else {
            counter = counter + 1;
            return f(cmd);
        }
    }
    return mf;
}
	</PYTHON>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <LONG_PAGE lines="3"/>
  <EXERCISE>
    <LABEL NAME="ex:password-protection"/>
    Modify the 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_account</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    so that it creates
    <INDEX>bank account<SUBINDEX>password-protected</SUBINDEX></INDEX>
    <INDEX>password-protected bank account</INDEX>
    password-protected accounts.  That is, 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_account</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    should take a
    <SPLITINLINE>
      <SCHEME>symbol</SCHEME>
      <PYTHON>string</PYTHON>
    </SPLITINLINE>
    as an additional argument, as in
    <SNIPPET EVAL="yes">
      <NAME>make_account_exercise</NAME>
      <SCHEME>
            (define acc (make-account 100 'secret-password))
      </SCHEME>
      <PYTHON>
const acc = make_account(100, "secret password");
      </PYTHON>
      <PYTHON_RUN>
// make_account function to be written by students
const acc = make_account(100, "secret password");
      </PYTHON_RUN>
    </SNIPPET>
    The resulting account object should process a request only if it is
    accompanied by the password with which the account was created, and
    should otherwise return a complaint:
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account_exercise</REQUIRES>
      <NAME>make_account_exercise_example1</NAME>
      <SCHEME>
((acc 'secret-password 'withdraw) 40)
      </SCHEME>
      <SCHEMEOUTPUT>
60
      </SCHEMEOUTPUT>
      <PYTHON>
acc("secret password", "withdraw")(40);
      </PYTHON>
      <PYTHON_OUTPUT>
60
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes" POSTPADDING="no">
      <NAME>make_account_exercise_example2</NAME>
      <REQUIRES>make_account_exercise_example1</REQUIRES>
      <SCHEME>
((acc 'some-other-password 'deposit) 50)
      </SCHEME>
      <SCHEMEOUTPUT>
"Incorrect password"
      </SCHEMEOUTPUT>
      <PYTHON>
acc("some other password", "deposit")(40);  
      </PYTHON>
      <PYTHON_OUTPUT>
"Incorrect password"
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
        <NAME>make_account_password_protected</NAME>
	<EXPECTED>'Incorrect Password'</EXPECTED>
	<PYTHON>
function make_account(balance, p) {
    function withdraw(amount) {
        if (balance >= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "Insufficient funds";
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    function dispatch(m, q) {
        if (p === q) {
            return m === "withdraw"
                   ? withdraw
                   : m === "deposit"
                   ? deposit
                   : "Unknown request: make_account";
        } else {
            return q => "Incorrect Password";
        }
    }
    return dispatch;
}

const a = make_account(100, "eva");
a("withdraw", "eva")(50); //withdraws 50
a("withdraw", "ben")(40); //incorrect password
	</PYTHON>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:3_4"/>
    Modify the 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_account</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    of exercise<SPACE/><REF NAME="ex:password-protection"/> by adding another
    local state variable so that, if an account is accessed more than seven
    consecutive times with an incorrect password, it invokes the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>call-the-cops</SCHEMEINLINE>.</SCHEME>
      <PYTHON><PYTHONINLINE>call_the_cops</PYTHONINLINE>.
      </PYTHON>
    </SPLITINLINE>
    <SOLUTION>
      <SNIPPET>
	<NAME>mka</NAME>
	<EXAMPLE>mka_example</EXAMPLE>
	<EXPECTED>'calling the cops because you have exceeded the max no of failed attempts'</EXPECTED>
	<PYTHON>
function call_the_cops(reason) {
    return "calling the cops because " + reason;
}
function make_account(balance, p) {

    let invalid_attempts = 0; //initializes to 0

    function withdraw(amount) {
        if (balance >= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "Insufficient funds";
        }
    }

    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }

    function calling_the_cops(_) {
        return call_the_cops("you have exceeded " +
                             "the max no of failed attempts");
    }

    function dispatch(m, q) {
        if (invalid_attempts &lt; 7) {
            if (p === q) {
                return m === "withdraw"
                       ? withdraw
                       : m === "deposit"
                       ? deposit
                       : "Unknown request: make_account";
            } else {
                invalid_attempts = invalid_attempts + 1;
                return x => "Incorrect Password";
            }
        } else {
            return calling_the_cops;
        }
    }

    return dispatch;

}
	</PYTHON>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>mka_example</NAME>
	<PYTHON>
const a = make_account(100, "rosebud");
a("withdraw", "rosebad")(50);
a("withdraw", "rosebad")(50);
a("withdraw", "rosebad")(50);
a("withdraw", "rosebad")(50);
a("withdraw", "rosebad")(50);
a("withdraw", "rosebad")(50);
a("withdraw", "rosebad")(50);
a("withdraw", "rosebad")(50);
	</PYTHON>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>
  <INDEX>local state variable<CLOSE/></INDEX>
  <INDEX>state variable<SUBINDEX>local<CLOSE/></SUBINDEX></INDEX>
  <LONG_PAGE lines="3"/>
</SUBSECTION>
