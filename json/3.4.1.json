[{"id":"/sicpjs/3.4.1","tag":"TITLE","body":"3.4.1  \n    The Nature of Time in Concurrent Systems"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    On the surface, time seems straightforward.  It\n    is an ordering imposed on events.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/3.4.1#footnote-1"},{"body":"\n    For any events ","tag":"#text"},{"body":"$A$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$B$","tag":"LATEX"},{"body":",\n    either ","tag":"#text"},{"body":"$A$","tag":"LATEX"},{"body":" occurs before\n    ","tag":"#text"},{"body":"$B$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$A$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$B$","tag":"LATEX"},{"body":" are simultaneous, or\n    ","tag":"#text"},{"body":"$A$","tag":"LATEX"},{"body":" occurs after\n    ","tag":"#text"},{"body":"$B$","tag":"LATEX"},{"body":".  For instance,\n    returning to the bank account example, suppose that Peter withdraws\n    $10 and Paul withdraws $25 from a \n    \n    joint account that initially\n    contains $100, leaving $65 in the account.  Depending on the\n    order of the two withdrawals, the sequence of balances in the account is\n    either ","tag":"#text"},{"body":"$\\$100 \\rightarrow \\$90 \\rightarrow\\$65$","tag":"LATEX"},{"body":"\n    or ","tag":"#text"},{"body":"$\\$100 \\rightarrow \\$75 \\rightarrow\\$65$","tag":"LATEX"},{"body":".\n    In a computer implementation of the banking system, this changing\n    sequence of balances could be  modeled by successive assignments to\n    a variable ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    In complex situations, however, such a view can be problematic.\n    Suppose that Peter and Paul, and other people besides, are\n    accessing the same bank account through a network of banking machines\n    distributed all over the world.  The actual sequence of balances in\n    the account will depend critically on the detailed timing of the\n    accesses and the details of the communication among the machines.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    This\n    \n    indeterminacy in the order of events can pose serious problems in\n    the design of concurrent systems.  For instance, suppose that the\n    withdrawals made by Peter and Paul are implemented as two separate\n    threads \n    sharing a common variable ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":", each \n    thread \n    specified by the\n    function\n    given in section ","tag":"#text"},{"tag":"REF","body":"3.1.1","href":"/sicpjs/3.1.1"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":3,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0EYBQuAbAUwBdQAjAQwMoDsBjI0AXlGwAZ2BufAMwFcGJAJYB7WqADuwkgAsAJgCdKkgBSUAtqMEkAlKADeuUCdDDeoVVRoMmAPlabttPYeOmP1uoxYVq3pgBaUCcdHg8PRVJ+RQkvW3DTAF9QIgIAZyYjCNMokhiJACJIWnT+Xl5hemEiF1ABWnl0wsSTJNx23Gk5JRVVACYAVl0uUBBQbRIAB34SAC5QAHZBoA","body":"function withdraw(amount) {\n    if (balance >= amount) {\n        balance = balance - amount;\n        return balance;\n    } else {\n        return \"Insufficient funds\";\n    }\n} "},{"body":"\n    If the two \n    threads \n    operate independently, then Peter might test the\n    balance and attempt to withdraw a legitimate amount.\n    \n    However, Paul\n    might withdraw some funds in between the time that Peter checks the\n    balance and the time Peter completes the withdrawal, thus invalidating\n    Peter's test.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Things can be worse still.  Consider the\n    \n\tstatement\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"balance = balance - amount;"},{"body":"\n    executed as part of each withdrawal process.  This consists of three\n    steps: (1) accessing the value of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":"\n    variable; (2) computing the new balance; (3) setting\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":" to this new value.  If Peter and\n    Paul's withdrawals execute this statement concurrently, then the\n    two withdrawals might interleave the order in which they access\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":" and set it to the new value.\n  ","tag":"#text"}]},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ch3-Z-G-31.svg","id":"#fig-3.29","captionHref":"/sicpjs/3.4.1#fig-3.29","captionName":"Figure 3.29 ","captionBody":[{"body":"Timing diagram\n          \n\t  showing how interleaving the order of events\n          in two banking withdrawals can lead to an incorrect final balance.\n          ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    The timing diagram in\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"3.29","href":"/sicpjs/3.4.1#fig-3.29"},{"body":"\n    depicts\n    an order of events where ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":" starts at 100,\n    Peter withdraws 10, Paul withdraws 25, and yet the final value of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":" is 75.  As shown in the diagram,\n    the reason for this anomaly is that Paul's assignment of 75 to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":" is made under the assumption that\n    the value of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":" to be decremented is 100.\n    That assumption, however, became invalid when Peter changed\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":" to 90.  This is a catastrophic\n    failure for the banking system, because the total amount of money in the\n    system is not conserved.  Before the transactions, the total amount of\n    money was $100.  Afterwards, Peter has $10, Paul has\n    $25, and the bank has $75.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/3.4.1#footnote-2"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    The general phenomenon illustrated\n    here is that several \n    threads \n    may\n    \n    share a common state variable.  What makes this complicated is that more than one \n    thread \n    may be trying to manipulate the shared state at the same\n    time.  For the bank account example, during each transaction, each\n    customer should be able to act as if the other customers did not\n    exist.  When\n    customers change\n    the balance in a way that depends on\n    the balance,\n    they    \n    must be able to assume that, just before the moment of\n    change, the balance is still what\n    they    \n    thought it was.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Correct behavior of concurrent programs","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    The above example typifies the subtle bugs that can creep into\n    concurrent programs.  The root of this complexity lies in the\n    assignments to variables that are shared among the different\n    threads.  \n    We already know that we must be careful in writing programs that use\n    assignment,\n    because the results of a computation depend on the order in which the\n    assignments occur.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/3.4.1#footnote-3"},{"body":"\n    With concurrent \n    threads \n    we must be especially careful about\n    assignments, because we may not be able to control the order of the\n    assignments made by the different \n    threads.  \n    If several such changes\n    might be made concurrently (as with two depositors accessing a joint\n    account) we need some way to ensure that our system behaves correctly.\n    For example, in the case of withdrawals from a joint bank account, we\n    must ensure that money is conserved.\n    To make concurrent programs behave correctly, we may have to\n    place some restrictions on concurrent execution.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    One possible restriction on concurrency would stipulate that no two\n    operations that change any shared state variables can occur at the same\n    time.  This is an extremely stringent requirement.  For distributed banking,\n    it would require the system designer to ensure that only one transaction\n    could proceed at a time. This would be both inefficient and overly\n    conservative.  Figure ","tag":"#text"},{"tag":"REF","body":"3.30","href":"/sicpjs/3.4.1#fig-3.30"},{"body":" shows\n    Peter and Paul sharing a bank account, where Paul has a private account\n    as well. The diagram illustrates two withdrawals from the shared account\n    (one by Peter and one by Paul) and a deposit to Paul's private\n    account.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/3.4.1#footnote-4"},{"body":"\n    The two withdrawals from the shared account must not be concurrent (since\n    both access and update the same account), and Paul's deposit and\n    withdrawal must not be concurrent (since both access and update the amount\n    in Paul's wallet). But there should be no problem permitting\n    Paul's deposit to his private account to proceed concurrently with\n    Peter's withdrawal from the shared account.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_original/Fig3.30.svg","id":"#fig-3.30","captionHref":"/sicpjs/3.4.1#fig-3.30","captionName":"Figure 3.30 ","captionBody":[{"body":"Concurrent deposits and withdrawals from a\n      joint account in Bank1 and a private account in Bank2.\n      ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    A less stringent restriction on concurrency would ensure that a\n    concurrent system produces the same result as if the \n    threads \n    had run sequentially in some order. There are two important aspects to this\n    requirement. First, it does not require the \n    threads \n    to actually run sequentially, but only to produce results that are the same\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"as if","tag":"#text"}]},{"body":" they had run sequentially.  For the example in\n    figure ","tag":"#text"},{"tag":"REF","body":"3.30","href":"/sicpjs/3.4.1#fig-3.30"},{"body":", the designer of the\n    bank account system can safely allow Paul's deposit and Peter's\n    withdrawal to happen concurrently, because the net result will be the same as\n    if the two operations had happened sequentially.  Second, there may be more\n    than one possible \"","tag":"#text"},{"body":"correct","tag":"#text"},{"body":"\" result produced by a concurrent\n    program, because we require only that the result be the same as for\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"some","tag":"#text"}]},{"body":" sequential order. For example, suppose that Peter and\n    Paul's joint account starts out with $100, and Peter deposits\n    $40 while Paul concurrently withdraws half the money in the account.\n    Then sequential execution could result in the account balance being either\n    $70 or $90 (see\n    exercise ","tag":"#text"},{"tag":"REF","body":"3.38","href":"/sicpjs/3.4.1#ex-3.38"},{"body":").","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/3.4.1#footnote-5"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    There are still weaker requirements for correct execution of concurrent\n    programs.  A program for simulating \n    \n    diffusion (say, the flow of heat in an object) might consist of a large\n    number of \n    threads,\n    each one representing a small volume of space, that update their values\n    concurrently.  Each \n    thread \n    repeatedly changes its value to the average of its own value and its\n    neighbors' values. This algorithm converges to the right answer\n    independent of the order in which the operations are done; there is no\n    need for any restrictions on concurrent use of the shared values.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.38","id":"#ex-3.38","child":[{"body":"\n    Suppose that\n    \n    Peter, Paul, and Mary share a joint bank account that\n    initially contains $100.  Concurrently, Peter deposits\n    $10, Paul withdraws $20, and Mary withdraws half the\n    money in the account, by executing the following commands:\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"Peter:","tag":"#text"}]},{"tag":"TD","child":[{"tag":"JAVASCRIPTINLINE","body":"balance = balance + 10"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"Paul:","tag":"#text"}]},{"tag":"TD","child":[{"tag":"JAVASCRIPTINLINE","body":"balance = balance - 20"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"Mary:","tag":"#text"}]},{"tag":"TD","child":[{"tag":"JAVASCRIPTINLINE","body":"balance = balance - (balance / 2)"}]}]}]},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n        List all the different possible values for\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":"\n\tafter these three transactions have been completed,\n\tassuming that the banking system forces the three \n  threads \n  to run sequentially in some order.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        What are some other values\n        that could be produced if the system allows the \n        threads \n\tto be interleaved? Draw timing diagrams like the one in\n\tfigure ","tag":"#text"},{"tag":"REF","body":"3.29","href":"/sicpjs/3.4.1#fig-3.29"},{"body":" to explain\n\thow these values can occur.\n      ","tag":"#text"}]}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/3.4.1#footnote-link-1","child":[{"body":"To quote some graffiti seen\n    on a \n    building wall in Cambridge,\n    Massachusetts: \"","tag":"#text"},{"body":"Time\n    \n    is a device that was invented to keep\n    everything from happening at once.","tag":"#text"},{"body":"\"","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/3.4.1#footnote-link-2","child":[{"body":"An even worse\n    failure for this system could occur if the two\n    assignments\n    attempt to change the balance simultaneously, in which case the actual data\n    appearing in memory might end up being a random combination of the\n    information being written by the two \n    threads.  \n    Most computers have interlocks on\n    the primitive memory-write operations, which protect against such\n    simultaneous access.  Even this seemingly simple kind of protection,\n    however, raises implementation challenges in the design of\n    multiprocessing computers, where elaborate \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"cache-coherence","tag":"#text"}]},{"body":"\n    protocols are required to ensure that the various processors will\n    maintain a consistent view of memory contents, despite the fact that\n    data may be replicated (\"","tag":"#text"},{"body":"cached","tag":"#text"},{"body":"\") among the different\n    processors to increase the speed of memory access.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/3.4.1#footnote-link-3","child":[{"body":"The factorial program in\n    section ","tag":"#text"},{"tag":"REF","body":"3.1.3","href":"/sicpjs/3.1.3"},{"body":" illustrates this for\n    a single sequential \n    thread.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/3.4.1#footnote-link-4","child":[{"body":"The columns show the contents of Peter's wallet,\n    the joint account (in Bank1), Paul's wallet, and Paul's\n    private account (in Bank2), before and after each withdrawal (W) and\n    deposit (D). Peter withdraws $10 from Bank1; Paul deposits\n    $5 in Bank2, then withdraws $25 from Bank1.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/3.4.1#footnote-link-5","child":[{"body":"A more formal way\n    to express this idea is to say that concurrent programs are inherently \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"nondeterministic","tag":"#text"}]},{"body":". That is, they are described not by single-valued\n    functions, but by functions whose results are sets of possible values.\n    In section ","tag":"#text"},{"tag":"REF","body":"4.3","href":"/sicpjs/4.3"},{"body":" we will\n    study a language for expressing nondeterministic computations.\n    ","tag":"#text"}]}]