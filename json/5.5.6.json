[{"id":"/sicpjs/5.5.6","tag":"TITLE","body":"5.5.6  \n    Lexical Addressing"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    One of the most common optimizations performed by compilers is the\n    optimization of\n    name\n    lookup. Our compiler, as we have implemented it so far, generates code that\n    uses the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup_symbol_value"},{"body":"\n    operation of the evaluator machine.\n    \n\tThis searches for a\n      name\n    by comparing\n    it\n    with each\n    \n\tname\n      \n    that is currently bound, working frame\n    by frame outward through the runtime environment.  This search can be\n    expensive if the frames are deeply nested or if there are many\n    names.\n    For example, consider the problem of looking up the value\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" while evaluating the expression\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x * y * z"},{"body":"\n    in an application of the\n    function of five arguments\n    that is returned by\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHToGwChsAo8APAGlAE8BKUAXgD5tRG8BDUgI1IGNSATUgUyp0GjJnjKkAXkNqhCoAFTlFoaSxVsVJUJ1ABqUD31yKFPAGZSAFgpA","body":"((x, y) =>\n   (a, b, c, d, e) =>\n     ((y, z) => x * y * z)(a * b * x, c + d + x))(3, 4) "},{"body":"\n    Each time\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup_symbol_value"},{"body":"\n    searches for ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":", it must determine that\n    the symbol\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"x\""},{"body":" is not\n\tequal to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"y\""},{"body":" or\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"z\""},{"body":" (in the first frame), nor to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a\""},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"b\""},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"c\""},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"d\""},{"body":", or\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"e\""},{"body":" (in the second frame).\n      \n    Because our language is\n    \n    lexically scoped, the runtime environment for any\n    \n        component\n      \n    will have a\n    structure that parallels the lexical structure of the program in which\n    the\n    \n        component\n      \n    appears.\n    Thus, the compiler can know, when it analyzes the\n    above expression,\n    that each time the\n    function\n    is applied the\n    \n\tbinding for\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":"\n    in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x * y * z"},{"body":"\n    will be found two frames out from the\n    current frame and will be the first\n    binding\n    in that frame.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    We can exploit this fact by inventing a new kind of\n    name-lookup\n    operation,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lexical_address_lookup"},{"body":",\n      \n    that takes as arguments an environment and a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"lexical address","tag":"#text"}]},{"body":" that\n    consists of two numbers: a ","tag":"#text"},{"tag":"EM","child":[{"body":"frame number","tag":"#text"}]},{"body":", which specifies how many\n    frames to pass over, and a ","tag":"#text"},{"tag":"EM","child":[{"body":"displacement number","tag":"#text"}]},{"body":", which specifies\n    how many\n    bindings\n    to pass over in that frame.\n    \n\tThe operation\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lexical_address_lookup"},{"body":"\n    will produce the value of the\n    name\n    stored at that lexical address\n    relative to the current environment.  If we add the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lexical_address_lookup"},{"body":"\n    operation to our machine, we can make the compiler generate code that\n    references\n    names\n    using this operation, rather than\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup_symbol_value"},{"body":".\n      \n    Similarly, our compiled code can use a new\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lexical_address_assign"},{"body":"\n    operation instead of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assign_symbol_value"},{"body":".\n      \n\tWith lexical addressing, there is no need to include any\n\tsymbolic references to names in the object code,\n\tand frames do not need to include symbols at run time.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    In order to generate such code, the compiler must be able to determine\n    the lexical address of a\n    name\n    it is about to compile a reference\n    to.  The lexical address of a\n    name\n    in a program depends on where\n    one is in the code.  For example, in the following program, the\n    address of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" in expression\n    ","tag":"#text"},{"body":"$e_1$","tag":"LATEX"},{"body":" is (2,0)—two frames back\n    and the first\n    name\n    in the frame.  At that point\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":" is at\n    address (0,0) and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"c"},{"body":" is at address (1,2).\n    In expression\n    ","tag":"#text"},{"body":"$e_2$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" is at (1,0),\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":" is at (1,1), and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"c"},{"body":" is at (0,2).\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n((x, y) =>\n   (a, b, c, d, e) =>\n     ((y, z) => $e_1$)($e_2$, c + d + x))(3, 4);\n      "}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    One way for the compiler to produce code that uses lexical addressing\n    is to maintain a data structure called a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"compile-time environment","tag":"#text"}]},{"body":".  This keeps track of which\n    bindings\n    will be at which\n    positions in which frames in the runtime environment when a\n    particular\n    name-access\n    operation is executed.  The compile-time\n    environment is a list of frames, each containing a list of\n    symbols.\n\tThere will be no values associated with the symbols,\n\tsince values are not computed at compile time.\n\t(Exercise ","tag":"#text"},{"tag":"REF","body":"5.46","href":"/sicpjs/5.5.6#ex-5.46"},{"body":"\n\twill change this, as an optimization for constants.)\n      \n    The compile-time\n    environment becomes an additional argument to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":" and is\n    passed along to each code generator.  The top-level call to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":" uses\n    \n\ta compile-time-environment that includes the names of all primitive\n\tfunctions and primitive values.\n      \n    When\n    \n\tthe body of a lambda expression\n      \n    is compiled,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_body"},{"body":"\n    extends the compile-time environment by a frame containing the\n    function's\n      \n    parameters, so that the\n    \n    body is compiled with that extended environment.\n    \n\tSimilarly, when\n\tthe body of a block\n\tis compiled,\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_block"},{"body":"\n\textends the compile-time environment by a frame containing the\n\t\n\tscanned-out local names of the body.\n      \n    At each point in the compilation,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_name"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_assignment_declaration"},{"body":"\n    use the compile-time\n    environment in order to generate the appropriate lexical addresses.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n\tExercises ","tag":"#text"},{"tag":"REF","body":"5.41","href":"/sicpjs/5.5.6#ex-5.41"},{"body":"\n\tthrough ","tag":"#text"},{"tag":"REF","body":"5.44","href":"/sicpjs/5.5.6#ex-5.44"},{"body":" describe how to\n\tcomplete this sketch of the lexical-addressing strategy in order to\n\tincorporate lexical lookup into the compiler.\n\tExercises ","tag":"#text"},{"tag":"REF","body":"5.45","href":"/sicpjs/5.5.6#ex-5.45"},{"body":"\n\tand ","tag":"#text"},{"tag":"REF","body":"5.46","href":"/sicpjs/5.5.6#ex-5.46"},{"body":"\n\tdescribe other uses for\tthe compile-time environment.\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.41","id":"#ex-5.41","child":[{"body":"\n    Write a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lexical_address_lookup"},{"body":"\n    that implements the new lookup operation.  It should take two\n    arguments—a lexical address and a runtime environment—and\n    return the value of the\n    name\n    stored at the specified lexical address.\n    The function\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lexical_address_lookup"},{"body":"\n    should signal an error if the value\n    of the name\n    is the\n    string ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"*unassigned*\""},{"body":".\n      \n    Also write a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lexical_address_assign"},{"body":"\n    that implements the operation that changes the value\n    of the name\n    at a specified lexical address.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.42","id":"#ex-5.42","child":[{"body":"\n    Modify the compiler to maintain the\n    \n    compile-time environment as\n    described above.  That is, add a compile-time-environment argument to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":" and the various code generators, and\n    extend it in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_body"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_block"},{"body":".\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.43","id":"#ex-5.43","child":[{"body":"\n    Write a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"find_symbol"},{"body":"\n    that takes as arguments a\n    symbol\n    and a\n    \n    compile-time environment and\n    returns the lexical address of the\n    symbol\n    with respect to that\n    environment.  For example, in the program fragment that is shown above, the\n    compile-time environment during the compilation of expression\n    ","tag":"#text"},{"body":"$e_1$","tag":"LATEX"},{"body":" is\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHToGwChsBsBLAZwBcAKQ0sgIgE9qAaUagL2oEoHtQefLzqAQ0bMARiOoBjCQBMJAUw5defYgIAeE+u3ZA","body":"list(list(\"y\", \"z\"),\n     list(\"a\", \"b\", \"c\", \"d\", \"e\"),\n     list(\"x\", \"y\")) "},{"body":"The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"find_symbol"},{"body":"\n    should produce\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHToGwChsDMBLAOwBMB9AZwE8BbAIwHsAbACgCIBjNgGlCYIoAXFvyHsqPUGwBebAJTdsoZStVr1fAcLYBDSWzr6uvNiX0BTeYo02No7QA99Eua4DcQA","body":"find_symbol(\"c\", list(list(\"y\", \"z\"),\n                      list(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                      list(\"x\", \"y\"))); ","output":"list(1, 2)"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHToGwChsDMBLAOwBMB9AZwE8BbAIwHsAbACgCIAPNgGlCYIoAXFvyHsqPUGwBebAJTdsoZStVr1fAcLYBDSWzr6AxvpL6ApvMUabG0dq682Eua4DcQA","body":"find_symbol(\"x\", list(list(\"y\", \"z\"),\n                      list(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                      list(\"x\", \"y\"))); ","output":"list(2, 0)"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHToGwChsDMBLAOwBMB9AZwE8BbAIwHsAbACgCIB3NgGlCYIoAXFvyHsqPUGwBebAJTdsoZStVr1fAcLYBDSWzr6AxvpL6ApvMUabG0doAe+iXNcBuIA","body":"find_symbol(\"w\", list(list(\"y\", \"z\"),\n                      list(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                      list(\"x\", \"y\"))); ","output":"\"not found\""}]},{"tag":"EXERCISE","title":"Exercise 5.44","id":"#ex-5.44","child":[{"body":"\n    Using\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"find_symbol"},{"body":"\n    from exercise ","tag":"#text"},{"tag":"REF","body":"5.43","href":"/sicpjs/5.5.6#ex-5.43"},{"body":",\n    rewrite\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_assignment_declaration"},{"body":"\n\tand\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_name"},{"body":"\n    to output lexical-address instructions.\n    \n\tIn cases where ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"find_symbol"},{"body":"\n\treturns ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"not found\""},{"body":"\n\t(that is, where the name is not in the compile-time environment),\n\tyou should report a compile-time error.\n      \n    Test the modified compiler on a few simple cases, such as the nested\n    lambda\n    combination at the beginning of this section.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.45","id":"#ex-5.45","child":[{"body":"\n\tIn JavaScript, an attempt to assign a new value to a name that is declared\n\tas a\n\t\n\tconstant leads to an error.\n\tExercise ","tag":"#text"},{"tag":"REF","body":"4.11","href":"/sicpjs/4.1.3#ex-4.11"},{"body":" shows how to\n\tdetect such errors at run time. With the techniques presented in this\n\tsection, we can detect attempts to assign a new value to a constant\n\t","tag":"#text"},{"tag":"EM","child":[{"body":"at compile time","tag":"#text"}]},{"body":". For this purpose, extend the functions\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_body"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_block"},{"body":"\n\tto record in the compile-time environment whether a name is declared as a variable (using\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"let"},{"body":" or as a parameter), or as\n\ta constant (using\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"const"},{"body":"\n\tor\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"function"},{"body":").\n\tModify ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_assignment"},{"body":"\n\tto report an appropriate error when it detects an\n\tassignment to a\tconstant.\n\t","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.46","id":"#ex-5.46","child":[{"body":"\n        Knowledge about constants at compile time opens the door to many\n        optimizations that allow us to generate more efficient object code. In\n        addition to the extension of the\n\t\n\tcompile-time environment in\n        exercise ","tag":"#text"},{"tag":"REF","body":"5.45","href":"/sicpjs/5.5.6#ex-5.45"},{"body":" to indicate names\n\tdeclared as constants, we may store the\n        value of a constant if it is known at compile time, or other information\n\tthat can help us optimize the code.\n        ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n            A constant declaration such as ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"const"},{"body":" ","tag":"#text"},{"tag":"META","body":"name"},{"body":" ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"="},{"body":" ","tag":"#text"},{"tag":"META","body":"literal"},{"tag":"JAVASCRIPTINLINE","body":";"},{"body":" allows us\n            to replace all occurrences of ","tag":"#text"},{"tag":"META","body":"name"},{"body":" within the scope of\n            the declaration by ","tag":"#text"},{"tag":"META","body":"literal"},{"body":" so that ","tag":"#text"},{"tag":"META","body":"name"},{"body":" \n            doesn't have to be looked up in the runtime environment. This optimization is\n            called ","tag":"#text"},{"tag":"EM","child":[{"body":"constant propagation","tag":"#text"}]},{"body":". Use an extended compile-time\n            environment to store literal constants, and modify\n            ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_name"},{"body":" to use the stored\n            constant in the generated ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assign"},{"body":"\n\t    instruction instead of the\n            ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup_symbol_value"},{"body":" operation.\n          ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t    Function declaration is a derived component that expands to\n\t    constant declaration. Let us assume that the names of primitive functions\n\t    in the global environment are also considered constants.\n\t    If we further extend our compile-time\n\t    environment to keep track of which names refer to compiled\n\t    functions and which ones to primitive functions, we can move\n            the test that checks whether a function is compiled or primitive\n            from run time to compile time. This makes the object code more\n            efficient because it replaces a test that must be performed once per\n            function application in the generated code by one that is performed\n            by the compiler. Using such an extended compile-time environment,\n            modify ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_function_call"},{"body":"\n\t    so that if it can be determined at\n\t    compile time whether the called function is compiled or primitive,\n\t    only the instructions in the\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compiled_branch"},{"body":" or the\n            ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"primitive_branch"},{"body":"\n            are generated.\n          ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n            Replacing constant names with their literal values as in part (a)\n            paves the way for another optimization, namely replacing\n            applications of primitive functions to literal values with the\n            compile-time computed result. This optimization, called\n            ","tag":"#text"},{"tag":"EM","child":[{"body":"constant folding","tag":"#text"}]},{"body":", replaces expressions such as\n            ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"40 + 2"},{"body":" by\n            ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"42"},{"body":" by performing the addition\n            in the compiler. Extend the compiler to perform constant folding for\n            arithmetic operations on numbers and for string concatenation.\n            ","tag":"#text"}]}]}]}]