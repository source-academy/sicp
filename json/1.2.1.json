[{"id":"/sicpjs/1.2.1","tag":"TITLE","body":"1.2.1  Linear Recursion and Iteration"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    We begin by considering the\n    \n    factorial function, defined by\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      n! &=& n\\cdot(n-1)\\cdot(n-2)\\cdots3\\cdot2\\cdot1\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    There are many ways to compute factorials.  One way is to make use of\n    the observation that ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":" is equal to \n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" times ","tag":"#text"},{"body":"$(n-1)!$","tag":"LATEX"},{"body":" for\n    any positive integer ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":":\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      n! &=& n\\cdot\\left[(n-1)\\cdot(n-2)\\cdots3\\cdot2\\cdot1\\right] \\quad = \\quad n \\cdot(n-1)!\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    Thus, we can compute ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":" by computing \n    ","tag":"#text"},{"body":"$(n-1)!$","tag":"LATEX"},{"body":" and multiplying the\n    result by ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".  If we add the stipulation that 1! \n    is equal to 1,\n    this observation translates directly into a \n    computer function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGj4CGF1ATpQwDYAUxAlKAG8coEaBYBTcoRZ06AXgWpQw0atEB+VCrWqAXKDoAqek3Kt23OgFpUvANw4AvnkbM2nLgFZ7QA","body":"function factorial(n) {\n    return n === 1 \n           ? 1\n           : n * factorial(n - 1);\n} "},{"body":"\n\t      We can use the substitution model of\n        section ","tag":"#text"},{"tag":"REF","body":"1.1.5","href":"/sicpjs/1.1.5"},{"body":" to watch this\n        \n        function in action computing 6!, as shown in\n\t      figure ","tag":"#text"},{"tag":"REF","body":"1.3","href":"/sicpjs/1.2.1#fig-1.3"},{"body":".\n  ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ch1-Z-G-7.svg","id":"#fig-1.3","captionHref":"/sicpjs/1.2.1#fig-1.3","captionName":"Figure 1.3 ","captionBody":[{"body":"A linear recursive process for computing 6!.\n\t  ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Now let's take a different perspective on computing factorials.  We\n    could describe a rule for computing ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":" by \n    specifying that we first multiply 1 by 2, then multiply the result by 3,\n    then by 4, and so on until we reach ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".\n    More formally, we maintain a running product, together with a counter\n    that counts from 1 up to ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".  We can describe\n    the computation by saying that the counter and the product simultaneously\n    change from one step to the next according to the rule\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      \\textrm{product} & \\leftarrow & \\textrm{counter} \\cdot \\textrm{product}\\\\\n      \\textrm{counter} & \\leftarrow & \\textrm{counter} + 1\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\nand stipulating that ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":" is the value of the\n    product when the counter exceeds ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    Once again, we can recast our description as a \n    function \n    for computing\n    factorials:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/1.2.1#footnote-1"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGj4CGF1ATpQwDYAUxAlKAG8coEaBYBTcoRZ1GFAPqVy4llxQAaVJr4BuHAF8CJCjVlNyi5aoAOLagBNCFTaWokrmgLYMAHvNfu-EKiYpLSdAHEVqAAfKDefpHkwiGpoAD8oLYOTslpqQBc9OaWKlxJKqAAVFl2js4p+U1pFSygANRajc098b7+blG8eoYE5qzs3ACsw0A","body":"function factorial(n) {\n    return fact_iter(1, 1, n);\n}\nfunction fact_iter(product, counter, max_count) {\n    return counter > max_count\n           ? product\n           : fact_iter(counter * product,\n                       counter + 1,\n                       max_count);\n} "},{"body":"\n        As before, we can use the substitution model to visualize the process\n  ","tag":"#text"},{"tag":"FIGURE","scale":"40%","src":"img_javascript/ch1-Z-G-10.svg","id":"#fig-1.4","captionHref":"/sicpjs/1.2.1#fig-1.4","captionName":"Figure 1.4 ","captionBody":[{"body":"A linear iterative process for computing\n\t","tag":"#text"},{"body":"$6!$","tag":"LATEX"},{"body":".\n\t","tag":"#text"}]},{"body":"\n        of computing ","tag":"#text"},{"body":"$6!$","tag":"LATEX"},{"body":", as shown in\n\tfigure ","tag":"#text"},{"tag":"REF","body":"1.4","href":"/sicpjs/1.2.1#fig-1.4"},{"body":".\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Compare the two processes.  From one point of view, they seem hardly\n    different at all.  Both compute the same mathematical function on the\n    same domain, and each requires a number of steps proportional to\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"\n    to compute ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":".  Indeed, both processes even\n    carry out the same sequence of multiplications, obtaining the same sequence\n    of partial products.  On the other hand, when we consider the\n    \"","tag":"#text"},{"body":"shapes","tag":"#text"},{"body":"\" of the two processes, we find that they evolve quite\n    differently.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Consider the first process.  The substitution model reveals a shape of\n    expansion followed by contraction, indicated by the arrow in\n    figure ","tag":"#text"},{"tag":"REF","body":"1.3","href":"/sicpjs/1.2.1#fig-1.3"},{"body":".\n    The expansion occurs as the process builds up a chain of \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"deferred operations","tag":"#text"}]},{"body":" (in this case, a chain of multiplications).\n    The contraction occurs as the operations are actually performed.  This\n    type of process, characterized by a chain of deferred operations, is called a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"recursive process","tag":"#text"}]},{"body":".  Carrying out this process requires that the\n    interpreter keep track of the operations to be performed later on.  In the\n    computation of ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":", the length of the chain of\n    deferred multiplications, and hence the amount of information needed to\n    keep track of it, \n    \n    grows linearly with ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" (is proportional to\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"), just like the number of steps.\n    Such a process is called a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"linear recursive process","tag":"#text"}]},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    By contrast, the second process does not grow and shrink.  At each\n    step, all we need to keep track of, for any ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":",\n    are the current values of the\n    names","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"product"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"counter"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"max_count"},{"body":".\n    We call this an \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"iterative process","tag":"#text"}]},{"body":".  In general, an iterative process is one whose\n    state can be summarized by a fixed number of\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"state variables","tag":"#text"}]},{"body":", together with a fixed rule that describes how\n    the state variables should be updated as the process moves from state to\n    state and an (optional) end test that specifies conditions under which the\n    process should terminate.  In computing ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":", the\n    number of steps required grows linearly with ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".\n    Such a process is called a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"linear iterative process","tag":"#text"}]},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    The contrast between the two processes can be seen in another way.\n    In the iterative case, the state variables provide a complete description of\n    the state of the process at any point. If we stopped the computation between\n    steps, all we would need to do to resume the computation is to supply the\n    interpreter with the values of the three state variables. Not so with the\n    recursive process.  In this case there is some additional\n    \"","tag":"#text"},{"body":"hidden","tag":"#text"},{"body":"\" information, maintained by the interpreter and not\n    contained in the state variables, which indicates \"","tag":"#text"},{"body":"where the process\n    is","tag":"#text"},{"body":"\" in negotiating the chain of deferred operations.  The longer the\n    chain, the more information must be maintained.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/1.2.1#footnote-2"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    In contrasting iteration and recursion, we must be careful not to\n    confuse the notion of a \n    \n    recursive ","tag":"#text"},{"tag":"EM","child":[{"body":"process","tag":"#text"}]},{"body":" with the notion of a recursive \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"function","tag":"#text"}]},{"body":".\n      \n    When we describe a\n    function\n    as recursive, we are referring to the syntactic fact that the\n    function declaration \n    refers (either directly or indirectly) to the\n    function\n    itself.  But when we describe a process as following a pattern that is, say,\n    linearly recursive, we are speaking about how the process evolves, not\n    about the syntax of how a\n    function\n    is written.  It may seem disturbing that we refer to a recursive\n    function\n    such as \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fact_iter"},{"body":"\n    as generating an iterative process.  However, the process really is\n    iterative: Its state is captured completely by its three state variables,\n    and an interpreter need keep track of only three\n    names\n    in order to execute the process.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    One reason that the distinction between process and\n    function\n    may be confusing is that most implementations of common languages\n    \n\t(including\n\t\n\tC,\n\t\n\tJava, and\n\t\n\tPython)\n      \n    are designed in such a way that the interpretation of\n    any recursive\n    function\n    consumes an amount of memory that grows with the number of\n    function\n    calls, even when the process described is, in principle, iterative.\n    As a consequence, these languages can describe iterative processes only\n    by resorting to special-purpose \n    \"","tag":"#text"},{"body":"looping constructs","tag":"#text"},{"body":"\" such as\n    ","tag":"#text"},{"body":"$\\texttt{do}$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$\\texttt{repeat}$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$\\texttt{until}$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$\\texttt{for}$","tag":"LATEX"},{"body":", and\n    ","tag":"#text"},{"body":"$\\texttt{while}$","tag":"LATEX"},{"body":".\n    The implementation of\n    JavaScript\n    we shall consider in chapter ","tag":"#text"},{"tag":"REF","body":"5","href":"/sicpjs/5"},{"body":" does not share this defect.  It will\n    execute an iterative process in constant space, even if the iterative\n    process is described by a recursive\n    function.\n\tAn implementation with this property is called \n\t","tag":"#text"},{"tag":"EM","child":[{"body":"tail-recursive","tag":"#text"}]},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/1.2.1#footnote-3"},{"body":"\n\tWith a tail-recursive implementation, \n\t\n\titeration can be expressed using the ordinary function\n\tcall mechanism, so that special iteration constructs are useful only as \n\t\n\tsyntactic sugar.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/1.2.1#footnote-4"}]},{"tag":"EXERCISE","title":"Exercise 1.9","id":"#ex-1.9","child":[{"body":"\n    Each of the following two\n    functions\n    defines a method for adding two positive integers in terms of the\n    functions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"inc"},{"body":", which increments its argument by 1,\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"dec"},{"body":", which decrements its argument by 1.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":8,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGiVkAUAHgJSgDeOoPoATgFNyhPnWagA1KgDcOAL4ESFGnQAmA0i3Zde-ISLGgAtDPl4iZKrVAAHADaEAzowCGAGlAAjbd16DhoqAuoAC8YaAADKAA-F6gAFz0TPZOjOqaLqwe3qzSoGY4Kc4ALB4ArLlAA","body":"function plus(a, b) {\n    return a === 0 ? b : inc(plus(dec(a), b)); \n} "},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":8,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGiVkAUAHgJSgDeOoPoATgFNyhPnWagA1KgDcOAL4ESFGnQAmA0i3Zde-ISLGgAtDPl4iZKrVAAHADaEAzowCGAGlAAjbd16DhoqAuoAC8YaAADKAA-F6gAFy2Ds7qmi6sHgya3qyyCjj2TowALB4ArLlAA","body":"function plus(a, b) {\n    return a === 0 ? b : plus(dec(a), inc(b));\n} "},{"body":"\n\n    Using the substitution model, illustrate the process generated by each\n    function\n    in evaluating\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"plus(4, 5);"},{"body":".\n    Are these processes iterative or recursive?\n\n    ","tag":"#text"}],"solution":[{"body":"\n\t  The process generated by the first function is recursive.\n          ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"plus(4, 5)\n4 === 0 ? 5 : inc(plus(dec(4), 5))\ninc(plus(dec(4), 5))\n...\ninc(plus(3, 5))\n...\ninc(inc(plus(2, 5)))\n...\ninc(inc(inc(plus(1, 5))))\n...\ninc(inc(inc(inc(plus(0, 5)))))\ninc(inc(inc(inc( 0 === 0 ? 5 : inc(plus(dec(0), 5))))))\ninc(inc(inc(inc( 5 ))))\ninc(inc(inc( 6 )))\ninc(inc( 7 ))\ninc( 8 )\n9"},{"body":"\n\t  The process generated by the second function is iterative.\n          ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"plus(4, 5)\n4 === 0 ? 5 : plus(dec(4), inc(5))\nplus(dec(4), inc(5))\n...\nplus(3, 6)\n...\nplus(2, 7)\n...\nplus(1, 8)\n...\nplus(0, 9)\n0 === 0 ? 9 : plus(dec(0), inc(9))\n9"}]},{"tag":"EXERCISE","title":"Exercise 1.10","id":"#ex-1.10","child":[{"body":"\n    The following\n    function\n    computes a mathematical function called\n    \n    Ackermann's function.\n\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGgCCAFAB4A0oAngJSgDeOoQaABOAU3KFhdDqAC880AAYBQ1UID8SlWtUAuUMzkLlOtZoygAVJ22nQ+mfNmpbp86536mhgLSp23uwyfihcXADcOAC+eEwo7CiKEUA","body":"function A(x, y) {\n    return y === 0\n           ? 0\n           : x === 0\n           ? 2 * y\n           : y === 1\n           ? 2\n           : A(x - 1, A(x, y - 1));\n} "},{"body":"\n\n    What are the values of the following\n    \n\tstatements?\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":11,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGgCCAFAB4A0oAngJSgDeOoQaABOAU3KFhdDqAC880AAYBQ1UID8SlWtUAuUMzkLlOtZoygAVJ22nQ+mfNmpbp86536mhgLSp23uwyfihcXADcOAC+eEwo7CiKEUA","body":"A(1, 10); "},{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":11,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGgCCAFAB4A0oAngJSgDeOoQaABOAU3KFhdDqAC880AAYBQ1UID8SlWtUAuUMzkLlOtZoygAVJ22nQ+mfNmpbp86536mhgLSp23uwyfihcXADcOAC+eEwY7AAsEUA","body":"A(2, 4); "},{"tag":"SNIPPET","latex":false,"id":10,"eval":true,"prependLength":11,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGgCCAFAB4A0oAngJSgDeOoQaABOAU3KFhdDqAC880AAYBQ1UID8SlWtUAuUMzkLlOtZoygAVJ22nQ+mfNmpbp86536mhgLSp23uwyfihcXADcOAC+eEwAzOxxEUA","body":"A(3, 3); "},{"body":"\n\n    Consider the following\n    functions,\n    where ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"A"},{"body":" is the\n    function declared  \n    above:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":true,"prependLength":11,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGgCCAFAB4A0oAngJSgDeOoQaABOAU3KFhdDqAC880AAYBQ1UID8SlWtUAuUMzkLlOtZoygAVJ22nQ+mfNmpbp86536mhgLSp23uwyfihcXADcOAC+eERkVLSg+IzEPPyqYhJSDIyK7KmRMXEUNHQA5ilptpmSdEwo+RHRBCQliQAWlXzV4rU5GI2FLfGloADWXemCNdkArFagdNbEQzgTACwRQA","body":"function f(n) {\n    return A(0, n);\n}\nfunction g(n) {\n    return A(1, n);\n}\nfunction h(n) {\n    return A(2, n);\n}\nfunction k(n) {\n   return 5 * n * n;\n} "},{"body":"\n    Give concise mathematical definitions for the functions computed by\n    the\n    functions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"g"},{"body":", and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"h"},{"body":" for positive integer values of\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".  For example,\n    ","tag":"#text"},{"body":"$k(n)$","tag":"LATEX"},{"body":" computes\n    ","tag":"#text"},{"body":"$5n^2$","tag":"LATEX"},{"body":".\n\n    ","tag":"#text"}],"solution":[{"body":"\n      The function ","tag":"#text"},{"body":"$f(n)$","tag":"LATEX"},{"body":" computes\n      ","tag":"#text"},{"body":"$2 n$","tag":"LATEX"},{"body":",\n      the function ","tag":"#text"},{"body":"$g(n)$","tag":"LATEX"},{"body":" computes\n      ","tag":"#text"},{"body":"$2^n$","tag":"LATEX"},{"body":", and\n      the function ","tag":"#text"},{"body":"$h(n)$","tag":"LATEX"},{"body":" computes\n      ","tag":"#text"},{"body":"$2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}}$","tag":"LATEX"},{"body":"\n      where the number of 2s in the chain of exponentiation is\n      ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/1.2.1#footnote-link-1","child":[{"body":"In a real program we would probably use the\n    block structure introduced in the last section to hide the \n    \n\tdeclaration of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fact_iter"},{"body":":\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0oFA4GYCuAdgMYAuAlgPbGj4CGF1ATpQwDYAUxAlKAG8coEfRIUadSuQCmLLgAcW1ACaEKAGlClqJWS35DRx0CxnlCLOjr1zQAPlB1hJ16ID8oJavXkXb1wAuUGk5LhtifVAAKi9lNU1-AOSRCKiAalReAG4kgF8kswsrEP0uFC0UHJwCgiZyVnZuAFYcoA","body":"function factorial(n) {\n    function iter(product, counter) {\n        return counter > n \n               ? product\n               : iter(counter * product,\n                      counter + 1);\n    }\n    return iter(1, 1);\n} "},{"body":"\n    We avoided doing this here so as to minimize the number of things to\n    think about at\n    once.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/1.2.1#footnote-link-2","child":[{"body":"When we discuss the\n    implementation of\n    functions \n    on register machines in chapter ","tag":"#text"},{"tag":"REF","body":"5","href":"/sicpjs/5"},{"body":", we will see that any iterative\n    process can be realized \"","tag":"#text"},{"body":"in hardware","tag":"#text"},{"body":"\" as a machine that has a\n    fixed set of registers and no auxiliary memory.  In contrast, realizing a\n    recursive process requires a machine that uses an\n    auxiliary data structure known as a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"stack","tag":"#text"}]},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/1.2.1#footnote-link-3","child":[{"body":"Tail recursion has long been\n\tknown as a compiler optimization trick.  A coherent semantic basis for\n\ttail recursion was provided by\n\t\n\tCarl Hewitt (1977), who explained it in\n\t\n\tterms of the \"","tag":"#text"},{"body":"message-passing","tag":"#text"},{"body":"\" model of computation that we\n\tshall discuss in chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":". Inspired by this, Gerald Jay Sussman\n\tand\n\t\n\tGuy Lewis Steele Jr. (see Steele 1975) \n\tconstructed a tail-recursive interpreter for Scheme.  Steele later showed\n\thow tail recursion is a consequence of the natural way to compile \n\tfunction calls\n\t\n\t(Steele 1977).\n\tThe IEEE standard for Scheme requires that Scheme implementations\n\t\n\tbe tail-recursive. The ECMA standard for JavaScript eventually followed\n\tsuit with ECMAScript 2015 (ECMA 2015). Note, however,\n\tthat as of this writing (2021), most implementations of JavaScript do\n\tnot comply with this standard with respect to tail recursion.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/1.2.1#footnote-link-4","child":[{"body":"Exercise ","tag":"#text"},{"tag":"REF","body":"4.7","href":"/sicpjs/4.1.2#ex-4.7"},{"body":" \n\texplores JavaScript's while loops as syntactic\n\tsugar for functions that give rise to iterative processes.\n\tThe full language JavaScript, like other conventional languages,\n\tfeatures a plethora of syntactic\n\tforms, all of which can be expressed more uniformly in the\n\tlanguage Lisp.\n\tThis, together with the fact that these constructs typically involve\n\tsemicolons whose placement rules are sometimes not obvious,\n\tled Alan Perlis to quip: \"","tag":"#text"},{"body":"Syntactic sugar causes\n\tcancer of the semicolon.","tag":"#text"},{"body":"\"","tag":"#text"}]}]