<SUBSECTION>
   <NAME> 不同类型数据的组合 </NAME> 

  <LABEL NAME="sec:combining-data-of-different-types"></LABEL>

   <TEXT> 我们已经看到如何定义一个统一的算术系统，该系统包含普通数、复数、有理数和我们可能决定发明的任何其他类型的数字，但我们忽略了一个重要问题。到目前为止，我们定义的操作将不同的数据类型视为完全独立的。因此，添加两个普通数字或两个复数等是有单独的软件包。我们尚未考虑的是定义跨类型边界的运算的意义，如将复数与普通数相加。我们非常费尽心思地在程序的各个部分之间设置屏障，以便它们可以独立开发和理解。我们希望以某种精心控制的方式引入跨类型运算，以便在不严重违反模块边界的情况下支持它们。 </TEXT> 
  <TEXT> 一种处理 <INDEX>操作<SUBINDEX>跨类型</SUBINDEX></INDEX> <INDEX>跨类型操作</INDEX> <INDEX>类型<SUBINDEX>跨类型操作</SUBINDEX></INDEX> 跨类型操作的方法是为每种可能的、操作有效的数据类型组合设计不同的 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>。例如，我们可以扩展复数包，以便它提供一个 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 用于将复数加到普通数，并使用标签 <SPLITINLINE>(complex scheme-number)<JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;complex&quot;, &quot;javascript_number&quot;)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:<FOOTNOTE>我们还需要提供一个几乎相同的 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 来处理类型<PDF_ONLY><BR></BR></PDF_ONLY> <SPLITINLINE> (scheme_number complex) <JAVASCRIPT> <JAVASCRIPTINLINE>list(&quot;javascript_number&quot;, &quot;complex&quot;)</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> </FOOTNOTE> <SNIPPET CHAP="4" HIDE="yes">
      <NAME>add_complex_to_javascript_number_example</NAME>
      <JAVASCRIPT>
const c = make_complex_from_real_imag(4, 3);
const n = make_javascript_number(7);

add(c, n);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4" EVAL="no">
      <INDEX><DECLARATION>add_complex_to_javascript_num</DECLARATION></INDEX> 
      <NAME>add_complex_to_javascript_number</NAME>
      <REQUIRES>install_javascript_number_package_usage</REQUIRES>
      <REQUIRES>install_complex_package_usage</REQUIRES>
      <EXAMPLE>add_complex_to_javascript_number_example</EXAMPLE>
      <EXPECTED>[ &apos;complex&apos;, [ &apos;rectangular&apos;, [ 11, 3 ] ] ]</EXPECTED>
      <SCHEME>
;; to be included in the complex package
(define (add-complex-to-schemenum z x)
  (make-from-real-imag (+ (real-part z) x)
                       (imag-part z)))

(put &apos;add &apos;(complex scheme-number)
     (lambda (z x) (tag (add-complex-to-schemenum z x))))
      </SCHEME>
      <JAVASCRIPT>
// to be included in the complex package
function add_complex_to_javascript_num(z, x) {
   return make_complex_from_real_imag(real_part(z) + x, imag_part(z));
}
put(&quot;add&quot;, list(&quot;complex&quot;, &quot;javascript_number&quot;),
    (z, x) =&gt; tag(add_complex_to_javascript_num(z, x)));
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
   <TEXT> 这种技术有效，但非常繁琐。在这样的系统中，引入新类型的成本不仅仅是为该类型构建 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 的软件包，还包括实现跨类型操作的 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 的构建和安装。这可能会比定义该类型自身操作所需的代码量更多。该方法还影响了我们以加法方式组合独立包的能力，或至少限制了单个包的实现者需要考虑其他包的程度。例如，在上面的例子中，处理复数和普通数的混合操作似乎合理地应由复数包负责。然而，将有理数和复数组合可能由复数包、有理数包或某个使用这两个包提取操作的第三方包完成。在许多包和许多跨类型操作的系统设计中，对包之间责任划分制定一致的策略可能是一个艰巨的任务。 </TEXT> 

   <SUBHEADING> <NAME>强制类型转换</NAME> </SUBHEADING> 

   <INDEX>强制类型转换<OPEN></OPEN></INDEX> 
   <TEXT> 在完全不相关的操作作用于完全不相关的类型的情况下，实现显式的跨类型操作虽然繁琐，但已是最佳方案。幸运的是，通常我们可以通过利用类型系统中潜在的附加结构做得更好。通常，不同的数据类型并不是完全独立的，可能存在某种方法可以将一种类型的对象视为另一种类型的对象。这个过程被称为<EM>强制类型转换</EM>。例如，如果要求我们将一个普通数与一个复数进行算术组合，我们可以将普通数视为虚部为零的复数。这将问题转换为组合两个复数的问题，可以通过复数算术包以常规方式处理。 </TEXT> 
  <TEXT> 一般来说，我们可以通过设计 <INDEX>强制类型转换<SUBINDEX><SPLITINLINE>过程<JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX> 强制类型转换 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 来实现该想法，将一种类型的对象转换为另一种类型的等效对象。以下是一个典型的强制类型转换 <SPLITINLINE> 过程， <JAVASCRIPT>函数，</JAVASCRIPT> </SPLITINLINE> 将给定的普通数字转换为具有该实部和零虚部的复数： <SNIPPET EVAL="no">
      <INDEX><DECLARATION>javascript_number_to_complex</DECLARATION></INDEX> 
      <NAME>javascript_number_to_complex</NAME>
      <SCHEME>
(define (scheme-number-&gt;complex n)
  (make-complex-from-real-imag (contents n) 0))
      </SCHEME>
      <JAVASCRIPT>
function javascript_number_to_complex(n) {
    return make_complex_from_real_imag(contents(n), 0);
}
      </JAVASCRIPT>
    </SNIPPET>
     <INDEX>表<SUBINDEX><ORDER>强制类型转换</ORDER>用于强制转换</SUBINDEX></INDEX> <INDEX>强制类型转换<SUBINDEX>表</SUBINDEX></INDEX> 我们将在一个特殊的强制类型转换表中安装这些强制类型转换 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE>，按这两种类型的名称进行索引： <SNIPPET HIDE="yes">
      <NAME>put_get_coercion</NAME>
      <SCHEME>
(define coercion-list &apos;())

(define (clear-coercion-list)
  (set! coercion-list &apos;()))

(define (put-coercion type1 type2 item)
  (if (get-coercion type1 type2) coercion-list
      (set! coercion-list
            (cons (list type1 type2 item)
                  coercion-list))))

(define (get-coercion type1 type2)
  (define (get-type1 listItem)
    (car listItem))
  (define (get-type2 listItem)
    (cadr listItem))
  (define (get-item listItem)
    (caddr listItem))
  (define (get-coercion-iter list type1 type2)
    (if (null? list) #f
        (let ((top (car list)))
          (if (and (equal? type1 (get-type1 top))
                   (equal? type2 (get-type2 top))) (get-item top)
                   (get-coercion-iter (cdr list) type1 type2)))))
  (get-coercion-iter coercion-list type1 type2))
      </SCHEME>
      <JAVASCRIPT>
let coercion_list = null;

function clear_coercion_list() {
    coercion_list = null;
}

function put_coercion(type1, type2, item) {
    if (is_null(get_coercion(type1, type2))) {
        coercion_list = pair(list(type1, type2, item),
                             coercion_list);
    } else {
        return coercion_list;
    }
}

function get_coercion(type1, type2) {
    function get_type1(list_item) {
        return head(list_item);
    }
    function get_type2(list_item) {
        return head(tail(list_item));
    }
    function get_item(list_item) {
        return head(tail(tail(list_item)));
    }
    function get_coercion_iter(items) {
        if (is_null(items)) {
            return undefined;
        } else {
            const top = head(items);
            return equal(type1, get_type1(top)) &amp;&amp;
                   equal(type2, get_type2(top))
                   ? get_item(top)
                   : get_coercion_iter(tail(items));
        }
    }
    return get_coercion_iter(coercion_list);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4">
      <NAME>put_coercion_usage</NAME>
      <REQUIRES>put_get_coercion</REQUIRES>
      <REQUIRES>javascript_number_to_complex</REQUIRES>
      <REQUIRES>install_complex_package_usage</REQUIRES>
      <EXAMPLE>put_coercion_usage_example</EXAMPLE>
      <REQUIRES>put_get_coercion</REQUIRES>

      <SCHEME>
(put-coercion &apos;scheme-number &apos;complex scheme-number-&gt;complex)
      </SCHEME>
      <JAVASCRIPT>
put_coercion(&quot;javascript_number&quot;, &quot;complex&quot;,
             javascript_number_to_complex);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="3" HIDE="yes">
      <NAME>put_coercion_usage_example</NAME>
      <JAVASCRIPT>
get_coercion(&quot;javascript_number&quot;, &quot;complex&quot;);
      </JAVASCRIPT>
    </SNIPPET> (我们假设有 <SPLITINLINE> put-coercion <JAVASCRIPT><JAVASCRIPTINLINE>put_coercion</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 和 <SPLITINLINE> get-coercion <JAVASCRIPT><JAVASCRIPTINLINE>get_coercion</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 可用于操作此表。) 通常，表中的某些槽位将为空，因为通常不能将每种类型的任意数据对象强制转换为所有其他类型。例如，无法将任意复数转换为普通数，因此不会包含一般的 <SPLITINLINE> complex-&gt;scheme-number <JAVASCRIPT> <JAVASCRIPTINLINE>complex_to_javascript_number</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 在表中。 </TEXT>
  <TEXT> 一旦强制类型转换表建立，我们可以通过修改第<REF NAME="sec:data-directed"></REF>节的 <SPLITINLINE>  apply-generic <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 以一种统一的方式处理强制类型转换。当要求应用一个操作时，我们首先检查操作是否对参数的类型定义，就像以前一样。如果是，我们将调度到操作与类型表中找到的 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE>。否则，我们尝试强制类型转换。为简单起见，我们仅考虑存在两个参数的情况。<FOOTNOTE>请参见练习<REF NAME="ex:multi-coercion"></REF>了解一般情况。</FOOTNOTE> 我们检查强制类型转换表，以查看是否可以将第一种类型的对象强制转换为第二种类型。如果可以，我们进行强制类型转换后再尝试操作。如果第一种类型的对象通常不能被转换为第二种类型，则我们反过来尝试看看是否可以将第二个参数转换为第一个参数的类型。最后，如果没有已知的方法能将任一类型转换为另一种类型，我们就放弃。以下是 <SPLITINLINE> 过程： <JAVASCRIPT>函数：</JAVASCRIPT> </SPLITINLINE> <INDEX><DECLARATION>apply_generic</DECLARATION><SUBINDEX>带强制转换</SUBINDEX></INDEX> <SNIPPET HIDE="yes">
      <NAME>base_operation_table</NAME>
      <JAVASCRIPT>
// operation_table, put and get
// from chapter 3 (section 3.3.3)
function assoc(key, records) {
    return is_null(records)
           ? undefined
           : equal(key, head(head(records)))
             ? head(records)
             : assoc(key, tail(records));
}
function make_table() {
    const local_table = list(&quot;*table*&quot;);
    function lookup(key_1, key_2) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            return undefined;
        } else {
            const record = assoc(key_2, tail(subtable));
            if (is_undefined(record)) {
                return undefined;
            } else {
                return tail(record);
            }
        }
    }
    function insert(key_1, key_2, value) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            set_tail(local_table,
                     pair(list(key_1, pair(key_2, value)),
                          tail(local_table)));
        } else {
            const record = assoc(key_2, tail(subtable));
            if (is_undefined(record)) {
                set_tail(subtable,
                         pair(pair(key_2, value),
                              tail(subtable)));
            } else {
                set_tail(record, value);
            }
        }
    }
    function dispatch(m) {
        return m === &quot;lookup&quot;
               ? lookup
               : m === &quot;insert&quot;
                 ? insert
                 : &quot;undefined operation -- table&quot;;
    }
    return dispatch;
}
const operation_table = make_table();
const get = operation_table(&quot;lookup&quot;);
const put = operation_table(&quot;insert&quot;);

// In Source, most functions have a fixed number of arguments.
// (The function list is the only exception, to this so far.)
// The function apply_in_underlying_javascript allows us to
// apply any given function fun to all elements of the argument
// list args, as if they were separate arguments
function apply(fun, args) {
    return apply_in_underlying_javascript(fun, args);
}
function add(x, y) {
    return apply_generic(&quot;add&quot;, list(x, y));
}
function sub(x, y) {
    return apply_generic(&quot;sub&quot;, list(x, y));
}
function mul(x, y) {
    return apply_generic(&quot;mul&quot;, list(x, y));
}
function div(x, y) {
    return apply_generic(&quot;div&quot;, list(x, y));
}

function attach_tag(type_tag, contents) {
    return pair(type_tag, contents);
}
function type_tag(datum) {
    return is_pair(datum)
           ? head(datum)
           : error(datum, &quot;bad tagged datum -- type_tag&quot;);
}
function contents(datum) {
    return is_pair(datum)
           ? tail(datum)
           : error(datum, &quot;bad tagged datum -- contents&quot;);
}
</JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>javascript_number_package</NAME>
      <REQUIRES>base_operation_table</REQUIRES>
      <JAVASCRIPT>
function install_javascript_number_package() {
    function tag(x) {
        return attach_tag(&quot;javascript_number&quot;, x);
    }
    put(&quot;add&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x + y));
    put(&quot;sub&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x - y));
    put(&quot;mul&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x * y));
    put(&quot;div&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x / y));
    put(&quot;make&quot;, &quot;javascript_number&quot;,
        x =&gt; tag(x));
    return &quot;done&quot;;
}
install_javascript_number_package();

function make_javascript_number(n) {
    return get(&quot;make&quot;, &quot;javascript_number&quot;)(n);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>complex_number_package</NAME>
      <REQUIRES>base_operation_table</REQUIRES>
      <JAVASCRIPT>
// generic selector functions for complex numbers

function real_part(z) {
    return apply_generic(&quot;real_part&quot;, list(z));
}
function imag_part(z) {
    return apply_generic(&quot;imag_part&quot;, list(z));
}
function magnitude(z) {
    return apply_generic(&quot;magnitude&quot;, list(z));
}
function angle(z) {
    return apply_generic(&quot;angle&quot;, list(z));
}
function square(x) {
    return x * x;
}

function install_rectangular_package() {
    function real_part(z) { return head(z); }
    function imag_part(z) { return tail(z); }
    function make_from_real_imag(x, y) { return pair(x, y); }
    function magnitude(z) {
        return math_sqrt(square(real_part(z)) +
                   square(imag_part(z)));
    }
    function angle(z) {
        return math_atan2(imag_part(z), real_part(z));
    }
    function make_from_mag_ang(r, a) {
        return pair(r * math_cos(a), r * math_sin(a));
    }
    // interface to the rest of the system
    function tag(x) {
        return attach_tag(&quot;rectangular&quot;, x);
    }
    put(&quot;real_part&quot;, list(&quot;rectangular&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;rectangular&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;rectangular&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;rectangular&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;rectangular&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
install_rectangular_package();

function install_polar_package() {
    // internal functions
    function magnitude(z) { return head(z); }
    function angle(z) { return tail(z); }
    function make_from_mag_ang(r, a) { return pair(r, a); }
    function real_part(z) {
        return magnitude(z) * math_cos(angle(z));
    }
    function imag_part(z) {
        return magnitude(z) * math_sin(angle(z));
    }
    function make_from_real_imag(x, y) {
        return pair(math_sqrt(square(x) + square(y)),
                    math_atan2(y, x));
    }

    // interface to the rest of the system
    function tag(x) { return attach_tag(&quot;polar&quot;, x); }
    put(&quot;real_part&quot;, list(&quot;polar&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;polar&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;polar&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;polar&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;polar&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;polar&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
install_polar_package();

function install_complex_package() {
    // imported functions from rectangular and polar packages
    function make_from_real_imag(x, y) {
        return get(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;)(x, y);
    }
    function make_from_mag_ang(r, a) {
        return get(&quot;make_from_mag_ang&quot;, &quot;polar&quot;)(r, a);
    }

    // internal functions
    function add_complex(z1, z2) {
        return make_from_real_imag(real_part(z1) +
                                   real_part(z2),
                                   imag_part(z1) +
                                   imag_part(z2));
    }
    function sub_complex(z1, z2) {
        return make_from_real_imag(real_part(z1) -
                                   real_part(z2),
                                   imag_part(z1) -
                                   imag_part(z2));
    }
    function mul_complex(z1, z2) {
        return make_from_mag_ang(magnitude(z1) *
                                 magnitude(z2),
                                 angle(z1) +
                                 angle(z2));
    }
    function div_complex(z1, z2) {
        return make_from_mag_ang(magnitude(z1) /
                                 magnitude(z2),
                                 angle(z1) -
                                 angle(z2));
    }

    // interface to rest of the system
    function tag(z) {
        return attach_tag(&quot;complex&quot;, z);
    }
    put(&quot;add&quot;, list(&quot;complex&quot;, &quot;complex&quot;),
        (z1, z2) =&gt; tag(add_complex(z1, z2)));
    put(&quot;sub&quot;, list(&quot;complex&quot;, &quot;complex&quot;),
        (z1, z2) =&gt; tag(sub_complex(z1, z2)));
    put(&quot;mul&quot;, list(&quot;complex&quot;, &quot;complex&quot;),
        (z1, z2) =&gt; tag(mul_complex(z1, z2)));
    put(&quot;div&quot;, list(&quot;complex&quot;, &quot;complex&quot;),
        (z1, z2) =&gt; tag(div_complex(z1, z2)));
    put(&quot;make_from_real_imag&quot;, &quot;complex&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;complex&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
install_complex_package();

function make_complex_from_real_imag(x, y){
    return get(&quot;make_from_real_imag&quot;, &quot;complex&quot;)(x, y);
}
function make_complex_from_mag_ang(r, a){
    return get(&quot;make_from_mag_ang&quot;, &quot;complex&quot;)(r, a);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>coercion_support</NAME>
      <JAVASCRIPT>
// coercion support

let coercion_list = null;

function clear_coercion_list() {
    coercion_list = null;
}

function put_coercion(type1, type2, item) {
    if (is_undefined(get_coercion(type1, type2))) {
        coercion_list = pair(list(type1, type2, item),
                             coercion_list);
    } else {
        return coercion_list;
    }
}

function get_coercion(type1, type2) {
    function get_type1(list_item) {
        return head(list_item);
    }
    function get_type2(list_item) {
        return head(tail(list_item));
    }
    function get_item(list_item) {
        return head(tail(tail(list_item)));
    }
    function get_coercion_iter(items) {
        if (is_null(items)) {
            return undefined;
        } else {
            const top = head(items);
            return equal(type1, get_type1(top)) &amp;&amp;
                   equal(type2, get_type2(top))
                   ? get_item(top)
                   : get_coercion_iter(tail(items));
        }
    }
    return get_coercion_iter(coercion_list);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>apply_generic_with_coercion_example</NAME>
      <REQUIRES>base_operation_table</REQUIRES>
      <REQUIRES>javascript_number_package</REQUIRES>
      <REQUIRES>complex_number_package</REQUIRES>
      <REQUIRES>coercion_support</REQUIRES>
      <JAVASCRIPT>
function javascript_number_to_complex(n) {
    return make_complex_from_real_imag(contents(n), 0);
}

put_coercion(&quot;javascript_number&quot;, &quot;complex&quot;,
             javascript_number_to_complex);

const c = make_complex_from_real_imag(4, 3);
const n = make_javascript_number(7);

add(c, n);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4">
      <NAME>apply_generic_with_coercion</NAME>
      <EXAMPLE>apply_generic_with_coercion_example</EXAMPLE>
      <EXPECTED>[ &apos;complex&apos;, [ &apos;rectangular&apos;, [ 11, 3 ] ] ]</EXPECTED>
      <SCHEME>
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
        (apply proc (map contents args))
        (if (= (length args) 2)
          (let ((type1 (car type-tags))
                 (type2 (cadr type-tags))
                 (a1 (car args))
                 (a2 (cadr args)))
            (let ((t1-&gt;t2 (get-coercion type1 type2))
                  (t2-&gt;t1 (get-coercion type2 type1)))
              (cond (t1-&gt;t2
                      (apply-generic op (t1-&gt;t2 a1) a2))
                    (t2-&gt;t1
                      (apply-generic op a1 (t2-&gt;t1 a2)))
                    (else
                      (error &quot;No method for these types&quot;
                        (list op type-tags))))))
          (error &quot;No method for these types&quot;
            (list op type-tags)))))))
      </SCHEME>
      <JAVASCRIPT>
function apply_generic(op, args) {
    const type_tags = map(type_tag, args);
    const fun = get(op, type_tags);
    if (! is_undefined(fun)) {
        return apply(fun, map(contents, args));
    } else {
        if (length(args) === 2) {
            const type1 = head(type_tags);
            const type2 = head(tail(type_tags));
            const a1 = head(args);
            const a2 = head(tail(args));
            const t1_to_t2 = get_coercion(type1, type2);
            const t2_to_t1 = get_coercion(type2, type1);
            return ! is_undefined(t1_to_t2)
                   ? apply_generic(op, list(t1_to_t2(a1), a2))
                   : ! is_undefined(t2_to_t1)
                   ? apply_generic(op, list(a1, t2_to_t1(a2)))
                   : error(list(op, type_tags),
                           &quot;no method for these types&quot;);
        } else {
            return error(list(op, type_tags),
                         &quot;no method for these types&quot;);
        }
    }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT> 这种强制类型转换方案比定义显式跨类型操作的方法有许多优点，如上所述。虽然我们仍然需要编写强制类型转换 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 来关联这些类型（可能 【46:0†cn.txt】 <LATEXINLINE>$n^2$</LATEXINLINE>
     <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 用于一个系统 <LATEXINLINE>$n$</LATEXINLINE> 类型），我们只需要为每对类型编写一个 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> ，而不是为每个类型集合和每个通用操作编写一个不同的 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 。<FOOTNOTE>如果我们足够聪明，通常可以用少于 $n^2$ 的强制类型转换 <SPLITINLINE> 过程。 <JAVASCRIPT>函数。</JAVASCRIPT> </SPLITINLINE> 例如，如果我们知道如何从类型1转换到类型2，再从类型2转换到类型3，那么我们可以利用这些知识从类型1转换到类型3。这可以极大减少我们在系统中新增类型时需要显式提供的强制类型转换 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 的数量。如果我们愿意在系统中构建所需的复杂性，我们可以让系统搜索类型之间关系的<QUOTE>图</QUOTE>，并自动生成那些能从显式提供的强制类型转换 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 推导出来的过程。</FOOTNOTE>我们依赖的是类型之间适当的变换仅依赖于类型本身，而不依赖于将要应用的操作。 </TEXT>
   <DO_BREAK_PAGE></DO_BREAK_PAGE> 
   <TEXT> 另一方面，对于某些应用，我们的强制类型转换方案可能不够通用。即使要组合的对象都无法转换为对方的类型，通过将这两个对象转换为第三种类型，仍然可能进行该操作。为了处理这种复杂性，同时保持程序的模块性，通常有必要构建利用类型间关系中更深层结构的系统，正如我们接下来将讨论的那样。 </TEXT> 

   <SUBHEADING> <NAME>类型层次结构</NAME> </SUBHEADING> 

   <INDEX>类型<SUBINDEX>层次结构</SUBINDEX><OPEN></OPEN></INDEX> 
   <INDEX>类型层次结构<OPEN></OPEN></INDEX> 
   <TEXT> 上述强制类型转换方案依赖于类型对之间自然关系的存在。通常，不同类型之间的关系具有更“全局”的结构。例如，假设我们正在构建一个通用算术系统，以处理整数、有理数、实数和复数。在这样的系统中，将整数视为一种特殊的有理数，再将其视为一种特殊的实数，最终视为一种特殊的复数是非常自然的。实际上，我们拥有一个所谓的<EM>类型层次结构</EM>，例如，整数是有理数的 <INDEX>子类型</INDEX> <INDEX>类型<SUBINDEX>子类型</SUBINDEX></INDEX> <EM>子类型</EM>（即任何可以应用于有理数的操作都可以自动应用于整数）。反过来，我们说有理数形成整数的 <INDEX>超类型</INDEX> <INDEX>类型<SUBINDEX>超类型</SUBINDEX></INDEX> <EM>超类型</EM>。我们这里的特定层次结构是非常简单的，其中每种类型最多只有一个超类型和一个子类型。这种结构称为<EM>塔</EM>，在图<REF NAME="fig:tower"></REF>中有所说明。 <FIGURE> <FIGURE SPLIT_SCALE="0.1" WEB_SCALE="0.2" SCALE="0.59" SRC="img_original/ch2-Z-G-66.svg"></FIGURE> <CAPTION>类型塔。 <INDEX>类型塔</INDEX> <INDEX>类型<SUBINDEX>塔</SUBINDEX></INDEX> </CAPTION>  </FIGURE> </TEXT> 
   <TEXT> 如果我们有一个塔结构，那么我们可以极大地简化向层次结构中添加新类型的问题，因为我们只需要指定新类型如何嵌入在其上方的下一个超类型中，以及它如何成为其下方类型的超类型。例如，如果我们想将一个整数添加到一个复数中，我们不需要显式定义一个特殊的强制类型转换 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> <SPLITINLINE> integer-&gt;complex. <JAVASCRIPT><JAVASCRIPTINLINE>integer_to_complex</JAVASCRIPTINLINE>. </JAVASCRIPT> </SPLITINLINE> 相反，我们定义一个整数可以如何转换为有理数，有理数如何转换为实数，以及实数如何转换为复数。然后我们允许系统通过这几个步骤将整数转换为复数并然后将两个复数相加。 </TEXT> 
   <TEXT> <INDEX>类型<SUBINDEX>提升</SUBINDEX></INDEX> <INDEX><USE>apply_generic</USE><SUBINDEX>带类型塔</SUBINDEX></INDEX> 我们可以通过以下方式重新设计我们的 <SPLITINLINE> apply-generic <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE>：对于每种类型，我们需要提供一个 raise <SPLITINLINE> 过程， <JAVASCRIPT>函数，</JAVASCRIPT> </SPLITINLINE> 该函数将该类型的对象“提升”一个层次到塔中。然后，当系统需要对不同类型的对象进行操作时，它可以逐步提升较低的类型，直到所有对象都位于塔中的相同层次。（练习<SPACE></SPACE><REF NAME="ex:raise"></REF> 和 <SPACE></SPACE><REF NAME="ex:apply-with-raise"></REF> 涉及实现这种策略的详细信息。） </TEXT> 
   <TEXT> 另一个塔结构的优点是我们可以轻松实现每种类型都“继承”定义在其超类型上的所有操作的概念。例如，如果我们没有提供一个用于查找整数实部的特殊 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> ，我们仍然可以期望 <SPLITINLINE> real-part <JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 会因为整数是复数的子类型而定义在整数上。在塔中，我们可以通过修改 <SPLITINLINE> apply-generic. <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>. </JAVASCRIPT> </SPLITINLINE> 来以统一的方式实现这一点。如果所需的操作未直接针对给定对象的类型定义，我们会将对象提升到其超类型并再次尝试。因此，我们沿着塔不断向上爬，随着前进而转换我们的参数，直到我们找到可以执行所需操作的层次，或到达顶层（在这种情况下，我们放弃）。 </TEXT> 
   <TEXT> <INDEX>类型<SUBINDEX>降低</SUBINDEX></INDEX> 底层结构的另一个优点是，它为我们提供了一种简单的方法来将数据对象“降为”最简单的表示。例如，如果我们将 $2+3i$ 加到 $4-3i$，得出结果为整数6而不是复数 $6+0i$会很好。练习<REF NAME="ex:simplify"></REF>讨论了实现这种降低操作的方法。（诀窍在于我们需要一种通用的方法来区分那些可以被降低的对象，比如 $6+0i$，与那些不能被降低的对象，比如 $6+2i$。） </TEXT> 

   <SUBHEADING> <NAME>层次结构的不足</NAME> </SUBHEADING> 

   <INDEX>类型层次结构<SUBINDEX>的不足</SUBINDEX></INDEX> 
  <TEXT> 如果我们系统中的数据类型可以自然地安排成一个塔结构，那么如我们所见，这将极大地简化处理不同类型上的通用操作的问题。不幸的是，通常情况并非如此。图<REF NAME="fig:relations-among-figures"></REF>展示了一种更复杂的混合类型排列，显示了不同几何图形类型之间的关系。我们看到，通常来说， <INDEX>类型<SUBINDEX>多重子类型和超类型</SUBINDEX></INDEX> <INDEX>超类型<SUBINDEX>多个</SUBINDEX></INDEX> <INDEX>子类型<SUBINDEX>多个</SUBINDEX></INDEX> 一个类型可以有多个子类型。例如，三角形和四边形都是多边形的子类型。此外，一个类型可以有多个超类型。例如，一个等腰直角三角形可以被视为等腰三角形或直角三角形。这种多重超类型的问题尤其棘手，因为这意味着在层次结构中没有唯一的方法将一个类型“提升”。为对象找到应用操作的“正确”超类型可能需要大量的搜索， <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 例如 <SPLITINLINE> apply-generic. <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>. </JAVASCRIPT> </SPLITINLINE> 由于通常一个类型有多个子类型，因此在将一个值“降低”到类型层次结构时也存在类似的问题。处理大量相互关联的类型同时在大型系统的设计中保持模块性是非常困难的，并且这是当前研究的一个热点领域。  <FOOTNOTE>这段话出现在该书的第一版中，现在仍然适用，就像我们十二年前编写时一样。开发一个用于表达不同实体类型之间关系的有用且通用的框架（哲学家称之为“本体论”）似乎难以解决。当前与十年前的混乱之间的主要区别在于，现在各种不完善的本体论理论已经被植入相应不完善的编程语言中。例如，面向对象编程语言的复杂性——以及当代面向对象语言之间微妙且混乱的差异——主要集中在处理相互关联类型上的通用操作。我们在第<REF NAME="chap:state"></REF>章中对计算对象的讨论完全避免了这些问题。熟悉面向对象编程的读者会注意到我们在第<REF NAME="chap:state"></REF>章中对局部状态有很多讨论，但我们甚至没有提到“类”或“继承”。事实上，我们怀疑这些问题不能仅通过计算机语言设计来充分解决，而不借助知识表示和自动推理方面的工作。</FOOTNOTE> </TEXT>
   <FIGURE> <FIGURE SPLIT_SCALE="0.6" SCALE="0.59" SRC="img_original/ch2-Z-G-67.svg"></FIGURE> <CAPTION>几何图形类型之间的关系。</CAPTION>  </FIGURE> 

  <EXERCISE>
      <INDEX><USE>apply_generic</USE><SUBINDEX>带强制转换</SUBINDEX></INDEX> Louis Reasoner 注意到 <SPLITINLINE> apply-generic <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 可能尝试将参数强制转换为彼此的类型，即使它们已经具有相同的类型。因此，他推测，我们需要在强制转换表中放置 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 以将每种类型的参数“强制转换”到其自身的类型。例如，除了上面展示的 <SPLITINLINE> scheme-number-&gt;complex <JAVASCRIPT> <JAVASCRIPTINLINE>javascript_number_to_complex</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 强制转换外，他还会这样做： <SNIPPET EVAL="no">
      <INDEX><DECLARATION>javascript_number_to_javascript_</DECLARATION> <JAVASCRIPTINLINE>number</JAVASCRIPTINLINE></INDEX> 
      <INDEX><DECLARATION>complex_to_complex</DECLARATION></INDEX> 
      <SCHEME>
(define (scheme-number-&gt;scheme-number n) n)
(define (complex-&gt;complex z) z)
(put-coercion &apos;scheme-number &apos;scheme-number
  scheme-number-&gt;scheme-number)
(put-coercion &apos;complex &apos;complex complex-&gt;complex)
      </SCHEME>
      <JAVASCRIPT>
function javascript_number_to_javascript_number(n) { return n; }
<SHORT_SPACE></SHORT_SPACE>	
function complex_to_complex(n) { return n; }
<SHORT_SPACE></SHORT_SPACE>
put_coercion(&quot;javascript_number&quot;, &quot;javascript_number&quot;,
             javascript_number_to_javascript_number);
put_coercion(&quot;complex&quot;, &quot;complex&quot;, complex_to_complex);
      </JAVASCRIPT>
    </SNIPPET>

    <OL>
      <LI> 随着 Louis 的强制类型转换 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 安装，如果 <SPLITINLINE> apply-generic <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 被调用且带有两个类型为 <SPLITINLINE> scheme-number <JAVASCRIPT><JAVASCRIPTINLINE>&quot;complex&quot;</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 或两个参数为类型的 <SPLITINLINE> complex <JAVASCRIPT><JAVASCRIPTINLINE>&quot;javascript_@number&quot;</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 且在这些类型的表中找不到操作，会发生什么？例如，假设我们已经定义了一个通用的指数运算： <SNIPPET EVAL="no">
          <REQUIRES>apply_generic</REQUIRES>
          <SCHEME>
(define (exp x y) (apply-generic &apos;exp x y))
          </SCHEME>
          <JAVASCRIPT>
function exp(x, y) {
    return apply_generic(&quot;exp&quot;, list(x, y));
}
          </JAVASCRIPT>
        </SNIPPET> 并在 <SPLITINLINE> Scheme-number <JAVASCRIPT>JavaScript-number</JAVASCRIPT> </SPLITINLINE> 包中但不在任何其他包中放入一个用于求幂的 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE>： <SNIPPET EVAL="no" LATEX="yes">
          <SCHEME>
;; following added to Scheme-number package
(put &apos;exp &apos;(scheme-number scheme-number)
  (lambda (x y) (tag (expt x y)))) ; using primitive expt
          </SCHEME>
          <JAVASCRIPT>
// following added to JavaScript-number package
put(&quot;exp&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
    (x, y) =&gt; tag(math_exp(x, y))); // using primitive $\texttt{math\char`_exp}$
          </JAVASCRIPT>
        </SNIPPET> 如果我们调用会发生什么 <SCHEMEINLINE>exp</SCHEMEINLINE> 以两个复数作为参数会怎样？ </LI>
       <LI> Louis 是否正确地认为针对相同类型参数的强制转换需要进行处理，或者 <SPLITINLINE> apply-generic <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 本身是否工作正常？ </LI> <LI> 修改 <SPLITINLINE> apply-generic <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 使得在两个参数具有相同类型时不尝试进行强制转换。 </LI> </OL>
    <SOLUTION>
    <OL>
     <LI> 如果 Louis 将强制类型转换函数放入操作表中， <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> 将进入一个无限循环 </LI> <LI> Louis 的代码不起作用。 <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> 按原样正确工作。但我们可以修改它，使其在尝试任何相同类型的强制转换之前退出并报错。 </LI> <LI>
    <SNIPPET HIDE="yes">
    <NAME>apply_generic_with_unavailable_type_example</NAME>
    <REQUIRES>base_operation_table</REQUIRES>
    <REQUIRES>complex_number_package</REQUIRES>
    <REQUIRES>coercion_support</REQUIRES>
    <JAVASCRIPT>

function install_javascript_number_package() {
    function tag(x) {
        return attach_tag(&quot;javascript_number&quot;, x);
    }
    put(&quot;add&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x + y));
    put(&quot;sub&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x - y));
    put(&quot;mul&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x * y));
    put(&quot;div&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x / y));
    put(&quot;exp&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
    (x, y) =&gt; tag(math_exp(x, y)));
    put(&quot;make&quot;, &quot;javascript_number&quot;,
        x =&gt; tag(x));
    return &quot;done&quot;;
}
install_javascript_number_package();

function make_javascript_number(n) {
    return get(&quot;make&quot;, &quot;javascript_number&quot;)(n);
}

function javascript_number_to_javascript_number(n) {
    return n;
}
function complex_to_complex(n) {
    return n;
}
put_coercion(&quot;javascript_number&quot;, &quot;javascript_number&quot;,
             javascript_number_to_javascript_number);
put_coercion(&quot;complex&quot;, &quot;complex&quot;,
             complex_to_complex);
function exp(x, y) {
    return apply_generic(&quot;exp&quot;, list(x, y));
}

const c = make_javascript_number(4);
const d = make_javascript_number(2);
exp(c, d);

    </JAVASCRIPT>
    <SCHEME></SCHEME>
    </SNIPPET>
    <SNIPPET CHAP="4">
      <NAME>apply_generic_with_unavailable_type</NAME>
      <EXAMPLE>apply_generic_with_unavailable_type_example</EXAMPLE>
      <SCHEME>
      </SCHEME>
      <JAVASCRIPT>
function apply_generic(op, args) {
    const type_tags = map(type_tag, args);
    const fun = get(op, type_tags);
    if (! is_undefined(fun)) {
        return apply(fun, map(contents, args));
    } else {
        if (length(args) === 2) {
            const type1 = head(type_tags);
            const type2 = head(tail(type_tags));
            const a1 = head(args);
            const a2 = head(tail(args));
            const t1_to_t2 = get_coercion(type1, type2);
            const t2_to_t1 = get_coercion(type2, type1);
            return type1 === type2
                   ? error(list(op, type_tags),
                                &quot;no method for these types&quot;)
                   : ! is_undefined(t1_to_t2)
                   ? apply_generic(op, list(t1_to_t2(a1), a2))
                   : ! is_undefined(t2_to_t1)
                   ? apply_generic(op, list(a1, t2_to_t1(a2)))
                   : error(list(op, type_tags),
                           &quot;no method for these types&quot;);
        } else {
            return error(list(op, type_tags),
                         &quot;no method for these types&quot;);
        }
    }
}
      </JAVASCRIPT>
    </SNIPPET>
    </LI>
    </OL>
    </SOLUTION>
    <LABEL NAME="ex:2_81"></LABEL>
  </EXERCISE>

  <EXERCISE>
      <INDEX><USE>apply_generic</USE><SUBINDEX>对多参数进行强制转换</SUBINDEX></INDEX> 展示如何将 <SPLITINLINE> apply-generic <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 泛化为处理多参数的强制转换。一种策略是尝试将所有参数强制转换为第一个参数的类型，然后是第二个参数的类型，以此类推。举一个此策略（以及上述的双参数版本）不够通用的例子。（提示：考虑在表中存在一些适合的混合类型操作但不会被尝试的情况。） <LABEL NAME="ex:multi-coercion"></LABEL>
    <SOLUTION>
      <SNIPPET HIDE="yes">
      <NAME>multi_coercion_example</NAME>
      <REQUIRES>base_operation_table</REQUIRES>
      <REQUIRES>javascript_number_package</REQUIRES>
      <REQUIRES>complex_number_package</REQUIRES>
      <REQUIRES>coercion_support</REQUIRES>
      <JAVASCRIPT>
function javascript_number_to_complex(n) {
    return make_complex_from_real_imag(contents(n), 0);
}

put_coercion(&quot;javascript_number&quot;, &quot;complex&quot;,
             javascript_number_to_complex);

put(&quot;add&quot;, list(&quot;complex&quot;, &quot;complex&quot;, &quot;complex&quot;),
  (x, y, z) =&gt; attach_tag(&quot;complex&quot;, make_complex_from_real_imag(
    real_part(x) + real_part(y) + real_part(z),
    imag_part(x) + imag_part(y) + imag_part(z))));

function add_three(x, y, z) {
    return apply_generic(&quot;add&quot;, list(x, y, z));
}

const c = make_complex_from_real_imag(4, 3);
const n = make_javascript_number(7);
add_three(c, c, n);
// add_three(c, n, n);

      </JAVASCRIPT>
      <SCHEME></SCHEME>
      </SNIPPET>
      <SNIPPET CHAP="4">
        <NAME>multi_coercion</NAME>
        <EXAMPLE>multi_coercion_example</EXAMPLE>
        <JAVASCRIPT>
function can_coerce_to(type_tags, target_type) {
    return accumulate((type_tag, result) =&gt;
                        result &amp;&amp;
                        (type_tag === target_type ||
                         ! is_undefined(get_coercion(type_tag, target_type))),
                      true,
                      type_tags);
}

function find_coerced_type(type_tags) {
    return is_null(type_tags)
           ? undefined
           : can_coerce_to(type_tags, head(type_tags))
           ? head(type_tags)
           : find_coerced_type(tail(type_tags));
}

function coerce_all(args, target_type) {
    return map(arg =&gt; type_tag(arg) === target_type
                      ? arg
                      : get_coercion(type_tag(arg), target_type)(arg),
               args);
}

function apply_generic(op, args) {
    const type_tags = map(type_tag, args);
    const fun = get(op, type_tags);
    if (! is_undefined(fun)) {
        return apply(fun, map(contents, args));
    } else {
        const target_type = find_coerced_type(type_tags);
        if (! is_undefined(target_type)) {
          return apply_generic(op, coerce_all(args, target_type));
        } else {
            return error(list(op, type_tags),
                         &quot;no method for these types&quot;);
        }
    }
}
        </JAVASCRIPT>
      </SNIPPET> 一种情况下这种方法是不够的：如果你有三种类型，A、B、C，其中A可以强制转换为B并且C可以强制转换为B，并且有一个注册的操作为(A, B, B)。对于(A, B, C)的运算只会尝试(A, B, C)和(B, B, B)，但你可以简单地将C强制转换为B，并使用(A, B, B)的注册操作。 </SOLUTION>
  </EXERCISE>

  <EXERCISE>
     <INDEX>类型<SUBINDEX>提升</SUBINDEX></INDEX> 假设你正在设计一个处理图<REF NAME="fig:tower"></REF>中显示的类型塔的通用算术系统：整数、有理数、实数、复数。对于每种类型（除了复数），设计一个 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 将该类型的对象提升一个层次到塔中。展示如何安装一个通用【136:3†cn.txt】 <SCHEMEINLINE>raise</SCHEMEINLINE> 操作，该操作将适用于每一种类型（除了复数）。 <LABEL NAME="ex:raise"></LABEL>
    <SOLUTION>
      <SNIPPET HIDE="yes">
      <NAME>rational_number_package</NAME>
      <JAVASCRIPT>
function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

function install_rational_package() {
    // internal functions
    function numer(x) {
        return head(x);
    }
    function denom(x) {
        return tail(x);
    }
    function make_rat(n, d) {
        let g = gcd(n, d);
        return pair(n / g, d / g);
    }
    function add_rat(x, y) {
        return make_rat(numer(x) * denom(y) +
                        numer(y) * denom(x),
                        denom(x) * denom(y));
    }
    function sub_rat(x, y) {
        return make_rat(numer(x) * denom(y) -
                        numer(y) * denom(x),
                        denom(x) * denom(y));
    }
    function mul_rat(x, y) {
        return make_rat(numer(x) * numer(y),
                        denom(x) * denom(y));
    }
    function div_rat(x, y) {
        return make_rat(numer(x) * denom(y),
                        denom(x) * numer(y));
    }
    // interface to rest of the system
    function tag(x) {
        return attach_tag(&quot;rational&quot;, x);
    }
    put(&quot;add&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(add_rat(x, y)));
    put(&quot;sub&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(sub_rat(x, y)));
    put(&quot;mul&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(mul_rat(x, y)));
    put(&quot;div&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(div_rat(x, y)));
    put(&quot;make&quot;, &quot;rational&quot;,
        (n, d) =&gt; tag(make_rat(n, d)));
}
install_rational_package();

function make_rational(n, d) {
    return get(&quot;make&quot;, &quot;rational&quot;)(n, d);
}
</JAVASCRIPT>
<SCHEME></SCHEME>
</SNIPPET>
      <SNIPPET HIDE="yes">
        <REQUIRES>javascript_number_package</REQUIRES>
        <REQUIRES>rational_number_package</REQUIRES>
        <REQUIRES>complex_number_package</REQUIRES>
        <REQUIRES>coercion_support</REQUIRES>
        <REQUIRES>apply_generic_with_coercion</REQUIRES>
        <NAME>raise_example</NAME>
        <JAVASCRIPT>
const a = make_javascript_number(2);
const b = make_rational(2, 3);
raise(a);
// raise(b);
        </JAVASCRIPT>
        <SCHEME></SCHEME>
      </SNIPPET>
      <SNIPPET CHAP="4">
        <NAME>raise</NAME>
        <EXAMPLE>raise_example</EXAMPLE>
        <JAVASCRIPT>
function raise(x) {
    return apply_generic(&quot;raise&quot;, list(x));
}

// add to Javascript-number package
put(&quot;raise&quot;, list(&quot;javascript_number&quot;),
    x =&gt; make_rational(x, 1));
//// add to rational package
// put(&quot;raise&quot;, list(&quot;rational&quot;),
//     x =&gt; make_real(div, numer(x), denom(x)));
// put(&quot;raise&quot;, list(&quot;rational&quot;),
//     x =&gt; make_complex_from_real_imag(x, 0));
//// add to real package
// put(&quot;raise&quot;, list(&quot;real&quot;),
//     x =&gt; make_complex_from_real_imag(x, 0));
        </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

   <EXERCISE> <INDEX><USE>apply_generic</USE><SUBINDEX>通过提升进行强制转换</SUBINDEX></INDEX> 使用练习<REF NAME="ex:raise"></REF>的raise操作，修改 <SPLITINLINE> apply-generic <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 以便通过本节讨论的逐层提升方法，将其参数强制转换为相同类型。您需要设计一种方法来测试两个类型中哪个在塔中更高。按照与系统其他部分“兼容”的方式做到这一点，并不会导致向塔中添加新层级时出现问题。  </EXERCISE> 

  <EXERCISE>
      <INDEX><USE>apply_generic</USE><SUBINDEX>通过下降进行简化</SUBINDEX></INDEX> <INDEX>类型<SUBINDEX>降低</SUBINDEX></INDEX> 本节提到了通过尽可能低地降低数据对象到类型塔中以进行“简化”的方法。设计一个 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE>   <SCHEMEINLINE>drop</SCHEMEINLINE> 实现练习<REF NAME="ex:raise"></REF>中描述的塔的功能。关键是要以某种通用方式判断一个对象是否可以降低。例如，复数 <LATEXINLINE>$1.5+0i$</LATEXINLINE> 可以被降低到 <SPLITINLINE> real, <JAVASCRIPT><JAVASCRIPTINLINE>&quot;real&quot;</JAVASCRIPTINLINE>,</JAVASCRIPT> </SPLITINLINE> 复数 <LATEXINLINE>$1+0i$</LATEXINLINE> 可以被降低到 <SPLITINLINE> integer, <JAVASCRIPT><JAVASCRIPTINLINE>&quot;integer&quot;</JAVASCRIPTINLINE>,</JAVASCRIPT> </SPLITINLINE> 和复数 <LATEXINLINE>$2+3i$</LATEXINLINE> 无法降低。以下是确定对象是否可以降低的计划：首先定义一个通用操作 <SCHEMEINLINE>project</SCHEMEINLINE> 通过降低塔中的对象来“推”它。例如，投影一个复数将涉及丢弃虚部。然后，如果当我们 【158:10†cn.txt】 <SCHEMEINLINE>project</SCHEMEINLINE> 它和 <SCHEMEINLINE>raise</SCHEMEINLINE> 结果返回到我们开始的类型，我们最终得到的等于我们开始的。通过编写一个详细地展示如何实现这个想法的 <SCHEMEINLINE>drop</SCHEMEINLINE>
     <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 将一个对象尽可能地降低。您将需要设计各种投影操作<FOOTNOTE>可以使用 <INDEX><USE>math_round</USE> （原语函数）</INDEX> <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>math_round</USE><ECMA>Math.round</ECMA></SUBINDEX></INDEX> <SPLITINLINE>  round  <JAVASCRIPT> <JAVASCRIPTINLINE>math_round</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 原语将实数投影到整数，该函数返回最接近其参数的整数。</FOOTNOTE> 并安装   <SCHEMEINLINE>project</SCHEMEINLINE> 作为系统中的一种通用操作。您还需使用通用等式谓词，例如在练习<REF NAME="ex:equ?"></REF>中描述的。最后，使用  <SCHEMEINLINE>drop</SCHEMEINLINE> 重写练习<REF NAME="ex:apply-with-raise"></REF>中的 <SPLITINLINE> apply-generic <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> ，使其“简化”其答案。 <LABEL NAME="ex:simplify"></LABEL>
  </EXERCISE>

   <EXERCISE> 假设我们希望处理复数，它们的实部、虚部、幅度和角度可以是普通数、有理数或我们可能希望添加到系统中的其他数字。描述并实现为适应此情况系统所需的更改。您将不得不定义一些操作如 sine 和 cosine，这些操作是普通数和有理数的通用操作。  </EXERCISE> 

   <INDEX>强制类型转换<CLOSE></CLOSE></INDEX> 
   <INDEX>类型<SUBINDEX>层次结构</SUBINDEX><CLOSE></CLOSE></INDEX> 
   <INDEX>类型层次结构<CLOSE></CLOSE></INDEX> 

</SUBSECTION>
