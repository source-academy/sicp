<SUBSECTION>
  

  <LABEL NAME="sec:combining-data-of-different-types"></LABEL>

  
  
  <TEXT>
    一种处理
    <INDEX>operation<SUBINDEX>跨类型</SUBINDEX></INDEX>
    <INDEX>跨类型运算</INDEX>
    <INDEX>type(s)<SUBINDEX>跨类型运算</SUBINDEX></INDEX>
    跨类型运算的方法是为每个对该运算有效的类型组合设计一个不同的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。例如，我们可以扩展复数包，使其提供一个用于将复数与普通数字相加的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，并使用标签
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(complex scheme-number)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;complex&quot;, &quot;javascript_number&quot;)</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    将其安装到表中：
    <FOOTNOTE>我们还必须提供一个几乎相同的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    来处理这些类型<PDF_ONLY><BR></BR></PDF_ONLY>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(scheme_number complex)</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>list(&quot;javascript_number&quot;, &quot;complex&quot;)</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE></FOOTNOTE>
    <SNIPPET CHAP="4" HIDE="yes">
      <NAME>add_complex_to_javascript_number_example</NAME>
      <JAVASCRIPT>
const c = make_complex_from_real_imag(4, 3);
const n = make_javascript_number(7);

add(c, n);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4" EVAL="no">
      <INDEX><DECLARATION>add_complex_to_javascript_num</DECLARATION></INDEX> 
      <NAME>add_complex_to_javascript_number</NAME>
      <REQUIRES>install_javascript_number_package_usage</REQUIRES>
      <REQUIRES>install_complex_package_usage</REQUIRES>
      <EXAMPLE>add_complex_to_javascript_number_example</EXAMPLE>
      <EXPECTED>[ &apos;complex&apos;, [ &apos;rectangular&apos;, [ 11, 3 ] ] ]</EXPECTED>
      <SCHEME>
;; 要包含在复数包中
(define (add-complex-to-schemenum z x)
  (make-from-real_imag (+ (real-part z) x)
                       (imag-part z)))

(put &apos;add &apos;(complex scheme-number)
     (lambda (z x) (tag (add-complex-to-schemenum z x))))
      </SCHEME>
      <JAVASCRIPT>
// 要包含在复数包中
function add_complex_to_javascript_num(z, x) {
   return make_complex_from_real_imag(real_part(z) + x, imag_part(z));
}
put(&quot;add&quot;, list(&quot;complex&quot;, &quot;javascript_number&quot;),
    (z, x) =&gt; tag(add_complex_to_javascript_num(z, x)));
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

   <TEXT>
    这种技术是可行的，但它非常繁琐。在这种系统中，引入新类型的代价不仅仅在于构建该类型的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    包，还在于构建和安装实现跨类型运算的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。所需的代码量很容易远远超过仅定义类型自身运算所需的代码量。这种方法也削弱了我们以累加方式组合独立包的能力，或者至少限制各个包的实现者需要考虑其他包的程度。例如，在上述示例中，处理复数和普通数字之间混合运算的任务似乎理应由复数包负责。然而，组合有理数和复数的工作，可能由复数包、有理数包，或者由某个使用从这两个包中提取运算的第三方包来完成。在设计包含众多包和众多跨类型运算的系统时，制定各包之间责任分工的连贯策略可能是一项艰巨的任务。
  </TEXT> 

  
  <SUBHEADING>
    <NAME>强制类型转换</NAME>
  </SUBHEADING>


  
  <INDEX>强制类型转换<OPEN></OPEN></INDEX>

  
  <TEXT>
    在完全无关的操作作用于完全无关的类型的总体情况下，实现显式跨类型操作虽繁琐，却是目前所能达到的最佳手段。
    幸运的是，通过利用类型系统中可能潜在的附加结构，我们通常能做得更好。通常，不同的数据类型并非完全独立，
    而总存在某种方式可以将一种类型的对象视为另一种类型。这个过程被称为<EM>强制类型转换</EM>。例如，
    如果要求我们将一个普通数与一个复数组合进行算术运算，我们可以将普通数视为其虚部为零的复数。
    这样一来，问题就转化为组合两个复数的问题，而这一问题可以通过复数算术包以常规方式处理。
  </TEXT>

  <TEXT>
    通常，我们可以通过设计
    <INDEX>强制类型转换<SUBINDEX><SPLITINLINE><SCHEME>过程</SCHEME><JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    强制类型转换
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，将一种类型的对象转换成另一种类型的等价对象。下面是一个典型的强制类型转换
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    ，它将给定的普通数转换为其实部为该数且虚部为零的复数：
<SNIPPET EVAL="no">
      <INDEX><DECLARATION>javascript_number_to_complex</DECLARATION></INDEX> 
      <NAME>javascript_number_to_complex</NAME>
      <SCHEME>
(define (scheme-number-&gt;complex n)
  (make-complex-from-real-imag (contents n) 0))
      </SCHEME>
      <JAVASCRIPT>
function javascript_number_to_complex(n) {
    return make_complex_from_real_imag(contents(n), 0);
}
      </JAVASCRIPT>
    </SNIPPET>
    
    <INDEX>表<SUBINDEX><ORDER>强制类型转换</ORDER>用于强制类型转换</SUBINDEX></INDEX>
    <INDEX>强制类型转换<SUBINDEX>表</SUBINDEX></INDEX>
    我们将在一个特殊的强制类型转换表中安装这些
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，以这两种类型的名称为索引：
<SNIPPET HIDE="yes">
      <NAME>put_get_coercion</NAME>
      <SCHEME>
(define coercion-list &apos;())

(define (clear-coercion-list)
  (set! coercion-list &apos;()))

(define (put-coercion type1 type2 item)
  (if (get-coercion type1 type2) coercion-list
      (set! coercion-list
            (cons (list type1 type2 item)
                  coercion-list))))

(define (get-coercion type1 type2)
  (define (get-type1 listItem)
    (car listItem))
  (define (get-type2 listItem)
    (cadr listItem))
  (define (get-item listItem)
    (caddr listItem))
  (define (get-coercion-iter list type1 type2)
    (if (null? list) #f
        (let ((top (car list)))
          (if (and (equal? type1 (get-type1 top))
                   (equal? type2 (get-type2 top))) (get-item top)
                   (get-coercion-iter (cdr list) type1 type2)))))
  (get-coercion-iter coercion-list type1 type2))
      </SCHEME>
      <JAVASCRIPT>
let coercion_list = null;

function clear_coercion_list() {
    coercion_list = null;
}

function put_coercion(type1, type2, item) {
    if (is_null(get_coercion(type1, type2))) {
        coercion_list = pair(list(type1, type2, item),
                             coercion_list);
    } else {
        return coercion_list;
    }
}

function get_coercion(type1, type2) {
    function get_type1(list_item) {
        return head(list_item);
    }
    function get_type2(list_item) {
        return head(tail(list_item));
    }
    function get_item(list_item) {
        return head(tail(tail(list_item)));
    }
    function get_coercion_iter(items) {
        if (is_null(items)) {
            return undefined;
        } else {
            const top = head(items);
            return equal(type1, get_type1(top)) &amp;&amp;
                   equal(type2, get_type2(top))
                   ? get_item(top)
                   : get_coercion_iter(tail(items));
        }
    }
    return get_coercion_iter(coercion_list);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4">
      <NAME>put_coercion_usage</NAME>
      <REQUIRES>put_get_coercion</REQUIRES>
      <REQUIRES>javascript_number_to_complex</REQUIRES>
      <REQUIRES>install_complex_package_usage</REQUIRES>
      <EXAMPLE>put_coercion_usage_example</EXAMPLE>
      <REQUIRES>put_get_coercion</REQUIRES>

      <SCHEME>
(put-coercion &apos;scheme-number &apos;complex scheme-number-&gt;complex)
      </SCHEME>
      <JAVASCRIPT>
put_coercion(&quot;javascript_number&quot;, &quot;complex&quot;,
             javascript_number_to_complex);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="3" HIDE="yes">
      <NAME>put_coercion_usage_example</NAME>
      <JAVASCRIPT>
get_coercion(&quot;javascript_number&quot;, &quot;complex&quot;);
      </JAVASCRIPT>
    </SNIPPET> 
    （我们假定存在
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>put-coercion</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>put_coercion</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-coercion</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_coercion</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    用于操作此表。） 通常表中的某些槽位将为空，因为通常无法将每种类型的任意数据对象强制转换为所有其他类型。例如，没有办法将任意复数强制转换为普通数字，因此表中不会包含普遍的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>complex-&gt;scheme-number</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>complex_to_javascript_number</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。 
</TEXT>
  <TEXT><STRONG>强制类型转换表</STRONG><SPLITINLINE>  
  <SCHEME>  
    <SCHEMEINLINE>apply-generic</SCHEMEINLINE>  
  </SCHEME>  
  <JAVASCRIPT>  
    <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>  
  </JAVASCRIPT>  
</SPLITINLINE><SPLITINLINE>  
  <SCHEME>过程</SCHEME>  
  <JAVASCRIPT>函数</JAVASCRIPT>  
</SPLITINLINE><REF NAME="sec:data-directed"></REF><STRONG>强制类型转换</STRONG><SPLITINLINE>  
  <SCHEME>过程</SCHEME>  
  <JAVASCRIPT>函数</JAVASCRIPT>  
</SPLITINLINE><STRONG>强制类型转换</STRONG><FOOTNOTE>关于更一般情况，请参见练习<REF NAME="ex:multi-coercion"></REF>。</FOOTNOTE><STRONG>强制类型转换表</STRONG><SPLITINLINE>  
  <SCHEME>过程:</SCHEME>  
  <JAVASCRIPT>函数:</JAVASCRIPT>  
</SPLITINLINE><INDEX><DECLARATION>apply_generic</DECLARATION><SUBINDEX>with coercion</SUBINDEX></INDEX><SNIPPET HIDE="yes">
      <NAME>base_operation_table</NAME>
      <JAVASCRIPT>
// operation_table, put and get
// from chapter 3 (section 3.3.3)
function assoc(key, records) {
    return is_null(records)
           ? undefined
           : equal(key, head(head(records)))
             ? head(records)
             : assoc(key, tail(records));
}
function make_table() {
    const local_table = list(&quot;*table*&quot;);
    function lookup(key_1, key_2) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            return undefined;
        } else {
            const record = assoc(key_2, tail(subtable));
            if (is_undefined(record)) {
                return undefined;
            } else {
                return tail(record);
            }
        }
    }
    function insert(key_1, key_2, value) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            set_tail(local_table,
                     pair(list(key_1, pair(key_2, value)),
                          tail(local_table)));
        } else {
            const record = assoc(key_2, tail(subtable));
            if (is_undefined(record)) {
                set_tail(subtable,
                         pair(pair(key_2, value),
                              tail(subtable)));
            } else {
                set_tail(record, value);
            }
        }
    }
    function dispatch(m) {
        return m === &quot;lookup&quot;
               ? lookup
               : m === &quot;insert&quot;
                 ? insert
                 : &quot;undefined operation -- table&quot;;
    }
    return dispatch;
}
const operation_table = make_table();
const get = operation_table(&quot;lookup&quot;);
const put = operation_table(&quot;insert&quot;);

// In Source, most functions have a fixed number of arguments.
// (The function list is the only exception, to this so far.)
// The function apply_in_underlying_javascript allows us to
// apply any given function fun to all elements of the argument
// list args, as if they were separate arguments
function apply(fun, args) {
    return apply_in_underlying_javascript(fun, args);
}
function add(x, y) {
    return apply_generic(&quot;add&quot;, list(x, y));
}
function sub(x, y) {
    return apply_generic(&quot;sub&quot;, list(x, y));
}
function mul(x, y) {
    return apply_generic(&quot;mul&quot;, list(x, y));
}
function div(x, y) {
    return apply_generic(&quot;div&quot;, list(x, y));
}

function attach_tag(type_tag, contents) {
    return pair(type_tag, contents);
}
function type_tag(datum) {
    return is_pair(datum)
           ? head(datum)
           : error(datum, &quot;bad tagged datum -- type_tag&quot;);
}
function contents(datum) {
    return is_pair(datum)
           ? tail(datum)
           : error(datum, &quot;bad tagged datum -- contents&quot;);
}
</JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>javascript_number_package</NAME>
      <REQUIRES>base_operation_table</REQUIRES>
      <JAVASCRIPT>
function install_javascript_number_package() {
    function tag(x) {
        return attach_tag(&quot;javascript_number&quot;, x);
    }
    put(&quot;add&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x + y));
    put(&quot;sub&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x - y));
    put(&quot;mul&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x * y));
    put(&quot;div&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(x / y));
    put(&quot;make&quot;, &quot;javascript_number&quot;,
        x =&gt; tag(x));
    return &quot;done&quot;;
}
install_javascript_number_package();

function make_javascript_number(n) {
    return get(&quot;make&quot;, &quot;javascript_number&quot;)(n);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>complex_number_package</NAME>
      <REQUIRES>base_operation_table</REQUIRES>
      <JAVASCRIPT>
// generic selector functions for complex numbers

function real_part(z) {
    return apply_generic(&quot;real_part&quot;, list(z));
}
function imag_part(z) {
    return apply_generic(&quot;imag_part&quot;, list(z));
}
function magnitude(z) {
    return apply_generic(&quot;magnitude&quot;, list(z));
}
function angle(z) {
    return apply_generic(&quot;angle&quot;, list(z));
}
function square(x) {
    return x * x;
}

function install_rectangular_package() {
    function real_part(z) { return head(z); }
    function imag_part(z) { return tail(z); }
    function make_from_real_imag(x, y) { return pair(x, y); }
    function magnitude(z) {
        return math_sqrt(square(real_part(z)) +
                   square(imag_part(z)));
    }
    function angle(z) {
        return math_atan2(imag_part(z), real_part(z));
    }
    function make_from_mag_ang(r, a) {
        return pair(r * math_cos(a), r * math_sin(a));
    }
    // interface to the rest of the system
    function tag(x) {
        return attach_tag(&quot;rectangular&quot;, x);
    }
    put(&quot;real_part&quot;, list(&quot;rectangular&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;rectangular&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;rectangular&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;rectangular&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;rectangular&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
install_rectangular_package();

function install_polar_package() {
    // internal functions
    function magnitude(z) { return head(z); }
    function angle(z) { return tail(z); }
    function make_from_mag_ang(r, a) { return pair(r, a); }
    function real_part(z) {
        return magnitude(z) * math_cos(angle(z));
    }
    function imag_part(z) {
        return magnitude(z) * math_sin(angle(z));
    }
    function make_from_real_imag(x, y) {
        return pair(math_sqrt(square(x) + square(y)),
                    math_atan2(y, x));
    }

    // interface to the rest of the system
    function tag(x) { return attach_tag(&quot;polar&quot;, x); }
    put(&quot;real_part&quot;, list(&quot;polar&quot;), real_part);
    put(&quot;imag_part&quot;, list(&quot;polar&quot;), imag_part);
    put(&quot;magnitude&quot;, list(&quot;polar&quot;), magnitude);
    put(&quot;angle&quot;, list(&quot;polar&quot;), angle);
    put(&quot;make_from_real_imag&quot;, &quot;polar&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;polar&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
install_polar_package();

function install_complex_package() {
    // imported functions from rectangular and polar packages
    function make_from_real_imag(x, y) {
        return get(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;)(x, y);
    }
    function make_from_mag_ang(r, a) {
        return get(&quot;make_from_mag_ang&quot;, &quot;polar&quot;)(r, a);
    }

    // internal functions
    function add_complex(z1, z2) {
        return make_from_real_imag(real_part(z1) +
                                   real_part(z2),
                                   imag_part(z1) +
                                   imag_part(z2));
    }
    function sub_complex(z1, z2) {
        return make_from_real_imag(real_part(z1) -
                                   real_part(z2),
                                   imag_part(z1) -
                                   imag_part(z2));
    }
    function mul_complex(z1, z2) {
        return make_from_mag_ang(magnitude(z1) *
                                 magnitude(z2),
                                 angle(z1) +
                                 angle(z2));
    }
    function div_complex(z1, z2) {
        return make_from_mag_ang(magnitude(z1) /
                                 magnitude(z2),
                                 angle(z1) -
                                 angle(z2));
    }

    // interface to rest of the system
    function tag(z) {
        return attach_tag(&quot;complex&quot;, z);
    }
    put(&quot;add&quot;, list(&quot;complex&quot;, &quot;complex&quot;),
        (z1, z2) =&gt; tag(add_complex(z1, z2)));
    put(&quot;sub&quot;, list(&quot;complex&quot;, &quot;complex&quot;),
        (z1, z2) =&gt; tag(sub_complex(z1, z2)));
    put(&quot;mul&quot;, list(&quot;complex&quot;, &quot;complex&quot;),
        (z1, z2) =&gt; tag(mul_complex(z1, z2)));
    put(&quot;div&quot;, list(&quot;complex&quot;, &quot;complex&quot;),
        (z1, z2) =&gt; tag(div_complex(z1, z2)));
    put(&quot;make_from_real_imag&quot;, &quot;complex&quot;,
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;complex&quot;,
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;
}
install_complex_package();

function make_complex_from_real_imag(x, y){
    return get(&quot;make_from_real_imag&quot;, &quot;complex&quot;)(x, y);
}
function make_complex_from_mag_ang(r, a){
    return get(&quot;make_from_mag_ang&quot;, &quot;complex&quot;)(r, a);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>coercion_support</NAME>
      <JAVASCRIPT>
// coercion support

let coercion_list = null;

function clear_coercion_list() {
    coercion_list = null;
}

function put_coercion(type1, type2, item) {
    if (is_undefined(get_coercion(type1, type2))) {
        coercion_list = pair(list(type1, type2, item),
                             coercion_list);
    } else {
        return coercion_list;
    }
}

function get_coercion(type1, type2) {
    function get_type1(list_item) {
        return head(list_item);
    }
    function get_type2(list_item) {
        return head(tail(list_item));
    }
    function get_item(list_item) {
        return head(tail(tail(list_item)));
    }
    function get_coercion_iter(items) {
        if (is_null(items)) {
            return undefined;
        } else {
            const top = head(items);
            return equal(type1, get_type1(top)) &amp;&amp;
                   equal(type2, get_type2(top))
                   ? get_item(top)
                   : get_coercion_iter(tail(items));
        }
    }
    return get_coercion_iter(coercion_list);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>apply_generic_with_coercion_example</NAME>
      <REQUIRES>base_operation_table</REQUIRES>
      <REQUIRES>javascript_number_package</REQUIRES>
      <REQUIRES>complex_number_package</REQUIRES>
      <REQUIRES>coercion_support</REQUIRES>
      <JAVASCRIPT>
function javascript_number_to_complex(n) {
    return make_complex_from_real_imag(contents(n), 0);
}

put_coercion(&quot;javascript_number&quot;, &quot;complex&quot;,
             javascript_number_to_complex);

const c = make_complex_from_real_imag(4, 3);
const n = make_javascript_number(7);

add(c, n);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4">
      <NAME>apply_generic_with_coercion</NAME>
      <EXAMPLE>apply_generic_with_coercion_example</EXAMPLE>
      <EXPECTED>[ &apos;complex&apos;, [ &apos;rectangular&apos;, [ 11, 3 ] ] ]</EXPECTED>
      <SCHEME>
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
        (apply proc (map contents args))
        (if (= (length args) 2)
          (let ((type1 (car type-tags))
                 (type2 (cadr type-tags))
                 (a1 (car args))
                 (a2 (cadr args)))
            (let ((t1-&gt;t2 (get-coercion type1 type2))
                  (t2-&gt;t1 (get-coercion type2 type1)))
              (cond (t1-&gt;t2
                      (apply-generic op (t1-&gt;t2 a1) a2))
                    (t2-&gt;t1
                      (apply-generic op a1 (t2-&gt;t1 a2)))
                    (else
                      (error &quot;No method for these types&quot;
                        (list op type-tags))))))
          (error &quot;No method for these types&quot;
            (list op type-tags)))))))
      </SCHEME>
      <JAVASCRIPT>
function apply_generic(op, args) {
    const type_tags = map(type_tag, args);
    const fun = get(op, type_tags);
    if (! is_undefined(fun)) {
        return apply(fun, map(contents, args));
    } else {
        if (length(args) === 2) {
            const type1 = head(type_tags);
            const type2 = head(tail(type_tags));
            const a1 = head(args);
            const a2 = head(tail(args));
            const t1_to_t2 = get_coercion(type1, type2);
            const t2_to_t1 = get_coercion(type2, type1);
            return ! is_undefined(t1_to_t2)
                   ? apply_generic(op, list(t1_to_t2(a1), a2))
                   : ! is_undefined(t2_to_t1)
                   ? apply_generic(op, list(a1, t2_to_t1(a2)))
                   : error(list(op, type_tags),
                           &quot;no method for these types&quot;);
        } else {
            return error(list(op, type_tags),
                         &quot;no method for these types&quot;);
        }
    }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
   
  <TEXT>
    正如上面所阐述的那样，这种强制转换方案相对于明确定义的跨类型操作方法具有许多优势。虽然我们仍然需要编写强制转换
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    来关联各类型（对于一个拥有 <LATEXINLINE>$n$</LATEXINLINE> 种类型的系统来说，可能需要编写 <LATEXINLINE>$n^2$</LATEXINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ），但我们只需为每一对类型编写一个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，而不是为每一组类型和每个通用操作编写不同的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。<FOOTNOTE>如果我们足够聪明，通常可以用少于 <LATEXINLINE>$n^2$</LATEXINLINE> 个强制转换
    <SPLITINLINE>
      <SCHEME>过程.</SCHEME>
      <JAVASCRIPT>函数.</JAVASCRIPT>
    </SPLITINLINE>
    来应付所有情况。例如，如果我们知道如何将类型 1 转换为类型 2，以及如何将类型 2 转换为类型 3，那么我们就可以利用这一知识将类型 1 转换为类型 3。这可以大大减少当我们向系统中添加新类型时需要显式提供的强制转换
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的数量。如果我们愿意在系统中构造出足够的复杂性，就可以让系统搜索各类型之间关系的<QUOTE>图</QUOTE>，并自动生成那些可以从显式给出的强制转换
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    中推导出的转换。</FOOTNOTE> 我们所依赖的事实是，不同类型之间适当的转换仅依赖于类型本身，而不依赖于所要应用的操作。
  </TEXT>

  
  
  <TEXT>
    另一方面，可能存在某些应用场景，其中我们的强制转换方案还不够通用。即使两个待合并对象都无法转换为对方的类型，通过将两个对象都转换为第三种类型仍然可能执行该操作。为了处理这种复杂性并同时保持程序的模块化，通常需要构建利用类型之间关系中更深层次结构的系统，如下文所述。
  </TEXT>


  
  <SUBHEADING>
    <NAME>类型的层次结构</NAME>
  </SUBHEADING>


  
  <INDEX>类型<SUBINDEX>层次结构</SUBINDEX><OPEN></OPEN></INDEX>

  
  <INDEX>类型<SUBINDEX>层次结构</SUBINDEX><OPEN></OPEN></INDEX>

  
  <TEXT>
    上面介绍的强制转换方案依赖于类型对之间自然关系的存在。通常，不同类型之间的关系往往具有更<QUOTE>全局</QUOTE>的结构。例如，假设我们正在构建一个通用算术系统，以处理整数、有理数、实数和复数。在这样的系统中，将整数视为特殊类型的有理数是非常自然的，而有理数又是特殊类型的实数，实数又是特殊类型的复数。实际上，我们拥有的是所谓的<EM>类型的层次结构</EM>，其中，例如，整数是有理数的<INDEX>子类型</INDEX>
    <INDEX>type(s)<SUBINDEX>子类型</SUBINDEX></INDEX>
    <EM>子类型</EM>（即任何可以应用于有理数的操作都能自动应用于整数）。反过来，我们说有理数构成了整数的<INDEX>超类型</INDEX>
    <INDEX>type(s)<SUBINDEX>超类型</SUBINDEX></INDEX>
    <EM>超类型</EM>。这里所讨论的这种层次结构非常简单，其中每种类型至多只有一个超类型，也至多只有一个子类型。这样的结构被称为<EM>塔</EM>，如图<SPACE></SPACE><REF NAME="fig:tower"></REF>所示。
    <FIGURE>
      <FIGURE SPLIT_SCALE="0.1" WEB_SCALE="0.2" SCALE="0.59" SRC="img_original/ch2-Z-G-66.svg"></FIGURE>
      <CAPTION>类型的塔。
      <INDEX>tower of types</INDEX>
      <INDEX>type(s)<SUBINDEX>tower of</SUBINDEX></INDEX>
      </CAPTION>
      <LABEL NAME="fig:tower"></LABEL>
    </FIGURE>
  </TEXT>

  
  <TEXT>
    如果我们有一个塔结构，那么我们可以极大地简化向层次结构中添加新类型的问题，因为我们只需指定新类型如何嵌入到其上一级超类型中以及它如何成为下一级类型的超类型。例如，如果我们想将一个整数添加到一个复数中，我们就不必显式定义一个特殊的强制转换
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>integer-&gt;complex</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>integer_to_complex</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    而是定义整数如何转换为有理数、有理数如何转换为实数，以及实数如何转换为复数。然后我们允许系统通过这些步骤将整数转换为复数，进而将两个复数相加。
  </TEXT>

  
  <TEXT>
    <INDEX>类型<SUBINDEX>提升</SUBINDEX></INDEX>
    <INDEX><USE>apply_generic</USE><SUBINDEX>使用类型塔</SUBINDEX></INDEX>
    我们可以以如下方式重新设计我们的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ：对于每种类型，我们需要提供一个
    <SCHEMEINLINE>raise</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    用于将该类型的对象在类型塔中“提升”一个层级。然后，当系统需要对不同类型的对象进行操作时，它可以依次将低层类型提升，直到所有对象都处于类型塔中的同一层级。（习题
    <SPACE></SPACE>
    <REF NAME="ex:raise"></REF>
    和
    <SPACE></SPACE>
    <REF NAME="ex:apply-with-raise"></REF>
    涉及实现这种策略的细节。）
  </TEXT>

  
  <TEXT>
    塔的另一个优点在于，我们可以轻松实现这样一种概念：每种类型<QUOTE>继承</QUOTE>了其超类型所定义的所有操作。例如，如果我们没有为整数提供一个专门的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    来求取其实部，我们仍然应当期望
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>real-part</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    能够根据整数是复数子类型这一事实而对整数进行定义。在一个塔结构中，我们可以通过修改
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    的方式，使这一过程统一起来。如果所需的操作没有直接在给定对象的类型中定义，我们就会将该对象提升到其超类型后再试一次。这样，我们就沿着塔向上爬行，在转换参数的过程中，直到找到一个可以执行所需操作的层级，或者到达塔顶（此时我们便放弃）。
  </TEXT>

  
  <TEXT>
    <INDEX>类型<SUBINDEX>降级</SUBINDEX></INDEX>
    与更一般的层次结构相比，塔的另一个优点在于它为我们提供了一种简单的方法，将数据对象“降级”为最简单的表示形式。例如，如果我们将 <LATEXINLINE>$2+3i$</LATEXINLINE> 与 <LATEXINLINE>$4-3i$</LATEXINLINE> 相加，我们希望得到的结果是整数 6，而不是复数 <LATEXINLINE>$6+0i$</LATEXINLINE>。
    练习<SPACE></SPACE><REF NAME="ex:simplify"></REF>讨论了一种实现这种降级操作的方法。（诀窍在于，我们需要一种通用的方法来区分那些可以降级的对象，如 <LATEXINLINE>$6+0i$</LATEXINLINE>，与那些不能降级的对象，如 <LATEXINLINE>$6+2i$</LATEXINLINE>。）
  </TEXT>


  
  <SUBHEADING>
    <NAME>层次结构的不足</NAME>
  </SUBHEADING>


  <INDEX>hierarchy of types<SUBINDEX>inadequacy of</SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  
  <TEXT>
    如果我们的系统中的数据类型能自然地排成一座塔，那么，正如我们所见，这将极大地简化对不同类型实施通用操作时遇到的问题。不幸的是，通常并非如此。 图<SPACE></SPACE><REF NAME="fig:relations-among-figures"></REF>展示了一种更为复杂的混合类型排列方式，此图显示了不同几何图形类型之间的关系。 我们看到，通常情况下，
    <INDEX>type(s)<SUBINDEX>multiple subtype and supertype</SUBINDEX></INDEX>
    <INDEX>supertype<SUBINDEX>multiple</SUBINDEX></INDEX>
    <INDEX>subtype<SUBINDEX>multiple</SUBINDEX></INDEX>
    一种类型可能拥有不止一个子类型。例如，三角形和四边形都为多边形的子类型。此外，一种类型还可能拥有多个超类型。例如，一个等腰直角三角形既可看作是等腰三角形，也可看作是直角三角形。 这种多重超类型的问题尤其棘手，因为这意味着在层次结构中没有唯一的方法将一种类型“提升”(raise)。 在一个
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    中，为对象寻找适用某操作的“正确”(correct)超类型可能需要在整个类型网络中进行大量搜索，例如
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    而由于通常存在一个类型对应多个子类型的情况，将一个值在类型层次中“降级”(down)时也会遇到类似问题。 处理大量相互关联的类型，并同时保持大型系统设计的模块化，是非常困难的，这也是当前的研究热点之一.<FOOTNOTE>这一论断在本书第一版中亦有出现，其真理性至今未变，就如我们在
    <SPLITINLINE>
      <SCHEME>twelve years ago.</SCHEME>
      <JAVASCRIPT>in 1984.</JAVASCRIPT>
    </SPLITINLINE>
    时所写的一样。</FOOTNOTE>
    实现一个有用的、通用的框架，以表达不同类型实体之间的关系（哲学家称之为“ontology”，即本体论）似乎难以攻克。 混乱的主要差别在于，十年前存在的困境
    <SPLITINLINE>
      <SCHEME>ten years ago</SCHEME>
      <JAVASCRIPT>in 1984</JAVASCRIPT>
    </SPLITINLINE>
    与现今的困境在于，如今各种不足的本体论理论已体现在大量相应不足的编程语言中。例如，正如参考文献中所示，<INDEX>object-oriented programming languages</INDEX>
    <INDEX>programming language<SUBINDEX>object-oriented</SUBINDEX></INDEX>
    面向对象编程语言citeturn0file10citeturn0file14——以及当代面向对象语言之间那些微妙而令人困惑的差异——核心问题都在于如何处理相互关联类型上的通用操作。 我们在第<SPACE></SPACE><REF NAME="chap:state"></REF>章中关于计算对象的讨论则完全规避了这些问题。 熟悉面向对象编程的读者会注意到，我们在第<SPACE></SPACE><REF NAME="chap:state"></REF>章中对局部状态有大量论述，但我们甚至没有提及“classes”或“inheritance”。 实际上，我们怀疑仅靠计算机语言设计是无法充分解决这些问题的，还必须借助于知识表示和自动推理等领域的研究。
  </TEXT>

  
  <FIGURE>
    <FIGURE SPLIT_SCALE="0.6" SCALE="0.59" SRC="img_original/ch2-Z-G-67.svg"></FIGURE>
    <CAPTION>几何图形类型之间的关系</CAPTION>
    <LABEL NAME="fig:relations-among-figures"></LABEL>
  </FIGURE>


  <EXERCISE>
     
  <INDEX>
    <USE>apply_generic</USE>
    <SUBINDEX>使用强制转换</SUBINDEX>
  </INDEX>
  Louis Reasoner已注意到，
  <SPLITINLINE>
    <SCHEME>
      <SCHEMEINLINE>apply-generic</SCHEMEINLINE>
    </SCHEME>
    <JAVASCRIPT>
      <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
    </JAVASCRIPT>
  </SPLITINLINE>
  可能会尝试将参数强制转换为对方的类型，即使它们本来就具有相同的类型<APOS></APOS>。因此，他推断，我们需要将
  <SPLITINLINE>
    <SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT>
  </SPLITINLINE>
  放入强制转换表中，以将每种类型的参数强制转换为其自身的类型。例如，除了上面显示的
  <SPLITINLINE>
    <SCHEME>
      <SCHEMEINLINE>scheme-number-&gt;complex</SCHEMEINLINE>
    </SCHEME>
    <JAVASCRIPT>
      <JAVASCRIPTINLINE>javascript_number_to_complex</JAVASCRIPTINLINE>
    </JAVASCRIPT>
  </SPLITINLINE>
  的强制转换外，他还将执行以下操作:
<SNIPPET EVAL="no">
      <INDEX><DECLARATION>javascript_number_to_javascript_</DECLARATION> <JAVASCRIPTINLINE>number</JAVASCRIPTINLINE></INDEX> 
      <INDEX><DECLARATION>complex_to_complex</DECLARATION></INDEX> 
      <SCHEME>
(define (scheme-number-&gt;scheme-number n) n)
(define (complex-&gt;complex z) z)
(put-coercion &apos;scheme-number &apos;scheme-number
  scheme-number-&gt;scheme-number)
(put-coercion &apos;complex &apos;complex complex-&gt;complex)
      </SCHEME>
      <JAVASCRIPT>
function javascript_number_to_javascript_number(n) { return n; }
<SHORT_SPACE></SHORT_SPACE>	
function complex_to_complex(n) { return n; }
<SHORT_SPACE></SHORT_SPACE>
put_coercion(&quot;javascript_number&quot;, &quot;javascript_number&quot;,
             javascript_number_to_javascript_number);
put_coercion(&quot;complex&quot;, &quot;complex&quot;, complex_to_complex);
      </JAVASCRIPT>
    </SNIPPET>

     
  <OL>
    <LI>
      在安装了Louis的强制转换 
      <SPLITINLINE>
        <SCHEME>过程</SCHEME>
        <JAVASCRIPT>函数</JAVASCRIPT>
      </SPLITINLINE>
      后，如果调用 
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      并传入两个参数，其类型为 
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>scheme-number</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>&quot;complex&quot;</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      或传入两个参数，其类型为 
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>complex</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>&quot;javascript_@number&quot;</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      用于执行一个在对应类型表中未找到的操作，会发生什么情况？例如，假设我们已经定义了一个泛用的求幂运算：
      <SNIPPET EVAL="no">
        <REQUIRES>apply_generic</REQUIRES>
        <SCHEME>
(define (exp x y) (apply-generic &apos;exp x y))
        </SCHEME>
        <JAVASCRIPT>
function exp(x, y) {
    return apply_generic(&quot;exp&quot;, list(x, y));
}
        </JAVASCRIPT>
      </SNIPPET>
      并且在 
      <SPLITINLINE>
        <SCHEME>Scheme-number</SCHEME>
        <JAVASCRIPT>JavaScript-number</JAVASCRIPT>
      </SPLITINLINE>
      包中放置了一个用于求幂的 
      <SPLITINLINE>
        <SCHEME>过程</SCHEME>
        <JAVASCRIPT>函数</JAVASCRIPT>
      </SPLITINLINE>
      ，而在其它包中则没有放置：
      <SNIPPET EVAL="no" LATEX="yes">
        <SCHEME>
;; following added to Scheme-number package
(put &apos;exp &apos;(scheme-number scheme-number)
  (lambda (x y) (tag (expt x y)))) ; using primitive expt
        </SCHEME>
        <JAVASCRIPT>
 // following added to JavaScript-number package
put(&quot;exp&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
    (x, y) =&gt; tag(math_exp(x, y))); // using primitive $\texttt{math\char`_exp}$
        </JAVASCRIPT>
      </SNIPPET>
      那么，如果我们使用两个复数作为参数来调用 <SCHEMEINLINE>exp</SCHEMEINLINE> 会怎样？
    </LI>
    <LI>
      Louis是否正确，即必须对相同类型的参数进行强制转换的处理？或者说，
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      本来就该能够正确运行？
    </LI>
    <LI>
      修改 
      <SPLITINLINE>
        <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      ，使得当两个参数具有相同类型时，不再尝试进行强制转换。
    </LI>
  </OL>

  <SOLUTION>
    <OL>
      <LI>如果Louis将强制转换函数放入操作表中，<JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>将进入无限循环</LI>
      <LI>Louis的代码不起作用。<JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>照现有方式运行是正确的，但我们可以修改它，使其在尝试任何相同类型的强制转换之前便以错误退出。</LI>
      <LI>
        <SNIPPET HIDE="yes">
          <NAME>apply_generic_with_unavailable_type_example</NAME>
          <REQUIRES>base_operation_table</REQUIRES>
          <REQUIRES>complex_number_package</REQUIRES>
          <REQUIRES>coercion_support</REQUIRES>
          <JAVASCRIPT>
    
    function install_javascript_number_package() {
        function tag(x) {
            return attach_tag(&quot;javascript_number&quot;, x);
        }
        put(&quot;add&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
            (x, y) =&gt; tag(x + y));
        put(&quot;sub&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
            (x, y) =&gt; tag(x - y));
        put(&quot;mul&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
            (x, y) =&gt; tag(x * y));
        put(&quot;div&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
            (x, y) =&gt; tag(x / y));
        put(&quot;exp&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
        (x, y) =&gt; tag(math_exp(x, y)));
        put(&quot;make&quot;, &quot;javascript_number&quot;,
            x =&gt; tag(x));
        return &quot;done&quot;;
    }
    install_javascript_number_package();
    
    function make_javascript_number(n) {
        return get(&quot;make&quot;, &quot;javascript_number&quot;)(n);
    }
    
    function javascript_number_to_javascript_number(n) {
        return n;
    }
    function complex_to_complex(n) {
        return n;
    }
    put_coercion(&quot;javascript_number&quot;, &quot;javascript_number&quot;,
                 javascript_number_to_javascript_number);
    put_coercion(&quot;complex&quot;, &quot;complex&quot;,
                 complex_to_complex);
    function exp(x, y) {
        return apply_generic(&quot;exp&quot;, list(x, y));
    }
    
    const c = make_javascript_number(4);
    const d = make_javascript_number(2);
    exp(c, d);
    
          </JAVASCRIPT>
          <SCHEME></SCHEME>
        </SNIPPET>
        <SNIPPET CHAP="4">
          <NAME>apply_generic_with_unavailable_type</NAME>
          <EXAMPLE>apply_generic_with_unavailable_type_example</EXAMPLE>
          <SCHEME>
          </SCHEME>
          <JAVASCRIPT>
    function apply_generic(op, args) {
        const type_tags = map(type_tag, args);
        const fun = get(op, type_tags);
        if (! is_undefined(fun)) {
            return apply(fun, map(contents, args));
        } else {
            if (length(args) === 2) {
                const type1 = head(type_tags);
                const type2 = head(tail(type_tags));
                const a1 = head(args);
                const a2 = head(tail(args));
                const t1_to_t2 = get_coercion(type1, type2);
                const t2_to_t1 = get_coercion(type2, type1);
                return type1 === type2
                       ? error(list(op, type_tags),
                                    &quot;no method for these types&quot;)
                       : ! is_undefined(t1_to_t2)
                       ? apply_generic(op, list(t1_to_t2(a1), a2))
                       : ! is_undefined(t2_to_t1)
                       ? apply_generic(op, list(a1, t2_to_t1(a2)))
                       : error(list(op, type_tags),
                               &quot;no method for these types&quot;);
            } else {
                return error(list(op, type_tags),
                             &quot;no method for these types&quot;);
            }
        }
    }
          </JAVASCRIPT>
        </SNIPPET>
      </LI>
    </OL>
  </SOLUTION>
<LABEL NAME="ex:2_81"></LABEL>
  </EXERCISE>

  
  <EXERCISE>
     <INDEX><USE>apply_generic</USE><SUBINDEX>多参数强制转换</SUBINDEX></INDEX>
    展示如何将
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    推广为处理多个参数的一般情况中的强制转换。一种策略是尝试将所有参数首先强制转换为第一个参数的类型，然后转换为第二个参数的类型，以此类推。请给出一个示例，说明这种策略（以及上面给出的针对两个参数版本的策略）在某些情况下不够通用。
    （提示：考虑存在一些合适的混合类型操作，但这些操作不会被尝试的情况。）
    <LABEL NAME="ex:multi-coercion"></LABEL>
    <SOLUTION>
      <SNIPPET HIDE="yes">
      <NAME>multi_coercion_example</NAME>
      <REQUIRES>base_operation_table</REQUIRES>
      <REQUIRES>javascript_number_package</REQUIRES>
      <REQUIRES>complex_number_package</REQUIRES>
      <REQUIRES>coercion_support</REQUIRES>
      <JAVASCRIPT>
function javascript_number_to_complex(n) {
    return make_complex_from_real_imag(contents(n), 0);
}

put_coercion(&quot;javascript_number&quot;, &quot;complex&quot;,
             javascript_number_to_complex);

put(&quot;add&quot;, list(&quot;complex&quot;, &quot;complex&quot;, &quot;complex&quot;),
  (x, y, z) =&gt; attach_tag(&quot;complex&quot;, make_complex_from_real_imag(
    real_part(x) + real_part(y) + real_part(z),
    imag_part(x) + imag_part(y) + imag_part(z))));

function add_three(x, y, z) {
    return apply_generic(&quot;add&quot;, list(x, y, z));
}

const c = make_complex_from_real_imag(4, 3);
const n = make_javascript_number(7);
add_three(c, c, n);
// add_three(c, n, n);

      </JAVASCRIPT>
      <SCHEME></SCHEME>
      </SNIPPET>
      <SNIPPET CHAP="4">
        <NAME>multi_coercion</NAME>
        <EXAMPLE>multi_coercion_example</EXAMPLE>
        <JAVASCRIPT>
function can_coerce_to(type_tags, target_type) {
    return accumulate((type_tag, result) =&gt;
                        result &amp;&amp;
                        (type_tag === target_type ||
                         ! is_undefined(get_coercion(type_tag, target_type))),
                      true,
                      type_tags);
}

function find_coerced_type(type_tags) {
    return is_null(type_tags)
           ? undefined
           : can_coerce_to(type_tags, head(type_tags))
           ? head(type_tags)
           : find_coerced_type(tail(type_tags));
}

function coerce_all(args, target_type) {
    return map(arg =&gt; type_tag(arg) === target_type
                      ? arg
                      : get_coercion(type_tag(arg), target_type)(arg),
               args);
}

function apply_generic(op, args) {
    const type_tags = map(type_tag, args);
    const fun = get(op, type_tags);
    if (! is_undefined(fun)) {
        return apply(fun, map(contents, args));
    } else {
        const target_type = find_coerced_type(type_tags);
        if (! is_undefined(target_type)) {
          return apply_generic(op, coerce_all(args, target_type));
        } else {
            return error(list(op, type_tags),
                         &quot;no method for these types&quot;);
        }
    }
}
        </JAVASCRIPT>
      </SNIPPET>
    一种这种方法不充分的情况是：若存在三种类型，A、B、C，其中A可以强制转换为B且C可以强制转换为B，并且存在针对(A, B, B)注册的操作。对(A, B, C)求值时，只会尝试(A, B, C)和(B, B, B)这两种情况，而实际上你可以将C强制转换为B，从而使用(A, B, B)的注册操作。
    </SOLUTION>
  </EXERCISE>


  
  <EXERCISE>
    <INDEX>type(s)<SUBINDEX>raising</SUBINDEX></INDEX>
    假设你正在设计一个用于处理图<SPACE></SPACE><REF NAME="fig:tower"></REF>所示的类型塔（整数、分式、实数、复数）的通用运算系统。对于每种类型（除复数外），设计一个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，使其能将该类型对象在类型塔中提升一级。请展示如何安装一个通用的<SCHEMEINLINE>raise</SCHEMEINLINE>操作，使其对于每种类型（除复数外）均能正常工作。
    <LABEL NAME="ex:raise"></LABEL>
    <SOLUTION>
      <SNIPPET HIDE="yes">
      <NAME>rational_number_package</NAME>
      <JAVASCRIPT>
function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

function install_rational_package() {
    // internal functions
    function numer(x) {
        return head(x);
    }
    function denom(x) {
        return tail(x);
    }
    function make_rat(n, d) {
        let g = gcd(n, d);
        return pair(n / g, d / g);
    }
    function add_rat(x, y) {
        return make_rat(numer(x) * denom(y) +
                        numer(y) * denom(x),
                        denom(x) * denom(y));
    }
    function sub_rat(x, y) {
        return make_rat(numer(x) * denom(y) -
                        numer(y) * denom(x),
                        denom(x) * denom(y));
    }
    function mul_rat(x, y) {
        return make_rat(numer(x) * numer(y),
                        denom(x) * denom(y));
    }
    function div_rat(x, y) {
        return make_rat(numer(x) * denom(y),
                        denom(x) * numer(y));
    }
    // interface to rest of the system
    function tag(x) {
        return attach_tag(&quot;rational&quot;, x);
    }
    put(&quot;add&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(add_rat(x, y)));
    put(&quot;sub&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(sub_rat(x, y)));
    put(&quot;mul&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(mul_rat(x, y)));
    put(&quot;div&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(div_rat(x, y)));
    put(&quot;make&quot;, &quot;rational&quot;,
        (n, d) =&gt; tag(make_rat(n, d)));
}
install_rational_package();

function make_rational(n, d) {
    return get(&quot;make&quot;, &quot;rational&quot;)(n, d);
}
</JAVASCRIPT>
      <SCHEME></SCHEME>
      </SNIPPET>
      <SNIPPET HIDE="yes">
        <REQUIRES>javascript_number_package</REQUIRES>
        <REQUIRES>rational_number_package</REQUIRES>
        <REQUIRES>complex_number_package</REQUIRES>
        <REQUIRES>coercion_support</REQUIRES>
        <REQUIRES>apply_generic_with_coercion</REQUIRES>
        <NAME>raise_example</NAME>
        <JAVASCRIPT>
const a = make_javascript_number(2);
const b = make_rational(2, 3);
raise(a);
// raise(b);
        </JAVASCRIPT>
        <SCHEME></SCHEME>
      </SNIPPET>
      <SNIPPET CHAP="4">
        <NAME>raise</NAME>
        <EXAMPLE>raise_example</EXAMPLE>
        <JAVASCRIPT>
function raise(x) {
    return apply_generic(&quot;raise&quot;, list(x));
}

// 添加到 Javascript-number 包
put(&quot;raise&quot;, list(&quot;javascript_number&quot;),
    x =&gt; make_rational(x, 1));
//// 添加到 rational 包
// put(&quot;raise&quot;, list(&quot;rational&quot;),
//     x =&gt; make_real(div, numer(x), denom(x)));
// put(&quot;raise&quot;, list(&quot;rational&quot;),
//     x =&gt; make_complex_from_real_imag(x, 0));
//// 添加到 real 包
// put(&quot;raise&quot;, list(&quot;real&quot;),
//     x =&gt; make_complex_from_real_imag(x, 0));
        </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>


  
  <EXERCISE>
    <INDEX><USE>apply_generic</USE><SUBINDEX>通过提升进行强制转换</SUBINDEX></INDEX>
    使用练习<REF NAME="ex:raise"></REF>中的<SCHEMEINLINE>raise</SCHEMEINLINE>运算，修改
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，使其通过连续提升的方法将参数强制转换为相同的类型，如本节所讨论的。你需要设计一种方法来测试两个类型中哪一个在类型塔中更高。请以与系统其他部分<QUOTE>兼容</QUOTE>的方式实现这一点，并且不会在向塔中添加新级别时引发问题。
    <LABEL NAME="ex:apply-with-raise"></LABEL>
  </EXERCISE>


  
  <EXERCISE>
    <INDEX><USE>apply_generic</USE><SUBINDEX>通过强制转换来简化</SUBINDEX></INDEX>
    <INDEX>类型<SUBINDEX>降低</SUBINDEX></INDEX>
    本节提到了一种通过在类型塔中尽可能降低数据对象来<QUOTE>简化</QUOTE>其的方法。设计一个<SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>drop</SCHEMEINLINE>，用于实现exercise<SPACE></SPACE><REF NAME="ex:raise"></REF>中所描述的类型塔的这一目标。关键在于以某种通用的方式判断一个对象是否可以降低。例如，复数&lt; латексINLINE&gt;$1.5+0i$&lt;/LATEXINLINE&gt;可以降低到<SPLITINLINE>
      <SCHEME><SCHEMEINLINE>real</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>&quot;real&quot;</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    的层次，复数&lt; LATEXINLINE&gt;$1+0i$&lt;/LATEXINLINE&gt;可以降低到<SPLITINLINE>
      <SCHEME><SCHEMEINLINE>integer</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>&quot;integer&quot;</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    的层次，而复数&lt; LATEXINLINE&gt;$2+3i$&lt;/LATEXINLINE&gt;则完全无法降低。以下是判断一个对象是否能够降低的方案：首先定义一个通用操作<SCHEMEINLINE>project</SCHEMEINLINE>，该操作将对象在类型塔中<QUOTE>下推</QUOTE>。例如，对复数进行投影将涉及丢弃其虚部。接着，当我们对一个数进行<SCHEMEINLINE>project</SCHEMEINLINE>操作，并用<SCHEMEINLINE>raise</SCHEMEINLINE>将结果提升回原来的类型后，如果最终得到的值与初始值相等，则该数可以被降低。请详细说明如何实现这一思想，方法是编写一个<SCHԊEINLINE>drop&lt;/SCHEMEINLINE&gt;<SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    来使对象尽可能降低。你需要设计各种投影操作<FOOTNOTE>一个实数可以通过使用<INDEX><USE>math_round</USE>（原始函数）</INDEX>
    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>math_round</USE><ECMA>Math.round</ECMA></SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>round</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>math_round</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    原语将其投影到整数，该原语返回最接近其参数的整数。</FOOTNOTE>
    并将<SCHEMEINLINE>project</SCHEMEINLINE>安装为系统中的通用操作。你还需要使用一个通用的相等谓词，如exercise<SPACE></SPACE><REF NAME="ex:equ?"></REF>中所描述的那样。最后，利用<SCHEMEINLINE>drop</SCHEMEINLINE>重写来自exercise<SPACE></SPACE><REF NAME="ex:apply-with-raise"></REF>的<SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>，使其在给出答案时能够<QUOTE>简化</QUOTE>结果。
    <LABEL NAME="ex:simplify"></LABEL>
  </SCHԊEINLINE></EXERCISE>


   <EXERCISE>
    假设我们希望处理复数，其实部、虚部、模和角度可以是普通数字、有理数，或其他我们可能希望加入系统中的数字。描述并实现为适应这一需求所需对系统进行的更改。你将需要定义诸如 <SCHEMEINLINE>sine</SCHEMEINLINE> 和 <SCHEMEINLINE>cosine</SCHEMEINLINE> 这样的操作，这些操作对于普通数字和有理数是通用的。
    <LABEL NAME="ex:2_86"></LABEL>
  </EXERCISE> 

   <INDEX>强制类型转换<CLOSE></CLOSE></INDEX> 
   <INDEX>类型<SUBINDEX>层次结构</SUBINDEX><CLOSE></CLOSE></INDEX> 
   <INDEX>类型的层次结构<CLOSE></CLOSE></INDEX> 

</SUBSECTION>
