
<REFERENCES>
  <!--  taken from http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-36.html#%_chap_Temp_849 -->
  <NAME>References</NAME>

  <REFERENCE>
    Abelson, Harold, Andrew Berlin, Jacob Katzenelson,
    William McAllister,
    Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992.  The
    Supercomputer Toolkit: A general framework for special-purpose
    computing.  <em>International Journal of High-Speed Electronics</em>
    3(3):337-361.</REFERENCE>

  <REFERENCE>
    Allen, John.  1978.  <em>Anatomy of Lisp.</em> New York: McGraw-Hill.
  </REFERENCE>

  <REFERENCE>ANSI X3.226-1994. <em>American National Standard for Information
      Systems<EMDASH/>Programming Language<EMDASH/>Common Lisp.</em></REFERENCE>

  <REFERENCE>Appel, Andrew W.  1987.  Garbage collection can be faster than stack
    allocation.  <em>Information Processing Letters</em> 25(4):275-279.</REFERENCE>

  <REFERENCE>Backus, John.  1978.  Can programming be liberated from the von
    Neumann style?  <em>Communications of the ACM</em> 21(8):613-641.</REFERENCE>

  <REFERENCE>Baker, Henry G., Jr.  1978.  List processing in real time on a serial
    computer.  <em>Communications of the ACM</em> 21(4):280-293.</REFERENCE>

  <REFERENCE>Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and
    Daniel Weise.  1982.  The Scheme-81 architecture<EMDASH/>System and chip.
    In <em>Proceedings of the MIT Conference on Advanced Research in
      VLSI,</em> edited by Paul Penfield, Jr. Dedham, MA: Artech House.</REFERENCE>

  <REFERENCE>Borning, Alan.  1977.  ThingLab<EMDASH/>An object-oriented system for
    building simulations using constraints. In <em>Proceedings of the 5th
      International Joint Conference on Artificial Intelligence.</em></REFERENCE>

  <REFERENCE>Borodin, Alan, and Ian Munro.  1975.  <em>The Computational
      Complexity of Algebraic and Numeric Problems.</em> New York: American
    Elsevier.</REFERENCE>

  <REFERENCE>Chaitin, Gregory J.  1975.  Randomness and mathematical proof.  <em>Scientific American</em> 232(5):47-52.</REFERENCE>

  <REFERENCE>Church, Alonzo.  1941.  <em>The Calculi of Lambda-Conversion.</em>
    Princeton, N.J.: Princeton University Press.</REFERENCE>

  <REFERENCE>Clark, Keith L.  1978.  Negation as failure.  In <em>Logic and Data
      Bases.</em> New York: Plenum Press, pp. 293-322.</REFERENCE>

  <REFERENCE>Clinger, William.  1982.  Nondeterministic call by need is neither
    lazy nor by name. In <em>Proceedings of the ACM Symposium on Lisp and
      Functional Programming,</em> pp. 226-234.</REFERENCE>

  <REFERENCE>Clinger, William, and Jonathan Rees.  1991.  Macros that work.  In
    <em>Proceedings of the 1991 ACM Conference on Principles of
      Programming Languages,</em> pp. 155-162.</REFERENCE>

  <REFERENCE>Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un syst<EGRAVE_LOWER/>me
    de communication homme-machine en fran<CCEDIL_LOWER/>ais.  Technical report,
    Groupe Intelligence Artificielle, Universit<EACUTE_LOWER/> d'Aix Marseille,
    Luminy.</REFERENCE>

  <REFERENCE>Cormen, Thomas, Charles Leiserson, and Ronald Rivest.  1990. <em>Introduction to Algorithms.</em> Cambridge, MA: MIT Press.</REFERENCE>

  <REFERENCE>Darlington, John, Peter Henderson, and David Turner.  1982.  <em>Functional Programming and Its Applications.</em> New York: Cambridge
    University Press.</REFERENCE>

  <REFERENCE>Dijkstra, Edsger W. 1968a.  The structure of the <QUOTE>THE</QUOTE>
    multiprogramming system.  <em>Communications of the ACM</em>
    11(5):341-346.</REFERENCE>

  <REFERENCE>Dijkstra, Edsger W. 1968b.  Cooperating sequential processes.  In <em>Programming Languages</em>, edited by F. Genuys. New York: Academic Press, pp.
    43-112.</REFERENCE>

  <REFERENCE>Dinesman, Howard P.  1968.  <em>Superior Mathematical Puzzles</em>.  New
    York: Simon and Schuster.</REFERENCE>

  <REFERENCE>deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.
    AMORD: Explicit control of reasoning.  In <em>Proceedings of the ACM
      Symposium on Artificial Intelligence and Programming Languages,</em> pp.
    116-125.</REFERENCE>

  <REFERENCE>Doyle, Jon. 1979. A truth maintenance system. <em>Artificial
      Intelligence</em> 12:231-272.</REFERENCE>

  <REFERENCE>Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National
    Fifth Generation Project: Introduction, survey, and evaluation.  In <em>Future Generation Computer Systems,</em> vol. 9, pp. 105-117.</REFERENCE>
  
  <REFERENCE>Feeley, Marc.  1986.  Deux approches <AGRAVE_LOWER/> l'implantation du
    language Scheme.  Masters thesis, Universit<EACUTE_LOWER/> de Montr<EACUTE_LOWER/>al.</REFERENCE>

  <REFERENCE>Feeley, Marc and Guy Lapalme.  1987.  Using closures for code
    generation.  <em>Journal of Computer Languages</em> 12(1):47-66.</REFERENCE>

  <REFERENCE>Feller, William.  1957.  <em>An Introduction to Probability Theory
      and Its Applications,</em> volume 1. New York: John Wiley <AMP/> Sons.</REFERENCE>

  <REFERENCE>Fenichel, R., and J. Yochelson.  1969.  A Lisp garbage collector for
    virtual memory computer systems.  <em>Communications of the ACM</em>

    12(11):611-612.</REFERENCE>

  <REFERENCE>Floyd, Robert. 1967. Nondeterministic algorithms. <em>JACM,</em> 14(4):636-644.</REFERENCE>

  <REFERENCE>Forbus, Kenneth D., and Johan deKleer.  1993. <em>Building Problem
      Solvers.</em> Cambridge, MA: MIT Press.</REFERENCE>

  <REFERENCE>Friedman, Daniel P., and David S. Wise.  1976.  CONS should not
    evaluate its arguments. In <em>Automata, Languages, and Programming:
      Third International Colloquium,</em> edited by S. Michaelson and R.
    Milner, pp. 257-284.</REFERENCE>

  <REFERENCE>Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.
    <em>Essentials of Programming Languages.</em>  Cambridge, MA: MIT
    Press/McGraw-Hill.</REFERENCE>

  <REFERENCE>Gabriel, Richard P. 1988.  The Why of <em>Y</em>.  <em>Lisp Pointers</em>
    2(2):15-25.</REFERENCE>

  <REFERENCE>Goldberg, Adele, and David Robson.  1983.  <em>Smalltalk-80: The
      Language and Its Implementation.</em> Reading, MA: Addison-Wesley.</REFERENCE>

  <REFERENCE>Gordon, Michael, Robin Milner, and Christopher Wadsworth.  1979.  <em>Edinburgh LCF.</em> Lecture Notes in Computer Science, volume 78. New
    York: Springer-Verlag.</REFERENCE>

  <REFERENCE>Gray, Jim, and Andreas Reuter. 1993. <em>Transaction Processing:
      Concepts and Models.</em> San Mateo, CA: Morgan-Kaufman.</REFERENCE>

  <REFERENCE>Green, Cordell.  1969.  Application of theorem proving to problem
    solving.  In <em>Proceedings of the International Joint Conference on
      Artificial Intelligence,</em> pp. 219-240.</REFERENCE>

  <REFERENCE>Green, Cordell, and Bertram Raphael.  1968.  The use of
    theorem-proving techniques in question-answering systems.  In <em>Proceedings of the ACM National Conference,</em> pp. 169-181.</REFERENCE>

  <REFERENCE>Griss, Martin L.  1981.  Portable Standard Lisp, a brief overview.
    Utah Symbolic Computation Group Operating Note 58, University of Utah.</REFERENCE>

  <REFERENCE>Guttag, John V.  1977.  Abstract data types and the development of
    data structures.  <em>Communications of the ACM</em> 20(6):397-404.</REFERENCE>

  <REFERENCE>Hamming, Richard W.  1980.  <em>Coding and Information Theory.</em>

    Englewood Cliffs, N.J.: Prentice-Hall.</REFERENCE>

  <REFERENCE>Hanson, Christopher P.  1990.  Efficient stack allocation for
    tail-recursive languages.  In <em>Proceedings of ACM Conference on
      Lisp and Functional Programming,</em> pp. 106-118.</REFERENCE>

  <REFERENCE>Hanson, Christopher P.  1991.  A syntactic closures macro facility.
    <em>Lisp Pointers,</em> 4(3).</REFERENCE>

  <REFERENCE>Hardy, Godfrey H.  1921.  Srinivasa Ramanujan.  <em>Proceedings of
      the London Mathematical Society</em> XIX(2).</REFERENCE>

  <REFERENCE>Hardy, Godfrey H., and E. M. Wright.  1960.  <em>An Introduction to
      the Theory of Numbers.</em>  4th edition.  New York: Oxford University
    Press.</REFERENCE>

  <REFERENCE>Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. <em>IBM Systems Journal</em> 7(2):74-84.</REFERENCE>

  <REFERENCE>Hearn, Anthony C.  1969.  Standard Lisp.  Technical report AIM-90,
    Artificial Intelligence Project, Stanford University.</REFERENCE>

  <REFERENCE>Henderson, Peter. 1980.  <em>Functional Programming: Application and
      Implementation.</em> Englewood Cliffs, N.J.: Prentice-Hall.</REFERENCE>

  <REFERENCE>Henderson. Peter. 1982. Functional Geometry. In <em>Conference Record
      of the 1982 ACM Symposium on Lisp and Functional Programming,</em>
    pp. 179-187.</REFERENCE>

  <REFERENCE>Hewitt, Carl E.  1969.  PLANNER: A language for proving theorems in
    robots.  In <em>Proceedings of the International Joint Conference on
      Artificial Intelligence,</em> pp. 295-301.</REFERENCE>

  <REFERENCE>Hewitt, Carl E.  1977.  Viewing control structures as patterns of
    passing messages.  <em>Journal of Artificial Intelligence</em>
    8(3):323-364.</REFERENCE>

  <REFERENCE>Hoare, C. A. R. 1972.  Proof of correctness of data representations.
    <em>Acta Informatica</em> 1(1).</REFERENCE>

  <REFERENCE>Hodges, Andrew. 1983.  <em>Alan Turing: The Enigma.</em> New York: Simon
    and Schuster.</REFERENCE>

  <REFERENCE>Hofstadter, Douglas R.  1979.  <em>G<OUML_LOWER/>del, Escher, Bach: An Eternal
      Golden Braid.</em> New York: Basic Books.</REFERENCE>

  <REFERENCE>Hughes, R. J. M.  1990.  Why functional programming matters.  In <em>Research Topics in Functional Programming</em>, edited by David Turner.
    Reading, MA: Addison-Wesley, pp. 17-42.</REFERENCE>

  <REFERENCE>IEEE Std 1178-1990.  1990.  <em>IEEE Standard for the Scheme
      Programming Language.</em></REFERENCE>

  <REFERENCE>Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig;
    assisted by M. Lind, Herbert Kanner, and Robert Floyd.  1960.  THUNKS:
    A way of compiling procedure statements, with some comments on
    procedure declarations.  Unpublished manuscript.  (Also, private
    communication from Wallace Feurzeig.)</REFERENCE>

  <REFERENCE>Kaldewaij, Anne. 1990.  <em>Programming: The Derivation of
      Algorithms.</em> New York: Prentice-Hall.</REFERENCE>

  <REFERENCE>Kohlbecker, Eugene Edmund, Jr. 1986.  Syntactic extensions in the
    programming language Lisp.  Ph.D. thesis, Indiana University.</REFERENCE>

  <REFERENCE>Konopasek, Milos, and Sundaresan Jayaraman.  1984.  <em>The TK!Solver
      Book: A Guide to Problem-Solving in Science, Engineering, Business,
      and Education.</em> Berkeley, CA: Osborne/McGraw-Hill.</REFERENCE>

  <REFERENCE>Knuth, Donald E.  1973.  <em>Fundamental Algorithms.</em> Volume 1 of
    <em>The Art of Computer Programming.</em>  2nd edition. Reading, MA:
    Addison-Wesley.</REFERENCE>

  <REFERENCE>Knuth, Donald E.  1981.  <em>Seminumerical Algorithms.</em> Volume 2 of
    <em>The Art of Computer Programming.</em>  2nd edition. Reading, MA:
    Addison-Wesley.</REFERENCE>

  <REFERENCE>Kowalski, Robert.  1973.  Predicate logic as a programming language.
    Technical report 70, Department of Computational Logic, School of
    Artificial Intelligence, University of Edinburgh.</REFERENCE>

  <REFERENCE>Kowalski, Robert.  1979.  <em>Logic for Problem Solving.</em> New York:
    North-Holland.</REFERENCE>

  <REFERENCE>Lamport, Leslie. 1978.  Time, clocks, and the ordering of events in a
    distributed system.  <em>Communications of the ACM</em> 21(7):558-565.</REFERENCE>

  <REFERENCE>Lampson, Butler, J. J. Horning, R.  London, J. G. Mitchell, and G. K.
    Popek.  1981.  Report on the programming language Euclid.  Technical
    report, Computer Systems Research Group, University of Toronto.</REFERENCE>

  <REFERENCE>Landin, Peter.  1965.  A correspondence between Algol 60 and Church's
    lambda notation: Part I.  <em>Communications of the ACM</em>
    8(2):89-101.</REFERENCE>

  <REFERENCE>Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage
    collector based on the lifetimes of objects. <em>Communications of
      the ACM</em> 26(6):419-429.</REFERENCE>

  <REFERENCE>Liskov, Barbara H., and Stephen N. Zilles.  1975.  Specification
    techniques for data abstractions.  <em>IEEE Transactions on Software
      Engineering</em> 1(1):7-19.</REFERENCE>

  <REFERENCE>McAllester, David Allen.  1978.  A three-valued truth-maintenance
    system.  Memo 473, MIT Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>McAllester, David Allen.  1980.  An outlook on truth maintenance.
    Memo 551, MIT Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>McCarthy, John.  1960.  Recursive functions of symbolic expressions
    and their computation by machine.  <em>Communications of the ACM</em>
    3(4):184-195.</REFERENCE>

  <REFERENCE>McCarthy, John.  1967.  A basis for a mathematical theory of
    computation.  In <em>Computer Programing and Formal Systems</em>, edited
    by P. Braffort and D. Hirschberg.  North-Holland.</REFERENCE>

  <REFERENCE>McCarthy, John.  1978.  The history of Lisp.  In <em>Proceedings of
      the ACM SIGPLAN Conference on the History of Programming Languages.</em></REFERENCE>

  <REFERENCE>McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I.
    Levin.  1965.  <em>Lisp 1.5 Programmer's Manual.</em>  2nd edition.
    Cambridge, MA: MIT Press.</REFERENCE>

  <REFERENCE>McDermott, Drew, and Gerald Jay Sussman.  1972. Conniver reference
    manual.  Memo 259, MIT Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>Miller, Gary L.  1976.  Riemann's Hypothesis and tests for primality.
    <em>Journal of Computer and System Sciences</em> 13(3):300-317.</REFERENCE>

  <REFERENCE>Miller, James S., and Guillermo J. Rozas. 1994.  Garbage collection is
    fast, but a stack is faster.  Memo 1462, MIT Artificial Intelligence
    Laboratory.</REFERENCE>

  <REFERENCE>Moon, David.  1978.  MacLisp reference manual, Version 0.  Technical
    report, MIT Laboratory for Computer Science.</REFERENCE>

  <REFERENCE>Moon, David, and Daniel Weinreb.  1981.  Lisp machine manual.
    Technical report, MIT Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>Morris, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience
    with an applicative string processing language.  In <em>Proceedings
      of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of
      Programming Languages.</em></REFERENCE>

  <REFERENCE>Phillips, Hubert.  1934. <em>The Sphinx Problem Book</em>.  London: Faber
    and Faber.</REFERENCE>

  <REFERENCE>Pitman, Kent.  1983.  The revised MacLisp Manual (Saturday evening
    edition).  Technical report 295, MIT Laboratory for Computer Science.</REFERENCE>

  <REFERENCE>Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.
    <em>Journal of Number Theory</em> 12:128-138.</REFERENCE>

  <REFERENCE>Raymond, Eric.  1993. <em>The New Hacker's Dictionary.</em> 2nd edition.
    Cambridge, MA: MIT Press.</REFERENCE>

  <REFERENCE>Raynal, Michel. 1986. <em>Algorithms for Mutual Exclusion.</em>
    Cambridge, MA: MIT Press.</REFERENCE>

  <REFERENCE>Rees, Jonathan A., and Norman I. Adams IV. 1982.  T: A dialect of Lisp
    or, lambda: The ultimate software tool.  In <em>Conference Record of
      the 1982 ACM Symposium on Lisp and Functional Programming,</em> pp.
    114-122.</REFERENCE>

  <REFERENCE>Rees, Jonathan, and William Clinger (eds). 1991.  The revised<LATEXINLINE>$^4$</LATEXINLINE>
    report on the algorithmic language Scheme.  <em>Lisp Pointers,</em> 4(3).</REFERENCE>

  <REFERENCE>Rivest, Ronald, Adi Shamir, and Leonard Adleman.  1977.  A method for
    obtaining digital signatures and public-key cryptosystems. Technical
    memo LCS/TM82, MIT Laboratory for Computer Science.</REFERENCE>

  <REFERENCE>Robinson, J. A. 1965.  A machine-oriented logic based on the
    resolution principle.  <em>Journal of the ACM</em> 12(1):23.</REFERENCE>

  <REFERENCE>Robinson, J. A. 1983.  Logic programming<EMDASH/>Past, present, and future.
    <em>New Generation Computing</em> 1:107-124.</REFERENCE>

  <REFERENCE>Sagade, Y. 2015. <LINK address="http://www.ysagade.nl/2015/04/12/sicp-change-growth/">SICP exercise 1.14</LINK>
    </REFERENCE>
    
  <REFERENCE>Spafford, Eugene H.  1989.  The Internet Worm: Crisis and aftermath.
    <em>Communications of the ACM</em> 32(6):678-688.</REFERENCE>

  <REFERENCE>Steele, Guy Lewis, Jr.  1977.  Debunking the <QUOTE>expensive procedure
      call</QUOTE> myth.  In <em>Proceedings of the National Conference of the
      ACM,</em> pp. 153-62.</REFERENCE>

  <REFERENCE>Steele, Guy Lewis, Jr.  1982.  An overview of Common Lisp.  In <em>Proceedings of the ACM Symposium on Lisp and Functional Programming,</em>
    pp. 98-107.</REFERENCE>

  <REFERENCE>Steele, Guy Lewis, Jr.  1990.  <em>Common Lisp: The Language.</em> 2nd
    edition.  Digital Press.</REFERENCE>

  <REFERENCE>Steele, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An
    interpreter for the extended lambda calculus.  Memo 349, MIT
    Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.
    Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  <em>The Hacker's Dictionary.</em> New York: Harper 
<AMP/> Row.</REFERENCE>

  <REFERENCE>Stoy, Joseph E.  1977.  <em>Denotational Semantics.</em> Cambridge, MA:
    MIT Press.</REFERENCE>

  <REFERENCE>Sussman, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic
    techniques in computer-aided circuit analysis.  <em>IEEE Transactions
      on Circuits and Systems</em> CAS-22(11):857-865.</REFERENCE>

  <REFERENCE>Sussman, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints<EMDASH/>A
    language for expressing almost-hierarchical descriptions.  <em>AI
      Journal</em> 14:1-39.</REFERENCE>

  <REFERENCE>Sussman, Gerald Jay, and Jack Wisdom.  1992. Chaotic evolution of the
    solar system.  <em>Science</em> 257:256-262.</REFERENCE>

  <REFERENCE>Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.
    Microplanner reference manual.  Memo 203A, MIT Artificial Intelligence
    Laboratory.</REFERENCE>

  <REFERENCE>Sutherland, Ivan E.  1963.  SKETCHPAD: A man-machine graphical
    communication system.  Technical report 296, MIT Lincoln Laboratory.</REFERENCE>

  <REFERENCE>Teitelman, Warren.  1974.  Interlisp reference manual.  Technical
    report, Xerox Palo Alto Research Center.</REFERENCE>

  <REFERENCE>Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978.
    Data type specification: Parameterization and the power of
    specification techniques. In <em>Conference Record of the Tenth Annual ACM
      Symposium on Theory of Computing</em>, pp. 119-132.

    Turner, David.  1981.  The future of applicative languages.  In <em>Proceedings of the 3rd European Conference on Informatics,</em> Lecture
    Notes in Computer Science, volume 123. New York: Springer-Verlag, pp.
    334-348.</REFERENCE>

  <REFERENCE>Wand, Mitchell.  1980.  Continuation-based program transformation
    strategies.  <em>Journal of the ACM</em> 27(1):164-180.</REFERENCE>

  <REFERENCE>Waters, Richard C.  1979.  A method for analyzing loop programs.  <em>IEEE Transactions on Software Engineering</em> 5(3):237-247.</REFERENCE>

  <REFERENCE>Winograd, Terry.  1971.  Procedures as a representation for data in a
    computer program for understanding natural language.  Technical report
    AI TR-17, MIT Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>Winston, Patrick. 1992. <em>Artificial Intelligence</em>.  3rd edition.
    Reading, MA: Addison-Wesley.</REFERENCE>

  <REFERENCE>Zabih, Ramin, David McAllester, and David Chapman.  1987.
    Non-deterministic Lisp with dependency-directed backtracking.
    <em>AAAI-87</em>, pp. 59-64.</REFERENCE>

  <REFERENCE>Zippel, Richard.  1979.  Probabilistic algorithms for sparse
    polynomials.  Ph.D. dissertation, Department of Electrical Engineering
    and Computer Science, MIT.</REFERENCE>

  <REFERENCE>Zippel, Richard.  1993.  <em>Effective Polynomial Computation.</em>
    Boston, MA: Kluwer Academic Publishers.</REFERENCE>

</REFERENCES>
