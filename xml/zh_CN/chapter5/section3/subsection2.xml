<SUBSECTION>
  <NAME>
    Maintaining the Illusion of Infinite Memory
  </NAME><!-- Error occurred while translating this section -->

  <LABEL NAME="sec:gc"></LABEL>
  
  <INDEX>garbage collection<OPEN></OPEN></INDEX><!-- Error occurred while translating this section -->

  <TEXT>
    The representation method outlined in
    section<SPACE></SPACE><REF NAME="sec:memory-as-vectors"></REF> solves the problem of
    implementing list structure, provided that we have an infinite amount of
    memory. With a real computer we will eventually run out of free space in
    which to construct new pairs.<!-- Error occurred while translating this section --><FOOTNOTE>This may not be true eventually,
    because memories may get large enough so that it would be impossible
    to run out of free memory in the lifetime of the computer.  For
    example, there are about
    <SPLITINLINE>
      <SCHEME>
        <LATEXINLINE>$3\times 10^{13}$ microseconds</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <LATEXINLINE>$3\times 10^{16}$ nanoseconds</LATEXINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    in a year, so if we were to
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    once per
    <SPLITINLINE>
      <SCHEME>
        <LATEXINLINE>microsecond</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <LATEXINLINE>nanosecond</LATEXINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    we would need about
    <SPLITINLINE>
      <SCHEME>
        <LATEXINLINE>$10^{15}$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <LATEXINLINE>$10^{18}$</LATEXINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    cells of memory to build a machine
    that could operate for 30 years without running out of memory.  That much
    memory seems absurdly large by today<APOS></APOS>s standards, but it is not
    physically impossible.  On the other hand, processors are getting faster and 
    <SPLITINLINE>
      <SCHEME>
        a future computer may have 
      </SCHEME>
      <JAVASCRIPT>
        modern computers have increasingly
      </JAVASCRIPT>
    </SPLITINLINE>
    large numbers of processors operating in
    parallel on a single memory, so it may be possible to use up memory much
    faster than we have postulated.</FOOTNOTE> However, most of the pairs
    generated in a typical computation are used only to hold intermediate
    results.  After these
    results are accessed, the pairs are no longer needed<EMDASH></EMDASH>they are <EM>
    garbage</EM>.  For instance, the computation
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no">
      <SCHEME>
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
      </SCHEME>
      <JAVASCRIPT>
accumulate((x, y) =&gt; x + y,
           0,
           filter(is_odd, enumerate_interval(0, n)))
      </JAVASCRIPT>
    </SNIPPET>
    constructs two lists: the enumeration and the result of filtering
    the enumeration.  When the accumulation is complete, these lists are
    no longer needed, and the allocated memory can be reclaimed.  If we
    can arrange to collect all the garbage periodically, and if this turns
    out to recycle memory at about the same rate at which we construct new
    pairs, we will have preserved the illusion that there is an infinite
    amount of memory.
  <!-- Error occurred while translating this section --></TEXT>

  <TEXT>
    In order to recycle pairs, we must have a way to determine which
    allocated pairs are not needed (in the sense that their contents can
    no longer influence the future of the computation).  The method we
    shall examine for accomplishing this is known as <EM>garbage
    collection</EM>.  Garbage collection is based on the observation that, at
    any moment in 
    <SPLITINLINE>
      <SCHEME>a Lisp interpretation,</SCHEME>
      <JAVASCRIPT>an interpretation based on list-structured memory,</JAVASCRIPT>
    </SPLITINLINE>
    the only objects that can
    affect the future of the computation are those that can be reached by
    some succession of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operations starting from the pointers that are currently in the machine
    registers.<FOOTNOTE>We assume here that the stack is represented as a list
    as described in section<SPACE></SPACE><REF NAME="sec:memory-as-vectors"></REF>, so that
    items on the stack are accessible via the pointer in the stack
    register.</FOOTNOTE>  Any memory cell that is not so accessible may be
    recycled.
  </TEXT><!-- Error occurred while translating this section -->

  <SHORT_PAGE LINES="1"></SHORT_PAGE><!-- Error occurred while translating this section -->
  <TEXT>
    There are many ways to perform garbage collection.  The method we
    shall examine here is called 
    <INDEX>stop-and-copy garbage collector<OPEN></OPEN></INDEX>
    <INDEX>garbage collector<SUBINDEX>stop-and-copy<OPEN></OPEN></SUBINDEX></INDEX>
    <EM>stop-and-copy</EM>.  The basic idea is to divide memory into two
    halves: <QUOTE>working memory</QUOTE> and <QUOTE>free memory.</QUOTE>  When
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    constructs pairs, it allocates these in working memory.  When working memory
    is full, we perform garbage collection by locating all the useful pairs in
    working memory and copying these into consecutive locations in free memory.
    (The useful pairs are located by tracing all the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE> and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointers, starting with the machine registers.)  Since we do not copy the
    garbage, there will presumably be additional free memory that we can
    use to allocate new pairs.  In addition, nothing in the working memory
    is needed, since all the useful pairs in it have been copied.  Thus,
    if we interchange the roles of working memory and free memory, we can
    continue processing; new pairs will be allocated in the new working
    memory (which was the old free memory).  When this is full, we can
    copy the useful pairs into the new free memory (which was the old
    working memory).<!-- Error occurred while translating this section --><FOOTNOTE>This idea was invented and first implemented
    by
    <!-- Error occurred while translating this section --><INDEX>Minsky, Marvin Lee<!-- Error occurred while translating this section --></INDEX>
    Minsky, as part of the implementation of 
    <!-- Error occurred while translating this section --><INDEX>Lisp<SUBINDEX><ORDER>DEC</ORDER>on DEC PDP-1</SUBINDEX><!-- Error occurred while translating this section --></INDEX>
    Lisp for the PDP-1 at the
    <!-- Error occurred while translating this section --><INDEX>MIT<SUBINDEX>Research Laboratory of Electronics</SUBINDEX><!-- Error occurred while translating this section --></INDEX>
    MIT Research Laboratory of Electronics.  It was further developed by
    <!-- Error occurred while translating this section --><INDEX>Fenichel, Robert<!-- Error occurred while translating this section --></INDEX>
    <INDEX>Yochelson, Jerome C.<!-- Error occurred while translating this section --></INDEX>
    Fenichel and Yochelson (1969) for use in the Lisp implementation for the
    <!-- Error occurred while translating this section --><INDEX>Multics time-sharing system<!-- Error occurred while translating this section --></INDEX>
    Multics time-sharing system.  Later, 
    <!-- Error occurred while translating this section --><INDEX>Baker, Henry G., Jr.<!-- Error occurred while translating this section --></INDEX>
    Baker (1978) developed a <!-- Error occurred while translating this section --><QUOTE>real-time<!-- Error occurred while translating this section --></QUOTE> version of the method,
    which does not require the computation to stop during garbage collection.
    Baker<!-- Error occurred while translating this section --><APOS></APOS>s idea was extended by 
    <!-- Error occurred while translating this section --><INDEX>Hewitt, Carl Eddie<!-- Error occurred while translating this section --></INDEX>
    Hewitt,
    <!-- Error occurred while translating this section --><INDEX>Lieberman, Henry<!-- Error occurred while translating this section --></INDEX>
    Lieberman, and
    <!-- Error occurred while translating this section --><INDEX>Moon, David A.<!-- Error occurred while translating this section --></INDEX>
    Moon (see Lieberman and Hewitt 1983) to take
    advantage of the fact that some structure is more volatile
    and other structure is more permanent.  
    <!-- Error occurred while translating this section --><P></P>
    An alternative commonly used garbage-collection technique is the 
    <!-- Error occurred while translating this section --><INDEX>mark-sweep garbage collector<!-- Error occurred while translating this section --></INDEX>
    <INDEX>garbage collector<SUBINDEX>mark-sweep</SUBINDEX><!-- Error occurred while translating this section --></INDEX>
    <EM>mark-sweep<!-- Error occurred while translating this section --></EM> method. This consists of tracing all the structure
    accessible from the machine registers and marking each pair we reach.
    We then scan all of memory, and any location that is unmarked is
    <!-- Error occurred while translating this section --><QUOTE>swept up<!-- Error occurred while translating this section --></QUOTE> as garbage and made available for reuse.  A full
    discussion of the mark-sweep method can be found in 
    <!-- Error occurred while translating this section --><INDEX>Allen, John<!-- Error occurred while translating this section --></INDEX>
    <CITATION>Allen 1978<!-- Error occurred while translating this section --></CITATION>.
    <P></P>
    The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in
    use for large-memory systems because it examines only the useful part
    of memory.  This is in contrast to mark-sweep, in which the sweep
    phase must check all of memory.  A second advantage of stop-and-copy
    is that it is a 
    <!-- Error occurred while translating this section --><INDEX>compacting garbage collector</INDEX>
    <INDEX>garbage collector<SUBINDEX>compacting</SUBINDEX></INDEX>
    <EM>compacting</EM> garbage collector.  That is, at the
    end of the garbage-collection phase the useful data will have been
    moved to consecutive memory locations, with all garbage pairs
    compressed out.  This can be an extremely important performance
    consideration in machines with virtual memory, in which accesses to
    widely separated memory addresses may require extra paging
    operations.<!-- Error occurred while translating this section --></FOOTNOTE>
  </TEXT>

  <SUBHEADING> 
    <NAME>Implementation of a stop-and-copy garbage collector</NAME>
  </SUBHEADING><!-- Error occurred while translating this section -->

  <TEXT>
    We now use our register-machine language to describe the stop-and-copy
    algorithm in more detail.  We will assume that there is a register
    called 
    <INDEX><USE>root</USE> register</INDEX>
    <!-- Error occurred while translating this section --><SCHEMEINLINE>root</SCHEMEINLINE> that contains a pointer to a structure
    that eventually points at all accessible data.  This can be arranged by
    storing the contents of all the machine registers in a preallocated list
    pointed at by <!-- Error occurred while translating this section --><SCHEMEINLINE>root</SCHEMEINLINE> just before starting
    garbage collection.<FOOTNOTE>This list of
    registers does not
    include
    the registers used by the storage-allocation
    <SPLITINLINE>
      <SCHEME>
	system<EMDASH></EMDASH><SCHEMEINLINE>root</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	system: <SCHEMEINLINE>root</SCHEMEINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cars</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_heads</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cdrs</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_tails</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and the other registers that will be introduced in this section.</FOOTNOTE>
    We also assume that, in addition to the current working memory, there is
    free memory available into which we can copy the useful data.  The current
    working memory consists of vectors whose base addresses are in 
    registers called
    <INDEX><USE>the_heads</USE><SUBINDEX>register</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cars</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_heads</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <INDEX><USE>the_tails</USE><SUBINDEX>register</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cdrs</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_tails</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and the free memory is in registers called 
    <INDEX><USE>new_heads</USE> register</INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-cars</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>new_heads</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <INDEX><USE>new_tails</USE> register</INDEX>
    <!-- Error occurred while translating this section --><SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-cdrs</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>new_tails</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
  <!-- Error occurred while translating this section --></TEXT>

  <SHORT_PAGE LINES="3"></SHORT_PAGE><!-- Error occurred while translating this section -->
  <TEXT>
    Garbage collection is triggered when we exhaust the free cells in the
    current working memory, that is, when a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operation attempts to increment the <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE>
    pointer beyond the end of the memory vector.  When the garbage-collection
    process is complete, the <!-- Error occurred while translating this section --><SCHEMEINLINE>root</SCHEMEINLINE> pointer will
    point into the new memory, all objects accessible from the
    <!-- Error occurred while translating this section --><SCHEMEINLINE>root</SCHEMEINLINE> will have been moved to the new memory,
    and the <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE> pointer will indicate the next
    place in the new memory where a new pair can be allocated.  In addition,
    the roles of working memory and new memory will have been
    interchanged<EMDASH></EMDASH>new pairs will be constructed in the new memory,
    beginning at the place indicated by <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE>, and
    the (previous) working memory will be available as the new memory for the
    next garbage collection.
    <SPLITINLINE>
      <SCHEME>Figure<SPACE></SPACE><REF NAME="fig:memory-reconfig_scheme"></REF></SCHEME>
      <JAVASCRIPT>Figure<SPACE></SPACE><REF NAME="fig:memory-reconfig"></REF></JAVASCRIPT>
    </SPLITINLINE>
    shows the arrangement of memory just before and just after garbage
    collection.
    <SPLIT>
      <SCHEME>
	<FIGURE WEB_SCALE="0.9" SRC="img_original/Fig5.15c.std.svg">
          <CAPTION>
	    Reconfiguration of memory by the garbage-collection process.
	  </CAPTION>
          <LABEL NAME="fig:memory-reconfig_scheme"></LABEL>
	</FIGURE>
      </SCHEME>
      <JAVASCRIPT>
	<FIGURE>
	  <FIGURE WEB_SCALE="0.9" SRC="img_javascript/Fig5.15c.std.svg"></FIGURE>
          <CAPTION>
	    Reconfiguration of memory by the garbage-collection process.
	  </CAPTION>
          <LABEL NAME="fig:memory-reconfig"></LABEL>
	</FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  <!-- Error occurred while translating this section --></TEXT>

  <TEXT>
    The state of the garbage-collection process is controlled by
    maintaining two pointers:
    <INDEX><USE>free</USE> register</INDEX>
    <SCHEMEINLINE>free</SCHEMEINLINE> and
    <INDEX><USE>scan</USE> register</INDEX>
    <SCHEMEINLINE>scan</SCHEMEINLINE>.  These are initialized to point to the
    beginning of the new memory.  The algorithm begins by relocating the pair
    pointed at by <SCHEMEINLINE>root</SCHEMEINLINE> to the beginning of the new
    memory.  The pair is copied, the <SCHEMEINLINE>root</SCHEMEINLINE> pointer
    is adjusted to point to the new location, and the
    <SCHEMEINLINE>free</SCHEMEINLINE> pointer is incremented.  In addition, the
    old location of the pair is marked to show that its contents have been
    moved.  This marking is done as follows: In the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position, we place a special tag that signals that this is an already-moved
    object.  (Such an object is traditionally called a 
    <INDEX>broken heart</INDEX>
    <EM>broken heart</EM>.)<FOOTNOTE>The term 
    <EM>broken heart</EM> was coined by
    <INDEX>Cressey, David</INDEX>
    David Cressey, who wrote a garbage collector
    for 
    <INDEX>MDL</INDEX>
    <INDEX>Lisp<SUBINDEX>MDL dialect of</SUBINDEX></INDEX>
    MDL, a dialect of Lisp developed at MIT during the early 1970s.</FOOTNOTE>
    In the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position we place a 
    <INDEX>forwarding address</INDEX>
    <EM>forwarding address</EM> that points at the location to which the object
    has been moved.
  </TEXT><!-- Error occurred while translating this section -->

  <DO_BREAK_PAGE></DO_BREAK_PAGE><!-- Error occurred while translating this section -->
  <TEXT>
    After relocating the root, the garbage collector enters its basic
    cycle.  At each step in the algorithm, the
    <!-- Error occurred while translating this section --><SCHEMEINLINE>scan</SCHEMEINLINE> pointer
    (initially pointing at the relocated root) points at a pair that has
    been moved to the new memory but whose
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointers still refer to objects in the old memory.  These objects are each
    relocated, and the <!-- Error occurred while translating this section --><SCHEMEINLINE>scan</SCHEMEINLINE> pointer is incremented.
    To relocate an object (for example, the object indicated by the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer of the pair we are scanning) we check to see if the object has
    already been moved (as indicated by the presence of a broken-heart tag
    in the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position of the object).  If the object has not
    already been moved, we copy it to the place indicated by
    <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE>,
    update <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE>, set up a broken heart at the
    object<APOS></APOS>s old location, and update the pointer to the object (in this
    example, the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer of the pair we are scanning) to point
    to the new location.  If the object has already been moved, its
    forwarding address (found in the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position of the broken heart) is substituted for the pointer in the pair
    being scanned. Eventually, all accessible objects will have been moved and
    scanned, at which point the <!-- Error occurred while translating this section --><SCHEMEINLINE>scan</SCHEMEINLINE> pointer will
    overtake the <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE> pointer and the process will
    terminate.
  <!-- Error occurred while translating this section --></TEXT>
  
  <TEXT>
    We can specify the stop-and-copy algorithm as a sequence of instructions for
    a register machine.  The basic step of relocating an object is accomplished
    by a subroutine called
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>relocate-old-result-in-new</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>relocate_old_result_in_new</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    This subroutine gets its argument, a pointer to the object to be relocated,
    from a register named 
    <INDEX><USE>old</USE> register</INDEX>
    <!-- Error occurred while translating this section --><SCHEMEINLINE>old</SCHEMEINLINE>.  It relocates the designated object
    (incrementing <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE> in the process),
    puts a pointer to the relocated object into a register called 
    <INDEX><USE>new</USE> register</INDEX>
    <!-- Error occurred while translating this section --><SCHEMEINLINE>new</SCHEMEINLINE>, and returns by branching to the entry
    point stored in the register
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>relocate-continue</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>relocate_continue</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    To begin garbage collection, we invoke this subroutine to relocate the
    <!-- Error occurred while translating this section --><SCHEMEINLINE>root</SCHEMEINLINE> pointer, after initializing
    <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE> and <!-- Error occurred while translating this section --><SCHEMEINLINE>scan</SCHEMEINLINE>.
    When the relocation of <!-- Error occurred while translating this section --><SCHEMEINLINE>root</SCHEMEINLINE> has been
    accomplished, we install the new pointer as the new
    <!-- Error occurred while translating this section --><SCHEMEINLINE>root</SCHEMEINLINE> and enter the main loop of the garbage
    collector.
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no">
      <NAME>begin_garbage_collection</NAME>
      <SCHEME>
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
      </SCHEME>
      <JAVASCRIPT>
&quot;begin_garbage_collection&quot;,
  assign(&quot;free&quot;, constant(0)),
  assign(&quot;scan&quot;, constant(0)),
  assign(&quot;old&quot;, reg(&quot;root&quot;)),
  assign(&quot;relocate_continue&quot;, label(&quot;reassign_root&quot;)),
  go_to(label(&quot;relocate_old_result_in_new&quot;)),
&quot;reassign_root&quot;,
  assign(&quot;root&quot;, reg(&quot;new&quot;)),
  go_to(label(&quot;gc_loop&quot;)),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SHORT_PAGE LINES="3"></SHORT_PAGE><!-- Error occurred while translating this section -->
  <TEXT>
    In the main loop of the garbage collector we must determine whether
    there are any more objects to be scanned.  We do this by testing
    whether the <!-- Error occurred while translating this section --><SCHEMEINLINE>scan</SCHEMEINLINE> pointer is coincident with
    the <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE> pointer.  If the pointers are equal,
    then all accessible objects have been relocated, and we branch to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>gc-flip</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>gc_flip</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    which cleans things up so that we can continue the interrupted computation.
    If there are still pairs to be scanned, we call the relocate subroutine to
    relocate the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the next pair (by placing the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer in <!-- Error occurred while translating this section --><SCHEMEINLINE>old</SCHEMEINLINE>).  The
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>relocate-continue</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>relocate_continue</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    register is set up so that the subroutine will return to update the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer.
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no">
      <NAME>gc_loop</NAME>
      <SCHEME>
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
      </SCHEME>
      <JAVASCRIPT>
&quot;gc_loop&quot;,
  test(list(op(&quot;===&quot;), reg(&quot;scan&quot;), reg(&quot;free&quot;))),
  branch(label(&quot;gc_flip&quot;)),
  assign(&quot;old&quot;, list(op(&quot;vector_ref&quot;), reg(&quot;new_heads&quot;), reg(&quot;scan&quot;))),
  assign(&quot;relocate_continue&quot;, label(&quot;update_head&quot;)),
  go_to(label(&quot;relocate_old_result_in_new&quot;)),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  
  <TEXT>
    At
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>update-car</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>update_head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    we modify the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer of the pair being scanned, then proceed to relocate the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the pair.  We return to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>update-cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>update_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    when that relocation has been accomplished. After relocating and updating
    the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    we are finished scanning that pair, so we continue with the main loop.
    <!-- Error occurred while translating this section --><SNIPPET EVAL="no">
      <NAME>update_head</NAME>
      <SCHEME>
update-car
  (perform
  (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform
  (op vector-set!) (reg new-cdrs) (reg scan) (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
      </SCHEME>
      <JAVASCRIPT>
&quot;update_head&quot;,
  perform(list(op(&quot;vector_set&quot;), 
               reg(&quot;new_heads&quot;), reg(&quot;scan&quot;), reg(&quot;new&quot;))),
  assign(&quot;old&quot;, list(op(&quot;vector_ref&quot;), 
                     reg(&quot;new_tails&quot;), reg(&quot;scan&quot;))),
  assign(&quot;relocate_continue&quot;, label(&quot;update_tail&quot;)),
  go_to(label(&quot;relocate_old_result_in_new&quot;)),

&quot;update_tail&quot;,
  perform(list(op(&quot;vector_set&quot;), 
               reg(&quot;new_tails&quot;), reg(&quot;scan&quot;), reg(&quot;new&quot;))),
  assign(&quot;scan&quot;, list(op(&quot;+&quot;), reg(&quot;scan&quot;), constant(1))),
  go_to(label(&quot;gc_loop&quot;)),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The subroutine
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>relocate-old-result-in-new</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>relocate_old_result_in_new</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    relocates objects as follows: If the object to be relocated (pointed at by
    <!-- Error occurred while translating this section --><SCHEMEINLINE>old</SCHEMEINLINE>) is not a pair, then we return the same
    pointer to the object unchanged (in <!-- Error occurred while translating this section --><SCHEMEINLINE>new</SCHEMEINLINE>).
    (For example, we may be scanning a pair whose
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is the number 4.  If we represent the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    by <!-- Error occurred while translating this section --><SCHEMEINLINE>n4</SCHEMEINLINE>, as described in
    section<SPACE></SPACE><REF NAME="sec:impl-list-ops"></REF>, then we want the
    <QUOTE>relocated</QUOTE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer to still be <!-- Error occurred while translating this section --><SCHEMEINLINE>n4</SCHEMEINLINE>.)  Otherwise, we
    must perform the relocation.  If the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position of the pair to be relocated contains a broken-heart tag, then the
    pair has in fact already been moved, so we retrieve the forwarding address
    (from the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position of the broken heart) and return this in
    <!-- Error occurred while translating this section --><SCHEMEINLINE>new</SCHEMEINLINE>. If the pointer in
    <!-- Error occurred while translating this section --><SCHEMEINLINE>old</SCHEMEINLINE> points at a yet-unmoved pair, then we move
    the pair to the first free cell in new memory (pointed at by
    <!-- Error occurred while translating this section --><SCHEMEINLINE>free</SCHEMEINLINE>) and set up the broken heart by storing a
    broken-heart tag and forwarding address at the old location.
    <SPLITINLINE>
      <SCHEME>Relocate-old-result-in-new</SCHEME>
      <JAVASCRIPT>The subroutine
      <JAVASCRIPTINLINE>relocate_old_result_in_new</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    uses a register 
    <SPLITINLINE>
      <SCHEME>
	<INDEX><USE>oldcr</USE> register</INDEX>
	<SCHEMEINLINE>oldcr</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><USE>oldht</USE> register</INDEX>
	<JAVASCRIPTINLINE>oldht</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to hold the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    or the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the object pointed at by <!-- Error occurred while translating this section --><SCHEMEINLINE>old</SCHEMEINLINE>.<FOOTNOTE>The
    garbage collector uses the low-level predicate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pointer-to-pair?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pointer_to_pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    instead of the list-structure
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pair?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operation because in a real system there might be various things
    that are treated as pairs for garbage-collection purposes.
    For example,
    <SPLITINLINE>
      <SCHEME>
    in a Scheme system that conforms to the IEEE standard
      </SCHEME>
    </SPLITINLINE>
    a
    <SPLITINLINE>
      <SCHEME>
	procedure
      </SCHEME>
      <JAVASCRIPT>
	      function
      </JAVASCRIPT>
    </SPLITINLINE>
    object may be implemented as a special kind of
    <QUOTE>pair</QUOTE> that doesn<APOS></APOS>t satisfy the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pair?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    predicate.
    For simulation purposes,
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pointer-to-pair?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pointer_to_pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    can be implemented as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pair?</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pair</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
  </FOOTNOTE>

    <!-- Error occurred while translating this section --><SNIPPET EVAL="no" LATEX="yes">
      <NAME>relocate_old_result_in_new</NAME>
      <SCHEME>
relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) <EM>; new location for pair</EM>
  <EM>;; Update free pointer.</EM>
  (assign free (op +) (reg free) (const 1))
  <EM>;; Copy the car and cdr to new memory.</EM>
  (perform (op vector-set!)
  (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
  (reg new-cdrs) (reg new) (reg oldcr))
  <EM>;; Construct the broken heart.</EM>
  (perform (op vector-set!)
  (reg the-cars) (reg old) (const broken-heart))
  (perform
  (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
      </SCHEME>
      <JAVASCRIPT>
&quot;relocate_old_result_in_new&quot;,
  test(list(op(&quot;is_pointer_to_pair&quot;), reg(&quot;old&quot;))),
  branch(label(&quot;pair&quot;)),
  assign(&quot;new&quot;, reg(&quot;old&quot;)),
  go_to(reg(&quot;relocate_continue&quot;)),
&quot;pair&quot;,
  assign(&quot;oldht&quot;, list(op(&quot;vector_ref&quot;), 
                       reg(&quot;the_heads&quot;), reg(&quot;old&quot;))),
  test(list(op(&quot;is_broken_heart&quot;), reg(&quot;oldht&quot;))),
  branch(label(&quot;already_moved&quot;)),
  assign(&quot;new&quot;, reg(&quot;free&quot;)),     // new location for pair
  // Update $\texttt{free}$ pointer
  assign(&quot;free&quot;, list(op(&quot;+&quot;), reg(&quot;free&quot;), constant(1))),
  // Copy the head and tail to new memory
  perform(list(op(&quot;vector_set&quot;),
               reg(&quot;new_heads&quot;), reg(&quot;new&quot;),
               reg(&quot;oldht&quot;))),
  assign(&quot;oldht&quot;, list(op(&quot;vector_ref&quot;), 
                       reg(&quot;the_tails&quot;), reg(&quot;old&quot;))),
  perform(list(op(&quot;vector_set&quot;),
               reg(&quot;new_tails&quot;), reg(&quot;new&quot;),
               reg(&quot;oldht&quot;))),
  // Construct the broken heart
  perform(list(op(&quot;vector_set&quot;),
               reg(&quot;the_heads&quot;), reg(&quot;old&quot;),
               constant(&quot;broken_heart&quot;))),
  perform(list(op(&quot;vector_set&quot;),
               reg(&quot;the_tails&quot;), reg(&quot;old&quot;),
               reg(&quot;new&quot;))),
  go_to(reg(&quot;relocate_continue&quot;)),
&quot;already_moved&quot;,
  assign(&quot;new&quot;, list(op(&quot;vector_ref&quot;), 
                     reg(&quot;the_tails&quot;), reg(&quot;old&quot;))),
  go_to(reg(&quot;relocate_continue&quot;)),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    At the very end of the garbage collection process, we interchange the
    role of old and new memories by interchanging pointers: interchanging
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cars</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_heads</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    with
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-cars</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>new_heads</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cdrs</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_tails</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    with
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-cdrs</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>new_tails</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    We will then be ready to perform another garbage
    collection the next time memory runs out.
    <!-- Error occurred while translating this section --><SNIPPET POSTPADDING="no">
      <NAME>testing_5_3_2</NAME>
      <REQUIRES>tagged_list</REQUIRES>
      <REQUIRES>make_go_to</REQUIRES>
      <REQUIRES>pop</REQUIRES>
      <REQUIRES>lookup1</REQUIRES>
      <REQUIRES>go_to_go_to_dest</REQUIRES>
      <REQUIRES>make_register</REQUIRES>
      <SCHEME>
      gc-flip
      (assign temp (reg the-cdrs))
      (assign the-cdrs (reg new-cdrs))
      (assign new-cdrs (reg temp))
      (assign temp (reg the-cars))
      (assign the-cars (reg new-cars))
      (assign new-cars (reg temp))
      </SCHEME>
      <JAVASCRIPT_RUN>
// TYPED POINTERS

const NUMBER_TYPE = &quot;number&quot;;
const BOOL_TYPE = &quot;bool&quot;;
const STRING_TYPE = &quot;string&quot;;
const PTR_TYPE = &quot;ptr&quot;;
const PROG_TYPE = &quot;prog&quot;;
const NULL_TYPE = &quot;null&quot;;
const UNDEFINED_TYPE = &quot;undefined&quot;;
const NO_VALUE_YET_TYPE = &quot;*unassigned*&quot;;
const BROKEN_HEART_TYPE = &quot;broken_heart&quot;;

function make_ptr_ptr(idx) {
    return pair(PTR_TYPE, idx);
}

function make_null_ptr() {
    return pair(NULL_TYPE, null);
}

function make_no_value_yet_ptr() {
    return pair(NO_VALUE_YET_TYPE, null);
}

function make_prog_ptr(idx) {
    return pair(PROG_TYPE, idx);
}

function make_broken_heart_ptr() {
    return pair(BROKEN_HEART_TYPE, null);
}

function get_elem_type(elem) {
    return is_number(elem) ? NUMBER_TYPE :
        is_boolean(elem) ? BOOL_TYPE :
        is_string(elem) ? STRING_TYPE :
        is_null(elem) ? NULL_TYPE :
        is_undefined(elem) ? UNDEFINED_TYPE :
        error(elem, &quot;invalid typed elem&quot;);
}

function wrap_ptr(elem) {
    return pair(get_elem_type(elem), elem);
}

function unwrap_ptr(ptr) {
    return tail(ptr);
}

function is_ptr(ptr) {
    return is_pair(ptr) &amp;&amp;
        !is_pair(head(ptr)) &amp;&amp;
        !is_pair(tail(ptr)) &amp;&amp;
        (head(ptr) === NUMBER_TYPE ||
        head(ptr) === BOOL_TYPE ||
        head(ptr) === STRING_TYPE ||
        head(ptr) === PTR_TYPE ||
        head(ptr) === NULL_TYPE ||
        head(ptr) === UNDEFINED_TYPE ||
        head(ptr) === PROG_TYPE ||
        head(ptr) === NO_VALUE_YET_TYPE ||
        head(ptr) === BROKEN_HEART_TYPE);
}

function is_number_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === NUMBER_TYPE;
}

function is_bool_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === BOOL_TYPE;
}

function is_string_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === STRING_TYPE;
}

function is_ptr_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === PTR_TYPE;
}

function is_null_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === NULL_TYPE;
}

function is_undefined_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === UNDEFINED_TYPE;
}

function is_prog_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === PROG_TYPE;
}

function is_no_value_yet_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === NO_VALUE_YET_TYPE;
}

function is_broken_heart_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === BROKEN_HEART_TYPE;
}

// Primitive functions and constants

const primitive_function_names_arities = list(
       pair(&quot;display&quot;, 1),
       pair(&quot;error&quot;, 1),
       pair(&quot;+&quot;, 2),
       pair(&quot;-&quot;, 2),
       pair(&quot;*&quot;, 2),
       pair(&quot;/&quot;, 2),
       pair(&quot;%&quot;, 2),
       pair(&quot;===&quot;, 2),
       pair(&quot;!==&quot;, 2),
       pair(&quot;&lt;&quot;, 2),
       pair(&quot;&lt;=&quot;, 2),
       pair(&quot;&gt;&quot;, 2),
       pair(&quot;&gt;=&quot;, 2),
       pair(&quot;!&quot;, 1),
       pair(&quot;||&quot;, 2),
       pair(&quot;&amp;&amp;&quot;, 2)
);

const primitive_constants = list(
       list(&quot;undefined&quot;, undefined),
       list(&quot;math_PI&quot;  , math_PI)
      );
       
function make_primitive_function(impl) {
    return list(&quot;primitive&quot;, impl);
}

function setup_environment() {
    const primitive_function_names =
        map(head, primitive_function_names_arities);
    const primitive_function_values =
        map(name =&gt; pair(make_primitive_function(name), false),
            primitive_function_names);
    const primitive_constant_names =
        map(head, primitive_constants);
    const primitive_constant_values =
        map(f =&gt; pair(head(tail(f)), false),
            primitive_constants);
    return pair(pair(
               append(primitive_function_names, 
                      primitive_constant_names),
               append(primitive_function_values, 
                      primitive_constant_values)),
               null);
}

function flatten_list_to_vectors(the_heads, the_tails, lst,
                                 make_ptr_fn, starting_index) {
    let free = starting_index;
    function helper(lst) {
        if (!is_pair(lst)) {
            return wrap_ptr(lst);
        } else {
            const index = free;
            free = free + 1;
            const elem = head(lst);
            the_heads[index] = helper(elem);
            the_tails[index] = helper(tail(lst));
            return make_ptr_fn(index);
        }
    }
    helper(lst);
    return free;
}

// MACHINE
function get_contents(register) {
    return register(&quot;get&quot;);
}

function set_contents(register, value) {
    return register(&quot;set&quot;)(value);
}

function make_stack() {
    let stack = null;

    function push(x) { 
        stack = pair(x, stack); 
        return &quot;done&quot;;
    }

    function pop() {
        if (is_null(stack)) {
            error(&quot;empty stack -- pop&quot;);

        } else {
            const top = head(stack);
            stack = tail(stack);
            return top;
        }
    }

    function initialize() {
        stack = null;
        return &quot;done&quot;;
    }

    function dispatch(message) {
        return message === &quot;push&quot;
               ? push
               : message === &quot;pop&quot;
               ? pop()
               : message === &quot;initialize&quot;
               ? initialize()
               : message === &quot;stack&quot;
               ? stack
               : error(message, &quot;unknown request -- stack&quot;);
    }

    return dispatch;
}

function make_new_machine() {
    const SIZE = make_register(&quot;SIZE&quot;);
    const pc = make_register(&quot;pc&quot;);
    const flag = make_register(&quot;flag&quot;);
    const stack = make_stack();
    const stack_reassign_proc = make_register(&quot;stack_reassign_proc&quot;);
    const free = make_register(&quot;free&quot;);
    const root = make_register(&quot;root&quot;);
    const root_populate_proc = make_register(&quot;root_populate_proc&quot;);
    const root_restore_proc = make_register(&quot;root_restore_proc&quot;);
    const gc_registers = list(
        list(&quot;free&quot;, free),
        list(&quot;scan&quot;, make_register(&quot;scan&quot;)),
        list(&quot;old&quot;, make_register(&quot;old&quot;)),
        list(&quot;new&quot;, make_register(&quot;new&quot;)),
        list(&quot;relocate_continue&quot;, make_register(&quot;relocate_continue&quot;)),
        list(&quot;temp&quot;, make_register(&quot;temp&quot;)),
        list(&quot;oldht&quot;, make_register(&quot;oldht&quot;))
    );
    const exp = make_register(&quot;exp&quot;);
    const env = make_register(&quot;env&quot;);
    const evaluator_registers = list(
        list(&quot;exp&quot;, exp),
        list(&quot;env&quot;, env),
        list(&quot;val&quot;, make_register(&quot;val&quot;)),
        list(&quot;continue&quot;, make_register(&quot;continue&quot;)),
        list(&quot;fun&quot;, make_register(&quot;fun&quot;)),
        list(&quot;argl&quot;, make_register(&quot;argl&quot;)),
        list(&quot;unev&quot;, make_register(&quot;unev&quot;)),
        list(&quot;fun&quot;, make_register(&quot;fun&quot;))
    );
    const aux_registers = list(
        list(&quot;res&quot;, make_register(&quot;val&quot;)),
        list(&quot;err&quot;, make_register(&quot;err&quot;)),
        list(&quot;a&quot;, make_register(&quot;a&quot;)),
        list(&quot;b&quot;, make_register(&quot;b&quot;)),
        list(&quot;c&quot;, make_register(&quot;c&quot;)),
        list(&quot;d&quot;, make_register(&quot;d&quot;)),
        list(&quot;e&quot;, make_register(&quot;e&quot;)),
        list(&quot;f&quot;, make_register(&quot;f&quot;))
    );
    const the_heads = make_register(&quot;the_heads&quot;);
    const the_tails = make_register(&quot;the_tails&quot;);
    set_contents(the_heads, make_vector());
    set_contents(the_tails, make_vector());
    const new_heads = make_register(&quot;new_heads&quot;);
    const new_tails = make_register(&quot;new_tails&quot;);
    set_contents(new_heads, make_vector());
    set_contents(new_tails, make_vector());
    const prog_heads = make_register(&quot;prog_heads&quot;);
    const prog_tails = make_register(&quot;prog_tails&quot;);
    let the_instruction_sequence = null;
    let the_ops = list(list(&quot;initialize_stack&quot;,
                            () =&gt; stack(&quot;initialize&quot;)));
    the_ops = append(the_ops, vector_ops);
    let register_table =
          list(list(&quot;SIZE&quot;, SIZE),
               list(&quot;pc&quot;, pc),
               list(&quot;flag&quot;, flag),
               list(&quot;root&quot;, root),
               list(&quot;root_populate_proc&quot;, root_populate_proc),
               list(&quot;root_restore_proc&quot;, root_restore_proc),
               list(&quot;stack_reassign_proc&quot;, stack_reassign_proc),
               list(&quot;the_heads&quot;, the_heads),
               list(&quot;the_tails&quot;, the_tails),
               list(&quot;new_heads&quot;, new_heads),
               list(&quot;new_tails&quot;, new_tails),
               list(&quot;prog_heads&quot;, prog_heads),
               list(&quot;prog_tails&quot;, prog_tails));
    register_table = append(register_table, gc_registers);
    register_table = append(register_table, evaluator_registers);
    register_table = append(register_table, aux_registers);

    function start() {
        const root_registers = 
                append(aux_registers, evaluator_registers);
        set_contents(pc, the_instruction_sequence);
        set_contents(free,
                     make_ptr_ptr(flatten_list_to_vectors(
                                    the_heads(&quot;get&quot;),
                                    the_tails(&quot;get&quot;),
                                    setup_environment(), 
                                    make_ptr_ptr,
                                    length(root_registers))));
        set_contents(env, make_ptr_ptr(length(root_registers)));
        function root_populate_proc_fn() {
            const root_ptr = free(&quot;get&quot;);
            root(&quot;set&quot;)(root_ptr);
            let register_list = root_registers;
            while (!is_null(register_list)) {
                const content = head(tail(head(register_list)))(&quot;get&quot;);
                const index = unwrap_ptr(free(&quot;get&quot;));
                the_heads(&quot;get&quot;)[index] = 
                  content === &quot;*unassigned*&quot;
                  ? make_null_ptr() : content;
                free(&quot;set&quot;)(make_ptr_ptr(index + 1));
                the_tails(&quot;get&quot;)[index] = free(&quot;get&quot;);
                register_list = tail(register_list);
            }
            the_tails(&quot;get&quot;)[unwrap_ptr(free(&quot;get&quot;)) - 1] =
              make_null_ptr();
        }
        function root_restore_proc_fn() {
            let root_ptr = root(&quot;get&quot;);
            let register_list = root_registers;
            while (!is_null(register_list)) {
                const index = unwrap_ptr(root_ptr);
                const value = the_heads(&quot;get&quot;)[index];
                head(tail(head(register_list)))(&quot;set&quot;)(value);
                root_ptr = the_tails(&quot;get&quot;)[index];
                register_list = tail(register_list);
            }
        }
        function stack_reassign_proc_fn() {
            let local_stack = stack(&quot;stack&quot;);
            while (!is_null(local_stack)) {
                const value = head(local_stack);
                if (is_ptr_ptr(value)) {
                    const index = unwrap_ptr(value);
                    const new_ptr = the_tails(&quot;get&quot;)[index];
                    set_head(local_stack, new_ptr);
                } else {}
                local_stack = tail(local_stack);
            }
        }
        set_contents(root_populate_proc, root_populate_proc_fn);
        set_contents(root_restore_proc, root_restore_proc_fn);
        set_contents(stack_reassign_proc, stack_reassign_proc_fn);
        return execute();  
    } 
    function allocate_register(name) {
        if (is_undefined(assoc(name, register_table))) {
        register_table = pair(list(name, make_register(name)),
                              register_table);
        } else {
            error(name, &quot;multiply defined register&quot;);
        }
        return &quot;register allocated&quot;;
    }
    function lookup_register(name) {
        const val = assoc(name, register_table);
        return is_undefined(val)
               ? error(name, &quot;unknown register&quot;)
               : head(tail(val));
    }
    function execute() {
        const insts = get_contents(pc);
        if (is_null(insts)) {
            return &quot;done&quot;;
        } else {
            const proc = inst_execution_fun(head(insts));
            proc(); 
            return execute();
        }
    }
    function dispatch(message) {
        return message === &quot;start&quot;
               ? start
               : message === &quot;install_instruction_sequence&quot;
               ? seq =&gt; { the_instruction_sequence = seq; }
               : message === &quot;allocate_register&quot;
               ? allocate_register
               : message === &quot;get_register&quot;
               ? lookup_register
               : message === &quot;install_operations&quot;
               ? ops =&gt; { the_ops = append(the_ops, ops); }
               : message === &quot;stack&quot;
               ? stack
               : message === &quot;operations&quot;
               ? the_ops
               : error(message, &quot;unknown request -- machine&quot;);
    }
    return dispatch;
}

function make_machine(register_names, ops, controller) {
    const machine = make_new_machine();

    map(reg_name =&gt; machine(&quot;allocate_register&quot;)(reg_name), register_names);
    machine(&quot;install_operations&quot;)(ops);
    machine(&quot;install_instruction_sequence&quot;)(assemble(controller, machine));

    return machine;
}

function start(machine) {
    return machine(&quot;start&quot;)();
}

function get_register_contents(machine, register_name) {
    return get_contents(get_register(machine, register_name));
}

function set_register_contents(machine, register_name, value) {
    set_contents(get_register(machine, register_name), value);
    return &quot;done&quot;;
}

function get_register(machine, reg_name) {
    return machine(&quot;get_register&quot;)(reg_name);
}


// ASSEMBLER

function assemble(controller, machine) {
    function receive(insts, labels) {
        update_insts(insts, labels, machine);
        return insts;
    }
    
    return extract_labels(controller, receive);
}

function extract_labels(text, receive) {
    function helper(insts, labels) { 
        const next_inst = head(text);

        return is_string(next_inst)
               ? receive(insts, pair(make_label_entry(next_inst, insts), labels))
               : receive(pair(make_inst(next_inst), insts), labels);
    }

    return is_undefined(text) || is_null(text)
           ? receive(null, null)
           : extract_labels(tail(text), helper);
}

function update_insts(insts, labels, machine) {
    const pc = get_register(machine, &quot;pc&quot;);
    const flag = get_register(machine, &quot;flag&quot;);
    const stack = machine(&quot;stack&quot;);
    const ops = machine(&quot;operations&quot;);

    const set_iep = set_inst_execution_fun;
    const make_ep = make_execution_function;
    return map(i =&gt; set_iep(i,
                            make_ep(inst_controller_instruction(i),
                                    labels,
                                    machine,
                                    pc,
                                    flag,
                                    stack,
                                    ops)),
               insts);
}

function make_inst(inst_controller_instruction) {
    return pair(inst_controller_instruction, null);
}

function inst_controller_instruction(inst) {
    return head(inst);
}

function inst_execution_fun(inst) {
    return tail(inst);
}

function set_inst_execution_fun(inst, fun) {
    set_tail(inst, fun);
}

function make_label_entry(label_name, insts) {
    return pair(label_name, insts);
}

function lookup_label(labels, label_name) {
    const val = assoc(label_name, labels);

    return is_undefined(val)
           ? error(label_name, &quot;undefined label -- assemble&quot;)
           : tail(val);
}

function make_execution_function(inst, labels, machine, pc, flag, stack, ops) {
    const x = head(inst);

    return x === &quot;assign&quot;
           ? make_assign_ef(inst, machine, labels, ops, pc)
           : x === &quot;test&quot;
           ? make_test_ef(inst, machine, labels, ops, flag, pc)
           : x === &quot;branch&quot;
           ? make_branch_ef(inst, machine, labels, flag, pc)
           : x === &quot;go_to&quot;
           ? make_go_to_ef(inst, machine, labels, pc)
           : x === &quot;save&quot;
           ? make_save_ef(inst, machine, stack, pc)
           : x === &quot;restore&quot;
           ? make_restore_ef(inst, machine, stack, pc)
           : x === &quot;perform&quot;
           ? make_perform_ef(inst, machine, labels, ops, pc)
           : x === &quot;dump_memory&quot; // Added to allow printing the memory vectors
           ? () =&gt; {
               display(stringify(get_register_contents(machine, &quot;the_heads&quot;)));
               display(stringify(get_register_contents(machine, &quot;the_tails&quot;)));
               advance_pc(pc);
           }
           : error(inst, &quot;unknown instruction type -- assemble&quot;);
}

function make_assign_ef(inst, machine, labels, operations, pc) {
    const target = get_register(machine, assign_reg_name(inst));
    const value_exp = assign_value_exp(inst);
    const value_fun = is_operation_exp(value_exp)
          ? make_operation_exp_ef(value_exp, machine, labels, operations)
          : make_primitive_exp_ef(value_exp, machine, labels);

    function perform_assign() {
        set_contents(target, value_fun());
        advance_pc(pc); 
    }

    return perform_assign;
}

function assign_reg_name(assign_instruction) {
    return head(tail(assign_instruction));
}

function assign_value_exp(assign_instruction) { 
    return head(tail(tail(assign_instruction)));
}

function assign(reg_name, value_exp) {
    return list(&quot;assign&quot;, reg_name, value_exp);
}

function dump_memory() {
    return list(&quot;dump_memory&quot;, &quot;the_heads&quot;, &quot;the_tails&quot;);
}

function advance_pc(pc) {
    set_contents(pc, tail(get_contents(pc))); 
    
}

function make_test_ef(inst, machine, labels, operations, flag, pc) {
    const condition = test_condition(inst);

    if (is_operation_exp(condition)) {
    const condition_fun = make_operation_exp_ef(condition, machine,
                                             labels, operations);

        function perform_test() {
            set_contents(flag, unwrap_ptr(condition_fun()));
            advance_pc(pc); 
        }

        return perform_test; 
    } else {
        error(inst, &quot;bad test instruction -- assemble&quot;);
    }
}

function test_condition(test_instruction) {
    return head(tail(test_instruction));
}

function test(condition) {
    return list(&quot;test&quot;, condition);
}

function make_branch_ef(inst, machine, labels, flag, pc) {
    const dest = branch_dest(inst);
    
    if (is_label_exp(dest)) {
        const insts = lookup_label(labels, label_exp_label(dest));

        function perform_branch() {
            if (get_contents(flag)) {
                set_contents(pc, insts);

            } else {
                advance_pc(pc);
            }
        }

        return perform_branch;

    } else {
        error(inst, &quot;bad branch instruction -- assemble&quot;);
    }
}

function branch_dest(branch_instruction) {
    return head(tail(branch_instruction));
}

function branch(dest) {
    return list(&quot;branch&quot;, dest);
}

function make_goto(inst, machine, labels, pc) {
    const dest = goto_dest(inst);

    if (is_label_exp(dest)) {
        const insts = lookup_label(labels, label_exp_label(dest));
        return () =&gt; set_contents(pc, insts);

    } else if (is_register_exp(dest)) {
        const reg = get_register(machine, register_exp_reg(dest));
        return () =&gt; set_contents(pc, get_contents(reg));

    } else {
        error(inst, &quot;bad go_to instruction -- assemble&quot;);
    }
}

function goto_dest(goto_instruction) {
    return head(tail(goto_instruction));
}
/*
function go_to(dest) {
    return list(&quot;go_to&quot;, dest);
}
*/
function make_save_ef(inst, machine, stack, pc) {
    const reg = get_register(machine, stack_inst_reg_name(inst));

    function perform_save() {
        push(stack, get_contents(reg));
        advance_pc(pc);
    }

    return perform_save;
}

function make_restore_ef(inst, machine, stack, pc) {
    const reg = get_register(machine, stack_inst_reg_name(inst));

    function perform_restore() {
        set_contents(reg, pop(stack));
        advance_pc(pc); 
    }

    return perform_restore;
}

function stack_inst_reg_name(stack_instruction) {
    return head(tail(stack_instruction));
}

function save(register_name) {
    return list(&quot;save&quot;, register_name);
}

function restore(register_name) {
    return list(&quot;restore&quot;, register_name);
}

function make_perform_ef(inst, machine, labels, operations, pc) {
    const action = perform_action(inst);

    if (is_operation_exp(action)) {
        const action_fun = make_operation_exp_ef(action, machine, 
                                              labels, operations);
        return () =&gt; { action_fun(); advance_pc(pc); };

    } else {
        error(inst, &quot;bad perform instruction -- assemble&quot;);
    }
}

function perform_action(inst) {
    return head(tail(inst)); 
}

function perform(op) {
    return list(&quot;perform&quot;, op);
}


function make_primitive_exp_ef(exp, machine, labels) {
    if (is_constant_exp(exp)) {
        const c = constant_exp_value(exp);
        return () =&gt; c;
        
    } else if (is_label_exp(exp)) {
        const insts = lookup_label(labels, label_exp_label(exp));
        return () =&gt; insts;

    } else if (is_register_exp(exp)) {
        const r = get_register(machine, register_exp_reg(exp));
        return () =&gt; get_contents(r); 

    } else {
        error(exp, &quot;unknown expression type -- assemble&quot;);
    }
}

/* TODO: probably remove these -- suddenly available through new import chains
function is_register_exp(exp) {
    return is_tagged_list(exp, &quot;reg&quot;);
}

function register_exp_reg(exp) {
    return head(tail(exp));
}

function reg(name) {
    return list(&quot;reg&quot;, name);
}

function is_constant_exp(exp) {
    return is_tagged_list(exp, &quot;constant&quot;);
}

function constant_exp_value(exp) {
    return head(tail(exp));
}

function constant(value) {
    return list(&quot;constant&quot;, wrap_ptr(value));
}

function is_label_exp(exp) {
    return is_tagged_list(exp, &quot;label&quot;);
}

function label_exp_label(exp) {
    return head(tail(exp));
}

function label(string) {
    return list(&quot;label&quot;, string);
}
*/

function make_operation_exp_ef(exp, machine, labels, operations) {
    const op = lookup_prim(op_exp_op(exp), operations);
    const aprocs = map(e =&gt; make_primitive_exp_ef(e, machine, labels),
                       operation_exp_operands(exp));

    function perform_operation_exp() {
        return op(map(p =&gt; p(), aprocs));
    }
    
    return perform_operation_exp;
}

/* TODO: probably remove these -- suddenly available through new import chains
function is_operation_exp(exp) {
    return is_tagged_list(head(exp), &quot;op&quot;);
}

function operation_exp_operands(operation_exp) {
    return tail(operation_exp);
}

function op(name) {
    return list(&quot;op&quot;, name);
}
*/

function op_exp_op(operation_exp) {
    return head(tail(head(operation_exp)));
}

function lookup_prim(symbol, operations) {
    const val = assoc(symbol, operations);

    return is_undefined(val)
           ? error(symbol, &quot;unknown operation -- assemble&quot;)
           : head(tail(val));
}

// PAIR OPERATIONS

// head in &quot;a&quot;, tail in &quot;b&quot;
const pair_controller = list(
  &quot;pair&quot;,
    save(&quot;continue&quot;),
    assign(&quot;continue&quot;, label(&quot;pair_after_gc&quot;)),
    test(list(op(&quot;===&quot;), reg(&quot;free&quot;), reg(&quot;SIZE&quot;))),
    branch(label(&quot;begin_garbage_collection&quot;)),
  &quot;pair_after_gc&quot;,
    restore(&quot;continue&quot;),
    perform(list(op(&quot;vector_set&quot;), reg(&quot;the_heads&quot;), reg(&quot;free&quot;), reg(&quot;a&quot;))),
    perform(list(op(&quot;vector_set&quot;), reg(&quot;the_tails&quot;), reg(&quot;free&quot;), reg(&quot;b&quot;))),
    assign(&quot;res&quot;, reg(&quot;free&quot;)),
    assign(&quot;free&quot;, list(op(&quot;inc_ptr&quot;), reg(&quot;free&quot;))),
    go_to(reg(&quot;continue&quot;))
);


function underlying_javascript_closure(fn) {
    return args =&gt; apply_in_underlying_javascript(fn, args);
}

function unwrap_args(fn) {
    return args =&gt; fn(map(unwrap_ptr, args));
}

function wrap_return_value(fn) {
    return args =&gt; wrap_ptr(fn(args));
}

function primitive_function(fn) {
    return wrap_return_value(unwrap_args(underlying_javascript_closure(fn)));
}

// 5.3 MEMORY MANAGEMENT

function vector_ref(vector, idx) {
    return vector[unwrap_ptr(idx)];
}

function vector_set(vector, idx, val) {
    vector[unwrap_ptr(idx)] = val;
}

function make_vector() {
    return [];
}

function inc_ptr(ptr) {
    return make_ptr_ptr(unwrap_ptr(ptr) + 1);
}

const vector_ops = list(
    list(&quot;vector_ref&quot;, underlying_javascript_closure(vector_ref)),
    list(&quot;vector_set&quot;, underlying_javascript_closure(vector_set)),
    list(&quot;inc_ptr&quot;, underlying_javascript_closure(inc_ptr))
);

// MACHINE SETUP
const ptr_ops =
  list(
    list(&quot;make_ptr_ptr&quot;,
         underlying_javascript_closure(make_ptr_ptr)),
    list(&quot;make_null_ptr&quot;,
         underlying_javascript_closure(make_null_ptr)),
    list(&quot;make_no_value_yet_ptr&quot;,
         underlying_javascript_closure(make_no_value_yet_ptr)),
    list(&quot;make_prog_ptr&quot;, underlying_javascript_closure(make_prog_ptr)),
    list(&quot;make_broken_heart_ptr&quot;,
         underlying_javascript_closure(make_broken_heart_ptr)),
    list(&quot;is_number_ptr&quot;,
         wrap_return_value(underlying_javascript_closure(is_number_ptr))),
    list(&quot;is_bool_ptr&quot;,
         wrap_return_value(underlying_javascript_closure(is_bool_ptr))),
    list(&quot;is_string_ptr&quot;,
         wrap_return_value(underlying_javascript_closure(is_string_ptr))),
    list(&quot;is_ptr_ptr&quot;,
         wrap_return_value(underlying_javascript_closure(is_ptr_ptr))),
    list(&quot;is_null_ptr&quot;,
         wrap_return_value(underlying_javascript_closure(is_null_ptr))),
    list(&quot;is_undefined_ptr&quot;,
         wrap_return_value(underlying_javascript_closure(is_undefined_ptr))),
    list(&quot;is_prog_ptr&quot;,
         wrap_return_value(underlying_javascript_closure(is_prog_ptr))),
    list(&quot;is_no_value_yet_ptr&quot;,
         wrap_return_value(underlying_javascript_closure(is_no_value_yet_ptr))),
    list(&quot;is_broken_heart_ptr&quot;,
         wrap_return_value(underlying_javascript_closure(is_broken_heart_ptr)))
);

const primitive_ops = list(
    list(&quot;display&quot;, primitive_function(display)),
    list(&quot;error&quot;, primitive_function(error)),
    list(&quot;+&quot;, primitive_function((x, y) =&gt; x + y)),
    list(&quot;-&quot;, primitive_function((x, y) =&gt; x - y)),
    list(&quot;*&quot;, primitive_function((x, y) =&gt; x * y)),
    list(&quot;/&quot;, primitive_function((x, y) =&gt; x / y)),
    list(&quot;%&quot;, primitive_function((x, y) =&gt; x % y)),
    list(&quot;===&quot;, primitive_function((x, y) =&gt; x === y)),
    list(&quot;!==&quot;, primitive_function((x, y) =&gt; x !== y)),
    list(&quot;&lt;&quot;, primitive_function((x, y) =&gt; x &lt; y)),
    list(&quot;&lt;=&quot;, primitive_function((x, y) =&gt; x &lt;= y)),
    list(&quot;&gt;&quot;, primitive_function((x, y) =&gt; x &gt; y)),
    list(&quot;&gt;=&quot;, primitive_function((x, y) =&gt; x &gt;= y)),
    list(&quot;!&quot;, primitive_function(x =&gt; !x)),
    list(&quot;||&quot;, primitive_function((x, y) =&gt; x || y)),
    list(&quot;&amp;&amp;&quot;, primitive_function((x, y) =&gt; x &amp;&amp; y))
);

const gc_ops = list(
    list(&quot;call_proc&quot;, underlying_javascript_closure(proc =&gt; proc()))
);

const gc_controller = list(
  &quot;begin_garbage_collection&quot;,
    perform(list(op(&quot;call_proc&quot;), reg(&quot;root_populate_proc&quot;))),
    assign(&quot;free&quot;, list(op(&quot;make_ptr_ptr&quot;), constant(0))),
    assign(&quot;scan&quot;, list(op(&quot;make_ptr_ptr&quot;), constant(0))),
    assign(&quot;old&quot;, reg(&quot;root&quot;)),
    assign(&quot;relocate_continue&quot;, label(&quot;reassign_root&quot;)),
    go_to(label(&quot;relocate_old_result_in_new&quot;)),
  &quot;reassign_root&quot;,
    assign(&quot;root&quot;, reg(&quot;new&quot;)),
    go_to(label(&quot;gc_loop&quot;)),
  &quot;gc_loop&quot;,
    test(list(op(&quot;===&quot;), reg(&quot;scan&quot;), reg(&quot;free&quot;))),
    branch(label(&quot;gc_flip&quot;)),
    assign(&quot;old&quot;, list(op(&quot;vector_ref&quot;), reg(&quot;new_heads&quot;), reg(&quot;scan&quot;))),
    assign(&quot;relocate_continue&quot;, label(&quot;update_head&quot;)),
    go_to(label(&quot;relocate_old_result_in_new&quot;)),
  &quot;update_head&quot;,
    perform(list(op(&quot;vector_set&quot;), reg(&quot;new_heads&quot;), reg(&quot;scan&quot;), reg(&quot;new&quot;))),
    assign(&quot;old&quot;, list(op(&quot;vector_ref&quot;), reg(&quot;new_tails&quot;), reg(&quot;scan&quot;))),
    assign(&quot;relocate_continue&quot;, label(&quot;update_tail&quot;)),
    go_to(label(&quot;relocate_old_result_in_new&quot;)),
  &quot;update_tail&quot;,
    perform(list(op(&quot;vector_set&quot;), reg(&quot;new_tails&quot;), reg(&quot;scan&quot;), reg(&quot;new&quot;))),
    assign(&quot;scan&quot;, list(op(&quot;inc_ptr&quot;), reg(&quot;scan&quot;))),
    go_to(label(&quot;gc_loop&quot;)),
  &quot;relocate_old_result_in_new&quot;,
    test(list(op(&quot;is_ptr_ptr&quot;), reg(&quot;old&quot;))),
    branch(label(&quot;gc_pair&quot;)),
    assign(&quot;new&quot;, reg(&quot;old&quot;)),
    go_to(reg(&quot;relocate_continue&quot;)),
  &quot;gc_pair&quot;,
    assign(&quot;oldht&quot;, list(op(&quot;vector_ref&quot;), reg(&quot;the_heads&quot;), reg(&quot;old&quot;))),
    test(list(op(&quot;is_broken_heart_ptr&quot;), reg(&quot;oldht&quot;))),
    branch(label(&quot;already_moved&quot;)),
    assign(&quot;new&quot;, reg(&quot;free&quot;)),
    // new location for pair
    // Update free pointer
    assign(&quot;free&quot;, list(op(&quot;inc_ptr&quot;), reg(&quot;free&quot;))),
    // Copy the head and tail to new memory
    perform(list(op(&quot;vector_set&quot;),
                 reg(&quot;new_heads&quot;), reg(&quot;new&quot;), reg(&quot;oldht&quot;))),
    assign(&quot;oldht&quot;, list(op(&quot;vector_ref&quot;), reg(&quot;the_tails&quot;), reg(&quot;old&quot;))),
    perform(list(op(&quot;vector_set&quot;),
                 reg(&quot;new_tails&quot;), reg(&quot;new&quot;), reg(&quot;oldht&quot;))),
    // Construct the broken heart
    assign(&quot;oldht&quot;, list(op(&quot;make_broken_heart_ptr&quot;))),
    perform(list(op(&quot;vector_set&quot;),
                 reg(&quot;the_heads&quot;), reg(&quot;old&quot;), reg(&quot;oldht&quot;))),
    perform(list(op(&quot;vector_set&quot;),
                 reg(&quot;the_tails&quot;), reg(&quot;old&quot;), reg(&quot;new&quot;))),
    go_to(reg(&quot;relocate_continue&quot;)),
  &quot;already_moved&quot;,
    assign(&quot;new&quot;, list(op(&quot;vector_ref&quot;), reg(&quot;the_tails&quot;), reg(&quot;old&quot;))),
    go_to(reg(&quot;relocate_continue&quot;)),
  &quot;gc_flip&quot;,
    perform(list(op(&quot;call_proc&quot;), reg(&quot;stack_reassign_proc&quot;))),
    assign(&quot;temp&quot;, reg(&quot;the_tails&quot;)),
    assign(&quot;the_tails&quot;, reg(&quot;new_tails&quot;)),
    assign(&quot;new_tails&quot;, reg(&quot;temp&quot;)),
    assign(&quot;temp&quot;, reg(&quot;the_heads&quot;)),
    assign(&quot;the_heads&quot;, reg(&quot;new_heads&quot;)),
    assign(&quot;new_heads&quot;, reg(&quot;temp&quot;)),
    perform(list(op(&quot;call_proc&quot;), reg(&quot;root_restore_proc&quot;))),
    go_to(reg(&quot;continue&quot;))
);

const error_controller = list(
    &quot;error&quot;,
    perform(list(op(&quot;error&quot;), reg(&quot;res&quot;), reg(&quot;err&quot;))),
    go_to(label(&quot;end_evaluation&quot;))
);

const begin_controller =  list(
  &quot;fig_5_14&quot;,
  &quot;pair4&quot;,
    assign(&quot;a&quot;, constant(4)),
    assign(&quot;b&quot;, list(op(&quot;make_null_ptr&quot;))),
    assign(&quot;continue&quot;, label(&quot;garbage1&quot;)),
    go_to(label(&quot;pair&quot;)),
    /// The following creates a garbage
    /// pair (9999, 9999) which will
    /// not affect live object count at
    /// the end of the program. You can
    /// verify by adding more garbage
    /// or remove this line. Or
    /// uncomment the use of
    /// dump_memory() below, before and
    /// after GC.
  &quot;garbage1&quot;,
    assign(&quot;a&quot;, constant(9999)),
    assign(&quot;b&quot;, constant(9999)),
    assign(&quot;continue&quot;, label(&quot;pair2&quot;)),
    go_to(label(&quot;pair&quot;)),
  &quot;pair2&quot;,
    assign(&quot;a&quot;, constant(3)),
    assign(&quot;b&quot;, reg(&quot;res&quot;)),
    assign(&quot;continue&quot;, label(&quot;garbage2&quot;)),
    go_to(label(&quot;pair&quot;)), 
    /// The following creates a garbage
    /// pair (9999, 9999) which will
    /// not affect live object count at
    /// the end of the program. You can
    /// verify by adding more garbage
    /// or remove this line. Or
    /// uncomment the use of
    /// dump_memory() below, before and
    /// after GC.
  &quot;garbage2&quot;,
    assign(&quot;a&quot;, constant(9999)),
    assign(&quot;b&quot;, constant(9999)),
    assign(&quot;continue&quot;, label(&quot;pair7&quot;)),
    go_to(label(&quot;pair&quot;)),
  &quot;pair7&quot;,
    assign(&quot;temp&quot;, reg(&quot;res&quot;)),
    assign(&quot;a&quot;, constant(2)),
    assign(&quot;b&quot;, list(op(&quot;make_null_ptr&quot;))),
    assign(&quot;continue&quot;, label(&quot;pair5&quot;)),
    go_to(label(&quot;pair&quot;)),
  &quot;pair5&quot;,
    assign(&quot;a&quot;, constant(1)),
    assign(&quot;b&quot;, reg(&quot;res&quot;)),
    assign(&quot;continue&quot;, label(&quot;pair1&quot;)),
    go_to(label(&quot;pair&quot;)),
  &quot;pair1&quot;,
    assign(&quot;a&quot;, reg(&quot;res&quot;)),
    assign(&quot;b&quot;, reg(&quot;temp&quot;)),
    assign(&quot;continue&quot;, label(&quot;done&quot;)),
    go_to(label(&quot;pair&quot;)),
  &quot;done&quot;,
    // dump_memory(), // uncomment to get a dump of heads and tails vectors
    assign(&quot;continue&quot;, label(&quot;after_gc&quot;)),
    go_to(label(&quot;begin_garbage_collection&quot;)),
  &quot;after_gc&quot;,
    // dump_memory(), // uncomment to get a dump of heads and tails vectors
    go_to(label(&quot;end_evaluation&quot;)));

const end_controller = list(
    &quot;end_evaluation&quot;
);

const ops = accumulate(append, null, list(
    vector_ops,
    ptr_ops,
    gc_ops,
    primitive_ops
));

const controller = accumulate(append, null, list(
    begin_controller,
    pair_controller,
    gc_controller,
    error_controller,
    end_controller
));

function make_evaluator_machine(size) {
    const evaluator_machine = make_machine(null, ops, controller);
    set_register_contents(evaluator_machine, &quot;SIZE&quot;, wrap_ptr(size));
    return evaluator_machine;
}

const evaluator_machine = make_evaluator_machine(10000);

set_register_contents(evaluator_machine, &quot;a&quot;, wrap_ptr(206));
set_register_contents(evaluator_machine, &quot;b&quot;, wrap_ptr(40));

start(evaluator_machine);
get_register_contents(evaluator_machine, &quot;free&quot;);
// [ &apos;ptr&apos;, 108 ] The number of live objects in the program at termination
      </JAVASCRIPT_RUN>      
      <EXPECTED>[ &apos;ptr&apos;, 108 ]</EXPECTED>
      <JAVASCRIPT>
&quot;gc_flip&quot;,
  assign(&quot;temp&quot;, reg(&quot;the_tails&quot;)),
  assign(&quot;the_tails&quot;, reg(&quot;new_tails&quot;)),
  assign(&quot;new_tails&quot;, reg(&quot;temp&quot;)),
  assign(&quot;temp&quot;, reg(&quot;the_heads&quot;)),
  assign(&quot;the_heads&quot;, reg(&quot;new_heads&quot;)),
  assign(&quot;new_heads&quot;, reg(&quot;temp&quot;))
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <INDEX>list-structured memory<CLOSE></CLOSE></INDEX><!-- Error occurred while translating this section -->
  <INDEX>memory<SUBINDEX>list-structured<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>garbage collection<CLOSE></CLOSE></INDEX><!-- Error occurred while translating this section -->
  <INDEX>stop-and-copy garbage collector<CLOSE></CLOSE></INDEX><!-- Error occurred while translating this section -->
  <INDEX>garbage collector<SUBINDEX>stop-and-copy<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  
  <DO_BREAK_PAGE></DO_BREAK_PAGE><!-- Error occurred while translating this section -->
</SUBSECTION>
