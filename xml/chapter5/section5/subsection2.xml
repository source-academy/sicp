<SUBSECTION>
  <NAME>
    Compiling
    <SPLITINLINE>
      <SCHEME>Expressions</SCHEME>
      <PYTHON>Components</PYTHON>
    </SPLITINLINE>
  </NAME>

  <LABEL NAME="sec:compiling-components"/>
  <TEXT>
    In this section and the next we implement the code generators to which the
    <SCHEMEINLINE>compile</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    dispatches.
  </TEXT>

  <SUBHEADING>
    <NAME>Compiling linkage code</NAME>
  </SUBHEADING>

  <TEXT>
    In general, the output of each code generator will end with
    instructions<EMDASH/>generated by the
    <INDEX>compiler for JavaScript<SUBINDEX>linkage code</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-linkage</SCHEMEINLINE><EMDASH/>that</SCHEME>
      <PYTHON>
	<PYTHONINLINE>compile_linkage</PYTHONINLINE><EMDASH/>that
      </PYTHON>
    </SPLITINLINE>
    implement the required linkage.  If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>"return"</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    then
    we must generate the instruction
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE>.</SCHEME>
      <PYTHON><PYTHONINLINE>go_to(reg("continue"))</PYTHONINLINE>.
      </PYTHON>
    </SPLITINLINE>
    This needs the <SCHEMEINLINE>continue</SCHEMEINLINE> register and does not
    modify any registers.
    If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>"next"</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    then we needn<APOS/>t include any additional instructions.  Otherwise, the
    linkage is a label, and we generate a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>go_to</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    to that label, an instruction that does not need or modify
    any registers.<SPLITINLINE><SCHEME><FOOTNOTE>This procedure
    uses a feature of Lisp called
    <INDEX>list(s)<SUBINDEX>backquote with</SUBINDEX></INDEX>
    <INDEX>backquote</INDEX>
    <INDEX>quasiquote</INDEX>
    <INDEX><USE>`</USE> (backquote)</INDEX>
    <INDEX><USE>,</USE> (comma, used with backquote)</INDEX>
    <INDEX>comma, used with backquote</INDEX>
    <EM>backquote</EM> (or <EM>quasiquote</EM>) that is handy for constructing
    lists. Preceding a list with a backquote symbol is much like quoting it,
    except that anything in the list that is flagged with a comma is
    evaluated.
    <P/>
    For example, if the value of <SCHEMEINLINE>linkage</SCHEMEINLINE> is the
    symbol <SCHEMEINLINE>branch25</SCHEMEINLINE>,
    then the expression
    <SCHEMEINLINE>`((goto (label ,linkage)))</SCHEMEINLINE>
    evaluates to the list
    <SCHEMEINLINE>((goto (label branch25)))</SCHEMEINLINE>.
    Similarly, if the value of <SCHEMEINLINE>x</SCHEMEINLINE> is the list
    <SCHEMEINLINE>(a b c)</SCHEMEINLINE>,
    then
    <SCHEMEINLINE>`(1 2 ,x)</SCHEMEINLINE>
    evaluates to the list
    <SCHEMEINLINE>(1 2 a)</SCHEMEINLINE>.</FOOTNOTE></SCHEME></SPLITINLINE>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_linkage</DECLARATION></INDEX>
      <NAME>compile_linkage</NAME>
      <SCHEME>
(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
          '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
          `((goto (label ,linkage)))))))
      </SCHEME>
      <PYTHON>
function compile_linkage(linkage) {
    return linkage === "return"
           ? make_instruction_sequence(list("continue"), null,
                                       list(go_to(reg("continue"))))
           : linkage === "next"
           ? make_instruction_sequence(null, null, null)
           : make_instruction_sequence(null, null, 
                                       list(go_to(label(linkage))));
}
      </PYTHON>
    </SNIPPET>
    The linkage code is appended to an instruction sequence by
    <SCHEMEINLINE>preserving</SCHEMEINLINE> the
    <SCHEMEINLINE>continue</SCHEMEINLINE> register, since a
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>"return"</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    linkage will
    require the <SCHEMEINLINE>continue</SCHEMEINLINE> register:
    If the given instruction sequence modifies
    <SCHEMEINLINE>continue</SCHEMEINLINE> and the linkage code needs it,
    <SCHEMEINLINE>continue</SCHEMEINLINE> will be saved and restored.
    <SNIPPET EVAL="no" POSTPADDING="no">
      <INDEX><DECLARATION>end_with_linkage</DECLARATION></INDEX>
      <NAME>end_with_linkage</NAME>
      <SCHEME>
(define (end-with-linkage linkage instruction-sequence)
  (preserving '(continue)
   instruction-sequence
   (compile-linkage linkage)))
      </SCHEME>
      <PYTHON>
function end_with_linkage(linkage, instruction_sequence) {
    return preserving(list("continue"),
                      instruction_sequence,
                      compile_linkage(linkage));
}
      </PYTHON>
    </SNIPPET>
  </TEXT>

  <DO_BREAK_PAGE/>
  <SUBHEADING>
    <NAME>Compiling simple
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <PYTHON>
	components
      </PYTHON>
    </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    The code generators for
    <INDEX>compiler for JavaScript<SUBINDEX>literals</SUBINDEX></INDEX>
    <INDEX>compiler for JavaScript<SUBINDEX>names</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>self-evaluating expressions, quotations, and variables</SCHEME>
      <PYTHON>literal expressions and names</PYTHON>
    </SPLITINLINE>
    construct instruction
    sequences that assign the required value to the target register
    and then proceed as specified by the linkage descriptor.
  </TEXT>
  <SPLIT>
    <PYTHON>
      <TEXT>
        The literal value is extracted at compile time from the component being
        compiled and put into the constant part of the
        <PYTHONINLINE>assign</PYTHONINLINE> instruction. For a name, an
        instruction is generated to use the
        <PYTHONINLINE>lookup_symbol_value</PYTHONINLINE> operation when
        the compiled program is run, to look up the value associated with a
        symbol in the current environment. Like a literal value, the symbol is
        extracted at compile time from the component being compiled. Thus
        <PYTHONINLINE>symbol_of_name(component)</PYTHONINLINE> is
        executed only once, when the program is being compiled, and the symbol
        appears as a constant in the
        <PYTHONINLINE>assign</PYTHONINLINE> instruction.
      </TEXT>
    </PYTHON>
  </SPLIT>
  <TEXT>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_literal</DECLARATION></INDEX>
      <INDEX><DECLARATION>compile_name</DECLARATION></INDEX>
      <NAME>compile_literal</NAME>
      <SCHEME>
(define (compile-self-evaluating exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,exp))))))

(define (compile-quoted exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,(text-of-quotation exp)))))))

(define (compile-variable exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '(env) (list target)
    `((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
      </SCHEME>
      <PYTHON>
function compile_literal(component, target, linkage) {
    const literal = literal_value(component);
    return end_with_linkage(linkage,
               make_instruction_sequence(null, list(target),
                   list(assign(target, constant(literal)))));
}
function compile_name(component, target, linkage) {
    const symbol = symbol_of_name(component);
    return end_with_linkage(linkage,
               make_instruction_sequence(list("env"), list(target),
                   list(assign(target,
                               list(op("lookup_symbol_value"),
                                    constant(symbol),
                                    reg("env"))))));
}
      </PYTHON>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME>All these</SCHEME>
      <PYTHON>These</PYTHON>
    </SPLITINLINE>
    assignment instructions modify the target register,
    and the one that looks up a
    <SPLITINLINE>
      <SCHEME>
	variable
      </SCHEME>
      <PYTHON>
	symbol
      </PYTHON>
    </SPLITINLINE>
    needs the <SCHEMEINLINE>env</SCHEMEINLINE> register.
  </TEXT>

  <TEXT>
    Assignments and
    <INDEX>compiler for JavaScript<SUBINDEX>assignments</SUBINDEX></INDEX>
    <INDEX>compiler for JavaScript<SUBINDEX>declarations</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>definitions</SCHEME>
      <PYTHON>declarations</PYTHON>
    </SPLITINLINE>
    are handled much as they are in the
    interpreter.
    <SPLITINLINE>
      <SCHEME>
        We recursively generate code that computes the value to be
        assigned to the variable, and append to it a
        two-instruction sequence that actually sets or defines the
        variable and assigns the value of the whole expression
        (the symbol <SCHEMEINLINE>ok</SCHEMEINLINE>) to the target
        register. The recursive compilation has target
        <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
        <SCHEMEINLINE>next</SCHEMEINLINE> so that the code will
        put its result into <SCHEMEINLINE>val</SCHEMEINLINE> and
        continue with the code that is appended after it. The
        appending is done preserving
        <SCHEMEINLINE>env</SCHEMEINLINE>, since the environment is
        needed for setting or defining the variable and the code
        for the variable value could be the compilation of a
        complex expression that might modify the registers in
        arbitrary ways.
      </SCHEME>
      <PYTHON>
        The function <PYTHONINLINE>compile_assignment_declaration</PYTHONINLINE>
        recursively generates code that computes the value to be
        associated with the symbol and appends to it a two-instruction
        sequence that updates the value associated with the symbol
        in the environment and assigns the value of the whole component
        <!-- (the <PYTHONINLINE>final_value</PYTHONINLINE>) --> <!-- FIXME PAGINATION: can be restored if final_value is visible on this page -->
 (the assigned value for an assignment or <PYTHONINLINE>undefined</PYTHONINLINE> for a declaration) 
        to the target register. 
        <!-- For an assignment, the <PYTHONINLINE>final_value</PYTHONINLINE> is the -->
        <!-- assigned value, and for a declaration it is <PYTHONINLINE>undefined</PYTHONINLINE>. -->
        
        The recursive compilation has target
        <PYTHONINLINE>val</PYTHONINLINE> and linkage
        <PYTHONINLINE>"next"</PYTHONINLINE> so that the code
        will put its result into <PYTHONINLINE>val</PYTHONINLINE>
        and continue with the code that is appended after it. The
        appending is done preserving <PYTHONINLINE>env</PYTHONINLINE>,
        since the environment is needed for updating the symbol<ENDASH/>value
        association and the code for computing the value could be the compilation
        of a complex expression that might modify the registers in
        arbitrary ways.
      </PYTHON>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_assignment</DECLARATION></INDEX>
      <INDEX><DECLARATION>compile_declaration</DECLARATION></INDEX>
      <NAME>compile_assignment</NAME>
      <SCHEME>
(define (compile-assignment exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))

(define (compile-definition exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op define-variable!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
      </SCHEME>
      <PYTHON>
function compile_assignment(component, target, linkage) {
    return compile_assignment_declaration(
               assignment_symbol(component),
               assignment_value_expression(component),
               reg("val"),
               target, linkage);
}
<ALLOW_BREAK/>
function compile_declaration(component, target, linkage) {
    return compile_assignment_declaration(
               declaration_symbol(component),
               declaration_value_expression(component),
               constant(undefined),
               target, linkage);
}
function compile_assignment_declaration(
             symbol, value_expression, final_value,
             target, linkage) {
    const get_value_code = compile(value_expression, "val", "next");
    return end_with_linkage(linkage,
               preserving(list("env"),
                   get_value_code,
                   make_instruction_sequence(list("env", "val"),
                                             list(target),
                       list(perform(list(op("assign_symbol_value"),
                                         constant(symbol),
                                         reg("val"),
                                         reg("env"))),
                            assign(target, final_value)))));
}
      </PYTHON>
    </SNIPPET>
    The appended two-instruction sequence requires
    <SCHEMEINLINE>env</SCHEMEINLINE> and <SCHEMEINLINE>val</SCHEMEINLINE>
    and modifies the target.  Note that although we preserve
    <SCHEMEINLINE>env</SCHEMEINLINE> for this sequence, we do not preserve
    <SCHEMEINLINE>val</SCHEMEINLINE>, because the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-value-code</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>get_value_code</PYTHONINLINE> 
      </PYTHON>
    </SPLITINLINE>
    is designed to explicitly place its result in
    <SCHEMEINLINE>val</SCHEMEINLINE> for use by this sequence.
    (In fact, if we did preserve <SCHEMEINLINE>val</SCHEMEINLINE>, we would
    have a bug, because this would cause the previous contents of
    <SCHEMEINLINE>val</SCHEMEINLINE> to be restored right after the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-value-code</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>get_value_code</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    is run.)
  </TEXT>

  <SHORT_PAGE lines="3"/>
  <SUBHEADING>
    <NAME>Compiling
    <SPLITINLINE>
      <SCHEME>
        conditional expressions
      </SCHEME>
      <PYTHON>
        conditionals
      </PYTHON>
    </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    The code for
    <INDEX>compiler for JavaScript<SUBINDEX>conditionals</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	an <SCHEMEINLINE>if expression</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	a conditional
      </PYTHON>
    </SPLITINLINE>
    compiled with a given target and linkage has the form
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
 $\langle compilation\ of\ predicate,\ target$ val$,\ linkage$ next$\rangle$
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 $\langle compilation\ of\ consequent\ with\ given\ target\ and\ given\ linkage or$ after-if$\rangle$
false-branch
 $\langle compilation\ of\ alternative\ with\ given\ target\ and\ linkage\rangle$
after-if
      </SCHEME>
      <PYTHON LATEX="yes">
<METAPHRASE>compilation of predicate, target <PYTHONINLINE>val</PYTHONINLINE>, linkage <PYTHONINLINE>"next"</PYTHONINLINE></METAPHRASE>
  test(list(op("is_falsy"), reg("val"))),
  branch(label("false_branch")),
"true_branch",
  <METAPHRASE>compilation of consequent with given target and given linkage or <PYTHONINLINE>after_cond</PYTHONINLINE></METAPHRASE>
"false_branch",
  <METAPHRASE>compilation of alternative with given target and linkage</METAPHRASE>
"after_cond"
      </PYTHON>
    </SNIPPET>
  </TEXT>

  <TEXT>
    To generate this code, we compile the predicate, consequent,
    and alternative, and combine the resulting code with instructions
    to test the predicate result and with newly generated labels to mark the
    true and false branches and the end of the
    conditional.<FOOTNOTE>We can<APOS/>t just use the labels
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>true-branch</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>true_branch</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>false-branch</SCHEMEINLINE>,</SCHEME>
      <PYTHON><PYTHONINLINE>false_branch</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>after-if</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>after_cond</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    as shown above, because there might be more than one
    <SPLITINLINE><SCHEME><SCHEMEINLINE>if</SCHEMEINLINE></SCHEME><PYTHON>conditional</PYTHON></SPLITINLINE>
    in the program.
    <INDEX>compiler for JavaScript<SUBINDEX>label generation</SUBINDEX></INDEX>
    The compiler uses the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-label</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_label</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    to generate labels.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-label</SCHEMEINLINE></SCHEME>
      <PYTHON>
	The function
	<PYTHONINLINE>make_label</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    takes a <SPLITINLINE><SCHEME>symbol</SCHEME><PYTHON>string</PYTHON></SPLITINLINE> as argument and returns a new
    <SPLITINLINE><SCHEME>symbol</SCHEME><PYTHON>string</PYTHON></SPLITINLINE> that begins with the
    given <SPLITINLINE><SCHEME>symbol</SCHEME><PYTHON>string</PYTHON></SPLITINLINE>.  For example, successive calls to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(make-label 'a)</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_label("a")</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    would return
    <SPLITINLINE><SCHEME><SCHEMEINLINE>a1</SCHEMEINLINE></SCHEME><PYTHON><PYTHONINLINE>"a1"</PYTHONINLINE></PYTHON></SPLITINLINE>,
    <SPLITINLINE><SCHEME><SCHEMEINLINE>a2</SCHEMEINLINE></SCHEME><PYTHON><PYTHONINLINE>"a2"</PYTHONINLINE></PYTHON></SPLITINLINE>,
    and so on.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-label</SCHEMEINLINE></SCHEME>
      <PYTHON>
	The function
	<PYTHONINLINE>make_label</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE><SPLITINLINE>
      <SCHEME>
	<INDEX>character strings<SUBINDEX>primitive procedures for</SUBINDEX></INDEX>
      </SCHEME>
    </SPLITINLINE>
    can be implemented similarly to the generation of unique variable names in
    the query language, as follows:<!--
 --><SNIPPET EVAL="no">
      <INDEX><DECLARATION>make_label</DECLARATION></INDEX>
      <NAME>make_label</NAME>
      <SCHEME>
(define label-counter 0)

(define (new-label-number)
  (set! label-counter (+ 1 label-counter))
  label-counter)

(define (make-label name)
  (string-&gt;symbol
    (string-append (symbol-&gt;string name)
                   (number-&gt;string (new-label-number)))))
      </SCHEME>
      <PYTHON>
let label_counter = 0;
<SHORT_SPACE/>
function new_label_number() {
    label_counter = label_counter + 1;
    return label_counter;
}
function make_label(string) {
    return string + stringify(new_label_number());
}
      </PYTHON>
    </SNIPPET></FOOTNOTE>
    In this arrangement of code, we must branch around the true branch
    if the test is false.  The only slight complication is in how the
    linkage for the true branch should be handled.  If the linkage for the
    conditional is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>"return"</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    or a label, then the
    true and false branches will both use this same linkage.  If the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>"next"</PYTHONINLINE>,
      </PYTHON>
    </SPLITINLINE>
    the true branch ends with a jump around
    the code for the false branch to the label at the end of the conditional.
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>compile_conditional</DECLARATION></INDEX>
      <NAME>compile_conditional</NAME>
      <SCHEME>
(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
         p-code
         (append-instruction-sequences
          (make-instruction-sequence '(val) '()
           `((test (op false?) (reg val))
             (branch (label ,f-branch))))
          (parallel-instruction-sequences
           (append-instruction-sequences t-branch c-code)
           (append-instruction-sequences f-branch a-code))
          after-if))))))
      </SCHEME>
      <PYTHON>
function compile_conditional(component, target, linkage) {
    const t_branch = make_label("true_branch");
    const f_branch = make_label("false_branch");
    const after_cond = make_label("after_cond");
    const consequent_linkage =
            linkage === "next" ? after_cond : linkage;
    const p_code = compile(conditional_predicate(component),
                           "val", "next");
    const c_code = compile(conditional_consequent(component),
                           target, consequent_linkage);
    const a_code = compile(conditional_alternative(component),
                           target, linkage);
    return preserving(list("env", "continue"),
             p_code,
             append_instruction_sequences(
               make_instruction_sequence(list("val"), null,
                 list(test(list(op("is_falsy"), reg("val"))),
                      branch(label(f_branch)))),
               append_instruction_sequences(
                 parallel_instruction_sequences(
                   append_instruction_sequences(t_branch, c_code),
                   append_instruction_sequences(f_branch, a_code)),
                 after_cond)));
}
      </PYTHON>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Env</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
        <PDF_ONLY>\newpage\noindent </PDF_ONLY>
	      The <SCHEMEINLINE>env</SCHEMEINLINE> register
      </PYTHON>
    </SPLITINLINE>
    is preserved around the predicate code
    because it could be needed by the true and false 
      branches, and <SCHEMEINLINE>continue</SCHEMEINLINE> is preserved because it could
    be needed by the linkage code in those branches.
  The code for the true and
    false branches (which are not executed sequentially) is appended using a
    special combiner
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>parallel-instruction-sequences</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>parallel_instruction_sequences</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    described in
    section<SPACE/><REF NAME="sec:combining-instruction-sequences"/>.
  </TEXT>

  <SPLIT>
    <SCHEME>
      <TEXT>
	Note that <SCHEMEINLINE>cond</SCHEMEINLINE> is a derived expression,
	so all that the compiler needs to do to handle it is to apply the
	<SCHEMEINLINE>cond-&gt;if</SCHEMEINLINE> transformer
	(from section<SPACE/><REF NAME="sec:representing-expressions"/>) and
	compile the resulting <SCHEMEINLINE>if</SCHEMEINLINE> expression.
      </TEXT>
    </SCHEME>
  </SPLIT>

  <SUBHEADING>
    <NAME>Compiling sequences</NAME>
  </SUBHEADING>

  <TEXT>
    The compilation of
    <INDEX>compiler for JavaScript<SUBINDEX>sequences of statements</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
        sequences (from procedure bodies or explicit <SCHEMEINLINE>begin</SCHEMEINLINE>
	expressions)
	parallels their evaluation.
      </SCHEME>
      <PYTHON>
        statement sequences
	parallels their evaluation
	in the explicit-control evaluator with one exception:
  If a return statement appears anywhere in a sequence, we treat
  it as if it were the last statement.
      </PYTHON>
    </SPLITINLINE>
    Each
    <SPLITINLINE>
      <SCHEME>
        expression
      </SCHEME>
      <PYTHON>
        statement
      </PYTHON>
    </SPLITINLINE>
    of the sequence is compiled<EMDASH/>the last
    <SPLITINLINE>
      <SCHEME>
        expression
      </SCHEME>
      <PYTHON>
        statement (or a return statement)
      </PYTHON>
    </SPLITINLINE>
    with
    the linkage specified for the sequence, and the other
    <SPLITINLINE>
      <SCHEME>
        expressions
      </SCHEME>
      <PYTHON>
        statements
      </PYTHON>
    </SPLITINLINE>
    with
    linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>"next"</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    (to execute the rest of the
    sequence). The instruction sequences for the individual
    <SPLITINLINE>
      <SCHEME>
        expressions
      </SCHEME>
      <PYTHON>
        statements
      </PYTHON>
    </SPLITINLINE>
    are
    appended to form a single instruction sequence, such that
    <SCHEMEINLINE>env</SCHEMEINLINE> (needed for the rest of the
    sequence)<SPLITINLINE>
    <SCHEME>
      and <SCHEMEINLINE>continue</SCHEMEINLINE> (possibly needed
      for the linkage at the end of the sequence) are 
      preserved.
    </SCHEME>
    <PYTHON>
      and <SCHEMEINLINE>continue</SCHEMEINLINE> (possibly needed
      for the linkage at the end of the sequence)
      are preserved.<FOOTNOTE>
The <PYTHONINLINE>continue</PYTHONINLINE> register would
be needed for a <PYTHONINLINE>"return"</PYTHONINLINE>
linkage, which can result from a compilation by
<PYTHONINLINE>compile_and_go</PYTHONINLINE>
(section<SPACE/><REF NAME="sec:interfacing-compiled-code"/>).
    </FOOTNOTE>
    </PYTHON>
  </SPLITINLINE>
  <SNIPPET EVAL="no">
    <INDEX><DECLARATION>compile_sequence</DECLARATION></INDEX>
    <NAME>compile_sequence</NAME>
    <SCHEME>
(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
       (compile (first-exp seq) target 'next)
       (compile-sequence (rest-exps seq) target linkage))))
    </SCHEME>
    <PYTHON>
function compile_sequence(seq, target, linkage) {
    return is_empty_sequence(seq)
           ? compile_literal(make_literal(undefined), target, linkage)
           : is_last_statement(seq) ||
                 is_return_statement(first_statement(seq))
           ? compile(first_statement(seq), target, linkage)
           : preserving(list("env", "continue"),
                 compile(first_statement(seq), target, "next"),
                 compile_sequence(rest_statements(seq), 
                                  target, linkage));
}
    </PYTHON>
  </SNIPPET>
  <SPLIT>
    <PYTHON>
      Treating a return statement as if it were the last statement in a sequence
      avoids compiling any <QUOTE>dead code</QUOTE> after the return statement that can
      never be executed.
      Removing the <PYTHONINLINE>is_return_statement</PYTHONINLINE> check does not change the behavior
      of the object program; however,
      there are many reasons not to compile dead code, which are beyond the scope of this book
      (security, compilation time, size of the object code, etc.),
      and many compilers give warnings for dead code.<FOOTNOTE>Our compiler does not detect all dead code. For example,
      a conditional statement whose consequent and alternative branches both end in a return
      statement will not stop subsequent statements from being compiled. See
      exercises<SPACE/><REF NAME="ex:dead-code"/> and <REF NAME="ex:append_return_undefined"/>.
      <LABEL NAME="foot:dead-code"/></FOOTNOTE>
    </PYTHON>
  </SPLIT>
  </TEXT>

  <LONG_PAGE lines="3"/>
  <SPLIT>
    <PYTHON>
      <!-- FIXME: This SPLIT.PYTHON contains a lot of SCHEME. Remove. -->
      <SUBHEADING>
	<NAME>
	  Compiling blocks
	</NAME>
      </SUBHEADING>

      <TEXT>
	A
	<INDEX>compiler for JavaScript<SUBINDEX>blocks</SUBINDEX></INDEX>
	block is compiled by prepending an <PYTHONINLINE>assign</PYTHONINLINE> instruction to the compiled
	body of the block. The assignment extends the current environment by a frame
	that binds the names declared in the block to the value
	<PYTHONINLINE>"*unassigned*"</PYTHONINLINE>. This operation
	both needs and modifies the <PYTHONINLINE>env</PYTHONINLINE> register.
	<SNIPPET EVAL="no" POSTPADDING="no">
          <INDEX><DECLARATION>compile_block</DECLARATION></INDEX>
          <INDEX>scanning out declarations<SUBINDEX>in compiler</SUBINDEX></INDEX>
	  <NAME>compile_block</NAME>
	  <PYTHON>
function compile_block(stmt, target, linkage) {
    const body = block_body(stmt);
    const locals = scan_out_declarations(body);
    const unassigneds = list_of_unassigned(locals);
    return append_instruction_sequences(
               make_instruction_sequence(list("env"), list("env"),
                   list(assign("env", list(op("extend_environment"),
                                           constant(locals),
                                           constant(unassigneds),
                                           reg("env"))))),
               compile(body, target, linkage));
}
	  </PYTHON>
	</SNIPPET>
      </TEXT>
    </PYTHON>
  </SPLIT>

  <SUBHEADING>
	<NAME>Compiling
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>lambda</SCHEMEINLINE>
	  </SCHEME>
	  <PYTHON>
	    lambda
	  </PYTHON>
	</SPLITINLINE>
	expressions</NAME>
      </SUBHEADING>

      <TEXT>
	Lambda expressions
	<INDEX>compiler for JavaScript<SUBINDEX>lambda expressions</SUBINDEX></INDEX>
	construct
	<SPLITINLINE>
	  <SCHEME>procedures.</SCHEME>
	  <PYTHON>functions.</PYTHON>
	</SPLITINLINE>
	The object code for a lambda expression must have the form
	<SNIPPET EVAL="no" LATEX="yes">
	  <SCHEME>
$\langle construct\ procedure\ object\ and\ assign\ it\ to\ target\ register\rangle$
$\langle linkage\rangle$
	  </SCHEME>
	  <PYTHON>
<METAPHRASE>construct function object and assign it to target register</METAPHRASE>
<METAPHRASE>linkage</METAPHRASE>
	  </PYTHON>
	</SNIPPET>
	When we compile the lambda expression, we also generate the code for the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	body. Although the body won<APOS/>t be executed at the time of
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	construction, it is convenient to insert it into the object code right after
	the code for the
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE>.</SCHEME>
	  <PYTHON>lambda expression.</PYTHON>
	</SPLITINLINE>
	If the linkage for the lambda expression is a label or
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>return</SCHEMEINLINE>,
	  </SCHEME>
	  <PYTHON>
	    <PYTHONINLINE>"return"</PYTHONINLINE>,
	  </PYTHON>
	</SPLITINLINE>
	this is fine.  But if the linkage is
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>next</SCHEMEINLINE>,
	  </SCHEME>
	  <PYTHON>
	    <PYTHONINLINE>"next"</PYTHONINLINE>,
	  </PYTHON>
	</SPLITINLINE>
	we will need to skip around the code for
	the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	body by using a linkage that jumps to a label that is inserted after the
	body.  The object code thus has the form
	<SNIPPET EVAL="no" LATEX="yes">
	  <SCHEME>
 $\langle construct\ procedure\ object\ and\ assign\ it\ to\ target\ register\rangle$
 $\langle code\ for\ given\ linkage\rangle\ or$ (goto (label after-lambda))
 $\langle compilation\ of\ procedure\ body\rangle$
after-lambda
	  </SCHEME>
	  <PYTHON>
<METAPHRASE>construct function object and assign it to target register</METAPHRASE>
<METAPHRASE>code for given linkage</METAPHRASE> <META>or</META> go_to(label("after_lambda"))
<METAPHRASE>compilation of function body</METAPHRASE>
"after_lambda"
	  </PYTHON>
	</SNIPPET>
      </TEXT>

      <TEXT>
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>Compile-lambda</SCHEMEINLINE>
	  </SCHEME>
	  <PYTHON>
	    The function
	  <PYTHONINLINE>compile_lambda_expression</PYTHONINLINE></PYTHON>
	</SPLITINLINE>
	generates the code for constructing the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	object followed by the code for the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	body. The
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	object will be constructed at run time by combining the current environment
	(the environment at the point of <SPLITINLINE><SCHEME>definition</SCHEME><PYTHON>declaration</PYTHON></SPLITINLINE>) with the entry point to the
	compiled
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	body (a newly generated label).<FOOTNOTE>We need machine operations to
	implement a data structure for representing compiled
	<SPLITINLINE>
	  <SCHEME>procedures,</SCHEME>
	  <PYTHON>functions,</PYTHON>
	</SPLITINLINE>
	analogous to the structure for compound
	<SPLITINLINE>
	  <SCHEME>procedures</SCHEME>
	  <PYTHON>functions</PYTHON>
	</SPLITINLINE>
	described in section<SPACE/><REF NAME="sec:eval-data-structures"/>:
	<SNIPPET EVAL="no" POSTPADDING="no">
	  <INDEX><DECLARATION>make_compiled_function</DECLARATION></INDEX>
	  <INDEX><DECLARATION>is_compiled_function</DECLARATION></INDEX>
	  <INDEX><DECLARATION>compiled_function_entry</DECLARATION></INDEX>
	  <INDEX><DECLARATION>compiled_function_env</DECLARATION></INDEX>
	  <NAME>make_compiled_function</NAME>
	  <SCHEME>
(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))

(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))

(define (compiled-procedure-entry c-proc) (cadr c-proc))

(define (compiled-procedure-env c-proc) (caddr c-proc))
	  </SCHEME>
	  <PYTHON>
function make_compiled_function(entry, env) {
    return list("compiled_function", entry, env);
}
function is_compiled_function(fun) {
    return is_tagged_list(fun, "compiled_function");
}
function compiled_function_entry(c_fun) {
    return head(tail(c_fun));
}
function compiled_function_env(c_fun) {
    return head(tail(tail(c_fun)));
}
	  </PYTHON>
	</SNIPPET>
	<LABEL NAME="foot:compiler-ops"/></FOOTNOTE>
	<SNIPPET EVAL="no">
	  <INDEX><DECLARATION>compile_lambda_expression</DECLARATION></INDEX>
	  <NAME>compile_lambda</NAME>
	  <SCHEME>
(define (compile-lambda exp target linkage)
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
         (make-instruction-sequence '(env) (list target)
          `((assign ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
	  </SCHEME>
	  <PYTHON>
function compile_lambda_expression(exp, target, linkage) {
    const fun_entry = make_label("entry");
    const after_lambda = make_label("after_lambda");
    const lambda_linkage =
            linkage === "next" ? after_lambda : linkage;
    return append_instruction_sequences(
               tack_on_instruction_sequence(
                   end_with_linkage(lambda_linkage,
                       make_instruction_sequence(list("env"),
                                                 list(target),
                           list(assign(target,
                                    list(op("make_compiled_function"),
                                         label(fun_entry),
                                         reg("env")))))),
                   compile_lambda_body(exp, fun_entry)),
               after_lambda);
}
	  </PYTHON>
	</SNIPPET>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>Compile-lambda</SCHEMEINLINE></SCHEME>
	  <PYTHON>
	    The function
	    <PYTHONINLINE>compile_lambda_expression</PYTHONINLINE>
	  </PYTHON>
	</SPLITINLINE>
	uses the special combiner
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>tack-on-instruction-sequence</SCHEMEINLINE></SCHEME>
	  <PYTHON>
	    <PYTHONINLINE>tack_@on_@instruction_@sequence</PYTHONINLINE>
	  </PYTHON>
	</SPLITINLINE>
	(<SPLITINLINE><PYTHON>from </PYTHON></SPLITINLINE>section<SPACE/><REF NAME="sec:combining-instruction-sequences"/>) rather
	than
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>append-instruction-sequences</SCHEMEINLINE>
	  </SCHEME>
	  <PYTHON>
	    <PYTHONINLINE>append_instruction_@sequences</PYTHONINLINE>
	  </PYTHON>
	</SPLITINLINE>
	to append the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	body to the lambda expression code, because the
	body is not part of the sequence of instructions that will be executed when
	the combined sequence is entered; rather, it is in the sequence only because
	that was a convenient place to put it.
      </TEXT>

      <TEXT>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>Compile-lambda-body</SCHEMEINLINE></SCHEME>
	  <PYTHON>
	    The function
	    <PYTHONINLINE>compile_lambda_body</PYTHONINLINE>
	  </PYTHON>
	</SPLITINLINE>
	constructs the code for the body of the
	<SPLITINLINE>
	  <SCHEME>procedure.</SCHEME>
	  <PYTHON>function.</PYTHON>
	</SPLITINLINE>
	This code begins with a label for the entry point.  Next come instructions
	that will cause the runtime evaluation environment to switch to the correct
	environment for evaluating the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	body<EMDASH/>namely, the
	<SPLITINLINE><SCHEME>definition</SCHEME></SPLITINLINE>
	environment of the
	<SPLITINLINE>
	  <SCHEME>procedure,</SCHEME>
	  <PYTHON>function,</PYTHON>
	</SPLITINLINE>
	extended to include the bindings of the
	<SPLITINLINE>
	  <SCHEME>formal</SCHEME>
	</SPLITINLINE>
	parameters to the arguments
	with which the
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <PYTHON>function</PYTHON>
	</SPLITINLINE>
	is called.  After this comes the code for the
	
	<SPLITINLINE>
	  <SCHEME>
	    sequence of expressions that makes up the
	  </SCHEME>
	</SPLITINLINE>
	<SPLITINLINE>
	  <SCHEME>procedure body.</SCHEME>
	  <PYTHON>
            function body, augmented to ensure that it ends with a return statement.
	  </PYTHON>
	</SPLITINLINE>
	<SPLIT>
	  <SCHEME>
	    The sequence is compiled with linkage return and target
	    <SCHEMEINLINE>val</SCHEMEINLINE> so that it will end by returning from
	    the procedure with the procedure result in
	    <SCHEMEINLINE>val</SCHEMEINLINE>.
	  </SCHEME>
	  <PYTHON>
            The
            augmented body is compiled with target <PYTHONINLINE>val</PYTHONINLINE> so that its return value will be
            placed in <PYTHONINLINE>val</PYTHONINLINE>.  The linkage descriptor passed to this compilation is
            irrelevant, as it will be ignored.<FOOTNOTE>
            The augmented function body is a sequence ending with a return statement.
            Compilation of a sequence of statements
            uses the linkage <PYTHONINLINE>"next"</PYTHONINLINE> for all its component statements except the last,
            for which it uses the given linkage.
            In this case, the last statement is a return statement, and
            as we will see in section<SPACE/><REF NAME="sec:compiling-combinations"/>,
            a return statement always uses the
	    <PYTHONINLINE>"return"</PYTHONINLINE> linkage
	    descriptor for its return expression. Thus all function bodies will end with a
	    <PYTHONINLINE>"return"</PYTHONINLINE>
	    linkage, not the <PYTHONINLINE>"next"</PYTHONINLINE> we
	    pass as the linkage argument to <PYTHONINLINE>compile</PYTHONINLINE> in
	    <PYTHONINLINE>compile_lambda_body</PYTHONINLINE>.</FOOTNOTE>
	    Since a linkage argument is required, we arbitrarily pick <PYTHONINLINE>"next"</PYTHONINLINE>.
	  </PYTHON>
	</SPLIT>
	<SNIPPET EVAL="no">
	  <INDEX><DECLARATION>compile_lambda_body</DECLARATION></INDEX>
	  <NAME>compile_lambda_body</NAME>
	  <REQUIRES>append_return_undefined</REQUIRES>
	  <SCHEME>
(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
	  </SCHEME>
	  <PYTHON>
function compile_lambda_body(exp, fun_entry) {
    const params  = lambda_parameter_symbols(exp);
    return append_instruction_sequences(
        make_instruction_sequence(list("env", "fun", "argl"),
                                  list("env"),
            list(fun_entry,
                 assign("env",
                        list(op("compiled_function_env"),
                             reg("fun"))),
                 assign("env",
                        list(op("extend_environment"),
                             constant(params),
                             reg("argl"),
                             reg("env"))))),
        compile(append_return_undefined(lambda_body(exp)),
                "val", "next"));
}
	  </PYTHON>
	</SNIPPET>
      </TEXT>

      <SPLIT>
	<PYTHON>
	  <TEXT>
	    To ensure that all functions end by executing a return statement,
	    <PYTHONINLINE>compile_@lambda_@body</PYTHONINLINE>
	    appends to the lambda body a return statement whose return expression is the literal
	    <PYTHONINLINE>undefined</PYTHONINLINE>.
	    To do so, it uses the function <PYTHONINLINE>append_@return_@undefined</PYTHONINLINE>,
	    which constructs the parser<APOS/>s tagged-list representation (from section<SPACE/><REF NAME="sec:representing-expressions"/>) of a 
	    sequence consisting of the body and a <PYTHONINLINE>return undefined;</PYTHONINLINE> statement.
	    <SNIPPET EVAL="no">
	      <NAME>append_return_undefined</NAME>
	      <PYTHON>
function append_return_undefined(body) {
    return list("sequence", list(body,
                                 list("return_statement",
                                      list("literal", undefined))));
}
	      </PYTHON>
	    </SNIPPET>
	    This simple transformation of lambda bodies is a third way to ensure that a
	    function that does not return explicitly has the return value
	    <INDEX>return value<SUBINDEX><USE>undefined</USE> as</SUBINDEX></INDEX>
	    <PYTHONINLINE>undefined</PYTHONINLINE>.
	    In the metacircular evaluator, we used a return-value object, which also played a
	    role in stopping a sequence evaluation.
	    In the explicit-control evaluator, functions that did not return explicitly continued
	    to an entry point that stored <PYTHONINLINE>undefined</PYTHONINLINE>
	    in <PYTHONINLINE>val</PYTHONINLINE>.
	    See exercise<SPACE/><REF NAME="ex:append_return_undefined"/> for a more elegant way
	    to handle insertion of return statements.
	    <LABEL NAME="sec:append_return_undefined"/>
	  </TEXT>

      <EXERCISE>
	<LABEL NAME="ex:dead-code"/>
	Footnote<SPACE/><REF NAME="foot:dead-code"/> pointed out that the compiler does not
	identify all instances of
	<INDEX>compiler for JavaScript<SUBINDEX>dead code analysis</SUBINDEX></INDEX>
	dead code. What would be required of a compiler to
	detect all instances of dead code?
	<TEXT>
	  Hint: The answer depends on how we define dead code. One possible (and useful)
	  definition is <QUOTE>code following a return statement in a sequence</QUOTE><EMDASH/>but
	  what about code in the consequent
	  branch of <PYTHONINLINE>if (false) </PYTHONINLINE><LATEXINLINE>$\ldots$</LATEXINLINE> or
	  code following a
	  call to <PYTHONINLINE>run_forever()</PYTHONINLINE> in exercise<SPACE/><REF NAME="ex:halting-theorem"/>?
	</TEXT>
      </EXERCISE>

    <DO_BREAK_PAGE/>
      <EXERCISE>
        The current design of <PYTHONINLINE>append_return_undefined</PYTHONINLINE>
        is a bit crude: It always appends a
        <PYTHONINLINE>return undefined;</PYTHONINLINE> to a lambda body, even if there is already a return statement in every execution
	path of the body. Rewrite
        <PYTHONINLINE>append_return_undefined</PYTHONINLINE> so that it inserts
        <PYTHONINLINE>return undefined;</PYTHONINLINE> at the end of only
	those paths that do not contain a return statement. Test your
        solution on the functions below, substituting any expressions for
        <LATEXINLINE>$e_1$</LATEXINLINE> and
        <LATEXINLINE>$e_2$</LATEXINLINE>
        and any (non-return) statements for
        <LATEXINLINE>$s_1$</LATEXINLINE> and
	<LATEXINLINE>$s_2$</LATEXINLINE>.
        In <PYTHONINLINE>t</PYTHONINLINE>, a return statement should be
	added either at both <PYTHONINLINE>(*)</PYTHONINLINE>'s or just at
	<PYTHONINLINE>(**)</PYTHONINLINE>.
        In <PYTHONINLINE>w</PYTHONINLINE> and
	<PYTHONINLINE>h</PYTHONINLINE>, a return statement should be added
	at one of the <PYTHONINLINE>(*)</PYTHONINLINE>'s.
        In <PYTHONINLINE>m</PYTHONINLINE>, no return statement should be added.
	<SNIPPET EVAL="no" LATEX="yes" POSTPADDING="no">
	  <PYTHON>
function t(b) {   function w(b) {    function m(b) {    function h(b1, b2) {
   if (b) {          if (b) {           if (b) {           if (b1) {
      $s_1~~$              return $e_1;~$         return $e_1;~$         return $e_1$;
      (*)                                                  } else {
   } else {          } else {           } else {              if (b2) {
      $s_2~~$               $s_1~~$               return $e_2$;             $s_1$
      (*)               (*)                                      (*)
   }                 }                  }                     } else {
   (**)              (*)                                         return $e_2$;
}                 }                  }                        }
                                                              (*)
                                                           }
                                                           (*)
                                                        }
	  </PYTHON>
	</SNIPPET>
	<LABEL NAME="ex:append_return_undefined"/>
      </EXERCISE>
	</PYTHON>
      </SPLIT>
</SUBSECTION>
