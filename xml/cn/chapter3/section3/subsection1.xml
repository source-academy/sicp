<SUBSECTION> 
   <NAME>
    可变数据对象 (列表结构)
  </NAME> 

  <LABEL NAME="sec:mutable-list-structure"></LABEL>
   <INDEX>可变数据对象<SUBINDEX>列表结构<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>列表结构<SUBINDEX>可变<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>可变数据对象<SUBINDEX>序对流生成函数<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>序对<SUBINDEX>可变<OPEN></OPEN></SUBINDEX></INDEX> 

   <TEXT>
    基本操作在
    <SPLITINLINE>
      
	序对<EMDASH></EMDASH>cons,
      
      <JAVASCRIPT>
	序对<EMDASH></EMDASH><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      car,
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      cdr<EMDASH></EMDASH>可以
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE><EMDASH></EMDASH>可以
      </JAVASCRIPT>
    </SPLITINLINE>
    用于构建列表结构并从列表结构中选择部分，但它们无法修改列表结构。同样地，我们迄今所用的列表操作，例如append和
    list，因为这些可以用
    <SPLITINLINE>
      cons,
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      car,
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      cdr.
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    要修改列表结构，我们需要新的操作。
  </TEXT> 

  <TEXT> 
    序对的基本修改器是
    <INDEX><USE>set_head</USE> (原语函数)</INDEX>
    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>set_head</USE> (\textit{ns})</SUBINDEX></INDEX>
    <SPLITINLINE>
      set-car!
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <INDEX><USE>set_tail</USE> (原语函数)</INDEX>
    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>set_tail</USE> (\textit{ns})</SUBINDEX></INDEX>
    <SPLITINLINE>
      set-cdr!.
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      Set-car!
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    接受两个参数，第一个必须是序对。它修改这个序对，将
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针替换为指向
    <SPLITINLINE>set-car!<JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>的第二个参数的指针。  <FOOTNOTE>
    <SPLIT>
      
	Set-car! 和
	set-cdr! 返回的是
	特定于实现的
	<INDEX><USE>set-car!</USE> (原语函数)<SUBINDEX>的值</SUBINDEX></INDEX>
	<INDEX>未指定值<SUBINDEX><ORDER>set-car</ORDER>set-car!</SUBINDEX></INDEX>
	<INDEX><USE>set-cdr!</USE> (原语函数)<SUBINDEX>的值</SUBINDEX></INDEX>
	<INDEX>未指定值<SUBINDEX><ORDER>set-cdr</ORDER>set-cdr!</SUBINDEX></INDEX>
	的值。像set!一样，它们应该仅用于其效果。
      
      <JAVASCRIPT>
	函数 <JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE> 返回值
	<JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>。
	<INDEX><USE>set_head</USE> (原语函数)<SUBINDEX>的值</SUBINDEX></INDEX>
	<INDEX><USE>set_tail</USE> (原语函数)<SUBINDEX>的值</SUBINDEX></INDEX>
	它们应该仅用于其效果。
      </JAVASCRIPT>
    </SPLIT></FOOTNOTE>
   </TEXT>

  <TEXT> 
    举例来说，假设
<SCHEMEINLINE>x</SCHEMEINLINE> 被绑定为 
    <SPLITINLINE>
      
	列表为
	((a b) c d)
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>list(list(&quot;a&quot;, &quot;b&quot;), &quot;c&quot;, &quot;d&quot;)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    和 <SCHEMEINLINE>y</SCHEMEINLINE> 绑定到 
    <SPLITINLINE>
      
	列表
	(e f)
      
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;e&quot;, &quot;f&quot;)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    如图所示
    <SPLITINLINE>
      
        图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>.
      
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
    计算表达式
    <SPLITINLINE>
      (set-car! x y)
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>set_head(x, y)</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    修改绑定到的序对  <SCHEMEINLINE>x</SCHEMEINLINE> 被绑定，
    将其
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    替换为  <SCHEMEINLINE>y</SCHEMEINLINE> 。操作的结果显示在
    <SPLITINLINE>
      
        图<SPACE></SPACE><REF NAME="fig:set-car_scheme"></REF>.
      
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:set-car"></REF>.
      </JAVASCRIPT>
    </SPLITINLINE>
    结构  <SCHEMEINLINE>x</SCHEMEINLINE>  已被修改，现在
    <SPLITINLINE>
      
	会被打印为
	((e<SPACE></SPACE>f)<SPACE></SPACE>c<SPACE></SPACE>d)。
      
      <JAVASCRIPT>
	现在等同于
	<JAVASCRIPTINLINE>list(list(&quot;e&quot;, &quot;f&quot;), &quot;c&quot;, &quot;d&quot;)</JAVASCRIPTINLINE>。
    </JAVASCRIPT></SPLITINLINE>
    表示列表的序对
    <SPLITINLINE>
      (a b),
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;a&quot;, &quot;b&quot;)</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    由被替换的指针表示，现在已从原始结构中分离出来。<FOOTNOTE>从中我们可以看到，对列表的修改操作可能会产生不属于任何可访问结构的<QUOTE>垃圾</QUOTE>。我们将在<SPACE></SPACE><REF NAME="sec:gc"></REF>部分看到，
    <SPLITINLINE>
      Lisp
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    内存管理系统包含一个
    <INDEX>垃圾回收<SUBINDEX>突变与</SUBINDEX></INDEX>
    <EM>垃圾回收器</EM>，用于识别并回收不需要的序对所占用的内存空间。</FOOTNOTE>
   </TEXT>

     <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-13.svg"></FIGURE>
          <CAPTION>
	    列表 x:
	    ((a b) c d) 和
	    y: (e f).
          </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-13.svg"></FIGURE>
          <CAPTION>
	    列表 x:
	    <JAVASCRIPTINLINE>list(list(&quot;a&quot;, &quot;b&quot;), &quot;c&quot;, &quot;d&quot;)</JAVASCRIPTINLINE>
	    和 y:
	    <JAVASCRIPTINLINE>list(&quot;e&quot;, &quot;f&quot;)</JAVASCRIPTINLINE>.
          </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT> 
     <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-14.svg"></FIGURE>
          <CAPTION>
	    (set-car! x y) 对图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>中列表的影响。
          </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-14.svg"></FIGURE>
          <CAPTION>
	    <JAVASCRIPTINLINE>set_head(x, y)</JAVASCRIPTINLINE> 对图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>中列表的影响。
          </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT> 
     <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-15.svg"></FIGURE>
          <CAPTION>
	    (define z (cons y (cdr x))) 对图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>中列表的影响。
          </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-15.svg"></FIGURE>
          <CAPTION>
	    <JAVASCRIPTINLINE>const z = pair(y, tail(x));</JAVASCRIPTINLINE> 对图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>中列表的影响。
          </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT> 
     <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-16.svg"></FIGURE>
          <CAPTION>
	    (set-cdr! x y) 对图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>中列表的影响。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-16.svg"></FIGURE>
          <CAPTION>
	    <JAVASCRIPTINLINE>set_tail(x, y)</JAVASCRIPTINLINE> 对图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>中列表的影响。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT> 
  
   <SHORT_PAGE LINES="3"></SHORT_PAGE> 
   <TEXT>
    比较
    <SPLITINLINE>
      
        图<SPACE></SPACE><REF NAME="fig:set-car_scheme"></REF>
      
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:set-car"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      
        图<SPACE></SPACE><REF NAME="fig:list-cons_scheme"></REF>，
      
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:list-cons"></REF>，
      </JAVASCRIPT>
    </SPLITINLINE>
    哪个说明了执行的结果
    
      <NAME>mutable_list_example</NAME>
      
(define x &apos;((a b) c d))
(define y &apos;(e f))
      
      <JAVASCRIPT>
const x = list(list(&quot;a&quot;, &quot;b&quot;), &quot;c&quot;);
const y = list(&quot;e&quot;, &quot;f&quot;);
      </JAVASCRIPT>
    
    
      <REQUIRES>mutable_list_example</REQUIRES>
      
(define z (cons y (cdr x)))
      
      <JAVASCRIPT>
const z = pair(y, tail(x));
      </JAVASCRIPT>
    
    其中x和y绑定到了原始列表
    <SPLITINLINE>
      
        图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>。
      
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>。
      </JAVASCRIPT>
    </SPLITINLINE>
    这个
    <SPLITINLINE>
      
	变量
      
      <JAVASCRIPT>
	名称
      </JAVASCRIPT>
    </SPLITINLINE>
      z 现在绑定到了一个
    由
    <SPLITINLINE>cons
    <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    操作创建的新序对；x绑定的列表未被改变。
  </TEXT> 

  <TEXT> 
    <SPLITINLINE>
      set-cdr!
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    操作与
    <SPLITINLINE>
      set-car!.
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    类似。唯一的区别是
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针而不是
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针被替换。执行
    <SPLITINLINE>
      (set-cdr! x y)
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail(x, y)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    在
    <SPLITINLINE>
      
        图<SPACE></SPACE><REF NAME="fig:two-lists_scheme"></REF>
      
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:two-lists"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    列表上的效果显示在
    <SPLITINLINE>
      
        图<SPACE></SPACE><REF NAME="fig:set-cdr_scheme"></REF>。
      
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:set-cdr"></REF>。
      </JAVASCRIPT>
    </SPLITINLINE>
    这里
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针
     <SCHEMEINLINE>x</SCHEMEINLINE>  被替换为指向
    <SPLITINLINE>
      (e f)。
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;e&quot;, &quot;f&quot;)</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLITINLINE>
    同时，列表
    <SPLITINLINE>
      (c d)，
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;c&quot;, &quot;d&quot;)</JAVASCRIPTINLINE>，
      </JAVASCRIPT>
    </SPLITINLINE>
    曾是
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    的  <SCHEMEINLINE>x</SCHEMEINLINE> ，现在从结构中分离出来。
   </TEXT>

  <TEXT>
     <SPLITINLINE>
      Cons
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    通过创建新的序对来构建新的列表结构，
    <SPLITINLINE>
      而 set-car!
      <JAVASCRIPT>而 <JAVASCRIPTINLINE>set_@head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      set-cdr!
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    修改现有的序对。
    实际上，我们可以
    <INDEX><USE>pair</USE> (原语函数)<SUBINDEX>用修改器实现</SUBINDEX></INDEX>
    用两个修改器和一个
    <SPLITINLINE>过程<JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE>
      get-new-pair,
      <JAVASCRIPT><JAVASCRIPTINLINE>get_new_pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    实现
    <SPLITINLINE>
      cons
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    ，它返回一个不属于任何现有列表结构的新序对。
    我们获得这个新序对，设置其
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针指向指定的对象，并返回作为
    <SPLITINLINE>cons<JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
    的结果的新序对。  <FOOTNOTE>
    <SPLIT>
      
	Get-new-pair
	是Lisp实现所需内存管理的一部分操作。
	我们将在<SPACE></SPACE><REF NAME="sec:memory-as-vectors"></REF>部分讨论这一点。
      
      <JAVASCRIPT>
	<REF NAME="sec:memory-as-vectors"></REF>部分
	将展示内存管理系统如何实现<JAVASCRIPTINLINE>get_new_pair</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLIT>
  </FOOTNOTE>

<SNIPPET HIDE="yes">
    <NAME>get_new_pair</NAME>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
// The book proposes a primitive function get_new_pair.
// Since JavaScript does not provide such a function, let&apos;s
// define it as follows, for the sake of the example.

function get_new_pair() {
    return pair(undefined, undefined);
}
{    
    </JAVASCRIPT>
  </SNIPPET>
  <SNIPPET POSTPADDING="no">
    <INDEX><DECLARATION>pair</DECLARATION> (primitive function)<SUBINDEX>implemented with mutators</SUBINDEX></INDEX>
    <REQUIRES>get_new_pair</REQUIRES>
    <EXAMPLE>mutable_pair_example</EXAMPLE>
    <EXPECTED>[ [ 1, 2 ], 4 ]</EXPECTED>
    <SCHEME>
(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
    </SCHEME>
    <JAVASCRIPT>
function pair(x, y) {
    const fresh = get_new_pair();
    set_head(fresh, x);
    set_tail(fresh, y);
    return fresh;
}
    </JAVASCRIPT>
  </SNIPPET>

  <SNIPPET HIDE="yes">
    <NAME>mutable_pair_example</NAME>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
pair(pair(1, 2), 4);
}
    </JAVASCRIPT>
  </SNIPPET>
  </TEXT>

  <EXERCISE>
    <LABEL NAME="ex:append"></LABEL> 
    以下是追加列表的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    在<SPACE></SPACE><REF NAME="sec:sequences"></REF>节中介绍：
<SNIPPET HIDE="yes">
      <NAME>append_example3</NAME>
      <EXPECTED>9</EXPECTED>
      <JAVASCRIPT>
append(list(1, 3), list(5, 7, 9));	
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
list_ref(append(list(1, 3), list(5, 7, 9)), 4);	
      </JAVASCRIPT_TEST>
    </SNIPPET>
     
    以下<SPACE></SPACE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    用于追加列表在<SPACE></SPACE><REF NAME="sec:sequences"></REF>部分中介绍：
<SNIPPET EVAL="yes">
      <NAME>append2</NAME>
      <EXAMPLE>append_example3</EXAMPLE>
      <EXPECTED>9</EXPECTED>
      <SCHEME>
(define (append x y)
  (if (null? x)
    y
    (cons (car x) (append (cdr x) y))))
      </SCHEME>
      <JAVASCRIPT>
function append(x, y) {
    return is_null(x)
           ? y
           : pair(head(x), append(tail(x), y));
}
      </JAVASCRIPT>
    </SNIPPET>
     <SPLITINLINE>
      Append
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>append</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    通过连续地
    <SPLITINLINE>
      
	cons将
	x的元素加入到
	y中。
      
      <JAVASCRIPT>
	将x的元素添加到
	<JAVASCRIPTINLINE>y</JAVASCRIPTINLINE>的前面。
      </JAVASCRIPT>
    </SPLITINLINE>
    这个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>append</USE><SUBINDEX><ORDER>append 变异器</ORDER><USE>append_mutator</USE> vs.</SUBINDEX></INDEX>
    <SPLITINLINE>
      append!
      <JAVASCRIPT><JAVASCRIPTINLINE>append_mutator</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    类似于  <SCHEMEINLINE>append</SCHEMEINLINE> ，但是它是一个修改器
    而不是构造器。它通过将列表拼接在一起来附加列表，
    修改  <SCHEMEINLINE>x</SCHEMEINLINE> ，现在变为
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    。 <SCHEMEINLINE>y</SCHEMEINLINE> 。（调用
    <SPLITINLINE>
      append!
      <JAVASCRIPT><JAVASCRIPTINLINE>append_mutator</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    带空是错误<SPACE></SPACE>  <SCHEMEINLINE>x</SCHEMEINLINE>。）
<SNIPPET EVAL="yes">
      <INDEX><DECLARATION>append_mutator</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <NAME>append_mutator</NAME>
      <REQUIRES>last_pair</REQUIRES>
      <SCHEME>
(define (append! x y)
  (set-cdr! (last-pair x) y)
            x)
      </SCHEME>
      <JAVASCRIPT>
function append_mutator(x, y) {
    set_tail(last_pair(x), y);
    return x;
}
      </JAVASCRIPT>
    </SNIPPET> 
    这里
    <SPLITINLINE>
      last-pair
      <JAVASCRIPT><JAVASCRIPTINLINE>last_pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    是一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，返回其参数中的最后一个序对：
<SNIPPET HIDE="yes">
      <NAME>last_pair_example_2</NAME>
      <JAVASCRIPT>
last_pair(list(1, 2, 3, 4, 5));
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>last_pair</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <NAME>last_pair</NAME>
      <EXAMPLE>last_pair_example_2</EXAMPLE>
      <EXPECTED>[ 5, null ]</EXPECTED>
      <SCHEME>
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
      </SCHEME>
      <JAVASCRIPT>
function last_pair(x) {
    return is_null(tail(x))
           ? x
           : last_pair(tail(x));
}
      </JAVASCRIPT>
    </SNIPPET> 
    考虑交互
<SNIPPET EVAL="yes">
      <NAME>append_interaction_1</NAME>
      <REQUIRES>append2</REQUIRES>
      <REQUIRES>append_mutator</REQUIRES>
      <SCHEME>
(define x (list &apos;a &apos;b))
      </SCHEME>
      <JAVASCRIPT>
const x = list(&quot;a&quot;, &quot;b&quot;);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_2</NAME>
      <REQUIRES>append_interaction_1</REQUIRES>
      <SCHEME>
(define y (list &apos;c &apos;d))
      </SCHEME>
      <JAVASCRIPT>
const y = list(&quot;c&quot;, &quot;d&quot;);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_3</NAME>
      <REQUIRES>append_interaction_2</REQUIRES>
      <SCHEME>
(define z (append x y))
      </SCHEME>
      <JAVASCRIPT>
const z = append(x, y);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_4</NAME>
      <REQUIRES>append_interaction_3</REQUIRES>
      <SCHEME>
z
      </SCHEME>
      <SCHEMEOUTPUT>
(a b c d)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
z;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[&quot;a&quot;, [&quot;b&quot;, [&quot;c&quot;, [&quot;d, null]]]]	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_5</NAME>
      <REQUIRES>append_interaction_4</REQUIRES>
      <SCHEME>
(cdr x)
      </SCHEME>
      <SCHEMEOUTPUT>
&lt;response&gt;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
tail(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
<META>response</META>
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_6</NAME>
      <REQUIRES>append_interaction_5</REQUIRES>
      <SCHEME>
(define w (append! x y))
      </SCHEME>
      <JAVASCRIPT>
const w = append_mutator(x, y);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_7</NAME>
      <REQUIRES>append_interaction_6</REQUIRES>
      <SCHEME>
w
      </SCHEME>
      <SCHEMEOUTPUT>
(a b c d)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
w;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[&quot;a&quot;, [&quot;b&quot;, [&quot;c&quot;, [&quot;d&quot;, null]]]]      
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>append_interaction_8</NAME>
      <REQUIRES>append_interaction_7</REQUIRES>
      <SCHEME>
(cdr x)
      </SCHEME>
      <SCHEMEOUTPUT>
&lt;response&gt;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
tail(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
<META>response</META>
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    缺少的<META>response</META>是什么？
    画出方框与指针图来解释你的答案。
</EXERCISE>

  <EXERCISE> 
    考虑以下
    <INDEX>列表中的循环</INDEX>
    <SPLITINLINE>
      make-cycle
      <JAVASCRIPT><JAVASCRIPTINLINE>make_cycle</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程，
      <JAVASCRIPT>函数，</JAVASCRIPT>
    </SPLITINLINE>
    它使用
    <SPLITINLINE>
      
	last-pair
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>last_pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    在练习<SPACE></SPACE><REF NAME="ex:append"></REF>中定义：
<SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_cycle</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <NAME>make_cycle</NAME>
      <REQUIRES>last_pair</REQUIRES>
      <EXAMPLE>make_cycle_example</EXAMPLE>
      <SCHEME>
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
            x)
      </SCHEME>
      <JAVASCRIPT>
function make_cycle(x) {
    set_tail(last_pair(x), x);
    return x;
}
      </JAVASCRIPT>
    </SNIPPET> 
    画出一个方框与指针图显示结构
<SCHEMEINLINE>z</SCHEMEINLINE> 
    由...创建的
<SNIPPET EVAL="yes">
      <NAME>make_cycle_example</NAME>
      <REQUIRES>make_cycle</REQUIRES>
      <EXPECTED>&apos;b&apos;</EXPECTED>
      <SCHEME>
(define z (make-cycle (list &apos;a &apos;b &apos;c)))
      </SCHEME>
      <JAVASCRIPT>
const z = make_cycle(list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
const z = make_cycle(list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
list_ref(z, 100);	
      </JAVASCRIPT_TEST>
    </SNIPPET> 
    如果我们尝试计算
    <SPLITINLINE>
      (last-pair z)？
      <JAVASCRIPT><JAVASCRIPTINLINE>last_pair(z)</JAVASCRIPTINLINE>？
      </JAVASCRIPT>
    </SPLITINLINE>
<LABEL NAME="ex:make-cycle"></LABEL>
     <SOLUTION>
      （由GitHub用户jonathantorres提供）
      如果我们尝试计算<JAVASCRIPTINLINE>last_pair(z)</JAVASCRIPTINLINE>，程序将进入一个无限循环，因为列表的末尾指向开头。

      <FIGURE SRC="img_javascript/ex-3-13-sol.png">
	
      </FIGURE>

    </SOLUTION>
</EXERCISE>

  <EXERCISE> 
    以下
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    是非常有用的，尽管比较晦涩：
<SNIPPET EVAL="yes">
      <INDEX><DECLARATION>mystery</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <NAME>mystery_loop</NAME>
      <REQUIRES>mystery_loop_example_1</REQUIRES>
      <EXAMPLE>mystery_loop_example_2</EXAMPLE>
      <SCHEME>
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x &apos;()))
      </SCHEME>
      <JAVASCRIPT>
function mystery(x) {
    function loop(x, y) {
        if (is_null(x)) {
            return y;
        } else {
            const temp = tail(x);
            set_tail(x, y);
            return loop(temp, x);
        }
    }
    return loop(x, null);
}
      </JAVASCRIPT>
    </SNIPPET>
     <SPLITINLINE>
      Loop
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>loop</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    使用<QUOTE>临时</QUOTE>
    <SPLITINLINE>
      
	变量
      
      <JAVASCRIPT>
	名称
      </JAVASCRIPT>
    </SPLITINLINE>
<SCHEMEINLINE>temp</SCHEMEINLINE> 
    用于保存
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    的旧值
<SCHEMEINLINE>x</SCHEMEINLINE>，因为下一行的
    <SPLITINLINE>
      set-cdr!
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    破坏了
    <SPLITINLINE>
      cdr。
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>。</JAVASCRIPT>
    </SPLITINLINE>
    解释什么
<SCHEMEINLINE>mystery</SCHEMEINLINE> 
    通常是做什么的。假设
<SCHEMEINLINE>v</SCHEMEINLINE> 
    由...定义为
<SNIPPET>
      <NAME>mystery_loop_example_1</NAME>
      <SCHEME>
(define v (list &apos;a &apos;b &apos;c &apos;d))
      </SCHEME>
      <JAVASCRIPT>
const v = list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
      </JAVASCRIPT>
    </SNIPPET> 
    画出一个方框与指针图来表示该列表
<SCHEMEINLINE>v</SCHEMEINLINE> 
    绑定到。假设我们现在计算
<SNIPPET>
      <NAME>mystery_loop_example_2</NAME>
      <REQUIRES>mystery_loop</REQUIRES>
      <SCHEME>
(define w (mystery v))
      </SCHEME>
      <JAVASCRIPT>
const w = mystery(v);
      </JAVASCRIPT>
    </SNIPPET> 
    画出方框与指针图来展示结构
<SCHEMEINLINE>v</SCHEMEINLINE> 和 <SCHEMEINLINE>w</SCHEMEINLINE> 
    在评估此
    <SPLITINLINE>
      表达式
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    后，展示结构的方框与指针图。什么将被打印为的值
<SCHEMEINLINE>v</SCHEMEINLINE> 和 <SCHEMEINLINE>w</SCHEMEINLINE> ？
<LABEL NAME="ex:mystery"></LABEL>
     <SOLUTION>
      （由GitHub用户jonathantorres提供）
      应用<JAVASCRIPTINLINE>mystery(x)</JAVASCRIPTINLINE>将原地反转列表<JAVASCRIPTINLINE>x</JAVASCRIPTINLINE>。
      最初
      <JAVASCRIPTINLINE>v</JAVASCRIPTINLINE>看起来像这样：
      
      <FIGURE SRC="img_javascript/ex-3-14-sol-2.png">
	
      </FIGURE>

      计算
      <JAVASCRIPTINLINE>const w = mystery(v);</JAVASCRIPTINLINE>
      后
      <JAVASCRIPTINLINE>v</JAVASCRIPTINLINE> 和
      <JAVASCRIPTINLINE>w</JAVASCRIPTINLINE> 的值变为：
      
      <FIGURE SRC="img_javascript/ex-3-14-sol-2.png">
	
      </FIGURE>

      函数<JAVASCRIPTINLINE>display</JAVASCRIPTINLINE>
      打印<JAVASCRIPTINLINE>[&quot;a&quot;, null]</JAVASCRIPTINLINE>为
      <JAVASCRIPTINLINE>v</JAVASCRIPTINLINE> 和
      <JAVASCRIPTINLINE>[&quot;d&quot;, [&quot;c&quot;, [&quot;b&quot;, [&quot;a&quot;, null]]]]</JAVASCRIPTINLINE>为
      <JAVASCRIPTINLINE>w</JAVASCRIPTINLINE>。
    </SOLUTION>
</EXERCISE>

   <INDEX>可变数据对象<SUBINDEX>列表结构<CLOSE></CLOSE></SUBINDEX></INDEX> 
  <INDEX>list structure<SUBINDEX>mutable<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
   <INDEX>可变数据对象<SUBINDEX>序对<CLOSE></CLOSE></SUBINDEX></INDEX> 
   <INDEX>序对<SUBINDEX>可变<CLOSE></CLOSE></SUBINDEX></INDEX> 

   <SUBHEADING> 
    <NAME>共享和同一性</NAME>
  </SUBHEADING> 

   <INDEX>数据<SUBINDEX>共享<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>共享数据<OPEN></OPEN></INDEX> 

  <TEXT> <INDEX>共享数据<OPEN></OPEN></INDEX> <SNIPPET EVAL="yes">
      <NAME>pair_example1</NAME>
      <SCHEME>
(define x (list &apos;a &apos;b))
(define z1 (cons x x))
      </SCHEME>
      <JAVASCRIPT>
const x = list(&quot;a&quot;, &quot;b&quot;);
const z1 = pair(x, x);
      </JAVASCRIPT>
    </SNIPPET> 
    如图所示
    <SPLITINLINE>
      
        图<SPACE></SPACE><REF NAME="fig:identity1_scheme"></REF>，
      
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:identity1"></REF>，
      </JAVASCRIPT>
    </SPLITINLINE>
<SCHEMEINLINE>z1</SCHEMEINLINE> <INDEX>可变数据对象<SUBINDEX>序对流生成函数<CLOSE></CLOSE></SUBINDEX></INDEX> <SCHEMEINLINE>x</SCHEMEINLINE> 。这种共享
<SCHEMEINLINE>x</SCHEMEINLINE> 由
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指向
<SCHEMEINLINE>z1</SCHEMEINLINE> 这是以
    <SPLITINLINE>
      cons
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    被简单实现的结果。通常，使用
    <SPLITINLINE>
      cons
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    构建列表会导致许多单独的序对在多个不同的结构中共享的序对的连接结构。
    <SPLIT>
      
        <FIGURE>
          <FIGURE SPLIT_SCALE="0.7" SRC="img_original/ch3-Z-G-17.svg"></FIGURE>
          <CAPTION>
	    列表z1由
	    (cons x x)形成。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-17.svg"></FIGURE>
          <CAPTION>
	    列表z1由
	    <JAVASCRIPTINLINE>pair(x, x)</JAVASCRIPTINLINE>形成。
          </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
 <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-18.svg"></FIGURE>
          <CAPTION>
	    列表z2由
	    (cons (list &apos;a &apos;b) (list &apos;a &apos;b))形成。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-18.svg"></FIGURE>
          <CAPTION>
	    列表z2由
	    <JAVASCRIPTINLINE>pair(list(&quot;a&quot;, &quot;b&quot;), list(&quot;a&quot;, &quot;b&quot;))</JAVASCRIPTINLINE>形成。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
</TEXT>

  <TEXT> 
    与
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:identity1_scheme"></REF>相比，
	图<SPACE></SPACE><REF NAME="fig:identity2_scheme"></REF>
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:identity1"></REF>相比，
	图<SPACE></SPACE><REF NAME="fig:identity2"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    显示的是由...创建的结构
<SNIPPET EVAL="yes">
      <NAME>pair_example2</NAME>
      <SCHEME>
(define z2 (cons (list &apos;a &apos;b) (list &apos;a &apos;b)))
      </SCHEME>
      <JAVASCRIPT>
const z2 = pair(list(&quot;a&quot;, &quot;b&quot;), list(&quot;a&quot;, &quot;b&quot;));
      </JAVASCRIPT>
    </SNIPPET>
    In this structure, the pairs in the two
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(a b)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;a&quot;, &quot;b&quot;)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    lists are distinct, although
    <SPLITINLINE>
      <SCHEME>
	the actual symbols are shared.
	<FOOTNOTE>The two pairs are distinct because each call to
	<SCHEMEINLINE>cons</SCHEMEINLINE> returns a new pair.  The
        symbols are shared; in Scheme there is a
        <INDEX>symbol(s)<SUBINDEX>uniqueness of</SUBINDEX></INDEX>
	unique symbol with any given
        name.  Since Scheme provides no way to mutate a symbol, this sharing is
        undetectable.  Note also that the sharing is what enables us to
        compare symbols using <SCHEMEINLINE>eq?</SCHEMEINLINE>, which simply checks equality of
        pointers.<LABEL NAME="foot:symbol-sharing_scheme"></LABEL></FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	they contain the same strings.<FOOTNOTE>The two pairs are distinct
	because each call to <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
	returns a new pair. The strings are
        <INDEX>string(s)<SUBINDEX>uniqueness of</SUBINDEX></INDEX>
	<QUOTE>the same</QUOTE> in the sense
	that they are primitive data (just like numbers) that are composed of
	the same characters in the same order. Since JavaScript provides no way
	to mutate a string, any sharing that the designers of a JavaScript
	interpreter might decide to implement for strings is undetectable.
	We consider primitive data such as numbers, booleans, and strings
	to be <EM>identical</EM> if and only if they are
	<EM>indistinguishable</EM>.
	<LABEL NAME="foot:symbol-sharing"></LABEL>
	</FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
  <!-- Error occurred while translating this section --></TEXT>
  <TEXT>
    When thought of as a list, <!-- Error occurred while translating this section --><SCHEMEINLINE>z1</SCHEMEINLINE> and
    <!-- Error occurred while translating this section --><SCHEMEINLINE>z2</SCHEMEINLINE> both represent <QUOTE>the same</QUOTE> list:
    <!-- Error occurred while translating this section --><SNIPPET>
      <NAME>abab</NAME>
      <EXPECTED>[ [ &apos;a&apos;, [ &apos;b&apos;, null ] ], [ &apos;a&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
((a b) a b)
      </SCHEME>
      <JAVASCRIPT>
list(list(&quot;a&quot;, &quot;b&quot;), &quot;a&quot;, &quot;b&quot;)
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list(list(&quot;a&quot;, &quot;b&quot;), &quot;a&quot;, &quot;b&quot;);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    In general, sharing is completely undetectable if we operate on lists using
    only
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    However, if we allow mutators on list structure, sharing becomes
    significant.  As an example of the difference that sharing can make,
    consider the following
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
    <JAVASCRIPT>function,</JAVASCRIPT></SPLITINLINE>
    which modifies the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the structure to which it is applied:
    <!-- Error occurred while translating this section --><SNIPPET EVAL="yes">
      <NAME>set_to_wow</NAME>
      <SCHEME>
(define (set-to-wow! x)
  (set-car! (car x) &apos;wow)
  x)
      </SCHEME>
      <JAVASCRIPT>
function set_to_wow(x) {
    set_head(head(x), &quot;wow&quot;);
    return x;
}
      </JAVASCRIPT>
    </SNIPPET>
    Even though <!-- Error occurred while translating this section --><SCHEMEINLINE>z1</SCHEMEINLINE> and
    <!-- Error occurred while translating this section --><SCHEMEINLINE>z2</SCHEMEINLINE> are <QUOTE>the same</QUOTE> structure,
    applying
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-to-wow!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_to_wow</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to them yields different results.  With <!-- Error occurred while translating this section --><SCHEMEINLINE>z1</SCHEMEINLINE>,
    altering the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    also changes the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    because in <!-- Error occurred while translating this section --><SCHEMEINLINE>z1</SCHEMEINLINE> the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    are the same pair.  With <!-- Error occurred while translating this section --><SCHEMEINLINE>z2</SCHEMEINLINE>, the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    are distinct, so
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-to-wow!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_to_wow</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    modifies only the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>:</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>:</JAVASCRIPT>
    </SPLITINLINE>
    <!-- Error occurred while translating this section --><SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_1</NAME>
      <REQUIRES>pair_example1</REQUIRES>
      <EXPECTED>[ [ &apos;a&apos;, [ &apos;b&apos;, null ] ], [ &apos;a&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
z1
      </SCHEME>
      <SCHEMEOUTPUT>
            ((a b) a b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
z1; 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>      
[[&quot;a&quot;, [&quot;b&quot;, null]], [&quot;a&quot;, [&quot;b&quot;, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_2</NAME>
      <REQUIRES>set_to_wow</REQUIRES>
      <REQUIRES>pair_example1</REQUIRES>
      <EXPECTED>[ [ &apos;wow&apos;, [ &apos;b&apos;, null ] ], [ &apos;wow&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
(set-to-wow! z1)
      </SCHEME>
      <SCHEMEOUTPUT>
((wow b) wow b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_to_wow(z1); 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[[&quot;wow&quot;, [&quot;b&quot;, null]], [&quot;wow&quot;, [&quot;b&quot;, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_3</NAME>
      <REQUIRES>pair_example2</REQUIRES>
      <EXPECTED>[ [ &apos;a&apos;, [ &apos;b&apos;, null ] ], [ &apos;a&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
z2
      </SCHEME>
      <SCHEMEOUTPUT>
((a b) a b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
z2;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>&gt;
[[&quot;a&quot;, [&quot;b&quot;, null]], [&quot;a&quot;, [&quot;b&quot;, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>set_to_wow_example_4</NAME>
      <REQUIRES>set_to_wow</REQUIRES>
      <REQUIRES>pair_example2</REQUIRES>
      <EXPECTED>[ [ &apos;wow&apos;, [ &apos;b&apos;, null ] ], [ &apos;a&apos;, [ &apos;b&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
(set-to-wow! z2)
      </SCHEME>
      <SCHEMEOUTPUT>
((wow b) a b)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_to_wow(z2); 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[[&quot;wow&quot;, [&quot;b&quot;, null]], [&quot;a&quot;, [&quot;b&quot;, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
	One way to detect sharing in list structures is to use the predicate 
	<SCHEMEINLINE>eq?</SCHEMEINLINE>, which we introduced in
	section<SPACE></SPACE><REF NAME="sec:quotation"></REF> as a way to test whether two 
	symbols are equal. More generally, <SCHEMEINLINE>(eq? x y)</SCHEMEINLINE>
	tests whether <SCHEMEINLINE>x</SCHEMEINLINE> and
	<SCHEMEINLINE>y</SCHEMEINLINE> are the same object (that is, whether
	<SCHEMEINLINE>x</SCHEMEINLINE> and <SCHEMEINLINE>y</SCHEMEINLINE>
	are equal as pointers).
      </SCHEME>
      <JAVASCRIPT>
	One way to detect sharing in list structures is to use the
	<INDEX><USE>===</USE><SUBINDEX><ORDER>equality</ORDER>as equality of pointers</SUBINDEX></INDEX>
	<INDEX><USE>===</USE><SUBINDEX><ORDER>general</ORDER>as general comparison operator</SUBINDEX></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>===</USE> (for nonprimitive values)</SUBINDEX></INDEX>
	primitive predicate <JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,	
	which we introduced in
	section<SPACE></SPACE><REF NAME="sec:conditionals"></REF> to test whether two numbers
	are equal 
	and extended in section<SPACE></SPACE><REF NAME="sec:strings"></REF> to test whether
	two strings are equal. When applied to two nonprimitive values,
	<JAVASCRIPTINLINE>x === y</JAVASCRIPTINLINE>
	tests whether <SCHEMEINLINE>x</SCHEMEINLINE> and
	<SCHEMEINLINE>y</SCHEMEINLINE> are the same object (that is, whether
	<SCHEMEINLINE>x</SCHEMEINLINE> and <SCHEMEINLINE>y</SCHEMEINLINE>
	are equal as pointers).
      </JAVASCRIPT>
    </SPLIT>
    Thus, with <!-- Error occurred while translating this section --><SCHEMEINLINE>z1</SCHEMEINLINE> and
    <!-- Error occurred while translating this section --><SCHEMEINLINE>z2</SCHEMEINLINE> as defined in
    <SPLITINLINE>
      <SCHEME>
	figure<SPACE></SPACE><REF NAME="fig:identity1_scheme"></REF>
	and<SPACE></SPACE><REF NAME="fig:identity2_scheme"></REF>,
      </SCHEME>
      <JAVASCRIPT>
	figure<SPACE></SPACE><REF NAME="fig:identity1"></REF>
	and<SPACE></SPACE><REF NAME="fig:identity2"></REF>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(eq? (car<SPACE></SPACE>z1) (cdr<SPACE></SPACE>z1))</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head(z1) === tail(z1)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is true and
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>(eq? (car z2) (cdr z2))</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head(z2) === tail(z2)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is false.
  <!-- Error occurred while translating this section --></TEXT>

  <TEXT>
    As will be seen in the following sections, we can exploit sharing to
    greatly extend the repertoire of data structures that can be
    represented by pairs.  On the other hand, sharing can also be
    <INDEX>mutable data objects<SUBINDEX>shared data</SUBINDEX></INDEX>
    dangerous, since modifications made to structures will also affect
    other structures that happen to share the modified parts.  The mutation
    operations
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    should be used with care; unless we have a good understanding of how our
    data objects are shared, mutation can have unanticipated
    results.<!-- Error occurred while translating this section --><FOOTNOTE>The subtleties of dealing with sharing of mutable data
    objects reflect the underlying issues of <QUOTE>sameness</QUOTE> and
    <QUOTE>change</QUOTE> that were raised in
    section<SPACE></SPACE><REF NAME="sec:costs-of-assignment"></REF>.  We mentioned there
    that admitting change to our language requires that a compound object must
    have an <QUOTE>identity</QUOTE> that is something different from the pieces
    from which it is composed.  In
    <SPLITINLINE>
      <SCHEME>Lisp,</SCHEME>
      <JAVASCRIPT>JavaScript,</JAVASCRIPT>
    </SPLITINLINE>
    we consider this <QUOTE>identity</QUOTE> to be the quality that is tested by
    <SPLITINLINE><SCHEME><SCHEMEINLINE>eq?</SCHEMEINLINE>,</SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    i.e., by equality of pointers.  Since in most
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    implementations a pointer is essentially a memory address, we are
    <QUOTE>solving the problem</QUOTE> of defining the identity of objects by
    stipulating that a data object <QUOTE>itself</QUOTE> is the information
    stored in some particular set of memory locations in the computer.  This
    suffices for simple
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    programs, but is hardly a general way to resolve the issue of
    <QUOTE>sameness</QUOTE> in computational models.</FOOTNOTE>
  <!-- Error occurred while translating this section --></TEXT>

  <EXERCISE>
    <LABEL NAME="ex:3_15"></LABEL>
    Draw box-and-pointer diagrams to explain the effect of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-to-wow!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_to_wow</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    on the structures <SCHEMEINLINE>z1</SCHEMEINLINE> and
    <SCHEMEINLINE>z2</SCHEMEINLINE> above.
  </EXERCISE><!-- Error occurred while translating this section -->

  <SHORT_PAGE LINES="1"></SHORT_PAGE><!-- Error occurred while translating this section -->
  <EXERCISE>
    Ben Bitdiddle decides to write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to count the number of pairs in any list structure.
    <QUOTE>It<APOS></APOS>s easy,</QUOTE> he reasons.  <QUOTE>The number of pairs in
    any structure is the number in the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    plus the number in the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    plus one more to count the current pair.</QUOTE> So Ben writes the following
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <!-- Error occurred while translating this section --><SNIPPET EVAL="yes">
      <NAME>count_pairs</NAME>
      <INDEX><DECLARATION>count_pairs</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <SCHEME>
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
      </SCHEME>
      <JAVASCRIPT>
function count_pairs(x) {
    return ! is_pair(x)
           ? 0
           : count_pairs(head(x)) + 
             count_pairs(tail(x)) +
             1;
}
      </JAVASCRIPT>
    </SNIPPET>
    Show that this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is not correct.  In particular, draw box-and-pointer diagrams representing
    list structures made up of exactly three pairs for which Ben<APOS></APOS>s
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    would return<SPACE></SPACE>3; return 4; return 7; never return at all.
    <!-- Error occurred while translating this section --><LABEL NAME="ex:count-pairs"></LABEL>
    <SOLUTION>
      <SNIPPET>
        <NAME>exercise_3_16_solution</NAME>
	<REQUIRES>count_pairs</REQUIRES>
        <EXAMPLE>exercise_3_16_solution_example</EXAMPLE>
        <SCHEME>
        </SCHEME>
        <JAVASCRIPT>
const three_list = list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
const one = pair(&quot;d&quot;, &quot;e&quot;);
const two = pair(one, one);
const four_list = pair(two, &quot;f&quot;);
const seven_list = pair(two, two);
const cycle = list(&quot;g&quot;, &quot;h&quot;, &quot;i&quot;);
set_tail(tail(tail(cycle)), cycle);
        </JAVASCRIPT>
      </SNIPPET>

      <SNIPPET HIDE="yes">
	      <NAME>exercise_3_16_solution_example</NAME>
	      <JAVASCRIPT>
// return 3; return 4; return 7;
display(count_pairs(three_list));
display(count_pairs(four_list));
display(count_pairs(seven_list));

// never return at all
display(count_pairs(cycle));	
	      </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  <!-- Error occurred while translating this section --></EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:count-pairs2"></LABEL>
    Devise a correct version of the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>count-pairs</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>count_pairs</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of exercise<SPACE></SPACE><REF NAME="ex:count-pairs"></REF> that returns the number of
    distinct pairs in any structure.  (Hint: Traverse the structure, maintaining
    an auxiliary data structure that is used to keep track of which pairs have
    already been counted.)
    <!-- Error occurred while translating this section --><SOLUTION>
      <SNIPPET>
	<EXAMPLE>exercise_3_17_solution_example</EXAMPLE>
	<JAVASCRIPT>
// solution provided by GitHub user clean99
	  
function count_pairs(x) {
    let counted_pairs = null;
    function is_counted_pair(current_counted_pairs, x) {
        return is_null(current_counted_pairs)
               ? false
               : head(current_counted_pairs) === x
               ? true
               : is_counted_pair(tail(current_counted_pairs), x);
    }
    function count(x) {
        if(! is_pair(x) || is_counted_pair(counted_pairs, x)) {
            return 0;
        } else {
            counted_pairs = pair(x, counted_pairs);
            return count(head(x)) +
                   count(tail(x)) +
                   1;
        }
    }
    return count(x);
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
         <NAME>exercise_3_17_solution_example</NAME>
         <JAVASCRIPT>
const three_list = list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
const one = pair(&quot;d&quot;, &quot;e&quot;);
const two = pair(one, one);
const four_list = pair(two, &quot;f&quot;);
const seven_list = pair(two, two);
const cycle = list(&quot;g&quot;, &quot;h&quot;, &quot;i&quot;);
set_tail(tail(tail(cycle)), cycle);

// return 3; return 3; return 3;
display(count_pairs(three_list));
display(count_pairs(four_list));
display(count_pairs(seven_list));

// return 3
display(count_pairs(cycle));
	 </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  <!-- Error occurred while translating this section --></EXERCISE>
  
  <EXERCISE>
    Write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that examines a list and
    <INDEX>cycle in list<SUBINDEX>detecting</SUBINDEX></INDEX>
    determines whether it contains a cycle, that is,
    whether a program that tried to find the end of the list by taking
    successive
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>s</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>s</JAVASCRIPT>
    </SPLITINLINE>
    would go into an infinite loop. Exercise<SPACE></SPACE><REF NAME="ex:make-cycle"></REF>
    constructed such lists.
    <LABEL NAME="ex:find-cycle"></LABEL>
   <SOLUTION>
      <SNIPPET>
	<EXAMPLE>exercise_3_18_solution_example</EXAMPLE>
	<JAVASCRIPT>
// solution provided by GitHub user clean99

function contains_cycle(x) {
    let counted_pairs = null;
    function is_counted_pair(counted_pairs, x) {
        return is_null(counted_pairs)
               ? false
               : head(counted_pairs) === x
               ? true
               : is_counted_pair(tail(counted_pairs), x);
    }
    function detect_cycle(x) {
        if (is_null(x)) {
            return false;
        } else if (is_counted_pair(counted_pairs, x)) {
            return true;
        } else {
            counted_pairs = pair(x, counted_pairs);
            return detect_cycle(tail(x));
        }
    }
    return detect_cycle(x);
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
         <NAME>exercise_3_18_solution_example</NAME>
         <JAVASCRIPT>
const three_list = list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
const cycle = list(&quot;g&quot;, &quot;h&quot;, &quot;i&quot;);
set_tail(tail(tail(cycle)), cycle);

// displays false
display(contains_cycle(three_list));

// displays true
display(contains_cycle(cycle));
	 </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE><!-- Error occurred while translating this section -->

  <EXERCISE>
    <LABEL NAME="ex:3_19"></LABEL>
    Redo exercise<SPACE></SPACE><REF NAME="ex:find-cycle"></REF> using an algorithm that
    takes only a constant amount of space.  (This requires a very clever idea.)
    <SNIPPET HIDE="yes">
      <NAME>pair2_example</NAME>
      <JAVASCRIPT>
const x = pair(1, 2);
set_head(x, 3);
head(x);
      </JAVASCRIPT>
    </SNIPPET>
    <SOLUTION>
      Define a fast pointer and a slow pointer. The fast pointer goes forward
      2 steps every time, while the slow pointer goes forward 1 step every time.
      If there is a cycle in the list, the fast pointer will eventually catch
      up with the slow pointer.
      <SNIPPET HIDE="yes">
	<NAME>contains_cycle_example</NAME>
	<REQUIRES>make_cycle</REQUIRES>
	<JAVASCRIPT>
const c = make_cycle(list(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;));
const c1 = append(list(&quot;a&quot;, &quot;b&quot;), c);

contains_cycle(c1);
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET EVAL="yes">
	<NAME>contains_cycle</NAME>
	<EXAMPLE>contains_cycle_example</EXAMPLE>
	<JAVASCRIPT>
function contains_cycle(x) {
    function detect_cycle(fast, slow) {
        return is_null(fast) || is_null(tail(fast))
               ? false
               : fast === slow
               ? true
               : detect_cycle(tail(tail(fast)), tail(slow));
    }
    return detect_cycle(tail(x), x);
}
	</JAVASCRIPT>
	</SNIPPET>
    </SOLUTION>
  </EXERCISE><!-- Error occurred while translating this section -->

  <INDEX>data<SUBINDEX>shared<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>shared data<CLOSE></CLOSE></INDEX><!-- Error occurred while translating this section -->

  <SUBHEADING> 
    <NAME>Mutation is just assignment</NAME>
  </SUBHEADING><!-- Error occurred while translating this section -->

  <INDEX>mutable data objects<SUBINDEX>functional representation of<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>mutable data objects<SUBINDEX>implemented with assignment<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>pair(s)<SUBINDEX>functional representation of<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>functional representation of data<SUBINDEX>mutable data<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->

  <TEXT>
    When we introduced compound data, we observed in
    section<SPACE></SPACE><REF NAME="sec:data?"></REF> that pairs can be represented purely
    in terms of
    <SPLITINLINE>
      <SCHEME>procedures:</SCHEME>
      <JAVASCRIPT>functions:</JAVASCRIPT>
    </SPLITINLINE>
    <!-- Error occurred while translating this section --><SNIPPET EVAL="yes">
      <INDEX><DECLARATION>pair</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>head</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>tail</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <EXAMPLE>cons_1_2_run</EXAMPLE>
      <EXPECTED>1</EXPECTED>
      <SCHEME>
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m &apos;car) x)
          ((eq? m &apos;cdr) y)
          (else (error &quot;Undefined operation - - CONS&quot; m))))
  dispatch)

(define (car z) (z &apos;car))

(define (cdr z) (z &apos;cdr))
      </SCHEME>
      <JAVASCRIPT>
function pair(x, y) {
    function dispatch(m) {
        return m === &quot;head&quot;
               ? x
               : m === &quot;tail&quot;
               ? y
               : error(m, &quot;undefined operation -- pair&quot;);
    }
    return dispatch;	      
}
<SHORT_SPACE></SHORT_SPACE>
function head(z) { return z(&quot;head&quot;); }
<SHORT_SPACE></SHORT_SPACE>
function tail(z) { return z(&quot;tail&quot;); }
      </JAVASCRIPT>
    </SNIPPET>
    The same observation is true for mutable data.  We can implement
    mutable data objects as
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    using assignment and local state. For instance, we can extend the above
    pair implementation to handle
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-car!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-cdr!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in a manner analogous to the way we implemented bank accounts using
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in section<SPACE></SPACE><REF NAME="sec:local-state-variables"></REF>:
    <!-- Error occurred while translating this section --><SNIPPET HIDE="yes">
      <NAME>cons_1_2_run_3</NAME>
      <JAVASCRIPT>
const x = pair(1, 2);
set_head(x, 3);
head(x);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>pair</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>head</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>tail</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>set_head</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <INDEX><DECLARATION>set_tail</DECLARATION> (primitive function)<SUBINDEX>functional implementation of</SUBINDEX></INDEX>
      <NAME>pair2</NAME>
      <EXAMPLE>cons_1_2_run_3</EXAMPLE>
      <EXPECTED>3</EXPECTED>
      <SCHEME>
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m &apos;car) x)
          ((eq? m &apos;cdr) y)
          ((eq? m &apos;set-car!) set-x!)
          ((eq? m &apos;set-cdr!) set-y!)
          (else (error &quot;Undefined operation - - CONS&quot; m))))
  dispatch)

(define (car z) (z &apos;car))

(define (cdr z) (z &apos;cdr))

(define (set-car! z new-value)
  ((z &apos;set-car!) new-value)
  z)

(define (set-cdr! z new-value)
  ((z &apos;set-cdr!) new-value)
  z)
      </SCHEME>
      <JAVASCRIPT>
function pair(x, y) {
    function set_x(v) { x = v; }
    function set_y(v) { y = v; }
    return m =&gt; m === &quot;head&quot;
                ? x
                : m === &quot;tail&quot;
                ? y
                : m === &quot;set_head&quot;
                ? set_x
                : m === &quot;set_tail&quot;
                ? set_y
                : error(m, &quot;undefined operation -- pair&quot;);
}
<SHORT_SPACE_AND_ALLOW_BREAK></SHORT_SPACE_AND_ALLOW_BREAK>
function head(z) { return z(&quot;head&quot;); }
<SHORT_SPACE></SHORT_SPACE>
function tail(z) { return z(&quot;tail&quot;); }
<SHORT_SPACE></SHORT_SPACE>
function set_head(z, new_value) {
    z(&quot;set_head&quot;)(new_value);
    return z;
}
function set_tail(z, new_value) {
    z(&quot;set_tail&quot;)(new_value);
    return z;
}
      </JAVASCRIPT> <!--   FIXME: add allow break without space after tail   -->
    </SNIPPET>
  </TEXT>

  <TEXT>
    Assignment is all that is needed, theoretically, to account for the
    behavior of mutable data.  As soon as we admit
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>assignment</JAVASCRIPT>
    </SPLITINLINE>
    to our language, we raise all the issues, not only of assignment, but of
    mutable data in general.<FOOTNOTE>On the other hand, from the viewpoint of
    implementation, assignment requires us to modify the environment, which is
    itself a mutable data structure.  Thus, assignment and mutation are
    equipotent: Each can be implemented in terms of the other.</FOOTNOTE>
  </TEXT><!-- Error occurred while translating this section -->

  <EXERCISE>
    Draw environment diagrams to illustrate the evaluation of the sequence
    of
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <NAME>pair2_example1</NAME>
      <REQUIRES>pair2</REQUIRES>
      <SCHEME>
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)

(car x)
      </SCHEME>
      <JAVASCRIPT>
const x = pair(1, 2);
const z = pair(x, x);
set_head(tail(z), 17);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>pair2_example2</NAME>
      <REQUIRES>pair2_example1</REQUIRES>
      <EXPECTED>17</EXPECTED>
      <SCHEME>
(car x)
      </SCHEME>
      <SCHEMEOUTPUT>
            17
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
head(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
17
      </JAVASCRIPT_OUTPUT>
      </SNIPPET>
    using the 
    <SPLITINLINE>
      <SCHEME>
            procedural 
      </SCHEME>
      <JAVASCRIPT>
            functional
      </JAVASCRIPT>
    </SPLITINLINE>
    implementation of pairs given above.  (Compare
    exercise<SPACE></SPACE><REF NAME="ex:two-accounts"></REF>.)
    <LABEL NAME="ex:cons-with-assignment"></LABEL>
  </EXERCISE><!-- Error occurred while translating this section -->

  <INDEX>mutable data objects<SUBINDEX>functional representation of<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>mutable data objects<SUBINDEX>implemented with assignment<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>pair(s)<SUBINDEX>functional representation of<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>functional representation of data<SUBINDEX>mutable data<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->
  <INDEX>mutable data objects<CLOSE></CLOSE></INDEX><!-- Error occurred while translating this section -->
</SUBSECTION>

