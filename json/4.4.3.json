[{"id":"/sicpjs/4.4.3","tag":"TITLE","body":"4.4.3  \n    Is Logic Programming Mathematical Logic?"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    The means of combination used in the query language may at first seem\n    identical to the operations ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"or"},{"body":", and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" of\n    mathematical logic, and the application of query-language rules is in\n    fact accomplished through a legitimate method of\n    \n    inference.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/4.4.3#footnote-1"},{"body":" This identification of the query language with\n    mathematical logic is not really valid, though, because the query language\n    provides a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"control structure","tag":"#text"}]},{"body":" that interprets the logical statements\n    procedurally.  We can often take advantage of this control structure.\n    For example, to find all of the supervisors of programmers we could\n    formulate a query in either of two logically equivalent forms:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"and(job($x, list(\"computer\", \"programmer\")),\n    supervisor($x, $y))"},{"body":"\n    or\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"and(supervisor($x, $y),\n    job($x, list(\"computer\", \"programmer\")))"},{"body":"\n    If a company has\n    \n    many more supervisors than programmers,\n    it is better to use the first form rather than the second,\n    because the data base must be scanned for each intermediate result\n    (frame) produced by the first clause of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The aim of logic programming is to provide the programmer with\n    techniques for decomposing a computational problem into two separate\n    problems:\n    \"","tag":"#text"},{"body":"what","tag":"#text"},{"body":"\" is to be computed, and \"","tag":"#text"},{"body":"how","tag":"#text"},{"body":"\" this\n    should be computed.  This is accomplished by selecting a subset of the\n    statements of mathematical logic that is powerful enough to be able to\n    describe anything one might want to compute, yet weak enough to have a\n    controllable procedural interpretation.  The intention here is that,\n    on the one hand, a program specified in a logic programming language\n    should be an effective program that can be carried out by a computer.\n    Control (\"","tag":"#text"},{"body":"how","tag":"#text"},{"body":"\" to compute) is effected by using the order of\n    evaluation of the language.  We should be able to arrange the order of\n    clauses and the order of subgoals within each clause so that the\n    computation is done in an order deemed to be effective and efficient.\n    At the same time, we should be able to view the result of the\n    computation (\"","tag":"#text"},{"body":"what","tag":"#text"},{"body":"\" to compute) as a simple consequence of the\n    laws of logic.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    Our query language can be regarded as just such a procedurally\n    interpretable subset of mathematical logic.  An assertion represents a\n    simple fact (an atomic proposition).  A rule represents the\n    implication that the rule conclusion holds for those cases where the\n    rule body holds.  A rule has a natural procedural interpretation: To\n    establish the conclusion of the rule, establish the body of the rule.\n    Rules, therefore, specify computations.  However, because rules can\n    also be regarded as statements of mathematical logic, we can justify any\n    \"","tag":"#text"},{"body":"inference","tag":"#text"},{"body":"\" accomplished by a logic program by asserting that\n    the same result could be obtained by working entirely within\n    mathematical logic.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/4.4.3#footnote-2"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Infinite loops","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    A consequence of the procedural interpretation of logic programs is\n    that it is possible to construct hopelessly inefficient programs for\n    solving certain problems.  An extreme case of inefficiency occurs when\n    the system falls into infinite loops in making deductions.  As a\n    simple example, suppose we are setting up a data base of famous\n    marriages, including\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"assert(married(\"Minnie\", \"Mickey\"))"},{"body":"\n    If we now ask\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"married(\"Mickey\", $who)"},{"body":"\n    we will get no response, because the system doesn't know that if\n    ","tag":"#text"},{"body":"$A$","tag":"LATEX"},{"body":" is married to ","tag":"#text"},{"body":"$B$","tag":"LATEX"},{"body":",\n    then ","tag":"#text"},{"body":"$B$","tag":"LATEX"},{"body":" is married to\n    ","tag":"#text"},{"body":"$A$","tag":"LATEX"},{"body":".  So we assert the rule\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"assert(rule(married($x, $y), \n            married($y, $x)))"},{"body":"\n    and again query\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"married(\"Mickey\", $who)"},{"body":"\n    Unfortunately, this will drive the system into an infinite loop, as\n    follows:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\t    The system finds that the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"married"},{"body":" rule is\n\t    applicable; that is, the rule conclusion\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"married($x, $y)"},{"body":"\n\t    unifies with the query pattern\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"married(\"Mickey\", $who)"},{"body":"\n\t    to produce a frame in which\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n\tis bound to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"Mickey\""},{"body":"\n\tand\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$y"},{"body":"      \n\tis bound to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$who"},{"body":".\n\tSo the interpreter proceeds to evaluate the rule body\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"married($y, $x)"},{"body":"\n\tin this frame—in effect, to process the query\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"married($who, \"Mickey\")"},{"body":".\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t    One answer,\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"married(\"Minnie\", \"Mickey\")"},{"body":",\n\t    appears directly as an assertion in the data base.\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tThe ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"married"},{"body":" rule is also applicable, so the\n\tinterpreter again evaluates the rule body, which this time is equivalent\n\tto\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"married(\"Mickey\", $who)"},{"body":".\n\t  ","tag":"#text"}]}]},{"body":"\n    The system is now in an infinite loop.  Indeed, whether the system\n    will find the simple answer\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"married(\"Minnie\", \"Mickey\")"},{"body":"\n    before it goes into the loop depends on implementation details concerning the\n    order in which the system checks the items in the data base.  This is a very\n    simple example of the kinds of loops that can occur. Collections of\n    interrelated rules can lead to loops that are much harder to anticipate, and\n    the appearance of a loop can depend on the order of clauses in an\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":" (see\n    exercise ","tag":"#text"},{"tag":"REF","body":"4.62","href":"/sicpjs/4.4.3#ex-4.62"},{"body":") or on low-level details\n    concerning the order in which the system processes queries.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/4.4.3#footnote-3"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Problems with ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Another quirk in the query system concerns\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":".\n    Given the data base of\n    section ","tag":"#text"},{"tag":"REF","body":"4.4.1","href":"/sicpjs/4.4.1"},{"body":", consider the\n    following two queries:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"and(supervisor($x, $y),\n    not(job($x, list(\"computer\", \"programmer\"))))\n\nand(not(job($x, list(\"computer\", \"programmer\"))),\n    supervisor($x, $y))"},{"body":"\n    These two queries do not produce the same result.  The first query\n    begins by finding all entries in the data base that match\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"supervisor($x, $y)"},{"body":",\n      \n    and then filters the resulting frames by removing the ones in which the\n    value of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    satisfies\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"job($x,@list(\"computer\", \"programmer\"))"},{"body":".\n      \n    The second query begins by filtering the \n    incoming frames to remove those that can satisfy\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"job($x, list(\"computer\",@\"programmer\"))"},{"body":".\n      \n    Since the only incoming frame is empty, it checks the data base\n    \n        for\n      \n    patterns that satisfy\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"job($x, list(\"computer\", \"programmer\"))"},{"body":".\n      \n    Since there generally are entries of this form, the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" clause filters out the empty frame and\n    returns an empty stream of frames.  Consequently, the entire compound query\n    returns an empty stream.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    The trouble is that our implementation of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":"\n    really is meant to serve as a filter on values for the variables.  If a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" clause is processed with a frame in which\n    some of the variables remain unbound (as does\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$x"},{"body":"\n    in the example above), the system will produce unexpected results. Similar\n    problems occur with the use of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"javascript_predicate"},{"body":"—the\n      \n\tJavaScript\n\tpredicate can't work if some of its variables are unbound.\n      \n    See exercise ","tag":"#text"},{"tag":"REF","body":"4.74","href":"/sicpjs/4.4.4#ex-4.74"},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    There is also a much more serious way in which the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" of the query language differs from the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" of mathematical logic.  In logic, we\n    interpret the statement \"","tag":"#text"},{"body":"not ","tag":"#text"},{"body":"$P$","tag":"LATEX"},{"body":"\" to\n    mean that ","tag":"#text"},{"body":"$P$","tag":"LATEX"},{"body":" is not true.  In the query system,\n    however, \"","tag":"#text"},{"body":"not ","tag":"#text"},{"body":"$P$","tag":"LATEX"},{"body":"\" means that\n    ","tag":"#text"},{"body":"$P$","tag":"LATEX"},{"body":" is not deducible from the knowledge in the\n    data base.  For example, given the personnel data base of\n    section ","tag":"#text"},{"tag":"REF","body":"4.4.1","href":"/sicpjs/4.4.1"},{"body":", the system would\n    happily deduce all sorts of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" statements,\n    such as that Ben Bitdiddle is not a baseball fan, that it is not raining\n    outside, and that ","tag":"#text"},{"body":"$2 + 2$","tag":"LATEX"},{"body":"\n    is not 4.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/4.4.3#footnote-4"},{"body":" In other\n    words, the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" of logic programming languages\n    reflects the so-called \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"closed world assumption","tag":"#text"}]},{"body":" that all relevant information has been\n    included in the data base.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/4.4.3#footnote-5"}]},{"tag":"EXERCISE","title":"Exercise 4.62","id":"#ex-4.62","child":[{"body":"\n    Louis Reasoner mistakenly deletes the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"outranked_by"},{"body":"\n    rule (section ","tag":"#text"},{"tag":"REF","body":"4.4.1","href":"/sicpjs/4.4.1"},{"body":") from the\n    data base.  When he realizes this, he quickly reinstalls it.  Unfortunately,\n    he makes a slight change in the rule, and types it in as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":false,"body":"rule(outranked_by($staff_person, $boss),      \n     or(supervisor($staff_person, $boss),\n        and(outranked_by($middle_manager, $boss),\n            supervisor($staff_person, $middle_manager))))"},{"body":"\n    Just after Louis types this information into the system, DeWitt\n    Aull comes by to find out who outranks Ben Bitdiddle. He issues\n    the query\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":false,"body":"outanked_by(list(\"Bitdiddle\", \"Ben\"), $who)"},{"body":"\n\n    After answering, the system goes into an infinite loop.  Explain why.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.63","id":"#ex-4.63","child":[{"body":"\n    Cy D. Fect, looking forward to the day when he will rise in the\n    organization, gives a query to find all the wheels (using the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"wheel"},{"body":" rule of\n    section ","tag":"#text"},{"tag":"REF","body":"4.4.1","href":"/sicpjs/4.4.1"},{"body":"):\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":false,"body":"wheel($who)"},{"body":"\n    To his surprise, the system responds\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":false,"output":"Query results:\nwheel(list(\"Warbucks\", \"Oliver\"))\nwheel(list(\"Bitdiddle\", \"Ben\"))\nwheel(list(\"Warbucks\", \"Oliver\"))\nwheel(list(\"Warbucks\", \"Oliver\"))\nwheel(list(\"Warbucks\", \"Oliver\"))"},{"body":"\n    Why is Oliver Warbucks listed four times?\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.64","id":"#ex-4.64","child":[{"body":"\n    Ben has been\n    \n    generalizing the query system to provide statistics about the\n    company.  For example, to find the total salaries of all the computer\n    programmers one will be able to say\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":false,"body":"sum($amount,      \n    and(job($x, list(\"computer\", \"programmer\")),\n        salary($x, $amount)))"},{"body":"\n    In general, Ben's new system allows expressions of the form\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\naccumulation_function($variable$, \n                      $query$-$pattern$)\n      "},{"body":"\n    where\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"accumulation_function"},{"body":"\n    can be things like ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum"},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"average"},{"body":", or\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"maximum"},{"body":".\n    Ben reasons that it should be a cinch to implement this.  He will simply\n    feed the query pattern to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate_query"},{"body":".\n      \n    This will produce a stream of frames.  He will then pass this stream through\n    a mapping function that extracts the value of the designated variable from\n    each frame in the stream and feed the resulting stream of values to the\n    accumulation function.  Just as Ben completes the implementation and is\n    about to try it out, Cy walks by, still puzzling over the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"wheel"},{"body":" query result in\n    exercise ","tag":"#text"},{"tag":"REF","body":"4.63","href":"/sicpjs/4.4.3#ex-4.63"},{"body":".  When Cy shows Ben the\n    system's response, Ben groans, \"","tag":"#text"},{"body":"Oh, no, my simple accumulation\n    scheme won't work!","tag":"#text"},{"body":"\"\n    What has Ben just realized?  Outline a method he can use to salvage the\n    situation.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.65","id":"#ex-4.65","child":[{"body":"\n    Devise a\n    \n    way to install a loop detector in the query system so as to\n    avoid the kinds of simple loops illustrated in the text and in\n    exercise ","tag":"#text"},{"tag":"REF","body":"4.62","href":"/sicpjs/4.4.3#ex-4.62"},{"body":".  The general idea is\n    that the system should maintain some sort of history of its current chain of\n    deductions and should not begin processing a query that it is already\n    working on.  Describe what kind of information (patterns and frames)\n    is included in this history, and how the check should be made.  (After\n    you study the details of the query-system implementation in\n    section ","tag":"#text"},{"tag":"REF","body":"4.4.4","href":"/sicpjs/4.4.4"},{"body":", you may\n    want to modify the system to include your loop detector.)\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.66","id":"#ex-4.66","child":[{"body":"\n    Define rules to implement the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reverse"},{"body":" operation\n    of exercise ","tag":"#text"},{"tag":"REF","body":"2.18","href":"/sicpjs/2.2.1#ex-2.18"},{"body":", which returns a list containing\n    the same elements as a given list\n\t  in reverse order.\n    (Hint: Use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_to_form"},{"body":".)\n      \n    Can your rules answer both\n    the query\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reverse(list(1, 2, 3), $x)"},{"body":"\n    and the query ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reverse($x, list(1, 2, 3))"},{"body":"?\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.67","id":"#ex-4.67","child":[{"body":"\n\tLet us modify the data base and the rules of\n\texercise ","tag":"#text"},{"tag":"REF","body":"4.61","href":"/sicpjs/4.4.1#ex-4.61"},{"body":" to add \n\t\"","tag":"#text"},{"body":"great","tag":"#text"},{"body":"\" to a grandson relationship. This should enable the\n\tsystem to deduce that Irad is the great-grandson of Adam, or that Jabal\n\tand Jubal are the great-great-great-great-great-grandsons of Adam.\n\t","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\t    Change the assertions in the data base such that there is only one\n\t    kind of relationship information, namely\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"related"},{"body":". The first item\n\t    then describes the relationship. Thus, instead of\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"son(\"Adam\", \"Cain\")"},{"body":", you would\n\t    write\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"related(\"son\", \"Adam\", \"Cain\")"},{"body":".\n\t    Represent the fact about Irad, for example, as\n\t    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":13,"eval":false,"body":"related(list(\"great\", \"grandson\"), \"Adam\", \"Irad\")"}]},{"tag":"LI","child":[{"body":"\n\t    Write rules that determine if a list ends in the word\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"grandson\""},{"body":".\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t    Use this to express a rule that allows one to derive the relationship\n\t    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":14,"eval":false,"body":"list(pair(\"great\", $rel), $x, $y)"},{"body":"\n\t    where ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"$rel"},{"body":" is a list ending in\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"grandson\""},{"body":".\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t    Check your rules on the queries\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"related(list(\"great\", \"grandson\"), $g, $ggs)"},{"body":"\n\t    and\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"related($relationship, \"Adam\", \"Irad\")"},{"body":".\n\t  ","tag":"#text"}]}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/4.4.3#footnote-link-1","child":[{"body":"That a particular method of inference is\n    legitimate is not a trivial assertion.  One must prove that if one\n    starts with true premises, only true conclusions can be derived.  The\n    method of inference represented by rule applications is \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"modus ponens","tag":"#text"}]},{"body":",\n    the familiar method of inference that says that if ","tag":"#text"},{"tag":"EM","child":[{"body":"A","tag":"#text"}]},{"body":" is\n    true and ","tag":"#text"},{"tag":"EM","child":[{"body":"A implies B","tag":"#text"}]},{"body":" is true, then we may conclude that ","tag":"#text"},{"tag":"EM","child":[{"body":"B","tag":"#text"}]},{"body":"\n    is true.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/4.4.3#footnote-link-2","child":[{"body":"We must qualify this statement by\n    agreeing that, in speaking of the \"","tag":"#text"},{"body":"inference","tag":"#text"},{"body":"\" accomplished\n    by a logic program, we assume that the computation terminates.\n    Unfortunately, even this qualified statement is false for our\n    implementation of the query language (and also false for programs in\n    Prolog and most other current logic programming languages) because of\n    our use of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"javascript_predicate"},{"body":".\n      \n    As we will describe below, the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" implemented\n    in the query language is not always consistent with the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" of mathematical logic, and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"javascript_predicate"},{"body":"\n    introduces additional complications.  We could implement a language\n    consistent with mathematical logic by simply removing\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"javascript_predicate"},{"body":"\n    from the language and agreeing to write programs using only simple queries,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"and"},{"body":", and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"or"},{"body":".\n    However, this would greatly restrict the expressive power of the language.\n    One of the major concerns of research in logic programming was to find ways\n    to achieve more consistency with mathematical logic without unduly\n    sacrificing expressive power.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/4.4.3#footnote-link-3","child":[{"body":"This is\n    not a problem of the logic but one of the procedural interpretation of the\n    logic provided by our interpreter. We could write an interpreter that would\n    not fall into a loop here. For example, we could enumerate all the proofs\n    derivable from our assertions and our rules in a breadth-first rather than a\n    depth-first order.  However, such a system makes it more difficult to take\n    advantage of the order of deductions in our programs.  One attempt to\n    build sophisticated control into such a program is described in\n    de Kleer et al. 1977.  \n    Another technique, which does not lead to such serious control problems, is\n    to put in special knowledge, such as detectors for particular kinds of loops\n    (exercise ","tag":"#text"},{"tag":"REF","body":"4.65","href":"/sicpjs/4.4.3#ex-4.65"},{"body":").  However, there can\n    be no general scheme for reliably preventing a system from going down\n    infinite paths in performing deductions.  Imagine a diabolical rule of\n    the form \"","tag":"#text"},{"body":"To show ","tag":"#text"},{"body":"$P(x)$","tag":"LATEX"},{"body":" is true, show that\n    ","tag":"#text"},{"body":"$P(f(x))$","tag":"LATEX"},{"body":" is true,","tag":"#text"},{"body":"\" for some suitably\n    chosen function ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/4.4.3#footnote-link-4","child":[{"body":"Consider the query\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not(baseball_fan(list(\"Bitdiddle\", \"Ben\")))"},{"body":".\n      \n    The system finds that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"baseball_fan(list(\"Bitdiddle\", \"Ben\"))"},{"body":"\n    is not in the data base, so the empty frame does not satisfy the pattern and\n    is not filtered out of the initial stream of frames.  The result of the\n    query is thus the empty frame, which is used to instantiate the input query\n    to produce\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not(baseball_fan(list(\"Bitdiddle\", \"Ben\")))"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/4.4.3#footnote-link-5","child":[{"body":"A discussion and justification of this\n    treatment of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"not"},{"body":" can be found in the article\n    \"","tag":"#text"},{"body":"Negation as Failure","tag":"#text"},{"body":"\" by\n    \n    Clark (1978).","tag":"#text"}]}]