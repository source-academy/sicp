[{"id":"/sicpjs/2.3.4","tag":"TITLE","body":"2.3.4  \n    Example: Huffman Encoding Trees"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    This section provides practice in the use of list structure and data\n    abstraction to manipulate sets and trees.  The application is to\n    methods for representing data as sequences of ones and zeros (bits).\n    For example, the\n    \n    ASCII standard code used to represent text in\n    computers encodes each\n    \n    character as a sequence of seven bits.  Using\n    seven bits allows us to distinguish ","tag":"#text"},{"body":"$2^7$","tag":"LATEX"},{"body":", or\n    128, possible different characters.  In general, if we want to distinguish\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" different symbols, we will need to use\n    ","tag":"#text"},{"body":"$\\log_2 n$","tag":"LATEX"},{"body":" bits per symbol.  If all our messages\n    are made up of the eight symbols A, B, C, D, E, F, G, and H, we can choose\n    a code with three bits per character, for example\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"A","tag":"#text"}]},{"tag":"TD","child":[{"body":"000","tag":"#text"}]},{"tag":"TD","child":[{"body":"           ","tag":"#text"}]},{"tag":"TD","child":[{"body":"C","tag":"#text"}]},{"tag":"TD","child":[{"body":"010","tag":"#text"}]},{"tag":"TD","child":[{"body":"           ","tag":"#text"}]},{"tag":"TD","child":[{"body":"E","tag":"#text"}]},{"tag":"TD","child":[{"body":"100","tag":"#text"}]},{"tag":"TD","child":[{"body":"           ","tag":"#text"}]},{"tag":"TD","child":[{"body":"G","tag":"#text"}]},{"tag":"TD","child":[{"body":"110","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"B","tag":"#text"}]},{"tag":"TD","child":[{"body":"001","tag":"#text"}]},{"tag":"TD"},{"tag":"TD","child":[{"body":"D","tag":"#text"}]},{"tag":"TD","child":[{"body":"011","tag":"#text"}]},{"tag":"TD"},{"tag":"TD","child":[{"body":"F","tag":"#text"}]},{"tag":"TD","child":[{"body":"101","tag":"#text"}]},{"tag":"TD"},{"tag":"TD","child":[{"body":"H","tag":"#text"}]},{"tag":"TD","child":[{"body":"111","tag":"#text"}]}]}]},{"body":"\n    With this code, the message\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\nBACADAEAFABBAAAGAH","tag":"#text"}]}]}]},{"body":"\n    is encoded as the string of 54 bits\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n001000010000011000100000101000001001000000000110000111","tag":"#text"}]}]}]}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Codes such as ASCII and the A-through-H code above are known as\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"fixed-length","tag":"#text"}]},{"body":" codes, because they represent each symbol in the\n    message with the same number of bits.  It is sometimes advantageous to use\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"variable-length","tag":"#text"}]},{"body":" codes, in which different symbols may be\n    represented by different numbers of bits.  For example,\n    \n    Morse code does not use the same number of dots and dashes for each letter\n    of the alphabet.  In particular, E, the most frequent letter, is represented\n    by a single dot.  In general, if our messages are such that some symbols\n    appear very frequently and some very rarely, we can encode data more\n    efficiently (i.e., using fewer bits per message) if we assign shorter\n    codes to the frequent symbols.  Consider the following alternative code for\n    the letters A through H:\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"A","tag":"#text"}]},{"tag":"TD","child":[{"body":"0","tag":"#text"}]},{"tag":"TD","child":[{"body":"           ","tag":"#text"}]},{"tag":"TD","child":[{"body":"C","tag":"#text"}]},{"tag":"TD","child":[{"body":"1010","tag":"#text"}]},{"tag":"TD","child":[{"body":"           ","tag":"#text"}]},{"tag":"TD","child":[{"body":"E","tag":"#text"}]},{"tag":"TD","child":[{"body":"1100","tag":"#text"}]},{"tag":"TD","child":[{"body":"           ","tag":"#text"}]},{"tag":"TD","child":[{"body":"G","tag":"#text"}]},{"tag":"TD","child":[{"body":"1110","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"B","tag":"#text"}]},{"tag":"TD","child":[{"body":"100","tag":"#text"}]},{"tag":"TD"},{"tag":"TD","child":[{"body":"D","tag":"#text"}]},{"tag":"TD","child":[{"body":"1011","tag":"#text"}]},{"tag":"TD"},{"tag":"TD","child":[{"body":"F","tag":"#text"}]},{"tag":"TD","child":[{"body":"1101","tag":"#text"}]},{"tag":"TD"},{"tag":"TD","child":[{"body":"H","tag":"#text"}]},{"tag":"TD","child":[{"body":"1111","tag":"#text"}]}]}]},{"body":"\n    With this code, the same message as above is encoded as the string\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n100010100101101100011010100100000111001111\n    ","tag":"#text"}]}]}]},{"body":"\n    This string contains 42 bits, so it saves more than 20% in space in\n    comparison with the fixed-length code shown above.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    One of the difficulties of using a variable-length code is knowing\n    when you have reached the end of a symbol in reading a sequence of\n    zeros and ones.  Morse code solves this problem by using a special\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"separator code","tag":"#text"}]},{"body":" (in this case, a pause) after the sequence of\n    dots and dashes for each letter.  Another solution is to design the\n    code in such a way that no complete code for any symbol is the\n    beginning (or ","tag":"#text"},{"tag":"EM","child":[{"body":"prefix","tag":"#text"}]},{"body":") of the code for another symbol.  Such a\n    code is called a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"prefix code","tag":"#text"}]},{"body":".  In the example above, A is encoded by 0 and B is\n    encoded by 100, so no other symbol can have a code that begins with 0 or\n    with 100.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    In general, we can attain significant savings if we use\n    variable-length prefix codes that take advantage of the relative\n    frequencies of the symbols in the messages to be encoded.  One\n    particular scheme for doing this is called the Huffman encoding\n    method, after its discoverer,\n    \n    David Huffman.  A Huffman code can be represented as a\n    \n    binary tree whose leaves are the symbols that are encoded.  At each\n    non-leaf node of the tree there is a set containing all the symbols in the\n    leaves that lie below the node.  In addition, each symbol at a leaf is\n    assigned a weight (which is its relative frequency), and each non-leaf\n    node contains a weight that is the sum of all the weights of the leaves\n    lying below it.  The weights are not used in the encoding or the decoding\n    process.  We will see below how they are used to help construct the tree.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"tag":"FIGURE","scale":"70%","src":"img_original/ch2-Z-G-53.svg","id":"#fig-2.18","captionHref":"/sicpjs/2.3.4#fig-2.18","captionName":"Figure 2.18 ","captionBody":[{"body":"A Huffman encoding tree.","tag":"#text"}]},{"body":"\n    Figure ","tag":"#text"},{"tag":"REF","body":"2.18","href":"/sicpjs/2.3.4#fig-2.18"},{"body":" shows the Huffman tree for the\n    A-through-H code given above.  The weights at the leaves indicate that the\n    tree was designed for messages in which A appears with relative frequency\n    8, B with relative frequency 3, and the other letters each with relative\n    frequency 1.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Given a Huffman tree, we can find the encoding of any symbol by\n    starting at the root and moving down until we reach the leaf that\n    holds the symbol.  Each time we move down a left branch we add a 0 to\n    the code, and each time we move down a right branch we add a 1.  (We\n    decide which branch to follow by testing to see which branch either is\n    the leaf node for the symbol or contains the symbol in its set.)  For\n    example, starting from the root of the tree in\n    figure ","tag":"#text"},{"tag":"REF","body":"2.18","href":"/sicpjs/2.3.4#fig-2.18"},{"body":", we arrive at the leaf for D by\n    following a right branch, then a left branch, then a right branch, then a\n    right branch; hence, the code for D is 1011.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    To decode a bit sequence using a Huffman tree, we begin at the root\n    and use the successive zeros and ones of the bit sequence to determine\n    whether to move down the left or the right branch.  Each time we come\n    to a leaf, we have generated a new symbol in the message, at which\n    point we start over from the root of the tree to find the next symbol.\n    For example, suppose we are given the tree above and the sequence\n    10001010.  Starting at the root, we move down the right branch (since\n    the first bit of the string is 1), then down the left branch (since\n    the second bit is 0), then down the left branch (since the third bit\n    is also 0).  This brings us to the leaf for B, so the first\n    symbol of the decoded message is B.  Now we start again at the root,\n    and we make a left move because the next bit in the string is 0.\n    This brings us to the leaf for A.  Then we start again at the root\n    with the rest of the string 1010, so we move right, left, right, left and\n    reach C. Thus, the entire message is BAC.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Generating Huffman trees","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    Given an \"","tag":"#text"},{"body":"alphabet","tag":"#text"},{"body":"\" of symbols and their relative frequencies,\n    how do we construct the \"","tag":"#text"},{"body":"best","tag":"#text"},{"body":"\" code?  (In other words, which\n    tree will encode messages with the fewest bits?)  Huffman gave an algorithm\n    for doing this and showed that the resulting code is indeed the best\n    variable-length code for messages where the relative frequency of the\n    symbols matches the frequencies with which the code was constructed.\n    \n    We will not prove this optimality of Huffman codes here, but we will\n    show how Huffman trees are constructed.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/2.3.4#footnote-1"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    The algorithm for generating a Huffman tree is very simple. The idea\n    is to arrange the tree so that the symbols with the lowest frequency\n    appear farthest away from the root. Begin with the set of leaf nodes,\n    containing symbols and their frequencies, as determined by the initial data\n    from which the code is to be constructed. Now find two leaves with\n    the lowest weights and merge them to produce a node that has these\n    two nodes as its left and right branches. The weight of the new node\n    is the sum of the two weights. Remove the two leaves from the\n    original set and replace them by this new node. Now continue this\n    process. At each step, merge two nodes with the smallest weights,\n    removing them from the set and replacing them with a node that has\n    these two as its left and right branches. The process stops when\n    there is only one node left, which is the root of the entire tree.\n    Here is how the Huffman tree of figure ","tag":"#text"},{"tag":"REF","body":"2.18","href":"/sicpjs/2.3.4#fig-2.18"},{"body":" was\n    generated:\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      Initial leaves\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"$\\{$","tag":"LATEX"},{"body":"(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)","tag":"#text"},{"body":"$\\}$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      Merge\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"$\\{$","tag":"LATEX"},{"body":"(A 8) (B 3) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"C D","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 2) (E 1) (F 1) (G 1) (H 1)","tag":"#text"},{"body":"$\\}$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      Merge\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"$\\{$","tag":"LATEX"},{"body":"(A 8) (B 3) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"C D","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 2) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"E F","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 2) (G 1) (H 1)","tag":"#text"},{"body":"$\\}$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      Merge\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"$\\{$","tag":"LATEX"},{"body":"(A 8) (B 3) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"C D","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 2) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"E F","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 2) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"G H","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 2)","tag":"#text"},{"body":"$\\}$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      Merge\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"$\\{$","tag":"LATEX"},{"body":"(A 8) (B 3) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"C D","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 2) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"E F G H","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 4)","tag":"#text"},{"body":"$\\}$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      Merge\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"$\\{$","tag":"LATEX"},{"body":"(A 8) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"B C D","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 5) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"E F G H","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 4)","tag":"#text"},{"body":"$\\}$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      Merge\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"$\\{$","tag":"LATEX"},{"body":"(A 8) (","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"B C D E F G H","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 9)","tag":"#text"},{"body":"$\\}$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      Final merge\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"$\\{$","tag":"LATEX"},{"body":"(","tag":"#text"},{"body":"$\\{$","tag":"LATEX"},{"body":"A B C D E F G H","tag":"#text"},{"body":"$\\}$","tag":"LATEX"},{"body":" 17)","tag":"#text"},{"body":"$\\}$","tag":"LATEX"}]}]}]},{"body":"\n    The algorithm does not always specify a unique tree, because there may\n    not be unique smallest-weight nodes at each step.  Also, the choice of\n    the order in which the two nodes are merged (i.e., which will be the\n    right branch and which will be the left branch) is arbitrary.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Representing Huffman trees","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    In the exercises below we will work with a system that uses\n    Huffman trees to encode and decode messages and generates Huffman\n    trees according to the algorithm outlined above.  We will begin by\n    discussing how trees are represented.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    Leaves of the tree are represented by a list consisting of the\n    string ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"leaf\""},{"body":",\n      \n    the symbol at the leaf, and the weight:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-DI6S0ZhGbzGVk47AWsAQQdQAA4vfDcpmf4GY8uvIA","body":"function make_leaf(symbol, weight) {\n    return list(\"leaf\", symbol, weight);\n}\nfunction is_leaf(object) {\n    return head(object) === \"leaf\";\n}\nfunction symbol_leaf(x) { return head(tail(x)); }\n\nfunction weight_leaf(x) { return head(tail(tail(x))); } "},{"body":"\n    A general tree will be a list of\n    \n\ta string ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"code_tree\""},{"body":",\n      \n    a left branch, a right branch, a set\n    of symbols, and a weight.  The set of symbols will be simply a list of\n    the symbols, rather than some more sophisticated set representation.\n    When we make a tree by merging two nodes, we obtain the weight of the\n    tree as the sum of the weights of the nodes, and the set of symbols as\n    the union of the sets of symbols for the nodes.  Since our symbol sets are\n    represented as lists, we can form the union by using the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":"function\n    we defined in section ","tag":"#text"},{"tag":"REF","body":"2.2.1","href":"/sicpjs/2.2.1"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":26,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-OY7A4ZBoaU4+P4RwoMm+UziIqxZgsVmsJrNHHxDnJbGONp+UiVjL0TAADiG2CQMsiuKirWpHNSUfxbR544GgwKppafepQABqTOqZM-ba63AmkiWRjCGYcACMeUYrE4uJsAEEvQAOHUVqsMGu4jgoRuGlthGwAIS9GB1uFHxtN5uu-H7tbrMlXg5QXiAA","body":"function make_code_tree(left, right) {\n    return list(\"code_tree\", left, right,\n                append(symbols(left), symbols(right)),\n                weight(left) + weight(right));\n} "},{"body":"\n    If we make a tree in this way, we have the following selectors:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":17,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAquZ2DjIaNM4KQzZ+HgIKGX13dS0dPUM2swsra1Pzjku2GwHKBbvcDE8pK8EtDoUwAA5wtgkDI1SSCG5sO5qRyiWrox5TQaQmEkvRuKYYrGgADUEye-AJHi8vj2AUqZkx0zE+iY5GUKyuLXei063Q2AsB212owO9EZXJ5fIlbCFSXaovWa1W-QBKqlI327OquLRyriUIW7RCdgEurUFpJAH4QV8hCa6jazfbSXoAFxLLqanXi7Ve7Ysw3jcmqM0vBLCq2CGZmh0w53R6aeu2p6H+jWhgshkOCwbhkanEiWRjCGYcACMeUYrE4nusAEFgQAOZkVqsMGs2jgoRtHFthGwAIWBGB7dD7Nd1I+bJzOFyu-H7tbrMk3g5QzNwGY3C8FniAA","body":"function left_branch(tree) { return head(tail(tree)); }\n\nfunction right_branch(tree) { return head(tail(tail(tree))); }\n\nfunction symbols(tree) {\n    return is_leaf(tree)\n           ? list(symbol_leaf(tree))\n           : head(tail(tail(tail(tree))));\n}\nfunction weight(tree) {\n    return is_leaf(tree)\n           ? weight_leaf(tree)\n           : head(tail(tail(tail(tail(tree)))));\n} "},{"body":"\n    The\n    functions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"symbols"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"weight"},{"body":" must do something slightly different\n    depending on whether they are called with a leaf or a general tree.\n    These are simple examples of\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"\n      generic\n    functions","tag":"#text"}]},{"body":"(functions\n    that can handle more than one kind of data), which we will have much more\n    to say about in sections ","tag":"#text"},{"tag":"REF","body":"2.4","href":"/sicpjs/2.4"},{"body":"\n    and ","tag":"#text"},{"tag":"REF","body":"2.5","href":"/sicpjs/2.5"},{"body":".\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"\n      The decoding\n      function","tag":"#text"}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    The following\n    function\n    implements the decoding algorithm. It takes as arguments a list of zeros\n    and ones, together with a Huffman tree.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":32,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-OY7A4ZBoaU4+P4RwoMm+UziIqxZgsVmsJrNHHxDnJbGONp+UiVjL0TAADiG2CQMsiuKirWpHNSUfxbR544GgwKppafepQABqTOqZM-ba6vnjM1utj8MRUCiCGSS4UJBEVmKmzgARhrdYboDIJkMJF+5zIyntQaoBFA-BCJCIXH6tfrg2bGd0jtA88X3iDPlAbBjbDX65NJEsW7YjRHFzy-eUNBogk4p1Hl1Vy8EafXP9-f4H+hDjeY46r+m44mE-AkFewHjumP5kiGvT6FSzh1LiUEwRwr4XN+f6-pWHYcN2XKfvGoCSlK+FEiyhHuiREJkTI0HXthfwgbujJ+Ak3GYkk7R0V2Pb1o2ry8uWVRjo+z5sW+wkyDhIEnqK9DLnkBQAAzwboZJWrJ-yKXBP4smp+S5KAnbaaSBg-PpY41uxRnriybCATQKHLjI1hiF0oBqQAtP597SS+jnWDqIxnheDDCDMxF3oanAYdYACCXoABw6lFFCMLFuIcCgCWsElkHWAAQl6GA6rg2W5R61xFUaVb1YC-AxXFnYyO1+UoNVgmWs6-AaTInUWTIGnke1kqeEAA","body":"function decode(bits, tree) {\n    function decode_1(bits, current_branch) {\n        if (is_null(bits)) {\n            return null;\n        } else {\n            const next_branch = choose_branch(head(bits),\n                                              current_branch);\n            return is_leaf(next_branch)\n                   ? pair(symbol_leaf(next_branch),\n                          decode_1(tail(bits), tree))\n                   : decode_1(tail(bits), next_branch);\n        }\n    }\n    return decode_1(bits, tree);\n}\n\nfunction choose_branch(bit, branch) {\n    return bit === 0\n           ? left_branch(branch)\n           : bit === 1\n           ? right_branch(branch)\n           : error(bit, \"bad bit -- choose_branch\");\n} "},{"body":"\n    The\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"decode_1"},{"body":"\n    takes two arguments: the list of remaining bits and the current position in\n    the tree.  It keeps moving \"","tag":"#text"},{"body":"down","tag":"#text"},{"body":"\" the tree, choosing a left or\n    a right branch according to whether the next bit in the list is a zero or a\n    one.  (This is done with the\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"choose_branch"},{"body":".)\n      \n    When it reaches a leaf, it returns the symbol at that leaf as the next\n    symbol in the message by\n    \n\tadjoining\n\tit to the result of decoding the rest of the message,\n\tstarting at the root of the tree.\n      \n    Note the error check in the final clause of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"choose_branch"},{"body":",\n      \n      which complains if the\n      function\n    finds something other than a zero or a one in the input data.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h4","child":[{"body":"Sets of weighted elements","tag":"#text"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    In our representation of trees, each non-leaf node contains a set of\n    symbols, which we have represented as a simple list.  However, the\n    tree-generating algorithm discussed above requires that we also work\n    with sets of leaves and trees, successively merging the two smallest\n    items.  Since we will be required to repeatedly find the smallest item\n    in a set, it is convenient to use an ordered representation for this\n    kind of set.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n    We will represent a set of leaves and trees as a list of elements,\n    arranged in increasing order of weight.\n    The following\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":"function\n    for constructing sets is similar to the one\n    described in exercise ","tag":"#text"},{"tag":"REF","body":"2.61","href":"/sicpjs/2.3.3#ex-2.61"},{"body":"; however, items\n    are compared by their weights, and the element being added to the set is\n    never already in it.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":26,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-K6kRoVBIHEERiajiMcRFWOC4pIRC4-XN6iVRLJFKszXdCRZctUA1AAB4BVN+KrXfTGQkyQAHXr6S3Va2+5mgBNUJOR60yQ3G02u5NcqPbXW4Mh0SyMYQzDgARjyjFYnFxNgAgg5QAAOHWVkjVhi13EcFBN5jsWnWABCXYwOtw+ZNZotQ7r9bzaSNy6La5HKBkjud2yAA","body":"function adjoin_set(x, set) {\n    return is_null(set)\n           ? list(x)\n           : weight(x) < weight(head(set))\n           ? pair(x, set)\n           : pair(head(set), adjoin_set(x, tail(set)));\n} "}]},{"tag":"TEXT","id":"#p15","child":[{"body":"\n    The following\n    function\n    takes a list of symbol-frequency pairs such as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"list(list(\"A\", 4), list(\"B\", 2), list(\"C\", 1), list(\"D\", 1))"},{"body":"\n    and constructs an initial ordered set of leaves, ready to be merged\n    according to the Huffman algorithm:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":34,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-K6kRoVBIHEERiajiMcRFWOC4pIRC4-XN6iVRLJFKszXdCRZctUA1AAB4BVN+KrXfTGQkyQAHXr6S3Va2+5mgBNUJOR60yQ3G02u5NcqPbXV88bMdgzM0WzP6QQ2hJUAigfghR3O-j1xtNxl20CdrjeBI+UBsLjm4Uxsh0SygAhZywcet5VkZHs6mMD-Mm2tWNMx3RVzi4iPLRcN6b1tQyRkgarUySHo+v1Vcy-Lm+DGQPgiGABHIg2HIYQXxjE8ayLLlNzLUdy0g3F934ckLCsVDKWsABBBxQGwW9wKPL0bAAIVwlACNfKjiOsaBcIARkoqiiLQmwABEGI0LjPCAA","body":"function make_leaf_set(pairs) {\n    if (is_null(pairs)) {\n        return null;\n    } else {\n        const first_pair = head(pairs);\n        return adjoin_set(\n                   make_leaf(head(first_pair),        // symbol\n                             head(tail(first_pair))), // frequency\n                   make_leaf_set(tail(pairs)));\n    }\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.67","id":"#ex-2.67","child":[{"body":"Declare\n    an encoding tree and a sample message:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":32,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-OY7A4ZBoaU4+P4RwoMm+UziIqxZgsVmsJrNHHxDnJbGONp+UiVjL0TAADiG2CQMsiuKirWpHNSUfxbR544GgwKppafepQABqTOqZM-ba63AmkiWapMBghnge655RisThu83XfiGzi4mwAQS92DTGeHI6JXeNpvbgM7Ldp1gAQl6UEPR6u18Px22G9P0+u9+vxz3rAARL0ARhX+6v+8PYRs0HP2u8Farghrdc4DDYgjfijYTYpKwAAYZDPUCZBA0BILAqDwNg0AYMQiCvCAA","body":"const sample_tree = make_code_tree(make_leaf(\"A\", 4),\n                                   make_code_tree(make_leaf(\"B\", 2),\n                                                  make_code_tree(\n                                                      make_leaf(\"D\", 1),\n                                                      make_leaf(\"C\", 1))));\nconst sample_message = list(0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0); "},{"body":"\n    Use the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"decode"},{"body":"function\n    to decode the message, and give the result.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":63,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-OY7A4ZBoaU4+P4RwoMm+UziIqxZgsVmsJrNHHxDnJbGONp+UiVjL0TAADiG2CQMsiuKirWpHNSUfxbR544GgwKppafepQABqTOqZM-ba6vnjM1utj8MRUCiCGSS4UJBEVmKmzgARhrdYboDIJkMJF+5zIyntQaoBFA-BCJCIXH6tfrg2bGd0jtA88X3iDPlAbBjbDX65NJEsW7YjRHFzy-eUNBogk4p1Hl1Vy8EafXP9-f4H+hDjeY46r+m44mE-AkFewHjumP5kiGvT6FSzh1LiUEwRwr4XN+f6-pWHYcN2XKfvGoCSlK+FEiyhHuiREJkTI0HXthfwgbujJ+Ak3GYkk7R0V2Pb1o2ry8uWVRjo+z5sW+wkyDhIEnqK9DLnkBQAAzwboZJWrJ-yKXBP4smp+S5KAnbaaSBg-PpY41uxRnriybCATQKHLjI1hiF0oBqQAtP597SS+jnWDqIxnheghMAwIY8B61x3oanBVolgL8CltLWAAgl62B4dRRW6FlaUWllGHWAAQl6KCFcVDW-qVREWlZjXtQkFWQdYAAiXqdvVHVDYyXUNNY0D9dq3hRRQ1SxfFnAMGwggxYox7mRSVgaTInY7TI22gAdu2HXtJ0Wadx0aTquCCUI80JUtK1MGtjj3eaYm4CA1QPguaR+WwLIANq5V6wN9TIwN5RD1WgzD0MTdDUNbguXAALroxjqNAA","body":"decode(sample_message, sample_tree);\n// should be: [\"A\", [\"D\", [\"A\", [\"B\", [\"B\", [\"C\", [\"A\", null]]]]]]] "}]},{"tag":"EXERCISE","title":"Exercise 2.68","id":"#ex-2.68","child":[{"body":"\n    The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"encode"},{"body":"function\n    takes as arguments a message and a tree and produces the list of bits that\n    gives the encoded message.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":true,"prependLength":3,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuRQBTAOwGMB7AEyIH0BnATwFsAjCgG1ADMBXcgC4BLCiVACKoVkVAB3AE5CBA0lMah6A3jRID6+PoJFjSlGgApmRevQCGAcyIAacfKJEAlKADeuUP9A3LXkxIXpaEl4ODktrO0cPPwDkgIB+UEjopJTkgC5QWwAHQtIqc1NqOiY2TnMACyJbMqsbB08XATd27Jze5IqLAVshGJb49td3Dw8AblwAXyA","body":"function encode(message, tree) {\n    return is_null(message)\n           ? null\n           : append(encode_symbol(head(message), tree),\n                    encode(tail(message), tree));\n} "},{"body":"\n\tThe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"encode_symbol"},{"body":",\n\twhich you must write, returns the list of bits that encodes a given symbol\n\taccording to\n\ta given tree.\n      \n    You should design\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"encode_symbol"},{"body":"\n    so that it signals an error if the symbol is not in the tree at all.\n    Test your\n    function\n    by encoding the result you obtained in\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.67","href":"/sicpjs/2.3.4#ex-2.67"},{"body":" with the sample tree and\n    seeing whether it is the same as the original sample message.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":11,"eval":true,"prependLength":72,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-OY7A4ZBoaU4+P4RwoMm+UziIqxZgsVmsJrNHHxDnJbGONp+UiVjL0TAADiG2CQMsiuKirWpHNSUfxbR544GgwKppafepQABqTOqZM-ba6vnjM1utj8MRUCiCGSS4UJBEVmKmzgARhrdYboDIJkMJF+5zIyntQaoBFA-BCJCIXH6tfrg2bGd0jtA88X3iDPlAbBjbDX65NJEsW7YjRHFzy-eUNBogk4p1Hl1Vy8EafXP9-f4H+hDjeY46r+m44mE-AkFewHjumP5kiGvT6FSzh1LiUEwRwr4XN+f6-pWHYcN2XKfvGoCSlK+FEiyhHuiREJkTI0HXthfwgbujJ+Ak3GYkk7R0V2Pb1o2ry8uWVRjo+z5sW+wkyDhIEnqK9DLnkBQAAzwboZJWrJ-yKXBP4smp+S5KAnbaaSBg-PpY41uxRnriybCATQKHLjI1hiF0oBqQAtP597SS+jnWDqIwgAe5BEdGoCtlUFA0H5x6yN8FAUBGfnCNUxhmsOgh6mMVQRlW-AMGwgiCEwihsKJMLKeB4rbv0FVVTVBIIVuC5cFZLKhuGkb8KVsWJv0qptdVtXkZKAbUUSI1mmqk0dTNWriWeF7VQwIY8B61x3oanBVvtgLlawnAYdYACCXrYHh82PUdxpERaz1XQAQl6KAPY9f2-s9J0WlZ-2gwk72QdYAAiXqdr9YMI4yEMNNY0Cw9q3ibRQ1RMDte0rbVd4UlYGkyJ2ZMyKToBU+T1MU3TFn07TGk6hJ9CLZw0aobU9XoiKCX0GeqznhwXPRjIAFAadfNBpuACEoBzj15VsOIrncy41RjaiksRtMlGgXovG6FOM4QQ0lHKQkm4tZxuj7oez5W3oWPesc0tEzmdmXJK3gAJCuym+sHeZQfe3S-ubkLvQi2LY0yHpkog3oiHIfwVMc6LY0a9IbvBzCVH4Sy0dULH2fizZ8pJ9RqdUChtOZ3HaF+lXWrJ7oLluSh1hxSQNDYwQNCkGkoCBdFJ3RuFdu7CMbAAI5EEw-Qc-wglCLju2cATdU43j5qvHNv7bZv0vw7vJ-b14QA","body":"function encode_symbol(symbol, tree) {\n    function contains_symbol(symbol, current_tree) {\n        return ! is_null(member(symbol, symbols(current_tree)));\n    }\n    if (is_leaf(tree)) {\n        return null;\n    } else {\n        const left_tree = left_branch(tree);\n\tconst right_tree = right_branch(tree);\n\treturn contains_symbol(symbol, left_tree)\n               ? pair(0, encode_symbol(symbol, left_tree))\n               : contains_symbol(symbol, right_tree)\n               ? pair(1, encode_symbol(symbol, right_tree))\n               : error(\"symbol not found -- encode_symbol\");\n    }\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.69","id":"#ex-2.69","child":[{"body":"\n    The following\n    function\n    takes as its argument a list of symbol-frequency pairs (where no symbol\n    appears in more than one pair) and generates a Huffman encoding tree\n    according to the Huffman algorithm.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":true,"prependLength":48,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-K6kRoVBIHEERiajiMcRFWOC4pIRC4-XN6iVRLJFKszXdCRZctUA1AAB4BVN+KrXfTGQkyQAHXr6S3Va2+5mgBNUJOR60yQ3G02u5NcqPbXV88bMdgzM0WzP6QQ2hJUAigfghR3O-j1xtNxl20CdrjeBI+UBsLjm4Uxsh0SygAhZywcet5VkZHs6mMD-Mm2tWNMx3RVzi4iPLRcN6b1tQyRkgarUySHo+v1Vcy-Lm+DGQPgiGABHIg2HIYQXxjE8ayLLlNzLUdywfQQiDIMg2EEQQqAAN04Bg2H0RQ2AXfVxgoGhQDEQjZG+CgKBA8jhGqYw0hAig9TGKoCJIPCmFojhlCIAgCGYU18W7RNG2nTEknaJCULQjDsI4XD8LYfhINxfcxKXMsfCAA","body":"function generate_huffman_tree(pairs) {\n    return successive_merge(make_leaf_set(pairs));\n} "},{"body":"\n        The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_leaf_set"},{"body":" \n        that transforms the list of pairs into an ordered set of leaves is\n\tgiven above. Write the function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"successive_merge"},{"body":" using\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_code_tree"},{"body":" to successively\n\tmerge the smallest-weight elements of the set until there is only one\n\telement left, which is the desired Huffman tree.\n      \n    (This\n    function\n    is slightly tricky, but not really complicated.  If you find yourself\n    designing a complex\n    function,\n    then you are almost certainly doing something wrong.  You can take\n    significant advantage of the fact that we are using an ordered set\n    representation.)\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":13,"eval":true,"prependLength":58,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-OY7A4ZBoaU4+P4RwoMm+UziIqxZgsVmsJrNHHxDnJbGONp+UiVjL0TAADiG2CQMsiuKirWpHNSUfxbR544GgwKppafepQABqTOqZM-ba6vnjLqRGhUEgcQRGJqOIz2hKO0AhEhELj9evqdN6MkUqzNfu6FlyotzAA8hasqt79IzujJId6+kb1Wbo9ALNXVHX8+bMkr1drvY3XIXpfh+vGhs4uLrDb3+kELb0VAIoH4Ha7-Rfb7vsSbadt23gJD4oBsDGbDCkGJokJYoAEPulgcC+eSshkAE6kGbYnjWT5WNuQb3rSqooa+0wvvGQYgNUiZcCRS6MqqXKUWhNGDDI9EEIYACORARmQwjMcSZGPueXI4aWEFlvRghEGQZBsIIghUAAbpwDBsPoiiwQi4wUDQoBiLBsjfBQFARqZwjVMYZokBQepjFU+kkLpTDWRwyhEAQBDMLWFo4XBmJJO0inKap6laRwOl6Ww-ASWERH8DJvLllUkUqWpmnabp+nZkwWlvqFuhtjwJCKBQlx2CVGj5LkoAAIzbmSqp1apUosSy2XRXlcUFYlYnBmkVaEeeI3iawnBuua1z8B1vD1QGLFretbEQp1gFputQYalty1dTyZYIUhghMAwIY8B61x5CKZFzbdgJJTNtLWAAgl62C7XtCSPaa80vVNjLJQ01gAEJeigv1-dNRpPRaINLmDAjWAAIl6zWw3DpFvbiNjQFj2reGdFDVJd12cHxbCCcJVCqZhQ6Ws6NhfTIP0yMje3M5D0O0dz6280TMjY1zuN-bzmOi6WuC00QTA9pTN34uLRLuZ53m+f5gXPYlF1XTdNN0+QDOAZ4QA","body":"function successive_merge(leaves) {\n    return length(leaves) === 1\n           ? head(leaves)\n           : successive_merge(\n                 adjoin_set(\n                     make_code_tree(head(leaves),\n                                    head(tail(leaves))),\n                     tail(tail(leaves))));\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.70","id":"#ex-2.70","child":[{"body":"\n    The following eight-symbol alphabet with associated relative\n    frequencies was designed to efficiently encode the lyrics of 1950s\n    \n    rock songs.  (Note that the \"","tag":"#text"},{"body":"symbols","tag":"#text"},{"body":"\" of an\n    \"","tag":"#text"},{"body":"alphabet","tag":"#text"},{"body":"\" need not be individual letters.)\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      A\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"\n\t      2\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"                        ","tag":"#text"}]},{"tag":"TD","child":[{"body":"\n\t      NA\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"\n\t      16\n\t    ","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      BOOM\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"\n\t      1\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":" ","tag":"#text"}]},{"tag":"TD","child":[{"body":"\n\t      SHA\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"  3\n\t    ","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      GET\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"\n\t      2\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":" ","tag":"#text"}]},{"tag":"TD","child":[{"body":"\n\t      YIP\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"  9\n\t    ","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"\n\t      JOB\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"\n\t      2\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":" ","tag":"#text"}]},{"tag":"TD","child":[{"body":"\n\t      WAH\n\t    ","tag":"#text"}]},{"tag":"TD","child":[{"body":"  1\n\t    ","tag":"#text"}]}]}]},{"body":"\n    Use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"generate_huffman_tree"},{"body":"\n    (exercise ","tag":"#text"},{"tag":"REF","body":"2.69","href":"/sicpjs/2.3.4#ex-2.69"},{"body":") to generate a\n    corresponding Huffman tree, and use ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"encode"},{"body":"\n    (exercise ","tag":"#text"},{"tag":"REF","body":"2.68","href":"/sicpjs/2.3.4#ex-2.68"},{"body":") to encode the following\n    message:\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"Get a job","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"Sha na na na na na na na na","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"Get a job","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"Sha na na na na na na na na","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"Wah yip yip yip yip yip yip yip yip yip","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"Sha boom","tag":"#text"}]}]}]},{"body":"\n    How many bits are required for the encoding?  What is the smallest number\n    of bits that would be needed to encode this song if we used a fixed-length\n    code for the eight-symbol alphabet?\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":14,"eval":true,"prependLength":94,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGY0BYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0AbNpggCgDOATwYAjGlwA0oAO5sqAcwAWFAJSgA3rlC7QAJzYUi++lyqCK-AEQ8+1mSPGSZ8parUBuXAF9CpSlp6C25eARoxACs2Sg1tPQMjE3plXgATfgjo2NAAXnzQWzDrbz9icmo6UCcJLlC+fgAPOMTjU1BUpgyKJiouJrUvUD9-CqC5BRUKeoFmrVbkjvT+Hr6V3v7mwc9h-HLAqp4CabF9JnJlFcM2FsM2lOXV-opr7d3Rg-p9dxOzi6u2Dd5ndFp1uht1msXoDBkMRvtKvQapJBACgfE9CD2iE7AJoTcdAkiaAAPygcyWISiWozNGDQnEvQALiWXUhzwhTzpsNKH0REx+dK0DIW2MEtPxahFjLJbimEte0uJLLB7LVXI1r1hXl8ewC-OY7A4ZBoaU4+P4RwoMm+UziIqxZgsVmsJrNHHxDnJbGONp+UiVjL0TAADiG2CQMsiuKirWpHNSUfxbR544GgwKppafepQABqTOqZM-ba6vnjLqRGhUEgcQRGJqOIz2hKO0AhEhELj9evqdN6MkUqzNfu6FlyotzAA8hasqt79IzujJId6+kb1Wbo9ALNXVHX8+bMkr1drvY3XIXpfh+vGhs4uLrDb3+kELb0VAIoH4Ha7-Rfb7vsSbadt23gJD4oBsDGbDCkGJokJYoAEPulgcC+eSshkAE6kGbYnjWT5WNuQb3rSqooa+0wvvGQYgNUiZcCRS6MqqXKUWhNGDDI9EEIYACORARmQwjMcSZGPueXI4aWEFlvRghEGQZBsIIghUAAbpwDBsPoiiwQi4wUDQoBiLBsjfBQFARqZwjVMYZokBQepjFU+kkLpTDWRwyhEAQBDMLWFo4XBmJJO0inKap6laRwOl6Ww-ASWERH8DJvLllUkUqWpmnabp+nZkwWlvqFuhtjwJCKBQlx2CVGj5LkoAAIzbmSqp1apUosSy2XRXlcUFYlYnBmkVaEeeI3iawnBuua1z8B1vD1QGLFretbEQp1gFputQYalty1dTyZaGVUwmmpw0ZUs40igJKZXIbeVQIasiF1oxN21DIZAmIYTkeq8j2tuF9AAITtuKoH9Dp4i6V9LgMbdqK-fo-3TJKsl6H4CSft+OJhNywNhfcoDQ+B2NQTBxO6AhSFWoDgKYQzpznGQlySt4ACQdMUAYPyM7BTUpr8bMc683Ntq9vTvdd0YyAzkojSua78AADDIF3unLjEKzmguLntLLSzW4o67dfrykre2kqAL78M1mvkJdH23Qjd0iwb3VG1BaM0Ou1jRmTNB8wQNCkGkoAALRR1Bzva4x1i4dj8lgFrV2MU9rn0MZpnmZZ1n0GIdmWEQjkUIILmfHHc1JdFTD6TID0YuVoOQxw0N12pDcEixZLQ9uLKhuGkb8Onru1Ityw6d3+m0ZKq02wk6dqjPgg9-PWoZbz5LCN8ZDinxbCCcJVCqZhXO6CKQ6Ws6NgAIJeigu1Bjf1gAHKPzIzUAGwv4yb8ABCAB5YBABZL0zV-7EjfuAAAEl-UAGBoFEjfgAcQAKIABUn4oISG-AAmpAWAXoACceC9BvwQMAwBuDF4ALvtYAA6vfOBuCdQ7y4HvKgB9BaYXcp5byvl-KBUFpabhvCj4n3IGfN83hOESMEMzO+IoADkmCsGqJkKo++WjQCqOoYArRaj4G6O0Z-PRqiLHmLMfo6xdjbFWMcfYpxxiEjqOwZYxxhjLGmMsS4gJzigl6LUYE-xjiWFwMsUQ2A0TiFxNidomJbi9CqOSUk+JGTEn6PSTkzJ+i-HaJAeA1RDJcK4EqtVS4K8uH70EArRRXtvD0QABzYCAA","body":"const lyrics_frequencies = \t  \n    list(list(\"A\", 2),\n         list(\"NA\", 16),\n         list(\"BOOM\", 1),\n         list(\"SHA\", 3),\n         list(\"GET\", 2),\n         list(\"YIP\", 9),\n         list(\"JOB\", 2),\n         list(\"WAH\", 2));\nconst lyrics_tree = generate_huffman_tree(lyrics_frequencies);\nconst lyrics = list(\n    'GET', 'A', 'JOB',\n    'SHA', 'NA', 'NA', 'NA', 'NA', 'NA', 'NA', 'NA', 'NA',\n    'GET', 'A', 'JOB', 'SHA', 'NA', 'NA', 'NA', 'NA', 'NA', \n    'NA', 'NA', 'NA', 'WAH', 'YIP', 'YIP', 'YIP', 'YIP',\n    'YIP', 'YIP', 'YIP', 'YIP', 'YIP', 'SHA', 'BOOM'\n   );\n \nlength(encode(lyrics, lyrics_tree));\n// 84 "},{"body":"\n      We have an alphabet of ","tag":"#text"},{"body":"$n = 8$","tag":"LATEX"},{"body":" symbols, and a\n      message of ","tag":"#text"},{"body":"$m = 36$","tag":"LATEX"},{"body":" symbols. Then the minimum\n      number of bits to encode a specific symbol using a fixed-length code is\n      ","tag":"#text"},{"body":"$\\lceil \\log_2{n} \\rceil = 3$","tag":"LATEX"},{"body":". Thus the minimum\n      number of bits to encode all the lyrics is \n      ","tag":"#text"},{"body":"$m \\lceil\\log_2{n}\\rceil = 36 \\times 3 = 108$","tag":"LATEX"},{"body":".\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.71","id":"#ex-2.71","child":[{"body":"\n    Suppose we have a Huffman tree for an alphabet of\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" symbols, and that the relative frequencies\n    of the symbols are 1, 2, 4, …,\n    ","tag":"#text"},{"body":"$2^{n-1}$","tag":"LATEX"},{"body":".  Sketch the tree for\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"=5; for ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"=10.\n    In such a tree (for general ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":") how may bits\n    are required to encode the most frequent symbol?  the least frequent symbol?\n    ","tag":"#text"}],"solution":[{"tag":"TEXT","id":"#p16","child":[{"body":"\n\tThe tree will be unbalanced, similar to the tree given in\n\tfigure ","tag":"#text"},{"tag":"REF","body":"2.17","href":"/sicpjs/2.3.3#fig-2.17"},{"body":". Encoding the most\n\tfrequent symbol requires one bit, whereas\n\t","tag":"#text"},{"body":"$n - 1$","tag":"LATEX"},{"body":" bits are required to encode the\n\tleast frequent symbol.\n      ","tag":"#text"}]}]},{"tag":"EXERCISE","title":"Exercise 2.72","id":"#ex-2.72","child":[{"body":"\n    Consider the encoding\n    function\n    that you designed in exercise ","tag":"#text"},{"tag":"REF","body":"2.68","href":"/sicpjs/2.3.4#ex-2.68"},{"body":".  What\n    is the\n    \n    order of growth in the number of steps needed to encode a symbol?\n    Be sure to include the number of steps needed to search the symbol list at\n    each node encountered.  To answer this question in general is difficult.\n    Consider the special case where the relative frequencies of the\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" symbols are as described in\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.71","href":"/sicpjs/2.3.4#ex-2.71"},{"body":", and give the order of\n    growth (as a function of ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":") of the number of\n    steps needed to encode the most frequent and least frequent symbols in the\n    alphabet.\n    ","tag":"#text"}],"solution":[{"body":"\n      Consider the special case in\n      exercise ","tag":"#text"},{"tag":"REF","body":"2.68","href":"/sicpjs/2.3.4#ex-2.68"},{"body":". At each step down the path\n      of length ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":", we need to do a linear search in\n      a list of length ","tag":"#text"},{"body":"$n, n-1, \\ldots, 1$","tag":"LATEX"},{"body":". In the\n      worst case, there are\n      ","tag":"#text"},{"body":"$O(n \\times n / 2) = O(n^2)$","tag":"LATEX"},{"body":" number of steps.\n      ","tag":"#text"},{"body":"$O(n^2)$","tag":"LATEX"},{"body":".\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/2.3.4#footnote-link-1","child":[{"body":"See\n    Hamming 1980\n    for a discussion of the mathematical properties of Huffman codes.","tag":"#text"}]}]