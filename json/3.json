[{"id":"/sicpjs/3","tag":"TITLE","body":"3  Modularity, Objects, and State"},{"tag":"EPIGRAPH","child":[{},{"body":"$\\def\\aal{\\alpha{\\raise 1pt\\hbox{\\hskip -4pt{\\char'47}}}}     M\\epsilon\\tau\\alpha\\beta\\acute{\\alpha}\\lambda\\lambda o \\nu\\     ἀ\\nu\\alpha\\pi\\alpha\\acute{\\upsilon}\\epsilon\\tau\\alpha\\iota$","tag":"LATEX"},{},{"tag":"BR"},{"body":"\n    (Even while it changes, it stands still.)\n    ","tag":"#text"},{},{}],"author":" Heraclitus"},{"tag":"EPIGRAPH","child":[{"body":"\n    Plus ","tag":"#text"},{"body":"ç","tag":"#text"},{"body":"a change, plus c","tag":"#text"},{"body":"'","tag":"#text"},{"body":"est la m","tag":"#text"},{"body":"ê","tag":"#text"},{"body":"me chose.\n\n    ","tag":"#text"},{},{}],"author":" Alphonse Karr"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    The preceding chapters introduced the basic elements from which\n    programs are made.  We saw how primitive\n    functions\n    and primitive data are combined to construct compound entities, and we\n    learned that abstraction is vital in helping us to cope with the complexity\n    of large systems.  But these tools are not sufficient for designing\n    programs.  Effective program synthesis also requires organizational\n    principles that can guide us in formulating the overall design of a\n    program.  In particular, we need strategies to help us structure large\n    systems so that they will be\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"modular","tag":"#text"}]},{"body":", that is, so that they can\n    be divided \"","tag":"#text"},{"body":"naturally","tag":"#text"},{"body":"\" into coherent parts that can be\n    separately developed and maintained.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    One powerful design strategy, which is particularly appropriate to the\n    construction of programs for\n    \n    modeling physical systems, is to base the\n    structure of our programs on the structure of the system being\n    modeled.  For each object in the system, we construct a corresponding\n    computational object.  For each system action, we define a symbolic\n    operation in our computational model.  Our hope in using this strategy\n    is that extending the model to accommodate new objects or new actions\n    will require no strategic changes to the program, only the addition of\n    the new symbolic analogs of those objects or actions.  If we have been\n    successful in our system organization, then to add a new feature or\n    debug an old one we will have to work on only a localized part of the\n    system.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    To a large extent, then, the way we organize a large program is\n    dictated by our perception of the system to be modeled.  In this\n    chapter we will investigate two prominent organizational strategies\n    arising from two rather different \"","tag":"#text"},{"body":"world views","tag":"#text"},{"body":"\" of the\n    structure of systems.  The first organizational strategy concentrates on\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"objects","tag":"#text"}]},{"body":", viewing a large system as a collection of distinct objects\n    whose behaviors may change over time.  An alternative organizational\n    strategy concentrates on the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"streams","tag":"#text"}]},{"body":" of information that flow in\n    the system, much as an electrical engineer views a signal-processing\n    system.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Both the object-based approach and the stream-processing approach\n    raise significant linguistic issues in programming.\n    With objects, we must be concerned with how a computational object can\n    change and yet maintain its identity.  This will force us to abandon\n    our old substitution model of computation\n    (section ","tag":"#text"},{"tag":"REF","body":"1.1.5","href":"/sicpjs/1.1.5"},{"body":") in favor of a more\n    mechanistic but less theoretically tractable\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"environment model","tag":"#text"}]},{"body":" of\n    computation.  The difficulties of dealing with objects, change, and\n    identity are a fundamental consequence of the need to grapple with\n    time in our computational models.  These difficulties become even\n    greater when we allow the possibility of concurrent execution of\n    programs.  The stream approach can be most fully exploited when we\n    decouple simulated time in our model from the order of the events that\n    take place in the computer during evaluation.  We will accomplish this\n    using a technique known as\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"delayed evaluation","tag":"#text"}]},{"body":".\n  ","tag":"#text"}]}]