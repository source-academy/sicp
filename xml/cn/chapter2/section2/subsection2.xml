<SUBSECTION>
  <NAME>
    Hierarchical Structures
  </NAME>

  <LABEL NAME="sec:trees"></LABEL>
  <INDEX>data<SUBINDEX>hierarchical</SUBINDEX><OPEN></OPEN></INDEX>
  <INDEX>hierarchical data structures<OPEN></OPEN></INDEX>
  <INDEX>tree<SUBINDEX>represented as pairs</SUBINDEX><OPEN></OPEN></INDEX>
  <INDEX>pair(s)<SUBINDEX>used to represent tree</SUBINDEX><OPEN></OPEN></INDEX>
  <TEXT>
    The representation of sequences in terms of lists generalizes naturally to
    represent sequences whose elements may themselves be sequences.  For
    example, we can regard the object
    <SPLITINLINE>
      ((1 2) 3 4)
      <JAVASCRIPT>
	  <JAVASCRIPTINLINE>
[[1, [2, null]], [3, [4, null]]]
	  </JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    constructed by
    <SNIPPET>
      
(cons (list 1 2) (list 3 4))
      
      <JAVASCRIPT>
pair(list(1, 2), list(3, 4));
      </JAVASCRIPT>
    </SNIPPET>
    as a list of three items, the first of which is itself a list,
    <SPLITINLINE>
      
	(1 2). Indeed, this is
	suggested by the form in which the result is printed by the
	interpreter.
      
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>[1, [2, null]]</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      
	Figure<SPACE></SPACE><REF NAME="fig:cons-of-2-lists_scheme"></REF>
      
      <JAVASCRIPT>
	Figure<SPACE></SPACE><REF NAME="fig:cons-of-2-lists"></REF>    
      </JAVASCRIPT>
    </SPLITINLINE>
    shows the representation of this structure in terms of pairs.
    <SPLIT>
      
        <FIGURE SPLIT_SCALE="0.6" SRC="img_original/ch2-Z-G-15.svg">
          <LABEL NAME="fig:cons-of-2-lists_scheme"></LABEL>
          <CAPTION>Structure formed by
	  (cons (list 1 2) (list 3 4)).
          </CAPTION>
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE SRC="img_javascript/ch2-Z-G-15.svg">
          <LABEL NAME="fig:cons-of-2-lists"></LABEL>
          <CAPTION>Structure formed by
	  <JAVASCRIPTINLINE>pair(list(1, 2), list(3, 4))</JAVASCRIPTINLINE>.
          </CAPTION>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    Another way to think of sequences whose elements are sequences is as
    <EM>trees</EM>.  The elements of the sequence are the branches of the
    tree, and elements that are themselves sequences are subtrees.
    <SPLITINLINE>
      Figure<SPACE></SPACE><REF NAME="fig:list-as-tree_scheme"></REF>
      <JAVASCRIPT>Figure<SPACE></SPACE><REF NAME="fig:list-as-tree"></REF></JAVASCRIPT>
    </SPLITINLINE>
    shows the structure in
    <SPLITINLINE>
      
	figure<SPACE></SPACE><REF NAME="fig:cons-of-2-lists_scheme"></REF>
      
      <JAVASCRIPT>
	figure<SPACE></SPACE><REF NAME="fig:cons-of-2-lists"></REF>	
      </JAVASCRIPT>
    </SPLITINLINE>
    viewed as a tree.
    <SPLIT>
      
        <FIGURE SRC="img_original/ch2-Z-G-16.svg">
          <LABEL NAME="fig:list-as-tree_scheme"></LABEL>
          <CAPTION>The list structure in
	  figure<SPACE></SPACE><REF NAME="fig:cons-of-2-lists_scheme"></REF>
	  viewed as a tree.
          </CAPTION>
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE SRC="img_javascript/ch2-Z-G-16.svg">
          <LABEL NAME="fig:list-as-tree"></LABEL>
          <CAPTION>The list structure in
	  figure<SPACE></SPACE><REF NAME="fig:cons-of-2-lists"></REF> viewed as a tree.
          </CAPTION>
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    Recursion
    <INDEX>recursion<SUBINDEX><ORDER>working</ORDER>in working with trees</SUBINDEX></INDEX>
    is a natural tool for dealing with tree structures, since we can
    often reduce operations on trees to operations on their branches, which
    reduce in turn to operations on the branches of the branches, and so on,
    until we reach the leaves of the tree. As an example, compare the
    <SPLITINLINE>
      length
      <JAVASCRIPT><JAVASCRIPTINLINE>length</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of section<SPACE></SPACE><REF NAME="sec:sequences"></REF> with the
     <INDEX><USE>count_leaves</USE></INDEX> 
    <INDEX>tree<SUBINDEX>counting leaves of</SUBINDEX></INDEX>
    <SPLITINLINE>
      count-leaves
      <JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure,
    <JAVASCRIPT>function,</JAVASCRIPT></SPLITINLINE>
    which returns the total number of leaves of a tree:
    <SNIPPET>
      <NAME>tree_x</NAME>
      
(define x (cons (list 1 2) (list 3 4)))
      
      <JAVASCRIPT>
const x = pair(list(1, 2), list(3, 4));
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>length_tree_x</NAME>
      <REQUIRES>tree_x</REQUIRES>
      <EXPECTED>3</EXPECTED>
      
(length x)
      
      <SCHEMEOUTPUT>
3
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
length(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
3	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>count_leaves_tree_x</NAME>
      <REQUIRES>tree_x</REQUIRES>
      <REQUIRES>count_leaves</REQUIRES>
      <EXPECTED>4</EXPECTED>
      
(count-leaves x)
      
      <SCHEMEOUTPUT>
4
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
count_leaves(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
4
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>list_x_x</NAME>
      <REQUIRES>tree_x</REQUIRES>
      <EXPECTED>3</EXPECTED>
      
(list x x)
      
      <SCHEMEOUTPUT>
(((1 2) 3 4) ((1 2) 3 4))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
list(x, x);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
length(head(tail(list(x, x))));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>length_list_x_x</NAME>
      <REQUIRES>tree_x</REQUIRES>
      <EXPECTED>2</EXPECTED>
      
(length (list x x))
      
      <SCHEMEOUTPUT>
2
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
length(list(x, x));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
2
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>count_leaves_list_x_x</NAME>
      <REQUIRES>tree_x</REQUIRES>
      <REQUIRES>count_leaves</REQUIRES>
      <EXPECTED>8</EXPECTED>
      
(count-leaves (list x x))
      
      <SCHEMEOUTPUT>
8
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
count_leaves(list(x, x));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
8
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    To implement
    <SPLITINLINE>
      count-leaves,
      <JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    recall the recursive plan for computing
    <SPLITINLINE>
      length:
      <JAVASCRIPT><JAVASCRIPTINLINE>length</JAVASCRIPTINLINE>:</JAVASCRIPT>
    </SPLITINLINE>
    <UL>
      <LI>
	<SPLITINLINE>
	  Length
	  <JAVASCRIPT>The <JAVASCRIPTINLINE>length</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	of a list x is 1 plus
	<SPLITINLINE>
	  length
	  <JAVASCRIPT>the <JAVASCRIPTINLINE>length</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	of the
        <SPLITINLINE>
	  cdr
	  <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	of x.
      </LI>
      <LI>
        <SPLITINLINE>
	  Length
	  <JAVASCRIPT>The <JAVASCRIPTINLINE>length</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	of the empty list is 0.
      </LI>
    </UL>
    <SPLITINLINE>
      Count-leaves
      <JAVASCRIPT>The function
      <JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is similar.  The value for the empty list is the same:
    <UL>
      <LI>
        <SPLITINLINE>
	  Count-leaves
	  <JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	of the empty list is 0.
      </LI>
    </UL>
    But in the reduction step, where we strip off the
    <SPLITINLINE>car
    <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the list, we must take into account that the
    <SPLITINLINE>car
    <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    may itself be a tree whose leaves we need to count.  Thus, the appropriate
    reduction step is
    <UL>
      <LI>
        <SPLITINLINE>
	  Count-leaves
	  <JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	of a tree x is
	<SPLITINLINE>
	  count-leaves
	  <JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	of the
	<SPLITINLINE>
	  car
	  <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	of x plus
	<SPLITINLINE>
	  count-leaves
	  <JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	of the
        <SPLITINLINE>
	  cdr
	  <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	of x.
      </LI>
    </UL>
    Finally, by taking
    <SPLITINLINE>
      cars
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>s</JAVASCRIPT>
    </SPLITINLINE>
    we reach actual leaves, so we need another base case:
    <UL>
      <LI>
        <SPLITINLINE>
	  Count-leaves
	  <JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	of a leaf is 1.
      </LI>
    </UL>
    To aid in writing recursive
    <SPLITINLINE>
      procedures
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    on trees,
    <SPLITINLINE>
      Scheme
      <JAVASCRIPT>our JavaScript environment</JAVASCRIPT>
    </SPLITINLINE>
    provides the primitive predicate
    <INDEX><USE>is_pair</USE> (primitive function)</INDEX>
    <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>is_pair</USE> (\textit{ns})</SUBINDEX></INDEX>
    <SPLITINLINE>
      pair?,
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    which tests whether its argument is a pair. Here is the complete
    <SPLITINLINE>procedure:<FOOTNOTE>The order of the first two clauses
    in the cond matters, since the empty list
    satisfies null? and also is not a
    pair.</FOOTNOTE><JAVASCRIPT>function:<FOOTNOTE>The order of the
    two predicates matters, since <JAVASCRIPTINLINE>null</JAVASCRIPTINLINE>
    satisfies is_null and also is not a
    pair.</FOOTNOTE></JAVASCRIPT></SPLITINLINE>
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>count_leaves</DECLARATION></INDEX>
      <NAME>count_leaves</NAME>
      <EXAMPLE>count_leaves_example</EXAMPLE>
      <EXPECTED>4</EXPECTED>
      
(define (count-leaves x)
  (cond ((null? x) 0)
    ((not (pair? x)) 1)
    (else (+ (count-leaves (car x))
             (count-leaves (cdr x))))))
      
      <JAVASCRIPT>
function count_leaves(x) {
    return is_null(x)
           ? 0
           : ! is_pair(x)
           ? 1
           : count_leaves(head(x)) + count_leaves(tail(x));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>count_leaves_example</NAME>
      
(count-leaves (cons (list 1 2) (list 3 4)))
      
      <JAVASCRIPT>
count_leaves(pair(list(1, 2), list(3, 4)));
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <EXERCISE>
    Suppose we evaluate the expression
    <SPLITINLINE>
      
	(list 1 (list 2 (list 3 4))).
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>list(1, list(2, list(3, 4)))</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Give the result printed by the interpreter, the corresponding
    box-and-pointer structure, and the interpretation of this as a tree (as in
    <SPLITINLINE>
      figure<SPACE></SPACE><REF NAME="fig:list-as-tree_scheme"></REF>).
      <JAVASCRIPT>figure<SPACE></SPACE><REF NAME="fig:list-as-tree"></REF>).</JAVASCRIPT>
    </SPLITINLINE>
    <LABEL NAME="ex:nested-list"></LABEL>
    <SOLUTION>
      <OL>
        <LI>
          <SNIPPET EVAL="no">
            <NAME>count_leaves_example_result</NAME>
            
            
            <JAVASCRIPT>
[1, [[2, [[3, [4, null]], null]], null]]
	    </JAVASCRIPT>
	  </SNIPPET>
        </LI>
        <LI>
          <FIGURE SRC="img_javascript/ch2-Z-G-ex-2-24.svg">
	    <LABEL NAME="ch2-Z-G-ex-2-24"></LABEL>
	  </FIGURE>
        </LI>
        <LI>
          <FIGURE SRC="img_javascript/ch2-Z-G-ex-2-24-tree.svg">
	    <LABEL NAME="ch2-Z-G-ex-2-24-tree"></LABEL>
	  </FIGURE>
        </LI>
      </OL>
    </SOLUTION>
    <LABEL NAME="ex:2_24"></LABEL>
  </EXERCISE>

  <DO_BREAK_PAGE></DO_BREAK_PAGE>
  <EXERCISE>
    Give combinations of
    <SPLITINLINE>cars
    <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>s</JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>cdrs
    <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>s</JAVASCRIPT>
    </SPLITINLINE>
    that will pick 7 from each of the following
    <SPLITINLINE>lists:
    <JAVASCRIPT>lists, given in list notation:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no" POSTPADDING="no">
      <NAME>extreme_list</NAME>
      
(1 3 (5 7) 9)

((7))

(1 (2 (3 (4 (5 (6 7))))))
      
      <JAVASCRIPT>
list(1, 3, list(5, 7), 9)

list(list(7))

list(1, list(2, list(3, list(4, list(5, list(6, 7))))))
      </JAVASCRIPT>
    </SNIPPET>
    <SOLUTION>
      <UL>
	<LI>
          <SNIPPET EVAL="no">
	    <JAVASCRIPT>
head(tail(head(tail(tail(the_first_list)))));
	    </JAVASCRIPT>
	  </SNIPPET>
	</LI>
	<LI>
          <SNIPPET EVAL="no">
	    <JAVASCRIPT>
 head(head(the_second_list));
	    </JAVASCRIPT>
	  </SNIPPET>
	</LI>
	<LI>
          <SNIPPET EVAL="no">
	    <JAVASCRIPT>
head(tail(head(tail(head(tail(head(tail(head(
    tail(head(tail(the_third_list))))))))))));
	    </JAVASCRIPT>
	  </SNIPPET>
	</LI>
      </UL>
    </SOLUTION>
    <LABEL NAME="ex:2_25"></LABEL>
  </EXERCISE>

  <EXERCISE>
    Suppose we define x and
    y to be two lists:
    <SNIPPET>
      <NAME>xy</NAME>
      
(define x (list 1 2 3))

(define y (list 4 5 6))
      
      <JAVASCRIPT>
const x = list(1, 2, 3);
<SHORT_SPACE></SHORT_SPACE>
const y = list(4, 5, 6);
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      
	What result is printed by the interpreter in response to evaluating
	each of the following
	expressions:
      
      <JAVASCRIPT>
        What is the result of evaluating each of the
        following expressions, in box notation and list notation?
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <NAME>appendxy</NAME>
      <REQUIRES>xy</REQUIRES>
      
(append x y)
      
      <JAVASCRIPT>
append(x, y)
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>pairxy</NAME>
      <REQUIRES>xy</REQUIRES>
      
(cons x y)
      
      <JAVASCRIPT>
pair(x, y)
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET POSTPADDING="no">
      <NAME>listxy</NAME>
      <REQUIRES>xy</REQUIRES>
      
(list x y)
      
      <JAVASCRIPT>
list(x, y)
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(tail(list(x, y)));
      </JAVASCRIPT_TEST>
    </SNIPPET>
    <SOLUTION>
      <OL>
	<LI>
          <SNIPPET>
            <NAME>appendxy_sol</NAME>
            <REQUIRES>appendxy</REQUIRES>
            
            
            <JAVASCRIPT>
[1, [2, [3, [4, [5, [6, null]]]]]]
            </JAVASCRIPT>
            <JAVASCRIPT_RUN>
// result: [1, [2, [3, [4, [5, [6, null]]]]]]
            </JAVASCRIPT_RUN>
          </SNIPPET>
	</LI>
	<LI>
          <SNIPPET>
            <NAME>pairxy_sol</NAME>
            <REQUIRES>pairxy</REQUIRES>
            
            
            <JAVASCRIPT>
[[1, [2, [3, null]]], [4, [5, [6, null]]]]
            </JAVASCRIPT>
            <JAVASCRIPT_RUN>
// result: [[1, [2, [3, null]]], [4, [5, [6, null]]]]
            </JAVASCRIPT_RUN>
          </SNIPPET>
	</LI>
	<LI>
          <SNIPPET>
            <NAME>listxy_sol</NAME>
            <REQUIRES>listxy</REQUIRES>
	    <EXPECTED>[ 4, [ 5, [ 6, null ] ] ]</EXPECTED>
            
            
            <JAVASCRIPT>
[[1, [2, [3, null]]], [[4, [5, [6, null]]], null]]
            </JAVASCRIPT>
            <JAVASCRIPT_RUN>
// result: [[1, [2, [3, null]]], [[4, [5, [6, null]]], null]]
            </JAVASCRIPT_RUN>
          </SNIPPET>
	</LI>
      </OL>
    </SOLUTION>
    <LABEL NAME="ex:2_26"></LABEL>
  </EXERCISE>

  <EXERCISE>
    Modify your
    <SPLITINLINE>
      reverse
      <JAVASCRIPT><JAVASCRIPTINLINE>reverse</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of exercise<SPACE></SPACE><REF NAME="ex:reverse"></REF> to produce a
     <INDEX><USE>deep_reverse</USE></INDEX> 
    <INDEX>tree<SUBINDEX>reversing at all levels</SUBINDEX></INDEX>
    <SPLITINLINE>
      deep-reverse
      <JAVASCRIPT><JAVASCRIPTINLINE>deep_reverse</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that takes a list as argument and returns as its value the list with its
    elements reversed and with all sublists deep-reversed as well.  For example,
    <SNIPPET>
      <NAME>x_list_list</NAME>
      
(define x (list (list 1 2) (list 3 4)))
      
      <JAVASCRIPT>
const x = list(list(1, 2), list(3, 4));
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>x_x_list_list</NAME>
      <REQUIRES>x_list_list</REQUIRES>
      
x
      
      <SCHEMEOUTPUT>
((1 2) (3 4))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
x;
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
list(list(1, 2), list(3, 4))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>reverse_x</NAME>
      <REQUIRES>x_list_list</REQUIRES>
      <REQUIRES>reverse</REQUIRES>
      
(reverse x)
      
      <SCHEMEOUTPUT>
((3 4) (1 2))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
reverse(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
list(list(3, 4), list(1, 2))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>deep_reverse</NAME>
      
;; deep_reverse to be written by student
      
      <JAVASCRIPT>
// deep_reverse to be written by student
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET POSTPADDING="no">
      <NAME>deep_reverse_x</NAME>
      <REQUIRES>x_list_list</REQUIRES>
      <REQUIRES>deep_reverse</REQUIRES>
      
(deep-reverse x)
      
      <SCHEMEOUTPUT>
((4 3) (2 1))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deep_reverse(x);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(deep_reverse(x));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(list(4, 3), list(2, 1))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>deep_reverse_solution</NAME>
        <REQUIRES>x_list_list</REQUIRES>
	<EXAMPLE>deep_reverse_x</EXAMPLE>
	<EXPECTED>[ 4, [ 3, null ] ]</EXPECTED>
	<JAVASCRIPT>
function deep_reverse(items){
    return is_null(items)
           ? null
           : is_pair(items)
           ? append(deep_reverse(tail(items)), 
                    pair(deep_reverse(head(items)), 
                         null))
           : items;
}
	</JAVASCRIPT>
	
	
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:2_27"></LABEL>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:fringe"></LABEL>
    Write a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>fringe</USE></INDEX> 
    <INDEX>tree<SUBINDEX>fringe of</SUBINDEX></INDEX>
    <SPLITINLINE>
      fringe
      <JAVASCRIPT><JAVASCRIPTINLINE>fringe</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    that takes as argument a tree (represented as a list) and returns a list
    whose elements are all the leaves of the tree arranged in left-to-right
    order.  For example,
    <SNIPPET HIDE="yes">
      <NAME>fringe</NAME>
      
;; fringe to be written by student
      
      <JAVASCRIPT>
// fringe to be written by student
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>x_fringe_example</NAME>
      
(define x (list (list 1 2) (list 3 4)))
      
      <JAVASCRIPT>
const x = list(list(1, 2), list(3, 4));
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>x_fringe_example_2</NAME>
      <REQUIRES>x_fringe_example</REQUIRES>
      <REQUIRES>fringe</REQUIRES>
      
(fringe x)
      
      <SCHEMEOUTPUT>
(1 2 3 4)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
fringe(x);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
list(1, 2, 3, 4)
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET POSTPADDING="no">
      <NAME>x_fringe_example_3</NAME>
      <REQUIRES>x_fringe_example</REQUIRES>
      <REQUIRES>fringe</REQUIRES>
      
(fringe (list x x))
      
      <SCHEMEOUTPUT>      
(1 2 3 4 1 2 3 4)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
fringe(list(x, x));
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
length(fringe(list(x, x)));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(1, 2, 3, 4, 1, 2, 3, 4)
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>x_fringe_solution</NAME>
	<REQUIRES>x_fringe_example</REQUIRES>
	<EXAMPLE>x_fringe_example_3</EXAMPLE>
	<EXPECTED>8</EXPECTED>
	<JAVASCRIPT>
function fringe(x) {
    return is_null(x)
           ? null
           : is_pair(x)
           ? append(fringe(head(x)), fringe(tail(x)))
           : list(x);
}
	</JAVASCRIPT>
	
	
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    A binary
    <INDEX>mobile</INDEX>
    mobile consists of two branches, a left branch and a right
    branch.  Each branch is a rod of a certain length, from which hangs
    either a weight or another binary mobile.  We can represent a binary
    mobile using compound data by constructing it from two branches (for
    example, using list):
    <SNIPPET>
      <NAME>make_mobile</NAME>
      
(define (make-mobile left right)
  (list left right))
      
      <JAVASCRIPT>
function make_mobile(left, right) {
    return list(left, right);
}
      </JAVASCRIPT>
    </SNIPPET>
    A branch is constructed from a length (which
    must be a number) together with a structure,
    which may be either a number (representing a simple weight) or another
    mobile:
    <SNIPPET>
      <NAME>make_branch</NAME>
      
(define (make-branch length structure)
  (list length structure))
      
      <JAVASCRIPT>
function make_branch(length, structure) {
    return list(length, structure);
}
      </JAVASCRIPT>
    </SNIPPET>
    <OL>
      <LI>
        Write the corresponding selectors
	<SPLITINLINE>
	  left-branch
	  <JAVASCRIPT><JAVASCRIPTINLINE>left_branch</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	and
        <SPLITINLINE>
	  right-branch,
	  <JAVASCRIPT><JAVASCRIPTINLINE>right_branch</JAVASCRIPTINLINE>,
	  </JAVASCRIPT>
	</SPLITINLINE>
	which return the branches of a mobile, and
        <SPLITINLINE>
	  branch-length
	  <JAVASCRIPT><JAVASCRIPTINLINE>branch_length</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	and
	<SPLITINLINE>
	  branch-structure,
	  <JAVASCRIPT><JAVASCRIPTINLINE>branch_structure</JAVASCRIPTINLINE>,
	</JAVASCRIPT></SPLITINLINE>
	which return the components of a branch.
      </LI>
      <LI>
        Using your selectors, define a
        <SPLITINLINE>
	  procedure
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
        <SPLITINLINE>
	  
	  total-weight
	  <JAVASCRIPT><JAVASCRIPTINLINE>total_weight</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        that returns the total weight of a mobile.
      </LI>
      <LI>
        A mobile is said to be
        <INDEX>balanced mobile</INDEX>
        <EM>balanced</EM> if the torque applied by its top-left branch is equal
	to that applied by its top-right branch (that is, if the length of the
	left rod multiplied by the weight hanging from that rod is equal to the
	corresponding product for the right side) and if each of the submobiles
	hanging off its branches is balanced. Design a predicate that tests
	whether a binary mobile is balanced.
      </LI>
      <LI>
        Suppose we change the representation of mobiles so that the
	constructors are
        <SNIPPET>
	  <NAME>make_mobile_branch_alternative</NAME>
          
(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))
          
          <JAVASCRIPT>
function make_mobile(left, right) {
    return pair(left, right);
}
function make_branch(length, structure) {
    return pair(length, structure);
}
          </JAVASCRIPT>
        </SNIPPET>
        How much do you need to change your programs to convert to the new
        representation?
      </LI>
    </OL>
    <LABEL NAME="ex:mobile"></LABEL>
    <SOLUTION>
      <OL>
	<LI>
	  <SNIPPET>
	    <NAME>branch_construction</NAME>
	    <REQUIRES>make_mobile</REQUIRES>
	    <REQUIRES>make_branch</REQUIRES>
	    <JAVASCRIPT>
function left_branch(m) {
    return head(m);
}
function right_branch(m) {
    return head(tail(m));
}
function branch_length(b) {
    return head(b);
}
function branch_structure(b) {
    return head(tail(b));
}
	    </JAVASCRIPT>
	  </SNIPPET>
	</LI>
	<LI>
	  <SNIPPET>
	    <NAME>total_weight</NAME>
	    <REQUIRES>branch_construction</REQUIRES>
	    <EXAMPLE>example_2.29</EXAMPLE>
	    <EXPECTED>30</EXPECTED>
	    <JAVASCRIPT>
function is_weight(x){
    return is_number(x);
}
function total_weight(x) {
    return is_weight(x)
        ? x
        : total_weight(branch_structure(
                         left_branch(x))) +
          total_weight(branch_structure(
                         right_branch(x)));
}
	    </JAVASCRIPT>
	  </SNIPPET>
	  <SNIPPET HIDE="yes">
	    <NAME>example_2.29</NAME>
	    <JAVASCRIPT>
const m = make_mobile(
              make_branch(10,
                  make_mobile(make_branch(10, 2), 
                      make_branch(4, 5))), 
              make_branch(10, 23));      
total_weight(m);
	    </JAVASCRIPT>
	  </SNIPPET>
	</LI>
	<LI>
	  <SNIPPET>
	    <NAME>is_balanced_solution</NAME>
	    <REQUIRES>total_weight</REQUIRES>
	    <EXAMPLE>example_2.29_2</EXAMPLE>
	    <EXPECTED>true</EXPECTED>
	    <JAVASCRIPT>
function is_balanced(x) {
    return is_weight(x) ||
        ( is_balanced(branch_structure(
                                  left_branch(x))) &amp;&amp;
          is_balanced(branch_structure(
                                  right_branch(x))) &amp;&amp;
          total_weight(branch_structure(
                                  left_branch(x))) 
          * branch_length(left_branch(x))
          ===
          total_weight(branch_structure(
                                  right_branch(x))) 
          * branch_length(right_branch(x))
        );
}
	    </JAVASCRIPT>
	  </SNIPPET>
	  <SNIPPET HIDE="yes">
	    <NAME>example_2.29_2</NAME>
	    <JAVASCRIPT>
const m = make_mobile(
              make_branch(20, 
                  make_mobile(make_branch(10, 2),
                              make_branch(4, 5))), 
              make_branch(28, 5));
is_balanced(m);
	    </JAVASCRIPT>
	  </SNIPPET>
	</LI>
	<LI>
	  With this alternative representation, the selector functions for
	  mobile and branch need to change as follows:
	  <SNIPPET EVAL="no">
	    <NAME>branch_construction_2</NAME>
	    <REQUIRES>make_mobile</REQUIRES>
	    <REQUIRES>make_branch</REQUIRES>
	    <JAVASCRIPT>
function left_branch(m) {
  return head(m);
}
function right_branch(m) {
  return tail(m);
}
function branch_length(b) {
  return head(b);
}
function branch_structure(b) {
  return tail(b);
}
	    </JAVASCRIPT>
	  </SNIPPET>
	</LI>
      </OL>
    </SOLUTION>
  </EXERCISE>

  <INDEX>data<SUBINDEX>hierarchical</SUBINDEX><CLOSE></CLOSE></INDEX>
  <INDEX>hierarchical data structures<CLOSE></CLOSE></INDEX>
  <INDEX>tree<SUBINDEX>represented as pairs</SUBINDEX><CLOSE></CLOSE></INDEX>
  <INDEX>pair(s)<SUBINDEX>used to represent tree</SUBINDEX><CLOSE></CLOSE></INDEX>

  <SUBHEADING>
    <NAME>Mapping over trees</NAME>
  </SUBHEADING>

  <INDEX>tree<SUBINDEX>mapping over</SUBINDEX><OPEN></OPEN></INDEX>
  <INDEX>mapping<SUBINDEX><ORDER>tree</ORDER>over trees</SUBINDEX><OPEN></OPEN></INDEX>

  <TEXT>
    Just as map is a powerful abstraction for
    dealing with sequences, map together with
    recursion is a powerful abstraction for dealing with trees.  For instance,
    the
    <SPLITINLINE>
      scale-tree
      <JAVASCRIPT><JAVASCRIPTINLINE>scale_tree</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure,
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    analogous to
    <SPLITINLINE>
      scale-list
      <JAVASCRIPT><JAVASCRIPTINLINE>scale_list</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of section<SPACE></SPACE><REF NAME="sec:sequences"></REF>, takes as arguments a numeric
    factor and a tree whose leaves are numbers.  It returns a tree of the same
    shape, where each number is multiplied by the factor. The recursive plan
    for
    <SPLITINLINE>
      scale-tree
      <JAVASCRIPT><JAVASCRIPTINLINE>scale_tree</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is similar to the one for
    <SPLITINLINE>
      count-leaves:
      <JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE>:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <INDEX><DECLARATION>scale_tree</DECLARATION></INDEX> 
      <NAME>scale_tree</NAME>
      <EXAMPLE>scale_tree_example</EXAMPLE>
      <EXPECTED>10</EXPECTED>
      
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
     ((not (pair? tree)) (* tree factor))
     (else (cons (scale-tree (car tree) factor)
                 (scale-tree (cdr tree) factor)))))
      
      <JAVASCRIPT>
function scale_tree(tree, factor) {
    return is_null(tree)
           ? null
           : ! is_pair(tree)
           ? tree * factor
           : pair(scale_tree(head(tree), factor), 
                  scale_tree(tail(tree), factor));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>scale_tree_example</NAME>
      <REQUIRES>scale_tree</REQUIRES>
      
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
            10)
      
      <SCHEMEOUTPUT>
(10 (20 (30 40) 50) (60 70))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),
           10);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),
           10));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(10, list(20, list(30, 40), 50), list(60, 70))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    Another way to implement
    <SPLITINLINE>
      scale-tree
      <JAVASCRIPT><JAVASCRIPTINLINE>scale_tree</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is to regard the tree as a sequence of sub-trees and use
    <SPLITINLINE>
      map.
      <JAVASCRIPT><JAVASCRIPTINLINE>map</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    We map over the sequence, scaling each sub-tree in turn, and return the
    list of results.  In the base case, where the tree is a leaf, we simply
    multiply by the factor:
    <SNIPPET HIDE="yes">
      <NAME>scale_tree_example_2</NAME>
      
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
            10)
      
      <JAVASCRIPT>
scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),
           10);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),
           10));
      </JAVASCRIPT_TEST>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>scale_tree</DECLARATION></INDEX> 
      <NAME>scale_tree_with_map</NAME>
      <EXAMPLE>scale_tree_example_2</EXAMPLE>
      <EXPECTED>10</EXPECTED>
      
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
           (scale-tree sub-tree factor)
           (* sub-tree factor)))
       tree))
      
      <JAVASCRIPT>
function scale_tree(tree, factor) {
    return map(sub_tree =&gt; is_pair(sub_tree)
                           ? scale_tree(sub_tree, factor)
                           : sub_tree * factor, 
               tree);
}
      </JAVASCRIPT>
    </SNIPPET>
    Many tree operations can be implemented by similar combinations of
    sequence operations and recursion.
  </TEXT>

  <EXERCISE>
    <LABEL NAME="ex:square-tree"></LABEL>
    <SPLITINLINE>
      Define a procedure
      <JAVASCRIPT>Declare a function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      square-tree
      <JAVASCRIPT><JAVASCRIPTINLINE>square_tree</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    analogous to the
    <SPLITINLINE>
      square-list
      <JAVASCRIPT><JAVASCRIPTINLINE>square_list</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of exercise<SPACE></SPACE><REF NAME="ex:square-list"></REF>.  That is,
    <SPLITINLINE>
      square-tree
      <JAVASCRIPT><JAVASCRIPTINLINE>square_tree</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    should behave as follows:
    <SNIPPET HIDE="yes">
      <NAME>square_tree</NAME>
      
      
      <JAVASCRIPT>
// square_tree to be written by student	    
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>square_tree_example</NAME>
      <REQUIRES>square_tree</REQUIRES>
      
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
      
      <SCHEMEOUTPUT>
(1 (4 (9 16) 25) (36 49))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square_tree(list(1,
                 list(2, list(3, 4), 5), 
                 list(6, 7)));
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
tail(tail(square_tree(list(1,
                 list(2, list(3, 4), 5), 
                 list(6, 7)))));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(1, list(4, list(9, 16), 25), list(36, 49)))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SPLITINLINE>
      Define square-tree
      <JAVASCRIPT>Declare <JAVASCRIPTINLINE>square_tree</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    both directly (i.e., without using any higher-order
    <SPLITINLINE>
      procedures)
    <JAVASCRIPT>functions)</JAVASCRIPT></SPLITINLINE>
    and also by using
    map and recursion.
    <SOLUTION>
      Directly:	  
      <SNIPPET>
	<NAME>square_tree_pedestrian</NAME>
	<REQUIRES>square_definition</REQUIRES>
	<EXAMPLE>square_tree_example</EXAMPLE>
	<EXPECTED>[ [ 36, [ 49, null ] ], null ]</EXPECTED>
	<JAVASCRIPT>
function square_tree(tree) {
    return is_null(tree)
           ? null
           : ! is_pair(tree)
           ? square(tree)
           : pair(square_tree(head(tree)),
                  square_tree(tail(tree)));
}
	</JAVASCRIPT>
	<JAVASCRIPT_OUTPUT>
[1, [[4, [[9, [16, null]], [25, null]]], [[36, [49, null]], null]]]
	</JAVASCRIPT_OUTPUT>
      </SNIPPET>
      The version using <JAVASCRIPTINLINE>map</JAVASCRIPTINLINE>:
      <SNIPPET>
	<NAME>square_tree_with_map</NAME>
	<REQUIRES>square_definition</REQUIRES>
	<EXAMPLE>square_tree_example</EXAMPLE>
	<EXPECTED>[ [ 36, [ 49, null ] ], null ]</EXPECTED>
	<JAVASCRIPT>
function square_tree(tree) {
    return map(sub_tree =&gt; ! is_pair(sub_tree)
                           ? square(sub_tree)
                           : square_tree(sub_tree),
               tree);
}
	</JAVASCRIPT>
	<JAVASCRIPT_OUTPUT>
[1, [[4, [[9, [16, null]], [25, null]]], [[36, [49, null]], null]]]
	</JAVASCRIPT_OUTPUT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:tree-map"></LABEL>
    Abstract your answer to exercise<SPACE></SPACE><REF NAME="ex:square-tree"></REF> to
    produce a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
     <INDEX><USE>tree_map</USE></INDEX> 
    <SPLITINLINE>
      tree-map
      <JAVASCRIPT><JAVASCRIPTINLINE>tree_map</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    with the property that
    <SPLITINLINE>
      
	square-tree
	could be defined as
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>square_tree</JAVASCRIPTINLINE>
	could be declared as	
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET HIDE="yes">
      <NAME>tree_map</NAME>
      <EXAMPLE>square_tree_example</EXAMPLE>
      
;; tree_map to be written by student
      
      <JAVASCRIPT>
// tree_map to be written by student
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET POSTPADDING="no">
      <NAME>square_tree_using_tree_map</NAME>
      <REQUIRES>tree_map</REQUIRES>
      
(define (square-tree tree) (tree-map square tree))
      
      <JAVASCRIPT>
function square_tree(tree) { return tree_map(square, tree); }
      </JAVASCRIPT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>tree_map_with_map</NAME>
	<REQUIRES>square_definition</REQUIRES>
	<REQUIRES>square_tree_using_tree_map</REQUIRES>
	<EXAMPLE>square_tree_example</EXAMPLE>
	<EXPECTED>[ [ 36, [ 49, null ] ], null ]</EXPECTED>
	<JAVASCRIPT>
function tree_map(f, tree) {
    return map(sub_tree =&gt; is_null(sub_tree)
                           ? null
                           : is_pair(sub_tree)
                           ? tree_map(f, sub_tree)
                           : f(sub_tree),
               tree);
}
	</JAVASCRIPT>
	<JAVASCRIPT_OUTPUT>
[1, [[4, [[9, [16, null]], [25, null]]], [[36, [49, null]], null]]]
	</JAVASCRIPT_OUTPUT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <DO_BREAK_PAGE></DO_BREAK_PAGE>
  <EXERCISE>
    We can represent a
    <INDEX>set<SUBINDEX>subsets of</SUBINDEX></INDEX>
    set as a list of distinct elements, and we can
    represent the set of all subsets of the set as a list of lists.  For
    example, if the set is
    <SPLITINLINE>
      (1 2 3),
      <JAVASCRIPT><JAVASCRIPTINLINE>list(1, 2, 3)</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    then the set of all subsets is
    <SPLITINLINE>
      
	(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)).
      
      <JAVASCRIPT>
      <SNIPPET EVAL="no">
	<JAVASCRIPT>
list(null, list(3), list(2), list(2, 3),
     list(1), list(1, 3), list(1, 2),	  
     list(1, 2, 3))
	</JAVASCRIPT>
      </SNIPPET>
      </JAVASCRIPT>
    </SPLITINLINE>
    Complete the
    following 
    <SPLITINLINE>
      definition of a procedure
      <JAVASCRIPT>declaration of a function</JAVASCRIPT>
    </SPLITINLINE>
    that generates the set of subsets of a set and give a clear explanation of
    why it works:
    <SNIPPET POSTPADDING="no" LATEX="yes">
      <INDEX><DECLARATION>subsets</DECLARATION> of a set<FRAGILE></FRAGILE></INDEX>
      
(define (subsets s)
  (if (null? s)
    (list nil)
    (let ((rest (subsets (cdr s))))
      (append rest (map ?? rest)))))
      
      <JAVASCRIPT>
function subsets(s) {
    if (is_null(s)) {
        return list(null);
    } else {
        const rest = subsets(tail(s));
        return append(rest, map(<METAPHRASE>??</METAPHRASE>, rest));
    }
}
      </JAVASCRIPT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>sublists</NAME>
	<EXAMPLE>example_2.33</EXAMPLE>
	<EXPECTED>4</EXPECTED>
	<JAVASCRIPT>
function subsets(s) {
    if (is_null(s)) {
        return list(null);
    } else {
        const rest = subsets(tail(s));
        return append(rest, map(x =&gt; pair(head(s), x), rest));
    }
}
	</JAVASCRIPT>
	<JAVASCRIPT_OUTPUT>
[ null,
  [ [3, null],
    [ [2, null],
      [ [2, [3, null]],
        [ [1, null],
          [ [1, [3, null]],
            [ [1, [2, null]],
              [[1, [2, [3, null]]], null]
            ]
          ]
        ]
      ]
    ]	    
  ]
]
	</JAVASCRIPT_OUTPUT>
	
	
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>example_2.33</NAME>
	<JAVASCRIPT>
subsets(list(1, 2, 3));
	</JAVASCRIPT>
	<JAVASCRIPT_TEST>
length(subsets(list(1, 2)));
	</JAVASCRIPT_TEST>
      </SNIPPET>
      The argument starts in a similar way as the argument for the function
      <JAVASCRIPTINLINE>cc</JAVASCRIPTINLINE>
      in section<SPACE></SPACE><REF NAME="sec:tree-recursion"></REF>: A subset either
      contains the first element <LATEXINLINE>$e$</LATEXINLINE> of the given
      set, or it doesn&apos;t. If it doesn&apos;t, the problem becomes strictly smaller:
      Compute all subsets of the tail of the list that represents the given
      set. If it does, it must result from adding <LATEXINLINE>$e$</LATEXINLINE>
      to a subset that doesn&apos;t contain <LATEXINLINE>$e$</LATEXINLINE>. In the
      end, we need to append both lists of subsets to obtain the list of all
      subsets.
    </SOLUTION>
    <LABEL NAME="ex:2_32"></LABEL>
  </EXERCISE>
  <INDEX>tree<SUBINDEX>mapping over</SUBINDEX><CLOSE></CLOSE></INDEX>
  <INDEX>mapping<SUBINDEX><ORDER>tree</ORDER>over trees</SUBINDEX><CLOSE></CLOSE></INDEX>
</SUBSECTION>
