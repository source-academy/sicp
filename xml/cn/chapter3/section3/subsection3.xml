<SUBSECTION> 
   <NAME>
    表示表
  </NAME> 

  <LABEL NAME="sec:tables"></LABEL>
   <INDEX>表<OPEN></OPEN></INDEX> 

   <SHORT_PAGE LINES="1"></SHORT_PAGE> 
   <TEXT>
    当我们在<REF NAME="chap:data"></REF>章节研究表示集合的各种方法时，我们在<REF NAME="sec:representing-sets"></REF>部分提到了通过识别键维护一个记录<INDEX>记录的键<SUBINDEX>在表中</SUBINDEX></INDEX>的任务。在<REF NAME="sec:data-directed"></REF>部分的数据导向编程的实现中，我们大量使用了二维表，其中通过两个键存储和检索信息。在这里，我们介绍如何将表构建为可变的列表结构。
  </TEXT> 

  <TEXT> 
    我们首先考虑一个<INDEX>表<SUBINDEX>一维<OPEN></OPEN></SUBINDEX></INDEX>一维表，其中每个值都存储在单个键下。我们将表实现为一个记录的列表，每个记录实现为一个由键和值组成的对。记录通过那些指向相继记录的cars<JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>s</JAVASCRIPT>对连接在一起形成列表。这些连接的对称为表的<INDEX>表<SUBINDEX>的主干</SUBINDEX></INDEX><EM>主干</EM>。为了在向表中添加新记录时可以更改的位置，我们将表构建为一个<INDEX>带头结点的列表</INDEX><INDEX>列表<SUBINDEX>带头结点</SUBINDEX></INDEX><EM>带头结点的列表</EM>。带头结点的列表在开始处有一个特殊的主干对，该对持有一个<QUOTE>伪记录</QUOTE><EMDASH>在这种情况下，任意选择的符号*table*.<JAVASCRIPT>字符串<JAVASCRIPTINLINE>&quot;*table*&quot;</JAVASCRIPTINLINE>.</JAVASCRIPT> 图<SPACE></SPACE><REF NAME="fig:table_scheme"></REF><JAVASCRIPT>图<SPACE></SPACE><REF NAME="fig:table"></REF></JAVASCRIPT>显示了表的方框与指针表示法。
 </EMDASH><SNIPPET EVAL="no">
      <SCHEME>
a:  1
b:  2
c:  3
      </SCHEME>
      <JAVASCRIPT>
a: 1
b: 2
c: 3
      </JAVASCRIPT>
    </SNIPPET>
     <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-22.svg"></FIGURE>
          <CAPTION>作为带头结点列表表示的表。 </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-22.svg"></FIGURE>
          <CAPTION>作为带头结点列表表示的表。 </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
   </TEXT>

  <TEXT> 
    要从表中提取信息，我们使用
<SCHEMEINLINE>lookup</SCHEMEINLINE>
     <SPLITINLINE>
      过程,
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    它接受一个键作为参数并返回相关的值(
    <SPLITINLINE>
      假
      <JAVASCRIPT><JAVASCRIPTINLINE>未定义</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    如果
    在那个键下没有存储值)。
    <SPLITINLINE>
      查找
      <JAVASCRIPT>函数<JAVASCRIPTINLINE>查找</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    是根据
<SCHEMEINLINE>assoc</SCHEMEINLINE> 操作，期望一个键和一个记录列表作为参数。注意<SCHEMEINLINE>assoc</SCHEMEINLINE> 从未看到伪记录。
    <SPLITINLINE>
      Assoc
      <JAVASCRIPT>函数<JAVASCRIPTINLINE>assoc</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    返回具有给定键作为其car<JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>的记录。
    <FOOTNOTE>
    <SPLIT>
      
	因为assoc使用
	equal?，它可以识别
	是符号、数字或列表结构的键。
      
      <JAVASCRIPT>
	因为 assoc 使用
	<JAVASCRIPTINLINE>equal</JAVASCRIPTINLINE>，它可以识别
	是字符串、数字或列表结构的键。&lt;!--  
     --&gt;</JAVASCRIPT>&lt;!--  
   --&gt;</SPLIT></FOOTNOTE>
    <SPLITINLINE>
      查找
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>查找</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    然后检查所返回的记录
<SCHEMEINLINE>assoc</SCHEMEINLINE> 不是
    <SPLITINLINE>
      假,
      <JAVASCRIPT><JAVASCRIPTINLINE>未定义</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    并返回值（记录的
    <SPLITINLINE>
      cdr）
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>）</JAVASCRIPT>
    。
     </SPLITINLINE><SNIPPET HIDE="yes">
      <NAME>lookup1_example</NAME>
      <REQUIRES>make_table1</REQUIRES>
      <REQUIRES>insert_into_table1</REQUIRES>
      <JAVASCRIPT>
const t = make_table();
insert(&quot;a&quot;, 10, t);
lookup(&quot;a&quot;, t);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>lookup</DECLARATION><SUBINDEX>in one-dimensional table</SUBINDEX></INDEX>
      <INDEX><DECLARATION>assoc</DECLARATION></INDEX>
      <NAME>lookup1</NAME>
      <EXAMPLE>lookup1_example</EXAMPLE>
      <EXPECTED>10</EXPECTED>
      <SCHEME>
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))

(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
      </SCHEME>
      <JAVASCRIPT>
function lookup(key, table) {
    const record = assoc(key, tail(table));
    return is_undefined(record)
           ? undefined
           : tail(record);
}
function assoc(key, records) {
    return is_null(records)
           ? undefined
           : equal(key, head(head(records)))
           ? head(records)
           : assoc(key, tail(records));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT> 
    要在指定键下插入一个值到表中，我们首先使用
<SCHEMEINLINE>assoc</SCHEMEINLINE> 查看表中是否已有该键的记录。如果没有，我们通过将键与值cons组成<JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>一个新记录，并将其插入到表的记录列表的头部，在伪记录之后。如果已有该键的记录，我们设置此记录的cdr<JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>为指定的新值。表的头部为我们提供了一个固定的位置进行修改以插入新记录。<FOOTNOTE>因此，第一个主干对是表示表“自身”的对象；即，指向表的指针就是指向这个对的指针。同一主干对总是开始于表。如果我们不这样安排，
    <SPLITINLINE>
      插入!
      <JAVASCRIPT><JAVASCRIPTINLINE>插入</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    在添加新记录时将需要返回表开始的新值。</FOOTNOTE> 
<SNIPPET EVAL="yes">
      <INDEX><DECLARATION>insert</DECLARATION><SUBINDEX>in one-dimensional table</SUBINDEX></INDEX>
      <REQUIRES>lookup1</REQUIRES>
      <NAME>insert_into_table1</NAME>
      <SCHEME>
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table)))))
  &apos;ok)
      </SCHEME>
      <JAVASCRIPT>
function insert(key, value, table) {
    const record = assoc(key, tail(table));
    if (is_undefined(record)) {
        set_tail(table,
                 pair(pair(key, value), tail(table)));
    } else {
        set_tail(record, value);
    }
    return &quot;ok&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

   <TEXT>
    要构建新的表，我们只需创建一个包含
    <SPLITINLINE>
      
	符号*table*:
      
      <JAVASCRIPT>
	仅包含字符串&quot;*table*&quot;:
      </JAVASCRIPT>
    </SPLITINLINE>
    
      <INDEX><DECLARATION>make_table</DECLARATION><SUBINDEX>一维表</SUBINDEX></INDEX>
      <NAME>make_table1</NAME>
      
(define (make-table)
  (list &apos;*table*))
      
      <JAVASCRIPT>
function make_table() {
    return list(&quot;*table*&quot;);
}
      </JAVASCRIPT>
    
    <INDEX>表<SUBINDEX>一维<CLOSE></CLOSE></SUBINDEX></INDEX>
  </TEXT> 

   <SUBHEADING> 
    <NAME>二维表</NAME>
  </SUBHEADING> 

   <INDEX>表<SUBINDEX>二维<OPEN></OPEN></SUBINDEX></INDEX> 

   <SHORT_PAGE LINES="1"></SHORT_PAGE> 
   <TEXT>
    在二维表中，每个值由两个键索引。我们可以将这样的表构建为一维表，其中每个键标识一个子表。
    <SPLITINLINE>
      
        图<SPACE></SPACE><REF NAME="fig:2dtable_scheme"></REF>
      
      <JAVASCRIPT>
        图<SPACE></SPACE><REF NAME="fig:2dtable"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    显示了表的方框与指针表示法
    
      
math:
    +:  43
    -:  45
    *:  42
letters:
    a:  97
    b:  98
      
      <JAVASCRIPT>
&quot;math&quot;:
    &quot;+&quot;:  43
    &quot;-&quot;:  45
    &quot;*&quot;:  42
&quot;letters&quot;:
    &quot;a&quot;:  97
    &quot;b&quot;:  98
      </JAVASCRIPT>
    
    其具有两个子表。 (子表不需要特殊的头符号,<JAVASCRIPT>串,</JAVASCRIPT>因为标识子表的键起到这个作用。)
    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-23.svg"></FIGURE>
          <CAPTION>一个二维表。</CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-23.svg"></FIGURE>
          <CAPTION>一个二维表。</CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT> 

   <TEXT>
    当查找一个项目时，我们使用第一个键来识别正确的子表。然后我们使用第二个键来识别子表中的记录。
    
      <NAME>lookup2_example</NAME>
      <REQUIRES>make_table2</REQUIRES>
      <REQUIRES>insert_into_table2</REQUIRES>
      <JAVASCRIPT>
const t = list(&quot;*table*&quot;);
insert(&quot;a&quot;, &quot;b&quot;, 10, t);
lookup(&quot;a&quot;, &quot;b&quot;, t);
      </JAVASCRIPT>
    
    
      <NAME>just_assoc</NAME>
      <JAVASCRIPT>
function assoc(key, records) {
    return is_null(records)
           ? undefined
           : equal(key, head(head(records)))
           ? head(records)
           : assoc(key, tail(records));
}
      </JAVASCRIPT>
    
    
      <INDEX><DECLARATION>查找</DECLARATION><SUBINDEX>在二维表中</SUBINDEX></INDEX>
      <NAME>lookup2</NAME>
      <REQUIRES>just_assoc</REQUIRES>
      <EXAMPLE>lookup2_example</EXAMPLE>
      <EXPECTED>10</EXPECTED>
      
(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
      
      <JAVASCRIPT>
function lookup(key_1, key_2, table) {
    const subtable = assoc(key_1, tail(table));
    if (is_undefined(subtable)) {
        return undefined;
    } else {
        const record = assoc(key_2, tail(subtable));
        return is_undefined(record)
               ? undefined
               : tail(record);
    }
}
      </JAVASCRIPT>
    
  </TEXT> 

  <TEXT> 
    要在一对键下插入新项目，我们使用
<SCHEMEINLINE>assoc</SCHEMEINLINE> 看是否已有子表存储在第一个键下。如果没有，我们构建一个包含单个记录的新子表
    <SPLITINLINE>
      (key-2,
      <JAVASCRIPT>(<JAVASCRIPTINLINE>key_2</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
<SCHEMEINLINE>value</SCHEMEINLINE> ) 并将其插入到第一个键下的表中。如果第一个键已经存在子表，我们将新记录插入到该子表中，使用上述一维表的插入方法：
<SNIPPET EVAL="yes" POSTPADDING="no">
      <INDEX><DECLARATION>insert</DECLARATION><SUBINDEX>in two-dimensional table</SUBINDEX></INDEX>
      <REQUIRES>just_assoc</REQUIRES>
      <NAME>insert_into_table2</NAME>
      <SCHEME>
(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr table)))))
  &apos;ok)
      </SCHEME>
      <JAVASCRIPT>
function insert(key_1, key_2, value, table) {
    const subtable = assoc(key_1, tail(table));
    if (is_undefined(subtable)) {
        set_tail(table,
                 pair(list(key_1, pair(key_2, value)), tail(table)));
    } else {
        const record = assoc(key_2, tail(subtable));
        if (is_undefined(record)) {
            set_tail(subtable,
                     pair(pair(key_2, value), tail(subtable)));
        } else {
            set_tail(record, value);
        }
    }
    return &quot;ok&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
     <INDEX>表<SUBINDEX>二维<CLOSE></CLOSE></SUBINDEX></INDEX>
   </TEXT>

   <SUBHEADING> 
    <NAME>创建局部表</NAME>
  </SUBHEADING> 

   <INDEX>表<SUBINDEX>局部<OPEN></OPEN></SUBINDEX></INDEX> 

  <TEXT> 
    该
<SCHEMEINLINE>lookup</SCHEMEINLINE>  和
    <SPLITINLINE>
      插入！
      <JAVASCRIPT><JAVASCRIPTINLINE>插入</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    上述操作将表作为参数。这使我们能够使用访问多个表的程序。处理多个表的另一种方法是拥有单独的
<SCHEMEINLINE>lookup</SCHEMEINLINE>  和
    <SPLITINLINE>
      插入！
      <JAVASCRIPT><JAVASCRIPTINLINE>插入</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    为每个表提供。我们可以通过过程化地表示一个表来做到这一点，作为一个维护内部表的对象，作为其局部状态的一部分。当收到合适的消息时，此<QUOTE>表对象</QUOTE>提供操作内部表的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。这是以这种方式表示的二维表的生成器：
<SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_table</DECLARATION><SUBINDEX>message-passing implementation</SUBINDEX></INDEX>
      <NAME>make_table2</NAME>
      <REQUIRES>just_assoc</REQUIRES>
      <SCHEME>
(define (make-table)
  (let ((local-table (list &apos;*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      &apos;ok)    
    (define (dispatch m)
      (cond ((eq? m &apos;lookup-proc) lookup)
            ((eq? m &apos;insert-proc!) insert!)
            (else (error &quot;Unknown operation - - TABLE&quot; m))))
  dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_table() {
    const local_table = list(&quot;*table*&quot;);
    function lookup(key_1, key_2) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            return undefined;
        } else {
            const record = assoc(key_2, tail(subtable));
            return is_undefined(record)
                   ? undefined
                   : tail(record);
        }
    }
    function insert(key_1, key_2, value) {
        const subtable = assoc(key_1, tail(local_table));
        if (is_undefined(subtable)) {
            set_tail(local_table,
                     pair(list(key_1, pair(key_2, value)),
                          tail(local_table)));
        } else {
            const record = assoc(key_2, tail(subtable));
            if (is_undefined(record)) {
                set_tail(subtable,
                         pair(pair(key_2, value), tail(subtable)));
            } else {
                set_tail(record, value);
            }
        }
    }
    function dispatch(m) {
        return m === &quot;lookup&quot;
               ? lookup
               : m === &quot;insert&quot;
               ? insert
               : error(m, &quot;unknown operation -- table&quot;);
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT> 
    使用
    <SPLITINLINE>
      make-table,
      <JAVASCRIPT><JAVASCRIPTINLINE>make_table</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    我们可以
    <INDEX>操作与类型表<SUBINDEX>实现</SUBINDEX></INDEX>
    实现该
<SCHEMEINLINE>get</SCHEMEINLINE> 和
     <SCHEMEINLINE>put</SCHEMEINLINE>  操作用于<REF NAME="sec:data-directed"></REF>部分的数据导向编程，如下所示：
     <SNIPPET HIDE="yes">
      <NAME>operation_table_example</NAME>
      <JAVASCRIPT>
put(&quot;a&quot;, &quot;b&quot;, 10);
get(&quot;a&quot;, &quot;b&quot;);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>get</DECLARATION></INDEX> 
      <INDEX><DECLARATION>put</DECLARATION></INDEX> 
      <NAME>operation_table</NAME>
      <REQUIRES>make_table2</REQUIRES>
      <EXAMPLE>operation_table_example</EXAMPLE>
      <EXPECTED>10</EXPECTED>
      <SCHEME>
        <INDEX>operation-and-type table<SUBINDEX>implementing</SUBINDEX></INDEX>
(define operation-table (make-table))
(define get (operation-table &apos;lookup-proc))
(define put (operation-table &apos;insert-proc!))
      </SCHEME>
      <JAVASCRIPT>
const operation_table = make_table();
const get = operation_table(&quot;lookup&quot;);
const put = operation_table(&quot;insert&quot;);
      </JAVASCRIPT>
    </SNIPPET>
     <SPLITINLINE>
      获取
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>get</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    接受两个键作为参数，并
<SCHEMEINLINE>put</SCHEMEINLINE>  接受两个键和一个值作为参数。两个操作都访问同一个局部表，该表封装在
    <SPLITINLINE>
      make-table.
      <JAVASCRIPT><JAVASCRIPTINLINE>make_table</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>表<SUBINDEX>局部<CLOSE></CLOSE></SUBINDEX></INDEX>
   </TEXT>

  <EXERCISE>  
    在上述表实现中，使用 
    <INDEX>表<SUBINDEX>测试键相等性</SUBINDEX></INDEX>
    <INDEX>记录的键<SUBINDEX>测试相等性</SUBINDEX></INDEX>
    通过
    <SPLITINLINE>
      equal?
      <JAVASCRIPT><JAVASCRIPTINLINE>equal</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    进行测试（由
<SCHEMEINLINE>assoc</SCHEMEINLINE> ). 这并不总是合适的测试。例如，我们可能有一个带有数值键的表，其中我们查找的不是需要与数字完全匹配，而是只需在某个容差范围内的数字。设计一个表构造器 
    <SPLITINLINE>
      make-table
      <JAVASCRIPT><JAVASCRIPTINLINE>make_table</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    接受一个 
    <SPLITINLINE>
      same-key?
      <JAVASCRIPT><JAVASCRIPTINLINE>same_key</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    作为参数，用于测试键的“相等性”。
    <SPLITINLINE>
      Make-table
      <JAVASCRIPT>函数 <JAVASCRIPTINLINE>make_table</JAVASCRIPTINLINE>
    </JAVASCRIPT></SPLITINLINE>
    应返回一个【134:12†cn.txt】。<SCHEMEINLINE>dispatch</SCHEMEINLINE>
     <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    可用于访问适当的 
     <SCHEMEINLINE>lookup</SCHEMEINLINE>  和
    <SPLITINLINE>
      插入！
      <JAVASCRIPT><JAVASCRIPTINLINE>插入</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程<JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    用于局部表。
     <LABEL NAME="ex:numeric-keys"></LABEL>
     <SOLUTION>
      
	<JAVASCRIPT>
// Solution by GitHub user clean99

function make_table(same_key) {
    const local_table = list(&quot;*table*&quot;);
    function assoc(key, records) {
        return is_null(records)
               ? undefined
               : same_key(key, head(head(records)))
               ? head(records)
               : assoc(key, tail(records));
    }
    function lookup(key) {
        const record = assoc(key, tail(local_table));
        return is_undefined(record)
               ? undefined
               : tail(record);
    }
    function insert(key, value) {
        const record = assoc(key, tail(local_table));
        if (is_undefined(record)) {
               set_tail(local_table,
                        pair(pair(key, value), tail(local_table)));
            } else {
               set_tail(record, value);
            }
            return &quot;ok&quot;;
    }
    function dispatch(m) {
        return m === &quot;lookup&quot;
               ? lookup
               : m === &quot;insert&quot;
               ? insert
               : error(m, &quot;unknow operation -- table&quot;);
    }
    return dispatch;
}

const operation_table = make_table((a, b) =&gt; a === b);
const get = operation_table(&quot;lookup&quot;);
const put = operation_table(&quot;insert&quot;);
	</JAVASCRIPT>
      
    </SOLUTION>
   </EXERCISE>

  <EXERCISE>  
    概括一维和二维表，展示如何实现一个在其中值存储在一个
    <INDEX>表<SUBINDEX><ORDER>n</ORDER>$n$维</SUBINDEX></INDEX>
    任意数量的键的表，并且不同的值可以存储在不同数量的键下。
    该【150:4†cn.txt】
     <SCHEMEINLINE>lookup</SCHEMEINLINE> 和
    <SPLITINLINE>
      插入！
      <JAVASCRIPT><JAVASCRIPTINLINE>插入</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    应接受一个用于访问表的键列表作为输入。
<LABEL NAME="ex:3_25"></LABEL>
    <SOLUTION>
      <SNIPPET>
	<NAME>solution_3_25</NAME>
	<EXAMPLE>solution_3_25_example</EXAMPLE>
	<JAVASCRIPT>
// contributed by GitHub user tttinkl

function assoc(key, records, same_key) {
  return is_null(records)
    ? undefined
    : same_key(key, head(head(records)))
    ? head(records)
    : assoc(key, tail(records), same_key);
}


function make_table(same_key) {
  const local_table = list(&quot;*table&quot;);

  const get_value = tail;

  function is_table(t) {
    return is_pair(t) &amp;&amp; head(t) === &quot;*table&quot;;
  }

  function lookup(keys) {
    function lookup_generic(keys, table) {
      if (is_null(keys)) {
        return table;
      }
      const key_1 = head(keys);
      const key_rest = tail(keys);
      const record = assoc(key_1, tail(table), same_key);
      if (is_undefined(record)) {
        return undefined;
      }
      if (is_null(key_rest)) {
        return get_value(record);
      } else if (is_table(get_value(record))) {
        return lookup_generic(key_rest, get_value(record));
      } else {
        error(&apos;invalid key&apos;);
      }
    }
    return lookup_generic(keys, local_table);
  }


  function insert(keys, value) {
    function insert_generic(keys, value, table) {
      const key_1 = head(keys);
      const key_rest = tail(keys);
      const record = assoc(key_1, tail(table), same_key);
      if (is_undefined(record)) {
        if (is_null(key_rest)) {
          set_tail(
            table,
            pair(pair(key_1, value), tail(table)));
        } else {
          const new_subtable = list(&quot;*table&quot;);
          set_tail(
            table,
            pair(pair(key_1, new_subtable), tail(table))
          );
          insert_generic(key_rest, value, new_subtable);
        }
      } else {
        if (is_null(key_rest)) {
          set_tail(record, value);
        } else {
          if (is_table(get_value(record))) {
            insert_generic(key_rest, value, get_value(record));
          } else {
            const new_subtable = list(&quot;*table&quot;);
            set_tail(record, new_subtable);
            insert_generic(key_rest, value, new_subtable);
          }
        }
      }
    }
    insert_generic(keys, value, local_table);
  }

  function dispatch(m) {
    return m === &quot;lookup&quot;
      ? lookup
      : m === &quot;insert&quot;
      ? insert
      : m === &quot;show&quot;
      ? () =&gt; {
        display(local_table);
        return local_table;
      }
      : error(m, &quot;unknow operation -- table&quot;);
  }
  return dispatch;
}

const table = make_table(equal);

const get = table(&apos;lookup&apos;);
const put = table(&apos;insert&apos;);
const show = table(&apos;show&apos;);
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>solution_3_25_example</NAME>
	<JAVASCRIPT>
put(list(&quot;a&quot;), 1);
put(list(&quot;b&quot;, &quot;c&quot;), 2);
put(list(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;), 3);

display(get(list(&quot;a&quot;)));
display(get(list(&quot;b&quot;, &quot;c&quot;)));
display(get(list(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)));

put(list(&quot;a&quot;, &quot;b&quot;), 1);
display(get(list(&quot;a&quot;)));
put(list(&quot;b&quot;, &quot;c&quot;, &quot;d&quot;), 2);
display(get(list(&quot;b&quot;, &quot;c&quot;)));
put(list(&quot;b&quot;), 1);
display(get(list(&quot;b&quot;)));
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE> 
    要搜索上面实现的表，需扫描记录列表。这基本上是<REF NAME="sec:representing-sets"></REF>部分中无序列表的表示。对于大型表，可能更有效率的是以不同方式构建表。描述一种表的实现方式，其中(key, value)记录使用
    <INDEX>二叉树<SUBINDEX>表结构为</SUBINDEX></INDEX>
    <INDEX>表<SUBINDEX>表示为二叉树 vs. 无序列表</SUBINDEX></INDEX>
    二叉树组织，假设键可以以某种方式排序（例如，数字或字母顺序）。（比较<REF NAME="ex:set-lookup-binary-tree"></REF>练习的<REF NAME="chap:data"></REF>章节。）
     <LABEL NAME="ex:3_26"></LABEL>
    <SOLUTION>
      <SNIPPET>
	<NAME>ex_3_26_solution</NAME>
	<EXAMPLE>ex_3_26_solution_example</EXAMPLE>
	<JAVASCRIPT>
// provided by GitHub user devinryu

function entry(tree) { return head(tree); }
function left_branch(tree) { return head(tail(tree)); }
function right_branch(tree) { return head(tail(tail(tree))); }
function make_tree(entry, left, right) { 
    return list(entry, left, right);
}

// kv is list(key, value)
function adjoin_set(kv, set) {
    return is_null(set)
           ? make_tree(kv, null, null)
           : head(kv) === head(entry(set))
           ? set
           : head(kv) &lt; head(entry(set))
           ? make_tree(entry(set),
                       adjoin_set(kv, left_branch(set)),
                       right_branch(set))
           : make_tree(entry(set),
                       left_branch(set),
                       adjoin_set(kv, right_branch(set)));
}

function make_table() {
    let local_table = null;
    function lookup(given_key, tree_of_records) {
        if (is_null(tree_of_records)) {
            return null;
        } else {
            const this_entry = entry(tree_of_records);
            const this_key = head(this_entry);
            return given_key === this_key 
                   ? this_entry
                   : given_key &lt; this_key
                   ? lookup(given_key, 
                            left_branch(tree_of_records))
                   : lookup(given_key, 
                            right_branch(tree_of_records));
        }
    }
    function insert(k, v) {
        let record = lookup(k, local_table);
        if(is_null(record)) {
            local_table = adjoin_set(list(k, v), local_table);
        } else {
            // do nothing
        }
    }
    function get(k) {
        return head(tail(lookup(k, local_table)));
    }
    function print() {
        return display(local_table);
    }
    function dispatch(m) {
        return m === &quot;lookup&quot;
        ? get
        : m === &quot;insert&quot;
        ? insert
        : m  === &quot;print&quot;
        ? print
        : error(m, &quot;error&quot;);
    }
    return dispatch;
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>ex_3_26_solution_example</NAME>
	<JAVASCRIPT>
const t = make_table();
const get = t(&quot;lookup&quot;);
const put = t(&quot;insert&quot;);
const print = t(&quot;print&quot;);

// The test results

put(3, &quot;d&quot;);
put(1, &quot;a&quot;);
put(2, &quot;b&quot;);
put(2, &quot;c&quot;);
put(4, &quot;e&quot;);
put(5, &quot;f&quot;);

print();

display(get(2)); // displays: &quot;b&quot;
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
     <EM>记忆化</EM>
    <INDEX>记忆化</INDEX>
    <INDEX>制表法</INDEX>
    <INDEX>表<SUBINDEX>用于存储计算值</SUBINDEX></INDEX>
    <INDEX><FUNCTION></FUNCTION><SUBINDEX>记忆化</SUBINDEX></INDEX>
    （也称为<EM>制表法</EM>）是一种技术，它使
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    能够在局部表中记录先前计算过的值。这个技术可以显著改善程序的性能。一个记忆化的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    维护一个表，其中将之前调用的值使用生成这些值的参数作为键存储。当记忆化的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    被要求计算一个值时，首先查看表中是否已有该值，如果有，则直接返回该值。否则，它按常规方式计算新值并存储在表中。作为记忆化的一个例子，回忆<REF NAME="sec:tree-recursion"></REF>部分用于计算斐波那契数的指数过程：
     <SNIPPET EVAL="yes">
      <EXAMPLE>fib_example</EXAMPLE>
      <EXPECTED>8</EXPECTED>
      <SCHEME>
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
      </SCHEME>
      <JAVASCRIPT>
function fib(n) {
    return n === 0
           ? 0
           : n === 1
           ? 1
           : fib(n - 1) + fib(n - 2);
}
      </JAVASCRIPT>
    </SNIPPET> 
    相同过程<JAVASCRIPT>函数</JAVASCRIPT>的记忆化版本是
     <SNIPPET HIDE="yes">
      <NAME>memorize_example</NAME>
      <JAVASCRIPT>
memo_fib(5);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>fib</DECLARATION><SUBINDEX>with memoization</SUBINDEX><FRAGILE></FRAGILE></INDEX>
      <INDEX><DECLARATION>memo_fib</DECLARATION></INDEX> 
      <NAME>memo_fib</NAME>
      <REQUIRES>memorize</REQUIRES>
      <EXAMPLE>memorize_example</EXAMPLE>
      <EXPECTED>5</EXPECTED>
      <SCHEME>
(define memo-fib
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (memo-fib (- n 1))
                            (memo-fib (- n 2))))))))
      </SCHEME>
      <JAVASCRIPT>
const memo_fib = memoize(n =&gt; n === 0
                              ? 0
                              : n === 1
                              ? 1
                              : memo_fib(n - 1) +
                                memo_fib(n - 2)
                        );
      </JAVASCRIPT>
    </SNIPPET> 
    记忆化器定义为
     <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>memoize</DECLARATION><FRAGILE></FRAGILE></INDEX> 
      <REQUIRES>make_table1</REQUIRES>
      <REQUIRES>lookup1</REQUIRES>
      <REQUIRES>insert_into_table1</REQUIRES>
      <NAME>memorize</NAME>
      <SCHEME>
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
      </SCHEME>
      <JAVASCRIPT>
function memoize(f) {
    const table = make_table();
    return x =&gt; {
               const previously_computed_result =
                   lookup(x, table);
               if (is_undefined(previously_computed_result)) {
                   const result = f(x);
                   insert(x, result, table);
                   return result;
               } else {
                   return previously_computed_result;
               }
           };
}
      </JAVASCRIPT>
    </SNIPPET> 
    其中记忆化版本的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    是
     <LATEXINLINE>$n$</LATEXINLINE> 第 n 个斐波那契数，其步骤数与 【166:2†cn.txt】 的比例相同。
     <LATEXINLINE>$n$</LATEXINLINE> 。该方案是否仍然有效，如果我们仅仅定义
    <SPLITINLINE>
      memo-fib
      <JAVASCRIPT><JAVASCRIPTINLINE>memo_fib</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    为
    <SPLITINLINE>
      (memoize fib)？
      <JAVASCRIPT><JAVASCRIPTINLINE>memoize(fib)</JAVASCRIPTINLINE>？</JAVASCRIPT>
    </SPLITINLINE>
     <LABEL NAME="ex:memoization"></LABEL>
  </EXERCISE>
   <INDEX>表<CLOSE></CLOSE></INDEX> 
</SUBSECTION>
