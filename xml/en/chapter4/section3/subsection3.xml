<SUBSECTION>
  <NAME>
    Implementing the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Amb</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    Evaluator
  </NAME>

  <LABEL NAME="sec:amb-implementation"/>

  <INDEX>nondeterministic evaluator<OPEN/></INDEX>

  <TEXT>
    The evaluation of an ordinary
    <SPLITINLINE>
      <SCHEME>Scheme expression</SCHEME>
      <JAVASCRIPT>JavaScript program</JAVASCRIPT>
    </SPLITINLINE>
    may return a value, may never terminate, or may signal an error.
    In nondeterministic
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    the evaluation of
    <SPLITINLINE>
      <SCHEME>an expression</SCHEME>
      <JAVASCRIPT>a program</JAVASCRIPT>
    </SPLITINLINE>
    may in addition result in the discovery of
    a dead end, in which case evaluation must backtrack to a previous choice
    point.  The interpretation of nondeterministic
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    is complicated by this extra case.
  </TEXT>

  <TEXT>
    We will construct the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator for
    nondeterministic
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    by modifying the
    <INDEX>analyzing evaluator<SUBINDEX>as basis for nondeterministic evaluator</SUBINDEX></INDEX>
    analyzing evaluator of
    section<SPACE/><REF NAME="sec:separating-analysis"/>.<FOOTNOTE>We chose to
    implement the lazy evaluator in
    section<SPACE/><REF NAME="sec:lazy-evaluation"/> as a modification of the
    ordinary metacircular evaluator of
    section<SPACE/><REF NAME="sec:core-of-evaluator"/>.  In contrast, we will
    base the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator on the analyzing
    evaluator of section<SPACE/><REF NAME="sec:separating-analysis"/>, because
    the execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in that evaluator provide a convenient framework for implementing
    backtracking.</FOOTNOTE> As in the analyzing evaluator, evaluation of
    <SPLITINLINE>
      <SCHEME>an expression</SCHEME>
      <JAVASCRIPT>a component</JAVASCRIPT>
    </SPLITINLINE>
    is accomplished by calling an 
    <INDEX>execution<SPLITINLINE> <SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    produced by analysis of that
    <SPLITINLINE>
      <SCHEME>expression.</SCHEME>
      <JAVASCRIPT>component.</JAVASCRIPT>
    </SPLITINLINE>
    The difference between the interpretation of ordinary
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    and the interpretation of nondeterministic
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    will be entirely
    in the execution
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <SUBHEADING>
    <NAME>
      Execution
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      and continuations
    </NAME>
  </SUBHEADING>

  <INDEX>continuation<SUBINDEX>in nondeterministic evaluator<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    Recall that the
    <INDEX>execution <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for the ordinary evaluator take one argument: the environment of execution.
    In contrast, the execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator take three arguments:
    the environment, and two
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    called
    <SPLITINLINE>
      <SCHEME><EM>continuation procedures</EM>.</SCHEME>
      <JAVASCRIPT><EM>continuation functions</EM>.</JAVASCRIPT>
    </SPLITINLINE>
    The evaluation of
    <SPLITINLINE>
      <SCHEME>an expression</SCHEME>
      <JAVASCRIPT>a component</JAVASCRIPT>
    </SPLITINLINE>
    will finish by calling one of these two
    continuations: If the evaluation results in a value, the 
    <INDEX>success continuation (nondeterministic evaluator)</INDEX>
    <EM>success continuation</EM> is called with that value; if the evaluation
    results in the discovery of a dead end, the 
    <INDEX>failure continuation (nondeterministic evaluator)</INDEX>
    <EM>failure continuation</EM> is called.  Constructing and calling
    appropriate continuations is the mechanism by which the nondeterministic
    evaluator implements backtracking.
  </TEXT>

  <TEXT>
    It is the job of the success continuation to receive a value and proceed
    with the computation.  Along with that value, the success continuation is
    passed another failure continuation, which is to be called subsequently if
    the use of that value leads to a dead end.
  </TEXT>

  <TEXT>
    It is the job of the failure continuation to try another branch of the
    nondeterministic process.  The essence of the nondeterministic
    language is in the fact that
    <SPLITINLINE>
      <SCHEME>expressions</SCHEME>
      <JAVASCRIPT>components</JAVASCRIPT>
    </SPLITINLINE>
    may represent choices among
    alternatives.  The evaluation of such
    <SPLITINLINE>
      <SCHEME>an expression</SCHEME>
      <JAVASCRIPT>a component</JAVASCRIPT>
    </SPLITINLINE>
    must proceed with
    one of the indicated alternative choices, even though it is not known
    in advance which choices will lead to acceptable results.  To deal
    with this, the evaluator picks one of the alternatives and passes this
    value to the success continuation.  Together with this value, the
    evaluator constructs and passes along a failure continuation that can
    be called later to choose a different alternative.
  </TEXT>

  <SHORT_PAGE lines="4"/>
  <TEXT>
    A failure is triggered during evaluation (that is, a failure
    continuation is called) when a user program explicitly rejects the
    current line of attack (for example, a call to
    <SCHEMEINLINE>require</SCHEMEINLINE> may result in execution of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(amb)</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>amb()</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    an expression that always
    fails<EMDASH/>see section<SPACE/><REF NAME="sec:amb"/>).  The failure
    continuation in hand at that point will cause the most recent choice point
    to choose another alternative.  If there are no more alternatives to be
    considered at that choice point, a failure at an earlier choice point
    is triggered, and so on.  Failure continuations are also invoked by
    the driver loop in response to a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    request, to find another value of the
    <SPLITINLINE>
      <SCHEME>expression.</SCHEME>
      <JAVASCRIPT>program.</JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    In addition, if a side-effect operation (such as assignment to a
    variable) occurs on a branch of the process resulting from a choice,
    it may be necessary, when the process finds a dead end, to undo the
    side effect before making a new choice.  This is accomplished by
    having the side-effect operation produce a failure continuation that
    undoes the side effect and propagates the failure.
  </TEXT>

  <TEXT>
    In summary, failure continuations are constructed by
    <UL>
      <LI>
	<SCHEMEINLINE>amb</SCHEMEINLINE> expressions<EMDASH/>to provide a
	mechanism to make alternative choices if the current choice made by the
	<SCHEMEINLINE>amb</SCHEMEINLINE> expression leads to a dead end;
      </LI>
      <LI>
	the top-level driver<EMDASH/>to provide a mechanism to report failure
	when the choices are exhausted;
      </LI>
      <LI>
	assignments<EMDASH/>to intercept failures and undo assignments
	during backtracking.
      </LI>
    </UL>
  </TEXT>

  <TEXT>
    Failures are initiated only when a dead end is encountered. This occurs
    <UL>
      <LI>
	if the user program executes
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(amb)</SCHEMEINLINE>;</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>amb()</JAVASCRIPTINLINE>;</JAVASCRIPT>
	  </SPLITINLINE>
      </LI>
      <LI>
	if the user types
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>try-again</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	at the top-level driver.
      </LI>

    </UL>
  </TEXT>

  <TEXT>
    Failure continuations are also called during processing of a failure:
    <UL>
      <LI>When the failure continuation created by an assignment finishes
      undoing a side effect, it calls the failure continuation it intercepted,
      in order to propagate the failure back to the choice point that
      led to this assignment or to the top level.

      </LI>
      <LI>When the failure continuation for an <SCHEMEINLINE>amb</SCHEMEINLINE>
      runs out of choices, it calls the failure continuation that was originally
      given to the <SCHEMEINLINE>amb</SCHEMEINLINE>, in order to propagate the
      failure back to the previous choice point or to the top level.
      </LI>
    </UL>
  </TEXT>

  <INDEX>continuation<SUBINDEX>in nondeterministic evaluator<CLOSE/></SUBINDEX></INDEX>
  
  <SUBHEADING>
    <NAME>Structure of the evaluator</NAME>
  </SUBHEADING>

  <TEXT>
    The syntax- and data-representation
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator, and also the basic
    <INDEX><USE>analyze</USE><SUBINDEX>nondeterministic</SUBINDEX></INDEX>
    <SCHEMEINLINE>analyze</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    are identical to those in the evaluator of
    section<SPACE/><REF NAME="sec:separating-analysis"/>, except for the fact
    that we need additional syntax
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    to recognize
    <SPLITINLINE>
      <SCHEME>
	the <SCHEMEINLINE>amb</SCHEMEINLINE> special
	form:<FOOTNOTE>We
	assume that the evaluator supports <SCHEMEINLINE>let</SCHEMEINLINE>
	(see exercise<SPACE/><REF NAME="ex:implement-analyze-let"/>),
	which we have used in our nondeterministic programs.</FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	the <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> syntactic form:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <INDEX><DECLARATION>is_amb</DECLARATION></INDEX>
      <NAME>is_amb_amb</NAME>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <SCHEME>
(define (amb? exp) (tagged-list? exp 'amb))

(define (amb-choices exp) (cdr exp))
      </SCHEME>
      <JAVASCRIPT>
function is_amb(component) {      
    return is_tagged_list(component, "application") &amp;&amp; 
           is_name(function_expression(component)) &amp;&amp; 
           symbol_of_name(function_expression(component)) === "amb";
}
function amb_choices(component) {
    return arg_expressions(component);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
      </SCHEME>
      <JAVASCRIPT>
<PDF_ONLY>\newpage\noindent </PDF_ONLY>
	We continue to use the parse function of
	section<SPACE/><REF NAME="sec:representing-expressions"/>, which
	doesn't support <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> as a syntactic
	form and instead treats <JAVASCRIPTINLINE>amb(</JAVASCRIPTINLINE><LATEX>$\ldots$</LATEX><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE> as
	a function application. The function
	<JAVASCRIPTINLINE>is_amb</JAVASCRIPTINLINE> ensures that
	whenever the name
	<JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> appears as the function
	expression of an application, the evaluator treats the
	<QUOTE>application</QUOTE> as
	a nondeterministic choice point.<FOOTNOTE>With this treatment, 
	<JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> is no longer a name with
	proper scoping.	To avoid confusion, we must
	refrain from declaring <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> as a
	name in our nondeterministic programs.</FOOTNOTE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    We must also add to the dispatch in <SCHEMEINLINE>analyze</SCHEMEINLINE> a
    clause that will recognize
    <SPLITINLINE>
      <SCHEME>this special form and generate an appropriate execution procedure:
      </SCHEME>
      <JAVASCRIPT>such expressions and generate an appropriate execution
      function:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET LATEX="yes">
      <NAME>is_amb_case_amb</NAME>
      <EXAMPLE>all_solutions_test_5</EXAMPLE>
      <SCHEME>
((amb? exp) (analyze-amb exp))
      </SCHEME>
      <JAVASCRIPT>
$\ldots$
: is_amb(component)
? analyze_amb(component)
: is_application(component)
$\ldots$
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
      </JAVASCRIPT_RUN>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The top-level
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>ambeval</SCHEMEINLINE> (similar to the version of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    given in section<SPACE/><REF NAME="sec:separating-analysis"/>) analyzes the
    given
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
      <JAVASCRIPT>component</JAVASCRIPT>
    </SPLITINLINE>
    and applies the resulting execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to the given environment, together with two given continuations:
    <SNIPPET HIDE="yes">
      <NAME>analyze_amb_headline</NAME>
      <JAVASCRIPT>
// functions from SICP JS 4.3.3	
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>analyze_amb</NAME>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_3</REQUIRES>
      <REQUIRES>functions_4_1_4</REQUIRES>
      <REQUIRES>analyze_amb_headline</REQUIRES>
      <REQUIRES>is_amb_amb</REQUIRES>
      <REQUIRES>analyze_literal_amb</REQUIRES>
      <REQUIRES>analyze_variable_amb</REQUIRES>
      <REQUIRES>analyze_lambda_amb</REQUIRES>
      <REQUIRES>analyze_sequence_amb</REQUIRES>
      <REQUIRES>analyze_declaration_amb</REQUIRES>
      <REQUIRES>analyze_assignment_amb</REQUIRES>
      <REQUIRES>analyze_if_amb</REQUIRES>
      <REQUIRES>scan_out_declarations</REQUIRES>
      <REQUIRES>analyze_block_amb</REQUIRES>
      <REQUIRES>analyze_return_statement_amb</REQUIRES>
      <REQUIRES>analyze_application_amb</REQUIRES>
      <REQUIRES>analyze_amb_amb</REQUIRES>
      <SCHEME>
      (define (analyze exp)
      (cond ((self-evaluating? exp) 
            (analyze-self-evaluating exp))
            ((quoted? exp) (analyze-quoted exp))
            ((variable? exp) (analyze-variable exp))
            ((assignment? exp) (analyze-assignment exp))
            ((definition? exp) (analyze-definition exp))
            ((if? exp) (analyze-if exp))
            ((lambda? exp) (analyze-lambda exp))
            ((begin? exp) (analyze-sequence (begin-actions exp)))
            ((cond? exp) (analyze (cond-&gt;if exp)))
            ((application? exp) (analyze-application exp))
            (else
            (error "Unknown expression type - - ANALYZE" exp))))
      </SCHEME>
      <JAVASCRIPT>
function analyze(component) {
    return is_literal(component)
           ? analyze_literal(component)
           : is_name(component)
           ? analyze_name(component)
           : is_amb(component)
           ? analyze_amb(component)
           : is_application(component)
           ? analyze_application(component)
           : is_operator_combination(component)
           ? analyze(operator_combination_to_application(component))
           : is_conditional(component)
           ? analyze_conditional(component)
           : is_lambda_expression(component)
           ? analyze_lambda_expression(component)
           : is_sequence(component)
           ? analyze_sequence(sequence_statements(component))
           : is_block(component)
           ? analyze_block(component)
           : is_return_statement(component)
           ? analyze_return_statement(component)
           : is_function_declaration(component)	    
           ? analyze(function_decl_to_constant_decl(component))
           : is_declaration(component)
           ? analyze_declaration(component)
           : is_assignment(component)
           ? analyze_assignment(component)
           : error(component, "unknown syntax -- analyze");
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>ambeval</DECLARATION></INDEX> 
      <NAME>ambeval</NAME>
      <REQUIRES>analyze_amb</REQUIRES>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
      </SCHEME>
      <JAVASCRIPT>
function ambeval(component, env, succeed, fail) {      
    return analyze(component)(env, succeed, fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    A success
    <INDEX>success continuation (nondeterministic evaluator)</INDEX>
    <INDEX>continuation<SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    continuation is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of two arguments: the value just obtained and another failure continuation to
    be used if that value leads to a subsequent failure. A
    <INDEX>failure continuation (nondeterministic evaluator)</INDEX>
    failure continuation
    is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of no arguments.  So 
    the general form of an
    <INDEX>execution <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(lambda (env succeed fail)
  ;; succeed is (lambda (value fail) $\ldots$)
  ;; fail is (lambda () $\ldots$)
  $\ldots$)
      </SCHEME>
      <JAVASCRIPT>
(env, succeed, fail) => {      
    // $\texttt{succeed}\,$ is $\texttt{(value, fail) =>}~\ldots$
    // $\texttt{fail}\,$ is $\texttt{() =>}~\ldots$
    $\ldots$
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    For example, executing
    <SPLIT>
      <SCHEME>
	<SNIPPET EVAL="no">
	  <SCHEME>
(ambeval exp
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
	  </SCHEME>
	</SNIPPET>
      </SCHEME>
      <JAVASCRIPT>
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
ambeval(<META>component</META>,
        the_global_environment,
        (value, fail) => value,
        () => "failed");
	  </JAVASCRIPT>
	</SNIPPET>
      </JAVASCRIPT>
    </SPLIT>
    will attempt to evaluate the given
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
      <JAVASCRIPT>component</JAVASCRIPT>
    </SPLITINLINE>
    and will return either the
    <SPLITINLINE>
      <SCHEME>expression<APOS/>s</SCHEME>
      <JAVASCRIPT>component<APOS/>s</JAVASCRIPT>
    </SPLITINLINE>
    value (if the evaluation succeeds) or the
    <SPLITINLINE>
      <SCHEME>
	symbol <SCHEMEINLINE>failed</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	string <JAVASCRIPTINLINE>"failed"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    (if the evaluation fails).
    The call to <SCHEMEINLINE>ambeval</SCHEMEINLINE> in the driver loop shown
    below uses much more complicated continuation
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <JAVASCRIPT>functions,</JAVASCRIPT>
    </SPLITINLINE>
    which continue the loop and support the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>try-again</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>	
      </JAVASCRIPT>
    </SPLITINLINE>
    request.
  </TEXT>

  <TEXT>
    Most of the complexity of the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator
    results from the mechanics of passing the continuations around as the
    execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    call each other.  In going through the following code, you should compare
    each of the execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    with the corresponding
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for the ordinary evaluator given in
    section<SPACE/><REF NAME="sec:separating-analysis"/>.
  </TEXT>

  <SUBHEADING>
    <NAME>Simple expressions</NAME>
  </SUBHEADING>

  <INDEX><USE>analyze_...</USE><SUBINDEX>nondeterministic</SUBINDEX><OPEN/></INDEX>
  
  <TEXT>
    The execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for the simplest kinds of expressions are
    essentially the same as those for the ordinary evaluator, except for the
    need to manage the continuations.  The execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    simply succeed with the value of the expression, passing along the failure
    continuation that was passed to them.
    <SNIPPET>
      <NAME>analyze_literal_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
      </SCHEME>
      <JAVASCRIPT>
function analyze_literal(component) {
    return (env, succeed, fail) =>
             succeed(literal_value(component), fail);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>analyze_variable_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
      </SCHEME>
      <JAVASCRIPT>
function analyze_name(component) {
    return (env, succeed, fail) =>
             succeed(lookup_symbol_value(symbol_of_name(component),
                                         env),
                     fail);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>analyze_lambda_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_lambda_expression(component) {
    const params = lambda_parameter_symbols(component);
    const bfun = analyze(lambda_body(component));
    return (env, succeed, fail) =>
             succeed(make_function(params, bfun, env),
                     fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Notice that looking up a
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>name</JAVASCRIPT>
    </SPLITINLINE>
    always <QUOTE>succeeds.</QUOTE>
    <INDEX>failure, in nondeterministic computation<SUBINDEX>bug vs.</SUBINDEX></INDEX>
    If
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>lookup-variable-value</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>lookup_symbol_value</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    fails to find the
    <SPLITINLINE>
      <SCHEME>variable,</SCHEME>
      <JAVASCRIPT>name,</JAVASCRIPT>
    </SPLITINLINE>
    it signals an
    error, as usual.  Such a <QUOTE>failure</QUOTE> indicates a program
    bug<EMDASH/>a reference to an unbound
    <SPLITINLINE>
      <SCHEME>variable;</SCHEME>
      <JAVASCRIPT>name;</JAVASCRIPT>
    </SPLITINLINE>
    it is not an indication
    that we should try another nondeterministic choice instead of the one that
    is currently being tried.
  </TEXT>

  <LONG_PAGE lines="2"/>
  <SUBHEADING>
    <NAME>Conditionals and sequences</NAME>
  </SUBHEADING>

  <TEXT>
    Conditionals are also handled in a similar way as in the ordinary
    evaluator.  The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    generated by
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>analyze-if</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_conditional</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    invokes the predicate execution
    <SPLITINLINE>
      <SCHEME>procedure
      <SCHEMEINLINE>pproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>function
      <JAVASCRIPTINLINE>pfun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    with a success continuation that checks whether the predicate value is true
    and goes on to execute either the consequent or the alternative.  If the
    execution of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>pproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>pfun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    fails, the original failure continuation for
    the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	conditional
      </JAVASCRIPT>
    </SPLITINLINE>
    expression is called.
    <SNIPPET LATEX="yes">
      <NAME>analyze_if_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
   (lambda (env succeed fail)
           (pproc env
                  <EM>;; success continuation for evaluating the predicate</EM>
                  <EM>;; to obtain <SCHEMEINLINE>pred-value</SCHEMEINLINE></EM>
                  (lambda (pred-value fail2)
                    (if (true? pred-value)
                        (cproc env succeed fail2)
                        (aproc env succeed fail2)))
                  <EM>;; failure continuation for evaluating the predicate</EM>
                  fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_conditional(component) {      
    const pfun = analyze(conditional_predicate(component));
    const cfun = analyze(conditional_consequent(component));
    const afun = analyze(conditional_alternative(component));
    return (env, succeed, fail) =>
             pfun(env,
                  // success continuation for evaluating the predicate 
                  // to obtain $\texttt{pred\char`_value}$
                  (pred_value, fail2) =>
                    is_truthy(pred_value) 
                    ? cfun(env, succeed, fail2)
                    : afun(env, succeed, fail2),
                  // failure continuation for evaluating the predicate		    
                  fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
	Sequences are also handled in the same way as in the previous
	evaluator, except for the machinations in the
      subprocedure
	<SCHEMEINLINE>sequentially</SCHEMEINLINE> that are required for passing the
	continuations. Namely, to sequentially execute <SCHEMEINLINE>a</SCHEMEINLINE>
	and then <SCHEMEINLINE>b</SCHEMEINLINE>, we call
	<SCHEMEINLINE>a</SCHEMEINLINE> with a success continuation that calls
	<SCHEMEINLINE>b</SCHEMEINLINE>.
	<SNIPPET>
	  <SCHEME>
	    (define (analyze-sequence exps)
	    (define (sequentially a b)
	    (lambda (env succeed fail)
	    (a env
            ;; success continuation for calling a
            (lambda (a-value fail2)
            (b env succeed fail2))
            ;; failure continuation for calling a
            fail)))
	    (define (loop first-proc rest-procs)
	    (if (null? rest-procs)
            first-proc
            (loop (sequentially first-proc (car rest-procs))
            (cdr rest-procs))))
	    (let ((procs (map analyze exps)))
	    (if (null? procs)
            (error "Empty sequence - - ANALYZE"))
	    (loop (car procs) (cdr procs))))
	  </SCHEME>
	</SNIPPET>
      </SCHEME>
      <JAVASCRIPT>
	Sequences are also handled in the same way as in the previous
	evaluator, except for the machinations in the
	subfunction
	<SCHEMEINLINE>sequentially</SCHEMEINLINE> that are required for passing the
	continuations. Namely, to sequentially execute <SCHEMEINLINE>a</SCHEMEINLINE>
	and then <SCHEMEINLINE>b</SCHEMEINLINE>, we call
	<SCHEMEINLINE>a</SCHEMEINLINE> with a success continuation that calls
	<SCHEMEINLINE>b</SCHEMEINLINE>.
	<SNIPPET POSTPADDING="no" LATEX="yes">
	  <NAME>analyze_sequence_amb</NAME>
	  <EXAMPLE>all_solutions_test_4</EXAMPLE>
	  <JAVASCRIPT>
function analyze_sequence(stmts) {
    function sequentially(a, b) {
        return (env, succeed, fail) => 
                 a(env, 
                   // success continuation for calling $\texttt{a}$
                   (a_value, fail2) =>
                     is_return_value(a_value)
                     ? succeed(a_value, fail2)
                     : b(env, succeed, fail2),
                   // failure continuation for calling $\texttt{a}$
                   fail);
    }
    function loop(first_fun, rest_funs) {
        return is_null(rest_funs)
               ? first_fun
               : loop(sequentially(first_fun, head(rest_funs)),
                      tail(rest_funs));
    }
    const funs = map(analyze, stmts);
    return is_null(funs) 
           ? env => undefined
           : loop(head(funs), tail(funs));
}
	  </JAVASCRIPT>
	</SNIPPET>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME>Definitions</SCHEME>
	<JAVASCRIPT>Declarations</JAVASCRIPT>
      </SPLITINLINE>
      and assignments
    </NAME>
  </SUBHEADING>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>Definitions</SCHEME>
      <JAVASCRIPT>Declarations</JAVASCRIPT>
    </SPLITINLINE>
    are another case where we must go to some trouble to
    manage the continuations, because it is necessary to evaluate the
    <SPLITINLINE>
      <SCHEME>
	definition-value expression before actually defining the new variable.
      </SCHEME>
      <JAVASCRIPT>
	declaration-value expression before actually declaring the new name.
      </JAVASCRIPT>
    </SPLITINLINE>
    To accomplish this, the
    <SPLITINLINE>
      <SCHEME>definition-value</SCHEME>
      <JAVASCRIPT>declaration-value</JAVASCRIPT>
    </SPLITINLINE>
    execution
    <SPLITINLINE>
      <SCHEME>procedure
      <SCHEMEINLINE>vproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>function
      <SCHEMEINLINE>vfun</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is called with the environment, a success continuation, and the
    failure continuation.  If the execution of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>vproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>vfun</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    succeeds, obtaining a value <SCHEMEINLINE>val</SCHEMEINLINE> for the
    <SPLITINLINE>
      <SCHEME>
	defined variable, the variable is defined and the success is propagated:
      </SCHEME>
      <JAVASCRIPT>
	declared name, the name is declared and the success is propagated:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <NAME>analyze_declaration_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env                        
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_declaration(component) {
    const symbol = declaration_symbol(component);
    const vfun = analyze(declaration_value_expression(component));
    return (env, succeed, fail) => 
             vfun(env,
                  (val, fail2) => {
                      assign_symbol_value(symbol, val, env);
                      return succeed(undefined, fail2);
                  },
                  fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Assignments
    <INDEX>failure continuation (nondeterministic evaluator)<SUBINDEX>constructed by assignment</SUBINDEX></INDEX>
    are more interesting.  This is the first place where we
    really use the continuations, rather than just passing them around.
    The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for assignments starts out like the one for
    <SPLITINLINE>
      <SCHEME>definitions.</SCHEME>
      <JAVASCRIPT>declarations.</JAVASCRIPT>
    </SPLITINLINE>
    It first attempts
    to obtain the new value to be assigned to the
    <SPLITINLINE>
      <SCHEME>variable.</SCHEME>
      <JAVASCRIPT>name.</JAVASCRIPT>
    </SPLITINLINE>
    If this evaluation of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>vproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>vfun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>  
    fails, the assignment fails.
  </TEXT>

  <TEXT>
    If
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>vproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>vfun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>  
    succeeds, however, and we go on to make the assignment, we must consider the
    possibility that this branch of the computation might later fail, which will
    require us to backtrack out of the assignment.  Thus, we must arrange to
    undo the assignment as part of the backtracking  process.<FOOTNOTE>We
    <SPLITINLINE>
      <SCHEME>
	didn<APOS/>t worry about undoing definitions,
	since we can
	assume that
	<INDEX>internal definition<SUBINDEX><ORDER>nondeterministic</ORDER>in nondeterministic evaluator</SUBINDEX></INDEX>
	internal definitions
	are scanned out
	(section<SPACE/><REF NAME="sec:internal-definitions"/>).
      </SCHEME>
      <JAVASCRIPT>
	didn<APOS/>t worry about undoing declarations, since we assume that a
	name can<APOS/>t be used prior to the evaluation of its declaration,
	<INDEX>internal declaration<SUBINDEX><ORDER>nondeterministic</ORDER>in nondeterministic evaluator</SUBINDEX></INDEX>
	so its previous value doesn<APOS/>t matter.
      </JAVASCRIPT>
    </SPLITINLINE></FOOTNOTE>
  </TEXT>

  <TEXT>
    This is accomplished by giving
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>vproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>vfun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>  
    a success continuation (marked with the comment <QUOTE>*1*</QUOTE> below)
    that saves the old value of the variable before assigning the new value to
    the variable and proceeding from the assignment.  The failure continuation
    that is passed along with the value of the assignment (marked with the
    comment <QUOTE>*2*</QUOTE> below) restores the old value of the variable
    before continuing the failure. That is, a successful assignment provides a
    failure continuation that will intercept a subsequent failure; whatever
    failure would otherwise have called <SCHEMEINLINE>fail2</SCHEMEINLINE> calls
    this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    instead, to undo the assignment before actually calling
    <SCHEMEINLINE>fail2</SCHEMEINLINE>.
    <SNIPPET POSTPADDING="no">
      <NAME>analyze_assignment_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        <EM>; *1*</EM>
               (let ((old-value
                     (lookup-variable-value var env))) 
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    <EM>; *2*</EM>
                            (set-variable-value! var
                                                 old-value
                                                 env)
                            (fail2)))))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_assignment(component) {
    const symbol = assignment_symbol(component);
    const vfun = analyze(assignment_value_expression(component));
    return (env, succeed, fail) =>
             vfun(env,
                  (val, fail2) => {              // *1*
                      const old_value = lookup_symbol_value(symbol,
                                                            env);
                      assign_symbol_value(symbol, val, env);
                      return succeed(val,
                                     () => {     // *2*
                                         assign_symbol_value(symbol,
                                                             old_value, 
                                                             env);
                                         return fail2();
                                     });
                  },
                  fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SPLIT>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
      <SUBHEADING>
	<NAME>Return statements and blocks</NAME>
      </SUBHEADING>

      <TEXT>
	Analyzing return statements is straightforward.
	The return expression is analyzed to produce an execution function.
	The execution function for the return statement calls that execution
	function with a success continuation that wraps the return value
	in a return value object and passes it to the original success continuation.
	<SNIPPET>
	  <NAME>analyze_return_statement_amb</NAME>
	  <EXAMPLE>all_solutions_test_4</EXAMPLE>
	  <JAVASCRIPT>
function analyze_return_statement(component) {
    const rfun = analyze(return_expression(component));
    return (env, succeed, fail) =>
             rfun(env,
                  (val, fail2) =>
                    succeed(make_return_value(val), fail2),
                  fail);
}
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
      <TEXT>
	The execution function for blocks calls the body<APOS/>s execution
	function on an extended environment, without changing success or
	failure continuations.
	<SNIPPET POSTPADDING="no">
	  <NAME>analyze_block_amb</NAME>
	  <REQUIRES>list_of_unassigned</REQUIRES>
	  <EXAMPLE>all_solutions_test_4</EXAMPLE>
	  <JAVASCRIPT>
function analyze_block(component) {
    const body = block_body(component);
    const locals = scan_out_declarations(body);
    const unassigneds = list_of_unassigned(locals);
    const bfun = analyze(body);
    return (env, succeed, fail) =>
             bfun(extend_environment(locals, unassigneds, env),
                  succeed, 
                  fail);
}
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>
  
  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME>Procedure</SCHEME>
	<JAVASCRIPT>Function</JAVASCRIPT>
      </SPLITINLINE>
      applications
    </NAME>
  </SUBHEADING>

  <TEXT>
    The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for applications contains no new ideas except for the technical complexity
    of managing the continuations.  This complexity arises in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>analyze-application</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>analyze_@application</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>  
    due to the need to keep track of the success and failure continuations as
    we evaluate the
    <SPLITINLINE>
      <SCHEME>operands.</SCHEME>
      <JAVASCRIPT>argument expressions.</JAVASCRIPT>
    </SPLITINLINE>
    We use a
    <SPLITINLINE>
      <SCHEME>procedure <SCHEMEINLINE>get-args</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>function <JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>  
    to evaluate the list of
    <SPLITINLINE>
      <SCHEME>operands,</SCHEME>
      <JAVASCRIPT>argument expressions,</JAVASCRIPT>
    </SPLITINLINE>
    rather than a simple
    <SCHEMEINLINE>map</SCHEMEINLINE> as in the ordinary evaluator.
    <SNIPPET>
      <NAME>analyze_application_amb</NAME>
      <REQUIRES>get_args_amb</REQUIRES>
      <REQUIRES>execute_application_amb</REQUIRES>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_application(component) {
    const ffun = analyze(function_expression(component));
    const afuns = map(analyze, arg_expressions(component));
    return (env, succeed, fail) =>
             ffun(env,
                  (fun, fail2) =>
                    get_args(afuns, 
                             env,
                             (args, fail3) =>
                               execute_application(fun,
                                                   args, 
                                                   succeed,
                                                   fail3),
                             fail2),
                  fail); 
}      
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <INDEX><USE>analyze_...</USE><SUBINDEX>nondeterministic</SUBINDEX><CLOSE/></INDEX>
  
  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	In  <SCHEMEINLINE>get-args</SCHEMEINLINE>, notice how
	<SCHEMEINLINE>cdr</SCHEMEINLINE>ing down the list of
	<SCHEMEINLINE>aproc</SCHEMEINLINE>
	execution procedures and
	<SCHEMEINLINE>cons</SCHEMEINLINE>ing
	up the resulting list of
	<SCHEMEINLINE>args</SCHEMEINLINE> is accomplished by calling each
	<SCHEMEINLINE>aproc</SCHEMEINLINE>
	in the list with a success continuation that recursively calls
	<SCHEMEINLINE>get-args</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	In <JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE>,
	notice how walking down the list of
	<JAVASCRIPTINLINE>afun</JAVASCRIPTINLINE>
	execution functions
	and constructing the resulting list of
	<SCHEMEINLINE>args</SCHEMEINLINE>
	is accomplished by calling each
	<JAVASCRIPTINLINE>afun</JAVASCRIPTINLINE>
	in the list with a success continuation that recursively calls
	<JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE>.<DO_BREAK_PAGE/>
      </JAVASCRIPT>
    </SPLITINLINE>
    Each of these recursive calls to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-args</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>  
    has a success continuation whose value is the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>cons</SCHEMEINLINE>
	of the newly obtained argument onto the list of accumulated arguments:
      </SCHEME>
      <JAVASCRIPT>
	new list resulting from using
	<JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
	to adjoin the newly obtained argument
	to the list of accumulated arguments:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET LATEX="yes">
      <NAME>get_args_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
                    <EM>;; success continuation for this <SCHEMEINLINE>aproc</SCHEMEINLINE></EM>
                    (lambda (arg fail2)
                      (get-args (cdr aprocs)
                                env
                                <EM>;; success continuation for recursive</EM>
                                <EM>;; call to <SCHEMEINLINE>get-args</SCHEMEINLINE></EM>
                                (lambda (args fail3)
                                  (succeed (cons arg args)
                                           fail3))
                                fail2))
                    fail)))
      </SCHEME>
      <JAVASCRIPT>
function get_args(afuns, env, succeed, fail) {      
    return is_null(afuns)
           ? succeed(null, fail)
           : head(afuns)(env,
                         // success continuation for this $\texttt{afun}$
                         (arg, fail2) =>
                           get_args(tail(afuns),
                                    env,
                                    // success continuation for
                                    // recursive call to $\texttt{get\char`_args}$
                                    (args, fail3) =>
                                      succeed(pair(arg, args),
                                              fail3),
                                    fail2),
                         fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application, which is performed by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>execute-application</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>execute_application</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>  
    is accomplished in the same way as for the ordinary evaluator, except for
    the need to manage the continuations.
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>execute_application</DECLARATION><SUBINDEX>nondeterministic</SUBINDEX></INDEX>
      <NAME>execute_application_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error
          "Unknown procedure type - - EXECUTE-APPLICATION"
          proc))))
      </SCHEME>
      <JAVASCRIPT>
function execute_application(fun, args, succeed, fail) {
    return is_primitive_function(fun)
           ? succeed(apply_primitive_function(fun, args),
                     fail)
           : is_compound_function(fun) 
           ? function_body(fun)(
                 extend_environment(function_parameters(fun),
                                    args,
                                    function_environment(fun)),
                 (body_result, fail2) => 
                   succeed(is_return_value(body_result) 
                           ? return_value_content(body_result)
                           : undefined,
                           fail2),
                 fail)
           : error(fun, "unknown function type - execute_application");
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <DO_BREAK_PAGE/>
  <SUBHEADING>
    <NAME>Evaluating <SCHEMEINLINE>amb</SCHEMEINLINE> expressions</NAME>
  </SUBHEADING>

  <TEXT>
    The <SCHEMEINLINE>amb</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>syntactic</JAVASCRIPT>
    </SPLITINLINE>
    form is the key element in the nondeterministic language.  Here we see the
    essence of the interpretation process and the reason for keeping track of
    the continuations.  The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for <SCHEMEINLINE>amb</SCHEMEINLINE> defines a loop
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-next</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>try_next</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    that cycles through the execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for all the possible values of the <SCHEMEINLINE>amb</SCHEMEINLINE>
    expression.  Each execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is called with a
    <INDEX>failure continuation (nondeterministic evaluator)<SUBINDEX><ORDER>constructed by amb</ORDER>constructed by <SCHEMEINLINE>amb</SCHEMEINLINE></SUBINDEX></INDEX>
    failure continuation that will try the next one.  When
    there are no more alternatives to try, the entire
    <SCHEMEINLINE>amb</SCHEMEINLINE> expression fails.
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>analyze_amb</DECLARATION></INDEX> 
      <NAME>analyze_amb_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME POSTPADDING="no">
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
             succeed
             (lambda ()
               (try-next (cdr choices))))))
      (try-next cprocs))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_amb(component) {
    const cfuns = map(analyze, amb_choices(component));
    return (env, succeed, fail) => {
               function try_next(choices) {
                   return is_null(choices)
                          ? fail()
                          : head(choices)(env,
                                          succeed,
                                          () =>
                                            try_next(tail(choices)));
               }
               return try_next(cfuns);
           };
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Driver loop</NAME>
  </SUBHEADING>

  <INDEX>driver loop<SUBINDEX><ORDER>nondeterministic</ORDER>in nondeterministic evaluator</SUBINDEX></INDEX>

  <TEXT>
    The driver loop for the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator is
    complex, due to the mechanism that permits the user to retry in evaluating
    <SPLITINLINE>
      <SCHEME>an expression.</SCHEME>
      <JAVASCRIPT>a program.</JAVASCRIPT>
    </SPLITINLINE>
    The driver uses a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    called
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>internal-loop</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>internal_loop</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which takes as argument a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>failure continuation (nondeterministic evaluator)<SUBINDEX>constructed by driver loop</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>  
	<SCHEMEINLINE>try-again</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The intent is that calling
    <SPLITINLINE><SCHEME>  
      <SCHEMEINLINE>try-again</SCHEMEINLINE>
    </SCHEME>
    <JAVASCRIPT>
      <JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
    </JAVASCRIPT></SPLITINLINE>
    should go on to the next untried alternative in the nondeterministic
    evaluation.
    <SPLITINLINE><SCHEME>  
      <SCHEMEINLINE>Internal-loop</SCHEMEINLINE>
    </SCHEME>
    <JAVASCRIPT>The function
    <JAVASCRIPTINLINE>internal_loop</JAVASCRIPTINLINE>
    </JAVASCRIPT></SPLITINLINE>
    either calls
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in response to the user typing
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    at the driver loop, or else starts a new evaluation by calling
    <SCHEMEINLINE>ambeval</SCHEMEINLINE>.  
  </TEXT>

  <TEXT>
    The failure continuation for this call to
    <SCHEMEINLINE>ambeval</SCHEMEINLINE>
    <!-- %(marked <QUOTE>*2*</QUOTE> below)-->
    informs the user that there are no more values and reinvokes the driver
    loop.
  </TEXT>

  <TEXT>
    The success continuation for the call to <SCHEMEINLINE>ambeval</SCHEMEINLINE>
    <!-- %(marked <QUOTE>*1*</QUOTE> below)-->
    is more subtle.  We print the obtained value and then
    <SPLITINLINE>
      <SCHEME>
	invoke the internal loop again
      </SCHEME>
      <JAVASCRIPT>
	reinvoke the internal loop
      </JAVASCRIPT>
    </SPLITINLINE>
    with a
    <SPLITINLINE>
      <SCHEME>  
	<SCHEMEINLINE>try-again</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that will be able to try the next alternative.  This
    <SPLITINLINE>
      <SCHEME>  
	<SCHEMEINLINE>next-alternative</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>next_alternative</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is the second argument that was passed to the success continuation.
    Ordinarily, we think of this second argument as a failure continuation to
    be used if the current evaluation branch later fails.  In this case,
    however, we have completed a successful evaluation, so we can invoke the
    <QUOTE>failure</QUOTE> alternative branch in order to search for additional
    successful evaluations.
    <SNIPPET HIDE="yes">
      <NAME>driver_loop_amb_example</NAME>
      <SCHEME>
(driver-loop)
      </SCHEME>
      <JAVASCRIPT>
driver_loop();
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX>prompts<SUBINDEX>nondeterministic evaluator</SUBINDEX></INDEX>
      <INDEX><DECLARATION>driver_loop</DECLARATION><SUBINDEX>for nondeterministic evaluator</SUBINDEX></INDEX>
      <NAME>driver_loop_amb</NAME>
      <REQUIRES>ambeval</REQUIRES>      
      <REQUIRES>user_print</REQUIRES>
      <REQUIRES>user_read</REQUIRES>
      <EXAMPLE>driver_loop_amb_example</EXAMPLE>
      <SCHEME>
(define input-prompt ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")

(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (ambeval input
                     the-global-environment
                     <EM>;; <SCHEMEINLINE>ambeval</SCHEMEINLINE> success</EM>
                     (lambda (val next-alternative)
                       (announce-output output-prompt)
                       (user-print val)
                       (internal-loop next-alternative))
                    <EM>;; <SCHEMEINLINE>ambeval</SCHEMEINLINE> failure</EM>
                    (lambda ()
                      (announce-output
                       ";;; There are no more values of")
                      (user-print input)
                      (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (driver-loop))))
      </SCHEME>
      <JAVASCRIPT>
const input_prompt = "amb-evaluate input:";
const output_prompt =  "amb-evaluate value:";

function driver_loop(env) {
    function internal_loop(retry) {
        const input = user_read(input_prompt);
        if (is_null(input)) {
            display("evaluator terminated");
        } else if (input === "retry") {
            return retry();
        } else {
            display("Starting a new problem");
            const program = parse(input);
            const locals = scan_out_declarations(program);
            const unassigneds = list_of_unassigned(locals);
            const program_env = extend_environment(
                                    locals, unassigneds, env);
            return ambeval(
                       program,  
                       program_env,
                       // ambeval success
                       (val, next_alternative) => {
                           user_print(output_prompt, val);
                           return internal_loop(next_alternative);
                       },
                       // ambeval failure
                       () => {
                           display("There are no more values of");
                           display(input);
                           return driver_loop(program_env);
                       });
        }
    }
    return internal_loop(() => {
                             display("There is no current problem");
                             return driver_loop(env);
                         });
}
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
const input_prompt = "amb-evaluate input:";
const output_prompt =  "amb-evaluate value:";
function driver_loop() {
    function internal_loop(retry) {
        const input = user_read(input_prompt);
        if (is_null(input)) {
        display("--- evaluator terminated ---", "");
        } else if (input === "retry") {
            display("----------------------------",
                    input_prompt + "\n" + input + "\n");
            return retry();
        } else {
            display("--- starting new problem ---",
                    input_prompt + "\n" + input + "\n");
            ambeval(parse("{ " + input + " }"),
                the_global_environment,
                // ambeval success
                (val, next_alternative) => {
                    user_print(output_prompt, val);
                    return internal_loop(next_alternative);
                },
                // ambeval failure
                () => {
                    display("----------------------------",
                            "no more values of:\n" + input + "\n");
                    return driver_loop();
                });
        }
    }
    return internal_loop(
               () => {
                   display("---  no current problem  ---", "");
                   return driver_loop();
               });
}
      </JAVASCRIPT_RUN>
    </SNIPPET>
    The initial call to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>internal-loop</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>internal_loop</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    uses a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that complains that there is no current problem and restarts the driver loop.
    This is the behavior that will happen if the user types
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    when there is no evaluation in progress.
  </TEXT>
  <SPLIT>
    <JAVASCRIPT>
      <TEXT>
	We start the driver loop as usual, by setting up the global environment
	and passing it as the enclosing environment for the first iteration of
	<JAVASCRIPTINLINE>driver_loop</JAVASCRIPTINLINE>.
	<SNIPPET EVAL="no" POSTPADDING="no">
	  <JAVASCRIPT>
const the_global_environment = setup_environment();
driver_loop(the_global_environment);
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>
  <DO_BREAK_PAGE/>
  <EXERCISE>
    Implement a new
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>syntactic</JAVASCRIPT>
    </SPLITINLINE>
    form <SCHEMEINLINE>ramb</SCHEMEINLINE> that is like
    <SCHEMEINLINE>amb</SCHEMEINLINE> except that it searches alternatives in a
    random order, rather than from left to right.  Show how this can help with
    Alyssa<APOS/>s problem in exercise<SPACE/><REF NAME="ex:sentence-generate"/>.
    <LABEL NAME="ex:ramb"/>
  </EXERCISE>


  <EXERCISE>
    <SPLITINLINE>
      <SCHEME>
	Implement a new kind of assignment called
	<SCHEMEINLINE>permanent-set!</SCHEMEINLINE> that
      </SCHEME>
      <JAVASCRIPT>
	Change the implementation of assignment so that it
      </JAVASCRIPT>
    </SPLITINLINE>
    is not undone upon failure. For example, we can choose two distinct
    elements from a list and count the number of trials required to make a
    successful choice as follows:
    <SNIPPET EVAL="no">
      <SCHEME>
(define count 0)

(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
(a b 2)

;;; Amb-Eval input:
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
let count = 0;

let x = an_element_of("a", "b", "c");
let y = an_element_of("a", "b", "c");
count = count + 1;
require(x !== y);
list(x, y, count);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
Starting a new problem
amb-evaluate value:
["a", ["b", [2, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <SCHEME>
try-again
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Amb-Eval value:
(a c 3)
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
amb-evaluate input:
      </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
retry
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
amb-evaluate value:
["a", ["c", [3, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
	What values would have been displayed if we had used
	<SCHEMEINLINE>set!</SCHEMEINLINE> here rather than
	<SCHEMEINLINE>permanent-set!</SCHEMEINLINE>?
      </SCHEME>
      <JAVASCRIPT>
	What values would have been displayed if we had used
	the original meaning of assignment rather than
	permanent assignment?
      </JAVASCRIPT>
    </SPLIT>
    <LABEL NAME="ex:permanent-set"/>
  </EXERCISE>

  <SPLIT>
    <SCHEME>
      <EXERCISE>
	<LABEL NAME="ex:if-fail_scheme"/>
	Implement a new construct called <SCHEMEINLINE>if-fail</SCHEMEINLINE>
	that permits the user to catch the failure of an expression.
	<SCHEMEINLINE>If-fail</SCHEMEINLINE> takes two expressions. It evaluates
	the first expression as usual and returns as usual if the evaluation
	succeeds. If the evaluation fails, however, the value of the second
	expression is returned, as in the following example:
	<SNIPPET EVAL="no">
	  <SCHEME>
	  </SCHEME>
	  <SCHEMEOUTPUT>
;;; Amb-Eval input:
	  </SCHEMEOUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <SCHEME>
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
	  </SCHEME>
	  <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
all-odd

;;; Amb-Eval input:
	  </SCHEMEOUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <SCHEME>
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
	  </SCHEME>
	  <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
8
	  </SCHEMEOUTPUT>
	</SNIPPET>
      </EXERCISE>
    </SCHEME>
    <JAVASCRIPT>
      <EXERCISE>
	<LABEL NAME="ex:if-fail"/>
	We shall horribly abuse the syntax for conditional statements, by
	implementing a construct of the following form: 
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
if (evaluation_succeeds_take) { $statement$ } else { $alternative$ }
	  </JAVASCRIPT>
	</SNIPPET>
	The construct permits the user to catch the failure of a
	statement. It evaluates the statement as usual and returns
	as usual if the evaluation succeeds. If the evaluation fails,
	however, the given alternative statement 
	is evaluated, as in the following example:
	<SNIPPET EVAL="no">
	  <JAVASCRIPT_PROMPT>
amb-evaluate input:
	  </JAVASCRIPT_PROMPT>
	  <JAVASCRIPT>
if (evaluation_succeeds_take) {
    const x = an_element_of(list(1, 3, 5));
    require(is_even(x));
    x;
} else {
    "all odd";
}
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
Starting a new problem
amb-evaluate value:
"all odd"
	  </JAVASCRIPT_OUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <JAVASCRIPT_PROMPT>
amb-evaluate input:
	  </JAVASCRIPT_PROMPT>
	  <JAVASCRIPT>
if (evaluation_succeeds_take) {
    const x = an_element_of(list(1, 3, 5, 8));
    require(is_even(x));
    x;
} else {
    "all odd";
}
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
Starting a new problem
amb-evaluate value:
8
	  </JAVASCRIPT_OUTPUT>
	</SNIPPET>
	Implement this construct by extending the
	<JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE>
	evaluator. Hint: The function 
	<JAVASCRIPTINLINE>is_amb</JAVASCRIPTINLINE> shows
	how to abuse the existing JavaScript syntax in order to implement
	a new syntactic form.
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>

  <EXERCISE>
    <LABEL NAME="ex:combine_permanent_if_fail"/>
    With
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>permanent-set!</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	the new kind of assignment
      </JAVASCRIPT>
    </SPLITINLINE>
    as described in exercise<SPACE/><REF NAME="ex:permanent-set"/> and
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if-fail</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	the construct
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
if (evaluation_succeeds_take) { $\ldots$ } else { $\ldots$ }
      </JAVASCRIPT>
	</SNIPPET>
      </JAVASCRIPT>
    </SPLITINLINE>
    as in exercise<SPACE/><REF NAME="ex:if-fail"/>, what will be the result of
    evaluating
    <SNIPPET EVAL="no" POSTPADDING="no">
      <SCHEME>
(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))
      </SCHEME>
      <JAVASCRIPT>
let pairs = null;      
if (evaluation_succeeds_take) {
    const p = prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));
    pairs = pair(p, pairs); // using permanent assignment
    amb();
} else {
    pairs;
}
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:require_special"/>
    If we had not realized that
    <INDEX><USE>require</USE><SUBINDEX>as a syntactic form</SUBINDEX></INDEX>
    <SCHEMEINLINE>require</SCHEMEINLINE> could be
    implemented as an ordinary
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that uses <SCHEMEINLINE>amb</SCHEMEINLINE>, to be defined by the user as
    part of a nondeterministic program, we would have had to implement it
    as a 
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>syntactic</JAVASCRIPT>
    </SPLITINLINE>
    form. This would require syntax
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
(define (require? exp) (tagged-list? exp 'require))

(define (require-predicate exp) (cadr exp))
      </SCHEME>
      <JAVASCRIPT>
function is_require(component) {
    return is_tagged_list(component, "require"); 
}
function require_predicate(component) { return head(tail(component)); }
      </JAVASCRIPT>
    </SNIPPET>
    and a new clause in the dispatch in <SCHEMEINLINE>analyze</SCHEMEINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      ((require? exp) (analyze-require exp))
      </SCHEME>
      <JAVASCRIPT>
: is_require(component)
? analyze_require(component)
      </JAVASCRIPT>
    </SNIPPET>
    as well the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>analyze-require</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_require</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    that handles <SCHEMEINLINE>require</SCHEMEINLINE>
    expressions.  Complete the following definition of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>analyze-require</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_require</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no" LATEX="yes" POSTPADDING="no">
      <SCHEME>
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if ??
                   ??
                   (succeed 'ok fail2)))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_require(component) {
    const pfun = analyze(require_predicate(component));
    return (env, succeed, fail) =>
             pfun(env,
                  (pred_value, fail2) =>
                    <METAPHRASE>??</METAPHRASE>
                    ? <METAPHRASE>??</METAPHRASE>
                    : succeed("ok", fail2),
                  fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>

  <INDEX>nondeterministic evaluator<CLOSE/></INDEX>

  <SNIPPET HIDE="yes">
    <NAME>all_solutions</NAME>
    <REQUIRES>ambeval</REQUIRES>
      <JAVASCRIPT>
function all_solutions(input) {
    let solutions = null;	
    function internal_loop(input, retry) {
        if (input === "retry") {
            return retry();
        } else {
            return ambeval(parse("{ " + input + " }"),
                       the_global_environment,
                       // ambeval success
                       (val, next_alternative) => {
                           solutions = pair(val, solutions);
                           return internal_loop("retry", next_alternative);
                       },
                       // ambeval failure
                       () => undefined
                      );
        }
    }
    internal_loop(
               input,
               () => {
                   display("// internal error");
               });
    return reverse(solutions);
}
      </JAVASCRIPT>
    </SNIPPET>
  <SNIPPET HIDE="yes">
    <NAME>first_solution</NAME>
    <REQUIRES>ambeval</REQUIRES>
      <JAVASCRIPT>
function first_solution(input) {
    return ambeval(parse("{ " + input + " }"),
                   the_global_environment,
                   (val, next_alternative) => val,
                   () => undefined);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_1</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <EXPECTED>[ 'apple', [ 'banana', [ 'cranberry', null ] ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions("                                            \
function require(p) {                                      \
    return ! p ? amb() : 'Satisfied require';              \
    }                                                      \
function an_element_of(items) {                            \
    require(! is_null(items));                             \
    return amb(head(items), an_element_of(tail(items)));   \
}                                                          \
const xs = list('apple', 'banana', 'cranberry');           \
an_element_of(xs);	                                   ");
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_2</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <EXPECTED>[ 8, [ 35, null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions("                                            \
function require(p) {                                      \
    return ! p ? amb() : 'Satisfied require';              \
    }                                                      \
function an_element_of(items) {                            \
    require(! is_null(items));                             \
    return amb(head(items), an_element_of(tail(items)));   \
}                                                          \
function square(x) {                                       \
    return x * x;                                          \
}                                                          \
function is_divisible(x, y) {                              \
    return x % y === 0;                                    \
}                                                          \
function integers_starting_from(n) {                       \
    return pair(n,                                         \
                () => integers_starting_from(n + 1)        \
               );                                          \
}                                                          \
function is_prime(n) {                                     \
    function iter(ps) {                                    \
        return square(head(ps)) &gt; n                        \
               ? true                                      \
               : is_divisible(n, head(ps))                 \
                 ? false                                   \
                 : iter(stream_tail(ps));                  \
    }                                                      \
    return iter(primes);                                   \
}                                                          \
function stream_tail(xs) {                                 \
    return tail(xs)();                                     \
}                                                          \
function stream_filter(pred, s) {                          \
    return is_null(s)                                      \
           ? null                                          \
           : pred(head(s))                                 \
             ? pair(head(s),                               \
                    () => stream_filter(pred,              \
                                        stream_tail(s)))   \
             : stream_filter(pred,                         \
                             stream_tail(s));              \
}                                                          \
const primes = pair(2,                                     \
                    () => stream_filter(                   \
                              is_prime,                    \
                              integers_starting_from(3))   \
                   );                                      \
function prime_sum_pair(list1, list2) {                    \
    const a = an_element_of(list1);                        \
    const b = an_element_of(list2);                        \
    require(is_prime(a + b));                              \
    return list(a, b);                                     \
}                                                          \
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));       ");
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list_ref(all_solutions("                                            \
function require(p) {                                      \
    return ! p ? amb() : 'Satisfied require';              \
    }                                                      \
function an_element_of(items) {                            \
    require(! is_null(items));                             \
    return amb(head(items), an_element_of(tail(items)));   \
}                                                          \
function square(x) {                                       \
    return x * x;                                          \
}                                                          \
function is_divisible(x, y) {                              \
    return x % y === 0;                                    \
}                                                          \
function integers_starting_from(n) {                       \
    return pair(n,                                         \
                () => integers_starting_from(n + 1)        \
               );                                          \
}                                                          \
function is_prime(n) {                                     \
    function iter(ps) {                                    \
        return square(head(ps)) &gt; n                        \
               ? true                                      \
               : is_divisible(n, head(ps))                 \
                 ? false                                   \
                 : iter(stream_tail(ps));                  \
    }                                                      \
    return iter(primes);                                   \
}                                                          \
function stream_tail(xs) {                                 \
    return tail(xs)();                                     \
}                                                          \
function stream_filter(pred, s) {                          \
    return is_null(s)                                      \
           ? null                                          \
           : pred(head(s))                                 \
             ? pair(head(s),                               \
                    () => stream_filter(pred,              \
                                        stream_tail(s)))   \
             : stream_filter(pred,                         \
                             stream_tail(s));              \
}                                                          \
const primes = pair(2,                                     \
                    () => stream_filter(                   \
                              is_prime,                    \
                              integers_starting_from(3))   \
                   );                                      \
function prime_sum_pair(list1, list2) {                    \
    const a = an_element_of(list1);                        \
    const b = an_element_of(list2);                        \
    require(is_prime(a + b));                              \
    return list(a, b);                                     \
}                                                          \
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));       "),
      4);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_3</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <EXPECTED>[ 'verb', [ 'eats', null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions("                                                      \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
let unparsed = null;                                                 \
const nouns = list('noun', 'student', 'professor', 'cat', 'class');  \
const verbs = list('verb', 'studies', 'lectures', 'eats', 'sleeps'); \
const articles = list('article', 'the', 'a');                        \
function parse_word(word_list) {                                     \
    require(! is_null(unparsed));                                    \
    require(! is_null(member(head(unparsed), tail(word_list))));     \
    const found_word = head(unparsed);                               \
    unparsed = tail(unparsed);                                       \
    return list(head(word_list), found_word);                        \
}                                                                    \
function parse_noun_phrase() {                                       \
    return list('noun-phrase',                                       \
                parse_word(articles),                                \
                parse_word(nouns));                                  \
}                                                                    \
function parse_sentence() {                                          \
    return list('sentence',                                          \
                parse_noun_phrase(),                                 \
                parse_word(verbs));                                  \
}                                                                    \
function parse_input(input) {                                        \
    unparsed = input;                                                \
    const sent = parse_sentence();                                   \
    require(is_null(unparsed));                                      \
    return sent;                                                     \
}                                                                    \
parse_input(list('the',  'cat',  'eats'));                           ");
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list_ref(list_ref(all_solutions("                                                      \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
let unparsed = null;                                                 \
const nouns = list('noun', 'student', 'professor', 'cat', 'class');  \
const verbs = list('verb', 'studies', 'lectures', 'eats', 'sleeps'); \
const articles = list('article', 'the', 'a');                        \
function parse_word(word_list) {                                     \
    require(! is_null(unparsed));                                    \
    require(! is_null(member(head(unparsed), tail(word_list))));     \
    const found_word = head(unparsed);                               \
    unparsed = tail(unparsed);                                       \
    return list(head(word_list), found_word);                        \
}                                                                    \
function parse_noun_phrase() {                                       \
    return list('noun-phrase',                                       \
                parse_word(articles),                                \
                parse_word(nouns));                                  \
}                                                                    \
function parse_sentence() {                                          \
    return list('sentence',                                          \
                parse_noun_phrase(),                                 \
                parse_word(verbs));                                  \
}                                                                    \
function parse_input(input) {                                        \
    unparsed = input;                                                \
    const sent = parse_sentence();                                   \
    require(is_null(unparsed));                                      \
    return sent;                                                     \
}                                                                    \
parse_input(list('the',  'cat',  'eats'));                           "),
                 0),
        2);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>full_parser</NAME>
      <JAVASCRIPT>
const full_parser = "                                                \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
let unparsed = null;                                                 \
function parse_word(word_list) {                                     \
    require(! is_null(unparsed));                                    \
    require(! is_null(member(head(unparsed), tail(word_list))));     \
    const found_word = head(unparsed);                               \
    unparsed = tail(unparsed);                                       \
    return list(head(word_list), found_word);                        \
}                                                                    \
const prepositions = list('prep', 'for', 'to',  'in', 'by', 'with'); \
function parse_prepositional_phrase() {                              \
    return list('prep-phrase',                                       \
                parse_word(prepositions),                            \
                parse_noun_phrase());                                \
}                                                                    \
const nouns = list('noun', 'student', 'professor', 'cat', 'class');  \
const verbs = list('verb', 'studies', 'lectures', 'eats', 'sleeps'); \
                                                                     \
const articles = list('article', 'the', 'a');                        \
function parse_simple_noun_phrase() {                                \
    return list('simple-noun-phrase',                                \
                parse_word(articles),                                \
                parse_word(nouns));                                  \
}                                                                    \
function parse_noun_phrase() {                                       \
    function maybe_extend(noun_phrase) {                             \
        return amb(noun_phrase,                                      \
                   maybe_extend(list('noun-phrase',                  \
                                 noun_phrase,                        \
                                 parse_prepositional_phrase())));    \
    }                                                                \
    return maybe_extend(parse_simple_noun_phrase());                 \
}                                                                    \
function parse_sentence() {                                          \
    return list('sentence',                                          \
                parse_noun_phrase(),                                 \
                parse_verb_phrase());                                \
}                                                                    \
function parse_verb_phrase() {                                       \
    function maybe_extend(verb_phrase) {                             \
        return amb(verb_phrase,                                      \
                   maybe_extend(list('verb-phrase',                  \
                                 verb_phrase,                        \
                                 parse_prepositional_phrase())));    \
    }		                                                     \
    return maybe_extend(parse_word(verbs));                          \
}                                                                    \
function parse_input(input) {                                        \
    unparsed = input;                                                \
    const sent = parse_sentence();                                   \
    require(is_null(unparsed));                                      \
    return sent;                                                     \
}                                                                    ";
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_4</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <REQUIRES>full_parser</REQUIRES>
      <EXPECTED>[ 'article', [ 'the', null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions(full_parser + 
"                                                                   \
parse_input(list('the', 'student', 'with', 'the', 'cat',            \
'sleeps', 'in', 'the', 'class'));                                   ");
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list_ref(list_ref(list_ref(list_ref(list_ref(all_solutions(full_parser + 
"                                                                   \
parse_input(list('the', 'student', 'with', 'the', 'cat',            \
'sleeps', 'in', 'the', 'class'));                                   "),
                                             0),
                                    2),
                           2),
                  2),
         1);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_5</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <REQUIRES>full_parser</REQUIRES>
      <EXPECTED>[ 'prep', [ 'with', null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions(full_parser + 
"                                                                   \
parse_input(list('the', 'professor', 'lectures',                    \
                 'to', 'the', 'student', 'with', 'the', 'cat'));    ");
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
list_ref(list_ref(list_ref(list_ref(list_ref(list_ref(all_solutions(full_parser + 
"                                                                   \
parse_input(list('the', 'professor', 'lectures',                    \
                 'to', 'the', 'student', 'with', 'the', 'cat'));    "),
                                                      1),
                                             2),
                                    2),
                           2),
                  2),
         1);
      </JAVASCRIPT_TEST>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>first_solutions_test_1</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <!-- No test case: command line version seems 
	   too slow for this puzzle                 
      <EXPECTED>what</EXPECTED>                         -->
      <JAVASCRIPT>
first_solution("                                                     \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function distinct(items) {                                           \
    return is_null(items)                                            \
        ? true                                                       \
        : is_null(tail(items))                                       \
          ? true                                                     \
          : is_null(member(head(items), tail(items)))                \
            ? distinct(tail(items))                                  \
            : false;                                                 \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
function multiple_dwelling() {                                       \
    const baker = amb(1, 2, 3, 4, 5);                                \
    const cooper = amb(1, 2, 3, 4, 5);                               \
    const fletcher = amb(1, 2, 3, 4, 5);                             \
    const miller = amb(1, 2, 3, 4, 5);                               \
    const smith = amb(1, 2, 3, 4, 5);                                \
    require(distinct(list(baker, cooper, fletcher, miller, smith))); \
    require(! (baker === 5));                                        \
    require(! (cooper === 1));                                       \
    require(! (fletcher === 5));                                     \
    require(! (fletcher === 1));                                     \
    require(miller &gt; cooper);                                        \
    require(! (math_abs(smith - fletcher) === 1));                   \
    require(! (math_abs(fletcher - cooper) === 1));                  \
    return list(list('baker', baker),                                \
                list('cooper', cooper),                              \
                list('fletcher', fletcher),                          \
                list('miller', miller),                              \
                list('smith', smith));                               \
}                                                                    \
multiple_dwelling();                                                 ");
      </JAVASCRIPT>
    </SNIPPET>
</SUBSECTION>
