[{"id":"/sicpjs/3.2.1","tag":"TITLE","body":"3.2.1  \n    The Rules for Evaluation"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    The overall specification of how the interpreter\n    \n    evaluates a\n    \n\tfunction application\n      \n    remains the same as when we first introduced it in\n    section ","tag":"#text"},{"tag":"REF","body":"1.1.4","href":"/sicpjs/1.1.4"},{"body":":\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n        To evaluate\n\t\n\t    an application:\n\t  ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\t    Evaluate the subexpressions\n\t    of the\n\t    \n\t\tapplication.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/3.2.1#footnote-1"}]},{"tag":"LI","child":[{"body":"\n\t    Apply the value of the\n\t    \n\t\tfunction\n\t      \n\t    subexpression\n\t    to the values of the\n\t    \n\t\targument\n\t      \n\t    subexpressions.\n\t  ","tag":"#text"}]}]}]}]},{"body":"\n    The environment model of evaluation replaces the substitution model in\n    specifying what it means to apply a compound\n    function\n    to arguments.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    In the environment model of evaluation, a\n    function\n    is always a pair consisting of some code and a pointer to an environment. \n    Functions\n    are created in one way only: by evaluating a\n    lambda\t\n    expression.\n    \n    This produces a\n    function\n    whose code is obtained from the text of the\n    lambda\t\n    expression and whose environment is the environment in which the\n    lambda\t\n    expression was evaluated to produce the\n    function.\n    For example, consider the\n    function declaration","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQCY0EYBQuAzAVwDsBjAFwEsB7E0AZwEciBDAJwFMAKADwEpQAb1ygxoLhSLt6vUACpQvANy4AvvmZsu3bABZ+yoA","body":"function square(x) {\n    return x * x;\n} "},{"body":"\n    evaluated in the\n    \n\tprogram\n      \n    environment.  The\n    function declaration\n    syntax is\n    \n\tequivalent to\n      \n    an underlying implicit\n    lambda\n    expression.  It would have been equivalent to have used","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/3.2.1#footnote-2"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQCY0EYBQuBjAewDsBnAF1DIEcBXAQwCcBTUAXlAA8OA+b0ACpuAbny1GrABTYALAEoRQA","body":"const square = x => x * x; "},{"body":"\n    which evaluates\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x => x * x"},{"body":"\n    and binds ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" to the resulting value, all\n    in the\n    \n\tprogram\n      \n    environment.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n\tFigure ","tag":"#text"},{"tag":"REF","body":"3.2","href":"/sicpjs/3.2.1#fig-3.2"},{"body":"\n    shows the result of evaluating this\n    declaration statement.\n\tThe global environment encloses the program environment. To reduce\n\tclutter, after this figure we will not display the global environment\n\t(as it is always the same), but we are reminded of its existence by the\n\tpointer from the program environment upward. \n      \n    The\n    function\n    object is a pair whose code specifies that the\n    function\n    has one\n    \n    parameter, namely ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":", and a\n    function\n    body\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return x * x;"},{"body":".\n      \n    The environment part of the\n    function\n    is a pointer to the program environment, since that is the environment in\n    which the\n    lambda\n    expression was evaluated to produce the\n    function.\n    A new binding, which associates the\n    function\n    object with the\n    \n\tname\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":", has been added\n    to the program frame. \n    ","tag":"#text"},{"tag":"FIGURE","scale":"50%","src":"img_javascript/ch3-Z-G-3.svg","id":"#fig-3.2","captionHref":"/sicpjs/3.2.1#fig-3.2","captionName":"Figure 3.2 ","captionBody":[{"body":"\n\t    Environment structure produced by evaluating\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"function square(x) { return x * x; }"},{"body":"\n\t    in the program environment.\n\t  ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n\tIn general, ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"const"},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"function"},{"body":", and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"let"},{"body":"\n\tadd bindings to frames.\n\tAssignment is forbidden on constants, so our environment model\n\tneeds to distinguish names that refer to constants\n\tfrom names that refer to variables. We indicate that\n\ta name is a constant by writing an equal sign after the colon\n\tthat follows the name.\n\tWe consider function declarations as equivalent to constant\n\tdeclarations;","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/3.2.1#footnote-3"},{"body":"\n\tobserve the equal signs after the colons in\n\tfigure ","tag":"#text"},{"tag":"REF","body":"3.2","href":"/sicpjs/3.2.1#fig-3.2"},{"body":".\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Now that we have seen how\n    functions\n    are created, we can describe how\n    functions\n    are applied.  The environment model specifies: To apply a\n    function\n    to arguments, create a new environment containing a frame that binds the\n    parameters to the values of the arguments.  The enclosing environment of\n    this frame is the environment specified by the\n    function.\n    Now, within this new environment, evaluate the\n    function\n    body.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    To show how this rule is followed,\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"3.3","href":"/sicpjs/3.2.1#fig-3.3"},{"body":"\n    illustrates the environment structure created by evaluating the\n    expression\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square(5)"},{"body":"\n    in the\n    program\n    environment, where ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" is the\n    function\n    generated in\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"3.2","href":"/sicpjs/3.2.1#fig-3.2"},{"body":".\n      \n    Applying the\n    function\n    results in the creation of a new environment, labeled E1 in the figure, that\n    begins with a frame in which ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":", the\n    \n    parameter for the\n    function,\n    is bound to the argument 5.\n    \n\tNote that name ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" in environment E1 is\n\tfollowed by a colon with no equal sign, which indicates\n\tthat the parameter ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" is treated as a\n\tvariable.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/3.2.1#footnote-4"},{"body":"\n    The pointer leading upward from this frame shows that the\n    frame's enclosing environment is the\n    program\n    environment.  The\n    program\n    environment is chosen here, because this is the environment that is\n    indicated as part of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":"function\n    object.  Within E1, we evaluate the body of the\n    function,","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return x * x;"},{"body":".\n      \n    Since the value of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" in E1 is 5, the result is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5 * 5"},{"body":",\n    or 25.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ch3-Z-G-4.svg","id":"#fig-3.3","captionHref":"/sicpjs/3.2.1#fig-3.3","captionName":"Figure 3.3 ","captionBody":[{"body":"\n\t    Environment created by evaluating\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square(5)"},{"body":"\n\t    in the program environment.\n\t  ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    The environment model of\n    function\n    application can be summarized by two\n    rules:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tA\n\tfunction\n\tobject is applied to a set of arguments by constructing a frame, \n\tbinding the parameters of the function\n\tto the arguments of the call, and then evaluating the body of the\n\tfunction\n\tin the context of the new environment constructed.  The new frame has as\n\tits enclosing environment the environment part of the\n\tfunction\n\tobject being applied.\n\tThe result of the application is the result of evaluating\n\tthe return expression of the first return statement encountered\n\twhile evaluating the function body.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tA\n\tfunction\n\tis created by evaluating a \n\tlambda\n\texpression relative to a given environment.  The resulting\n\tfunction\n\tobject is a pair consisting of the text of the\n\tlambda\n\texpression and a pointer to the environment in which the\n\tfunction\n\twas created.\n      ","tag":"#text"}]}]}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n\tFinally, we specify the behavior of assignment, the operation that\n\tforced us to introduce the environment model in the first place.\n\tEvaluating the expression\n\t","tag":"#text"},{"tag":"META","body":"name"},{"body":" ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"="},{"body":" ","tag":"#text"},{"tag":"META","body":"value"},{"body":"\n\tin some environment\n\tlocates the binding of the name in the environment.\n\tThat is, one finds the first frame in the environment that contains a\n\tbinding for the name.\n\tIf the binding is a variable binding—indicated in the frame by\n\tjust ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":":"},{"body":"\n\tafter the name—that binding is changed to reflect the new\n\tvalue of the variable. \n\tOtherwise, if the binding in the frame is a constant\n\tbinding—indicated\n\tin the frame by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":":="},{"body":"\n\tafter the name—the assignment signals an\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"assignment to constant\""},{"body":" error.\n\tIf the name is unbound in the environment, then\n\tthe assignment signals a\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"variable undeclared\""},{"body":" error.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    These evaluation rules, though considerably more complex than the\n    substitution model, are still reasonably straightforward.  Moreover,\n    the evaluation model, though abstract, provides a correct description\n    of how the interpreter evaluates expressions.  In chapter ","tag":"#text"},{"tag":"REF","body":"4","href":"/sicpjs/4"},{"body":" we shall\n    see how this model can serve as a blueprint for implementing a working\n    interpreter.  The following sections elaborate the details of the\n    model by analyzing some illustrative programs.\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/3.2.1#footnote-link-1","child":[{"body":"Assignment introduces a subtlety\n\t\tinto step 1 of the evaluation rule.  As shown in\n\t\texercise , the\n\t\tpresence of assignment allows us to write expressions that will\n\t\tproduce different values depending on the order in which the\n\t\tsubexpressions in a combination\n\t\tare evaluated. To eliminate such ambiguities,\n\t\t\n\t\tJavaScript specifies left-to-right evaluation of the\n\t\tsubexpressions of combinations and of the argument expressions\n\t\tof applications.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/3.2.1#footnote-link-2","child":[{"body":"\n\tFootnote ","tag":"#text"},{"tag":"REF","body":2,"href":"/sicpjs/1.3.2#footnote-2"},{"body":" in chapter 1\n\tmentions subtle differences between the two in full JavaScript, which\n\twe will ignore in this book.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/3.2.1#footnote-link-3","child":[{"body":"We mentioned in\n\tfootnote ","tag":"#text"},{"tag":"REF","body":2,"href":"/sicpjs/1.3.2#footnote-2"},{"body":"\n\tin chapter 1\n\tthat the full JavaScript language allows assignment to\n\tnames that are declared with function declarations.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/3.2.1#footnote-link-4","child":[{"body":"This example does not make use of the fact that\n\tthe parameter ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" is a variable, but recall the\n\tfunction ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_withdraw"},{"body":" in\n\tsection ","tag":"#text"},{"tag":"REF","body":"3.1.1","href":"/sicpjs/3.1.1"},{"body":", which relied on\n\tits parameter being a variable.\n\t","tag":"#text"}]}]