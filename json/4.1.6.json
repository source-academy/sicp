[{"id":"/sicpjs/4.1.6","tag":"TITLE","body":"4.1.6  \n    Internal\n    \n      \n      Declarations"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n\tIn JavaScript, the scope of a declaration\n\tis the entire block that immediately surrounds the declaration,\n\tnot just the portion of the block starting at the point where\n\tthe declaration occurs.\n\tThis section takes a closer look at this design choice.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n\tLet us revisit the pair of mutually recursive functions\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":" from\n\tSection ","tag":"#text"},{"tag":"REF","body":"3.2.4","href":"/sicpjs/3.2.4"},{"body":",\n\tdeclared locally\n\tin the body of a function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":".\n\t","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction f(x) {\n    function is_even(n) {\n        return n === 0\n               ? true\n               : is_odd(n - 1);\n    }\n    function is_odd(n) {\n        return n === 0\n               ? false\n               : is_even(n - 1);\n    }\n    return is_even(x);\n}\n\t  "},{"body":"\n\tOur intention here is that the name\n\t ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":"\n\tin the body of the function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":"\n\tshould refer to the function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":"\n\tthat is declared after ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":".\n\tThe scope of the name ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":" is the\n\tentire body block of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":", not just the portion of\n\tthe body of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":" starting at the point where\n\tthe declaration of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":"\n\toccurs. Indeed, when we consider that\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":" is itself defined in terms of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":"—so that\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":" are mutually recursive\n\tfunctions—we see that the only\tsatisfactory interpretation of\n\tthe two declarations is to regard them as if the names\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":"\n\twere being added to the environment simultaneously. More generally, in\n\tblock structure, the scope of a local name is the entire block\n\tin which the declaration is evaluated.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n\tThe evaluation of blocks in the metacircular evaluator of\n\tsection ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":" achieves such\n\ta simultaneous scope for local names by\n        \n\tscanning out the declarations in the block and extending the current\n\tenvironment with a frame containing bindings for all the declared\n\tnames before evaluating the declarations. Thus the new environment\n\tin which the block body is evaluated already contains\n\tbindings for \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":", and any occurrence\n\tof one of these names refers to the correct binding. Once their\n\tdeclarations are evaluated,\n\tthese names are bound to their declared values, namely function\n\tobjects that have the extended environment as their environment\n\tpart. Thus, for example,\n\tby the time\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":" \t\n\tgets applied in the body of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":", its environment\n\talready contains the correct binding for the symbol\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":", and\n\tthe evaluation of the name \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":" in the body  of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":" retrieves the correct\n\tvalue.\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.16","id":"#ex-4.16","child":[{"body":"\n\tConsider the function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f_3"},{"body":"\n\tof section ","tag":"#text"},{"tag":"REF","body":"1.3.2","href":"/sicpjs/1.3.2"},{"body":":\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"function f_3(x, y) {\n    const a = 1 + x * y;\n    const b = 1 - y;\n    return x * square(a) + y * b + a * b;\n}"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\t    Draw a diagram of the environment in effect during evaluation\n\t    of the return expression of\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f_3"},{"body":".\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t    When evaluating a function application, the evaluator creates two\n\t    frames: one for the parameters and one for the names declared \n\t    ","tag":"#text"},{"tag":"EM","child":[{"body":"directly","tag":"#text"}]},{"body":" in the function's body\n\t    block, as opposed to in an inner block.\n\t    Since all these names have\n\t    the same scope, an implementation could combine the two frames.\n\t    Change the evaluator\n\t    such that the evaluation of the body block does not create\n\t    a new frame.\n\t    You may assume that this will not result in duplicate names\n\t    in the frame (exercise ","tag":"#text"},{"tag":"REF","body":"4.5","href":"/sicpjs/4.1.2#ex-4.5"},{"body":" justifies this).\n\t  ","tag":"#text"}]}]}]},{"tag":"EXERCISE","title":"Exercise 4.17","id":"#ex-4.17","child":[{"body":"    \n\t    Eva Lu Ator is writing programs in which\n\t    function declarations and other statements are interleaved.\n\t    She needs to make sure that the declarations are evaluated before\n\t    the functions are applied. She complains: \"","tag":"#text"},{"body":"Why can't\n\t    the evaluator take care of this chore, and\n\t    \n\t    hoist all function\n\t    declarations to the beginning of the block in which they appear? Function declarations outside of blocks should be hoisted to the beginning of the program.","tag":"#text"},{"body":"\"","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\t\tModify the evaluator following Eva's suggestion.\n\t      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t\tThe designers of JavaScript decided to follow Eva's approach.\n\t\tDiscuss this decision.\n\t      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t\tIn addition, the designers of JavaScript decided to allow the name declared\n\t\tby a function declaration to be reassigned using assignment.\n\t\tModify your solution\n\t\taccordingly and discuss this decision.\n\t      ","tag":"#text"}]}]}]},{"tag":"EXERCISE","title":"Exercise 4.18","id":"#ex-4.18","child":[{"body":"\n\tRecursive functions are obtained in a\n\t\n\troundabout way in our\n\tinterpreter: First declare the name that will refer to the recursive\n\tfunction and assign to it the special value\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"*unassigned*\""},{"body":"; then define the\n\trecursive function in the scope of that name; and finally assign the\n\tdefined function to the name. By the time the recursive function gets\n\tapplied, any occurrences of the name in the body properly refer to\n\tthe recursive function. Amazingly, it is possible to specify recursive\n\tfunctions without using declarations or assignment. The following program computes\n\t10 factorial by applying a recursive\n\t\n\tfactorial function:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/4.1.6#footnote-1"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAFgHQEY0DYBQuAKAO1AF4A+UAgMwEMBjAFzMrqZocYBpQiBKPrlDCRBGt1ABrPiyllSpUBiEjVatQH4lK9bpEAuOQCpQ1RuJ6TQAWiUC+BDAAY+AbiA","body":"(n => (fact => fact(fact, n))\n      ((ft, k) => k === 1\n                  ? 1\n                  : k * ft(ft, k - 1)))(10); "},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\t    Check (by evaluating the expression) that this really does compute\n\t    factorials.  Devise an analogous expression for computing Fibonacci\n\t    numbers.\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t    Consider the function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":" given\n\t    above:\n\t    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction f(x) {\n    function is_even(n) {\n        return n === 0\n               ? true\n               : is_odd(n - 1);\n    }\n    function is_odd(n) {\n        return n === 0\n               ? false\n               : is_even(n - 1);\n    }\n    return is_even(x);\n}\n\t      "},{"body":"\n\t    Fill in the missing expressions to complete an alternative\n\t    declaration of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":", which has\n\t    no internal function declarations:\n\t    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction f(x) {\n    return ((is_even, is_odd) => is_even(is_even, is_odd, x))\n           ((is_ev, is_od, n) => n === 0 ? true : is_od($\\langle{}$??$\\rangle$, $\\langle{}$??$\\rangle$, $\\langle{}$??$\\rangle$),\n            (is_ev, is_od, n) => n === 0 ? false : is_ev($\\langle{}$??$\\rangle$, $\\langle{}$??$\\rangle$, $\\langle{}$??$\\rangle$));\n}\n\t      "}]}]}],"solution":[{"body":"\n\t  Part (a)\n\t  ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAFgHQEY0DYBQuRQBnAewBsBXAFwEsSA7UABwCcSA3GgEwFMvQARgE9QAcRpUAEhQGgKRHi1AAZCgGMAhkVFcSRAEr5CAFQAWPUADEaAhhrVqaoAGYV6a2g1AseanjXYeIlBGLVANUJYAcwoAWx56KgIwSCpwpiYyGiDQKnMXGxc3DzpGHzUKFiIAnjIhABpmLWr6KJDw4Ijw6LiEqnrkjtAAd1qyIbyLGnoJGg1xjR74xOCACgBrUABeUAxG5xsMbd39mwAmY4wASlxVxi2APlBVg9lHgoEXm0b6RrPGva7K43UCgsEmfKvIruTyMGjBSaMXgHeh8IbOfq4MHgsDDCSmJosDTxKiKYK-UDrU4CQERfivM5Y7GgQgAUSIVA0AiyRAJk0EWgsmgURAAXO0tpLdqASEp7lLGczni9+iFGlSPoCGVdtk95TsMEylcawQB+XZGk3G8X60CKq0m82Gh0m0WWl040CpRQaUlyRI0cabHgARwo83JaFAADkSLQ-JTiJyWFROml-uF6PwojxU6BpmofMtSfweIEWCIJD7Ye6PYnJTt6LWPYQAOrmRibHz2czkxo+KiVRj8+wVWIUMi+tEM5su80zuvMwgAeUmLDxCkao7iE6nuXyRDiE3yqOGH3ti9B4oxKp+6tAAGoTufqUcn9rgQBuIA","body":"// solution provided by GitHub user LucasGdosR\n\n// The Fibonacci function receives n as an argument\n// It applies the fib function recursively, passing n as an argument,\n// as well as the initial arguments (k = 1, fib1 = 1, fib2 = 1)\n(n => (fib => fib(fib, n, 2, 1, 1))\n      // The fib function is then defined as ft,\n      // with parameters n, k, fib1, and fib2\n      // Establish the base cases: n === 1 or n === 2\n      ((ft, n, k, fib1, fib2) => n === 1\n                  ? 1\n                  : n === 2\n                  ? 1\n                  :\n                  // Iterate until k equals n. Notice k starts at 2, and gets incremented every iteration\n                  k === n\n                  // When k reaches n, return the accumulated fib2\n                  ? fib2\n                  // Otherwise, accumulate the sum as the new fib2\n                  : ft(ft, n, k + 1, fib2, fib1 + fib2))); "},{"body":"\n\t  Part (b)\n\t  ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAFgHQEY0DYBQuRQBnAewBsBXAFwEsSA7UABwCcSA3GgEwFMvQARgE9QAcRpUAEhQGgKRHi1AAZCgGMAhkVFcSRAEr4AZhXpraDUEYAUADwCUoAN65Qb0Cx5UKLRtes0RAD6POw89AA0oIFBJFxcjgC8AHzRwaHhAelhkWmx8VEO9q7upe7+MaFRMXFR9EmpjInNoAAMoAD8oFQsFDygAFx5cVkh7NXBtaCMALSgGPYRJWWlo1XDXHUN06DNiW2dVhpkCoN5oWvjG3Wgcwv2ANy4AL5AA","body":"// solution provided by GitHub user LucasGdosR\n\nfunction f(x) {\n    return ((is_even, is_odd) => is_even(is_even, is_odd, x))\n           ((is_ev, is_od, n) => n === 0 ? true : is_od(is_ev, is_od, n - 1),\n           (is_ev, is_od, n) => n === 0 ? false : is_ev(is_ev, is_od, n - 1));\n} "}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Sequential Declaration Processing","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\t\n\tThe design of our evaluator of\n\tsection ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":" imposes a\n\truntime burden on the evaluation of blocks: It needs to scan\n\tthe body of the block for locally declared names, extend the\n\tcurrent environment with a new frame that binds those names, and evaluate the\n\tblock body in this extended environment. Alternatively, the evaluation\n\tof a block could extend the current environment with an empty frame.\n\tThe evaluation of each declaration in the block body would then add\n\ta new binding to that frame.\n\tTo implement this design, we first simplify\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_block"},{"body":":\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"function eval_block(component, env) {\n    const body = block_body(component);\n    return evaluate(body, extend_environment(null, null, env);\n}"},{"body":"\n\tThe function \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_declaration"},{"body":" can no\n\tlonger assume that the environment already has a binding for\n\tthe name.\n\tInstead of using\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assign_symbol_value"},{"body":" to\n\tchange an existing binding, it calls a new function,\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_binding_to_frame"},{"body":", to\n\tadd to the first frame of the environment a binding of the name\n\tto the value of the value expression.\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"function eval_declaration(component, env) {\n    add_binding_to_frame(\n        declaration_symbol(component),\n        evaluate(declaration_value_expression(component), env),\n        first_frame(env));\n    return undefined;\n}\nfunction add_binding_to_frame(symbol, value, frame) {\n    set_head(frame, pair(symbol, head(frame)));\n    set_tail(frame, pair(value, tail(frame)));\n}"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n\tWith sequential declaration processing, the scope of a\n\tdeclaration is no longer the entire block that immediately surrounds\n\tthe declaration, but rather just the portion of the block starting at\n\tthe point where the declaration occurs.\n\tAlthough we no longer have simultaneous scope, sequential\n\tdeclaration processing\n\twill evaluate calls to the function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":" at the beginning of this section\n\tcorrectly, but for an\n\t\"","tag":"#text"},{"body":"accidental","tag":"#text"},{"body":"\" reason: Since the declarations\n\tof the internal functions come first, no calls to these functions\n\twill be evaluated until all of them have been declared. Hence,\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_odd"},{"body":" will have been declared by the time\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_even"},{"body":" is executed.  In fact, \n\tsequential declaration processing \n\twill give the same result as our scanning-out-names evaluator in\n\tsection ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":"\n\tfor any function\n\tin which the \n\t\n\tinternal declarations come first in a body and evaluation of the value\n\texpressions for the declared names doesn't actually use any of\n\tthe declared names.\n\tExercise ","tag":"#text"},{"tag":"REF","body":"4.19","href":"/sicpjs/4.1.6#ex-4.19"},{"body":" shows\n\tan example of a function that doesn't\n\tobey these restrictions, so that the alternative evaluator isn't\n\tequivalent to our scanning-out-names evaluator.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n\tSequential declaration processing is more efficient and easier to\n\timplement than scanning out names.\n\tHowever, with sequential processing, the\n\tdeclaration to which a name refers may depend on the order in which\n\tthe statements in a block are evaluated.\n\tIn exercise ","tag":"#text"},{"tag":"REF","body":"4.19","href":"/sicpjs/4.1.6#ex-4.19"},{"body":", we see that\n\tviews may differ as to whether that is desirable.\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.19","id":"#ex-4.19","child":[{"body":" \n\tBen Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing about\n\tthe desired result of evaluating the program\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAFgHQEY0DYBQuBjAewDsBnAF1AENQBeUDAblwDMBXEgigS1NFYAKAB4BKUAG9Q0mbhmhi5KgCN6NUAGpQwlvMWV1DAKy6ZAJwCmFdmZLqtylgF82gjAAZRTIA","body":"const a = 1;\nfunction f(x) {      \n    const b = a + x;\n    const a = 5;\n    return a + b;\n}\nf(10); "},{"body":"\n\tBen asserts that the result should be obtained using the sequential\n\tprocessing of declarations:\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" is declared to be 11, then\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" is declared to be 5, so the result is 16.\n\tAlyssa objects that mutual recursion requires the simultaneous scope\n\trule for internal function declarations, and that it is unreasonable to\n\ttreat function names differently from other names.  Thus, she argues for\n\tthe mechanism implemented in\n\tsection ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":". This would\n\tlead to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" being unassigned at the time that\n\tthe value for ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" is to be computed.  Hence,\n\tin Alyssa's view the function should produce an error.  Eva has a\n\tthird opinion.  She says that if the declarations of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":"\n\tare truly meant to be simultaneous, then the value 5 for\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" should be used in evaluating\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":".  Hence, in Eva's view\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" should be 5,\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" should be 15, and the result should be 20.\n\tWhich (if any) of these\tviewpoints do you support?  Can you devise a way\n\tto implement internal declarations so that they behave as Eva\n\tprefers?","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/4.1.6#footnote-2"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/4.1.6#footnote-link-1","child":[{"body":"This example illustrates a programming\n\ttrick for formulating recursive functions without using assignment. The\n\tmost general trick of this sort is the\n\t","tag":"#text"},{"body":"$Y$","tag":"LATEX"},{"tag":"EM","child":[{"body":"operator","tag":"#text"}]},{"body":", which can be used to give a \"","tag":"#text"},{"body":"pure\n\t","tag":"#text"},{"body":"$\\lambda$","tag":"LATEX"},{"body":"-calculus","tag":"#text"},{"body":"\" implementation of\n\trecursion.  (See\n\tStoy 1977 for details on the lambda\n\tcalculus, and Gabriel 1988 for an exposition of the\n\t","tag":"#text"},{"body":"$Y$","tag":"LATEX"},{"body":" operator in the language\n\tScheme.)","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/4.1.6#footnote-link-2","child":[{"body":"The designers of JavaScript support Alyssa on the\n\tfollowing grounds: Eva is in principle correct—the declarations\n\tshould be regarded as simultaneous.  But it seems difficult to implement\n\ta general, efficient mechanism that does what Eva requires. In the\n\tabsence of such a mechanism, it is better to generate an error in the\n\tdifficult cases of simultaneous declarations (Alyssa's notion) than\n\tto produce an incorrect answer (as Ben would have it).","tag":"#text"}]}]