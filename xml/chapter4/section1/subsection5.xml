<SUBSECTION>
  <NAME>
    Data as Programs
  </NAME>

  <LABEL NAME="sec:data-as-programs"/>

  <INDEX>program<SUBINDEX><ORDER>data</ORDER>as data<OPEN/></SUBINDEX></INDEX>
  <INDEX>data<SUBINDEX><ORDER>program</ORDER>as program<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    In thinking about a
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    program that evaluates
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript statements and</JAVASCRIPT>
    </SPLITINLINE>
    expressions, an analogy might be helpful.  One operational view of the
    meaning of a program is that a 
    <INDEX>program<SUBINDEX><ORDER>abstract</ORDER>as abstract machine</SUBINDEX></INDEX>
    program is a description of an abstract (perhaps infinitely large) machine.
    For example, consider the familiar program to compute factorials:
    <SNIPPET>
      <NAME>factorial_4_1_5</NAME>
      <EXAMPLE>factorial_example</EXAMPLE>
      <EXPECTED>120</EXPECTED>
      <SCHEME>
(define (factorial n)
   (if (= n 1)
       1
       (* (factorial (- n 1)) n)))
      </SCHEME>
      <JAVASCRIPT>
function factorial(n) {
    return n === 1
           ? 1
           : factorial(n - 1) * n;
}
      </JAVASCRIPT>
    </SNIPPET>
    We may regard this program as the description of a
    <INDEX><USE>factorial</USE><SUBINDEX>as an abstract machine</SUBINDEX></INDEX>
    machine containing
    parts that decrement, multiply, and test for equality, together with a
    two-position switch and another factorial machine. (The factorial
    machine is infinite because it contains another factorial machine
    within it.)  Figure<SPACE/><REF NAME="fig:fact-proc-as-machine"/> is a flow
    diagram for the factorial machine, showing how the parts are wired together.
    <FIGURE>
      <FIGURE web_scale="0.9" src="img_original/ch4-Z-G-2.svg"></FIGURE>
      <LABEL NAME="fig:fact-proc-as-machine"/>
      <CAPTION>The factorial program, viewed as an abstract machine.
      </CAPTION>
    </FIGURE>
  </TEXT>

  <TEXT>
    In a similar way, we can regard the evaluator as a very special
    <INDEX>evaluator<SUBINDEX><ORDER>abstract</ORDER>as abstract machine</SUBINDEX></INDEX>
    machine that takes as input a description of a machine.  Given this
    input, the evaluator configures itself to emulate the machine
    described.  For example, if we feed our evaluator the definition of
    <SCHEMEINLINE>factorial</SCHEMEINLINE>, as shown in
    <SPLITINLINE>
      <SCHEME>figure<SPACE/><REF NAME="fig:eval-factorial_scheme"/>,</SCHEME>
      <JAVASCRIPT>figure<SPACE/><REF NAME="fig:eval-factorial"/>,</JAVASCRIPT>
    </SPLITINLINE>
    the evaluator will be able to compute factorials.
    <SPLIT>
      <SCHEME>
	<FIGURE>
          <FIGURE web_scale="0.7" src="img_original/ch4-Z-G-3.svg"></FIGURE>
          <LABEL NAME="fig:eval-factorial_scheme"/>
          <CAPTION>The evaluator emulating a factorial machine.
          </CAPTION>
	</FIGURE>
      </SCHEME>
      <JAVASCRIPT>
	<FIGURE>
          <FIGURE web_scale="0.7" src="img_javascript/ch4-Z-G-3.svg"></FIGURE>
          <LABEL NAME="fig:eval-factorial"/>
          <CAPTION>The evaluator emulating a factorial machine.
          </CAPTION>
	</FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    From this perspective, our evaluator is seen to be a
    <INDEX>evaluator<SUBINDEX><ORDER>universal</ORDER>as universal machine</SUBINDEX></INDEX>
    <INDEX>universal machine</INDEX>
    <EM>universal machine</EM>.
    It mimics other machines when these are described as 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE> 
    programs.<FOOTNOTE>The fact that the machines are described in 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE> 
    is inessential.  If we give our evaluator a 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE> 
    program that behaves as an evaluator for some other language, say C, the 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE> 
    evaluator will emulate the C evaluator, which in turn can emulate any
    machine described as a C program.  Similarly, writing a 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE> 
    evaluator in C produces a C program that can execute any 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE> 
    program.  The deep idea here is that any evaluator can emulate any other.
    Thus, the notion of <QUOTE>what can in principle be computed</QUOTE>
    (ignoring practicalities of time and memory required) is independent of the
    language or the computer, and instead reflects an underlying notion of 
    <INDEX>computability</INDEX>
    <EM>computability</EM>.  This was first demonstrated in a clear way by 
    <INDEX>Turing, Alan M.</INDEX>
    Alan M. Turing (1912<ENDASH/>1954), whose 1936 paper laid the foundations
    for theoretical 
    <INDEX>computer science</INDEX>
    computer science.  In the paper, Turing presented a simple computational
    model<EMDASH/>now known as a 
    <INDEX>Turing machine</INDEX>
    <EM>Turing machine</EM><EMDASH/>and argued that any <QUOTE>effective
    process</QUOTE> can be formulated as a program for such a machine.  (This
    argument is known as the 
    <INDEX>Church-Turing thesis</INDEX>
    <EM>Church-Turing thesis</EM>.) Turing then implemented a universal machine,
    i.e., a Turing machine that behaves as an evaluator for Turing-machine
    programs.  He used this framework to demonstrate that there are well-posed
    problems that cannot be computed by Turing machines (see
    exercise<SPACE/><REF NAME="ex:halting-theorem"/>), and so by implication
    cannot be formulated as <QUOTE>effective processes.</QUOTE>  Turing went on
    to make fundamental contributions to practical computer science as well.
    For example, he invented the idea of 
    <INDEX>program<SUBINDEX>structured with subroutines</SUBINDEX></INDEX>
    structuring programs using general-purpose subroutines.  See 
    <INDEX>Hodges, Andrew</INDEX>
    <CITATION>Hodges 1983</CITATION> for a biography of Turing.</FOOTNOTE>
    This is striking. Try to imagine an analogous evaluator for electrical
    circuits.  This would be a circuit that takes as input a signal encoding the
    plans for some other circuit, such as a filter.  Given this input, the
    circuit evaluator would then behave like a filter with the same description.
    Such a universal electrical circuit is almost unimaginably complex.  It is
    remarkable that the program evaluator is a rather simple
    program.<FOOTNOTE>Some people find it counterintuitive that an evaluator,
    which is implemented by a relatively simple
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    can emulate programs that are more complex than the evaluator itself.  The
    existence of a universal evaluator machine is a deep and wonderful property
    of computation.
    <INDEX>recursion theory</INDEX>
    <EM>Recursion theory</EM>, a branch of mathematical logic, is concerned with
    logical limits of computation.  
    <INDEX>Hofstadter, Douglas R.</INDEX>
    Douglas Hofstadter<APOS/>s beautiful book <EM>G<OUML_LOWER/>del, Escher,
    Bach</EM> (1979) explores some of these ideas.</FOOTNOTE>
  </TEXT>

  <TEXT>
    Another striking aspect of the evaluator is that it acts as a bridge between
    the data objects that are manipulated by our programming language and the
    programming language itself.  Imagine that the evaluator program
    <SPLITINLINE>
      <SCHEME>(implemented in Lisp)</SCHEME>
      <JAVASCRIPT>(implemented in JavaScript)</JAVASCRIPT>
    </SPLITINLINE>
    is running, and that a user is typing
    <SPLITINLINE>
      <SCHEME>expressions</SCHEME>
      <JAVASCRIPT>programs</JAVASCRIPT>
    </SPLITINLINE>
    to the evaluator and
    observing the results. From the perspective of the user, an input
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
      <JAVASCRIPT>program</JAVASCRIPT>
    </SPLITINLINE>
    such as 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(* x x)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>x * x;</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is
    <SPLITINLINE>
      <SCHEME>an expression</SCHEME>
      <JAVASCRIPT>a program</JAVASCRIPT>
    </SPLITINLINE>
    in the programming language, which the evaluator should
    execute.
    <SPLITINLINE>
      <SCHEME>
	From the perspective of the evaluator, however, the expression is simply
	a list (in this case, a list of three symbols:
	<SCHEMEINLINE>*</SCHEMEINLINE>, <SCHEMEINLINE>x</SCHEMEINLINE>, 
	and <SCHEMEINLINE>x</SCHEMEINLINE>) that is to be manipulated according
	to a well-defined set of rules.
      </SCHEME>
      <JAVASCRIPT>
	From the perspective of the evaluator, however, the program is simply
	a string or<EMDASH/>after parsing<EMDASH/>a tagged-list representation
	that is to be manipulated according to a well-defined set of rules.
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <SPLIT>
    <SCHEME>
      <TEXT>
	That the user<APOS/>s programs are the evaluator<APOS/>s data need not
	be a source of confusion.  In fact, it is sometimes convenient to ignore
	this distinction, and to give the user the ability to explicitly
	evaluate a data object as a Lisp expression, by making
	<SCHEMEINLINE>eval</SCHEMEINLINE> available for use in programs.  Many
	Lisp dialects provide a 
	<INDEX><DECLARATION>eval</DECLARATION></INDEX>
	<INDEX><DECLARATION>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>eval</ORDER><SCHEMEINLINE>eval</SCHEMEINLINE> (<EM>ns</EM>)</SUBINDEX></INDEX>
	primitive <SCHEMEINLINE>eval</SCHEMEINLINE> procedure that takes as
	arguments an expression and an environment and evaluates the expression
	relative to the environment.<FOOTNOTE>Warning:
	<INDEX><USE>eval</USE> (metacircular)<SUBINDEX>primitive <SCHEMEINLINE>eval</SCHEMEINLINE> vs.</SUBINDEX></INDEX>
	This <SCHEMEINLINE>eval</SCHEMEINLINE> primitive is not
	identical to the <SCHEMEINLINE>eval</SCHEMEINLINE> procedure we
	implemented in section<SPACE/><REF NAME="sec:core-of-evaluator"/>,
	because it uses <EM>actual</EM>	Scheme environments rather than the
	sample environment structures we built in
	section<SPACE/><REF NAME="sec:eval-data-structures"/>.  These actual
	environments cannot be manipulated by the user as ordinary lists; they
	must be accessed via <SCHEMEINLINE>eval</SCHEMEINLINE> or other special
	operations.
	Similarly, the
	<INDEX><USE>apply</USE> (metacircular)<SUBINDEX>primitive <SCHEMEINLINE>apply</SCHEMEINLINE> vs.</SUBINDEX></INDEX>
	<SCHEMEINLINE>apply</SCHEMEINLINE> primitive we saw
	earlier is not identical to the metacircular
	<SCHEMEINLINE>apply</SCHEMEINLINE>, because it uses actual Scheme
	procedures rather than the procedure objects we constructed in
	sections<SPACE/><REF NAME="sec:eval-data-structures"/>
	and<SPACE/><REF NAME="sec:running-eval"/>.</FOOTNOTE>
	Thus,
	<SNIPPET>
	  <SCHEME>
(eval '(* 5 5) user-initial-environment)
	  </SCHEME>
	</SNIPPET>
	and
	<SNIPPET>
	  <SCHEME>
(eval (cons '* (list 5 5)) user-initial-environment)
	  </SCHEME>
	</SNIPPET>
	will both return 25.<FOOTNOTE>The MIT
	<INDEX>MIT Scheme<SUBINDEX><ORDER>eval</ORDER><SCHEMEINLINE>eval</SCHEMEINLINE></SUBINDEX></INDEX>
	<INDEX>MIT Scheme<SUBINDEX><ORDER>user-initial-environment</ORDER><SCHEMEINLINE>user-initial-environment</SCHEMEINLINE></SUBINDEX></INDEX>
	<INDEX><DECLARATION>eval</DECLARATION><SUBINDEX>MIT Scheme</SUBINDEX></INDEX>
	<INDEX><DECLARATION>user-initial-environment</DECLARATION> (MIT Scheme)</INDEX>
	implementation of Scheme includes <SCHEMEINLINE>eval</SCHEMEINLINE>, as
	well as a symbol <SCHEMEINLINE>user-initial-environment</SCHEMEINLINE>
	that is bound to the initial environment in which the user<APOS/>s input
	expressions are evaluated.
	<LABEL NAME="foot:mit-eval"/></FOOTNOTE>

	<INDEX>program<SUBINDEX><ORDER>data</ORDER>as data<CLOSE/></SUBINDEX></INDEX>
	<INDEX>data<SUBINDEX><ORDER>program</ORDER>as program<CLOSE/></SUBINDEX></INDEX>
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <TEXT>
	That the
	<INDEX>JavaScript<SUBINDEX><DECLARATION>eval</DECLARATION> in</SUBINDEX></INDEX>
	<INDEX><USE>eval</USE> (primitive function in JavaScript)</INDEX>
	user<APOS/>s programs are the evaluator<APOS/>s data need not
	be a source of confusion.  In fact, it is sometimes convenient to ignore
	this distinction, and to give the user the ability to explicitly
	evaluate a string as a JavaScript expression, using JavaScript's
	primitive function <SCHEMEINLINE>eval</SCHEMEINLINE>
	that takes as argument a string. It parses the string
	and<EMDASH/>provided that it syntactically correct<EMDASH/>evaluates the
	resulting representation in the environment in which
	<SCHEMEINLINE>eval</SCHEMEINLINE> is applied. Thus,
	<SNIPPET>
	  <JAVASCRIPT>
eval("5 * 5;");
	  </JAVASCRIPT>
	</SNIPPET>
	and
	<SNIPPET>
	  <NAME>evaluate_example_4_1_5</NAME>
	  <REQUIRES>functions_4_1_1</REQUIRES>
	  <REQUIRES>functions_4_1_2</REQUIRES>
	  <REQUIRES>functions_4_1_3</REQUIRES>
	  <REQUIRES>functions_4_1_4</REQUIRES>
	  <EXPECTED>25</EXPECTED>
	  <JAVASCRIPT>
evaluate(parse("5 * 5;"), the_global_environment);
	  </JAVASCRIPT>
	</SNIPPET>
	will both return 25.<FOOTNOTE>Note that
	<JAVASCRIPTINLINE>eval</JAVASCRIPTINLINE>
	may not be available in the JavaScript environment that you are
	using, or its use may be restricted for security reasons.</FOOTNOTE>

	<INDEX>program<SUBINDEX><ORDER>data</ORDER>as data<CLOSE/></SUBINDEX></INDEX>
	<INDEX>data<SUBINDEX><ORDER>program</ORDER>as program<CLOSE/></SUBINDEX></INDEX>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>
	
  <EXERCISE>
    Given a one-argument
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>    
	<SCHEMEINLINE>p</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>f</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and an object <SCHEMEINLINE>a</SCHEMEINLINE>,
    <SPLITINLINE>
      <SCHEME>    
	<SCHEMEINLINE>p</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>f</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is said to <QUOTE>halt</QUOTE> on
    <SCHEMEINLINE>a</SCHEMEINLINE> if evaluating the expression
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(p a)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>f(a)</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    returns a value (as opposed to terminating with an error message or running
    forever).
    <INDEX>halting problem</INDEX>
    Show that it is impossible to write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    that correctly determines whether
    <SPLITINLINE>
      <SCHEME>    
	<SCHEMEINLINE>p</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>f</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    halts on
    <SCHEMEINLINE>a</SCHEMEINLINE> for any
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>    
	<SCHEMEINLINE>p</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>f</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and object <SCHEMEINLINE>a</SCHEMEINLINE>.
    Use the following reasoning: If you had such a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    you could implement the following program:
    <SNIPPET EVAL="no">
      <SCHEME>
(define (run-forever) (run-forever))

(define (try p)
   (if (halts? p p)
      (run-forever)
      'halted))
      </SCHEME>
      <JAVASCRIPT>
function run_forever() {
    return run_forever();      
}
function strange(f) {
    return halts(f, f) 
           ? run_forever();
           : "halted";
}
      </JAVASCRIPT>
    </SNIPPET>
    Now consider evaluating the expression
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(try try)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>strange(strange)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and show that any possible outcome (either halting or running forever)
    violates the intended behavior of
    <SPLITINLINE><SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.<FOOTNOTE>Although
    we stipulated that
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is given a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    object, notice that this reasoning still applies even if
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>halts?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>halts</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    can gain access to the
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s</SCHEME>
      <JAVASCRIPT>function<APOS/>s</JAVASCRIPT>
    </SPLITINLINE>
    text and its environment.
    <INDEX>Turing, Alan M.</INDEX>
    This is Turing<APOS/>s celebrated
    <INDEX>Halting Theorem</INDEX>
    <EM>Halting Theorem</EM>, which gave the
    first clear example of a
    <INDEX>noncomputable</INDEX><INDEX>computability</INDEX>
    <EM>noncomputable</EM> problem, i.e., a well-posed
    task that cannot be carried out as a computational
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE></FOOTNOTE>
    <LABEL NAME="ex:halting-theorem"/>
  </EXERCISE>

  <INDEX>metacircular evaluator for JavaScript<CLOSE/></INDEX>
</SUBSECTION>
