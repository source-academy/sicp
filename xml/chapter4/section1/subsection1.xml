<SUBSECTION>
  <NAME>
    The Core of the Evaluator
  </NAME>

  <TEXT>
    <LABEL NAME="sec:core-of-evaluator"/>

    <SPLIT>
      <SCHEME>
	<INDEX>metacircular evaluator for Scheme
	<SUBINDEX>eval@<SCHEMEINLINE>eval</SCHEMEINLINE> and 
	<SCHEMEINLINE>apply</SCHEMEINLINE>|(</SUBINDEX></INDEX>

	<FIGURE>
	  <FIGURE src="img_original/ch4-Z-G-1.svg"></FIGURE>
	  <LABEL NAME="fig:eval-apply_scheme"/>
	  <CAPTION>
	    The
	    <SCHEMEINLINE>eval</SCHEMEINLINE><ENDASH/><SCHEMEINLINE>apply</SCHEMEINLINE> 
	    cycle exposes the essence of a computer language.
	  </CAPTION>
	</FIGURE>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>metacircular evaluator for JavaScript
	<SUBINDEX>evaluate@<SCHEMEINLINE>evaluate</SCHEMEINLINE> and 
	<SCHEMEINLINE>apply</SCHEMEINLINE>|(</SUBINDEX></INDEX>
	<FIGURE>
	  <FIGURE src="img_javascript/ch4-Z-G-1.svg"></FIGURE>
	  <LABEL NAME="fig:eval-apply"/>
	  <CAPTION>
	    The
	    <SCHEMEINLINE>evaluate</SCHEMEINLINE><ENDASH/><SCHEMEINLINE>apply</SCHEMEINLINE> 
	    cycle exposes the essence of a computer language.
	  </CAPTION>
	</FIGURE>
      </JAVASCRIPT>
    </SPLIT>
    The evaluation process can be described as the interplay between two
    <SPLITINLINE>
      <SCHEME>procedures:</SCHEME>
      <JAVASCRIPT>functions:</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and <SCHEMEINLINE>apply</SCHEMEINLINE>.
  </TEXT>
  
  <SUBHEADING>
    <NAME><SPLITINLINE>
      <SCHEME>Eval</SCHEME>
      <JAVASCRIPT>The function 
      <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    <COMMENT>
      In JavaScript's strict mode<EMDASH/>our preferred way to run JavaScript
      programs<EMDASH/>the name <JAVASCRIPTINLINE>eval</JAVASCRIPTINLINE> cannot
      be declared in user programs. It is reserved for a related but quite
      different pre-declared function. We opt for the complete word
      <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE> as a replacement.
    </COMMENT>
  </TEXT>
  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    takes as arguments
    <SPLITINLINE>
      <JAVASCRIPT>
	a program <EM>component</EM><EMDASH/>a statement or
	expression<FOOTNOTE>There is no
	need to distinguish between statements and expressions in our evaluator.
	For example, we do not differentiate between expressions and
	expression statements; we represent them identically and consequently
	they are handled in the same way by the
	<JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
	function. Similarly, our evaluator does not enforce JavaScript's syntactic
	restriction that statements
	cannot appear inside expressions except in function bodies.
	As a result, 
	it would happily evaluate a program in which a return statement
	appears as argument of an application, although such a
	construct is not supported by the JavaScript syntax.</FOOTNOTE><EMDASH/>and an
	environment.
      </JAVASCRIPT>
      <SCHEME>
	and an environment.
      </SCHEME>
    </SPLITINLINE>
    It  classifies the 
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
      <JAVASCRIPT>component</JAVASCRIPT>
    </SPLITINLINE> 
    and directs its evaluation.  
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is structured as a case analysis of the syntactic type of the
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
      <JAVASCRIPT>component</JAVASCRIPT>
    </SPLITINLINE> 
    to be evaluated.  In order to keep the
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    general, we express
    the determination of the type of 
    <SPLITINLINE><SCHEME>an expression</SCHEME>
    <JAVASCRIPT>a component</JAVASCRIPT></SPLITINLINE>
    abstractly, making no
    commitment to any particular 
    <INDEX>metacircular evaluator for Scheme
    <SUBINDEX>expression representation</SUBINDEX></INDEX>
    representation for the various types of
    <SPLITINLINE><SCHEME>expressions.</SCHEME>
    <JAVASCRIPT>components.</JAVASCRIPT></SPLITINLINE>
    Each type of 
    <SPLITINLINE><SCHEME>expression</SCHEME>
    <JAVASCRIPT>component</JAVASCRIPT></SPLITINLINE>
    has a
    <SPLITINLINE>
      <SCHEME>predicate</SCHEME>
      <JAVASCRIPT><EM>syntax predicate</EM></JAVASCRIPT>
    </SPLITINLINE>
    that tests for it and an abstract means for selecting its parts.  This 
    <INDEX>metacircular evaluator for Scheme
    <SUBINDEX>data abstraction in</SUBINDEX></INDEX>
    <INDEX>abstract syntax<SUBINDEX>in metacircular evaluator</SUBINDEX></INDEX>
    <EM>abstract syntax</EM>
    makes it easy to see how we can change the syntax of the language by
    using the same evaluator, but with a different collection of syntax
    <SPLITINLINE>
      <SCHEME>
	procedures.
      </SCHEME>
      <JAVASCRIPT>
	functions.
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
	
	<SUBSUBHEADING>
	  <NAME>Primitive expressions</NAME>
	</SUBSUBHEADING>
	
	<UL>
	  <LI>
	    <SPLITINLINE>
	      <SCHEME>
		<INDEX>expression<SUBINDEX>self-evaluating</SUBINDEX></INDEX>
		<INDEX>self-evaluating expression</INDEX>
		For self-evaluating expressions, such as numbers,
		<SCHEMEINLINE>eval</SCHEMEINLINE>
		returns the expression itself.
	      </SCHEME>
	      <JAVASCRIPT>
		<INDEX>expression<SUBINDEX>literal</SUBINDEX></INDEX>
		<INDEX>literal expression</INDEX>
		For literal expressions, such as numbers,
		<JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
		returns their value.
	      </JAVASCRIPT>
	    </SPLITINLINE>
	  </LI>
	  <LI>
	    <SPLITINLINE>
	      <SCHEME><SCHEMEINLINE>Eval</SCHEMEINLINE></SCHEME>
	      <JAVASCRIPT>The function
	      <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT>
	    </SPLITINLINE>
	    must look up
	    <SPLITINLINE>
	      <SCHEME>variables</SCHEME>
	      <JAVASCRIPT>names</JAVASCRIPT>
	    </SPLITINLINE>
	    in the environment to find their values.
	  </LI>
	</UL>
      
	<SUBSUBHEADING>
	  <NAME>Special forms</NAME>
	</SUBSUBHEADING>
	
          <UL>
	    <LI>
	      For quoted expressions, 
	      <SCHEMEINLINE>eval</SCHEMEINLINE>
	      returns the expression that was
	      quoted.
	    </LI>
	    <LI>
	      An assignment to (or a definition of) a variable
	      must recursively call      
	      <SCHEMEINLINE>eval</SCHEMEINLINE>
	      to compute the new value to be associated with the variable.
	      The environment must be modified to change (or create) the
	      binding of the variable.
	    </LI>
	    <LI>
	      An if expression requires special processing of its parts, so as to
	      evaluate the consequent if the predicate is true, and otherwise to
	      evaluate the alternative.
	    </LI>
	    <LI>
	      A <SCHEMEINLINE>lambda</SCHEMEINLINE> expression
	      must be transformed into an applicable
	      procedure by packaging together the parameters and body
	      specified by the
	      <SCHEMEINLINE>lambda</SCHEMEINLINE>
	      expression with the environment of the evaluation.
	    </LI>
	    <LI>
	      A <SCHEMEINLINE>begin</SCHEMEINLINE> expression
	      requires evaluating its sequence of
	      expressions in the order in which they appear.
	    </LI>
	    <LI>
	      A case analysis (<SCHEMEINLINE>cond</SCHEMEINLINE>) is transformed
	      into a nest of <SCHEMEINLINE>if</SCHEMEINLINE>
	      expressions and then evaluated.
	    </LI>
          </UL>

      <SUBSUBHEADING>
	<NAME>Combinations</NAME>
      </SUBSUBHEADING>
      
      <UL>
	<LI>
	  For a procedure application, <SCHEMEINLINE>eval</SCHEMEINLINE>
	  must recursively evaluate the operator part and the operands of
	  the combination.  The resulting procedure
	  and arguments are passed to <SCHEMEINLINE>apply</SCHEMEINLINE>,
	  which handles the actual procedure application.
	</LI>
      </UL>
      <!-- \indcodeplus*{eval}{(metacircular)}-->
    Here is the definition of <SCHEMEINLINE>eval</SCHEMEINLINE>:
    <SNIPPET PAGE="365">
      <NAME>eval_scheme</NAME>
      <SCHEME>
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type - - EVAL" exp))))
      </SCHEME>
    </SNIPPET>
	  
      </SCHEME>

      <JAVASCRIPT>

	<SUBSUBHEADING>
	  <NAME>Primitive expressions</NAME>
	</SUBSUBHEADING>
	
	<UL>
	  <LI>
	    <INDEX>expression<SUBINDEX>literal</SUBINDEX></INDEX>
	    <INDEX>literal expression</INDEX>
	    For literal expressions, such as numbers,
	    <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
	    returns their value.
	  </LI>
	  <LI>
	    The function
	    <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
	    must look up names in the environment to find their values.
	  </LI>
	</UL>
	

	<SUBSUBHEADING>
	  <NAME>Combinations</NAME>
	</SUBSUBHEADING>
      
        <UL>
	  <LI>
	    For a function application,
	    <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE> must recursively
	    evaluate the function expression and the argument expressions of the
	    application.  The resulting function and arguments are passed to
	    <SCHEMEINLINE>apply</SCHEMEINLINE>, which handles the actual
	    function application.
	  </LI>
	  <LI>
	    An operator combination is transformed into a function application
	    and then evaluated.
	  </LI>
        </UL>

	<SUBSUBHEADING>	
	  <NAME>Syntactic forms</NAME>
	</SUBSUBHEADING>
	
        <UL>
	  <LI>
	    A conditional expression or statement requires special processing of
	    its parts,
	    so as to evaluate the consequent if the predicate is true, and
	    otherwise to evaluate the alternative.
	  </LI>
	  <LI>
	    A lambda expression must be transformed into an applicable
	    function by packaging together the parameters and body specified
	    by the lambda expression with the environment of the evaluation.
	  </LI>
	  <LI>
	    A sequence of statements requires evaluating its
	    components in the order in which they appear.
	  </LI>
	  <LI>
	    A block requires evaluating its body in a new environment
	    that reflects all names declared within the block.
	  </LI>
	  <LI>
	    A return statement must produce a value that becomes the
	    result of the function call that gave rise to the
	    evaluation of the return statement.
	  </LI>
	  <LI>
	    A function declaration is transformed into a
	    constant declaration and then evaluated.
	  </LI>
	  <LI>
	    A constant or variable declaration or an assignment must
	    recursively call
	    <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE> to compute the new
	    value to be associated with the name being declared or assigned.
	    The environment must be
	    modified to reflect the new value of the name.
	  </LI>
        </UL>
	<!-- \indcodeplus*{eval}{(metacircular)}-->
	Here is the definition of
	<SPLITINLINE><SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE>:</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>:
	</JAVASCRIPT>
	</SPLITINLINE>
	<SNIPPET PAGE="365" HIDE="yes">
	  <NAME>headline_4_1_1</NAME>
	  <JAVASCRIPT>
// functions from SICP JS 4.1.1
	  </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET PAGE="365">
	  <NAME>eval</NAME>
	  <EXAMPLE>eval_example</EXAMPLE>
	  <EXPECTED>3</EXPECTED>
	  <JAVASCRIPT>
function evaluate(component, env) {
   return is_literal(component)
          ? literal_value(component)
          : is_name(component)
          ? lookup_symbol_value(symbol_of_name(component), env)
          : is_application(component)
          ? apply(evaluate(function_expression(component), env),
                  list_of_values(arg_expressions(component), env))
          : is_operator_combination(component)
          ? evaluate(operator_combination_to_application(component), env)
          : is_conditional(component)
          ? eval_conditional(component, env)
          : is_lambda_expression(component)
          ? make_function(lambda_parameter_symbols(component),
                          lambda_body(component), env)
          : is_sequence(component)
          ? eval_sequence(sequence_statements(component), env)
          : is_block(component)
          ? eval_block(component, env)
          : is_return_statement(component)
          ? eval_return_statement(component, env)
          : is_assignment(component)
          ? eval_assignment(component, env)
          : is_function_declaration(component)	    
          ? evaluate(function_decl_to_constant_decl(component), env)
          : is_declaration(component)
          ? eval_declaration(component, env)
          : error(component, "Unknown syntax -- evaluate");
}
	  </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET PAGE="365" HIDE="yes">
	  <NAME>eval_example</NAME>
	  <REQUIRES>functions_4_1_1</REQUIRES>
	  <REQUIRES>functions_4_1_2</REQUIRES>
	  <REQUIRES>functions_4_1_3</REQUIRES>
	  <REQUIRES>functions_4_1_4</REQUIRES>
	  <JAVASCRIPT>
const my_program = parse("1; { true; 3; }");
evaluate(my_program, the_empty_environment);
	  </JAVASCRIPT>
	</SNIPPET>
	
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    <INDEX>data-directed programming
    <SUBINDEX>case analysis vs.</SUBINDEX></INDEX>
    <INDEX>case analysis
    <SUBINDEX>data-directed programming vs.</SUBINDEX></INDEX>
    For clarity, 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    has been implemented as a case analysis using
    <SPLITINLINE><SCHEME><SCHEMEINLINE>cond</SCHEMEINLINE>.</SCHEME>
    <JAVASCRIPT>conditional expressions.</JAVASCRIPT></SPLITINLINE>
    The disadvantage of this is that our
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    handles only a few distinguishable types of 
    <SPLITINLINE>
      <JAVASCRIPT>statements and</JAVASCRIPT>
    </SPLITINLINE>
    expressions, and no new ones can be defined without editing the
    <SPLITINLINE>
      <SCHEME>
	definition of 
	<SCHEMEINLINE>eval</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	declaration of
	<JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    In most
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>interpreter</JAVASCRIPT>
    </SPLITINLINE>
    implementations, dispatching on the type of
    <SPLITINLINE>
      <SCHEME>an expression</SCHEME>
      <JAVASCRIPT>a component</JAVASCRIPT>
    </SPLITINLINE>
    is done in a data-directed style.  This allows a user to add new types of    
    <SPLITINLINE>
      <SCHEME>expressions that <SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>components that
      <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    can distinguish, without modifying the 
    <SPLITINLINE>
      <SCHEME>
	definition of <SCHEMEINLINE>eval</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	declaration of
	<JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    itself. (See exercise<SPACE/><REF NAME="ex:data-directed-eval"/>.)
  </TEXT>

  <SUBHEADING>
    <NAME>Apply</NAME>
  </SUBHEADING>

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Apply</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>apply</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    takes two arguments, a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    and a list of arguments  to which the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    should be applied.  
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Apply</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>apply</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    classifies
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    into two kinds: It calls 
    <!--  \indcode{apply-primitive-procedure} -->
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>apply-primitive-procedure</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>apply_primitive_function</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to apply primitives; it applies compound
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	by sequentially evaluating the 	
	expressions that make up the body of the procedure.
      </SCHEME>
      <JAVASCRIPT>
	by evaluating the block that makes up the body
	of the function.
      </JAVASCRIPT>
    </SPLITINLINE>
    The environment for the evaluation of the body of a compound
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is constructed by extending the base environment carried by the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to include a frame that binds the parameters of the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to the arguments to which the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is to be applied. 
    Here is the definition of <SCHEMEINLINE>apply</SCHEMEINLINE>:
    <SNIPPET PAGE="366">
      <NAME>apply</NAME>
      <EXAMPLE>apply_example</EXAMPLE>
      <EXPECTED>3</EXPECTED>
      <SCHEME>
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type - - APPLY" procedure))))
      </SCHEME>
      <JAVASCRIPT>
function apply(fun, args) {
   if (is_primitive_function(fun)) {
      return apply_primitive_function(fun, args);
   } else if (is_compound_function(fun)) {
      const result = evaluate(function_body(fun),
                              extend_environment(
                                  function_parameters(fun),
                                  args,
                                  function_environment(fun)));
      return is_return_value(result)
             ? return_value_content(result)
             : undefined;
   } else {
      error(fun, "Unknown function type -- apply");
   }
}
      </JAVASCRIPT>
    </SNIPPET>
    <COMMENT>
      The name <JAVASCRIPTINLINE>arguments</JAVASCRIPTINLINE>
      is reserved in JavaScript's strict mode. We chose
      <JAVASCRIPTINLINE>args</JAVASCRIPTINLINE> instead.
    </COMMENT>
    <SNIPPET PAGE="366" HIDE="yes">
      <NAME>apply_example</NAME>
      <REQUIRES>functions_4_1_1</REQUIRES>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_3</REQUIRES>
      <REQUIRES>functions_4_1_4</REQUIRES>
      <JAVASCRIPT>
const plus = list("primitive", (x, y) => x + y);
apply(plus, list(1, 2));
      </JAVASCRIPT>
    </SNIPPET>
    
    <SPLIT>
      <JAVASCRIPT>
	In order to return a value, a JavaScript function needs to evaluate a
	return statement. If a function terminates without evaluating a return
	statement, the value 
	<JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> is returned.
	To distinguish the two cases, the evaluation of a return statement
	will wrap the result of evaluating its return expression into a
	<EM>return value</EM>. If
	the evaluation of the function body yields such a return value, the content
	of the return value is retrieved; otherwise the value
	<JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> is returned.
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <SUBHEADING>
    <NAME>
    <SPLITINLINE>
      <SCHEME>Procedure</SCHEME>
      <JAVASCRIPT>Function</JAVASCRIPT>
    </SPLITINLINE>
      arguments
    </NAME>
  </SUBHEADING>

  <TEXT>
    When
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><SCHEMEINLINE>evaluate</SCHEMEINLINE></JAVASCRIPT>
    </SPLITINLINE>
    processes a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application, it uses
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>list-of-values</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to produce the list of arguments to which the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is to be applied.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>List-of-values</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function
      <JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    takes as an argument the
    <SPLITINLINE>
      <SCHEME>operands of the combination.</SCHEME>
      <JAVASCRIPT>argument expressions of the application.</JAVASCRIPT>
    </SPLITINLINE>
    It evaluates each
    <SPLITINLINE>
      <SCHEME>operand</SCHEME>
      <JAVASCRIPT>argument expression</JAVASCRIPT>
    </SPLITINLINE>
    and returns a
    list of the corresponding values:<SPLITINLINE><SCHEME><FOOTNOTE>We could
    have simplified the 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>application?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>is_application</JAVASCRIPTINLINE> function
      </JAVASCRIPT>
    </SPLITINLINE>
    clause in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><SCHEMEINLINE>evaluate</SCHEMEINLINE></JAVASCRIPT>
    </SPLITINLINE>
    by using
    <SCHEMEINLINE>map</SCHEMEINLINE> (and stipulating that
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>operands</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><SCHEMEINLINE>args</SCHEMEINLINE></JAVASCRIPT>
    </SPLITINLINE>
    returns a list) rather than writing
    an explicit
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>list-of-values</SCHEMEINLINE> procedure.</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE>
      function.
      </JAVASCRIPT>
    </SPLITINLINE>
    We chose not to use <SCHEMEINLINE>map</SCHEMEINLINE> here to emphasize the
    fact that the
    <INDEX>metacircular evaluator for Scheme<SUBINDEX>higher-order
    <SPLITINLINE><SCHEME>procedures</SCHEME>
    <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE> in </SUBINDEX></INDEX>
    <INDEX>higher-order <SPLITINLINE><SCHEME>procedures</SCHEME>
    <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    <SUBINDEX>in metacircular evaluator</SUBINDEX></INDEX>
    evaluator can be implemented without any use of higher-order
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    (and thus could be written in a language that doesn<APOS/>t
    have higher-order
    <SPLITINLINE>
      <SCHEME>procedures),</SCHEME>
      <JAVASCRIPT>functions),</JAVASCRIPT>
    </SPLITINLINE>
    even though the language that it supports
    will include higher-order
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    <LABEL NAME="foot:mceval-higher-order-scheme"/></FOOTNOTE></SCHEME><JAVASCRIPT><FOOTNOTE>We chose to implement <JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE>
    using the higher-order
    function <JAVASCRIPTINLINE>map</JAVASCRIPTINLINE>, and will use
    <JAVASCRIPTINLINE>map</JAVASCRIPTINLINE> in other places as well.
    However, the evaluator can be implemented without any use of higher-order
    functions (and thus could be written in a language that doesn t have
    higher-order functions), even though the language that it supports
    will include higher-order functions.  For example,
    <JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE> can be
    written without map as follows:
    <SNIPPET PAGE="367">
      <NAME>list_of_values_without_map</NAME>
      <EXAMPLE>list_of_values_example</EXAMPLE>
      <JAVASCRIPT>
function list_of_values(exps, env) {
    return is_null(exps)	
           ? null
           : pair(evaluate(head(exps), env), 
                  list_of_values(tail(exps), env));
}
      </JAVASCRIPT>
    </SNIPPET>
    <LABEL NAME="foot:mceval-higher-order"/></FOOTNOTE></JAVASCRIPT></SPLITINLINE>
    <SNIPPET PAGE="367">
      <NAME>list_of_values</NAME>
      <EXAMPLE>list_of_values_example</EXAMPLE>
      <SCHEME>
(define (list-of-values exps env)
  (if (no-operands? exps)
      \&apos;()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
      </SCHEME>
      <JAVASCRIPT>
function list_of_values(exps, env) {
     return map(arg => evaluate(arg, env), exps);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="365" HIDE="yes">
      <NAME>list_of_values_example</NAME>
      <REQUIRES>functions_4_1_1</REQUIRES>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_3</REQUIRES>
      <REQUIRES>functions_4_1_4</REQUIRES>
      <SCHEME>
(define the-global-environment (setup-environment))
(eval (read) the-global-environment)
      </SCHEME>
      <JAVASCRIPT>
const my_addition_expression = parse("1 + 2;");
list_of_values(list(parse("1;"), my_addition_expression, parse("7;")),
               the_global_environment);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>
      Conditionals
    </NAME>
  </SUBHEADING>

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Eval-if</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function
      <JAVASCRIPTINLINE>eval_conditional</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    evaluates the predicate part of 
    <SPLITINLINE>
      <SCHEME>an <SCHEMEINLINE>if</SCHEMEINLINE> expression</SCHEME>
      <JAVASCRIPT>a conditional component</JAVASCRIPT>
    </SPLITINLINE>
    in the given environment.  If the result is true, 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-if</SCHEMEINLINE>
      evaluates the consequent, otherwise it evaluates the alternative:
      </SCHEME>
      <JAVASCRIPT>
	the consequent is evaluated, otherwise the alternative is evaluated:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET PAGE="367">
      <NAME>eval_if</NAME>
      <EXAMPLE>eval_if_example</EXAMPLE>
      <EXPECTED>1</EXPECTED>
      <SCHEME>
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
      </SCHEME>
      <JAVASCRIPT>
function eval_conditional(component, env) {
    return is_truthy(evaluate(conditional_predicate(component), env))
           ? evaluate(conditional_consequent(component), env)
           : evaluate(conditional_alternative(component), env);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="367" HIDE="yes">
      <NAME>eval_if_example</NAME>
      <REQUIRES>functions_4_1_1</REQUIRES>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_3</REQUIRES>
      <REQUIRES>functions_4_1_4</REQUIRES>
      <JAVASCRIPT>
const my_cond_expr = parse("true ? 1 : 2;");
eval_conditional(my_cond_expr, the_empty_environment);
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <JAVASCRIPT>
	Note that the evaluator does not need to distinguish between
	conditional expressions and conditional statements.
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    <INDEX>metacircular evaluator for Scheme
    <SUBINDEX>implemented language vs.<SPACE/>implementation language
    </SUBINDEX></INDEX>
    The use of 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>true?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_truthy</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-if</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>eval_conditional</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    highlights the issue of the connection between an implemented language and
    an implementation language.  The 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>if-predicate</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>conditional_predicate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is evaluated in the language being implemented and thus yields a value in
    that language.  The interpreter predicate 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>true?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_truthy</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE> 
    translates that value into a value that can be tested by the
    <SPLITINLINE><SCHEME><SCHEMEINLINE>if</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT>conditional expression</JAVASCRIPT></SPLITINLINE>
    in the implementation language: The metacircular representation of truth
    might not be the same as that of the underlying 
    <SPLITINLINE><SCHEME>Scheme</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE>.<FOOTNOTE>In this case, the language being implemented and the
    implementation language are the same. Contemplation of the meaning of
    <INDEX>consciousness, expansion of</INDEX>
    <SPLITINLINE><SCHEME><SCHEMEINLINE>true?</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>is_truthy</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    here yields expansion of consciousness without the abuse of
    substance.</FOOTNOTE>
  </TEXT>

  <SUBHEADING>
    <NAME>    
	Sequences
    </NAME>
  </SUBHEADING>

  <SPLIT>
    <SCHEME>
      <TEXT>
	<SCHEMEINLINE>Eval-sequence</SCHEMEINLINE> is used by
	<SCHEMEINLINE>apply</SCHEMEINLINE> to evaluate the sequence of
	expressions in a procedure body and by <SCHEMEINLINE>eval</SCHEMEINLINE>
	to evaluate the sequence of expressions in a
	<SCHEMEINLINE>begin</SCHEMEINLINE> expression.  It takes as arguments a
	sequence of expressions and an environment, and evaluates the
	expressions in the order in which they occur.  The value returned is the
	value of the final expression.
	<SNIPPET PAGE="367">
          <NAME>eval_sequence</NAME>
          <SCHEME>
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
          </SCHEME>
	</SNIPPET>
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <TEXT>
	The function <JAVASCRIPTINLINE>eval_sequence</JAVASCRIPTINLINE>
	is used by <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
	to evaluate a sequence of statements at the top level, or in a block.
	It takes as arguments a sequence of statements and an
	environment, and evaluates the statements in the order in which they
	occur. The value returned is the value of the final statement, except
	that if the result of evaluating any statement in the sequence yields
	a return value, that value is returned and the subsequent statements are
	ignored.<FOOTNOTE>The treatment of return statements in
	<JAVASCRIPTINLINE>eval_sequence</JAVASCRIPTINLINE>
	reflects the proper
	result of evaluating function applications in JavaScript, but the
	evaluator presented here does not comply with the ECMAScript
	specification for the value of programs that consist
	of sequences of statements outside of any function body. 
	Exercise<SPACE/><REF NAME="ex:value_producing"/> addresses this issue.
	<LABEL NAME="foot:value_producing"/>
      </FOOTNOTE>
	<SNIPPET PAGE="367">
	  <NAME>eval_sequence</NAME>
	  <EXAMPLE>eval_sequence_example</EXAMPLE>
	  <EXPECTED>3</EXPECTED>
          <JAVASCRIPT>
function eval_sequence(stmts, env) {
    if (is_empty_sequence(stmts)) {
        return undefined;
    } else if (is_last_statement(stmts)) {
        return evaluate(first_statement(stmts),env);
    } else {
        const first_stmt_value = 
            evaluate(first_statement(stmts),env);
        if (is_return_value(first_stmt_value)) {
            return first_stmt_value;
        } else {
            return eval_sequence(
                rest_statements(stmts),env);
        }
    }
}	
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET PAGE="367" HIDE="yes">
	  <NAME>eval_sequence_example</NAME>
	  <REQUIRES>functions_4_1_1</REQUIRES>
	  <REQUIRES>functions_4_1_2</REQUIRES>
	  <REQUIRES>functions_4_1_3</REQUIRES>
	  <REQUIRES>functions_4_1_4</REQUIRES>
	  <JAVASCRIPT>
const my_sequence = head(tail(parse("1; true; 3;")));
eval_sequence(my_sequence, the_empty_environment);
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>

  <SPLIT>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
      <SUBHEADING>
	<NAME>Blocks</NAME>
      </SUBHEADING>
      <TEXT>
	The function <JAVASCRIPTINLINE>eval_block</JAVASCRIPTINLINE> handles
	blocks. The variables and constants (including functions)
	declared in the block have the whole block as their scope and thus
	are <QUOTE>scanned out</QUOTE> before the body of the block is
	evaluated.
	The body of the	block is evaluated with respect to an environment
	that extends the current
	environment with a binding of these local names
	to a special value
	<JAVASCRIPTINLINE>"*unassigned*"</JAVASCRIPTINLINE>.
	This string serves as a placeholder in the environment, before
	the evaluation of the respective declaration assigns the name to
	its proper value.
	<SNIPPET PAGE="367">
          <NAME>eval_block</NAME>
          <REQUIRES>list_of_unassigned</REQUIRES>
          <REQUIRES>scan_out_declarations</REQUIRES>
	  <EXAMPLE>eval_block_example</EXAMPLE>
	  <EXPECTED>42</EXPECTED>
          <JAVASCRIPT>
function eval_block(component, env) {
    const body = block_body(component);
    const locals = scan_out_declarations(body);
    const unassigneds = list_of_unassigned(locals);
    return evaluate(body, extend_environment(locals,
                                             unassigneds, 
                                             env));
}
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET PAGE="367">
          <NAME>list_of_unassigned</NAME>
          <JAVASCRIPT>
function list_of_unassigned(names) {
    return map(name => "*unassigned*", names);
}
	  </JAVASCRIPT>
	</SNIPPET>
	The function <JAVASCRIPTINLINE>scan_out_declarations</JAVASCRIPTINLINE>
	collects a list of all names declared in the body. 
	<SNIPPET>
          <NAME>scan_out_declarations</NAME>
	  <EXAMPLE>scan_out_declarations_example</EXAMPLE>
	  <EXPECTED>[ 'x', [ 'y', null ] ]</EXPECTED>
          <JAVASCRIPT>
function scan_out_declarations(component) {
    if (is_sequence(component)) {
        const stmts = sequence_statements(component);
        return is_empty_sequence(stmts)
               ? null
               : append(scan_out_declarations(first_statement(stmts)),
                        scan_out_declarations(
                            make_sequence(rest_statements(stmts))));
    } else {
        return is_declaration(component)
            ? list(declaration_symbol(component))
            : null;
    }
}
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET HIDE="yes">
          <NAME>scan_out_declarations_example</NAME>
	  <REQUIRES>functions_4_1_1</REQUIRES>
	  <REQUIRES>functions_4_1_2</REQUIRES>
	  <REQUIRES>functions_4_1_3</REQUIRES>
	  <REQUIRES>functions_4_1_4</REQUIRES>
          <JAVASCRIPT>
scan_out_declarations(parse("const x = 1; let y = 2;"));
	  </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET PAGE="367" HIDE="yes">
          <NAME>eval_block_example</NAME>
	  <REQUIRES>functions_4_1_1</REQUIRES>
	  <REQUIRES>functions_4_1_2</REQUIRES>
	  <REQUIRES>functions_4_1_3</REQUIRES>
	  <REQUIRES>functions_4_1_4</REQUIRES>
          <JAVASCRIPT>
const my_block = parse("{ const x = 1; 3; 42; }");
eval_block(my_block, the_empty_environment);
	  </JAVASCRIPT>
	</SNIPPET>
	We ignore declarations that are nested in another block,
	because the evaluation of that block will take care of them.
	The function <JAVASCRIPTINLINE>scan_out_declarations</JAVASCRIPTINLINE>	
	looks for declarations only in sequences because 
	declarations in conditional statements, function declarations, or
	lambda expressions are always nested in another block.
      </TEXT>

      <SUBHEADING>
	<NAME>Return statements</NAME>
      </SUBHEADING>

      <TEXT>
	The function <JAVASCRIPTINLINE>eval_return_statement</JAVASCRIPTINLINE>
	is used to evaluate return statements. As seen in
	<JAVASCRIPTINLINE>apply</JAVASCRIPTINLINE> and
	the evaluation
	of sequences, the result of evaluation of a return statement
	needs to be identifiable so that the evaluation of a function
	body can return immediately, even if there are statements
	after the return statement. For this purpose,
	the evaluation of a return statement wraps the result of
	evaluating the return expression in a return value object.
	<SNIPPET PAGE="367">
          <NAME>eval_return</NAME>
	  <EXAMPLE>eval_return_example</EXAMPLE>
	  <EXPECTED>1</EXPECTED>
          <JAVASCRIPT>
function eval_return_statement(component, env) {
    return make_return_value(
               evaluate(return_expression(component), env));
}
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET PAGE="367" HIDE="yes">
          <NAME>eval_return_example</NAME>
	  <REQUIRES>functions_4_1_1</REQUIRES>
	  <REQUIRES>functions_4_1_2</REQUIRES>
	  <REQUIRES>functions_4_1_3</REQUIRES>
	  <REQUIRES>functions_4_1_4</REQUIRES>
          <JAVASCRIPT>
const my_program = parse("{ function f() { return 1; } f(); }");
evaluate(my_program, the_global_environment);
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>

  <SUBHEADING>
    <NAME>Assignments and
    <SPLITINLINE>
      <SCHEME>definitions</SCHEME>
      <JAVASCRIPT>declarations</JAVASCRIPT>
    </SPLITINLINE></NAME>
  </SUBHEADING>

  <TEXT>
    The 
    <SPLITINLINE>
      <SCHEME>following procedure</SCHEME>
      <JAVASCRIPT>
	function <JAVASCRIPTINLINE>eval_assignment</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    handles assignments to
    <SPLITINLINE>
      <SCHEME>variables.</SCHEME>
      <JAVASCRIPT>
	names.
	(To simplify the	presentation of our evaluator,
	we allow assignment not just to variables but
	also<EMDASH/>erroneously<EMDASH/>to constants.
	Exercise<SPACE/><REF NAME="ex:mutable"/>
	explains how we could
	distinguish constants from variables and prevent
	assignment to constants.)
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	It calls
	<SCHEMEINLINE>eval</SCHEMEINLINE>
	to find the value to be assigned and transmits the variable
	and the resulting value to
	<SCHEMEINLINE>set-variable-value!</SCHEMEINLINE>
	to be installed  in the designated environment.
      </SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>eval_assignment</JAVASCRIPTINLINE>
	calls
	<SCHEMEINLINE>evaluate</SCHEMEINLINE>
	on the value expression
	to find the value to be assigned and calls
	<JAVASCRIPTINLINE>assignment_symbol</JAVASCRIPTINLINE>
	to retrieve the symbol that represents the name
	from the assignment statement. The function
	<JAVASCRIPTINLINE>eval_assignment</JAVASCRIPTINLINE>	
	transmits the symbol and the value to
	<JAVASCRIPTINLINE>assign_symbol_value</JAVASCRIPTINLINE>
	to be installed in the designated environment.
	The evaluation of an assignment returns the value 
	that was assigned.
      </JAVASCRIPT>
    </SPLITINLINE>    
    <SNIPPET PAGE="368">
      <NAME>eval_assignment</NAME>
      <EXAMPLE>eval_assignment_example</EXAMPLE>
      <EXPECTED>2</EXPECTED>
      <SCHEME>
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  \&apos;ok)
      </SCHEME>
      <JAVASCRIPT>
function eval_assignment(component, env) {
    const value = evaluate(assignment_value_expression(component), env);
    assign_symbol_value(assignment_symbol(component), value, env);
    return value;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="368" HIDE="yes">
      <NAME>eval_assignment_example</NAME>
      <REQUIRES>functions_4_1_1</REQUIRES>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_3</REQUIRES>
      <REQUIRES>functions_4_1_4</REQUIRES>
      <JAVASCRIPT>
const my_program = parse("{ let x = 1; x = 2; }");
evaluate(my_program, the_global_environment);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SPLIT>
    <SCHEME>
      <TEXT>
	Definitions of variables are handled in a similar manner.<FOOTNOTE>This
	implementation of <SCHEMEINLINE>define</SCHEMEINLINE> ignores a subtle
	issue in the handling of internal definitions, although it works
	correctly in most cases.  We will see what the problem is and how to
	solve it in
	section<SPACE/><REF NAME="sec:internal-definitions"/>.</FOOTNOTE>
	<SNIPPET PAGE="368">
	  <NAME>eval_definition</NAME>
	  <REQUIRES>define_variable</REQUIRES>
	  <REQUIRES>definition</REQUIRES>
	  <REQUIRES>eval</REQUIRES>
	  <SCHEME>
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  \&apos;ok)
	  </SCHEME>
	</SNIPPET>
      </TEXT>

      <TEXT>
	We have chosen here to return the symbol <SCHEMEINLINE>ok</SCHEMEINLINE>
	as the value of an assignment or a definition.<FOOTNOTE>As we said when
	we introduced <SCHEMEINLINE>define</SCHEMEINLINE> and 
        <SCHEMEINLINE>set!</SCHEMEINLINE>, these values
        are implementation-dependent in Scheme<EMDASH/>that is, the implementor
        can choose what value to return.</FOOTNOTE>
	<INDEX>metacircular evaluator for Scheme
	<SUBINDEX>eval@<SCHEMEINLINE>eval</SCHEMEINLINE> and
	<SCHEMEINLINE>apply</SCHEMEINLINE>|)</SUBINDEX></INDEX>
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <TEXT>
	Constant and variable declarations are treated
	in a manner similar to
	assignments; they replace the current value of the name in the
	environment with the result of evaluating the value expression.
	<SNIPPET PAGE="368">
	  <NAME>eval_definition</NAME>
	  <EXAMPLE>eval_definition_example</EXAMPLE>
	  <EXPECTED>3</EXPECTED>
	  <JAVASCRIPT>
function eval_declaration(component, env) {
    assign_symbol_value(declaration_symbol(component), 
                        evaluate(declaration_value_expression(component),
                                 env),
                        env);
    return undefined;
}
	  </JAVASCRIPT>
	</SNIPPET>
	The result of evaluating the body of functions is determined by
	return statements. The result of evaluating programs is determined
	by its top level components, outside of any function body.
	Exercise<SPACE/><REF NAME="ex:value_producing"/> describes in 
	detail what is considered the value of top level components. To
	simplify the presentation, we state in
	<JAVASCRIPTINLINE>eval_declaration</JAVASCRIPTINLINE>
	that declarations produce
	<JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>, while we
	stated in
	<JAVASCRIPTINLINE>eval_assignment</JAVASCRIPTINLINE> that
	assignments produce the result of evaluating the
	value expression.

	<LABEL NAME="foot:value_producing_2"/>	

	<SNIPPET PAGE="368" HIDE="yes">
	  <NAME>eval_definition_example</NAME>
	  <REQUIRES>functions_4_1_1</REQUIRES>
	  <REQUIRES>functions_4_1_2</REQUIRES>
	  <REQUIRES>functions_4_1_3</REQUIRES>
	  <REQUIRES>functions_4_1_4</REQUIRES>
	  <JAVASCRIPT>
const my_program = parse("{ let x = 1; const y = 2; x + y; }");
evaluate(my_program, the_global_environment);
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
      <TEXT>
	<INDEX>metacircular evaluator for Scheme
	<SUBINDEX>eval@<SCHEMEINLINE>eval</SCHEMEINLINE> and
	<SCHEMEINLINE>apply</SCHEMEINLINE>|)</SUBINDEX></INDEX>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>
  <SNIPPET PAGE="383" HIDE="yes">
    <NAME>functions_4_1_1</NAME>
    <REQUIRES>headline_4_1_1</REQUIRES>
    <REQUIRES>eval</REQUIRES>
    <REQUIRES>apply</REQUIRES>
    <REQUIRES>list_of_values</REQUIRES>
    <REQUIRES>eval_if</REQUIRES>
    <REQUIRES>eval_sequence</REQUIRES>
    <REQUIRES>eval_block</REQUIRES>
    <REQUIRES>eval_return</REQUIRES>
    <REQUIRES>eval_assignment</REQUIRES>
    <REQUIRES>eval_definition</REQUIRES>
    <JAVASCRIPT></JAVASCRIPT>
  </SNIPPET>

  <SPLIT>
    <SCHEME>
      <EXERCISE>
	<INDEX>order of evaluation
	<SUBINDEX>metacircular@in metacircular evaluator</SUBINDEX></INDEX>
	<INDEX>metacircular evaluator for Scheme
	<SUBINDEX>order of operand evaluation</SUBINDEX></INDEX>
	Notice that we cannot tell whether the metacircular evaluator
	evaluates operands from left to right or from right to left.  Its
	evaluation order is inherited from the underlying Lisp:	If the
	arguments to <SCHEMEINLINE>cons</SCHEMEINLINE> in
	<SCHEMEINLINE>list-of-values</SCHEMEINLINE> are evaluated from left to
	right, then <SCHEMEINLINE>list-of-values</SCHEMEINLINE>	will evaluate
	operands from left to right; and if the arguments to
	<SCHEMEINLINE>cons</SCHEMEINLINE> are evaluated from right to left, then
	<SCHEMEINLINE>list-of-values</SCHEMEINLINE> will evaluate operands
	from right to left.
	<P/>
	Write a version of <SCHEMEINLINE>list-of-values</SCHEMEINLINE> that
	evaluates <SCHEME>operands</SCHEME> from left to right regardless of the
	order of evaluation in the underlying Lisp. Also write a version of
	<SCHEMEINLINE>list-of-values</SCHEMEINLINE> that evaluates
	operands from right to left.
	<LABEL NAME="ex:arg-eval-order_scheme"/>
      </EXERCISE>
    </SCHEME>
    <JAVASCRIPT>
      <EXERCISE>
	<INDEX>order of evaluation
	<SUBINDEX>metacircular@in metacircular evaluator</SUBINDEX></INDEX>
	<INDEX>metacircular evaluator for JavaScript
	<SUBINDEX>order of argument evaluation</SUBINDEX></INDEX>
	Notice that we cannot tell whether the metacircular evaluator
	evaluates argument expressions from left to right or from right to left.
	Its evaluation order is inherited from the underlying JavaScript:
	If the arguments to <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE> in
	<JAVASCRIPTINLINE>map</JAVASCRIPTINLINE> are evaluated from
	left to	right, then <JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE>
	will evaluate argument expressions from left to right; and if the
	argument expressions to <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE> are
	evaluated from right to left, then
	<JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE> will evaluate
	argument expressions from right to left.
	<P/>
	Write a version of <JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE>
	that evaluates argument expressions from left to right regardless of the
	order of evaluation in the underlying JavaScript. Also write a version of
	<JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE> that evaluates
	argument expressions from right to left.
	<LABEL NAME="ex:arg-eval-order"/>
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>

  <!-- test cases -->
  
  <SNIPPET HIDE="yes">
    <NAME>parse_and_evaluate</NAME>
    <REQUIRES>functions_4_1_1</REQUIRES>
    <REQUIRES>functions_4_1_2</REQUIRES>
    <REQUIRES>functions_4_1_3</REQUIRES>
    <REQUIRES>functions_4_1_4</REQUIRES>
    <JAVASCRIPT>
function parse_and_evaluate(input) {
    const program = parse(input);
    const locals = scan_out_declarations(program);
    const unassigneds = list_of_unassigned(locals);
    const program_env = extend_environment(locals, unassigneds,
                                       the_global_environment);
    return evaluate(program, program_env);
}
    </JAVASCRIPT>
  </SNIPPET>

  <SNIPPET HIDE="yes">
    <NAME>parse_and_evaluate_test_factorial</NAME>
    <REQUIRES>parse_and_evaluate</REQUIRES>
    <EXPECTED>120</EXPECTED>
    <JAVASCRIPT>
parse_and_evaluate("               \
function factorial(n) {            \
    return n === 1                 \
           ? 1                     \
           : n * factorial(n - 1); \
}                                  \
factorial(5);                      ");
    </JAVASCRIPT>
  </SNIPPET>
  <SNIPPET HIDE="yes">
    <NAME>parse_and_evaluate_test_append</NAME>
    <REQUIRES>parse_and_evaluate</REQUIRES>
    <EXPECTED>[ 'b', [ 'c', [ 'd', null ] ] ]</EXPECTED>
    <JAVASCRIPT>
parse_and_evaluate("                                \
function append(xs, ys) {                           \
    return is_null(xs)                              \
           ? ys                                     \
           : pair(head(xs), append(tail(xs), ys));  \
}                                                   \
tail(append(list('a', 'b'), list('c', 'd')));       ");
    </JAVASCRIPT>
  </SNIPPET>
  <SNIPPET HIDE="yes">
    <NAME>parse_and_evaluate_test_map</NAME>
    <REQUIRES>parse_and_evaluate</REQUIRES>
    <EXPECTED>[ 3, [ 4, [ 5, null ] ] ]</EXPECTED>
    <JAVASCRIPT>
parse_and_evaluate("                              \
function map(f, xs) {                             \
    return is_null(xs)                            \
           ? null                                 \
           : pair(f(head(xs)), map(f, tail(xs))); \
}                                                 \
tail(map(x => x + 1, list(1, 2, 3, 4)));          ");
    </JAVASCRIPT>
  </SNIPPET>
</SUBSECTION>

