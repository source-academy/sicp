[{"id":"/sicpjs/3.5.3","tag":"TITLE","body":"3.5.3  \n    Exploiting the Stream Paradigm"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    Streams with delayed evaluation can be a powerful modeling tool,\n    providing many of the benefits of local state and assignment.\n    Moreover, they avoid some of the theoretical tangles that accompany\n    the introduction of assignment into a programming language.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The stream approach can be illuminating because it allows us to build\n    systems with different\n    \n    module boundaries than systems organized around\n    assignment to state variables.  For example, we can think of an entire\n    time series (or signal) as a focus of interest, rather than the values\n    of the state variables at individual moments.  This makes it\n    convenient to combine and compare components of state from different\n    moments.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Formulating iterations as stream processes","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"1.2.1","href":"/sicpjs/1.2.1"},{"body":", we introduced\n    iterative processes, which proceed by updating state variables.  We know now\n    that we can represent state as a \"","tag":"#text"},{"body":"timeless","tag":"#text"},{"body":"\" stream of values\n    rather than as a set of variables to be updated.  Let's adopt this\n    perspective in revisiting the square-root\n    function\n    from section ","tag":"#text"},{"tag":"REF","body":"1.1.7","href":"/sicpjs/1.1.7"},{"body":".  Recall that the idea is to\n    generate a sequence of better and better guesses for the square root of\n    ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" by applying over and over again the\n    function\n    that improves guesses:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":5,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgCGAbgKYBO9A5swBQAeANKACeASlABvHKGmhWzcoVZ0+oANTCxYAEwBuHAF88RMlVqgAzgEdW5APqUAtgAdW1Ftw6Fm584N5jJGVl5RTomNk4eT29fUF5QMGifET1DHCsbe2dXdwBGNC1BLRSgA","body":"function sqrt_improve(guess, x) {\n    return average(guess, x / guess);\n} "}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    In our original\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":"function,\n    we made these guesses be the successive values of a state variable. Instead\n    we can generate the infinite stream of guesses, starting with an initial\n    \n\tguess of 1:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":23,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgCGAbgKYBO9A5swBQAeANKACeASlABvHKGmhWzcoVZ0+oANTCxYAEwBuHAF88RMlVqgAzgEdW5APqUAtgAdW1Ftw6Fm584N5jJGVl5RTomNk4eT29fUF5QMGifET1DHFJac3JQB3peWwATSnMnABt6IVAAXlAATj1jCho6IpLyoVssuXoHbnMAqRlG0xbisorO8m6He3I2PvJBYgGgoMp8UG5i22JCUtKFkRXV6X1QZlLzZlB1zboqh9AABmOToNbxoW4Acm-BACI0ED-ilBiczhcrhIwW9pB92twABbMegFQ6g2HvMbtSbTWbzLoombkeiUA5ZERLUAAWlAAEYMW9DEFmTJ4RNCT18aw+oJcvl2aJUkYSE0zFYbLiiXxXnIFEpQE5STy6YJuGIqgA+CxTIm2XJODxeHzVbUSuyOFxuKLG2L+fgwzFO50Wax2Tm9fxHYU4QVSnp9N3+3pab1AA","body":"function sqrt_stream(x) {\n   return pair(1, () => stream_map(guess => sqrt_improve(guess, x),\n                                   sqrt_stream(x)));\n} "},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":28,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4MYD2AdgM4AuoAtgIYAeA+gCYCWpADgDY0CeoAvKACcAbhwAzAK7F85FiVCsO3HgwoAnAKY0qAClIBKUAG8coc6Cky5CpV15ryWnQxblN6-eQA0oYkdMLINAWcVBdNgZiSU5OLwMAs2DzAF9QTU5STRCw3WIBfkEABkTk5LsVXQByKt8AIjRGuoMxMtA0jKyTJLbzCt5dAAttJniWnt7+1Q1tKld3TxmXchoWOIoDX3yAWlAARnG2lInjoKnHZzm3D31fWkYp8eOJaVl5fJoANw8aAHNNXR0Xw8UoWLTkSTqfKA0AAalAINAYAATGJnlY3gpSABHdTkVxUdjqQjfXS-SSaUikXx0UHmcGQj7fdR-AHkynU0B0JGgdlUp54DE2fI4vEXWaAukMqGgdirTx7Xy6Iz8AB8oCWc1o7DJFKpAnVovxLEJxNJfM5tO8E16trtGtx+M1koSaLw52dRvFOl0yNdQA","body":"display_stream(sqrt_stream(2)); ","output":"1\n1.5\n1.4166666666666665\n1.4142156862745097\n1.4142135623746899\n..."},{"body":"\n    We can generate more and more terms of the stream to get better and\n    better guesses.  If we like, we can write a\n    function\n    that keeps generating terms until the answer is good enough.\n    (See exercise ","tag":"#text"},{"tag":"REF","body":"3.64","href":"/sicpjs/3.5.3#ex-3.64"},{"body":".)\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Another iteration that we can treat in the same way is to generate an\n    approximation to\n    ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":", based upon the\n    alternating series that we saw in\n    section ","tag":"#text"},{"tag":"REF","body":"1.3.1","href":"/sicpjs/1.3.1"},{"body":":\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      \\dfrac {\\pi}{4} &=& 1-\\dfrac{1}{3}+\\dfrac{1}{5}-\\dfrac{1}{7}+\\cdots\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    We first generate the stream of summands of the series (the reciprocals\n    of the odd integers, with alternating signs).  Then we take the stream\n    of sums of more and more terms (using the \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"partial_sums"},{"body":" function\n      \n    of exercise ","tag":"#text"},{"tag":"REF","body":"3.55","href":"/sicpjs/3.5.2#ex-3.55"},{"body":") and scale the result by 4:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":54,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4MYD2AdgM4AuoAtgIYAeA+gCYCWpADgDY0CeoAvKACcAbhwAzAK7F85FiVCsO3HgwoAnAKY0qAClIBKUAG8coc6Cky5CpV15ryWnQxblN6-eQA0oYkdMLINAWcVBdNgZiSU5OLwMAs2DzAF9QTU5STRCw3WIBfkEABkTk5LsVXQByKt8AIjRGuoMxMtA0jKyTJLbzCt5dAAttJniWnt7+1Q1tKld3TxmXchoWOIoDX3yAWlAARnG2lInjoKnHZzm3D31fWkYp8eOJaVl5fNJ8Gk5NC9mvS6+cQ0WSEdSlCxaciSdQfJyzBi0di6OgCAB8oFRACpLCDyGDvBNer0llQnngrG8FFRNFRCLorAEAJBBCY-SjfZxMVTqaQCXGZTStCzs0BaUgxSiCaRMTTiFjETRMYXmKEw-K6Iz8DGBYlBULhACEnJGPOkEL1yXFkv5Vk1KstQRNNG5DF5+UETkkQqJjrFmmhsP9Es45Adeo6gu6fuCaqD1tD4eJp2TYmelJscMuiJo7AYACYGb5SHti-mLf7A-lItFYvoDqAAGSNkKkKIxdbl33BAD8fg73aCAC5W+26yWjAAfSej2udgyDix9jzqMF5Dv1aSaOjsTSyJWgGjqADmkhpxEo212pJzefzzUX5hH7FWnnEQxG9c2oGGLv05c2R82hpOldE1dFQBvJECyLSD4WWVZ1gOQkY1QvUbxWNZ-wSBI0wpV5M0PJgmD+HRSHrMsKzjLMEWgwsUVLTFywgug9lAABqJji0Y0hyzwl5rHeUAX3UORvjUM9yMMaNIQDdVhNfD8-0MFCY3A7UiJI0kpPguZMPWQC0LQkSxM4CSqCknD+IzIT2BYczaGIJhyP8GTK3kl8WE8NiwGIXx1IxKDcxRCDdjoXw7IcmgnJcjjQAA8kiDIShItJflPm+X5SV0EyWHEiULJy+yCsc5zdAOb8ABZxhwc5stS3SWiAA","body":"function pi_summands(n) {\n   return pair(1 / n, () => stream_map(x => - x, pi_summands(n + 2)));\n}\nconst pi_stream = scale_stream(partial_sums(pi_summands(1)), 4); "},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":59,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4MYD2AdgM4AuoAtgIYAeA+gCYCWpADgDY0CeoAvKACcAbhwAzAK7F85FiVCsO3HgwoAnAKY0qAClIBKUAG8coc6Cky5CpV15ryWnQxblN6-eQA0oYkdMLINAWcVBdNgZiSU5OLwMAs2DzAF9QTU5STRCw3WIBfkEABkTk5LsVXQByKt8AIjRGuoMxMtA0jKyTJLbzCt5dAAttJniWnt7+1Q1tKld3TxmXchoWOIoDX3yAWlAARnG2lInjoKnHZzm3D31fWkYp8eOJaVl5fNJ8Gk5NC9mvS6+cQ0WSEdSlCxaciSdQfJyzBi0di6OgCAB8oFRACpLCDyGDvBNer0llQnngrG8FFRNFRCLorAEAJBBCY-SjfZxMVTqaQCXGZTStCzs0BaUgxSiCaRMTTiFjETRMYXmKEw-K6Iz8DGBYlBULhACEnJGPOkEL1yXFkv5Vk1KstQRNNG5DF5+UETkkQqJjrFmmhsP9Es45Adeo6gu6fuCaqD1tD4eJp2TYmelJscMuiJo7AYACYGb5SHti-mLf7A-lItFYvoDqAAGSNkKkKIxdbl33BAD8fg73aCAC5W+26yWjAAfSej2udgyDix9jzqMF5Dv1aSaOjsTSyJWgGjqADmkhpxEo212pJzefzzUX5hH7FWnnEQxG9c2oGGLv05c2R82hpOldE1dFQBvJECyLSD4WWVZ1gOQkY1QvUbxWNZ-wSBI0wpV5M0PJgmD+HRSHrMsKzjLMEWgwsUVLTFywgug9lAABqJji0Y0hyzwl5rHeUAX3UORvjUM9yMMaNIQDdVhNfD8-0MFCY3A7UiJI0kpPguZMPWQC0LQkSxM4CSqCknD+IzIT2BYczaGIJhyP8GTK3kl8WE8NiwGIXx1IxKDcxRCDdjoXw7IcmgnJcjjQAA8kiDIShItJflPm+X5SV0EyWHEiULJy+yCsc5zdAOb8ABZxhwc5stS3SWiAA","body":"display_stream(pi_stream); ","output":"4\n2.666666666666667\n3.466666666666667\n2.8952380952380956\n3.3396825396825403\n2.9760461760461765\n3.2837384837384844\n3.017071817071818\n..."},{"body":"\n    This gives us a stream of better and better approximations to\n    ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":", although the approximations converge\n    rather slowly.  Eight terms of the sequence bound the value of\n    ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":" between 3.284 and 3.017.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    So far, our use of the stream of states approach is not much different\n    from updating state variables.  But streams give us an opportunity to do\n    some interesting tricks.  For example, we can transform a stream with a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"sequence accelerator","tag":"#text"}]},{"body":" that converts a sequence of approximations to a\n    new sequence that converges to the same value as the original, only faster.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    One such accelerator, due to the eighteenth-century Swiss mathematician\n    \n    Leonhard Euler, works well with sequences that are partial sums of\n    alternating series (series of terms with alternating signs). In\n    Euler's technique, if ","tag":"#text"},{"body":"$S_n$","tag":"LATEX"},{"body":" is the\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"th term of the original sum sequence, then\n    the accelerated sequence has terms\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{l}\n      S_{n+1} - \\dfrac{(S_{n+1}-S_n)^2}{S_{n-1}-2S_n+S_{n+1}}\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":" \n    Thus, if the original sequence is represented as a stream of values,\n    the transformed sequence is given by\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction euler_transform(s) {\n    const s0 = stream_ref(s, 0);     // $S_{n-1}$\n    const s1 = stream_ref(s, 1);     // $S_{n}$\n    const s2 = stream_ref(s, 2);     // $S_{n+1}$\n    return pair(s2 - square(s2 - s1) / (s0 + (-2) * s1 + s2),\n                memo(() => euler_transform(stream_tail(s))));\n}\n      "},{"body":"\n\t  Note that we make use of the memoization optimization of\n\t  section ","tag":"#text"},{"tag":"REF","body":"3.5.1","href":"/sicpjs/3.5.1"},{"body":", because in the\n\t  following we will rely on repeated evaluation of the resulting stream.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    We can demonstrate Euler acceleration with our sequence of\n    approximations to ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":71,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgDOAjoQIYBOApgBQAeAlKADeOUKNCdyhNnR6gAVKB4BuHAF88RMlVqgAth13UumgYICQY0CLEAbDuVAsbnFgBMAngH02JUAF5QfCd6DhVLOwdOekIbBwCSVw58SmIOVzCxCSk6LgE-AD4ha0sSy0p8UC4AQicXD28SU2LSlsyOaNj-QJJcjNb+2o43Lx86APIfUOb+0qzpcXaY8j6Z0VVQDhsQotXWuboopZXV9ROVdQISCho6DhiONk8JlmJ6fGo2XS56JstSWnoDnoAAYuoCXLpvElvgAaUDAvhKEogUAAEnAnkExAAtABGVSo5r-V5A3FgiZDSGcfCw0C4xHIsDozHEAlEgFAgBM5IhUJp9DhnIZlhRzKxAGp8YTLPtQAAHFiUNjfbnYhjMdjceiqhj00Bgb6g8WVbFC+S60DG7V8GHTVb6QxcXL+Qp3OyPZ6vd6fb4UliQ8iKmzfPihxFqPDEwF6Fg8TyuSj0OU2FjuLoAThUmmuOgTSZTXnBlJDOzE2e0dDzydTniL-s8lHID19cOIvxa5Uqic8xBiwcBodLpXWm22na4Yz8AQRQ-6VYLXAA5Iu4QAiNAb1fh1ojrYcWeteeprgACyGrl9oeOLSPhb9kMbzbrAaDl9boDV9Ova2apzEt9re8GybZUBRjONb3DC5yxuBhSCcDhAIhX0IThIIKA+dtRFlZ9PF0Fg5V4F1FHNdDyA+W1dhmZ8oI0K4KwYID8LlTxOWMOF6FxDizWEGV7GyUBu17Gx+z1AAyMTBPoHs+xVPg7RKAB+UBhJsBTLAALikmSRO+PUAB99O01S5PUsRlIeNgPgnPs1xIDgeDlDgKDSRw2AAc0IfRiAcbE1Vw5jWK3MzRC0hUlWMU9zz0m1QDPNw5JtELWgdIxnQKRjeUCtj8A4oDA0oUSkqokrStwgr+yFMNzjorRYLcVwkMpeg9O4rCFkkeYAoI1inR4LjFDNDL+stQaOIG60asuOqdAVNgqCcWsvJan5Z1lcLlXii8fko0r0sKBqmv9Fb8tfHbktK1o5oWmwlt0FbqojaaczoOVKDu-DiFcFq2yHdbFWVMkwGIOF9syyk8IIoiMrVHg4Tej6Xm+idRqq2iowcBHnzBeC7COr5rsoRbonurgsa8z7kfpWKABZwxwADny4N0HieNgXjeD4CfemjESAA","body":"display_stream(euler_transform(pi_stream)); ","output":"3.166666666666667\n3.1333333333333337\n3.1452380952380956\n3.13968253968254\n3.1427128427128435\n3.1408813408813416\n3.142071817071818\n3.1412548236077655\n..."}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    Even better, we can accelerate the accelerated sequence, and recursively\n    accelerate that, and so on.  Namely, we create a stream of streams (a\n    structure we'll call a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"tableau","tag":"#text"}]},{"body":") in which each stream is the transform of the preceding one:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgC2AhgNYCmA+uYwEYA2rjQgApyAJ0bEAzvmqj6AGlCSAlKADeOUFtCjW5QqLoAHRpVFDJioaoC8APgYsOXPgOFiJ02QtAepMuQtlYIBuHABfIA","body":"function make_tableau(transform, s) {\n    return pair(s, () => make_tableau(transform, transform(s)));\n} "},{"body":"\n    The tableau has the form\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{llllll}\n      s_{00} & s_{01} & s_{02} & s_{03} & s_{04} & \\ldots\\\\\n      & s_{10} & s_{11} & s_{12} & s_{13} & \\ldots\\\\\n      &        & s_{20} & s_{21} & s_{22} & \\ldots\\\\\n      &        &        &        & \\ldots &\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    Finally, we form a sequence by taking the first term in each row of\n    the tableau:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":75,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgC2AhgNYCmA+uYwEYA2rjQgApyAJ0bEAzvmqj6AGlCSAlKADeOUFtCjW5QqLoAHRpVFDJioaoC8APgYsOXPgOFiJ02QtAepMuQtlYIBuHABfPCIyKlolAEdCRl0hAA9VDW0dPQM6VNAAKlBUsMiCEgoaOnpWemohaIyASCzNbX5yUEZeXUYAEwBPdlESUBtQfG7JVjCsjuzJQl5O8ZI+1nxKYlY+2e1dfUNQazGHTKyLi8p8Y4BCbt7B4ZIMtsv3rN1F5bGJkms9h8gQ8BE8RnRxmJCDM3kD3gdcgsluRAXCtOFQKxeNN1LC0Z8ckcvsjUWjImTSlEKrE6KwlqxRJxxP5vEFcVlSLRJJ1JAAGX7c3r0YYbCyKXnKEIXECgAAk4HYamIAFoAIzhWWwzlSHmqgViATC3T4MWgVWS6VgeWK4garVcnkAJn1QpFJssoEdFqyMutSoA1OrNQTDsZTOZJM7lQkkilI6Bo5JzaAwBZ+f7jsqvYUlHqM5HlPI8WianUhCd7Jj6Yy-F5AoLDZxTLwgsFJRE8NruY5Uuw+pRJEZeIwBr8AJxhaKVOL9wfDoYNxj0NnnLRTmmgWdDkfsRfCyjkBkWciKYivD7XY4D9jEJYt7nBdnvDFYnGXoQQmzjCVPuFb+dCAA5IBigAERoBBoHth8L7Yqwv5Av+I5CAAFqCx6hMWlxIQuBpLuwB5HnuTaUPe5CFqAdDRuapLaOSdGwjhu54fuh4RooTC9jh7ZlOuVRKKQ3QcHux5CookwULI577ISdDEUwRhpKcxQ5hJ5CyEW+JwnuPFUjE-HyYwRjsI6DSKEm5nZqu2ShqA163rw97JgAZM5dmSDed4WF6WFZAA-JRd6+doABc7meY5FjJgAPtF4UOfePlogFDKiLIH53mBJCsKkRisBQOxdKIADmhA1MQnTKomLHsApJlQcFWhhSYZgNKh6FJhRaH9N5wSaVpWSlvUFYOIZxmmfg5k1VwpFRYWjUDYt2jETNiVtrp5T6XE-R9MxQqSFFlnSVoCJHGNJnlqkqqKKk2aVldoAZrd5nXUoXqUpt05hqIVDdLuZUHSoCGnWGrXdX0QT9QNI1dH0u17oD03NpDC1Le8Jg-ZQf2LPQgNth9fFxEYlD-fQTDEH0B1nr+IOgC15h6mAxBWLYo01QpSmVtGqSKMTpPk5TH6PZ6+Mdl2nR83uAqCfwe2GkIGO-bwpMHZLZUCwd5oUQALO2n0bowpCkFiDKMIe8OsIkrBkKwIjMnWPhA9ZtNje1-QcU4TauIIdueAEjuYWUTEiYbxv8OI5u7pb0I20IdLh0yfveLzJM6ZKQA","body":"function accelerated_sequence(transform, s) {\n    return stream_map(head, make_tableau(transform, s));\n} "}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    We can demonstrate this kind of \"","tag":"#text"},{"body":"super-acceleration","tag":"#text"},{"body":"\" of the\n    ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":" sequence:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":79,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgC2AhgNYCmA+uYwEYA2rjQgApyAJ0bEAzvmqj6AGlCSAlKADeOUFtCjW5QqLoAHRpVFDJioaoC8APgYsOXPgOFiJ02QtAepMuQtlYIBuHABfPCIyKlpQRlJSVn5xclYAE3ZJVgBHQlYyVhFxf29FFXVNbV19QyUxAXp2JiMhAAsBdMUmNk4efkFizwCfFWUwyIISCho6STzGXSEAD1UNbR09Azpl0AAqUGWJqOnYunpWemohaLWASA2qrX5yeN5dRnSAT3ZRElAbKB8IxeNkwhsXptJIReK9ASR0qx8JRiBlwdUtnVrACHOsNvj8ZR8KAhABCEEfb6-EhrJ4E+kY6GwgFAkjWdEMzkUzo-P50QFifIczn0mrbKEw8jCkWgcKgZLZSoyhliuq6JlSukyyLa45TGKzeUw1iiTglLyBCp4rSkWiSV6SAAMLPtHyaunwFkUjvG+JAoAAJOB2GpiABaACM4QDdNtUgdEZdDUY7qRXtAEd9G39QZDxGjsbtDoATEm3b805ZQMWs9oc8HQwBqKMxjaq4ymcySUthpQLJbd0C9ySZ0BgCzOxsksM1-ZKRNT7vKeRamUXK5CbH2I0pM3DbwWZNNLiUXhBYLjCJ4OP2xzLdjpSiSIy8RhfFkATjC0RmcUfz9fH5XUaIIlW0H8zlAf8XzfLIj3YSg0i7chFGIWkGSJEkn3YYgYTPe1gjAgk5QVVhQEwoR+RsQEfSIzloMAoQAHImMUAAiNBOLYy8GRI0EyOteinxgr52k6Q9QlXAkGNg4CUwQpDD3LE98PIZdQDoXtM2lbQdV0ukZKA+DEJNdMmHvQzL0mCDDUkUgQQ4OT6CUxpFGBChZHQjFajmeCWhWHFDjndzyFkFdlRFJyrJOA04ic5pGCMdhixucoI3KWdBPbcjJBwvCLFHAAyQqcry3h8JrKSNgAfg0vCqu0AAuUrcPKgrVAAHw6lr8qXBqtFqk1RFkSi8PYkhWGWIxWAoDJ4lEABzQgLmIV4w2HPzEuS7j+tAZqTDMG4xM+drFA6E6l2XXb6XXa4twceKWmS1L6mU0x8MzcKIu+774pUiwawvPUbLiT5MicyQCoyrytGyx6tpSlZ0sOWdt2WBcUbS6HgdOQ0TFEKgQSyZbIatOlsoO8xzvSIIvu++74nScGj1J+D-pUOmfq5-HCd4Yn6FJoGr31X9jEofmmGIdJIbQoiKc7IREzAYgrFsB7NtaXZt17ZZFCMcXoXoSXpco0Ap0B6Kb1efW4LdF17P4W2QJ5ygicNyGbcN43IczdSABZLxwQynZTIQEiSFJGDScHcnyQohFYY1TT8C0fE9o9QiAA","body":"display_stream(accelerated_sequence(euler_transform, pi_stream)); ","output":"4\n3.166666666666667\n3.142105263157895\n3.141599357319005\n3.1415927140337785\n3.1415926539752927\n3.1415926535911765\n3.141592653589778\n..."},{"body":"\n    The result is impressive.  Taking eight terms of the sequence yields the\n    correct value of ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":" to 14 decimal places.\n    If we had used only the original ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":" sequence,\n    we would need to compute on the order of ","tag":"#text"},{"body":"$10^{13}$","tag":"LATEX"},{"body":"\n    terms (i.e., expanding the series far enough so that the individual terms\n    are less then ","tag":"#text"},{"body":"$10^{-13}$","tag":"LATEX"},{"body":") to get that much\n    accuracy!\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    We could have implemented these acceleration techniques without using\n    streams.  But the stream formulation is particularly elegant and convenient\n    because the entire sequence of states is available to us as a data structure\n    that can be manipulated with a uniform set of operations.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.63","id":"#ex-3.63","child":[{"body":"\n\tLouis Reasoner is not happy with the performance of the stream\n\tproduced by the\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_stream"},{"body":" function and\n\ttries to optimize it using memoization:\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":false,"body":"function sqrt_stream_optimized(x) {\n    return pair(1,\n                memo(() => stream_map(guess =>\n                                        sqrt_improve(guess, x),\n                                      sqrt_stream_optimized(x))));\n}"},{"body":"\n\tAlyssa P. Hacker instead proposes\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":false,"body":"function sqrt_stream_optimized_2(x) {\n    const guesses = pair(1,\n                         memo(() => stream_map(guess => \n                                                 sqrt_improve(guess, x),\n                                               guesses)));\n    return guesses;\n}"},{"body":"\n        and claims that Louis's version is \n\tconsiderably less efficient than hers, because it performs\n\tredundant computation. Explain Alyssa's answer.\n\tWould Alyssa's approach without memoization be more\n\tefficient \n\tthan the original ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_stream"},{"body":"?\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.64","id":"#ex-3.64","child":[{"body":"\n  Write a\n  function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"stream_limit"},{"body":"\n  that takes as arguments a stream\n  and a number (the tolerance).  It should examine the stream until it\n  finds two successive elements that differ in absolute value by less\n  than the tolerance, and return the second of the two elements.  Using\n  this, we could compute square roots up to a given tolerance by\n  ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":false,"body":"function sqrt(x, tolerance) {\n    return stream_limit(sqrt_stream(x), tolerance);\n}"}]},{"tag":"EXERCISE","title":"Exercise 3.65","id":"#ex-3.65","child":[{"body":"\n    Use the series \n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      \\ln 2 &=& 1-\\dfrac{1}{2}+\\dfrac{1}{3}-\\dfrac{1}{4}+\\cdots\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    to compute three sequences of approximations to the natural logarithm of 2,\n  \n    in the same way we did above for ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":".\n    How rapidly do these sequences converge?\n    ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Infinite streams of pairs","tag":"#text"}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"2.2.3","href":"/sicpjs/2.2.3"},{"body":", we saw how the\n    sequence paradigm handles traditional nested loops as processes defined\n    on sequences of pairs. If we generalize this technique to infinite streams,\n    then we can write programs that are not easily represented as loops, because\n    the \"","tag":"#text"},{"body":"looping","tag":"#text"},{"body":"\" must range over an infinite set.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    For example, suppose we want to generalize the \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"prime_sum_pairs"},{"body":" function\n      \n    of section ","tag":"#text"},{"tag":"REF","body":"2.2.3","href":"/sicpjs/2.2.3"},{"body":" to produce the stream\n    of pairs of ","tag":"#text"},{"tag":"EM","child":[{"body":"all","tag":"#text"}]},{"body":" integers ","tag":"#text"},{"body":"$(i,j)$","tag":"LATEX"},{"body":" with\n    ","tag":"#text"},{"body":"$i \\leq j$","tag":"LATEX"},{"body":" such that\n    ","tag":"#text"},{"body":"$i+j$","tag":"LATEX"},{"body":"\n    is prime.  If\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"int_pairs"},{"body":"\n    is the sequence of all pairs of integers ","tag":"#text"},{"body":"$(i,j)$","tag":"LATEX"},{"body":"\n    with ","tag":"#text"},{"body":"$i \\leq j$","tag":"LATEX"},{"body":", then our required stream is\n    simply","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/3.5.3#footnote-1"},{"tag":"SNIPPET","latex":false,"id":13,"eval":true,"prependLength":60,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgDOAjoQIYBOApgBQAeAlKADeOUKNCdyhNnR6gAVKB4BuHAF88RMlVqhK9APoATSgDc9lAEYAbbjwA0oAJ4DB4jpOmLQAUiegAvIGgAAxKoOoEJBQ0dJTE5BwA5hxsBvTk7FTEifr4bNQAtlzELiJiElJ0AA4slGzFDlwC-gB8uvFJKWkZbFk5eYXFoADUoACMfHwqEZrROnr6VWyUBdwlQmWis9qxCfVV9KVix24edEysnFwAFhwshlwHk6BtxJsnH6AA-KDkbIQcd6fY4ALl0BmMZnolhsDVAt3uj0OfCBwNEP3wLCs9EBaI+YMoey46U4LAK+gylCsSMmKmO6mOFU8hJSj2Wq0O0xwpFo6VASxWHHoAX5tXqACY7Ki8ccmgE2iS7uT8FSidKZRqFgLVg51Rq8XEEslUvp0pk4v18kUUJM9Xiphoojt2nsbCwTNx6GMHPRxUdyu5KuD9MRCFZqV6UTKfr67aAwTU6jc7g9I7r9Sc5a0XSk3R7iZKGH8lRTahGJrS1I6tDFRXV6MSHOR-aImdUxVwrHpyMnEYcHAiHs2+OmM6As21Dbm7vnFWT9AUWFVePLQF30r3UyPFCO42P96I5+TKdTh1KD-vE6licX5yfidu9xe0UfS1SuMPKxEecQ+VPjcK-g5gBpo9H0uRWlwEwqNyvLkKAi48EYehVFYLCOCKACcKjbLWxj0Kh6GgaSRSHBsxy4To+GEY4xEliy9TpA46zCMClD4OOCyhuGN7PKxnyqKAHDYhwugcUMgRAcELZotRaGOFwADkikOAARGgGmqQ6wKCcJOLkTKcnoZuvHaYZKHyXR84MTeJFvhGzbMaAAC04xmR8DJiJ5ohGbRr42fQDiIchBHyQ635wS6ixioBdbXv+XQOAlqQOjgr4qlYRJXquWrstwg6PGKAijAV95XpMu4Zoa0X1lMQA","body":"stream_filter(pair => is_prime(head(pair) + head(tail(pair))),\n              int_pairs); "}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n    Our problem, then, is to produce the stream\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"int_pairs"},{"body":".\n    More generally, suppose we have two streams\n    ","tag":"#text"},{"body":"$S = (S_i)$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$T = (T_j)$","tag":"LATEX"},{"body":",\n    and imagine the infinite rectangular array\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{cccc}\n      (S_0,T_0) & (S_0,T_1) & (S_0, T_2) & \\ldots\\\\\n      (S_1,T_0) & (S_1,T_1) & (S_1, T_2) & \\ldots\\\\\n      (S_2,T_0) & (S_2,T_1) & (S_2, T_2) & \\ldots\\\\\n      \\ldots\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    We wish to generate a stream that contains all the pairs in the array\n    that lie on or above the diagonal, i.e., the pairs\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{cccc}\n      (S_0,T_0) & (S_0,T_1) & (S_0, T_2) & \\ldots\\\\\n      & (S_1,T_1) & (S_1, T_2) & \\ldots\\\\\n      &           & (S_2, T_2) & \\ldots\\\\\n      &           &            & \\ldots\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    (If we take both ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$T$","tag":"LATEX"},{"body":" to be the stream of integers, then this\n    will be our desired stream\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"int_pairs"},{"body":".)","tag":"#text"}]},{"tag":"TEXT","id":"#p15","child":[{"body":"\n    Call the general stream of pairs\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pairs(S, T)"},{"body":",\n    and consider it to be composed of three parts: the pair\n    ","tag":"#text"},{"body":"$(S_0,T_0)$","tag":"LATEX"},{"body":", the rest of the pairs in the first\n    row, and the remaining pairs:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/3.5.3#footnote-2"},{"body":"\n      \\[\n      \\begin{array}{c|ccc}\n      (S_0,T_0) & (S_0,T_1) & (S_0, T_2) & \\ldots\\\\\n      \\hline{} %--------------------------------------------------- \\\\\n      & (S_1,T_1) & (S_1, T_2) & \\ldots\\\\\n      &           & (S_2, T_2) & \\ldots\\\\\n      &           &            & \\ldots\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    Observe that the third piece in this decomposition (pairs that are not in\n    the first row) is (recursively) the pairs formed from \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"stream_tail(S)"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"stream_tail(T)"},{"body":".\n      \n    Also note that the second piece (the rest of the first row) is\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":14,"eval":false,"body":"stream_map(x => list(head(s), x),\n           stream_tail(t));"},{"body":"\n    Thus we can form our stream of pairs as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction pairs(s, t) {\n    return pair(list(head(s), head(t)), \n                () => $combine$-$in$-$some$-$way$(\n                          stream_map(x => list(head(s), x),\n                                     stream_tail(t)),\n                          pairs(stream_tail(s), stream_tail(t))));\n}\n      "}]},{"tag":"TEXT","id":"#p16","child":[{"body":"\n    In order to complete the\n    function,\n    we must choose some way to\n    \n    combine the two inner streams.  One idea is to\n    use the stream analog of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":"function\n    from section ","tag":"#text"},{"tag":"REF","body":"2.2.1","href":"/sicpjs/2.2.1"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":15,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgDO5ATgKYCGAtgPpsAOvLYgBMAFPQCMAGgYAmAJSgA3jlCrQrcoSZ1K9LsUIAbQ2PFyVay2oD8si1csAuULzaUmIgBbtREudPsHINURBQBeAD4GZnZuPgFhMRjOLnI3Ez9penk5AG4cAF88UlpGUFoWelAwlzcPKVBQ6qiK+jycEuIy8gB3aiqa13cRGWkmyNBe-vbOsvjBIRYhaujWFPnE1ukptvzGNe5WfBENxaFpcQAGS7ygA","body":"function stream_append(s1, s2) {\n    return is_null(s1)\n           ? s2\n           : pair(head(s1), \n                  () => stream_append(stream_tail(s1), s2));\n} "},{"body":"\n    This is unsuitable for infinite streams, however, because it takes all the\n    elements from the first stream before incorporating the second stream. In\n    particular, if we try to generate all pairs of positive integers using\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":16,"eval":true,"prependLength":37,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgDO5ATgKYCGAtgPpsAOvLYgBMAFPQCMAGgYAmAJSgA3jlCrQrcoSZ1K9LsUIAbQ2PFyVay2oD8si1csAuULzaUmIgBbtREudPsHINURBQBeAD4GZnZuPgFhMRjOLnI3Ez9penk5AG4cAF88IjIqWhc3JnoxaXIFZUsNLTpXdxFDXXIvHzF-UG82UTq+wODLUNBI6NYU+MFRUbGl6diuDj4RAA9JqI7GbsHe6U3-ReXzoMYZ7jTKE2HJM4urVqqk69T0o5WU2-u5AFPIJ5Qp4Ui0RigdabLhCXS8QxsACek1AAE58iUKDQ6HD6AjkVwrrFekpAliyrj4YikUTktxKOQWB5GNJiPUnpR8KARLp9EYMsMycECqAWIZ6CxQFyeXQwvLQAAGDnnPEEpEiADkmukACI0AbdSCRWKJVKGss1TSDr5hvlVdTCcSUozme9Vn8kn06ABaUBme1BIqWYNqK1O+lcV0s6TQ2GOpEgooEEjY8qUYhMgDmzL0jDYTCoxCzXHwTGoHBE7OFaia2gqbWI0gmUwz2dzdILRZLZYrVdAAGp-QD8snwcRIW2WDmqqipzO82lCxme+XKwG8K9qvPc9Id1UQThw7TnZWt7zM9Pd9LLwuR0A","body":"pairs(integers, integers); "},{"body":"\n    our stream of results will first try to run through all pairs with the\n    first integer equal to 1, and hence will never produce pairs with any\n    other value of the first integer.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p17","child":[{"body":"\n    To handle infinite streams, we need to devise an order of combination\n    that ensures that every element will eventually be reached if we let\n    our program run long enough.  An elegant way to accomplish this is\n    with the following ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"interleave"},{"body":"function:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/3.5.3#footnote-3"},{"tag":"SNIPPET","latex":false,"id":17,"eval":true,"prependLength":15,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4MYD2AdgM4AuoAtgIYAeA+gCYCWpADgDY0CeoAvKACcAbhwAzAK7F85FiVCsO3HgwoAnAKY0qAClIBKUAG8coc6Cky5CpV15ryWnQxblN6-eQA0oYkdMLINAWcVBdNgZiSU5OLwMAs2DzAF9QTU5STRCw3WIBfkEABkTk5LsVXQByKt8AIjRGuoMxMtA0jKyTJLbzCt5dAAttJniWnt7+1Q1tKld3TxmXchoWOIoDX3yAWlAARnG2lInjoKnHZzm3D31fWkYp8eOJaVl5fJZiBc5tADdNfR7XykABMpQsWnIknUH1IURi6wOEzKAH5QKDkckAFygdirTzDGijUgHXyY3oWXRGfgAPhCXw8Pxo-30IOBTlmDBWa0BCSeeCIZEoJE0pAEuPxuiB4WpdJFhjEgoooHIAHdCGLBHiWJ42TKBHS1RrxkrKJ9vn9NExxebGZbdPLfEaFThzks9Lb1Ez-kwWkA","body":"function interleave(s1, s2) {\n    return is_null(s1)\n           ? s2\n           : pair(head(s1), \n                  () => interleave(s2, stream_tail(s1)));\n} "},{"body":"\n    Since ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"interleave"},{"body":" takes elements alternately\n    from the two streams, every element of the second stream will eventually\n    find its way into the interleaved stream, even if the first stream is\n    infinite.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p18","child":[{"body":"\n    We can thus generate the required stream of pairs as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":18,"eval":true,"prependLength":28,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGiXHkCmATgDZMCGAbkwBQBnAIwAaUAIBMASlABvHKEWgWTcoRZ1KAgPrFCbNoKFSFSs0oD84iafNmAXKAAOnSiz4ALLgBMjUsbZ2QYp8MgC8AHz0jKwcPPySYgLkKpwAttrkrobCUnkA3DgAvniktMmgaZwAHtreWk5snACeoGGgAJyFRGRUtKD1Ao0t2smpaYIy8mY9FDR0g8PNoylcGZTM7slixFOBZpT4oHxauvo55Hly+0pFoExsAkz0R3x0YR+gAAx7wWaLTWafAA5MCxAAiNBQ8FSQrBO4PJ7XP5KAEtTw+QSXWE3Oxo5ZjNbaDasLHjTLZLH+UB0AC0oGMcKCJTMLNRDUBK3JJK2YiqtXxOJKBBIc36DGYAHNWDpkpwWFRiJLtPgWNQJrtkUoVGoNM5XO5iGJQm0ohKmNKWLKsgqGMrVeq3qAANQMgrFUrlcjRKUyto+i0ylbyxX2tUTRl4WZ9OguNwCQRiS5axQ69Sxg18NhacgYzi+ATUrz5vjYgIouwmyIB9hcXhkolVJx8aqm0DZ5J5gvU6r+XEVgeD8SrdIUyiGMv9ocVuNWhujrLjybl6eroKEheU7Hu4X4rlrPizhPmy0CMQnmUFIA","body":"function pairs(s, t) {\n    return pair(list(head(s), head(t)), \n                () => interleave(stream_map(x => list(head(s), x),\n                                            stream_tail(t)),\n                                 pairs(stream_tail(s), \n                                       stream_tail(t))));\n} "}]},{"tag":"EXERCISE","title":"Exercise 3.66","id":"#ex-3.66","child":[{"body":"\n    Examine the stream\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pairs(integers, integers)"},{"body":".\n      \n    Can you make any general comments about the order in which the pairs are\n    placed into the stream? For example, approximately how many pairs precede\n    the pair (1,100)? the pair (99,100)? the pair (100,100)? (If you can make\n    precise mathematical statements here, all the better. But feel free to give\n    more qualitative answers if you find yourself getting bogged down.)\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.67","id":"#ex-3.67","child":[{"body":"\n    Modify the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pairs"},{"body":"function\n    so that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pairs(integers, integers)"},{"body":"\n    will produce the stream of ","tag":"#text"},{"tag":"EM","child":[{"body":"all","tag":"#text"}]},{"body":" pairs of integers\n    ","tag":"#text"},{"body":"$(i,j)$","tag":"LATEX"},{"body":" (without the condition\n    ","tag":"#text"},{"body":"$i \\leq j$","tag":"LATEX"},{"body":").  Hint: You will need to\n    mix in an additional stream.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.68","id":"#ex-3.68","child":[{"body":"\n    Louis Reasoner thinks that building a stream of pairs from three parts is\n    unnecessarily complicated.  Instead of separating the pair\n    ","tag":"#text"},{"body":"$(S_0,T_0)$","tag":"LATEX"},{"body":" from the rest of the pairs in the\n    first row, he proposes to work with the whole first row, as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":19,"eval":false,"body":"function pairs(s, t) {\n    return interleave(stream_map(x => list(head(s), x),\n                                 t), \n                      pair(stream_tail(s), stream_tail(t)));\n}"},{"body":"\n    Does this work?  Consider what happens if we evaluate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pairs(integers, integers)"},{"body":"\n    using Louis's definition of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pairs"},{"body":".\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.69","id":"#ex-3.69","child":[{"body":"\n    Write a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"triples"},{"body":" that takes three infinite streams,\n    ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":", ","tag":"#text"},{"body":"$T$","tag":"LATEX"},{"body":", and\n    ","tag":"#text"},{"body":"$U$","tag":"LATEX"},{"body":", and produces the stream of triples\n    ","tag":"#text"},{"body":"$(S_i,T_j,U_k)$","tag":"LATEX"},{"body":" such that\n    ","tag":"#text"},{"body":"$i \\leq j \\leq k$","tag":"LATEX"},{"body":". Use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"triples"},{"body":" to generate the stream of all \n    \n    Pythagorean triples of positive integers, i.e., the triples\n    ","tag":"#text"},{"body":"$(i,j,k)$","tag":"LATEX"},{"body":" such that\n    ","tag":"#text"},{"body":"$i \\leq j$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$i^2 + j^2 =k^2$","tag":"LATEX"},{"body":".\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.70","id":"#ex-3.70","child":[{"body":"\n    It would be nice to be able to generate\n    \n    streams in which the pairs\n    appear in some useful order, rather than in the order that results\n    from an ","tag":"#text"},{"tag":"EM","child":[{"body":"ad hoc","tag":"#text"}]},{"body":" interleaving process.  We can use a technique\n    similar to the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"merge"},{"body":"function\n    of exercise ","tag":"#text"},{"tag":"REF","body":"3.56","href":"/sicpjs/3.5.2#ex-3.56"},{"body":", if we define a way to say that\n    one pair of integers is \"","tag":"#text"},{"body":"less than","tag":"#text"},{"body":"\" another.  One way to do\n    this is to define a\n    \"","tag":"#text"},{"body":"weighting function","tag":"#text"},{"body":"\"","tag":"#text"},{"body":"$W(i,j)$","tag":"LATEX"},{"body":" and stipulate that\n    ","tag":"#text"},{"body":"$(i_1,j_1)$","tag":"LATEX"},{"body":" is less than\n    ","tag":"#text"},{"body":"$(i_2,j_2)$","tag":"LATEX"},{"body":" if\n    ","tag":"#text"},{"body":"$W(i_1,j_1) < W(i_2,j_2)$","tag":"LATEX"},{"body":".  Write a\n    function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"merge_weighted"},{"body":"\n    that is like ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"merge"},{"body":", except that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"merge_weighted"},{"body":"\n    takes an additional argument ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"weight"},{"body":", which is a\n    function\n    that computes the weight of a pair, and is used to determine the order in\n    which elements should appear in the resulting merged stream.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/3.5.3#footnote-4"},{"body":" Using this, generalize ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pairs"},{"body":"\n    to a\n    function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"weighted_pairs"},{"body":"\n    that takes two streams, together with a\n    function\n    that computes a weighting function, and generates the stream of pairs,\n    ordered according to weight.  Use your\n    function\n    to generate\n    ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\tthe stream of all pairs of positive integers\n\t","tag":"#text"},{"body":"$(i,j)$","tag":"LATEX"},{"body":" with ","tag":"#text"},{"body":"$i \\leq         j$","tag":"LATEX"},{"body":" ordered according to the sum\n\t","tag":"#text"},{"body":"$i + j$","tag":"LATEX"}]},{"tag":"LI","child":[{"body":"\n\tthe stream of all pairs of positive integers\n\t","tag":"#text"},{"body":"$(i,j)$","tag":"LATEX"},{"body":" with ","tag":"#text"},{"body":"$i \\leq         j$","tag":"LATEX"},{"body":", where neither ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":" nor\n\t","tag":"#text"},{"body":"$j$","tag":"LATEX"},{"body":" is divisible by 2, 3, or 5, and the\n\tpairs are ordered according to the sum\n\t","tag":"#text"},{"body":"$2 i + 3 j + 5 i j$","tag":"LATEX"},{"body":".\n      ","tag":"#text"}]}]}]},{"tag":"EXERCISE","title":"Exercise 3.71","id":"#ex-3.71","child":[{"body":"\n    Numbers that can be expressed as the sum of two cubes in more than one\n    way are sometimes called\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Ramanujan numbers","tag":"#text"}]},{"body":", in honor of the\n    mathematician Srinivasa Ramanujan.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/3.5.3#footnote-5"},{"body":" Ordered streams of pairs provide an elegant solution\n    to the problem of computing these numbers.  To find a number that can be\n    written as the sum of two cubes in two different ways, we need only generate\n    the stream of pairs of integers ","tag":"#text"},{"body":"$(i,j)$","tag":"LATEX"},{"body":" weighted\n    according to the sum ","tag":"#text"},{"body":"$i^3 + j^3$","tag":"LATEX"},{"body":" (see\n    exercise ","tag":"#text"},{"tag":"REF","body":"3.70","href":"/sicpjs/3.5.3#ex-3.70"},{"body":"), then search the stream for\n    two consecutive pairs with the same weight.  Write a\n    function\n    to generate the Ramanujan numbers.  The first\n    such number is 1,729.  What are the next five?\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.72","id":"#ex-3.72","child":[{"body":"\n    In a similar way to exercise ","tag":"#text"},{"tag":"REF","body":"3.71","href":"/sicpjs/3.5.3#ex-3.71"},{"body":" generate\n    a stream of all numbers that can be written as the sum of two squares in\n    three different ways (showing how they can be so written).\n    ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"Streams as signals","tag":"#text"}]},{"tag":"TEXT","id":"#p19","child":[{"body":"\n    We began our discussion of streams by describing them as computational\n    analogs of the \"","tag":"#text"},{"body":"signals","tag":"#text"},{"body":"\" in signal-processing systems.\n    In fact, we can use streams to model signal-processing systems in a very\n    direct way, representing the values of a signal at successive time\n    intervals as consecutive elements of a stream.  For instance, we can\n    implement an \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"integrator","tag":"#text"}]},{"body":" or \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"summer","tag":"#text"}]},{"body":" that, for an input stream\n    ","tag":"#text"},{"body":"$x=(x_{i})$","tag":"LATEX"},{"body":", an initial value ","tag":"#text"},{"body":"$C$","tag":"LATEX"},{"body":", and a small increment ","tag":"#text"},{"body":"$dt$","tag":"LATEX"},{"body":",\n    accumulates the sum\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      S_i &=& C +\\sum_{j=1}^{i} x_{j} \\, dt\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    and returns the stream of values ","tag":"#text"},{"body":"$S=(S_{i})$","tag":"LATEX"},{"body":".\n    The following ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"integral"},{"body":"function\n    is reminiscent of the \"","tag":"#text"},{"body":"implicit style","tag":"#text"},{"body":"\" definition of the\n    stream of integers (section ","tag":"#text"},{"tag":"REF","body":"3.5.2","href":"/sicpjs/3.5.2"},{"body":"):\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":20,"eval":true,"prependLength":34,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFY0oFA4GYCuAdgMYAuAlgPbGgC2ApvdQBRHECUoA3gJChBoHENAAbRuVABDMQCdG0gCYBPAPpySoALyh8sgM6MA3CKESpCg4TFTdJJY3yVijJadELyhOXVbdtAD5eM1Ew0Up8UFYAQlkFZXVNLhDwtPCrGzs9En8PdIKZeUVVDS1dck0TUMKMyR86TNt82sEAX1BGMSNU1rrvX1Am8hbWtpq0ttNxghIKGjoDSsV6NXppAAc1ACZ2ABpQAwBGA4Nt7h4arwbQSgM1YhsxVmPuADI32-vHsWezzgm4QA-KAfmJAWEAFxfB5PF5HbgAH0RMLBL3OENEIMYcjk1DkrDBBwARCRGAAPDaMChuGRyADmhCYxCkAFpWYdltJVustttiQDatCNtJKAT8KwABYleGcA7S5TozhyzGFJgsVj+HTBJYJHmbHb7Tl6tTkUV-BF7VV9G3hXUrU3mpXKzjTPAcea0GRKJRqe3cgzw07nXqCa6Df36vma8knUDkkNBeNHUAAanj21Ocf+btmZCoXoMpFkjD9XPoL3LB30FHxFyu9Qj5bWm1Y5O18dAACo9NJa3Irba0pHXTgZh6C3QXORGPS5LJWNPZ-PiEoDi5KFRZGoAG6yQiMA5Kcj10SkWhLW4s2c6UAisWL4ibyjbvdiA+DofhLVJ5S+yOBkWJZlnqj4znO0irkeJ6fl+cERNe9LKqM4ZTohuYTgsoJMgARji9xLNIchUMQ9JqPgeIVuQ0GnkIqF3qKBLUda34BMEjz0HhcgEWaxEuGRFHUFRaagMeNEsaIo7jOexCXset4AAxoApRymDJl5iC4ihyLeHFcTxREkQJlGsApNFqReUiaa4RFqEuEFiLe9nzs81naQcZmiSepggKA570BshBGVe4EuXolGgApoDkNQqCgNQUQSuSATxjgvmsOQ0ohcushfKA9JtilSkYPGAB6mYyKu0XSgo+D4owaVgJljBDIw1i2HlNk6cV3aoOVt4ACyYACkYaE4rBubZzmyAc6yZRo1AOKwKCgGAx7IUAA","body":"function integral(integrand, initial_value, dt) {\n    const integ = pair(initial_value,\n                       () => add_streams(scale_stream(integrand, dt),\n                                         integ));\n    return integ;\n} "},{"tag":"FIGURE","scale":"90%","src":"img_javascript/ch3-Z-G-49.svg","id":"#fig-3.32","captionHref":"/sicpjs/3.5.3#fig-3.32","captionName":"Figure 3.32 ","captionBody":[{"body":"The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"integral"},{"body":"\n          function viewed as a signal-processing system.\n          ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p20","child":[{"body":"\n\tFigure ","tag":"#text"},{"tag":"REF","body":"3.32","href":"/sicpjs/3.5.3#fig-3.32"},{"body":"\n    is a picture of a signal-processing\n    system that corresponds to the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"integral"},{"body":"function.\n    The input stream is scaled by ","tag":"#text"},{"body":"$dt$","tag":"LATEX"},{"body":" and passed\n    through an adder, whose output is passed back through the same adder.\n    The self-reference in the definition of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"integ"},{"body":"\n    is reflected in the figure by the feedback loop that\n    connects the output of the adder to one of the inputs.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.73","id":"#ex-3.73","child":[{"body":"\n      We can model electrical circuits using streams to represent the values\n      of currents or voltages at a sequence of times.  For instance, suppose\n      we have an\n      ","tag":"#text"},{"tag":"EM","child":[{"body":"RC circuit","tag":"#text"}]},{"body":" consisting of a resistor of resistance\n      ","tag":"#text"},{"body":"$R$","tag":"LATEX"},{"body":" and a capacitor of capacitance\n      ","tag":"#text"},{"body":"$C$","tag":"LATEX"},{"body":" in series.  The voltage response\n      ","tag":"#text"},{"body":"$v$","tag":"LATEX"},{"body":" of the circuit to an injected current\n      ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":" is determined by the formula in\n      figure ","tag":"#text"},{"tag":"REF","body":"3.33","href":"/sicpjs/3.5.3#fig-3.33"},{"body":", whose structure is shown by the\n      accompanying signal-flow diagram.\n  ","tag":"#text"},{"tag":"FIGURE","scale":"80%","src":"img_original/ch3-Z-G-51.svg","id":"#fig-3.33","captionHref":"/sicpjs/3.5.3#fig-3.33","captionName":"Figure 3.33 ","captionBody":[{"body":"An RC circuit and the associated\n\t\n\tsignal-flow diagram.\n\t","tag":"#text"}]},{"body":"\n      Write a\n      function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"RC"},{"body":" that models this circuit.\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"RC"},{"body":" should take as inputs the values of\n      ","tag":"#text"},{"body":"$R$","tag":"LATEX"},{"body":", ","tag":"#text"},{"body":"$C$","tag":"LATEX"},{"body":", and\n      ","tag":"#text"},{"body":"$dt$","tag":"LATEX"},{"body":" and should return a\n      function\n      that takes as inputs a stream representing the current\n      ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":" and an initial value for the capacitor\n      voltage ","tag":"#text"},{"body":"$v_{0}$","tag":"LATEX"},{"body":" and produces as output the\n      stream of voltages ","tag":"#text"},{"body":"$v$","tag":"LATEX"},{"body":".  For example, you\n      should be able to use ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"RC"},{"body":" to model an RC\n      circuit with ","tag":"#text"},{"body":"$R = 5$","tag":"LATEX"},{"body":" ohms,\n      ","tag":"#text"},{"body":"$C = 1$","tag":"LATEX"},{"body":" farad, and a 0.5-second time step by\n      evaluating\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"const RC1 = RC(5, 1, 0.5)"},{"body":".\n\t\n      This defines ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"RC1"},{"body":" as a\n      function\n      that takes a stream representing the time sequence of currents and an\n      initial capacitor voltage and produces the output stream of voltages.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.74","id":"#ex-3.74","child":[{"body":"\n    Alyssa P. Hacker is designing a system to process signals coming from\n    physical sensors.  One important feature she wishes to produce is a signal\n    that describes the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"zero crossings","tag":"#text"}]},{"body":" of the input signal. That is,\n    the resulting signal should be ","tag":"#text"},{"body":"$+1$","tag":"LATEX"},{"body":" whenever the\n    input signal changes from negative to positive,\n    ","tag":"#text"},{"body":"$-1$","tag":"LATEX"},{"body":" whenever the input signal changes from\n    positive to negative, and 0 otherwise.  (Assume that the sign of a 0 input\n    is positive.)  For example, a typical input signal with its associated\n    zero-crossing signal would be\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\ldots$ 1  2  1.5  1  0.5  -0.1  -2  -3  -2  -0.5  0.2  3  4 $\\ldots$\n$\\ldots\\;$  0  0    0  0    0     -1  0   0   0     0    1  0  0 $\\ldots$\n      "},{"body":"\n\n    In Alyssa's system, the signal from the sensor is represented as a\n    stream\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sense_data"},{"body":" \n    and the stream\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"zero_crossings"},{"body":"\n    is the corresponding stream of zero crossings.  Alyssa first writes a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sign_change_detector"},{"body":"\n    that takes two values as arguments and compares the signs of the values to\n    produce an appropriate ","tag":"#text"},{"body":"$0$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$1$","tag":"LATEX"},{"body":", or ","tag":"#text"},{"body":"$-1$","tag":"LATEX"},{"body":".  She\n    then constructs her zero-crossing stream as follows:\n\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":21,"eval":false,"body":"function make_zero_crossings(input_stream, last_value) {\n    return pair(sign_change_detector(head(input_stream), last_value),\n                () => make_zero_crossings(stream_tail(input_stream),\n                                          head(input_stream)));\n}\nconst zero_crossings = make_zero_crossings(sense_data, 0);"},{"body":"\n\n    Alyssa's boss, Eva Lu Ator, walks by and suggests that this program is\n    approximately equivalent to the following one, which uses\n    \n\tthe function \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"stream_map_2"},{"body":"\n\tfrom exercise ","tag":"#text"},{"tag":"REF","body":"3.50","href":"/sicpjs/3.5.1#ex-3.50"},{"body":":\n      ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nconst zero_crossings = stream_map_2(sign_change_detector,\n                                    sense_data,\n                                    $expression$);\n      "},{"body":"\n    Complete the program by supplying the indicated\n    ","tag":"#text"},{"tag":"META","body":"expression"},{"body":".\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.75","id":"#ex-3.75","child":[{"body":"\n    Unfortunately, Alyssa's\n    \n    zero-crossing detector in\n    exercise ","tag":"#text"},{"tag":"REF","body":"3.74","href":"/sicpjs/3.5.3#ex-3.74"},{"body":" proves to be insufficient,\n    because the noisy signal from the sensor leads to spurious zero crossings.\n    Lem E. Tweakit, a hardware specialist, suggests that Alyssa smooth the\n    signal to filter out the noise before extracting the zero crossings.\n    Alyssa takes his advice and decides to extract the zero crossings from\n    the signal constructed by averaging each value of the sense data with\n    the previous value.  She explains the problem to her assistant, Louis\n    Reasoner, who attempts to implement the idea, altering Alyssa's\n    program as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":22,"eval":false,"body":"function make_zero_crossings(input_stream, last_value) {\n    const avpt = (head(input_stream) + last_value) / 2;\n    return pair(sign_change_detector(avpt, last_value),\n                () => make_zero_crossings(stream_tail(input_stream), \n                                          avpt));\n}"},{"body":"\n    This does not correctly implement Alyssa's plan.\n    Find the bug that Louis has installed\n    and fix it without changing the structure of the program.  (Hint: You\n    will need to increase the number of arguments to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_zero_crossings"},{"body":".)\n      ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.76","id":"#ex-3.76","child":[{"body":"\n    Eva Lu Ator has a criticism of Louis's approach in\n    exercise ","tag":"#text"},{"tag":"REF","body":"3.75","href":"/sicpjs/3.5.3#ex-3.75"},{"body":".\n    \n    The program he wrote is\n    not modular, because it intermixes the operation of smoothing with the\n    zero-crossing extraction.  For example, the extractor should not have\n    to be changed if Alyssa finds a better way to condition her input\n    signal.  Help Louis by writing a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"smooth"},{"body":" that takes a stream as input and\n    produces a stream in which each element is the average of two successive\n    input stream elements.  Then use ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"smooth"},{"body":" as a\n    component to implement the zero-crossing detector in a more modular style.\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/3.5.3#footnote-link-1","child":[{"body":"As in\n    section ","tag":"#text"},{"tag":"REF","body":"2.2.3","href":"/sicpjs/2.2.3"},{"body":", we\n    represent a pair of integers as a list rather than a\n    \n    pair.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/3.5.3#footnote-link-2","child":[{"body":"See\n    exercise ","tag":"#text"},{"tag":"REF","body":"3.68","href":"/sicpjs/3.5.3#ex-3.68"},{"body":" for some insight into why we\n    chose this decomposition.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/3.5.3#footnote-link-3","child":[{"body":"The\n    precise statement of the required property on the order of combination is\n    as follows: There should be a function ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" of\n    two arguments such that the pair corresponding to\n    element ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":" of the first stream and\n    element ","tag":"#text"},{"body":"$j$","tag":"LATEX"},{"body":" of the second stream will\n    appear as element number ","tag":"#text"},{"body":"$f(i,j)$","tag":"LATEX"},{"body":" of the output\n    stream.  The trick of using ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"interleave"},{"body":"\n    to accomplish this was shown to us by \n    \n    David Turner, who employed it in the language \n    \n    KRC (Turner 1981).","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/3.5.3#footnote-link-4","child":[{"body":"We\n    will require that the weighting function be such that the weight of a pair\n    increases as we move out along a row or down along a column of the array of\n    pairs.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/3.5.3#footnote-link-5","child":[{"body":"To quote from G. H.\n    Hardy's obituary of\n    \n    Ramanujan (Hardy 1921): \"","tag":"#text"},{"body":"It was\n    Mr. Littlewood\n    (I believe) who remarked that '","tag":"#text"},{"body":"every positive integer was one of his\n    friends.","tag":"#text"},{"body":"'  I remember once going to see him when he was lying ill\n    at Putney.  I had ridden in taxi-cab No. 1729, and remarked that the number\n    seemed to me a rather dull one, and that I hoped it was not an unfavorable\n    omen. '","tag":"#text"},{"body":"No,","tag":"#text"},{"body":"' he replied, '","tag":"#text"},{"body":"it is a very interesting number;\n    it is the smallest number expressible as the sum of two cubes in two\n    different ways.","tag":"#text"},{"body":"'","tag":"#text"},{"body":"\" The trick of using weighted pairs to\n    generate the Ramanujan numbers was shown to us by\n    \n    Charles\n    Leiserson.","tag":"#text"}]}]