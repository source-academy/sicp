[
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 1,
    "content": "We are about to study the idea of a computational process . data . program . People create programs to direct processes. In effect, we conjure the spirits of the computer with our spells."
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 2,
    "content": "A computational process is indeed much like a sorcerer s idea of a spirit. It cannot be seen or touched. It is not composed of matter at all. However, it is very real. It can perform intellectual work. It can answer questions. It can affect the world by disbursing money at a bank or by controlling a robot arm in a factory. The programs we use to conjure processes are like a sorcerer s spells. They are carefully composed from symbolic expressions in arcane and esoteric programming languages"
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 3,
    "content": "A computational process, in a correctly working computer, executes programs precisely and accurately. Thus, like the sorcerer s apprentice, novice programmers must learn to understand and to anticipate the consequences of their conjuring. Even small errors (usually called bugs or glitches ) (usually called bugs ) in programs can have complex and unanticipated consequences."
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 4,
    "content": "Fortunately, learning to program is considerably less dangerous than learning sorcery, because the spirits we deal with are conveniently contained in a secure way. Real-world programming, however, requires care, expertise, and wisdom. A small bug in a computer-aided design program, for example, can lead to the catastrophic collapse of an airplane or a dam or the self-destruction of an industrial robot."
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 5,
    "content": "Master software engineers have the ability to organize programs so that they can be reasonably sure that the resulting processes will perform the tasks intended. They can visualize the behavior of their systems in advance. They know how to structure programs so that unanticipated problems do not lead to catastrophic consequences, and when problems do arise, they can debug their programs. Well-designed computational systems, like well-designed automobiles or nuclear reactors, are designed in a modular manner, so that the parts can be constructed, replaced, and debugged separately."
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 6,
    "content": "We need an appropriate language for describing processes, and we will use for this purpose the programming language Lisp. Just as our everyday thoughts are usually expressed in our natural language (such as English, Swedish, or German), and descriptions of quantitative phenomena are expressed with mathematical notations, our procedural thoughts will be expressed in Lisp. recursion equations , as a model for computation. The language was conceived by Recursive Functions of Symbolic Expressions and Their Computation by Machine ("
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 7,
    "content": "We need an appropriate language for describing processes, and we will use for this purpose the programming language JavaScript. Just as our everyday thoughts are usually expressed in our natural language (such as English, Swedish, or Chinese), and descriptions of quantitative phenomena are expressed with mathematical notations, our procedural thoughts will be expressed in JavaScript. Mocha , which was later renamed to LiveScript , and finally to JavaScript. JavaScript is a trademark of Oracle Corporation."
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 8,
    "content": "Despite its inception as a mathematical formalism, Lisp is a practical programming language. A Lisp interpreter is a machine that carries out processes described in the Lisp language. The first Lisp interpreter was implemented by"
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 9,
    "content": "Despite its inception as a language for scripting the web, JavaScript interpreter is a machine that carries out processes described in the JavaScript language."
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 10,
    "content": "Lisp was not the product of a concerted design effort. Instead, it evolved informally in an experimental manner in response to users needs and to pragmatic implementation considerations. Lisp s informal evolution has continued through the years, and the community of Lisp users has traditionally resisted attempts to promulgate any official definition of the language. This evolution, together with the flexibility and elegance of the initial conception, has enabled Lisp, which is the second oldest language in widespread use today (only"
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 11,
    "content": "JavaScript bears only superficial resemblance to the language Java, after which it was (eventually) named; both Java and JavaScript use the block structure of the language C. In contrast with Java and C, which usually employ compilation to lower-level languages, JavaScript programs were initially interpreted by web browsers. s Internet Explorer, whose JavaScript version is called JScript . The popularity of JavaScript for controlling web browsers gave rise to a standardization effort, culminating in ECMAScript . The and completed in June 1997 ("
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 12,
    "content": "Because of its experimental character and its emphasis on symbol manipulation,"
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 13,
    "content": "The practice of embedding JavaScript programs in web pages encouraged the developers of web browsers to implement JavaScript interpreters. As these programs became more complex, the interpreters became more efficient in executing them, eventually using sophisticated implementation techniques such as Just-In-Time (JIT) compilation. The majority of JavaScript programs as of this writing (2021) are embedded in web pages and interpreted by browsers, but JavaScript is increasingly used as a general-purpose programming language, using systems such as Node.js."
  },
  {
    "source_file": "chapter1.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Procedures Functions",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 14,
    "content": "If Lisp is not a mainstream language, why are we using it as the framework for our discussion of programming? Because the language possesses procedures , can themselves be represented and manipulated as Lisp data. The importance of this is that there are powerful program-design techniques that rely on the ability to blur the traditional distinction between passive data and active processes. As we shall discover, Lisp s flexibility in handling procedures as data makes it one of the most convenient languages in existence for exploring these techniques. The ability to represent procedures as data also makes Lisp an excellent language for writing programs that must manipulate other programs as data, such as the interpreters and compilers that support computer languages. Above and beyond these considerations, programming in Lisp is great fun."
  },
  {
    "source_file": "section1.xml",
    "tag_type": "SECTION",
    "title": "The Elements of Programming",
    "parent_title": "Building Abstractions with Procedures Functions",
    "depth": 1,
    "paragraph_index": 1,
    "content": "A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three mechanisms for accomplishing this: primitive expressions , cerned with, means of combination , by means of abstraction ,"
  },
  {
    "source_file": "section1.xml",
    "tag_type": "SECTION",
    "title": "The Elements of Programming",
    "parent_title": "Building Abstractions with Procedures Functions",
    "depth": 1,
    "paragraph_index": 2,
    "content": "In programming, we deal with two kinds of elements: and stuff that we want to manipulate, and procedures functions are descriptions of the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive procedures functions and should have methods for combining and abstracting procedures functions and data."
  },
  {
    "source_file": "section1.xml",
    "tag_type": "SECTION",
    "title": "The Elements of Programming",
    "parent_title": "Building Abstractions with Procedures Functions",
    "depth": 1,
    "paragraph_index": 3,
    "content": "In this chapter we will deal only with simple procedures functions . procedures functions to manipulate compound data as well."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "section1.xml",
    "tag_type": "SECTION",
    "title": "The Elements of Programming",
    "parent_title": "Building Abstractions with Procedures Functions",
    "depth": 1,
    "paragraph_index": 1,
    "content": "A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three mechanisms for accomplishing this: primitive expressions , cerned with, means of combination , by means of abstraction ,"
  },
  {
    "source_file": "section1.xml",
    "tag_type": "SECTION",
    "title": "The Elements of Programming",
    "parent_title": "Building Abstractions with Procedures Functions",
    "depth": 1,
    "paragraph_index": 2,
    "content": "In programming, we deal with two kinds of elements: and stuff that we want to manipulate, and procedures functions are descriptions of the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive procedures functions and should have methods for combining and abstracting procedures functions and data."
  },
  {
    "source_file": "section1.xml",
    "tag_type": "SECTION",
    "title": "The Elements of Programming",
    "parent_title": "Building Abstractions with Procedures Functions",
    "depth": 1,
    "paragraph_index": 3,
    "content": "In this chapter we will deal only with simple procedures functions . procedures functions to manipulate compound data as well."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "section1.xml",
    "tag_type": "SECTION",
    "title": "The Elements of Programming",
    "parent_title": "Building Abstractions with Procedures Functions",
    "depth": 1,
    "paragraph_index": 1,
    "content": "A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three mechanisms for accomplishing this: primitive expressions , cerned with, means of combination , by means of abstraction ,"
  },
  {
    "source_file": "section1.xml",
    "tag_type": "SECTION",
    "title": "The Elements of Programming",
    "parent_title": "Building Abstractions with Procedures Functions",
    "depth": 1,
    "paragraph_index": 2,
    "content": "In programming, we deal with two kinds of elements: and stuff that we want to manipulate, and procedures functions are descriptions of the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive procedures functions and should have methods for combining and abstracting procedures functions and data."
  },
  {
    "source_file": "section1.xml",
    "tag_type": "SECTION",
    "title": "The Elements of Programming",
    "parent_title": "Building Abstractions with Procedures Functions",
    "depth": 1,
    "paragraph_index": 3,
    "content": "In this chapter we will deal only with simple procedures functions . procedures functions to manipulate compound data as well."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 1,
    "content": "One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. JavaScript language. Imagine that you are sitting at a computer terminal. You type an expression , a statement , and the interpreter responds by displaying the result of its evaluating that expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 3,
    "content": "One kind of statement you might type is an expression statement, which consists of an expression followed by a semicolon. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number JavaScript with the program 486 486; the interpreter will respond by printing 486"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 4,
    "content": "Expressions representing numbers may be combined with an + or * ) to form a compound expression that represents the application of the procedure to those numbers. For example, (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Expressions representing numbers may be combined with operators (such + * ) to form a 137 + 349; 486 1000 - 334; 666 5 * 99; 495 10 / 4; 2.5 2.7 + 10; 12.7"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Expressions such as these, formed by combinations . The leftmost element in the list is called the operator , and the other elements are called operands . The arguments that are the values of the operands."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 7,
    "content": "Expressions such as these, which contain other expressions as components, are called combinations . operator symbol in the middle, and operand expressions to the left and right of it, are called operator combinations ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 8,
    "content": "The convention of placing the operator to the left of the operands is known as prefix notation , and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 9,
    "content": "A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested , that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 10,
    "content": "The convention of placing the operator between the operands is known as infix notation . It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be nested , that is, they can have operands that (3 * 5) + (10 - 6); 19 As usual, 3 * 5 + 10 / 2; stands for (3 * 5) + (10 / 2); We say that * and / have higher precedence than + and - . Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus, -6 1 - 5 / 2 * 4 + 3; stands for (1 - ((5 / 2) * 4)) + 3; We say that the operators + , - , * and / are left-associative ."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 11,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing , in which each long combination is written so that the operands are aligned vertically. The resulting"
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 12,
    "content": "There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as 57 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form 3 * 2 * (3 - 5 + 4) + 27 / 6 * 10; to visually separate the major components of the expression."
  },
  {
    "source_file": "subsection1.xml",
    "tag_type": "SUBSECTION",
    "title": "Expressions",
    "parent_title": "The Elements of Programming",
    "depth": 2,
    "paragraph_index": 13,
    "content": "Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, a statement typed by the user, evaluates the expression, statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop . read-evaluate-print loop . Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression. statement."
  }
]