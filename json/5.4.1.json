[{"id":"/sicpjs/5.4.1","tag":"TITLE","body":"5.4.1  \n    \n      \n      The Dispatcher and Basic Evaluation"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    The central element in the evaluator is the sequence of instructions beginning at\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":". \n    This corresponds to the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":"function\n    of the metacircular evaluator described in section ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":". When the controller starts at\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":",\n      \n    it evaluates the \n    component\n    specified by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":"\n    in the environment specified by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":". When evaluation is\n    complete, the controller will go to the entry point stored in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":", and the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":"\n    register will hold the value of the\n    component.\n    As with the metacircular\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":",\n    the structure of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":"\n    is a case analysis on the syntactic type of the\n    component\n    to be evaluated.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.4.1#footnote-1"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"\"eval_dispatch\",\n  test(list(op(\"is_literal\"), reg(\"comp\"))),\n  branch(label(\"ev_literal\")),\n  test(list(op(\"is_name\"), reg(\"comp\"))),\n  branch(label(\"ev_name\")),\n  test(list(op(\"is_application\"), reg(\"comp\"))),\n  branch(label(\"ev_application\")),\n  test(list(op(\"is_operator_combination\"), reg(\"comp\"))),\n  branch(label(\"ev_operator_combination\")),\n  test(list(op(\"is_conditional\"), reg(\"comp\"))),\n  branch(label(\"ev_conditional\")),\n  test(list(op(\"is_lambda_expression\"), reg(\"comp\"))),\n  branch(label(\"ev_lambda\")),\n  test(list(op(\"is_sequence\"), reg(\"comp\"))),\n  branch(label(\"ev_sequence\")),\n  test(list(op(\"is_block\"), reg(\"comp\"))),\n  branch(label(\"ev_block\")),\n  test(list(op(\"is_return_statement\"), reg(\"comp\"))),\n  branch(label(\"ev_return\")),\n  test(list(op(\"is_function_declaration\"), reg(\"comp\"))),\n  branch(label(\"ev_function_declaration\")),\n  test(list(op(\"is_declaration\"), reg(\"comp\"))),\n  branch(label(\"ev_declaration\")),\n  test(list(op(\"is_assignment\"), reg(\"comp\"))),\n  branch(label(\"ev_assignment\")),\n  go_to(label(\"unknown_component_type\")),"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Evaluating simple expressions","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Numbers and strings,\n    names,\n    and\n    lambda\n    expressions have no subexpressions to be evaluated. For these, the evaluator simply\n    places the correct value in the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" register and\n    continues execution at the entry point specified by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":". Evaluation of simple expressions is performed\n    by the following controller code:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"\"ev_literal\",\n  assign(\"val\", list(op(\"literal_value\"), reg(\"comp\"))),\n  go_to(reg(\"continue\")),\n\n\"ev_name\",\n  assign(\"val\", list(op(\"symbol_of_name\"), reg(\"comp\"), reg(\"env\"))),\n  assign(\"val\", list(op(\"lookup_symbol_value\"),\n                     reg(\"val\"), reg(\"env\"))),\n  go_to(reg(\"continue\")),\n\n\"ev_lambda\",\n  assign(\"unev\", list(op(\"lambda_parameter_symbols\"), reg(\"comp\"))),\n  assign(\"comp\", list(op(\"lambda_body\"), reg(\"comp\"))),\n  assign(\"val\", list(op(\"make_function\"),\n                     reg(\"unev\"), reg(\"comp\"), reg(\"env\"))),\n  go_to(reg(\"continue\")),"},{"body":"\n    Observe how\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_lambda"},{"body":"\n    uses the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":"\n    registers to hold the parameters and body of the lambda expression so\n    that they can be passed to the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_function"},{"body":"\n    operation, along with the environment in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":".\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"\n          Conditionals\n        ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n        As with the metacircular evaluator, syntactic forms are handled by selectively\n        evaluating fragments of the component. For a\n        \n\tconditional, we must evaluate the\n        predicate and decide, based on the value of predicate, whether to evaluate the\n        consequent or the alternative.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n        Before evaluating the predicate, we save the conditional itself, which is in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":", so that we can later extract the\n        consequent or alternative. To evaluate the predicate expression, we move it to\n        the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":" register and go to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":". The environment in the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register is already the correct one in\n        which to evaluate the predicate. However, we save\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" because we will need it later to\n        evaluate the consequent or the alternative. We set up\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" so that evaluation will resume at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_conditional_decide"},{"body":" after the predicate\n        has been evaluated. First, however, we save the old value of\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":", which we will need later in order\n        to return to the evaluation of the statement that is waiting for the value of\n        the conditional.\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"\"ev_conditional\",\n  save(\"comp\"), // save conditional for later\n  save(\"env\"),\n  save(\"continue\"),\n  assign(\"continue\", label(\"ev_conditional_decide\")),\n  assign(\"comp\", list(op(\"conditional_predicate\"), reg(\"comp\"))),\n  go_to(label(\"eval_dispatch\")), // evaluate the predicate"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n        When we resume at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_conditional_decide"},{"body":" after\n\tevaluating the predicate, we test whether it was true or false\n        and, depending on the result, place either the consequent or the alternative in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":" before going to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.4.1#footnote-2"},{"body":"\n\tNotice that restoring\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" here sets up\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" to have the correct environment\n\tand to continue at the right place to receive the value of the conditional.\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"\"ev_conditional_decide\",\n  restore(\"continue\"),\n  restore(\"env\"),\n  restore(\"comp\"),\n  test(list(op(\"is_falsy\"), reg(\"val\"))),\n  branch(label(\"ev_conditional_alternative\")),\n\"ev_conditional_consequent\",\n  assign(\"comp\", list(op(\"conditional_consequent\"), reg(\"comp\"))),\n  go_to(label(\"eval_dispatch\")),\n\"ev_conditional_alternative\",\n  assign(\"comp\", list(op(\"conditional_alternative\"), reg(\"comp\"))),\n  go_to(label(\"eval_dispatch\")),"}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"\n          Sequence Evaluation\n        ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n        The portion of the explicit-control evaluator beginning at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence"},{"body":", which handles\n\tsequences of statements, is analogous to the metacircular evaluator's\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_sequence"},{"body":" function.  \n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n        The entries at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence_next"},{"body":" and\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence_continue"},{"body":" form a loop that\n        successively evaluates each statement in a sequence.\n        The list of unevaluated\n        statements is kept in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":".\n        At ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence"},{"body":" we place the sequence of\n        statements to be evaluated in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":". If the\n        sequence is empty, we set ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":" and jump to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" via\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence_empty"},{"body":". Otherwise we start the\n        sequence-evaluation loop, first saving the value of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" on the stack, because\n        the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register will be used for local flow of control in the loop, and the original\n        value is needed for continuing after the statement sequence. Before evaluating\n        each statement, we check to see if there are additional statements to be evaluated\n        in the sequence. If so, we save the rest of the unevaluated statements (held in\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":") and the environment in which these must\n        be evaluated (held in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":") and call\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" to evaluate the statement,\n        which has been placed in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":". The\n        two saved registers are restored after this evaluation, at\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence_continue"},{"body":".\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n        The final statement in the sequence is handled differently, at the entry point\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence_last_statement"},{"body":". Since there are\n        no more statements to be evaluated after this one, we need not save\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":" or\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" before going to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":". The value of the whole\n        sequence is the value of the last statement, so after the evaluation of the last\n        statement there is nothing left to do except continue at the entry point that was\n        saved at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence"},{"body":".\n        Rather than setting up ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" to arrange\n        for ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" to return here and then\n        restoring ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" from the stack and\n        continuing at that entry point, we restore\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" from the stack before going to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":", so that\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":" will continue at that entry\n        point after evaluating the statement.\n      ","tag":"#text"}]},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"\"ev_sequence\",\n  assign(\"unev\", list(op(\"sequence_statements\"), reg(\"comp\"))),\n  test(list(op(\"is_empty_sequence\"), reg(\"unev\"))), \n  branch(label(\"ev_sequence_empty\")),\n  save(\"continue\"),\n\"ev_sequence_next\",\n  assign(\"comp\", list(op(\"first_statement\"), reg(\"unev\"))),\n  test(list(op(\"is_last_statement\"), reg(\"unev\"))),\n  branch(label(\"ev_sequence_last_statement\")),\n  save(\"unev\"),\n  save(\"env\"),\n  assign(\"continue\", label(\"ev_sequence_continue\")),\n  go_to(label(\"eval_dispatch\")),\n\"ev_sequence_continue\",\n  restore(\"env\"),\n  restore(\"unev\"),\n  assign(\"unev\", list(op(\"rest_statements\"), reg(\"unev\"))),\n  go_to(label(\"ev_sequence_next\")),\n\"ev_sequence_last_statement\",\n  restore(\"continue\"),\n  go_to(label(\"eval_dispatch\")),\n\n\"ev_sequence_empty\",\n  assign(\"val\", constant(undefined)),\n  go_to(reg(\"continue\")),"},{"tag":"TEXT","id":"#p9","child":[{"body":"\n        Unlike ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_sequence"},{"body":" in the metacircular\n        evaluator, ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence"},{"body":" does not need to check whether a return statement was\n        evaluated so as to terminate the sequence evaluation. The \"","tag":"#text"},{"body":"explicit\n        control","tag":"#text"},{"body":"\" in this evaluator allows a return statement to jump directly to\n        the continuation of the current function application without resuming the\n        sequence evaluation. Thus sequence evaluation does not need to be concerned\n        with returns, or even be aware of the existence of return statements in the\n        language. Because a return statement jumps out of the sequence-evaluation code,\n        the restores of saved registers at ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_sequence_continue"},{"body":"\n        won't be executed. We will see later how the return statement removes these values from the stack. \n      ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.4.1#footnote-link-1","child":[{"body":"In our controller, the dispatch is written as a sequence of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"branch"},{"body":"\n    instructions. Alternatively, it could have been written in a data-directed \n    style, which avoids\n    the need to perform sequential tests and\n    facilitates\n    the definition of new\n    component\n    types.\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.4.1#footnote-link-2","child":[{"body":"\n        In this chapter, we will use the function\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_falsy"},{"body":" to test the value of the predicate.\n        This allows us to write the consequent and alternative branches in the same\n        order as in a conditional, and simply fall through to the consequent\n        branch when the predicate holds. The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_falsy"},{"body":"\n        is declared as the opposite of the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_truthy"},{"body":" function used to test predicates of\n        conditionals in section ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":".","tag":"#text"}]}]