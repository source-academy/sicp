[{"id":"/sicpjs/prefaces96","tag":"TITLE","body":"Prefaces\n    \n      \n\tto Structure and Interpretation of Computer Programs, 19961984"},{"tag":"SUBHEADING","id":"#h1","child":[{"child":[{"body":"\n    Preface  to the Second Edition of SICP, 1996","tag":"#text"}]}]},{"tag":"EPIGRAPH","child":[{"body":"\n    Is it possible that software is not like anything else, that it\n    is meant to be discarded: that the whole point is to\n    always see it as a soap bubble?\n    ","tag":"#text"}],"author":" Alan J. Perlis"},{"tag":"TEXT","id":"#p1","child":[{"body":"\nThe material in this book has been the basis of MIT's entry-level\ncomputer science subject since 1980.  We had been teaching this\nmaterial for four years when the first edition was published, and\ntwelve more years have elapsed until the appearance of this second\nedition.  We are pleased that our work has been widely adopted and\nincorporated into other texts.  We have seen our students take the\nideas and programs in this book and build them in as the core of new\ncomputer systems and languages.  In literal realization of an ancient\nTalmudic pun, our students have become our builders.  We are lucky to\nhave such capable students and such accomplished builders.\n","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\nIn preparing this edition, we have incorporated hundreds of\nclarifications suggested by our own teaching experience and the\ncomments of colleagues at MIT and elsewhere.  We have redesigned\nmost of the major programming systems in the book, including\nthe generic-arithmetic system, the interpreters, the register-machine\nsimulator, and the compiler; and we have rewritten all the program\nexamples to ensure that any Scheme implementation conforming to\nthe IEEE Scheme standard (IEEE 1990) will be able to run the code.\n","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\nThis edition emphasizes several new themes.  The most important\nof these is the central role played by different approaches to\ndealing with time in computational models: objects with state,\nconcurrent programming, functional programming, lazy evaluation,\nand nondeterministic programming.  We have included new sections on\nconcurrency and nondeterminism, and we have tried to integrate this\ntheme throughout the book.\n","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\nThe first edition of the book closely followed the syllabus of our MIT\none-semester subject.  With all the new material in the second\nedition, it will not be possible to cover everything in a single\nsemester, so the instructor will have to pick and choose.  In our own\nteaching, we sometimes skip the section on logic programming\n(section ","tag":"#text"},{"tag":"REF","body":"4.4","href":"/sicpjs/4.4"},{"body":"),\nwe have students use the\nregister-machine simulator but we do not cover its implementation\n(section ","tag":"#text"},{"tag":"REF","body":"5.2","href":"/sicpjs/5.2"},{"body":"),\nand we give only a cursory overview of\nthe compiler\n(section ","tag":"#text"},{"tag":"REF","body":"5.5","href":"/sicpjs/5.5"},{"body":").\nEven so, this is still\nan intense course.  Some instructors may wish to cover only the first\nthree or four chapters, leaving the other material for subsequent\ncourses.\n","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\nThe World Wide Web site ","tag":"#text"},{"tag":"LINK","body":"of MIT Press","href":"https://mitpress.mit.edu/sites/default/files/sicp/index.html"},{"body":"\nprovides support for users of this book.\nThis includes programs from the book,\nsample programming assignments, supplementary materials,\nand downloadable implementations of the Scheme dialect of Lisp.\n","tag":"#text"}]},{"tag":"EPIGRAPH","child":[{}],"author":" Harold Abelson and Gerald Jay Sussman"},{"tag":"SUBHEADING","id":"#h2","child":[{"child":[{"body":"Preface to the First Edition of SICP, 1984","tag":"#text"}]}]},{"tag":"EPIGRAPH","child":[{"body":"\n    A computer is like a violin.  You can imagine a novice trying first a\n    phonograph and then a violin.  The latter, he says, sounds terrible.\n    That is the argument we have heard from our humanists and most of our\n    computer scientists.  Computer programs are good, they say, for\n    particular purposes, but they aren't flexible.  Neither is a violin,\n    or a typewriter, until you learn how to use it.\n    ","tag":"#text"}],"author":" Marvin Minsky, ","title":"\""},{"tag":"TEXT","id":"#p6","child":[{"body":"\"","tag":"#text"},{"body":"The Structure and Interpretation of Computer Programs","tag":"#text"},{"body":"\" is the\n    entry-level subject in computer science at the Massachusetts Institute\n    of Technology.  It is required of all students at MIT who major\n    in electrical engineering or in computer science, as one-fourth of the\n    \"","tag":"#text"},{"body":"common core curriculum,","tag":"#text"},{"body":"\" which also includes two subjects on\n    circuits and linear systems and a subject on the design of digital\n    systems.  We have been involved in the development of this subject\n    since 1978, and we have taught this material in its present form since\n    the fall of 1980 to between 600 and 700 students each year.  Most of\n    these students have had little or no prior formal training in\n    computation, although many have played with computers a bit and a few\n    have had extensive programming or hardware-design experience.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    Our design of this introductory computer-science subject reflects two\n    major concerns.  First, we want to establish the idea that a computer\n    language is not just a way of getting a computer to perform operations\n    but rather that it is a novel formal medium for expressing ideas about\n    methodology.  Thus, programs must be written for people to read, and\n    only incidentally for machines to execute.  Second, we believe that\n    the essential material to be addressed by a subject at this level is\n    not the syntax of particular programming-language constructs, nor\n    clever algorithms for computing particular functions efficiently, nor\n    even the mathematical analysis of algorithms and the foundations of\n    computing, but rather the techniques used to control the intellectual\n    complexity of large software systems.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    Our goal is that students who complete this subject should have a good\n    feel for the elements of style and the aesthetics of programming.\n    They should have command of the major techniques for controlling\n    complexity in a large system. They should be capable of reading a\n    50-page-long program, if it is written in an exemplary style. They\n    should know what not to read, and what they need not understand at any\n    moment.  They should feel secure about modifying a program, retaining\n    the spirit and style of the original author.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    These skills are by no means unique to computer programming.  The\n    techniques we teach and draw upon are common to all of engineering\n    design.  We control complexity by building abstractions that hide\n    details when appropriate.  We control complexity by establishing\n    conventional interfaces that enable us to construct systems by\n    combining standard, well-understood pieces in a \"","tag":"#text"},{"body":"mix and match","tag":"#text"},{"body":"\" way.\n    We control complexity by establishing new languages for describing a\n    design, each of which emphasizes particular aspects of the design and\n    deemphasizes others.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    Underlying our approach to this subject is our conviction that\n    \"","tag":"#text"},{"body":"computer science","tag":"#text"},{"body":"\" is not a science and that its significance has\n    little to do with computers.  The computer revolution is a revolution\n    in the way we think and in the way we express what we think.  The\n    essence of this change is the emergence of what might best be called\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"procedural epistemology","tag":"#text"}]},{"body":"—the study of the structure of\n    knowledge from an imperative point of view, as opposed to the more\n    declarative point of view taken by classical mathematical subjects.\n    Mathematics provides a framework for dealing precisely with notions of\n    \"","tag":"#text"},{"body":"what is.","tag":"#text"},{"body":"\"  Computation provides a framework for dealing precisely\n    with notions of \"","tag":"#text"},{"body":"how to.","tag":"#text"},{"body":"\"","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    In teaching our material we use a dialect of the programming language\n    Lisp.  We never formally teach the language, because we don't have to.\n    We just use it, and students pick it up in a few days.  This is one\n    great advantage of Lisp-like languages: They have very few ways of\n    forming compound expressions, and almost no syntactic structure.  All\n    of the formal properties can be covered in an hour, like the rules of\n    chess.  After a short time we forget about syntactic details of the\n    language (because there are none) and get on with the real\n    issues—figuring out what we want to compute, how we will decompose\n    problems into manageable parts, and how we will work on the parts.\n    Another advantage of Lisp is that it supports (but does not enforce)\n    more of the large-scale strategies for modular decomposition of\n    programs than any other language we know.  We can make procedural and\n    data abstractions, we can use higher-order functions to capture common\n    patterns of usage, we can model local state using assignment and data\n    mutation, we can link parts of a program with streams and delayed\n    evaluation, and we can easily implement embedded languages.  All of\n    this is embedded in an interactive environment with excellent support\n    for incremental program design, construction, testing, and debugging.\n    We thank all the generations of Lisp wizards, starting with John\n    McCarthy, who have fashioned a fine tool of unprecedented power and\n    elegance.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    Scheme, the dialect of Lisp that we use, is an attempt to bring\n    together the power and elegance of Lisp and Algol.  From Lisp we take\n    the metalinguistic power that derives from the simple syntax, the\n    uniform representation of programs as data objects, and the\n    garbage-collected heap-allocated data.  From Algol we take lexical\n    scoping and block structure, which are gifts from the pioneers of\n    programming-language design who were on the Algol committee.  We wish\n    to cite John Reynolds and Peter Landin for their insights into the\n    relationship of Church's lambda calculus to the structure of\n    programming languages.  We also recognize our debt to the\n    mathematicians who scouted out this territory decades before computers\n    appeared on the scene.  These pioneers include Alonzo Church, Barkley\n    Rosser, Stephen Kleene, and Haskell Curry.\n  ","tag":"#text"}]},{"tag":"EPIGRAPH","child":[{}],"author":" Harold Abelson and Gerald Jay Sussman"}]