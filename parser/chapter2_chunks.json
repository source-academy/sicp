[
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 1,
    "content": "We concentrated in chapter on computational processes and on the role of procedures functions in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine procedures functions to form compound procedures functions through composition, conditionals, and the use of parameters, and how to abstract procedures processes by using define . function declarations. We saw that a procedure function can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in procedures. functions. We also saw that higher-order procedures functions enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming."
  },
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 2,
    "content": "In this chapter we are going to look at more complex data. All the procedures functions in chapter operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter was on building abstractions by combining procedures functions to form compound procedures, functions, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form compound data ."
  },
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 3,
    "content": "Why do we want compound data in a programming language? For the same reasons that we want compound procedures: functions: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to define procedures declare functions enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language."
  },
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 4,
    "content": "Consider the task of designing a system to perform add-rat add_rat that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where add-rat add_rat would be implemented by two procedures functions (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could glue together a numerator and denominator to form a pair a compound data object that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit."
  },
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 5,
    "content": "The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called data abstraction . We will see how data abstraction makes programs much easier to design, maintain, and modify."
  },
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 6,
    "content": "The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a linear combination $ax+by$ . We might like to write a procedure function that would accept $a$ , $b$ , $x$ , and $y$ as arguments and return the value of $ax+by$ . This presents no difficulty if the arguments are to be numbers, because we can readily define the procedure declare the function linear_combination_example (define (linear-combination a b x y) (+ (* a x) (* b y))) function linear_combination(a, b, x, y) { return a * x + b * y; } linear_combination_example linear_combination(1, 2, 3, 4); But suppose we are not concerned only with numbers. Suppose we would like to express, in procedural terms, the idea that one can form describe a process that forms linear combinations whenever addition and multiplication are defined for rational numbers, complex numbers, polynomials, or whatever. We could express this as a procedure function of the form (define (linear-combination a b x y) (add (mul a x) (mul b y))) function linear_combination(a, b, x, y) { return add(mul(a, x), mul(b, y)); } where add and mul are not the primitive procedures functions + and * but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments a , b , x , and y . The key point is that the only thing linear-combination linear_combination should need to know about a , b , x , and y is that the procedures functions add and mul will perform the appropriate manipulations. From the perspective of the procedure function linear-combination , linear_combination , it is irrelevant what a , b , x , and y are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a procedure function such as linear-combination linear_combination to pass its arguments along to add and mul without having to know their detailed structure."
  },
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 7,
    "content": "We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound procedures, functions, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable abstraction barriers between different parts of a program."
  },
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 8,
    "content": "We will see that the key to forming compound data is that a programming language should provide some kind of glue so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special data operations at all, only procedures. functions. This will further blur the distinction between procedure function and data, which was already becoming tenuous toward the end of chapter . We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of closure that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as conventional interfaces for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure."
  },
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 9,
    "content": "We will then augment the representational power of our language by introducing symbolic expressions data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information."
  },
  {
    "source_file": "chapter2.xml",
    "tag_type": "CHAPTER",
    "title": "Building Abstractions with Data",
    "parent_title": null,
    "depth": 0,
    "paragraph_index": 10,
    "content": "Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement generic operations , which must handle many different types of data. Maintaining modularity in the presence of generic operations requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce data-directed programming as a technique that allows individual data representations to be designed in isolation and then combined additively (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 1,
    "content": "As we have seen, pairs provide a primitive glue that we can use to construct compound data objects. Figure Figure shows a standard way to visualize a in this case, the pair formed by (cons 1 2) . pair(1, 2) . In this representation, which is called box-and-pointer notation , each object is shown as a pointer to a box. The box for a primitive object contains a representation of the object. For example, the box for a number contains a numeral. The box for a pair is actually a double box, the left part containing (a pointer to) the car of the pair and the right part containing the cdr . In this representation, which is called box-and-pointer notation , each compound object is shown as a pointer to a box. The box for a pair has two parts, the left part containing the head of the pair and the right part containing the tail."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 2,
    "content": "We have already seen that cons pair can be used to combine not only numbers but pairs as well. (You made use of this fact, or should have, in doing exercises and .) As a consequence, pairs provide a universal building block from which we can construct all sorts of data structures. Figure Figure shows two ways to use pairs to combine the numbers 1, 2, 3, and 4. Two ways to combine 1, 2, 3, and 4 using pairs. Two ways to combine 1, 2, 3, and 4 using pairs."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 3,
    "content": "The ability to create pairs whose elements are pairs is the essence of list structure s importance as a representational tool. We refer to this ability as the closure property of cons . pair . In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation. hierarchical structures structures made up of parts, which themselves are made up of parts, and so on."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 4,
    "content": "From the outset of chapter , we ve made essential use of closure in dealing with procedures, functions, because all but the very simplest programs rely on the fact that the elements of a combination can themselves be combinations. In this section, we take up the consequences of closure for compound data. We describe some conventional techniques for using pairs to represent sequences and trees, and we exhibit a graphics language that illustrates closure in a vivid way."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 1,
    "content": "As we have seen, pairs provide a primitive glue that we can use to construct compound data objects. Figure Figure shows a standard way to visualize a in this case, the pair formed by (cons 1 2) . pair(1, 2) . In this representation, which is called box-and-pointer notation , each object is shown as a pointer to a box. The box for a primitive object contains a representation of the object. For example, the box for a number contains a numeral. The box for a pair is actually a double box, the left part containing (a pointer to) the car of the pair and the right part containing the cdr . In this representation, which is called box-and-pointer notation , each compound object is shown as a pointer to a box. The box for a pair has two parts, the left part containing the head of the pair and the right part containing the tail."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 2,
    "content": "We have already seen that cons pair can be used to combine not only numbers but pairs as well. (You made use of this fact, or should have, in doing exercises and .) As a consequence, pairs provide a universal building block from which we can construct all sorts of data structures. Figure Figure shows two ways to use pairs to combine the numbers 1, 2, 3, and 4. Two ways to combine 1, 2, 3, and 4 using pairs. Two ways to combine 1, 2, 3, and 4 using pairs."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 3,
    "content": "The ability to create pairs whose elements are pairs is the essence of list structure s importance as a representational tool. We refer to this ability as the closure property of cons . pair . In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation. hierarchical structures structures made up of parts, which themselves are made up of parts, and so on."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 4,
    "content": "From the outset of chapter , we ve made essential use of closure in dealing with procedures, functions, because all but the very simplest programs rely on the fact that the elements of a combination can themselves be combinations. In this section, we take up the consequences of closure for compound data. We describe some conventional techniques for using pairs to represent sequences and trees, and we exhibit a graphics language that illustrates closure in a vivid way."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 1,
    "content": "As we have seen, pairs provide a primitive glue that we can use to construct compound data objects. Figure Figure shows a standard way to visualize a in this case, the pair formed by (cons 1 2) . pair(1, 2) . In this representation, which is called box-and-pointer notation , each object is shown as a pointer to a box. The box for a primitive object contains a representation of the object. For example, the box for a number contains a numeral. The box for a pair is actually a double box, the left part containing (a pointer to) the car of the pair and the right part containing the cdr . In this representation, which is called box-and-pointer notation , each compound object is shown as a pointer to a box. The box for a pair has two parts, the left part containing the head of the pair and the right part containing the tail."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 2,
    "content": "We have already seen that cons pair can be used to combine not only numbers but pairs as well. (You made use of this fact, or should have, in doing exercises and .) As a consequence, pairs provide a universal building block from which we can construct all sorts of data structures. Figure Figure shows two ways to use pairs to combine the numbers 1, 2, 3, and 4. Two ways to combine 1, 2, 3, and 4 using pairs. Two ways to combine 1, 2, 3, and 4 using pairs."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 3,
    "content": "The ability to create pairs whose elements are pairs is the essence of list structure s importance as a representational tool. We refer to this ability as the closure property of cons . pair . In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation. hierarchical structures structures made up of parts, which themselves are made up of parts, and so on."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 4,
    "content": "From the outset of chapter , we ve made essential use of closure in dealing with procedures, functions, because all but the very simplest programs rely on the fact that the elements of a combination can themselves be combinations. In this section, we take up the consequences of closure for compound data. We describe some conventional techniques for using pairs to represent sequences and trees, and we exhibit a graphics language that illustrates closure in a vivid way."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 1,
    "content": "As we have seen, pairs provide a primitive glue that we can use to construct compound data objects. Figure Figure shows a standard way to visualize a in this case, the pair formed by (cons 1 2) . pair(1, 2) . In this representation, which is called box-and-pointer notation , each object is shown as a pointer to a box. The box for a primitive object contains a representation of the object. For example, the box for a number contains a numeral. The box for a pair is actually a double box, the left part containing (a pointer to) the car of the pair and the right part containing the cdr . In this representation, which is called box-and-pointer notation , each compound object is shown as a pointer to a box. The box for a pair has two parts, the left part containing the head of the pair and the right part containing the tail."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 2,
    "content": "We have already seen that cons pair can be used to combine not only numbers but pairs as well. (You made use of this fact, or should have, in doing exercises and .) As a consequence, pairs provide a universal building block from which we can construct all sorts of data structures. Figure Figure shows two ways to use pairs to combine the numbers 1, 2, 3, and 4. Two ways to combine 1, 2, 3, and 4 using pairs. Two ways to combine 1, 2, 3, and 4 using pairs."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 3,
    "content": "The ability to create pairs whose elements are pairs is the essence of list structure s importance as a representational tool. We refer to this ability as the closure property of cons . pair . In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation. hierarchical structures structures made up of parts, which themselves are made up of parts, and so on."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 4,
    "content": "From the outset of chapter , we ve made essential use of closure in dealing with procedures, functions, because all but the very simplest programs rely on the fact that the elements of a combination can themselves be combinations. In this section, we take up the consequences of closure for compound data. We describe some conventional techniques for using pairs to represent sequences and trees, and we exhibit a graphics language that illustrates closure in a vivid way."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 1,
    "content": "As we have seen, pairs provide a primitive glue that we can use to construct compound data objects. Figure Figure shows a standard way to visualize a in this case, the pair formed by (cons 1 2) . pair(1, 2) . In this representation, which is called box-and-pointer notation , each object is shown as a pointer to a box. The box for a primitive object contains a representation of the object. For example, the box for a number contains a numeral. The box for a pair is actually a double box, the left part containing (a pointer to) the car of the pair and the right part containing the cdr . In this representation, which is called box-and-pointer notation , each compound object is shown as a pointer to a box. The box for a pair has two parts, the left part containing the head of the pair and the right part containing the tail."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 2,
    "content": "We have already seen that cons pair can be used to combine not only numbers but pairs as well. (You made use of this fact, or should have, in doing exercises and .) As a consequence, pairs provide a universal building block from which we can construct all sorts of data structures. Figure Figure shows two ways to use pairs to combine the numbers 1, 2, 3, and 4. Two ways to combine 1, 2, 3, and 4 using pairs. Two ways to combine 1, 2, 3, and 4 using pairs."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 3,
    "content": "The ability to create pairs whose elements are pairs is the essence of list structure s importance as a representational tool. We refer to this ability as the closure property of cons . pair . In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation. hierarchical structures structures made up of parts, which themselves are made up of parts, and so on."
  },
  {
    "source_file": "section2.xml",
    "tag_type": "SECTION",
    "title": "Hierarchical Data and the Closure Property",
    "parent_title": "Building Abstractions with Data",
    "depth": 1,
    "paragraph_index": 4,
    "content": "From the outset of chapter , we ve made essential use of closure in dealing with procedures, functions, because all but the very simplest programs rely on the fact that the elements of a combination can themselves be combinations. In this section, we take up the consequences of closure for compound data. We describe some conventional techniques for using pairs to represent sequences and trees, and we exhibit a graphics language that illustrates closure in a vivid way."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 1,
    "content": "The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) [[1, [2, null]], [3, [4, null]]] constructed by (cons (list 1 2) (list 3 4)) pair(list(1, 2), list(3, 4)); as a list of three items, the first of which is itself a list, (1 2) . Indeed, this is suggested by the form in which the result is printed by the interpreter. [1, [2, null]] . Figure Figure shows the representation of this structure in terms of pairs. Structure formed by (cons (list 1 2) (list 3 4)) . Structure formed by pair(list(1, 2), list(3, 4)) ."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 2,
    "content": "Another way to think of sequences whose elements are sequences is as trees . The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure Figure shows the structure in figure figure viewed as a tree. The list structure in figure viewed as a tree. The list structure in figure viewed as a tree."
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 3,
    "content": "Recursion length length procedure function of section with the count-leaves count_leaves procedure, function, which returns the total number of leaves of a tree: tree_x (define x (cons (list 1 2) (list 3 4))) const x = pair(list(1, 2), list(3, 4)); length_tree_x tree_x 3 (length x) 3 length(x); 3 count_leaves_tree_x tree_x count_leaves 4 (count-leaves x) 4 count_leaves(x); 4 list_x_x tree_x 3 (list x x) (((1 2) 3 4) ((1 2) 3 4)) list(x, x); length(head(tail(list(x, x)))); list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4)) length_list_x_x tree_x 2 (length (list x x)) 2 length(list(x, x)); 2 count_leaves_list_x_x tree_x count_leaves 8 (count-leaves (list x x)) 8 count_leaves(list(x, x)); 8"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 4,
    "content": "To implement count-leaves , count_leaves , recall the recursive plan for computing length : length : Length The length of a list x is 1 plus length the length of the cdr tail of x . Length The length of the empty list is 0. Count-leaves The function count_leaves is similar. The value for the empty list is the same: Count-leaves count_leaves of the empty list is 0. But in the reduction step, where we strip off the car head of the list, we must take into account that the car head may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is Count-leaves count_leaves of a tree x is count-leaves count_leaves of the car head of x plus count-leaves count_leaves of the cdr tail of x . Finally, by taking car s head s we reach actual leaves, so we need another base case: Count-leaves count_leaves of a leaf is 1. To aid in writing recursive procedures functions on trees, Scheme our JavaScript environment provides the primitive predicate pair? , is_pair , which tests whether its argument is a pair. Here is the complete procedure: function: count_leaves count_leaves_example 4 (define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x)))))) function count_leaves(x) { return is_null(x) ? 0 : ! is_pair(x) ? 1 : count_leaves(head(x)) + count_leaves(tail(x)); } count_leaves_example (count-leaves (cons (list 1 2) (list 3 4))) count_leaves(pair(list(1, 2), list(3, 4)));"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 5,
    "content": "Just as map is a powerful abstraction for dealing with sequences, map together with recursion is a powerful abstraction for dealing with trees. For instance, the scale-tree scale_tree procedure, function, analogous to scale-list scale_list of section , takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for scale-tree scale_tree is similar to the one for count-leaves : count_leaves : scale_tree scale_tree_example 10 (define (scale-tree tree factor) (cond ((null? tree) nil) ((not (pair? tree)) (* tree factor)) (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))))) function scale_tree(tree, factor) { return is_null(tree) ? null : ! is_pair(tree) ? tree * factor : pair(scale_tree(head(tree), factor), scale_tree(tail(tree), factor)); } scale_tree_example scale_tree (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) (10 (20 (30 40) 50) (60 70)) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); list(10, list(20, list(30, 40), 50), list(60, 70))"
  },
  {
    "source_file": "subsection2.xml",
    "tag_type": "SUBSECTION",
    "title": "Hierarchical Structures",
    "parent_title": "Hierarchical Data and the Closure Property",
    "depth": 2,
    "paragraph_index": 6,
    "content": "Another way to implement scale-tree scale_tree is to regard the tree as a sequence of sub-trees and use map . map . We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor: scale_tree_example_2 (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10); head(scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10)); scale_tree_with_map scale_tree_example_2 10 (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) function scale_tree(tree, factor) { return map(sub_tree => is_pair(sub_tree) ? scale_tree(sub_tree, factor) : sub_tree * factor, tree); } Many tree operations can be implemented by similar combinations of sequence operations and recursion."
  }
]