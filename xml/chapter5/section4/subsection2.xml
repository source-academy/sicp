<SUBSECTION>
  <NAME>
    Return Statements and Tail Recursion
  </NAME>

  <LABEL NAME="sec:tail-recursion-return"/>

  <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>tail recursion<OPEN/></SUBINDEX></INDEX>
  <INDEX>tail recursion<SUBINDEX>explicit-control evaluator and<OPEN/></SUBINDEX></INDEX>
  <TEXT>
    In chapter<SPACE/>1 we said that the process described by a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    such as
    <SNIPPET EVAL="no">
      <SCHEME>
(define (sqrt-iter guess x)
(if (good-enough? guess x)
guess
(sqrt-iter (improve guess x)
      x)))
      </SCHEME>
      <JAVASCRIPT>
function sqrt_iter(guess, x) {
    return is_good_enough(guess, x)
           ? guess
           : sqrt_iter(improve(guess, x), x);
}
      </JAVASCRIPT>
    </SNIPPET>
    is an iterative process.  Even though the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is syntactically recursive (defined in terms of itself), it is not logically
    necessary for an evaluator to save information in passing from one call to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to the next.<FOOTNOTE>We saw in
    section<SPACE/><REF NAME="sec:designing-register-machines"/> how to
    implement such a process with a register machine that had no stack; the
    state of the process was stored in a fixed set of registers.</FOOTNOTE> An
    evaluator that can execute a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    such as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    without requiring increasing storage as the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    continues to call itself is called a 
    <INDEX>tail-recursive evaluator</INDEX>
    <EM>tail-recursive</EM> evaluator.  
    <INDEX>metacircular evaluator for JavaScript<SUBINDEX>no tail recursion in</SUBINDEX></INDEX>
    <INDEX>tail recursion<SUBINDEX>metacircular evaluator and</SUBINDEX></INDEX>
    <SPLIT>
      <SCHEME>
        The metacircular implementation of the evaluator in chapter<SPACE/>4
        does not specify whether the evaluator is tail-recursive, because that
        evaluator inherits its mechanism for saving state from the underlying
        Scheme. With the explicit-control evaluator, however, we can trace
        through the evaluation process to see when procedure calls cause a net
        accumulation of information on the stack.
      </SCHEME>
      <JAVASCRIPT>
        The implementation of the metacircular evaluator in chapter<SPACE/>4 is
        not tail-recursive. The reason for this is found in the handling of
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> as an operator that creates
        a return value object and inspecting the result of a function call to
        see if it is such an object or not.
        If the result of a function is a return value object, its content
        is the return value of the function. 
        Otherwise, the return value is <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>.
        Both the construction of the return value object, and the eventual inspection of
        the result of the function call are deferred operations, which lead to an
        accumulation of information on the stack.
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
        Our evaluator is tail-recursive, because in order to evaluate the final
        expression of a sequence we transfer directly to
        <SCHEMEINLINE>eval-dispatch</SCHEMEINLINE> without saving any
        information on the stack. Hence, evaluating the final expression in a
        sequence<EMDASH/>even if it is a procedure call (as in
        <SCHEMEINLINE>sqrt-iter</SCHEMEINLINE>, where the
        <SCHEMEINLINE>if</SCHEMEINLINE> expression, which is the last expression
        in the procedure body, reduces to a call to
        <SCHEMEINLINE>sqrt-iter</SCHEMEINLINE>)<EMDASH/>will not cause any
        information to be accumulated on the stack.
      </SCHEME>
      <JAVASCRIPT>
        Our explicit-control evaluator is tail-recursive, because it avoids the accumulation
        of information such as in the metacircular evaluator. When we
        evaluate a return statement at <JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE>, we
        first remove anything saved by the current function on the stack, and
        restore <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> to the value saved
        at <JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE> in the beginning
        of the function call. 
        Thus, when we 
        proceed to evaluate the return expression, the information 
        accumulated on the stack is the same as just before the
        call to the function whose return value we are about to compute.
        We then
        place the return expression in <JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE>
        and transfer directly to
        <JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE> without any additional saves.<!--
   --></JAVASCRIPT><!-- 
 --></SPLIT><FOOTNOTE>This implementation of tail
        recursion <SPLITINLINE><SCHEME>in <SCHEMEINLINE>ev-sequence</SCHEMEINLINE></SCHEME></SPLITINLINE> is one variety of
        a well-known optimization technique used by many compilers. In compiling
        a <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        that ends with a <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        call, one can replace the call by a jump to the called
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><APOS/>s
        entry point.
        Building this strategy into the interpreter, as we have done in this section, provides the optimization uniformly throughout the language.
      </FOOTNOTE>

      <TEXT>
        <SPLIT>
          <SCHEME>
          If we did not think to take advantage of the fact that it was unnecessary to
          save information in this case, we might have implemented
          <SCHEMEINLINE>eval-sequence</SCHEMEINLINE>
          by treating all the expressions in a sequence in the same way<EMDASH/>saving
          the registers, evaluating the expression, returning to restore the registers,
          and repeating this until all the expressions have been
          evaluated:<FOOTNOTE>We can define
          <SCHEMEINLINE>no-more-exps?</SCHEMEINLINE>
          as follows:
          <SNIPPET EVAL="no">
            <SCHEME>
              (define (no-more-exps? seq) (null? seq))
            </SCHEME>
          </SNIPPET></FOOTNOTE>
          <INDEX><DECLARATION>ev-sequence</DECLARATION><SUBINDEX>without tail recursion</SUBINDEX></INDEX>
          <SNIPPET EVAL="no">
            <SCHEME>
            ev-sequence
            (test (op no-more-exps?) (reg unev))
            (branch (label ev-sequence-end))
            (assign exp (op first-exp) (reg unev))
            (save unev)
            (save env)
            (assign continue (label ev-sequence-continue))
            (goto (label eval-dispatch))
            ev-sequence-continue
            (restore env)
            (restore unev)
            (assign unev (op rest-exps) (reg unev))
            (goto (label ev-sequence))
            ev-sequence-end
            (restore continue)
            (goto (reg continue))
            </SCHEME>
          </SNIPPET>

        This may seem like a minor change to our previous code for evaluation of
        a sequence: The only difference is that we go through the save-restore
        cycle for the last expression in a sequence as well as for the others.
        The interpreter will still give the same value for any expression. But
        this change is fatal to the tail-recursive implementation, because we
        must now return after evaluating the final expression in a sequence in
        order to undo the (useless) register saves. These extra saves will
        accumulate during a nest of procedure calls. Consequently, processes
        such as <SCHEMEINLINE>sqrt-iter</SCHEMEINLINE> will require space
        proportional to the number of iterations rather than requiring constant
        space.
          </SCHEME>
      <JAVASCRIPT>
        Let us consider an implementation of the handling of
        return statements in the spirit of
        the metacircular evaluator. In ev_return, we evaluate the return
        expression, place the result in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, and then continue at
        <JAVASCRIPTINLINE>ev_make_return_value</JAVASCRIPTINLINE> where a return
        value object is created. 
        
        For simplicity, assume that a function body does not continue once a
        return statement has been
        evaluated, and that all saves to the stack in the function body have
        been restored when the body is fully evaluated, meaning there is no need
        to use our marker trick. 

        In this design <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> installs
        a continuation
        <JAVASCRIPTINLINE>check_return_value</JAVASCRIPTINLINE>, and every function
        call will eventually arrive here after its complete evaluation.
        At <JAVASCRIPTINLINE>check_return_value</JAVASCRIPTINLINE>, we check
        whether the function's return value stored in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> 
        is a return value object or not. If it is, we extract the contents from the
        object and place it in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>. Otherwise,
        the function did not return explicitly so we must assign
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> to
        <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>. We then restore
        <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> and jump to the
        <QUOTE>final</QUOTE> continuation, which was saved in
        <JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>.
          <SNIPPET EVAL="no">
            <JAVASCRIPT>
"ev_return", 
      assign("comp", list(op("return_expression"), reg("comp"))),
      assign("continue", label("ev_make_return_value")),
      go_to(label("eval_dispatch")), // evaluate the return expression

"ev_make_return_value",
      // wrap contents of val in return value object 
      assign("val", list(op("ev_make_return_value"), reg("val"))), 
      restore("continue"),
      go_to(reg("continue")), 

"compound_apply",
      ... // as before (first 4 lines)
      assign("continue", label("check_for_explicit_return")), // install return handler
      go_to(label("eval_dispatch")),

"check_for_explicit_return",
      test(list(op("is_return_value"), reg("val"))),
      branch(label("explicit_return")),
      assign("val", constant(undefined)),
      go_to(label("return_from_function")),

"explicit_return",
      // extract return value from wrapper
      assign("val", list(op("return_value_content"), reg("val"))), 
      
"return_from_function",
      restore("continue"),
      go_to(reg("continue")), // jump to final continuation 
            </JAVASCRIPT>
          </SNIPPET>

          This design is not tail-recursive as it introduces two deferred
          operations:
          <JAVASCRIPTINLINE>ev_make_return_value</JAVASCRIPTINLINE> and
          <JAVASCRIPTINLINE>check_for_explicit_return</JAVASCRIPTINLINE>.
          The cost of these deferred operations will materialise on the stack through
          saves of <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>.
          For example, assigning
          <JAVASCRIPTINLINE>check_for_explicit_return</JAVASCRIPTINLINE> to
          <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> requires us to store its
          previous value, the 
          final continuation of the function call, on the stack during the
          evaluation of its body. This save took place in <JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>.
          Without <JAVASCRIPTINLINE>check_for_explicit_return</JAVASCRIPTINLINE>, this value
          could have been restored in <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE>.
          Similar reasoning applies to the assignment of <JAVASCRIPTINLINE>ev_make_return_value</JAVASCRIPTINLINE>
          to <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> in <JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE>.
          

          These stores will accumulate during a nest of
          function calls. Consequently, processes such as
          <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE> would require space
          proportional to the number of iterations rather than requiring
          constant space. 
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>
  <TEXT>
    This difference can be significant. For example,
    <INDEX>iterative process<SUBINDEX>implemented by <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE> call</SUBINDEX></INDEX>
    with tail recursion, an infinite loop can be expressed using only the
    <SPLITINLINE>
      <SCHEME>procedure-call mechanism:</SCHEME>
      <JAVASCRIPT>function-call and return mechanisms:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      (define (count n)
      (newline)
      (display n)
      (count (+ n 1)))
      </SCHEME>
      <JAVASCRIPT>
function count(n) {
    display(n);
    return count(n + 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Without tail recursion, such a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    would eventually run out of stack space, and expressing a true iteration
    would require some control mechanism other than
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call.
  </TEXT>

  <SPLIT>
    <JAVASCRIPT>
      <TEXT>
        Because our explicit-control evaluator does not use a special return value
        object, we do not introduce any associated deferred operations.
        Our <JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE> continuation from section<SPACE/>5.4.1 is very
        similar to <JAVASCRIPTINLINE>check_for_explicit_return</JAVASCRIPTINLINE> in
        the alternative design explored above.
        The reason why <JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE>
        does not lead to an accumulation
        of space is because it stored on the stack <EM>after</EM> the
        marker. This means that the
        <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE> instruction will
        remove this continuation from the stack before evaluating the return
        expression. In other words: when we know that the check is not needed,
        we remove it along with the stack space it occupied. 
        
        Because the <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE> is part
        of <JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE>, our JavaScript
        implementation is tail-recursive only in the presence of an explicit
        return statement. Without it,
        one save of <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> 
        is needed per function call to ensure its eventual arrival at
        <JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE> to store 
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> in the
        <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> register. Thus, removing
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> from the <JAVASCRIPTINLINE>count</JAVASCRIPTINLINE>
        function above will cause it to eventually run out of stack space.
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>

    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>tail recursion<CLOSE/></SUBINDEX></INDEX>
    <INDEX>tail recursion<SUBINDEX>explicit-control evaluator and<CLOSE/></SUBINDEX></INDEX>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>sequences of statements<CLOSE/></SUBINDEX></INDEX>
  </TEXT>
</SUBSECTION>
