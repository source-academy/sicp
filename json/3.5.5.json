[{"id":"/sicpjs/3.5.5","tag":"TITLE","body":"3.5.5  \n    Modularity of Functional Programs and Modularity of Objects"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    As we saw in section ","tag":"#text"},{"tag":"REF","body":"3.1.2","href":"/sicpjs/3.1.2"},{"body":", one of\n    the major benefits of introducing assignment is that we can increase the\n    modularity of our systems by encapsulating, or \"","tag":"#text"},{"body":"hiding,","tag":"#text"},{"body":"\" parts\n    of the state of a large system within local variables.  Stream models can\n    provide an equivalent modularity without the use of assignment.  As an\n    illustration, we can reimplement the\n    \n    Monte Carlo estimation\n    of ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":", which we examined in\n    section ","tag":"#text"},{"tag":"REF","body":"3.1.2","href":"/sicpjs/3.1.2"},{"body":", from a\n    stream-processing point of view.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The key modularity issue was that we wished to hide the internal state\n    of a random-number generator from programs that used random numbers.\n    We began with a\n    function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"rand_update"},{"body":",\n      \n    whose successive values furnished our supply of random numbers, and used\n    this to produce a random-number generator:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":18,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFZMChslAIKgBuApgE4CeoAzgJYC2ADgDamjkCGAdgCYD6AVya9OAF3YAzQdwDGYugHtuoWYuaCJNUJ1DdBDAEYU8YSeXWgADKAAUdOS0H0yASlBjFoAExWrGADYrABYATisARhQIu10WTnIAc3YmckZSV1NQc0tdYk4ndgAPUENqBkEWBVZKB0TQOjFQAHdGgAsdVWUaMR4mzgAaLM5eXjrOtW4evtKBnT4PNtIVXoBrcbEljlIGTgdeE3xFSVAx4jox7nrG0upN9niklLSGUjRQAHV2Z1JeBqaluR2FlJIpyA0WE4elwFMpQMoWJQ5jw-rwvNxFE1ZPFGPNqFlpgoenRZAVQKlFEwKApSDQ0NhJj1QAxQABeHx+QIhcJRCIAblADO6-TZoAiESsKAwEQw3mCGD5QqmTUMooi3hQ8sV2GkclhKi4fCEInEpFsRXcAG9sKBbdsxIJyCpbLoAFSgEoAalK7gApMzFQBfXCMpqGtEMfgOG7s9WawIAdgAHKFtbr5EoVLtVqR+OHbFabXa2E0Suzw+oo9xGoq7fbHc73KyAHyga11judsscFHG0QSc2uWudkf1p0e4ej0CBoNKpnh0XZ3P5oe4MY0VicSi2Fer9eb7e7xX7+KHlEFodAA","body":"function make_rand() {\n    let x = random_init;\n    return () => {\n               x = rand_update(x);\n               return x;\n           };\n}\nconst rand = make_rand(); "}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    In the stream formulation there is no random-number generator ","tag":"#text"},{"tag":"EM","child":[{"body":"per\n    se","tag":"#text"}]},{"body":", just a stream of random numbers produced by successive calls to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"rand_update"},{"body":":\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":18,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFZMChslAIKgBuApgE4CeoAzgJYC2ADgDamjkCGAdgCYD6AVya9OAF3YAzQdwDGYugHtuoWYuaCJNUJ1DdBDAEYU8YSeXWgADKAAUdOS0H0yASlBjFoAExWrGADYrABYATisARhQIu10WTnIAc3YmckZSV1NQc0tdYk4ndgAPUENqBkEWBVZKB0TQOjFQAHdGgAsdVWUaMR4mzgAaLM5eXjrOtW4evtKBnT4PNtIVXoBrcbEljlIGTgdeE3xFSVAx4jox7nrG0upN9niklLSGUjRQAHV2Z1JeBqaluR2FlJIpyA0WE4elwFMpQMoWJQ5jw-rwvNxFE1ZPFGPNqFlpgoenRZAVQKlFEwKApSDQ0NhJj1QAxQABeHx+QIhcJRCIAblADO6-TZoAiESsKAwEQw3mCGD5QqmTUMooi3hQ8sV2GkclhKi4fCEInEpFsRXcAG9sKBbdsxIJyCpbLoAFSgEoAalK7gApMzFQBfXCMpqGtEMfgOG7s9WawIAdgAHKFtaGOCj1Px9EYKNpWTa7Uw9uRbOGs9GxEM7TXbbZ3KyAHy0MRAziR3ZMMso42iCRzcuRnPGcg0VyubWkfIsfjQ0jt7t8LPDvNzDAToA","body":"const random_numbers =\n    pair(random_init,\n         () => stream_map(rand_update, random_numbers)); "},{"body":"\n    We use this to construct the stream of outcomes of the Cesàro\n    experiment performed on consecutive pairs in the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"random_numbers"},{"body":"\n    stream:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":26,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFZMChslAIKgBuApgE4CeoAzgJYC2ADgDamjkCGAdgCYD6AVya9OAF3YAzQdwDGYugHtuoWYuaCJNUJ1DdBDAEYU8YSeXWgADKAAUdOS0H0yASlBjFoAExWrGADYrABYATisARhQIu10WTnIAc3YmckZSV1NQc0tdYk4ndgAPUENqBkEWBVZKB0TQOjFQAHdGgAsdVWUaMR4mzgAaLM5eXjrOtW4evtKBnT4PNtIVXoBrcbEljlIGTgdeE3xFSVAx4jox7nrG0upN9niklLSGUjRQAHV2Z1JeBqaluR2FlJIpyA0WE4elwFMpQMoWJQ5jw-rwvNxFE1ZPFGPNqFlpgoenRZAVQKlFEwKApSDQ0NhJj1QAxQABeHx+QIhcJRCIAblADO6-TZoAiESsKAwEQw3mCGD5QqmTUMooi3hQ8sV2GkclhKi4fCEInEpFsRXcAG9sKBbdsxIJyCpbLoAFSgEoAalK7gApMzFQBfXCMpqGtEMfgOG7s9WawIAdgAHKFtaGOCj1Px9EYKNpWTa7Uw9uRbOGs9GxEM7TXbbZ3KyAHy0MRAziR3ZMMso42iCRzcuRnPGcg0VyubW6+RKFSJWS8F1zQxWwu2oEOp2lNms9k2AD8nQAXKA5wvDMjQP7l0HcFP9czOEx+DRBLJZLSXKR+MW6KPbJI5jHUBrRrddHRUH9S0kWwlhGWwxzmWCF2hUh234Xo6BYeDx1cata3wmt6zZZtO2fV93xoT9vxLGhbFXAiGIYgD6MY1i7RQtCMKwjjIy47CcJvdMxjSWQ2jYMRn1bVCWQLGtSJfN8PzoMhqN-WiywiAdvAbZtTw0rSGx3MU8LY0zB2zAwRzHbVSHyFhJLbBhbGEkkxNICSeLmXwJyAA","body":"function map_successive_pairs(f, s) {\n    return pair(f(head(s), head(stream_tail(s))),\n                () => map_successive_pairs(\n                          f,\n                          stream_tail(stream_tail(s))));\n}\nconst dirichlet_stream =\n    map_successive_pairs((r1, r2) => gcd(r1, r2) === 1,\n                         random_numbers); "},{"body":"\n    The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"dirichlet_stream"},{"body":"\n    is now fed to a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"monte_carlo"},{"body":"function,\n    which produces a stream of estimates of probabilities.  The results are then\n    converted into a stream of estimates of ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":".\n    This version of the program doesn't need a parameter telling how many\n    trials to perform.  Better estimates of ","tag":"#text"},{"body":"$\\pi$","tag":"LATEX"},{"body":"\n    (from performing more experiments) are obtained by looking farther into the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pi"},{"body":" stream:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":36,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFZMChslAIKgBuApgE4CeoAzgJYC2ADgDamjkCGAdgCYD6AVya9OAF3YAzQdwDGYugHtuoWYuaCJNUJ1DdBDAEYU8YSeXWgADKAAUdOS0H0yASlBjFoAExWrGADYrABYATisARhQIu10WTnIAc3YmckZSV1NQc0tdYk4ndgAPUENqBkEWBVZKB0TQOjFQAHdGgAsdVWUaMR4mzgAaLM5eXjrOtW4evtKBnT4PNtIVXoBrcbEljlIGTgdeE3xFSVAx4jox7nrG0upN9niklLSGUjRQAHV2Z1JeBqaluR2FlJIpyA0WE4elwFMpQMoWJQ5jw-rwvNxFE1ZPFGPNqFlpgoenRZAVQKlFEwKApSDQ0NhJj1QAxQABeHx+QIhcJRCIAblADO6-TZoAiESsKAwEQw3mCGD5QqmTUMooi3hQ8sV2GkclhKi4fCEInEpFsRXcAG9sKBbdsxIJyCpbLoAFSgEoAalK7gApMzFQBfXCMpqGtEMfgOG7s9WawIAdgAHKFtaGOCj1Px9EYKNpWTa7Uw9uRbOGs9GxEM7TXbbZ3KyAHy0MRAziR3ZMMso42iCRzcuRnPGcg0VyubW6+RKFSJWS8F1zQxWwu2oEOp2lNms9k2AD8nQAXKA5wvDMjQP7l0HcFP9czOEx+DRBLJZLSXKR+MW6KPbJI5jHUBrRrddHRUH9S0kWwlhGWwxzmWCF2hUh234Xo6BYeDx1cata3wmt6zZZtO2fV93xoT9vxLGhbFXAiGIYgD6MY1i7RQtCMKwjjIy47CcJvdMxjSWQ2jYMRn1bVCWQLGtSJfN8PzoMhqN-WiywiAdvAbZtTw0rSGx3MU8LY0zB2zAwRzHScZGnOEGGUCR+FJcgWEUWxSCKKkXmWCSeLmYtKN+OZJD2NheCtfD6LvGc9E8sRbECmhguyMLfhXBiwM3SDEs4IK-jAXL8tAb1Qsw9KTNM2siKbZlHK-Fy3PgqTOLCjyvIodJuD8lqGFwliqsG-CkpSsrwvHRUa2DUDSA3FQkPa7yup6ts+oG2sD24eKiuSv5vU01Lyoi9aa2PLaigSkbeBCtK9rFCdsGDdMmDoUUeP4TtEuIh9NmfABHcgEoCUAwCYfqhoIhzuoahImuEkkxNmyTVrmKxUYm3B3qBaCXrmCUrAnIA","body":"function monte_carlo(experiment_stream, passed, failed) {      \n    function next(passed, failed) {\n        return pair(passed / (passed + failed),\n                    () => monte_carlo(stream_tail(experiment_stream),\n                                      passed, failed));\n    }\n    return head(experiment_stream)\n           ? next(passed + 1, failed)\n           : next(passed, failed + 1);\n}\nconst pi = stream_map(p => math_sqrt(6 / p),\n                      monte_carlo(dirichlet_stream, 0, 0)); "},{"body":"\n    There is considerable\n    \n    modularity in this approach, because we still\n    can formulate a general \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"monte_carlo"},{"body":" function\n      \n    that can deal with arbitrary experiments.  Yet there is no assignment or\n    local state.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.81","id":"#ex-3.81","child":[{"body":"\n    Exercise ","tag":"#text"},{"tag":"REF","body":"3.6","href":"/sicpjs/3.1.2#ex-3.6"},{"body":" discussed generalizing\n    the random-number generator to allow one to\n    \n    reset the random-number sequence\n    so as to produce repeatable sequences of \"","tag":"#text"},{"body":"random","tag":"#text"},{"body":"\" numbers.\n    Produce a stream formulation of this same generator that operates on an\n    input stream of requests to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"generate\""},{"body":"\n    a new\n    random number or to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"reset\""},{"body":"\n    the sequence to a\n    specified value and that produces the desired stream of random numbers.\n    Don't use assignment in your solution.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.82","id":"#ex-3.82","child":[{"body":"\n    Redo exercise ","tag":"#text"},{"tag":"REF","body":"3.5","href":"/sicpjs/3.1.2#ex-3.5"},{"body":" on\n    \n    Monte Carlo integration in terms of streams.  The stream version of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"estimate_integral"},{"body":"\n    will not have an argument telling how many trials to perform.  Instead, it\n    will produce a stream of estimates based on successively more trials.\n    ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"A functional-programming view of time","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Let us now return to the issues of objects and state that were raised\n    at the beginning of this chapter and examine them in a new light.  We\n    introduced assignment and mutable objects to provide a mechanism for\n    modular construction of programs that model systems with state.\n    We constructed computational objects with local state variables and used\n    assignment to modify these variables.  We modeled the temporal behavior of\n    the objects in the world by the temporal behavior of the corresponding\n    computational objects.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Now we have seen that streams provide an alternative way to model\n    objects with local state.  We can model a changing quantity, such as\n    the local state of some object, using a stream that represents the\n    time history of successive states.  In essence, we represent time\n    explicitly, using streams, so that we decouple time in our simulated\n    world from the sequence of events that take place during evaluation.\n    Indeed, because of the presence of\n    \n\tdelayed evaluation\n      \n    there may be little relation between simulated time in the model and the\n    order of events during the evaluation.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    In order to contrast these two approaches to modeling, let us\n    reconsider the implementation of a \"","tag":"#text"},{"body":"withdrawal processor","tag":"#text"},{"body":"\" that\n    monitors the balance in a\n    \n    bank account.  In\n    section ","tag":"#text"},{"tag":"REF","body":"3.1.3","href":"/sicpjs/3.1.3"},{"body":" we implemented a\n    simplified version of such a processor:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"function make_simplified_withdraw(balance) {\n    return amount => {\n               balance = balance - amount;\n               return balance;\n           };\n}"},{"body":"\n    Calls to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_simplified_withdraw"},{"body":"\n    produce computational objects, each with a local state variable\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":" that is decremented by successive calls\n    to the object.  The object takes an ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"amount"},{"body":" as\n    an argument and returns the new balance.  We can imagine the user of a bank\n    account typing a sequence of inputs to such an object and observing the\n    sequence of returned values shown on a display screen.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    Alternatively, we can model a withdrawal processor as a\n    function\n    that takes as input a balance and a stream of amounts to withdraw and\n    produces the stream of successive balances in the account:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQFZMChsDMBXAOwGMAXASwHsjQBnMgJwFMBDAWwH0B3CsgCwAmjVtwAUAI1YAbVqWYAaUByrEynBiw4BKUAG9Qho9iOgWZAo1oAHVhUaSZckopOn3HsboC8APnpMbFy8AsKijrLyoAC0oPxsgmIqahqBOgpuHlnZOR6aQZxkdtJJ7KpE6vk62toA3MYAvrgkNAyg7ACenMkVdKDeoNIUDIVUqVrsYkMMYhgADEoAjHMLoAAsczW12C1EbZ3dJC0pVez9ARM8fEIi4gBMK0oHPWR0dQCQ2MwAbjLjQWJnkdypU0uwlCg6kA","body":"function stream_withdraw(balance, amount_stream) {      \n    return pair(balance,\n                () => stream_withdraw(balance - head(amount_stream),\n                                      stream_tail(amount_stream)));   \n} "},{"body":"\n\tThe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"stream_withdraw"},{"body":"\n    implements a well-defined mathematical function whose output is fully\n    determined by its input.  Suppose, however, that the input\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"amount_stream"},{"body":"\n    is the stream of successive values typed by the user and that the resulting\n    stream of balances is displayed. Then, from the perspective of the user who\n    is typing values and watching results, the stream process has the same\n    behavior as the object created by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_simplified_withdraw"},{"body":".\n      \n    However, with the stream version, there is no assignment, no local state\n    variable, and consequently none of the theoretical difficulties that we\n    encountered\n    \n    in section ","tag":"#text"},{"tag":"REF","body":"3.1.3","href":"/sicpjs/3.1.3"},{"body":".  Yet the system\n    has state!\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    This is really remarkable.  Even though\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"stream_withdraw"},{"body":"\n    implements a well-defined mathematical function whose behavior does not\n    change, the user's perception here is one of interacting with a system\n    that has a changing state.  One way to resolve this paradox is to realize\n    that it is the user's temporal existence that imposes state on the\n    system.  If the user could step back from the interaction and think in terms\n    of streams of balances rather than individual transactions, the system\n    would appear stateless.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/3.5.5#footnote-1"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    From the point of view of one part of a complex process, the other parts\n    appear to change with time.  They have hidden time-varying local state.  If\n    we wish to write programs that model this kind of natural decomposition in\n    our world (as we see it from our viewpoint as a part of that world) with\n    structures in our computer, we make computational objects that are not\n    functional—they must change with time.  We model state with local\n    state variables, and we model the changes of state with assignments to\n    those variables.  By doing this we make the time of execution of a\n    computation model time in the world that we are part of, and thus we\n    get \"","tag":"#text"},{"body":"objects","tag":"#text"},{"body":"\" in our computer.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    Modeling with objects is powerful and intuitive, largely because this\n    matches the perception of interacting with a world of which we are\n    part.  However, as we've seen repeatedly throughout this chapter,\n    these models raise thorny problems of constraining the order of events\n    and of synchronizing multiple processes.  The possibility of avoiding\n    these problems has stimulated the development of \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"functional programming languages","tag":"#text"}]},{"body":", which do not include any\n    provision for assignment or mutable data.  In such a language, all\n    functions\n    implement well-defined mathematical functions of their arguments,\n    whose behavior does not change.  The functional approach is extremely\n    attractive for dealing with\n    \n    concurrent systems.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/3.5.5#footnote-2"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    On the other hand, if we look closely, we can see time-related problems\n    creeping into functional models as well.  One particularly troublesome area\n    arises when we wish to design interactive systems, especially ones that\n    model interactions between independent entities. For instance, consider once\n    more the implementation of a banking system that permits joint bank accounts.\n    In a conventional system using assignment and objects, we would model the\n    fact that Peter and Paul share an account by having both Peter and Paul send\n    their transaction requests to the same bank-account object, as we saw in\n    section ","tag":"#text"},{"tag":"REF","body":"3.1.3","href":"/sicpjs/3.1.3"},{"body":". From the stream point\n    of view, where there are no \"","tag":"#text"},{"body":"objects","tag":"#text"},{"body":"\"","tag":"#text"},{"tag":"EM","child":[{"body":"per se","tag":"#text"}]},{"body":", we have\n    already indicated that a bank account can be modeled as a process that\n    operates on a stream of transaction requests to produce a stream of\n    responses.  Accordingly, we could model the fact that Peter and Paul have a\n    joint bank account by merging Peter's stream of transaction requests\n    with Paul's stream of requests and feeding the result to the\n    bank-account stream process, as shown in\n    figure ","tag":"#text"},{"tag":"REF","body":"3.38","href":"/sicpjs/3.5.5#fig-3.38"},{"body":".\n    ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_original/ch3-Z-G-60.svg","id":"#fig-3.38","captionHref":"/sicpjs/3.5.5#fig-3.38","captionName":"Figure 3.38 ","captionBody":[{"body":"\n\tA joint\n\t\n\tbank account, modeled by merging two streams of transaction\n\trequests.\n      ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    The trouble with this formulation is in the notion of ","tag":"#text"},{"tag":"EM","child":[{"body":"merge","tag":"#text"}]},{"body":".  It\n    will not do to merge the two streams by simply taking alternately one\n    request from Peter and one request from Paul. Suppose Paul accesses\n    the account only very rarely.  We could hardly force Peter to wait for\n    Paul to access the account before he could issue a second transaction.\n    \n    However such a merge is implemented, it must interleave the two\n    transaction streams in some way that is constrained by \"","tag":"#text"},{"body":"real\n    time","tag":"#text"},{"body":"\" as perceived by Peter and Paul, in the sense that, if Peter and\n    Paul meet, they can agree that certain transactions were processed\n    before the meeting, and other transactions were processed after the\n    meeting.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/3.5.5#footnote-3"},{"body":"\n    This is precisely the same constraint that we had to deal with in\n    section ","tag":"#text"},{"tag":"REF","body":"3.4.1","href":"/sicpjs/3.4.1"},{"body":", where we found the need to\n    introduce explicit synchronization to ensure a \"","tag":"#text"},{"body":"correct","tag":"#text"},{"body":"\" order\n    of events in concurrent processing of objects with state.  Thus, in an\n    attempt to support the functional style, the need to merge inputs from\n    different agents reintroduces the same problems that the functional style\n    was meant to eliminate.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    We began this chapter with the goal of building computational models\n    whose structure matches our perception of the real world we are trying\n    to model.  We can model the world as a collection of separate,\n    time-bound, interacting objects with state, or we can model the world\n    as a single, timeless, stateless unity.  Each view has powerful\n    advantages, but neither view alone is completely satisfactory.  A\n    grand unification has yet to emerge.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/3.5.5#footnote-4"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/3.5.5#footnote-link-1","child":[{"body":"Similarly in physics, when we observe a\n    moving particle, we say that the position (state) of the particle is\n    changing.  However, from the perspective of the particle's \n    \n    world line in space-time there is no change involved.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/3.5.5#footnote-link-2","child":[{"body":"John Backus, the\n    \n    inventor of Fortran, gave high\n    visibility to functional programming when he was awarded the ACM Turing\n    award in 1978.  His acceptance speech\n    \n    (Backus 1978)\n    strongly advocated the functional approach.  A good overview of functional\n    programming is given in \n    Henderson 1980 and in \n    Darlington, Henderson, and Turner 1982.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/3.5.5#footnote-link-3","child":[{"body":"Observe that, for any two streams, there is in general\n    more than one\n    acceptable order of interleaving.  Thus, technically, \"","tag":"#text"},{"body":"merge","tag":"#text"},{"body":"\"\n    is a\n    \n    relation rather than a function—the answer is not a\n    deterministic function of the inputs.  We already mentioned\n    (footnote ","tag":"#text"},{"tag":"REF","body":5,"href":"/sicpjs/3.4.1#footnote-5"},{"body":") that nondeterminism\n    is essential when dealing with concurrency.  The merge relation illustrates\n    the same essential nondeterminism, from the functional perspective.\n    In section ","tag":"#text"},{"tag":"REF","body":"4.3","href":"/sicpjs/4.3"},{"body":", we\n    will look at nondeterminism from yet another point of view.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/3.5.5#footnote-link-4","child":[{"body":"The object model approximates\n    the world by dividing it into separate pieces.  The functional model does\n    not\n    \n    modularize along object boundaries.  The object model is useful when\n    the unshared state of the \"","tag":"#text"},{"body":"objects","tag":"#text"},{"body":"\" is much larger than the\n    state that they share.  An example of a place where the object viewpoint\n    fails is \n    \n    quantum mechanics, where thinking of things as individual particles leads\n    to paradoxes and confusions.  Unifying the object view with the\n    functional view may have little to do with programming, but rather\n    with fundamental epistemological issues.","tag":"#text"}]}]