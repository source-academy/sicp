<SUBSECTION>
   <NAME>
    通用算术操作
  </NAME> 

  <LABEL NAME="sec:generic-arithmetic-operators"></LABEL>
   <INDEX>通用算术操作<OPEN></OPEN></INDEX> 
   <TEXT>
    设计通用算术操作的任务类似于设计通用复数操作的任务。例如，我们希望有一个通用加法
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    add，它在普通数字上像普通原始加法
    +一样运作，就像在有理数上
    <SPLITINLINE>
      add-rat
      <JAVASCRIPT><JAVASCRIPTINLINE>add_rat</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    ，在复数上像
    <SPLITINLINE>
      add-complex
      <JAVASCRIPT><JAVASCRIPTINLINE>add_complex</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    一样。我们可以通过采用我们在<SPACE></SPACE><REF NAME="sec:data-directed"></REF>实现通用复数选择器时使用的相同策略来实现add和其他通用算术操作。我们将为每种数字附加一个类型标签，并使通用
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    根据其参数的数据类型分派到一个适当的软件包。
  </TEXT> 
   <TEXT>
    通用算术
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    定义如下：
    
      <INDEX><DECLARATION>add</DECLARATION> (通用)</INDEX>
      <INDEX><DECLARATION>sub</DECLARATION> (通用)</INDEX>
      <INDEX><DECLARATION>mul</DECLARATION> (通用)</INDEX>
      <INDEX><DECLARATION>div</DECLARATION> (通用)</INDEX>
      <NAME>ops</NAME>
      <REQUIRES>apply_generic</REQUIRES>
      
(define (add x y) (apply-generic &apos;add x y))
(define (sub x y) (apply-generic &apos;sub x y))
(define (mul x y) (apply-generic &apos;mul x y))
(define (div x y) (apply-generic &apos;div x y))
      
      <JAVASCRIPT>
function add(x, y) { return apply_generic(&quot;add&quot;, list(x, y)); }
<SHORT_SPACE></SHORT_SPACE>
function sub(x, y) { return apply_generic(&quot;sub&quot;, list(x, y)); }
<SHORT_SPACE></SHORT_SPACE>
function mul(x, y) { return apply_generic(&quot;mul&quot;, list(x, y)); }
<SHORT_SPACE></SHORT_SPACE>
function div(x, y) { return apply_generic(&quot;div&quot;, list(x, y)); }
      </JAVASCRIPT>
    
  </TEXT> 
  <TEXT> 
    我们开始安装一个用于处理
    <INDEX>数<SUBINDEX><ORDER>通用</ORDER>在通用算术系统中</SUBINDEX></INDEX>
    <INDEX>普通数 (在通用算术系统中)</INDEX>
    <EM>普通</EM>数字的软件包，即我们语言的原语数字。
    <SPLITINLINE>
      会
    </SPLITINLINE>
    为这些附加
    <SPLITINLINE>
      scheme-number符号。
      <JAVASCRIPT>
	字符串<JAVASCRIPTINLINE>&quot;javascript_number&quot;</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLITINLINE>
    此包中的算术操作是原语算术
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    （因此无需定义额外的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    来处理未打标签的数字）。由于这些操作每个都需要两个
    参数，它们被安装在由列表键控的表中
    <SPLITINLINE>
      
      (scheme-number scheme-number)：
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>list(&quot;javascript_number&quot;, &quot;javascript_number&quot;)</JAVASCRIPTINLINE>：</JAVASCRIPT>
    </SPLITINLINE>
<SNIPPET CHAP="4">
      <INDEX>package<SUBINDEX>JavaScript-number</SUBINDEX></INDEX>
      <INDEX><USE>javascript_number</USE> package</INDEX>
      <INDEX><DECLARATION>install_javascript_number_package</DECLARATION></INDEX> 
      <NAME>install_javascript_number_package</NAME>
      <REQUIRES>ops</REQUIRES>
      <REQUIRES>operation_table_from_chapter_3</REQUIRES>
      <REQUIRES>operation_table</REQUIRES>
      <REQUIRES>attach_tag</REQUIRES>
      <SCHEME>
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag &apos;scheme-number x))    
  (put &apos;add &apos;(scheme-number scheme-number)
    (lambda (x y) (tag (+ x y))))
  (put &apos;sub &apos;(scheme-number scheme-number)
    (lambda (x y) (tag (- x y))))
  (put &apos;mul &apos;(scheme-number scheme-number)
    (lambda (x y) (tag (* x y))))
  (put &apos;div &apos;(scheme-number scheme-number)
    (lambda (x y) (tag (/ x y))))
  (put &apos;make &apos;scheme-number
    (lambda (x) (tag x)))
  &apos;done)
      </SCHEME>
      <JAVASCRIPT>
function install_javascript_number_package() {
    function tag(x) {
        return attach_tag(&quot;javascript_number&quot;, x);
    }
    put(&quot;add&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;), 
        (x, y) =&gt; tag(x + y));
    put(&quot;sub&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;), 
        (x, y) =&gt; tag(x - y));
    put(&quot;mul&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;), 
        (x, y) =&gt; tag(x * y));
    put(&quot;div&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;), 
        (x, y) =&gt; tag(x / y));
    put(&quot;make&quot;, &quot;javascript_number&quot;, 
        x =&gt; tag(x));
    return &quot;done&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
   <TEXT>
    使用
    <SPLITINLINE>
      Scheme-number 包
      <JAVASCRIPT>JavaScript-number 包</JAVASCRIPT>
    </SPLITINLINE>
    的用户将通过以下
    <SPLITINLINE>
      过程：
      <JAVASCRIPT>函数：</JAVASCRIPT>
    </SPLITINLINE>
    创建（带标签的）普通数字：
    
      <NAME>actually_install_javascript_number_package</NAME>
      <JAVASCRIPT>
install_javascript_number_package();
      </JAVASCRIPT>
    
    
      <INDEX><DECLARATION>make_javascript_number</DECLARATION></INDEX> 
      <NAME>install_javascript_number_package_usage</NAME>
      <REQUIRES>install_javascript_number_package</REQUIRES>
      <REQUIRES>actually_install_javascript_number_package</REQUIRES>
      <EXAMPLE>install_javascript_number_package_usage_example</EXAMPLE>
      <EXPECTED>[ &apos;javascript_number&apos;, 9 ]</EXPECTED>
      
(define (make-scheme-number n)
  ((get &apos;make &apos;scheme-number) n))
      
      <JAVASCRIPT>
function make_javascript_number(n) {
    return get(&quot;make&quot;, &quot;javascript_number&quot;)(n);
}
      </JAVASCRIPT>
    
    
      <NAME>install_javascript_number_package_usage_example</NAME>
      <JAVASCRIPT>
const n1 = make_javascript_number(4);
const n2 = make_javascript_number(5);

add(n1, n2);
      </JAVASCRIPT>
    
    
  </TEXT> 
  <TEXT> 
    现在通用算术系统的框架已到位，
    我们可以轻松地包含新类型的数字。这里有一个执行有理数算术的包。注意，由于可加性的好处，我们可以使用<REF NAME="sec:rationals"></REF>中的有理数代码，而无需修改，作为包中的内部
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ：
<SNIPPET CHAP="4">
      <INDEX>package<SUBINDEX>rational-number</SUBINDEX></INDEX>
      <INDEX><USE>rational</USE> package</INDEX>
      <INDEX>rational-number arithmetic<SUBINDEX>interfaced to generic arithmetic system</SUBINDEX></INDEX>
      <INDEX><DECLARATION>install_rational_package</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_rational</DECLARATION></INDEX> 
      <NAME>benefit_of_additivity</NAME>
      <REQUIRES>ops</REQUIRES>
      <REQUIRES>operation_table_from_chapter_3</REQUIRES>
      <REQUIRES>operation_table</REQUIRES>
      <REQUIRES>attach_tag</REQUIRES>
      <REQUIRES>gcd_definition</REQUIRES>
      <EXAMPLE>benefit_of_additivity_example</EXAMPLE>
      <EXPECTED>[ &apos;rational&apos;, [ 11, 15 ] ]</EXPECTED>
      <SCHEME>
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))

  ;; interface to rest of the system
  (define (tag x) (attach-tag &apos;rational x))
  (put &apos;add &apos;(rational rational)
    (lambda (x y) (tag (add-rat x y))))
  (put &apos;sub &apos;(rational rational)
    (lambda (x y) (tag (sub-rat x y))))
  (put &apos;mul &apos;(rational rational)
    (lambda (x y) (tag (mul-rat x y))))
  (put &apos;div &apos;(rational rational)
    (lambda (x y) (tag (div-rat x y))))

  (put &apos;make &apos;rational
    (lambda (n d) (tag (make-rat n d))))
  &apos;done)

(define (make-rational n d)
  ((get &apos;make &apos;rational) n d))
      </SCHEME>
      <JAVASCRIPT>
function install_rational_package() {
    // internal functions
    function numer(x) { return head(x); }
    function denom(x) { return tail(x); }
    function make_rat(n, d) {
        const g = gcd(n, d);
        return pair(n / g, d / g);
    }
    function add_rat(x, y) {
        return make_rat(numer(x) * denom(y) + numer(y) * denom(x),
                        denom(x) * denom(y));
    }
    function sub_rat(x, y) {
        return make_rat(numer(x) * denom(y) - numer(y) * denom(x),
                        denom(x) * denom(y));
    }
    function mul_rat(x, y) {
        return make_rat(numer(x) * numer(y),
                        denom(x) * denom(y));
    }
    function div_rat(x, y) {
        return make_rat(numer(x) * denom(y),
                        denom(x) * numer(y));
    }
    // interface to rest of the system
    function tag(x) {
        return attach_tag(&quot;rational&quot;, x);
    }
    put(&quot;add&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(add_rat(x, y)));
    put(&quot;sub&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(sub_rat(x, y)));
    put(&quot;mul&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(mul_rat(x, y)));
    put(&quot;div&quot;, list(&quot;rational&quot;, &quot;rational&quot;),
        (x, y) =&gt; tag(div_rat(x, y)));
    put(&quot;make&quot;, &quot;rational&quot;,
        (n, d) =&gt; tag(make_rat(n, d)));
    return &quot;done&quot;;  
}

function make_rational(n, d) {
    return get(&quot;make&quot;, &quot;rational&quot;)(n, d);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4" HIDE="yes">
      <NAME>benefit_of_additivity_example</NAME>
      <JAVASCRIPT>
install_rational_package();

const r1 = make_rational(1, 3);
const r2 = make_rational(2, 5);

add(r1, r2);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT> 
    我们可以安装一个类似的软件包来处理复数，使用标签
    <SPLITINLINE>
      complex。
      <JAVASCRIPT><JAVASCRIPTINLINE>&quot;complex&quot;</JAVASCRIPTINLINE>。</JAVASCRIPT>
    </SPLITINLINE>
    在<SPACE></SPACE>创建软件包时，我们从表中提取由直角和极坐标包定义的操作
    <SPLITINLINE>
      make-from-real-imag
      <JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      make-from-mag-ang
      <JAVASCRIPT><JAVASCRIPTINLINE>make_from_mag_ang</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    。
    <INDEX>可加性</INDEX>
    可加性使我们可以使用相同的内部操作，
    <SPLITINLINE>
      add-complex,
      <JAVASCRIPT><JAVASCRIPTINLINE>add_complex</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      sub-complex,
      <JAVASCRIPT><JAVASCRIPTINLINE>sub_complex</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      mul-complex,
      <JAVASCRIPT><JAVASCRIPTINLINE>mul_complex</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      div-complex
      <JAVASCRIPT><JAVASCRIPTINLINE>div_complex</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，来自<SPACE></SPACE><REF NAME="sec:representations-complex-numbers"></REF>。
<SNIPPET CHAP="4">
      <INDEX>package<SUBINDEX>complex-number</SUBINDEX></INDEX>
      <INDEX><USE>complex</USE> package</INDEX>
      <INDEX>complex-number arithmetic<SUBINDEX>interfaced to generic arithmetic system</SUBINDEX></INDEX>
      <INDEX><DECLARATION>install_complex_package</DECLARATION></INDEX> 
      <NAME>install_complex_package</NAME>
      <REQUIRES>ops</REQUIRES>
      <REQUIRES>generic_selectors</REQUIRES>
      <REQUIRES>operation_table_from_chapter_3</REQUIRES>
      <REQUIRES>operation_table</REQUIRES>
      <REQUIRES>install_rectangular_package</REQUIRES>
      <REQUIRES>install_rectangular_package_usage</REQUIRES>
      <REQUIRES>install_polar_package_usage</REQUIRES>
      <REQUIRES>attach_tag</REQUIRES>
      <EXAMPLE>actually_install_complex_package</EXAMPLE>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get &apos;make-from-real-imag &apos;rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get &apos;make-from-mag-ang &apos;polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))

  ;; interface to rest of the system
  (define (tag z) (attach-tag &apos;complex z))
  (put &apos;add &apos;(complex complex)
    (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put &apos;sub &apos;(complex complex)
    (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put &apos;mul &apos;(complex complex)
    (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put &apos;div &apos;(complex complex)
    (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put &apos;make-from-real-imag &apos;complex
    (lambda (x y) (tag (make-from-real-imag x y))))
  (put &apos;make-from-mag-ang &apos;complex
    (lambda (r a) (tag (make-from-mag-ang r a))))
  &apos;done)
      </SCHEME>
      <JAVASCRIPT>
function install_complex_package() {
    // imported functions from rectangular and polar packages
    function make_from_real_imag(x, y) {
        return get(&quot;make_from_real_imag&quot;, &quot;rectangular&quot;)(x, y);
    }
    function make_from_mag_ang(r, a) {
        return get(&quot;make_from_mag_ang&quot;, &quot;polar&quot;)(r, a);
    }
    // internal functions
    function add_complex(z1, z2) {
        return make_from_real_imag(real_part(z1) + real_part(z2),
                                   imag_part(z1) + imag_part(z2));
    }
    function sub_complex(z1, z2) {
        return make_from_real_imag(real_part(z1) - real_part(z2),
                                   imag_part(z1) - imag_part(z2));
    }
    function mul_complex(z1, z2) {
        return make_from_mag_ang(magnitude(z1) * magnitude(z2),
                                 angle(z1) + angle(z2));
    }
    function div_complex(z1, z2) {
        return make_from_mag_ang(magnitude(z1) / magnitude(z2),
                                 angle(z1) - angle(z2));
    }
    // interface to rest of the system
    function tag(z) { return attach_tag(&quot;complex&quot;, z); }
    put(&quot;add&quot;, list(&quot;complex&quot;, &quot;complex&quot;), 
        (z1, z2) =&gt; tag(add_complex(z1, z2)));
    put(&quot;sub&quot;, list(&quot;complex&quot;, &quot;complex&quot;), 
        (z1, z2) =&gt; tag(sub_complex(z1, z2)));
    put(&quot;mul&quot;, list(&quot;complex&quot;, &quot;complex&quot;), 
        (z1, z2) =&gt; tag(mul_complex(z1, z2)));
    put(&quot;div&quot;, list(&quot;complex&quot;, &quot;complex&quot;), 
        (z1, z2) =&gt; tag(div_complex(z1, z2)));
    put(&quot;make_from_real_imag&quot;, &quot;complex&quot;, 
        (x, y) =&gt; tag(make_from_real_imag(x, y)));
    put(&quot;make_from_mag_ang&quot;, &quot;complex&quot;, 
        (r, a) =&gt; tag(make_from_mag_ang(r, a)));
    return &quot;done&quot;;    
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT> 
    复数包以外的程序可以通过实部和虚部或模长和角度来构造复数。请注意，最初在直角和极坐标包中定义的底层
    <SPLITINLINE>
      过程,
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    被导出到复数包中，并从那里导出到外部世界。
<SNIPPET CHAP="4" HIDE="yes">
      <NAME>actually_install_complex_package</NAME>
      <JAVASCRIPT>
install_complex_package();
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4">
      <INDEX><DECLARATION>make_complex_from_real_imag</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_complex_from_mag_ang</DECLARATION></INDEX> 
      <NAME>install_complex_package_usage</NAME>
      <REQUIRES>install_complex_package</REQUIRES>
      <REQUIRES>actually_install_complex_package</REQUIRES>
      <EXPECTED>[ &apos;rectangular&apos;, [ 8.387912809451864, 5.397127693021015 ] ]</EXPECTED>
      <EXAMPLE>install_complex_package_example</EXAMPLE>
      <SCHEME>
(define (make-complex-from-real-imag x y)
  ((get &apos;make-from-real-imag &apos;complex) x y))

(define (make-complex-from-mag-ang r a)
  ((get &apos;make-from-mag-ang &apos;complex) r a))
      </SCHEME>
      <JAVASCRIPT>
function make_complex_from_real_imag(x, y){
   return get(&quot;make_from_real_imag&quot;, &quot;complex&quot;)(x, y);
}
function make_complex_from_mag_ang(r, a){
   return get(&quot;make_from_mag_ang&quot;, &quot;complex&quot;)(r, a);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>install_complex_package_example</NAME>
      <JAVASCRIPT>
const r = make_complex_from_real_imag(4, 3);
const p = make_complex_from_mag_ang(5, 0.5);

add(r, p);    // results in a complex number in rectangular coordinates
// mul(r, p); // results in a complex number in polar coordinates
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
const r = make_complex_from_real_imag(4, 3);
const p = make_complex_from_mag_ang(5, 0.5);
tail(add(r, p));
      </JAVASCRIPT_TEST>
    </SNIPPET>
  </TEXT>
  <TEXT> 
    我们这里有一个
    <INDEX>类型标签<SUBINDEX>两级</SUBINDEX></INDEX>
    的两级标签系统。一个典型的复数，例如
<LATEXINLINE>$3+4i$</LATEXINLINE>  在直角形式中，如
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:complex-number-structure_scheme"></REF>
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:complex-number-structure"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
      所示表示。外层标签
    <SPLITINLINE>(complex)
    <JAVASCRIPT>(<JAVASCRIPTINLINE>&quot;complex&quot;</JAVASCRIPTINLINE>)</JAVASCRIPT>
    </SPLITINLINE>
    用于将数字引导到复数包。进入
    复数包后，下一标签
    <SPLITINLINE>
      (rectangular)
      <JAVASCRIPT>(<JAVASCRIPTINLINE>&quot;rectangular&quot;</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    用于将数字引导到直角包。在一个大型而复杂的系统中可能会有许多级别，每个级别通过通用操作与下一个级别接口。当一个数据对象被传递
    <QUOTE>向下</QUOTE>时，用于将其引导到适当包的外层标签会被去掉（通过应用
<SCHEMEINLINE>contents</SCHEMEINLINE> ) 以及下一级标签（如果有）变得可见，以便用于进一步分派。
    <SPLIT>
      
        <FIGURE>
          <FIGURE SPLIT_SCALE="0.7" SRC="img_original/ch2-Z-G-65.svg"></FIGURE>
          <CAPTION>
	    矩形形式中 $3+4i$ 的表示。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch2-Z-G-65.svg"></FIGURE>
          <CAPTION>
	    矩形形式中 $3+4i$ 的表示。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
   </TEXT>
   <TEXT>
    在上述软件包中，我们使用了
    <SPLITINLINE>
      add-rat,
      <JAVASCRIPT><JAVASCRIPTINLINE>add_rat</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      add-complex,
      <JAVASCRIPT><JAVASCRIPTINLINE>add_complex</JAVASCRIPTINLINE>,
    </JAVASCRIPT></SPLITINLINE>
    和其他算术
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，正如最初编写的一样。一旦这些声明是不同安装
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的内部，它们就不再需要彼此不同的名称：我们可以简单地在两个包中分别命名为add，
    sub，mul，和
    div。
  </TEXT> 
  <EXERCISE>  
    Louis Reasoner 试图求值表达式
    <SPLITINLINE>
      (magnitude z)
      <JAVASCRIPT><JAVASCRIPTINLINE>magnitude(z)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    其中
<SCHEMEINLINE>z</SCHEMEINLINE>  是如
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:complex-number-structure_scheme"></REF>
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:complex-number-structure"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    所示的对象。令他惊讶的是，结果不是
<LATEXINLINE>$5$</LATEXINLINE> 
    他从
    <SPLITINLINE>
      apply-generic,
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    得到了一个错误信息，提示该操作没有方法。
<SCHEMEINLINE>magnitude</SCHEMEINLINE>  
    的类型
    <SPLITINLINE>
      (complex)。
      <JAVASCRIPT><JAVASCRIPTINLINE>list(&quot;complex&quot;)</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLITINLINE>
    他向 Alyssa P. Hacker 展示了这个互动，Alyssa 说<QUOTE>问题是复数选择器从未为
    <SPLITINLINE>
      complex
      <JAVASCRIPT><JAVASCRIPTINLINE>&quot;complex&quot;</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    数而定义，只为
    <SPLITINLINE>
      polar
      <JAVASCRIPT><JAVASCRIPTINLINE>&quot;polar&quot;</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      rectangular
      <JAVASCRIPT><JAVASCRIPTINLINE>&quot;rectangular&quot;</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    数字定义。要解决这个问题，你只需将以下内容添加到complex包中：</QUOTE>
<SNIPPET CHAP="4">
      <NAME>use_generic_magnitude</NAME>
      <REQUIRES>install_complex_package_usage</REQUIRES>
      <REQUIRES>actually_install_complex_package</REQUIRES>
      <EXAMPLE>use_generic_magnitude_example</EXAMPLE>
      <EXPECTED>5</EXPECTED>
      <SCHEME>
(put &apos;real-part &apos;(complex) real-part)
(put &apos;imag-part &apos;(complex) imag-part)
(put &apos;magnitude &apos;(complex) magnitude)
(put &apos;angle &apos;(complex) angle)
      </SCHEME>
      <JAVASCRIPT>
put(&quot;real_part&quot;, list(&quot;complex&quot;), real_part);
put(&quot;imag_part&quot;, list(&quot;complex&quot;), imag_part);
put(&quot;magnitude&quot;, list(&quot;complex&quot;), magnitude);
put(&quot;angle&quot;,     list(&quot;complex&quot;), angle);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="4" HIDE="yes">
      <NAME>use_generic_magnitude_example</NAME>
      <EXAMPLE>use_generic_magnitude_example</EXAMPLE>
      <JAVASCRIPT>
const z = make_complex_from_real_imag(3, 4);

magnitude(z);
      </JAVASCRIPT>
    </SNIPPET> 
    详细描述为什么这可以工作。作为一个例子，跟踪所有在求值表达式
    <SPLITINLINE>
      (magnitude z)
      <JAVASCRIPT><JAVASCRIPTINLINE>magnitude(z)</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    时调用的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，其中
<SCHEMEINLINE>z</SCHEMEINLINE>  
    是如
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:complex-number-structure_scheme"></REF>
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:complex-number-structure"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    所示的对象。特别是，
    <SPLITINLINE>
      apply-generic
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    被调用了多少次？在每种情况下被分派到哪个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ？
<SOLUTION>  
      将上述行放入包中将会打开
<SCHEMEINLINE>z</SCHEMEINLINE> ，这些行起到了传递作用。
      <SPLITINLINE>
	apply-generic
	<JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      将被调用两次。我们将使用替换模型跟踪程序的求值过程。
<SNIPPET EVAL="no">
        <JAVASCRIPT>
magnitude(z);
apply_generic(&quot;magnitude&quot;, list(z));
// In this case:
// type_tags = map(type_tag, list(z))
// Which evaluates to:
// type_tags = list(&quot;complex&quot;);
// and
// fun = get(&quot;magnitude&quot;, list(&quot;complex&quot;));
// which, due to the addition of
// put(&quot;magnitude&quot;, list(&quot;complex&quot;), magnitude);
// fun = magnitude;
apply(magnitude, map(contents, list(z)));
apply(magnitude, pair(&quot;rectangular&quot;, pair(3, 4)));
magnitude(pair(&quot;rectangular&quot;), pair(3, 4));
apply_generic(&quot;magnitude&quot;, list(pair(&quot;rectangular&quot;), pair(3, 4)));
// type_tags = map(type_tag, list(z)) evaluates to list(&quot;rectangular&quot;)
// fun = get(&quot;magnitude&quot;, list(&quot;rectangular&quot;)) which evaluates to
// z =&gt; math_sqrt(square(real_part(z)) + square(imag_part(z)))
// z =&gt; math_sqrt(square(head(z)) + square(tail(z)))
apply(fun, map(contents, list(pair(&quot;rectangular&quot;), pair(3, 4))))
apply(fun, pair(3, 4))
(z =&gt; math_sqrt(square(head(z)) + square(tail(z))))(pair(3, 4));
math_sqrt(square(head(pair(3, 4))) + square(tail(pair(3, 4))))
...
math_sqrt(square(3) + square(4));
...
math_sqrt(9 + 16);
math_sqrt(25);
5
        </JAVASCRIPT>
        <SCHEME>
;;*** Use substitution rule:
(magnitude z)

;;** First apply-generic:
(apply-generic &apos;magnitude z)
;; where z is the whole object including symbol &apos;complex.

;;recall
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
            &quot;No method for these types -- APPLY-GENERIC&quot;
            (list op type-tags))))))
;; substitution
(let ((type-tags &apos;(complex))  ... ))
(let ((proc (get op &apos;(complex))) ... ))
(let ((proc magnitude) ... ))
(if proc...  ;; true
(apply magnitude (contents z))
(magnitude z-prime) ;; where z-prime is the contents (the cdr) of the original
                    ;; object, that is, with the &apos;complex stripped off.

;;** Second apply-generic:
(let ((type-tags &apos;(rectangular)) ... ))
(let ((proc (get op &apos;(rectangular))) ... ))
(let ((proc (get &apos;magnitude &apos;(rectangular))) ... ))
(let ((proc (lambda (z) (sqrt (+ (square (real-part z))
                                 (square (imag-part z))))))  ...  )))

(if proc... ;; true
(apply (lambda (z) (sqrt (+ (square (real-part z))
                            (square (imag-part z))))) (contents z-prime))
(sqrt (+ (square 3) (square 4)))
5
        </SCHEME>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:2_77"></LABEL>
  </EXERCISE>

  <EXERCISE>  
    内部
    <INDEX>JavaScript<SUBINDEX>内部类型系统</SUBINDEX></INDEX>
    <INDEX>数据类型<SUBINDEX>在 JavaScript 中</SUBINDEX></INDEX>
    <INDEX><USE>is_number</USE> (原语函数)<SUBINDEX>数据类型 and</SUBINDEX></INDEX>
    <INDEX><USE>is_string</USE> (原语函数)<SUBINDEX>数据类型 and</SUBINDEX></INDEX>
    <INDEX><USE>attach_tag</USE><SUBINDEX>使用 JavaScript 数据类型</SUBINDEX></INDEX>
    <INDEX><USE>type_tag</USE><SUBINDEX>使用 JavaScript 数据类型</SUBINDEX></INDEX>
    <INDEX><USE>contents</USE><SUBINDEX>使用 JavaScript 数据类型</SUBINDEX></INDEX>
    <SPLITINLINE>过程
    <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    在
    <SPLITINLINE>
      scheme-number
      <JAVASCRIPT><JAVASCRIPTINLINE>javascript_number</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    包中本质上不过是对原语的调用
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
<SCHEMEINLINE>+</SCHEMEINLINE>, <SCHEMEINLINE>-</SCHEMEINLINE> ，等等。我们的类型标签系统要求每个数据对象都必须附加一个类型，因此无法直接使用语言的原语。然而，事实上，所有
    <SPLITINLINE>
      Lisp
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    实现确实有一个类型系统，它们在内部使用。原语谓词如
    <SPLITINLINE>
      symbol?
      <JAVASCRIPT><JAVASCRIPTINLINE>is_string</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      number?
      <JAVASCRIPT><JAVASCRIPTINLINE>is_number</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    判断数据对象是否具有特定类型。修改
    <SPLITINLINE>
      type-tag,
      <JAVASCRIPT><JAVASCRIPTINLINE>type_tag</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    的定义
<SCHEMEINLINE>contents</SCHEMEINLINE> ，和
    <SPLITINLINE>
      attach-tag
      <JAVASCRIPT><JAVASCRIPTINLINE>attach_tag</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    来自<SPACE></SPACE><REF NAME="sec:manifest-types"></REF>以便我们的通用系统利用
    <SPLITINLINE>Scheme<APOS></APOS>s
    <JAVASCRIPT>JavaScript<APOS></APOS>s</JAVASCRIPT>
    </SPLITINLINE>
    内部类型系统。也就是说，系统应与之前一样运作，只是普通数字应简单地表示为
    <SPLITINLINE>
      Scheme
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    数字，而不是其
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    是
    <SPLITINLINE>
      符号 scheme-number。
      <JAVASCRIPT>
	字符串 <JAVASCRIPTINLINE>&quot;javascript_number&quot;</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLITINLINE>
<LABEL NAME="ex:internal-type-system"></LABEL>
      
    <SOLUTION>
      以下修改将利用 JavaScript 数字实现：
      
        <JAVASCRIPT>
function attach_tag(type_tag, contents) {
  return is_number(contents) 
    ? pair(&quot;javascript_number&quot;, contents)
    : pair(type_tag, contents);
}
function type_tag(datum) {
  return is_number(datum)
    ? &quot;javascript_number&quot;
    : is_pair(datum)
      ? head(datum)
      : error(datum, &quot;bad tagged datum -- type_tag&quot;);
}
function contents(datum) {
  return is_number(datum)
    ? datum
    : is_pair(datum)
      ? tail(datum)
      : error(datum, &quot;bad tagged datum -- contents&quot;);
}
        </JAVASCRIPT>
        
(define (attach-tag type-tag contents) 
  (if (number? contents) 
      contents 
      (cons type-tag contents))) 

(define (type-tag datum) 
(cond ((number? datum) &apos;scheme-number) 
    ((pair? datum) (car datum)) 
    (else (error &quot;Wrong datum -- TYPE-TAG&quot; datum)))) 

(define (contents datum) 
(cond ((number? datum) datum) 
    ((pair? datum) (cdr datum)) 
    (else (error &quot;Wrong datum -- CONTENTS&quot; datum)))) 
        
      
    </SOLUTION>
   </EXERCISE>

   <EXERCISE> 
    定义一个通用相等性谓词
    <INDEX><USE>is_equal</USE> (通用相等性谓词)</INDEX>
    <INDEX>相等性<SUBINDEX><ORDER>通用</ORDER>在通用算术系统中</SUBINDEX></INDEX>
    <SPLITINLINE>
      equ?<JAVASCRIPT>
      <JAVASCRIPTINLINE>is_equal</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    ，用于测试两个数的相等性，并将其安装在通用算术包中。此操作应适用于普通数字，有理数和复数。
    
    <SOLUTION>
      
	<JAVASCRIPT>
// provided by GitHub user clean99

function is_equal(x, y) {
    return apply_generic(&quot;is_equal&quot;, list(x, y));
}

function install_javascript_number_package() {
    // ...

    put(&quot;is_equal&quot;, list(&quot;javascript_number&quot;, &quot;javascript_number&quot;),
           (x, y) =&gt; x === y);

    // ...
}

function install_rational_package() {
    // ...

    function is_equal(x, y) {
        return numer(x) * denom(y) === numer(y) * denom(x);
    }

    put(&quot;is_equal&quot;, list(&quot;rational&quot;, &quot;rational&quot;), is_equal);

    // ...
}

function install_complex_package() {
    // ...

    function is_equal(z1, z2) {
        return real_part(z1) === real_part(z2)
               ? imag_part(z1) === imag_part(z2)
               : false;
    }

    put(&quot;is_equal&quot;, list(&quot;complex&quot;, &quot;complex&quot;),
            is_equal);

    //...
}
	</JAVASCRIPT>
      
    </SOLUTION>
</EXERCISE> 

   <EXERCISE>
    定义一个通用谓词
    <INDEX><USE>is_equal_to_zero</USE> (通用)</INDEX>
    <INDEX>零值测试 (通用)</INDEX>
    <SPLITINLINE>
      =zero?
      <JAVASCRIPT><JAVASCRIPTINLINE>is_equal_to_zero</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    ，用于测试其参数是否为零，并将其安装在通用算术包中。此操作应适用于普通数字，有理数和复数。
    
    <SOLUTION>
      
	<JAVASCRIPT>
// provided by GitHub user clean99

function is_equal_to_zero(x) {
    return apply_generic(&quot;is_equal_to_zero&quot;, list(x));
}

function install_javascript_number_package() {
    // ...

    put(&quot;is_equal_to_zero&quot;, &quot;javascript_number&quot;,
          x =&gt; x === 0);

    // ...
}

function install_rational_package() {
    // ...

    function is_equal_to_zero(x) {
        return numer(x) === 0;
    }

    put(&quot;is_equal_to_zero&quot;, &quot;rational&quot;,
           is_equal_to_zero);

    // ...
}

function install_complex_package() {
    // ...

    function is_equal_to_zero(z) {
        return real_part(z) === 0
               ? imag_part(z) === 0
               : false;
    }

    put(&quot;is_equal_to_zero&quot;, &quot;complex&quot;,
            is_equal_to_zero);

    //...
}
	</JAVASCRIPT>
      
    </SOLUTION>
  </EXERCISE> 

   <INDEX>通用算术操作<CLOSE></CLOSE></INDEX> 
</SUBSECTION>
