<SUBSECTION>
  <NAME>
    Conditionals, Assignments<SPLITINLINE><SCHEME>, and Definitions</SCHEME><JAVASCRIPT>, and Declarations</JAVASCRIPT></SPLITINLINE>
  </NAME>

  <LABEL NAME="sec:cond-assign-def-evaluation"/>
  <TEXT>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>conditionals</SUBINDEX></INDEX>
    As with the metacircular evaluator,
    <SPLITINLINE>
      <SCHEME>
        special
      </SCHEME>
      <JAVASCRIPT>
        syntactic
      </JAVASCRIPT>
    </SPLITINLINE>
    forms are handled by
    selectively evaluating fragments of the
    <SPLITINLINE>
      <SCHEME>
        expression.
      </SCHEME>
      <JAVASCRIPT>
        component.
      </JAVASCRIPT>
    </SPLITINLINE>
    For
    <SPLITINLINE>
      <SCHEME>
	an <SCHEMEINLINE>if</SCHEMEINLINE> expression, 
      </SCHEME>
      <JAVASCRIPT>
	a conditional,
      </JAVASCRIPT>
    </SPLITINLINE>
    we must evaluate the predicate and decide, based on the
    value of predicate, whether to evaluate the consequent or the
    alternative.
  </TEXT>

  <TEXT>
    Before evaluating the predicate, we save the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE> expression 
      </SCHEME>
      <JAVASCRIPT>
	conditional
      </JAVASCRIPT>
    </SPLITINLINE>
    itself so that we can later extract the consequent or
    alternative.  We also save the environment, which we will need later in
    order to evaluate the consequent or the alternative, and we save
    <SCHEMEINLINE>continue</SCHEMEINLINE>, which we will need later in order to
    return to the evaluation of the
    <SPLITINLINE>
      <SCHEME>
        expression
      </SCHEME>
      <JAVASCRIPT>
        statement
      </JAVASCRIPT>
    </SPLITINLINE>
    that is waiting for the value of
    the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	      conditional.<FOOTNOTE>In this chapter, we will use the function
        <JAVASCRIPTINLINE>is_falsy</JAVASCRIPTINLINE> to test the value of
        the predicate. This allows us to write the consequent and the
        alternate branches in the same order as they appear in a conditional,
        and simply fall through to the consequent branch when the predicate
        holds. The function is declared as the opposite of the
        <JAVASCRIPTINLINE>is_truthy</JAVASCRIPTINLINE> function used to
        test predicates of conditionals in section<SPACE/><REF NAME="sec:core-of-evaluator"/>.
	<INDEX><DECLARATION>is_falsy</DECLARATION><SUBINDEX>why used in explicit-control evaluator</SUBINDEX></INDEX>
      </FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><DECLARATION>ev_conditional</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
ev-if
(save exp)                    <EM>; save expression for later</EM>
(save env)
(save continue)
(assign continue (label ev-if-decide))
(assign exp (op if-predicate) (reg exp))
(goto (label eval-dispatch))  <EM>; evaluate the predicate</EM>
      </SCHEME>
      <JAVASCRIPT>
"ev_conditional",
      save("comp"), // save conditional for later
      save("env"),
      save("continue"),
      assign("continue", label("ev_conditional_decide")),
      assign("comp", list(op("conditional_predicate"), reg("comp"))),
      go_to(label("eval_dispatch")), // evaluate the predicate
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    When we return from evaluating the predicate, we test whether it was
    true or false and, depending on the result, place either the
    consequent or the alternative in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    before
    going to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Notice that restoring <SCHEMEINLINE>env</SCHEMEINLINE> and
    <SCHEMEINLINE>continue</SCHEMEINLINE> here sets up
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to have the correct environment and
    to continue at the right place to receive the value of the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE> expression. 
      </SCHEME>
      <JAVASCRIPT>
	conditional.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
ev-if-decide
(restore continue)
(restore env)
(restore exp)
(test (op true?) (reg val))
(branch (label ev-if-consequent))
ev-if-alternative
(assign exp (op if-alternative) (reg exp))
(goto (label eval-dispatch))
ev-if-consequent
(assign exp (op if-consequent) (reg exp))
(goto (label eval-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_conditional_decide",
      restore("continue"),
      restore("env"),
      restore("comp"),
      test(list(op("is_falsy"), reg("val"))),
      branch(label("ev_conditional_alternative")),
      
"ev_conditional_consequent",
      assign("comp", list(op("conditional_consequent"), reg("comp"))),
      go_to(label("eval_dispatch")),
      
"ev_conditional_alternative",
      assign("comp", list(op("conditional_alternative"), reg("comp"))),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  
  <SUBHEADING> 
    <NAME>Assignments and <SPLITINLINE><SCHEME>definitions</SCHEME><JAVASCRIPT>declarations</JAVASCRIPT></SPLITINLINE></NAME>
  </SUBHEADING>

  <TEXT>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>assignments</SUBINDEX></INDEX>
    Assignments are handled by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-assignment</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_assignment</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which is reached from
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    with the assignment expression in <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>.  The
    code at
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>ev-assignment</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_assignment</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    first evaluates the value part of the expression and then installs the new
    value in the environment.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Set-variable-value!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>assign_symbol_value</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is assumed to be available as a machine operation.
    <INDEX><DECLARATION>ev_assignment</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
ev-assignment
(assign unev (op assignment-variable) (reg exp))
(save unev)                   <EM>; save variable for later</EM>
(assign exp (op assignment-value) (reg exp))
(save env)
(save continue)
(assign continue (label ev-assignment-1))
(goto (label eval-dispatch))  <EM>; evaluate the assignment value</EM>
ev-assignment-1
(restore continue)
(restore env)
(restore unev)
(perform
(op set-variable-value!) (reg unev) (reg val) (reg env))
(assign val (const ok))
(goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
"ev_assignment",
      assign("unev", list(op("assignment_symbol"), reg("comp"))),
      save("unev"), // save variable for later
      assign("comp", list(op("assignment_value_expression"), reg("comp"))),
      save("env"),
      save("continue"),
      assign("continue", label("ev_assignment_1")),
      go_to(label("eval_dispatch")), // evaluate assignment value
      
"ev_assignment_1",
      restore("continue"),
      restore("env"),
      restore("unev"),
      perform(list(op("assign_symbol_value"),
                   reg("unev"), reg("val"), reg("env"))),
      go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>declarations</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
        Definitions are handled in a similar way:
      </SCHEME>
      <JAVASCRIPT>
        Declarations of variables and constants are handled in a similar way.
        Note that whereas the value of an assignment is the value that was assigned,
        the value of a declaration is
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>. This is handled by
        setting <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> to
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> before continuing. 
        As in the metacircular evaluator, we transform a function declaration
        into a constant declaration whose value expression is a lambda expression. This happens at
        <JAVASCRIPTINLINE>ev_function_declaration</JAVASCRIPTINLINE> which makes the
        transformation in place in <JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE> and
        falls through to <JAVASCRIPTINLINE>ev_declaration</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
      </SPLITINLINE>
      <INDEX><DECLARATION>ev_function_declaration</DECLARATION></INDEX> 
      <INDEX><DECLARATION>ev_declaration</DECLARATION></INDEX> 
      <INDEX><DECLARATION>ev_declaration_assign</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
ev-definition
(assign unev (op definition-variable) (reg exp))
(save unev)                   <EM>; save variable for later</EM>
(assign exp (op definition-value) (reg exp))
(save env)
(save continue)
(assign continue (label ev-definition-1))
(goto (label eval-dispatch))  <EM>; evaluate the definition value</EM>
ev-definition-1
(restore continue)
(restore env)
(restore unev)
(perform
(op define-variable!) (reg unev) (reg val) (reg env))
(assign val (const ok))
(goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
"ev_function_declaration",
      assign("comp", list(op("function_decl_to_constant_decl"), reg("comp"))),

"ev_declaration",
      assign("unev", list(op("declaration_symbol"),
                          reg("comp"))),
      save("unev"), // save declared name
      assign("comp", list(op("declaration_value_expression"),
                          reg("comp"))),
      save("env"),
      save("continue"),
      assign("continue", label("ev_declaration_assign")),
      go_to(label("eval_dispatch")), // evaluate declaration value
      
"ev_declaration_assign",
      restore("continue"),
      restore("env"),
      restore("unev"),
      perform(list(op("assign_symbol_value"),
                   reg("unev"), reg("val"), reg("env"))),
      assign("val", constant(undefined)),
      go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  
  <EXERCISE>
    <LABEL NAME="ex:derived-expressions"/>
    <INDEX>derived components in evaluator<SUBINDEX>adding to explicit-control evaluator</SUBINDEX></INDEX>
    <SPLIT>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme<SUBINDEX>derived expressions</SUBINDEX></INDEX>
	<INDEX>explicit-control evaluator for Scheme<SUBINDEX>special forms (additional)</SUBINDEX></INDEX>
	Extend the evaluator to handle derived expressions such as
	<SCHEMEINLINE>cond</SCHEMEINLINE>,
	<SCHEMEINLINE>let</SCHEMEINLINE>, and so on
	(section<SPACE/><REF NAME="sec:representing-expressions"/>).
	You may <QUOTE>cheat</QUOTE> and assume that the syntax
	transformers such as <SCHEMEINLINE>cond-&gt;if</SCHEMEINLINE> are available
	as machine operations.<FOOTNOTE>This isn<APOS/>t really cheating.  In an
	actual implementation built from scratch, we would use our explicit-control
	evaluator to interpret a Scheme program that performs source-level
	transformations
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>like cond-&gt;if</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE></JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE> in a syntax phase that runs before execution.</FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript<SUBINDEX>derived components</SUBINDEX></INDEX>
	<INDEX>explicit-control evaluator for JavaScript<SUBINDEX>syntactic forms (additional)</SUBINDEX></INDEX>
	Extend the evaluator to handle while 
	loops, by translating them to applications of a function
	<JAVASCRIPTINLINE>while_loop</JAVASCRIPTINLINE>, as shown in
	exercise<SPACE/><REF NAME="ex:while_loop"/>.
	You can then paste the declaration of the function
	<JAVASCRIPTINLINE>while_loop</JAVASCRIPTINLINE> in front of user programs.
	You may <QUOTE>cheat</QUOTE> and assume that the syntax transformer
	<JAVASCRIPTINLINE>while_to_application</JAVASCRIPTINLINE> is available
	as a machine operation.<FOOTNOTE>This isn<APOS/>t really cheating.  In an
	actual implementation built from scratch, we would use our explicit-control
	evaluator to interpret a JavaScript program that performs source-level
	transformations like
	<JAVASCRIPTINLINE>while_to_application</JAVASCRIPTINLINE>
	in a syntax phase that runs before execution.</FOOTNOTE> Refer to
	exercise<SPACE/><REF NAME="ex:while_loop"/> to discuss whether
	this approach works if return, break and continue statements are allowed
	inside the while loop. If not,
	how can you modify the explicit control evaluator to run programs 
	with while loops that include these statements?
      </JAVASCRIPT>
    </SPLIT>
  </EXERCISE>

  <SPLIT>
    <JAVASCRIPT>
      <EXERCISE>
        <LABEL NAME="ex:save_marker1"/>
        Implement the equivalent of <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE> by using
        <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> to store a special marker value on the
        stack.<FOOTNOTE> In exercise <REF NAME="ex:stack-behavior"/>, different ways to
        implement the stack were introduced that changes the semantics of
        <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>restore</JAVASCRIPTINLINE>.

        An implementation where a <JAVASCRIPTINLINE>restore</JAVASCRIPTINLINE> to a
        register is matched with the last <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> of the
        same register, as in alternative<SPACE/>(b), will need to remove all values saved
        after the marker.

        An implementation that uses a dedicated stack per register, as in
        alternative<SPACE/>(c), will need to insert and remove the marker across all
        stacks.

        <LABEL NAME="foot:save_marker1"/></FOOTNOTE> You can implement
        <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE> using a loop that repeatedly
        performs a <JAVASCRIPTINLINE>restore</JAVASCRIPTINLINE> until it hits the marker.
        Note that this will require restoring a value to a register other than the one it
        was saved from. (Although we are careful to avoid that in our evaluator, our stack
        implementation actually allows this. See exercise <REF NAME="ex:stack-behavior"/>.)
        This is necessary because the only way to pop from the stack is by
        restoring to a register.
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>
  
  <EXERCISE>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>syntactic forms (additional)</SUBINDEX></INDEX>
    <SPLIT>
      <SCHEME>
	      Implement <SCHEMEINLINE>cond</SCHEMEINLINE> as a new basic special form
	      without reducing it to <SCHEMEINLINE>if</SCHEMEINLINE>. You will have to
	      construct a loop that tests the predicates of successive
	      <SCHEMEINLINE>cond</SCHEMEINLINE> clauses until you find one that is
	      true, and then use <SCHEMEINLINE>ev-sequence</SCHEMEINLINE> to evaluate
	      the actions of the clause.
      </SCHEME>
      <JAVASCRIPT>
        <LABEL NAME="ex:save_marker2"/>
        Implement <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE>. To do this, extend the
        evaluator with two new instructions, following the implementation of
        <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>restore</JAVASCRIPTINLINE>.<FOOTNOTE> In exercise <REF
        NAME="ex:stack-behavior"/>, different ways to implement the stack were introduced.
        See footnote<SPACE/><REF NAME="foot:save_marker1"/> for details of how to adapt
        this exercise accordingly.</FOOTNOTE> Add two functions
        <JAVASCRIPTINLINE>push_marker</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>pop_marker</JAVASCRIPTINLINE> to access stacks mirroring the
        implementation of <JAVASCRIPTINLINE>push</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>pop</JAVASCRIPTINLINE>. Note that you do not need to actually
        insert a marker into the stack. Instead, you can add a local state variable to the
        stack to keep track of the position of the last
        <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> before a call to
        <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE>. This can be done by extending
        <JAVASCRIPTINLINE>make_stack</JAVASCRIPTINLINE> with two new functions used by
        your new access functions.
      </JAVASCRIPT>
    </SPLIT>
      <LABEL NAME="ex:eceval-cond"/>
  </EXERCISE>

  <EXERCISE>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>normal-order evaluation</SUBINDEX></INDEX>
    <INDEX>normal-order evaluation<SUBINDEX><ORDER>explicit</ORDER>in explicit-control evaluator</SUBINDEX></INDEX>
    Modify the evaluator so that it uses normal-order evaluation,
    based on the lazy evaluator of
    section<SPACE/><REF NAME="sec:lazy-evaluation"/>.
  </EXERCISE>
</SUBSECTION>
