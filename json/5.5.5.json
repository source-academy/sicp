[{"id":"/sicpjs/5.5.5","tag":"TITLE","body":"5.5.5  \n    An Example of Compiled Code"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    Now that we have seen all the elements of the compiler, let us examine\n    an example of compiled code to see how things fit together.  We will\n    compile the\n    declaration\n    of a recursive\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":"function\n\tby passing as first argument to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":"\n\tthe result of applying\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"parse"},{"body":" to\n\ta string representation of the program\n\t(here using\n\t\n\tback quotes\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"`"},{"body":"$\\ldots$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":"`"},{"body":", which work like\n\tsingle and double quotation marks\n\tbut allow the string to span multiple lines):\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"compile(parse(`\nfunction factorial(n) {\n    return n === 1\n           ? 1\n           : factorial(n - 1) * n;\n}\n              `),\n        \"val\",\n        \"next\");"},{"body":"\n    We have specified that the value of the\n    declaration\n    should be placed in the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" register.\n    We don't care what the compiled\n    code does after executing the\n    declaration,\n    so our choice of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":"\n    as the linkage\n    descriptor is arbitrary.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n\tThe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":"\n\tdetermines that it was given a function declaration, so it transforms it\n  to a constant declaration and then\n      \ncalls    \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_declaration"},{"body":". This compiles\n      \n    code to compute the value to be assigned (targeted to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":"), followed by code to install the\n    declaration,\n    followed by code to put the value of the\n    \n\tdeclaration (which is the value\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":")\n      \n    into the target register, followed finally by the linkage code.\n    \n\tThe ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register\n      \n    is preserved around the computation of the\n    value, because it is needed in order to install the\n    \n\tdeclaration.\n      \n    Because\n    the linkage is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":",\n      \n    there is no linkage code\n    in this case.  The skeleton of the compiled code is thus\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\langle{}$save env if modified by code to compute value$\\rangle$\n$\\langle{}$compilation of declaration value, target val, linkage \"next\"$\\rangle$\n$\\langle{}$restore env if saved above$\\rangle$\nperform(list(op(\"assign_symbol_value\"),\n             constant(\"factorial\"),\n             reg(\"val\"),\n             reg(\"env\"))),\nassign(\"val\", constant(undefined))\n      "}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    The expression that is\n    \n    compiled to produce the value for the\n    name","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":"\n    is a\n    lambda\n    expression whose value is the\n    function\n    that computes factorials.\n    \n\tThe function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":"\n    handles this\n    by calling\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_expression"},{"body":",\n      \n    which compiles the\n    function\n    body, labels it as a new entry point, and generates the instruction that\n    will combine the\n    function\n    body at the new entry point with the runtime environment and assign the\n    result to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":".  The sequence then skips around\n    the compiled\n    function\n    code, which is inserted at this point.  The\n    function\n    code itself begins by extending the\n    function's declaration\n    environment by a frame that binds the\n    \n    parameter ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" to the\n    function\n    argument.  Then comes the actual\n    function\n    body.  Since this code for the value of the\n    name\n    doesn't modify the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register, the\n    optional ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":"\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":" shown above aren't\n    generated.  (The\n    function\n    code at\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"entry1"},{"body":"\n     isn't executed at this point,\n    so its use of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" is irrelevant.)\n    Therefore, the skeleton for the compiled code becomes\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\texttt{ }\\texttt{ }$assign(\"val\", list(op(\"make_compiled_function\"), \n                     label(\"entry1\"), \n                     reg(\"env\"))),\n  go_to(label(\"after_lambda2\")),\n\"entry1\",\n  assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))),\n  assign(\"env\", list(op(\"extend_environment\"),\n                     constant(list(\"n\")), \n                     reg(\"argl\"), \n                     reg(\"env\"))),\n  $\\langle{}$compilation of function body$\\rangle$\n\"after_lambda2\",\n  perform(list(op(\"assign_symbol_value\"), \n               constant(\"factorial\"), \n               reg(\"val\"), \n               reg(\"env\"))),\n  assign(\"val\", constant(undefined))\n      "}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    A\n    function\n    body is always compiled (by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_body"},{"body":")\n    with target ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and linkage\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":".\n      \n    The\n    \n\tbody\n      \n    in this case consists of\n    a single\n    \n\treturn statement:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.5.5#footnote-1"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"return n === 1\n       ? 1\n       : factorial(n - 1) * n;"},{"body":"\n\t      The function\n\t      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_return_statement"},{"body":"\n        generates code to revert the stack using the marker and to restore\n       \tthe ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register,\n\t      and then compiles the return \n        expression with target ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and linkage\n\t      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":", because\n\t      its value is to be returned from the function.\n      \n\tThe return expression is a conditional expression, \n\tfor which\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_conditional"},{"body":"\n    generates code that first computes the predicate (targeted to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":"), then checks the result and branches\n    around the true branch if the predicate is false.\n    Registers ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":"\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":"\n    are preserved around the predicate code, since they may be needed for the\n    rest of the\n    conditional\n    expression.\n    \n\tThe\n      \n    true and false branches are both\n    compiled with target ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and linkage\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":".\n      \n    (That is, the value of the conditional,\n    which is the value computed by either of its branches, is the value of the\n    function.)","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":""}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    The predicate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n === 1"},{"body":"\n    is a\n    function application (after transformation of the\n      operator combination).\n      \n    This looks up the\n    \n\tfunction expression\n\t(the symbol ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"===\""},{"body":")\n      \n    and places this value in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":".\n    It then assembles the arguments ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"1"},{"body":" and the value\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" into ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":".\n    Then it tests whether\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":"\n    contains a primitive or a compound\n    function,\n    and dispatches to a primitive branch or a compound branch accordingly.\n    Both branches resume at the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"after_call"},{"body":"\n    label.\n    \n      The compound branch must set up\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" to jump past the primitive\n      branch and push a marker to the stack to match the revert\n      operation in the compiled return statement of the function.\n      \n    The requirements to preserve registers around the evaluation of the\n    \n\tfunction and argument expressions\n      \n    don't result in\n    any saving of registers, because in this case those evaluations don't\n    modify the registers in question.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":""}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    The true branch, which is the constant 1, compiles (with target\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and linkage\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":")\n      \n    to\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\texttt{ }\\texttt{ }$assign(\"val\", constant(1)),\n  go_to(reg(\"continue\")),\n      "},{"body":"\n    The code for the false branch is another\n    function\n    call, where the\n    function\n    is the value of the symbol\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"*\""},{"body":",\n    and the arguments\n    are ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" and the result of another\n    function\n    call (a call to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":").\n    Each of these calls sets up\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":"\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":" and its own primitive\n    and compound branches.  Figure ","tag":"#text"},{"tag":"REF","body":"5.17","href":"/sicpjs/5.5.5#fig-5.17"},{"body":"\n    shows the complete compilation of the\n    \n\tdeclaration\n      \n    of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":"function.\n    Notice that the possible ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":" of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" around the predicate, shown above,\n    are in fact generated, because these registers are modified by the\n    function\n    call in the predicate and needed for the\n    function\n    call and the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n    linkage in the branches.\n  ","tag":"#text"}]},{"tag":"FIGURE","snippet":{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n// construct the function and skip over the code for the function body\n  assign(\"val\", list(op(\"make_compiled_function\"), \n                     label(\"entry1\"), reg(\"env\"))),\n  go_to(label(\"after_lambda2\")),\n\"entry1\",                           // calls to $\\texttt{factorial}$ will enter here\n  assign(\"env\", list(op(\"compiled_function_env\"), reg(\"fun\"))),\n  assign(\"env\", list(op(\"extend_environment\"), constant(list(\"n\")), \n                     reg(\"argl\"), reg(\"env\"))),\n// begin actual function body\n  revert_stack_to_marker(),         // starts with a return statement\n  restore(\"continue\"),\n  save(\"continue\"),                 // preserve registers across predicate\n  save(\"env\"),\n// compute $\\texttt{n === 1}$\n  assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"===\"), reg(\"env\"))),\n  assign(\"val\", constant(1)),\n  assign(\"argl\", list(op(\"list\"), reg(\"val\"))),\n  assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))),\n  assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))),\n  test(list(op(\"is_primitive_function\"), reg(\"fun\"))),\n  branch(label(\"primitive_branch6\")),\n\"compiled_branch7\",\n  assign(\"continue\", label(\"after_call8\")),\n  save(\"continue\"),\n  push_marker_to_stack(),\n  assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\n  go_to(reg(\"val\")),\n\"primitive_branch6\",\n  assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))),\n\"after_call8\",                      // $\\texttt{val}$ now contains result of $\\texttt{n === 1}$\n  restore(\"env\"),\n  restore(\"continue\"),\n  test(list(op(\"is_falsy\"), reg(\"val\"))),\n  branch(label(\"false_branch4\")),\n\"true_branch3\",                     // return 1\n  assign(\"val\", constant(1)),\n  go_to(reg(\"continue\")),\n\"false_branch4\",\n// compute and return $\\texttt{factorial(n - 1) * n}$\n  assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"*\"), reg(\"env\"))),\n  save(\"continue\"),\n  save(\"fun\"),                      // save $\\texttt{*}$ function\n  assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))),\n  assign(\"argl\", list(op(\"list\"), reg(\"val\"))),\n  save(\"argl\"),                     // save partial argument list for $\\texttt{*}$\n// compute $\\texttt{factorial(n - 1)}$ which is the other argument for $\\texttt{*}$\n  assign(\"fun\", list(op(\"lookup_symbol_value\"), \n                     constant(\"factorial\"), reg(\"env\"))),\n  save(\"fun\"),                      // save $\\texttt{factorial}$ function\n    "},"captionHref":"/sicpjs/5.5.5#fig-5.17","captionName":"Figure 5.17 ","captionBody":[{"body":"\n    Compilation of the declaration of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":"function\n    (continued on next page).\n  ","tag":"#text"}]},{"tag":"FIGURE","snippet":{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n// compute $\\texttt{n - 1}$ which is the argument for $\\texttt{factorial}$\n  assign(\"fun\", list(op(\"lookup_symbol_value\"), constant(\"-\"), reg(\"env\"))),\n  assign(\"val\", constant(1)),\n  assign(\"argl\", list(op(\"list\"), reg(\"val\"))),\n  assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"n\"), reg(\"env\"))),\n  assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))),\n  test(list(op(\"is_primitive_function\"), reg(\"fun\"))),\n  branch(label(\"primitive_branch10\")),\n\"compiled_branch11\",\n  assign(\"continue\", label(\"after_call12\")),\n  save(\"continue\"),\n  push_marker_to_stack(),\n  assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\n  go_to(reg(\"val\")),\n\"primitive_branch10\",\n  assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))),\n\"after_call12\",                     // $\\texttt{val}$ now contains result of $\\texttt{n - 1}$\n  assign(\"argl\", list(op(\"list\"), reg(\"val\"))),\n  restore(\"fun\"),                   // restore $\\texttt{factorial}$\n// apply $\\texttt{factorial}$\n  test(list(op(\"is_primitive_function\"), reg(\"fun\"))),\n  branch(label(\"primitive_branch14\")),\n\"compiled_branch15\",\n  assign(\"continue\", label(\"after_call16\")),\n  save(\"continue\"),                 // set up for compiled function $-$\n  push_marker_to_stack(),           //   return in function will restore stack\n  assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\n  go_to(reg(\"val\")),\n\"primitive_branch14\",\n  assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))),\n\"after_call16\",                     // $\\texttt{val}$ now contains result of $\\texttt{factorial(n - 1)}$\n  restore(\"argl\"),                  // restore partial argument list for $\\texttt{*}$\n  assign(\"argl\", list(op(\"pair\"), reg(\"val\"), reg(\"argl\"))),\n  restore(\"fun\"),                   // restore $\\texttt{*}$\n  restore(\"continue\"),\n// apply $\\texttt{*}$ and return its value\n  test(list(op(\"is_primitive_function\"), reg(\"fun\"))),\n  branch(label(\"primitive_branch18\")),\n\"compiled_branch19\", // note that a compound function here is called tail-recursively\n  save(\"continue\"),\n  push_marker_to_stack(),\n  assign(\"val\", list(op(\"compiled_function_entry\"), reg(\"fun\"))),\n  go_to(reg(\"val\")),\n\"primitive_branch18\",\n  assign(\"val\", list(op(\"apply_primitive_function\"), reg(\"fun\"), reg(\"argl\"))),\n  go_to(reg(\"continue\")),\n\"after_call20\",\n\"after_cond5\",\n\"after_lambda2\",\n// assign the function to the name $\\texttt{factorial}$\n  perform(list(op(\"assign_symbol_value\"), \n               constant(\"factorial\"), reg(\"val\"), reg(\"env\"))),\n  assign(\"val\", constant(undefined))\n    "},"captionHref":"/sicpjs/5.5.5#fig-5.18","captionName":"Figure 5.18 ","captionBody":[{"body":"(continued)","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.35","id":"#ex-5.35","child":[{"body":"\n    Consider the following declaration of a factorial\n    function,\n    which is slightly different from the one given above:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"function factorial_alt(n) {\n    return n === 1\n           ? 1\n           : n * factorial_alt(n - 1);\n}"},{"body":"\n    Compile this\n    function\n    and compare the resulting code with that produced for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":".  Explain any differences you find.\n    Does either program execute more efficiently than the other?\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.36","id":"#ex-5.36","child":[{"body":"\n    Compile the\n    \n    iterative factorial\n    function","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"function factorial(n) {\n    function iter(product, counter) {\n        return counter > n\n               ? product\n               : iter(product * counter, counter + 1);\n    }\n    return iter(1, 1);\n}"},{"body":"\n    Annotate the resulting code, showing the essential difference between\n    the code for iterative and recursive versions of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":" that makes one process build up\n    stack space and the other run in constant stack space.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.37","id":"#ex-5.37","child":[{"body":"\n  What\n  \n      program\n    \n  was compiled to produce the code shown in\n  figure ","tag":"#text"},{"tag":"REF","body":"5.19","href":"/sicpjs/5.5.5#fig-5.19"},{"body":"?\n  ","tag":"#text"}]},{"tag":"FIGURE","snippet":{"tag":"SNIPPET","latex":true,"eval":false,"body":""},"captionHref":"/sicpjs/5.5.5#fig-5.19","captionName":"Figure 5.19 ","captionBody":[{"body":"\n    An example of compiler output (continued on next page).\n    See exercise ","tag":"#text"},{"tag":"REF","body":"5.37","href":"/sicpjs/5.5.5#ex-5.37"},{"body":".\n  ","tag":"#text"}]},{"tag":"FIGURE","snippet":{"tag":"SNIPPET","latex":true,"eval":false,"body":""},"captionHref":"/sicpjs/5.5.5#fig-5.20","captionName":"Figure 5.20 ","captionBody":[{"body":"(continued)","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.38","id":"#ex-5.38","child":[{"body":"\n    What\n    \n    order of evaluation does our compiler produce for\n    arguments of an application?\n    Is it left-to-right (as mandated by the ECMAScript specification), right-to-left, or some other order?\n    Where in the compiler is this order determined?  Modify the compiler\n    so that it produces some other order of evaluation.  (See the\n    discussion of order of evaluation for the explicit-control evaluator\n    in section ","tag":"#text"},{"tag":"REF","body":"5.4.1","href":"/sicpjs/5.4.1"},{"body":".)  How does changing the\n    order of\n    argument\n    evaluation affect the efficiency of the code that\n    constructs the argument list?\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.39","id":"#ex-5.39","child":[{"body":"\n    One way to understand the compiler's\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" mechanism for\n    optimizing stack usage is to see what extra operations would\n    be generated if we did not use this idea.  Modify\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" so\n    that it always generates the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":" operations.\n    Compile some simple expressions and identify the unnecessary stack\n    operations that are generated.\n    Compare the code to that generated with the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" mechanism intact.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.40","id":"#ex-5.40","child":[{"body":"\n    Our compiler is clever about avoiding unnecessary stack operations,\n    but it is not clever at all when it comes to compiling calls to the primitive\n    functions\n    of the language in terms of the primitive operations\n    supplied by the machine.  For example, consider how much code is\n    compiled to compute\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a + 1"},{"body":":\n    The code sets up an argument list in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":", puts\n    the primitive addition\n    function\n    (which it finds by looking up the symbol\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"+\""},{"body":"\n    in the environment) into\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":",\n    and tests whether the\n    function\n    is primitive or compound.  The\n    compiler always generates code to perform the test, as well as code\n    for primitive and compound branches (only one of which will be executed).\n    We have not shown the part of the controller that implements\n    primitives, but we presume that these instructions make use of\n    primitive arithmetic operations in the machine's data paths.  Consider\n    how much less code would be generated if the compiler could\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"open-code","tag":"#text"}]},{"body":" primitives—that is, if it could generate code to\n    directly use these primitive machine operations.  The expression\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a + 1"},{"body":"\n    might be compiled into something as simple as","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.5.5#footnote-2"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"assign(\"val\", list(op(\"lookup_symbol_value\"), constant(\"a\"), reg(\"env\"))),\nassign(\"val\", list(op(\"+\"), reg(\"val\"), constant(1)))"},{"body":"\n    In this exercise we will extend our compiler to support open coding of\n    selected primitives.  Special-purpose code will be generated for calls to these primitive\n    functions\n    instead of the general\n    function-application\n    code.  In order to support this, we will augment\n    our machine with special argument registers\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"arg1"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"arg2"},{"body":".\n    The primitive arithmetic operations of the machine will take their\n    inputs from ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"arg1"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"arg2"},{"body":". The results may be put into\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"arg1"},{"body":", or\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"arg2"},{"body":".\n    \n    The compiler must be able to recognize the application of an\n    open-coded primitive in the source program.  We will augment the\n    dispatch in the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":"function\n    to recognize the names of these primitives in addition to the\n    \n\tsyntactic forms it currently recognizes.\n      \n    For each\n    syntactic\n    form our compiler has a code\n    generator.  In this exercise we will construct a family of code generators\n    for the open-coded primitives.\n    ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\tThe open-coded primitives, unlike the\n\tsyntactic\n\tforms, all need their\n\targument expressions\n\tevaluated.  Write a code generator\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"spread_arguments"},{"body":"\n\tfor use by all the open-coding code generators.\n\t\n\t    The function\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"spread_arguments"},{"body":"\n\tshould take\n\ta list of argument expressions\n\tand compile the given\n\targument expressions\n\ttargeted to\n\tsuccessive argument registers.  Note that an\n\targument expression\n\tmay contain a call\n\tto an open-coded primitive, so argument registers will have to be\n\tpreserved during\n\targument-expression\n\tevaluation.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t    The JavaScript operators\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"==="},{"body":",\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"*"},{"body":",\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"-"},{"body":", and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"+"},{"body":",\n\t    among others, are implemented in the register machine as\n\t    primitive functions and are referred to in the global environment\n\t    with the symbols\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"===\""},{"body":",\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"*\""},{"body":",\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"-\""},{"body":", and\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"+\""},{"body":". In JavaScript, it is\n\t    not possible to redeclare these names, because they do not\n\t    meet the syntactic restrictions for names. This means it is safe\n\t    to open-code them.\n\t  \n\tFor each of the primitive\n\tfunctions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"==="},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"*"},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"-"},{"body":", and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"+"},{"body":",\n\twrite a code generator that takes\n\tan application with a function expression that\n\t  names that function,\n\t  \n\ttogether with a target and a linkage descriptor, and\n\tproduces code to spread the arguments into the registers and then\n\tperform the operation targeted to the given target with the given\n\tlinkage.\n\t\n\tMake ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":" dispatch to these code\n\tgenerators.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tTry your new compiler on the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":"\n\texample.  Compare the resulting code with the result produced without\n\topen coding.\n      ","tag":"#text"}]}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.5.5#footnote-link-1","child":[{"body":"\n  Because of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_return_undefined"},{"body":" in\n  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_body"},{"body":", the body actually\n  consists of a sequence with two return statements. However, the dead-code check\n  in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_sequence"},{"body":" will stop after the compilation\n  of the first return statement,\n  so the body effectively consists of only a single return statement.\n","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.5.5#footnote-link-2","child":[{"body":"We have used\n    the same symbol ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"+"},{"body":" here to denote both the\n    source-language\n    function\n    and the machine operation.  In general there will not be a\n    one-to-one correspondence between primitives of the source language\n    and primitives of the machine.","tag":"#text"}]}]