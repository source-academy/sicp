<SUBSECTION>
   <NAME>
    条件表达式和谓词
  </NAME> 
  <LABEL NAME="sec:conditionals"></LABEL>

  <TEXT> 
    目前我们可以定义的
    <SPLITINLINE>
      
	procedure
      
      <JAVASCRIPT>
	function
      </JAVASCRIPT>
    </SPLITINLINE>
    类别的表达能力非常有限，因为我们无法进行测试，并依据测试结果执行不同的操作。
<SPLIT>
      <SCHEME>
        For instance, we cannot define a procedure that computes the 
        <INDEX>absolute value</INDEX>
        absolute
        value of a number by testing whether the number is positive, negative,
        or zero and taking different actions in the different cases according
        to the rule
        <LATEX>
      \[\begin{array}{lll}
          |x| &amp; = &amp; \left\{ \begin{array}{rl}
          x   &amp; \mbox{if $x&gt;0$} \\
          0   &amp; \mbox{if $x=0$} \\
          -x  &amp; \mbox{if $x&lt;0$}
          \end{array}
          \right.
      \end{array}\]
        </LATEX>
        This construct is called a
        <INDEX>case analysis<SUBINDEX>general</SUBINDEX></INDEX>
	<EM>case analysis</EM>, and
        there is a special form in Lisp for notating such a case
        analysis.  It is called 
        <INDEX><DECLARATION>cond</DECLARATION></INDEX> 
        <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>cond</ORDER><SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX>conditional expression<SUBINDEX><ORDER>cond</ORDER><SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
        <SCHEMEINLINE>cond</SCHEMEINLINE> (which stands for
        <QUOTE>conditional</QUOTE>), and it is used as follows:
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX> 
          <NAME>abs_definition</NAME>
          <EXAMPLE>abs_example</EXAMPLE>
          <SCHEME>
(define (abs x)
  (cond ((&gt; x 0) x)
        ((= x 0) 0)
        ((&lt; x 0) (- x))))
          </SCHEME>
        </SNIPPET>
        <SNIPPET EVAL="no">
          <NAME>abs_example</NAME>
          <SCHEME>
(abs (- 5))
          </SCHEME>
        </SNIPPET>
        The general form of a conditional expression is
        <SNIPPET EVAL="no" LATEX="yes">
          <SCHEME>
(cond ($\langle p_1 \rangle $ $\langle e_1 \rangle$)
      ($\langle p_2 \rangle $ $\langle e_2 \rangle$)
      $\vdots$
      ($\langle p_n \rangle $ $\langle e_n \rangle$))
          </SCHEME>
        </SNIPPET>
        consisting of the symbol <SCHEMEINLINE>cond</SCHEMEINLINE> followed by
        <INDEX>parentheses<SUBINDEX><ORDER>delimiting cond</ORDER>delimiting <SCHEMEINLINE>cond</SCHEMEINLINE> clauses</SUBINDEX></INDEX>
        parenthesized pairs of expressions
	<SCHEMEINLINE>(</SCHEMEINLINE><LATEXINLINE>$\langle p\ e \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE>
        called 
        <INDEX>clause, of a <SCHEMEINLINE>cond</SCHEMEINLINE></INDEX>
        <INDEX><DECLARATION>cond</DECLARATION><SUBINDEX>clause</SUBINDEX></INDEX>
        <EM>clauses</EM>. The first expression in each pair is a 
        <INDEX>predicate<SUBINDEX><ORDER>cond</ORDER>of <SCHEMEINLINE>cond</SCHEMEINLINE> clause</SUBINDEX></INDEX>
	<INDEX>conditional expression<SUBINDEX>predicate, consequent, alternative of</SUBINDEX></INDEX>
        <EM>predicate</EM><EMDASH></EMDASH>that is, an expression whose value is
	interpreted as either true or false.<FOOTNOTE>
        <QUOTE>Interpreted as either
        <INDEX>true</INDEX>
	<INDEX>false</INDEX>
        <INDEX><DECLARATION>\#t</DECLARATION></INDEX>
	<INDEX><DECLARATION>true</DECLARATION></INDEX>
        <INDEX><DECLARATION>\#f</DECLARATION></INDEX>
	<INDEX><DECLARATION>false</DECLARATION></INDEX> 
	true or false</QUOTE>
        means this: In Scheme, there are two distinguished values that are
        denoted by the constants 
        <SCHEMEINLINE>#t</SCHEMEINLINE> and <SCHEMEINLINE>#f</SCHEMEINLINE>.  
        When the interpreter checks a predicate<APOS></APOS>s value, it interprets 
        <SCHEMEINLINE>#f</SCHEMEINLINE> as false.  Any other value
        is treated as true.  (Thus, providing <SCHEMEINLINE>#t</SCHEMEINLINE>
	is logically unnecessary, but it is convenient.)  In this book we will
	use names <SCHEMEINLINE>true</SCHEMEINLINE> and
	<SCHEMEINLINE>false</SCHEMEINLINE>, 
        which are associated with the values <SCHEMEINLINE>#t</SCHEMEINLINE> and 
        <SCHEMEINLINE>#f</SCHEMEINLINE> respectively.</FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	 <COMMENT>
	  我们在这里从条件表达式开始，因为它们更适合于代换模型。请注意，第 1.1.1 节到第 1.1.7 节中的所有函数的主体有一个单一的返回语句，这强调了条件表达式的重要性。条件语句将在 1.3.2 中介绍。
	</COMMENT>
        例如，我们无法声明一个计算
        <INDEX>绝对值</INDEX>
        的函数，通过测试该数字是否为非负数，并根据规则在每种情况下采取不同的行动。
<LATEX>
      \[\begin{array}{lll}
          |x| &amp; = &amp; \left\{ \begin{array}{rl}
          x   &amp; \mbox{if $x \geq 0$} \\
          -x  &amp; \mbox{otherwise}
          \end{array}
          \right.
      \end{array}\]
        </LATEX>
	 <COMMENT>
	  我们简化例子，以便可以用一个条件表达式解决问题。
	</COMMENT>
        这种结构是一种
	<INDEX>情况分析</INDEX>
	<EM>情况分析</EM>，可以使用
	<EM>条件表达式</EM>在 JavaScript 中编写。
<SNIPPET>
	  <INDEX><DECLARATION>abs</DECLARATION></INDEX>
          <NAME>abs_definition</NAME>
          <EXAMPLE>abs_example</EXAMPLE>
          <JAVASCRIPT>
function abs(x) {
    return x &gt;= 0 ? x : - x;
}
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <NAME>abs_example</NAME>
	  <REQUIRES>abs_definition</REQUIRES>
	  <EXPECTED>5</EXPECTED>
          <JAVASCRIPT>
abs(-5);
          </JAVASCRIPT>
        </SNIPPET> 
	可以用英语表达为 <QUOTE>如果 $x$ 大于或等于零，则返回 $x$; 否则 返回 $- x$。</QUOTE>
	条件表达式的一般形式是
 <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
<META>predicate</META> ? <META>consequent-expression</META> : <META>alternative-expression</META>
          </JAVASCRIPT>
        </SNIPPET> 
        条件
	<INDEX>条件表达式</INDEX>
	<INDEX>语法形式<SUBINDEX>条件表达式</SUBINDEX></INDEX>
	<INDEX><JAVASCRIPTINLINE>?</JAVASCRIPTINLINE><SPACE></SPACE><JAVASCRIPTINLINE>:</JAVASCRIPTINLINE><ORDER>;3</ORDER></INDEX>
	<INDEX>谓词<SUBINDEX><ORDER>条件</ORDER>的条件表达式</SUBINDEX></INDEX>
	<INDEX><ORDER>true</ORDER><USE>true</USE> (关键字)</INDEX>
	<INDEX><ORDER>false</ORDER><USE>false</USE> (关键字)</INDEX>
	<INDEX>关键字<SUBINDEX><ORDER>true</ORDER><USE>true</USE></SUBINDEX></INDEX>
	<INDEX>关键字<SUBINDEX><ORDER>false</ORDER><USE>false</USE></SUBINDEX></INDEX>
	<INDEX>表达式<SUBINDEX>原语布尔</SUBINDEX></INDEX>
	<INDEX>布尔值 (true, false)</INDEX>
	表达式以一个
        <META>谓词</META><EMDASH></EMDASH>开始，
        也就是一个值为
	<EM>true</EM> 或 <EM>false</EM> 的表达式，这在 JavaScript 中是两个特定的
	<EM>布尔</EM> 值。
	原语布尔表达式
	<JAVASCRIPTINLINE>true</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>false</JAVASCRIPTINLINE> 显然评估为布尔值 true 和 false，分别。
	<META>谓词</META> 
        后面跟着一个问号， 
        <META>后续表达式</META>，
        一个冒号，最后是 
        <META>替代表达式</META>。
</JAVASCRIPT>
    </SPLIT>
  </TEXT>
  <SPLIT>
    <SCHEME>
      <TEXT>
        Conditional expressions are
        <INDEX><DECLARATION>cond</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
        <INDEX>evaluation<SUBINDEX><ORDER>of cond</ORDER>of <SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
	evaluated as follows.  The predicate
        <LATEXINLINE>$\langle p_1 \rangle$</LATEXINLINE> is evaluated first.
	If its value is false, then
        <LATEXINLINE>$\langle p_2 \rangle$</LATEXINLINE> is evaluated.  
        If <LATEXINLINE>$\langle p_2 \rangle$</LATEXINLINE><APOS></APOS>s 
        value is also false, then
        <LATEXINLINE>$\langle p_3 \rangle$</LATEXINLINE> is evaluated.  
        This process continues until a predicate is
        found whose value is true, in which case the interpreter returns the
        value of the corresponding 
        <INDEX>consequent<SUBINDEX><ORDER>cond</ORDER>of <SCHEMEINLINE>cond</SCHEMEINLINE> clause</SUBINDEX></INDEX>
        <EM>consequent expression</EM>
	<LATEXINLINE>$\langle e \rangle$</LATEXINLINE> of the
        clause as the value of the conditional expression.  If none of the
        <LATEXINLINE>$\langle p \rangle$</LATEXINLINE><APOS></APOS>s
	is found to be true, the value of the <SCHEMEINLINE>cond</SCHEMEINLINE>
	is undefined.
      </TEXT>
    </SCHEME>
     <JAVASCRIPT>
      <TEXT>
        为了
	<INDEX>求值<SUBINDEX>条件表达式的</SUBINDEX></INDEX>
	<INDEX>条件表达式<SUBINDEX>的求值</SUBINDEX></INDEX>
	评估一个条件表达式，
	解释器首先评估该表达式的
        <META>谓词</META>。
        如果
	<META>谓词</META>
	评估为 true，解释器将评估
        <INDEX>后续<SUBINDEX><ORDER>条件表达式</ORDER>的条件表达式</SUBINDEX></INDEX>
        <META>后续表达式</META> 并将其值作为条件的值返回。
        如果 <META>谓词</META>
	评估为 false，它将评估
        <INDEX>替代<SUBINDEX><ORDER>条件表达式</ORDER>的条件表达式</SUBINDEX></INDEX>
        <META>替代表达式</META> 并将其值作为条件的值返回。<FOOTNOTE>
	<INDEX>条件表达式<SUBINDEX>非布尔值作为谓词</SUBINDEX></INDEX>
	条件语句
	
	在完整的 JavaScript 中接受任何值，而不仅仅是布尔值，作为评估
	<META>谓词</META> 表达式的结果（有关详细信息，请参见脚注<SPACE></SPACE><REF NAME="foot:truthy"></REF>
	在节<SPACE></SPACE><REF NAME="sec:eval-data-structures"></REF>中）。本书中的程序
	仅使用布尔值作为条件的谓词。
      </FOOTNOTE>
      </TEXT>
    </JAVASCRIPT>
   </SPLIT>
  <SPLIT>
    <SCHEME>
      <TEXT>
        The word
        <INDEX>predicate</INDEX>
	<EM>predicate</EM> is used for procedures that return true
        or false, as well as for expressions that evaluate to true or false.
        The absolute-value procedure <SCHEMEINLINE>abs</SCHEMEINLINE> makes use of the 
        <INDEX><USE>&gt;</USE> (primitive numeric comparison predicate)</INDEX>   
        <INDEX><USE>&lt;</USE> (primitive numeric comparison predicate)</INDEX>   
        <INDEX><USE>=</USE> (primitive numeric equality predicate)</INDEX>   
        <INDEX><USE>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</USE><SUBINDEX><ORDER>&gt;</ORDER><SCHEMEINLINE>&gt;</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX><USE>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</USE><SUBINDEX><ORDER>&lt;</ORDER><SCHEMEINLINE>&lt;</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX><USE>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</USE><SUBINDEX><ORDER>=</ORDER><SCHEMEINLINE>=</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX>number(s)<SUBINDEX>comparison of</SUBINDEX></INDEX>
        <INDEX>number(s)<SUBINDEX>equality of</SUBINDEX></INDEX>
        <INDEX>equality<SUBINDEX><ORDER>numbers</ORDER>of numbers</SUBINDEX></INDEX>
        primitive predicates <SCHEMEINLINE>&gt;</SCHEMEINLINE>, 
        <SCHEMEINLINE>&lt;</SCHEMEINLINE>, and 
        <SCHEMEINLINE>=</SCHEMEINLINE>.<FOOTNOTE>
	<SCHEMEINLINE>Abs</SCHEMEINLINE> also uses
        <INDEX><USE>-</USE> (primitive subtraction procedure)<SUBINDEX>as negation</SUBINDEX></INDEX>
        <INDEX><USE>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</USE><SUBINDEX><ORDER>-</ORDER><SCHEMEINLINE>-</SCHEMEINLINE></SUBINDEX></INDEX>
        the <QUOTE>minus</QUOTE> operator <SCHEMEINLINE>-</SCHEMEINLINE>, 
        which, when used with a single
        operand, as in <SCHEMEINLINE>(- x)</SCHEMEINLINE>, 
        indicates negation.</FOOTNOTE> These take two numbers as arguments and
	test whether the first number is, respectively, greater than, less than,
	or equal to the second number, returning true or false accordingly.
      </TEXT>
    </SCHEME>
     <JAVASCRIPT>
      <TEXT>
        词
        <INDEX>谓词</INDEX>
	<EM>谓词</EM> 用于返回 true 或 false 的运算符和函数，以及用于评估为 true 或 false 的表达式。绝对值函数
	<JAVASCRIPTINLINE>abs</JAVASCRIPTINLINE> 利用
	<INDEX><USE>&gt;=</USE> (数值比较运算符)</INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>&gt;=</USE> (数值比较)</SUBINDEX><FRAGILE></FRAGILE></INDEX>
        <INDEX>数字<SUBINDEX>比较</SUBINDEX></INDEX>
        <INDEX>数字<SUBINDEX>相等性</SUBINDEX></INDEX>
        原语谓词 <JAVASCRIPTINLINE>&gt;=</JAVASCRIPTINLINE>，
	一个接受两个数字作为参数并测试第一个数字是否大于或等于第二个数字的运算符，返回 true 或 false。
      </TEXT>
    </JAVASCRIPT>
   </SPLIT>
   <SPLIT>
    
      <TEXT>
        另一种写绝对值过程的方法是
        
          <INDEX><DECLARATION>abs</DECLARATION></INDEX> 
          <EXAMPLE>abs_example</EXAMPLE>
          
(define (abs x)
  (cond ((&lt; x 0) (- x))
    (else x)))
          
        
        可以用英语表达为 
        <QUOTE>如果 $x$ 小于零
        则返回 $- x$; 否则返回 
        $x$.</QUOTE>  
        <INDEX><DECLARATION>else</DECLARATION> (在 cond 中的特殊符号)</INDEX>
        Else 是一个特殊符号，可以在
	cond 的最终子句中替代 $\langle p \rangle$。  
        这使得 cond 返回其值 
        对应的
	$\langle e \rangle$
        每当所有先前的条款被跳过时。事实上，任何
	始终评估为真值的表达式都可以在这里用作
	$\langle p \rangle$。
      </TEXT>
    
    <JAVASCRIPT>
    </JAVASCRIPT>
  </SPLIT> 
  <SPLIT>
    <SCHEME>
      <TEXT>
        Here is yet another way to write the absolute-value procedure:
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX> 
          <EXAMPLE>abs_example</EXAMPLE>
          <SCHEME>
(define (abs x)
  (if (&lt; x 0)
    (- x)
    x))
          </SCHEME>
        </SNIPPET>
        <INDEX>conditional expression<SUBINDEX><ORDER>if</ORDER><SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        This uses the
        <INDEX><DECLARATION>if</DECLARATION></INDEX>
        <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>if</ORDER><SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
	special form <SCHEMEINLINE>if</SCHEMEINLINE>, a restricted 
        type of conditional that can be used when there are precisely 
        <INDEX>case analysis<SUBINDEX><ORDER>two</ORDER>with two cases (<SCHEMEINLINE>if</SCHEMEINLINE>)</SUBINDEX></INDEX>
        two cases in the case
        analysis.  The general form of an <SCHEMEINLINE>if</SCHEMEINLINE>
	expression is
        <SNIPPET EVAL="no" LATEX="yes">
          <SCHEME>
(if $\langle \textit{predicate} \rangle$ $\langle \textit{consequent}\rangle$ $\langle \textit{alternative}\rangle$)
          </SCHEME>
        </SNIPPET>
        To
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
        <INDEX>evaluation<SUBINDEX><ORDER>of if</ORDER>of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX>predicate, consequent, and alternative of</SUBINDEX></INDEX>
	evaluate an <SCHEMEINLINE>if</SCHEMEINLINE> expression, 
        the interpreter starts by evaluating the 
        <INDEX>predicate<SUBINDEX><ORDER>if</ORDER>of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        <LATEXINLINE>$\langle \textit{predicate}\rangle$</LATEXINLINE> 
        part of the expression.  
        If the <LATEXINLINE>$\langle \textit{predicate}\rangle$</LATEXINLINE> 
        evaluates to a true value, the interpreter then evaluates the 
        <INDEX>consequent<SUBINDEX><ORDER>if</ORDER>of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        <LATEXINLINE>$\langle \textit{consequent}\rangle$</LATEXINLINE> 
        and returns its value.  Otherwise it evaluates the 
        <INDEX>alternative of <SCHEMEINLINE>if</SCHEMEINLINE></INDEX>
        <LATEXINLINE>$\langle \textit{alternative}\rangle$</LATEXINLINE> 
        and returns its value.<FOOTNOTE>A minor 
        difference
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX><ORDER>cond</ORDER><SCHEMEINLINE>cond</SCHEMEINLINE> vs.</SUBINDEX></INDEX>
        <INDEX><DECLARATION>cond</DECLARATION><SUBINDEX><ORDER>if</ORDER><SCHEMEINLINE>if</SCHEMEINLINE> vs.</SUBINDEX></INDEX>
        <INDEX>sequence of expressions<SUBINDEX>in consequent of <SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
	between <SCHEMEINLINE>if</SCHEMEINLINE> and 
        <SCHEMEINLINE>cond</SCHEMEINLINE> is that the
        <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
        part of each <SCHEMEINLINE>cond</SCHEMEINLINE> 
        clause may be a sequence of expressions.
        If the corresponding <LATEXINLINE>$\langle p \rangle$</LATEXINLINE> 
        is found to be true, 
        the expressions 
        <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
        are evaluated in sequence and the value of the final
        expression in the sequence is returned as the value of the 
        <SCHEMEINLINE>cond</SCHEMEINLINE>.
        In an <SCHEMEINLINE>if</SCHEMEINLINE> expression, however, 
        the <LATEXINLINE>$\langle \textit{consequent}\rangle$</LATEXINLINE> and
        <LATEXINLINE>$\langle \textit{alternative}\rangle$</LATEXINLINE> must
	be single expressions.<LABEL NAME="foot:cond-consequent"></LABEL></FOOTNOTE>
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <LONG_PAGE LINES="1"></LONG_PAGE>
      <TEXT> 
      如果我们更愿意单独处理零的情况，我们可以通过编写来指定计算一个数字绝对值的函数。
<LATEX>
      \[\begin{array}{lll}
          |x| &amp;=&amp; \left\{ \begin{array}{rl}
          x   &amp; \mbox{if $x &gt; 0$} \\
          0   &amp; \mbox{if $x = 0$} \\
          -x  &amp; \mbox{otherwise}
          \end{array}
          \right.
          \end{array}\]
        </LATEX> 
	在 JavaScript 中，我们通过在其他条件表达式内部将条件表达式嵌套作为替代表达式来表达具有多个条件的情况分析：
<SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX>
          <EXAMPLE>abs_example</EXAMPLE>
          <JAVASCRIPT>
function abs(x) {
    return x &gt; 0
           ? x
           : x === 0
           ? 0
           : - x;
}
	  </JAVASCRIPT>
        </SNIPPET> 
	替代表达式
	<JAVASCRIPTINLINE>x === 0 ? 0 : - x</JAVASCRIPTINLINE> 周围不需要括号，因为条件表达式的语法形式
	<INDEX>条件表达式<SUBINDEX><ORDER>替代</ORDER>作为条件表达式的替代</SUBINDEX></INDEX>
	<INDEX>结合性<SUBINDEX><ORDER>条件表达式</ORDER>的条件表达式</SUBINDEX></INDEX>
	<INDEX>条件表达式<SUBINDEX>的右结合性</SUBINDEX></INDEX>
	<INDEX>右结合的</INDEX>
	是右结合的。
	解释器忽略空格和换行符，这里插入是为了可读性，以对齐
	<JAVASCRIPTINLINE>?</JAVASCRIPTINLINE><APOS></APOS>和 <JAVASCRIPTINLINE>:</JAVASCRIPTINLINE><APOS></APOS>  
	在情况分析的第一个谓词下。
	一般的情况分析
	<INDEX>情况分析<SUBINDEX>一般</SUBINDEX></INDEX>
	的形式是
  <DO_BREAK_PAGE></DO_BREAK_PAGE>
<SNIPPET LATEX="yes" EVAL="no">
	  <JAVASCRIPT>
<META>p</META>$_1$
? <META>e</META>$_1$
: <META>p</META>$_2$
? <META>e</META>$_2$
$\vdots$
: <META>p</META>$_n$
? <META>e</META>$_n$
: <META>final-alternative-expression</META>
	  </JAVASCRIPT>
	</SNIPPET> 
	我们称谓词 
<LATEXINLINE>$p_i$</LATEXINLINE> 
	连同其后续表达式
<LATEXINLINE>$e_i$</LATEXINLINE> 
	一个
	<INDEX>情况分析的子句</INDEX>
	<INDEX>谓词<SUBINDEX><ORDER>子句</ORDER>的子句</SUBINDEX></INDEX>
	<EM>子句</EM>。情况分析
	可以看作是一系列子句，后面跟着一个最终的
	替代表达式。
	<INDEX>情况分析<SUBINDEX><ORDER>子句序列</ORDER>的序列</SUBINDEX></INDEX>
	根据条件表达式的评估，
	情况分析是通过首先评估
	谓词 <META>p</META> 来进行评估的。
<LATEXINLINE>$_1$</LATEXINLINE> 
	如果它的值为假，那么 <META>p</META> 
<LATEXINLINE>$_2$</LATEXINLINE> 
	被评估。
	如果 <META>p</META> 
<LATEXINLINE>$_2$</LATEXINLINE> 
	的值也是假，那么 <META>p</META> 
<LATEXINLINE>$_3$</LATEXINLINE> 
	被评估。此过程继续，直到找到一个谓词，其值为 true，此时，解释器返回对应的
	<INDEX>后续<SUBINDEX><ORDER>子句</ORDER>的子句</SUBINDEX></INDEX>
	后续表达式
	<META>e</META>
	作为情况分析的值。
	如果没有任何
	<META>p</META><APOS></APOS> 被发现为 true，情况分析的值
	就是最终替代表达式的值。
</TEXT>
    </JAVASCRIPT>
  </SPLIT>
  <SPLIT>
    <SCHEME>
      <TEXT>
        In addition to primitive predicates such as
	<SCHEMEINLINE>&lt;</SCHEMEINLINE>,
	<SCHEMEINLINE>=</SCHEMEINLINE>, and <SCHEMEINLINE>&gt;</SCHEMEINLINE>,
	there are logical composition operations, which enable us to construct
	compound predicates.  The three most frequently used are these:
        <UL>
          <LI>
            <INDEX><DECLARATION>and</DECLARATION></INDEX> 
            <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>and</ORDER><SCHEMEINLINE>and</SCHEMEINLINE></SUBINDEX></INDEX>
            <INDEX><DECLARATION>and</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
            <INDEX>evaluation<SUBINDEX><ORDER>of and</ORDER>of <SCHEMEINLINE>and</SCHEMEINLINE></SUBINDEX></INDEX>
	    <SCHEMEINLINE>(and</SCHEMEINLINE>
	    <LATEXINLINE>$\langle e_1\rangle \ldots \langle e_n \rangle$
	    </LATEXINLINE>
	    <SCHEMEINLINE>)</SCHEMEINLINE><BR></BR>
            The interpreter evaluates the expressions
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> one at a time, 
            in left-to-right order.  If any
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> evaluates to false, 
            the value of the <SCHEMEINLINE>and</SCHEMEINLINE> expression is
	    false, and the rest of the
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS></APOS>s 
            are not evaluated. If all
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS></APOS>s
	    evaluate to true values, the value of the
	    <SCHEMEINLINE>and</SCHEMEINLINE>
            expression is the value of the last one.
          </LI>
          <LI>
            <INDEX><DECLARATION>or</DECLARATION></INDEX> 
            <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>or</ORDER><SCHEMEINLINE>or</SCHEMEINLINE></SUBINDEX></INDEX>
            <INDEX><DECLARATION>or</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
            <INDEX>evaluation<SUBINDEX><ORDER>of or</ORDER>of <SCHEMEINLINE>or</SCHEMEINLINE></SUBINDEX></INDEX>
            <SCHEMEINLINE>(or</SCHEMEINLINE> <LATEXINLINE>$\langle e_1 \rangle\ldots \langle e_n \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE><BR></BR>
            The interpreter evaluates the expressions 
            <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> one at a time, in
	    left-to-right order.  If any
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE>
	    evaluates to a true value, that value is returned as the value of the
	    <SCHEMEINLINE>or</SCHEMEINLINE> expression, and the rest of the
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS></APOS>s are not
	    evaluated. If all
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS></APOS>s
	    evaluate to false, the value of the
	    <SCHEMEINLINE>or</SCHEMEINLINE> expression is false.
          </LI>
          <LI>
            <INDEX><DECLARATION>not</DECLARATION></INDEX> 
            <INDEX><DECLARATION>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>not</ORDER><SCHEMEINLINE>not</SCHEMEINLINE></SUBINDEX></INDEX>
            <SCHEMEINLINE>(not</SCHEMEINLINE>
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><SCHEMEINLINE>)
	    </SCHEMEINLINE><BR></BR>
            The value of a <SCHEMEINLINE>not</SCHEMEINLINE> expression is true
            when the expression <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
            evaluates to false, and false otherwise.
          </LI>
        </UL>
        <INDEX><DECLARATION>and</DECLARATION><SUBINDEX>why a special form</SUBINDEX></INDEX>
        <INDEX><DECLARATION>or</DECLARATION><SUBINDEX>why a special form</SUBINDEX></INDEX>
        Notice that <SCHEMEINLINE>and</SCHEMEINLINE> and
	<SCHEMEINLINE>or</SCHEMEINLINE> are special forms, not procedures,
        because the subexpressions are not necessarily all evaluated.
        <SCHEMEINLINE>Not</SCHEMEINLINE> is an ordinary procedure.
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <LONG_PAGE LINES="1"></LONG_PAGE>
      <TEXT> 
	除了原始谓词，例如
	<INDEX><USE>&gt;</USE> (数值比较运算符)<FRAGILE></FRAGILE></INDEX>
	<INDEX><ORDER>&gt;=0</ORDER><JAVASCRIPTINLINE>&lt;</JAVASCRIPTINLINE> (数值比较运算符)</INDEX> 
	<INDEX><ORDER>&gt;=1</ORDER><JAVASCRIPTINLINE>&lt;=</JAVASCRIPTINLINE> (数值比较运算符)<FRAGILE></FRAGILE></INDEX>
	<INDEX><USE>===</USE><SUBINDEX><ORDER>数值</ORDER>作为数值相等性运算符</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX><USE>&quot;!==</USE><ORDER>;4</ORDER><SUBINDEX>作为数值比较运算符<ORDER>数值</ORDER></SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>&gt;</USE> (数值比较)</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><ORDER>===1</ORDER><USE>&lt;</USE> (数值比较)</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><ORDER>===2</ORDER><USE>&lt;=</USE> (数值比较)</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>===</USE> (用于数值比较)</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>&quot;!==</USE> (用于数值比较)<ORDER>;4</ORDER></SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX>相等性<SUBINDEX><ORDER>数字</ORDER>的数字</SUBINDEX></INDEX>
	<JAVASCRIPTINLINE>&gt;=</JAVASCRIPTINLINE>, 
	<JAVASCRIPTINLINE>&gt;</JAVASCRIPTINLINE>, 
	<JAVASCRIPTINLINE>&lt;</JAVASCRIPTINLINE>, 
	<JAVASCRIPTINLINE>&lt;=</JAVASCRIPTINLINE>, 
	<JAVASCRIPTINLINE>===</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>!==</JAVASCRIPTINLINE> 这些都应用于
	数字，
 
	目前，我们将这些运算符限制为数字参数。在节<SPACE></SPACE><REF NAME="sec:strings"></REF>和<SPACE></SPACE><REF NAME="sec:mutable-list-structure"></REF>中，我们将对相等性和不等性谓词
	<JAVASCRIPTINLINE>===</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>!==</JAVASCRIPTINLINE> 进行概括。&lt;/FOOTNOTE&gt;
	有逻辑组合操作，这使我们能够构建复合谓词。三种最常用的操作是：
<UL>
          <LI>
	     
	表达式
<LATEXINLINE>$_1$</LATEXINLINE>  
	<JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE>
	<META>表达式</META> 
<LATEXINLINE>$_2$</LATEXINLINE> <BR></BR>
	    该操作表示
	    <INDEX>语法糖<SUBINDEX><ORDER>;1</ORDER><JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE> 和 {\tt &quot;|&quot;|} 作为</SUBINDEX></INDEX>
	    <INDEX><USE>&amp;&amp;</USE> (逻辑与)<ORDER>;1</ORDER><FRAGILE></FRAGILE></INDEX>
	    <INDEX><USE>&amp;&amp;</USE> (逻辑与)<SUBINDEX>的求值</SUBINDEX><ORDER>;1</ORDER><FRAGILE></FRAGILE></INDEX>
	    <INDEX>语法形式<SUBINDEX>逻辑与 (<JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE>)</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <INDEX>逻辑与<FRAGILE></FRAGILE></INDEX>
	    <INDEX>合取</INDEX>
            <INDEX>求值<SUBINDEX>的 <JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE><ORDER>的 ;1</ORDER></SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <EM>逻辑与</EM>，大致意思与英语单词 <QUOTE>and.</QUOTE> 
	    我们假设<FOOTNOTE>这一假设是由脚注中提到的限制所证明的 
	    <SPACE></SPACE><REF NAME="foot:any-value-as-predicate"></REF>。完整的 JavaScript 需要考虑评估 <META>表达式</META>$_1$ 的结果既不是 true 也不是 false 的情况。</FOOTNOTE> 这个语法形式被认为是语法糖<FOOTNOTE>语法形式只是那些可以用更统一的方式编写的方便替代表面结构，有时称为 <EM>语法糖</EM>，这个短语源自 
            <INDEX>Landin, Peter</INDEX>
            <INDEX>语法糖</INDEX>
	    Peter Landin。	    
	    </FOOTNOTE> 用于<BR></BR>
	    <META>表达式</META> <LATEXINLINE>$_1$</LATEXINLINE>  
	<JAVASCRIPTINLINE>?</JAVASCRIPTINLINE>
	<META>表达式</META> 
<LATEXINLINE>$_2$</LATEXINLINE>  
	<JAVASCRIPTINLINE>:</JAVASCRIPTINLINE>
	<JAVASCRIPTINLINE>false</JAVASCRIPTINLINE>。
</LI>
           
	<LI>
            <META>表达式</META>$_1$
            <JAVASCRIPTINLINE>||</JAVASCRIPTINLINE>
            <META>表达式</META>$_2$<BR></BR>
	    该操作表示
	    <INDEX>{\tt &quot;|&quot;|} (逻辑或)<ORDER>;2</ORDER><FRAGILE></FRAGILE></INDEX>
	    <INDEX>{\tt &quot;|&quot;|} (逻辑或)<ORDER>;2</ORDER><SUBINDEX>的求值</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <INDEX>语法形式<SUBINDEX>逻辑或 ({\tt &quot;|&quot;|})</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <INDEX>逻辑或<FRAGILE></FRAGILE></INDEX>
	    <INDEX>析取</INDEX>
            <INDEX>求值<SUBINDEX>的 {\tt &quot;|&quot;|}<ORDER>的 ;2</ORDER></SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <EM>逻辑或</EM>，大致意思与英语单词 <QUOTE>or.</QUOTE>
	    我们假设这个语法形式是 <BR></BR>
	    <META>表达式</META>$_1$ <JAVASCRIPTINLINE>?</JAVASCRIPTINLINE>
	    <JAVASCRIPTINLINE>true</JAVASCRIPTINLINE> <JAVASCRIPTINLINE>:</JAVASCRIPTINLINE>
	    <META>表达式</META>$_2$。

          </LI>
          <LI>
            <JAVASCRIPTINLINE>!</JAVASCRIPTINLINE>
	    <META>表达式</META><BR></BR>
	    该操作表示
	    <INDEX><USE>&quot;!</USE> (逻辑非运算符)<ORDER>;399</ORDER></INDEX>
	    <INDEX><OPERATOR></OPERATOR><SUBINDEX><ORDER>;399</ORDER><USE>&quot;!</USE> (逻辑非)</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	    <INDEX>否定<SUBINDEX>逻辑 (<JAVASCRIPTINLINE>&quot;!</JAVASCRIPTINLINE>)</SUBINDEX></INDEX>
	    <EM>逻辑非</EM>，大致意思与英语单词 <QUOTE>not.</QUOTE>
            当 <META>表达式</META> 的求值为假时，该表达式的值为真，当 <META>表达式</META> 的求值为真时，该表达式的值为假。
          </LI>
</UL> 
	注意 
 
	<JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE> 和 
    <JAVASCRIPTINLINE>||</JAVASCRIPTINLINE> 是语法形式，
	而不是运算符；
	<INDEX><USE>&amp;&amp;</USE> (逻辑与)<ORDER>;1</ORDER><SUBINDEX>为何是语法形式</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX>{\tt &quot;|&quot;|} (逻辑或)<ORDER>;2</ORDER><SUBINDEX>为何是语法形式</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	它们的右侧表达式并不总是被求值。另一方面，运算符
    <JAVASCRIPTINLINE>!</JAVASCRIPTINLINE> 
    遵循节
	<REF NAME="sec:evaluating-combinations"></REF> 中的求值规则。
    它是一个 <EM>一元</EM> 运算符，这意味着它只接受一个参数，而到目前为止讨论的算术运算符和原始谓词都是 <EM>二元</EM>，接受两个参数。运算符 
    <JAVASCRIPTINLINE>!</JAVASCRIPTINLINE> 位于其参数之前；
	我们称它为
    <INDEX><USE>-</USE><SUBINDEX>作为数值取反运算符</SUBINDEX></INDEX>
    <INDEX><OPERATOR></OPERATOR><SUBINDEX><USE>-</USE> (数值取反运算符)</SUBINDEX></INDEX>
	<INDEX>否定<SUBINDEX>数值 (<JAVASCRIPTINLINE>-</JAVASCRIPTINLINE>)</SUBINDEX></INDEX>
	<INDEX>二元运算符</INDEX>
	<INDEX>一元运算符</INDEX>
	<INDEX>前缀运算符</INDEX>
	<EM>前缀运算符</EM>。另一个前缀运算符是
	数值取反运算符，例如在上述 <JAVASCRIPTINLINE>abs</JAVASCRIPTINLINE> 函数中表达式 <JAVASCRIPTINLINE>- x</JAVASCRIPTINLINE> 的例子。
</TEXT>
    </JAVASCRIPT>
  </SPLIT>

   <SPLIT>
    
      <TEXT>
        作为这些用法的一个例子，数字 $x$ 在范围
	$5 &lt; x &lt; 10$ 的条件可以表示为
        
          
(and (&gt; x 5) (&lt; x 10))
          
        
      </TEXT>
    
    <JAVASCRIPT>
      <TEXT>
        作为这些谓词用法的一个例子，数字 $x$ 在范围
	$5 &lt; x &lt; 10$ 的条件可以表示为
        
          <JAVASCRIPT>
x &gt; 5 &amp;&amp; x &lt; 10 
          </JAVASCRIPT>
        
        语法形式
	<JAVASCRIPTINLINE>&amp;&amp;</JAVASCRIPTINLINE>
        的优先级低于比较运算符
        <JAVASCRIPTINLINE>&gt;</JAVASCRIPTINLINE>
	和<SPACE></SPACE><JAVASCRIPTINLINE>&lt;</JAVASCRIPTINLINE>，并且 
        条件表达式的语法形式
	$\cdots$<JAVASCRIPTINLINE>?</JAVASCRIPTINLINE>$\cdots$<JAVASCRIPTINLINE>:</JAVASCRIPTINLINE>$\cdots$
        的优先级低于我们目前遇到的任何其他运算符，这是我们在
        上述 <JAVASCRIPTINLINE>abs</JAVASCRIPTINLINE> 函数中使用的属性。
      </TEXT>
    </JAVASCRIPT>
  </SPLIT> 
   
	作为另一个例子，我们可以
    <SPLITINLINE>
      
	定义
      
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    一个谓词来测试一个数字是否大于或等于另一个数字，表示为   
    
      <EXAMPLE>geq_example</EXAMPLE>
      
(define (&gt;= x y)
  (or (&gt; x y) (= x y)))
      
      <JAVASCRIPT>
function greater_or_equal(x, y) {
    return x &gt; y || x === y;
}
      </JAVASCRIPT>
    
    或者也可以表示为
    <SPLITINLINE>
      
	<INDEX><USE>&gt;=</USE></INDEX> 
      
    </SPLITINLINE>
    
      <EXAMPLE>geq_example</EXAMPLE>
      
(define (&gt;= x y)
  (not (&lt; x y)))
      
      <JAVASCRIPT>
function greater_or_equal(x, y) {
    return ! (x &lt; y);
}
      </JAVASCRIPT>
    
    
      <NAME>geq_example</NAME>
      
(&gt;= 7 4)
      
      <JAVASCRIPT>
greater_or_equal(7, 4);
      </JAVASCRIPT>
    
    <SPLIT>
      
      
      <JAVASCRIPT>
        函数 <JAVASCRIPTINLINE>greater_or_equal</JAVASCRIPTINLINE> 在应用于两个数字时，行为与运算符
	<JAVASCRIPTINLINE>&gt;=</JAVASCRIPTINLINE> 相同。一元运算符的优先级
        <INDEX>优先级<SUBINDEX><ORDER>一元</ORDER>运算符的优先级</SUBINDEX></INDEX>
	高于二元运算符，这使得该例中的括号是必要的。
      </JAVASCRIPT>
    </SPLIT>


  <LONG_PAGE LINES="1"></LONG_PAGE>
  <EXERCISE> 
    以下是一系列
    <SPLITINLINE>
      
	表达式。
      
      <JAVASCRIPT>
	语句。
      </JAVASCRIPT>
    </SPLITINLINE>
    解释器对每个
    <SPLITINLINE>
      
        表达式的结果是什么?
      
      <JAVASCRIPT>
	语句的结果是什么?
      </JAVASCRIPT>
    </SPLITINLINE>
    假设按照展现的顺序来评估这一序列。
<SNIPPET>
      <NAME>ten</NAME>
      <EXPECTED>10</EXPECTED>
      <SCHEME>
10
      </SCHEME>
      <JAVASCRIPT>
10;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>five_plus_three_plus_four</NAME>
      <EXPECTED>12</EXPECTED>
      <SCHEME>
(+ 5 3 4)
      </SCHEME>
      <JAVASCRIPT>
5 + 3 + 4;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>nine_minus_one</NAME>
      <EXPECTED>8</EXPECTED>
      <SCHEME>
(- 9 1)
      </SCHEME>
      <JAVASCRIPT>
9 - 1;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>six_over_two</NAME>
      <EXPECTED>3</EXPECTED>
      <SCHEME>
(/ 6 2)
      </SCHEME>
      <JAVASCRIPT>
6 / 2;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>two_times_four_etc</NAME>
      <EXPECTED>6</EXPECTED>
      <SCHEME>
(+ (* 2 4) (- 4 6))
      </SCHEME>
      <JAVASCRIPT>
2 * 4 + (4 - 6);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>definea</NAME>
      <EXPECTED>undefined</EXPECTED>
      <SCHEME>
(define a 3)
      </SCHEME>
      <JAVASCRIPT>
const a = 3;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>defineb</NAME>
      <REQUIRES>definea</REQUIRES>
      <EXPECTED>undefined</EXPECTED>
      <SCHEME>
(define b (+ a 1))
      </SCHEME>
      <JAVASCRIPT>
const b = a + 1;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_plus_b_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>19</EXPECTED>
      <SCHEME>
(+ a b (* a b))
      </SCHEME>
      <JAVASCRIPT>
a + b + a * b;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_equal_b</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>false</EXPECTED>
      <SCHEME>
(= a b)
      </SCHEME>
      <JAVASCRIPT>
a === b;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>b_gt_a_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>4</EXPECTED>
      <SCHEME>
(if (and (&gt; b a) (&lt; b (* a b)))
  b
  a)
      </SCHEME>
      <JAVASCRIPT>
b &gt; a &amp;&amp; b &lt; a * b ? b : a;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_equal_four_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>16</EXPECTED>
      <SCHEME>
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
      </SCHEME>
      <JAVASCRIPT>
a === 4
? 6
: b === 4
? 6 + 7 + a
: 25;
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>two_plus_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>6</EXPECTED>
      <SCHEME>
(+ 2 (if (&gt; b a) b a))
      </SCHEME>
      <JAVASCRIPT>
2 + (b &gt; a ? b : a);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_greater_b_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>16</EXPECTED>
      <SCHEME>
(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))
      </SCHEME>
      <JAVASCRIPT>
(a &gt; b
 ? a
 : a &lt; b
 ? b
 : -1)
*
(a + 1);
      </JAVASCRIPT>
    </SNIPPET>
     
	括号围绕条件表达式在最后两个语句中是必要的，因为
	<INDEX>条件表达式<SUBINDEX><ORDER>操作数</ORDER>作为运算符组合的操作数</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	条件表达式的语法形式优先级低于
	<INDEX>优先级<SUBINDEX><ORDER>条件表达式</ORDER>的条件表达式</SUBINDEX></INDEX>
	<INDEX>条件表达式<SUBINDEX>的优先级</SUBINDEX></INDEX>
	算术运算符
	<JAVASCRIPTINLINE>+</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>*</JAVASCRIPTINLINE>。
<LABEL NAME="ex:1_1"></LABEL>
     
    以下是
    <SPLITINLINE>
      
	表达式。
      
      <JAVASCRIPT>
	语句。
      </JAVASCRIPT>
    </SPLITINLINE>
    解释器对每个
    <SPLITINLINE>
      
        表达式的结果是什么？
      
      <JAVASCRIPT>
	语句的结果是什么？
      </JAVASCRIPT>
    </SPLITINLINE>
    假设按照展现的顺序评估这一序列。
</EXERCISE>

   
    将以下表达式翻译成 
    <SPLITINLINE>
      
        前缀形式
      
      <JAVASCRIPT>
        JavaScript
      </JAVASCRIPT>
    </SPLITINLINE>
    <PDF_ONLY>
      \par\medskip
    </PDF_ONLY>
    
      $\begin{array}{l}
      \quad~~\dfrac{5+4+\left(2-\left(3-(6+\frac{4}{5})\right)\right)}{3 (6-2) (2-7)}
      \end{array}$
    
    <SOLUTION>   
      
	<JAVASCRIPT>
(5 + 4 + (2 - (3 - (6 + 4 / 5)))) 
/
(3 * (6 - 2) * (2 - 7));
	</JAVASCRIPT>
      
    </SOLUTION>
    

   
    <EXERCISE>
    <SPLITINLINE>
      
        定义一个过程
      
      <JAVASCRIPT>
	声明一个函数
      </JAVASCRIPT>
    </SPLITINLINE>
    接收三个数字作为参数并返回两个较大数字的平方和。
    <SOLUTION>
      
        <EXAMPLE>larger_two_square_example</EXAMPLE>
        <REQUIRES>square_definition</REQUIRES>
        <JAVASCRIPT>
function f(x, y, z) {
   return square(x) + square(y) + square(z) -
          // subtract the square of the smallest
          square(x &gt; y ? (y &gt; z ? z : y) : (x &gt; z ? z : x));
}
        </JAVASCRIPT>
        
(define (f x y z)
   (let ((smallest (if (&gt; x y) (if (&gt; y z) z y) (if (&gt; x z) z x))))
      (- (+ (square x) (square y) (square z)) (square smallest))))
        
      
    </SOLUTION>
    
      <NAME>larger_two_square_example</NAME>
      
(f 4 7 2)
      
      <JAVASCRIPT>
f(4, 7, 2);
      </JAVASCRIPT>
    
    
  </EXERCISE> 


  <EXERCISE>
    <LABEL NAME="ex:a-plus-abs-b"></LABEL>
    <SPLIT>
      <SCHEME>
	Observe that our model of evaluation allows for
	<INDEX>combination<SUBINDEX>compound expression as operator of</SUBINDEX></INDEX>
	<INDEX>compound expression<SUBINDEX><ORDER>operator</ORDER>as operator of combination</SUBINDEX></INDEX>
	<INDEX>operator of a combination<SUBINDEX>compound expression as</SUBINDEX></INDEX>
	combinations whose
	operators are compound expressions.  Use this observation to describe
	the behavior of the following procedure:
	<SNIPPET>
          <SCHEME>
(define (a-plus-abs-b a b)
  ((if (&gt; b 0) + -) a b))
          </SCHEME>
	</SNIPPET>
      </SCHEME>
      <JAVASCRIPT> 
	注意我们的评估模型允许
	<INDEX>函数应用<SUBINDEX>复合表达式作为函数表达式的</SUBINDEX></INDEX>
	<INDEX>复合表达式<SUBINDEX><ORDER>函数表达式</ORDER>作为函数应用的表达式</SUBINDEX></INDEX>
	<INDEX>函数表达式<SUBINDEX>复合表达式作为</SUBINDEX></INDEX>
	应用程序，这些应用程序的函数表达式是复合表达式。利用这一观察描述 
	<JAVASCRIPTINLINE>a_plus_abs_b</JAVASCRIPTINLINE> 的行为：
<SNIPPET POSTPADDING="no">
          <EXAMPLE>plusminusexample</EXAMPLE>
          <JAVASCRIPT>
function plus(a, b) { return a + b; }
<SHORT_SPACE></SHORT_SPACE>
function minus(a, b) { return a - b; }
<SHORT_SPACE></SHORT_SPACE>
function a_plus_abs_b(a, b) {
    return (b &gt;= 0 ? plus : minus)(a, b);
}
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET HIDE="yes">
          <NAME>plusminusexample</NAME>
          <JAVASCRIPT>
a_plus_abs_b(5, -4);
          </JAVASCRIPT>
	</SNIPPET>
	 
	请注意，在 JavaScript 中的条件表达式中，我们不能像在 Scheme 中那样直接使用运算符 <JAVASCRIPTINLINE>+</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>-</JAVASCRIPTINLINE>，反而必须使用名称 <JAVASCRIPTINLINE>plus</JAVASCRIPTINLINE> 和
	<JAVASCRIPTINLINE>minus</JAVASCRIPTINLINE>，因为在中缀表示法中，
	只允许运算符符号出现在中间，而不允许复合表达式。
 
	根据节<SPACE></SPACE><REF NAME="sec:substitution-model"></REF>，应用程序的求值过程如下：
	<OL>
	    <LI>评估应用程序的子表达式。</LI>
            <LI>评估函数表达式的返回表达式，每个参数都替换为其各自参数表达式的结果。</LI>
	</OL>
	因此，应用程序 
	<JAVASCRIPTINLINE>a_plus_abs_b(5, -4)</JAVASCRIPTINLINE> 的求值 
	(1) 评估 <JAVASCRIPTINLINE>a_plus_abs_b</JAVASCRIPTINLINE>，得到上面的函数，且参数已是值。所以我们需要评估 
	(2) 函数的返回表达式，用参数替换为参数，从而得到：
	<JAVASCRIPTINLINE>(-4 &gt;= 0 ? plus : minus)(5, -4)</JAVASCRIPTINLINE>。根据相同规则，我们需要 (1) 评估函数表达式，在本例中是条件表达式 
	<JAVASCRIPTINLINE>-4 &gt;= 0 ? plus : minus</JAVASCRIPTINLINE>。由于谓词评估为假，函数表达式 
	评估为 <JAVASCRIPTINLINE>minus</JAVASCRIPTINLINE>。参数再次 (1) 已是值。因此，我们最终评估 (2) <JAVASCRIPTINLINE>minus</JAVASCRIPTINLINE> 的主体，参数 
	<JAVASCRIPTINLINE>a</JAVASCRIPTINLINE> 和 
	<JAVASCRIPTINLINE>b</JAVASCRIPTINLINE> 分别替换为 5 和 -4，结果为 
	<JAVASCRIPTINLINE>5 - (-4)</JAVASCRIPTINLINE>，最终结果为 9。
</JAVASCRIPT>
    </SPLIT>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:normal-order-vs-appl-order-test"></LABEL> 
    Ben Bitdiddle 发明了一项测试，用于判断他面对的解释器是使用 
    <INDEX>正则序求值<SUBINDEX>应用序 vs.</SUBINDEX></INDEX>
    <INDEX>应用序求值<SUBINDEX>正则序 vs.</SUBINDEX></INDEX>
    或正则序求值。他 
    <SPLITINLINE>
      
	定义了以下两个过程：
      
      <JAVASCRIPT>
	声明了以下两个函数：
      </JAVASCRIPT>
    </SPLITINLINE>
<SNIPPET>
	<NAME>ptest</NAME>
	<SCHEME>
(define (p) (p))

(define (test x y)
  (if (= x 0)
    0
    y))
	</SCHEME>
	<JAVASCRIPT>
function p() { return p(); }

function test(x, y) {
    return x === 0 ? 0 : y;
}
	</JAVASCRIPT>
      </SNIPPET>
       
    然后他评估
    <SPLITINLINE>
	表达式
	<JAVASCRIPT>语句</JAVASCRIPT>
    </SPLITINLINE>
<SNIPPET>
	<REQUIRES>ptest</REQUIRES>
	<SCHEME>
(test 0 (p))
	</SCHEME>
	<JAVASCRIPT>
test(0, p());
	</JAVASCRIPT>
      </SNIPPET>
       
	贝恩·比特迪尔发明了一项测试，用于确定他所面对的解释器是使用
    <INDEX>应用序求值<SUBINDEX>正则序 vs.</SUBINDEX></INDEX>
    <INDEX>正则序求值<SUBINDEX>应用序 vs.</SUBINDEX></INDEX>
    应用序求值还是正则序求值。他
    <SPLITINLINE>
      
        定义了以下两个过程：
      
      <JAVASCRIPT>
        声明了以下两个函数：
      </JAVASCRIPT>
    </SPLITINLINE>
 
	解决方案：
	<SPLIT>
	  <JAVASCRIPT>
	    在
	    <JAVASCRIPTINLINE>test(0, p())</JAVASCRIPTINLINE> 的应用序求值中，
	    我们需要在评估函数
	    <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE> 的返回表达式之前，先评估参数表达式。
	    然而，参数表达式
	    <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE> 的评估不会终止：它将不断评估形如 
	    <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE> 的应用表达式，因此 
	    <JAVASCRIPTINLINE>test(0, p())</JAVASCRIPTINLINE> 的评估不会产生合法值。另一方面，在正则序求值中，
	    函数应用
	    <JAVASCRIPTINLINE>test(0, p())</JAVASCRIPTINLINE> 将立即评估函数
	    <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE> 的返回表达式
	    <JAVASCRIPTINLINE>x === 0 ? 0 : y</JAVASCRIPTINLINE>，
	    替换参数 
	    <JAVASCRIPTINLINE>x</JAVASCRIPTINLINE> 为 
	    <JAVASCRIPTINLINE>0</JAVASCRIPTINLINE> 和 
	    <JAVASCRIPTINLINE>y</JAVASCRIPTINLINE> 为 
	    <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE>。
	    替换的结果将是
	    <JAVASCRIPTINLINE>0 === 0 ? 0 : p()</JAVASCRIPTINLINE>。
	    谓词 <JAVASCRIPTINLINE>0 === 0</JAVASCRIPTINLINE> 的评估结果为真，因此条件表达式评估为 0，而不需要评估 
	    <JAVASCRIPTINLINE>p()</JAVASCRIPTINLINE>。
	  </JAVASCRIPT>
	</SPLIT>
</EXERCISE>
</SUBSECTION>
