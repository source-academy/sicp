[{"id":"/sicpjs/5.5","tag":"TITLE","body":"5.5  Compilation"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    The explicit-control evaluator of\n    section ","tag":"#text"},{"tag":"REF","body":"5.4","href":"/sicpjs/5.4"},{"body":" is a\n    register machine whose controller interprets\n    JavaScript\n    programs.  In this\n    section we will see how to run\n    JavaScript\n    programs on a register machine whose controller is not a\n    JavaScript\n    interpreter.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The explicit-control evaluator machine is\n    \n    universal—it\n    can carry out any computational process that can be described in\n    JavaScript.\n    The\n    evaluator's controller orchestrates the use of its data\n    paths to perform the desired computation.  Thus, the\n    evaluator's data paths are universal: They are sufficient\n    to perform any computation we desire, given an appropriate\n    controller.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.5#footnote-1"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    Commercial\n    \n    general-purpose computers are\n    register machines organized\n    around a collection of registers and operations that constitute\n    an efficient and convenient universal set of data paths.\n    The controller for a general-purpose machine is an interpreter for\n    a register-machine language like the one we have been using.  This\n    language is called the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"native language","tag":"#text"}]},{"body":" of the machine, or simply\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"machine language","tag":"#text"}]},{"body":".  Programs written in machine language are\n    sequences of instructions that use the machine's data paths.\n    For example, the\n    \n    explicit-control evaluator's instruction sequence\n    can be thought of as a machine-language program for a general-purpose\n    computer rather than as the controller for a specialized interpreter\n    machine.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    There are two common strategies for bridging the gap between\n    higher-level languages and register-machine languages.\n    The explicit-control evaluator illustrates the\n    strategy of interpretation.  An interpreter written in the native\n    language of a machine configures the machine to execute programs\n    written in a language (called the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"source language","tag":"#text"}]},{"body":") that may\n    differ from the native language of the machine performing the\n    evaluation.  The primitive\n    functions\n    of the source language are implemented as a library of subroutines written\n    in the native language of the given machine.  A program to be interpreted\n    (called the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"source program","tag":"#text"}]},{"body":") is represented as a data structure.  The interpreter\n      traverses this data structure, analyzing the source program.  As it\n      does so, it simulates the intended behavior of the source program by\n      calling appropriate primitive subroutines from the library.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    In this section, we explore the alternative strategy of ","tag":"#text"},{"tag":"EM","child":[{"body":"\n    compilation","tag":"#text"}]},{"body":".  A compiler for a given source language and machine\n    translates a source program into an equivalent program (called the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"object program","tag":"#text"}]},{"body":") written in the machine's native language.\n    The compiler that we implement in this section translates programs written in\n    JavaScript\n    into sequences of instructions to be executed using the explicit-control\n    evaluator machine's data paths.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.5#footnote-2"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Compared with interpretation, compilation can provide a great increase\n    in the efficiency of program execution, as we will explain below in\n    the overview of the compiler.\n    On the other hand, an interpreter\n    provides a more powerful environment for interactive program\n    development and debugging, because the source program being executed\n    is available at run time to be examined and modified.  In addition,\n    because the entire library of primitives is present, new programs can\n    be constructed and added to the system during debugging.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    In view of the complementary advantages of compilation and\n    interpretation, modern\n    program-development environments\n    pursue a mixed\n    strategy.\n    These systems\n    are generally organized so that interpreted\n    functions\n    and compiled\n    functions\n    can call each other.\n    This enables a programmer to compile those parts of a\n    program that are assumed to be debugged, thus gaining the efficiency\n    advantage of compilation, while retaining the interpretive mode of execution\n    for those parts of the program that are in the flux of interactive\n    development and\n    debugging.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/5.5#footnote-3"},{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"5.5.7","href":"/sicpjs/5.5.7"},{"body":", after\n    we have implemented the compiler, we will show how to interface it\n    with our interpreter to produce an integrated\n    interpreter-compiler\n    \n    system.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"An overview of the compiler","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    Our compiler is much like our interpreter, both in its structure and in\n    the function it performs.  Accordingly, the mechanisms used by the\n    compiler for analyzing\n    \n\tcomponents\n      \n    will be similar to those used by\n    the interpreter.  Moreover, to make it easy to interface compiled and\n    interpreted code, we will design the compiler to generate code that\n    obeys the same conventions of\n    \n    register usage as the interpreter: The\n    environment will be kept in the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register,\n    argument lists will be accumulated in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":", a\n    function\n    to be applied will be in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":",\n      functions\n    will return their answers in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":",\n    and the location to which a\n    function\n    should return will be kept in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":".\n    In general, the compiler translates a source program into an object\n    program that performs essentially the same register operations as\n    would the interpreter in evaluating the same source program.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    This description suggests a strategy for implementing a rudimentary\n    compiler: We traverse the\n    \n\tcomponent\n      \n    in the same way the\n    interpreter does.  When we encounter a register instruction that the\n    interpreter would perform in evaluating the\n    \n\tcomponent,\n      \n    we do not\n    execute the instruction but instead accumulate it into a sequence.  The\n    resulting sequence of instructions will be the object code.  Observe\n    the\n    \n    efficiency advantage of compilation over interpretation.  Each\n    time the interpreter evaluates\n    \n\ta component—for example,\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f(96, 22)"},{"body":"—it\n      \n    performs the work of classifying the\n    \n\tcomponent\n      \n    (discovering that this is a\n    function\n    application) and\n\ttesting for the end of the\n    \n\tlist of argument expressions\n\t(discovering that there are two argument expressions).\n      \n    With a\n    compiler, the\n    \n\tcomponent\n      \n    is analyzed only once, when the\n    instruction sequence is generated at compile time.  The object code\n    produced by the compiler contains only the instructions that evaluate\n    the\n    \n\tfunction expression and the two argument expressions,\n      \n    assemble the argument list, and apply the\n    function (in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":")\n    to the arguments (in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"argl"},{"body":").\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    This is the same kind of optimization we implemented in the\n    \n    analyzing evaluator of section ","tag":"#text"},{"tag":"REF","body":"4.1.7","href":"/sicpjs/4.1.7"},{"body":".\n    But there are further opportunities to gain efficiency in compiled code.\n    As the interpreter runs, it follows a process that must be applicable\n    to any\n    \n        component\n      \n    in the language.  In contrast, a given segment of\n    compiled code is meant to execute some particular\n    \n        component.\n      \n    This can make a big difference, for example in the use of the\n    stack to save registers.  When the interpreter evaluates\n    \n        a component,\n      \n    it must be prepared for any contingency. Before evaluating a\n    subcomponent,\n    the interpreter saves all registers that will be needed later, because the\n    subcomponent\n    might require an arbitrary evaluation.\n    A compiler, on the other hand, can exploit the structure of the particular\n    \n        component\n      \n    it is processing to generate code that avoids\n    unnecessary stack operations.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    As a case in point, consider the\n    application ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f(96, 22)"},{"body":".\n    Before the interpreter evaluates the\n    \n\tfunction expression of the application,\n      \n    it prepares\n    for this evaluation by saving the registers containing the\n    \n\targument expressions\n      \n    and the environment, whose values will be needed later.  The interpreter then\n    evaluates the\n    \n\tfunction expression\n      \n    to obtain the result in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":", restores the saved registers, and finally\n    moves the result from ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":".\n    However, in the particular expression we\n    are dealing with, the\n    \n\tfunction expression\n      \n    is the\n    \n\tname\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":", whose evaluation is\n    accomplished by the machine operation\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup_symbol_value"},{"body":",\n      \n    which does not alter any registers.  The compiler that we implement in\n    this section will take advantage of this fact and generate code that\n    evaluates the\n    \n\t      function expression\n      \n      using the instruction\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"assign(\"fun\", \n       list(op(\"lookup_symbol_value\"), constant(\"f\"), reg(\"env\")))"},{"body":"\n\twhere the argument to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup_symbol_value"},{"body":"\n\tis extracted at compile time from the parser's representation of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f(96, 22)"},{"body":".\n      \n    This code not only avoids the unnecessary saves and\n    restores but also assigns the value of the lookup directly to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":",\n    whereas the interpreter would obtain the\n    result in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and then move this to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fun"},{"body":".","tag":"#text"}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    A compiler can also optimize access to the environment.  Having\n    analyzed the code, the compiler can\n    \n    know in which frame\n    the value of a particular name\n    will be located and access that frame directly,\n    rather than performing the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup_symbol_value"},{"body":"\n    search.  We will discuss how to implement such\n    lexical addressing\n    in\n    section ","tag":"#text"},{"tag":"REF","body":"5.5.6","href":"/sicpjs/5.5.6"},{"body":".  Until then, however,\n    we will focus on the kind of register and stack optimizations described\n    above. There are many other optimizations that can be performed by a\n    compiler, such as coding primitive operations \"","tag":"#text"},{"body":"in line","tag":"#text"},{"body":"\" instead\n    of using a general ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply"},{"body":" mechanism (see\n    exercise ","tag":"#text"},{"tag":"REF","body":"5.40","href":"/sicpjs/5.5.5#ex-5.40"},{"body":"); but we will not emphasize these\n    here. Our main goal in this section is to illustrate the compilation process\n    in a simplified (but still interesting) context.\n  ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.5#footnote-link-1","child":[{"body":"This is a theoretical statement.  We are\n    not claiming\n    that the evaluator's data paths are a particularly convenient or\n    efficient set of data paths for a general-purpose computer.  For example,\n    they are not very good for implementing high-performance floating-point\n    calculations or calculations that intensively manipulate bit\n    vectors.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.5#footnote-link-2","child":[{"body":"Actually, the machine that\n    runs compiled code can be simpler than the interpreter machine, because we\n    \n    won't use the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"comp"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unev"},{"body":" registers.  The interpreter\n    used these to hold pieces of unevaluated\n    \n\tcomponents.\n      \n    With the\n    compiler, however, these\n    \n\tcomponents\n      \n    get built into the\n    compiled code that the register machine will run.  For the same\n    reason,\n    \n    we don't need the machine operations that deal with\n    \n\tcomponent\n      \n    syntax.  But compiled code will use a few additional machine\n    operations (to represent compiled\n    function\n    objects) that didn't\n    appear in the explicit-control evaluator machine.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/5.5#footnote-link-3","child":[{"body":"Language implementations\n    often delay the compilation of program parts even when they are\n    assumed to be debugged, until there is enough evidence that compiling them\n    would lead to an overall efficiency advantage. The evidence is obtained at\n    run time by monitoring the number of times the program parts are being\n    interpreted. This technique is called\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"just-in-time compilation","tag":"#text"}]},{"body":".","tag":"#text"}]}]