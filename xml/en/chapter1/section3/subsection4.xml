<SUBSECTION> 
  <NAME>
    <SPLITINLINE>
      <SCHEME>Procedures</SCHEME>
      <JAVASCRIPT>Functions</JAVASCRIPT>
    </SPLITINLINE>
    as Returned Values
  </NAME>

  <LABEL NAME="sec:proc-returned-values"/>

  <INDEX>higher-order <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE><SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE> as returned value<OPEN/></SUBINDEX></INDEX>
  <INDEX><FUNCTION/><SUBINDEX><ORDER>returned</ORDER>as returned value<OPEN/></SUBINDEX></INDEX>
  
  <TEXT>
    The above examples demonstrate how the ability to pass
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    as arguments significantly enhances the expressive power of our programming
    language.  We can achieve even more expressive power by creating
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    whose returned values are themselves
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>
  <TEXT>
    We can illustrate this idea by looking again at the fixed-point example
    described at the end of
    section<SPACE/><REF NAME="sec:proc-general-methods"/>.  We formulated a new
    version of the square-root
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    as a fixed-point search, starting with the observation that
    <LATEXINLINE>$\sqrt{x}$</LATEXINLINE> is a fixed-point of the function
    <LATEXINLINE>$y\mapsto x/y$</LATEXINLINE>.  Then we used average damping to
    make the approximations converge.  Average damping is a useful general
    technique in itself.  Namely, given a
    function<SPACE/><LATEXINLINE>$f$</LATEXINLINE>, we consider the function
    whose value at <LATEXINLINE>$x$</LATEXINLINE> is equal to the average of
    <LATEXINLINE>$x$</LATEXINLINE> and <LATEXINLINE>$f(x)$</LATEXINLINE>.
  </TEXT>
  <TEXT>
    We can express the idea of average damping by means of the following
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <JAVASCRIPT>function:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET PAGE="72">
      <INDEX><DECLARATION>average_damp</DECLARATION></INDEX>
      <NAME>average_damp_definition</NAME>
      <REQUIRES>average_definition</REQUIRES>
      <EXAMPLE>average_damp_example</EXAMPLE>
      <EXPECTED>55</EXPECTED>
      <SCHEME>
(define (average-damp f)
  (lambda (x) (average x (f x))))
      </SCHEME>
      <JAVASCRIPT>
function average_damp(f) {
    return x => average(x, f(x));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>Average-damp</SCHEMEINLINE>
	is a procedure that
      </SCHEME>
      <JAVASCRIPT>
        The function
        <JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    takes as its argument a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>f</SCHEMEINLINE> and returns as its value a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>(produced by the <SCHEMEINLINE>lambda</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT>(produced by the lambda expression)</JAVASCRIPT>
    </SPLITINLINE>
    that, when applied to a number<SPACE/><SCHEMEINLINE>x</SCHEMEINLINE>, produces the
    average of <SCHEMEINLINE>x</SCHEMEINLINE> and 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(f x)</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>f(x)</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    For example, applying 
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>average-damp</SCHEMEINLINE> 
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to the <SCHEMEINLINE>square</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    produces a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    whose value at some number <LATEXINLINE>$x$</LATEXINLINE> is the average of 
    <LATEXINLINE>$x$</LATEXINLINE> and <LATEXINLINE>$x^2$</LATEXINLINE>.  
    Applying this resulting
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to 10 returns the average of 10 and 100, or 55:<FOOTNOTE>
    <SPLIT>
      <SCHEME>
	Observe that this is a combination whose operator is itself
	<INDEX>combination<SUBINDEX>combination as operator of</SUBINDEX></INDEX>
	<INDEX>combination<SUBINDEX><ORDER>operator</ORDER>as operator of combination</SUBINDEX></INDEX>
	<INDEX>operator of a combination<SUBINDEX>combination as</SUBINDEX></INDEX>
	a combination. Exercise<SPACE/><REF NAME="ex:a-plus-abs-b"/> already
	demonstrated the ability to form such combinations, but that was only a toy
	example.  Here we begin to see the real need for such
	combinations<EMDASH/>when applying a procedure
	that is obtained as the value returned by a higher-order procedure.
      </SCHEME>
      <JAVASCRIPT>
	Observe that this
	is an application whose function expression is itself
	<INDEX>function application<SUBINDEX><ORDER>function</ORDER>as function expression of application</SUBINDEX></INDEX>
	<INDEX>function expression<SUBINDEX>application as</SUBINDEX></INDEX>
	an application. Exercise<SPACE/><REF NAME="ex:a-plus-abs-b"/> already
	demonstrated the ability to form such applications, but that was only a toy
	example.  Here we begin to see the real need for such
	applications<EMDASH/>when applying a function
	that is obtained as the value returned by a higher-order function.
      </JAVASCRIPT>
    </SPLIT>
  </FOOTNOTE>
    <SNIPPET PAGE="73">
      <NAME>average_damp_example</NAME>
      <REQUIRES>average_damp_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
((average-damp square) 10)
      </SCHEME>
      <SCHEMEOUTPUT>
55
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
average_damp(square)(10);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
55
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Using 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>average-damp</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    we can reformulate the
    <INDEX>fixed point<SUBINDEX>square root as</SUBINDEX></INDEX>
    square-root
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    as follows:
    <SNIPPET PAGE="73">
      <INDEX><DECLARATION>sqrt</DECLARATION><SUBINDEX><ORDER>fixed</ORDER>as fixed point</SUBINDEX></INDEX>    
      <NAME>sqrt_definition4</NAME>
      <REQUIRES>average_damp_definition</REQUIRES>
      <REQUIRES>fixed_definition</REQUIRES>
      <EXAMPLE>sqrt_example3</EXAMPLE>
      <SCHEME>
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
      </SCHEME>
      <JAVASCRIPT>
function sqrt(x) {
    return fixed_point(average_damp(y =&gt; x / y), 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>sqrt_example3</NAME>
      <REQUIRES>sqrt_definition4</REQUIRES>
      <EXPECTED>2.4494897427875517</EXPECTED>
      <JAVASCRIPT>
sqrt(6);
      </JAVASCRIPT>
    </SNIPPET>
    Notice how this formulation makes explicit the three ideas in the method:
    fixed-point search, average damping, and the function
    <LATEXINLINE>$y\mapsto x/y$</LATEXINLINE>.  It is instructive to compare
    this formulation of the square-root method with the original version given
    in section<SPACE/><REF NAME="sec:sqrt"/>.  Bear in mind that these
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    express the same process, and notice how much clearer the idea becomes when
    we express the process in terms of these abstractions.  In general, there
    are many ways to formulate a process as a
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    Experienced programmers know how to choose
    <SPLITINLINE>
      <SCHEME>procedural</SCHEME>
      <JAVASCRIPT>process</JAVASCRIPT>
    </SPLITINLINE>
    formulations that are particularly perspicuous, and where useful elements of
    the process are exposed as separate entities that can be reused in other
    applications. As a simple example of reuse, notice that the cube root of
    <LATEXINLINE>$x$</LATEXINLINE> is a fixed point of the function
    <LATEXINLINE>$y\mapsto x/y^2$</LATEXINLINE>, so we can immediately
    generalize our square-root
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to one that extracts 
    <INDEX>cube root<SUBINDEX><ORDER>fixed</ORDER>as fixed point</SUBINDEX></INDEX>
    <INDEX>fixed point<SUBINDEX>cube root as</SUBINDEX></INDEX>
    cube roots:<FOOTNOTE>See exercise<SPACE/><REF NAME="ex:nth-roots"/> 
    for a further generalization.</FOOTNOTE>
    <INDEX><DECLARATION>cube_root</DECLARATION></INDEX>
    <SNIPPET PAGE="73">
      <INDEX><DECLARATION>cube_root</DECLARATION></INDEX>
      <NAME>cube_root_definition</NAME>
      <REQUIRES>average_damp_definition</REQUIRES>
      <REQUIRES>fixed_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>cube_root_example</EXAMPLE>
      <SCHEME>
(define (cube-root x)
  (fixed-point (average-damp (lambda (y) (/ x (square y))))
               1.0))
      </SCHEME>
      <JAVASCRIPT>
function cube_root(x) {
    return fixed_point(average_damp(y => x / square(y)), 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="24" HIDE="yes">
      <NAME>cube_root_example</NAME>
      <REQUIRES>cube_root_definition</REQUIRES>
      <EXPECTED>2.9999972321057697</EXPECTED>
      <SCHEME>
(cube-root 27)
      </SCHEME>
      <JAVASCRIPT>
cube_root(27);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Newton<APOS/>s method</NAME>
  </SUBHEADING>

  <TEXT>
    When we first introduced the square-root
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    in section<SPACE/><REF NAME="sec:sqrt"/>, we mentioned that this was a
    special case of
    <INDEX>Newton<APOS/>s method<SUBINDEX><ORDER>diff</ORDER>for differentiable functions<OPEN/></SUBINDEX></INDEX>
    <EM>Newton<APOS/>s method</EM>. If
    <LATEXINLINE>$x\mapsto g(x)$</LATEXINLINE> is a differentiable function,
    then a solution of the equation <LATEXINLINE>$g(x)=0$</LATEXINLINE> is a
    fixed point of the function <LATEXINLINE>$x\mapsto f(x)$</LATEXINLINE> where
    <LATEX>
      \[
      \begin{array}{lll}
      f(x) &amp; = &amp; x - \dfrac{g(x)}{Dg(x)}
      \end{array}
      \]
    </LATEX>
    and <LATEXINLINE>$Dg(x)$</LATEXINLINE> is the derivative of
    <LATEXINLINE>$g$</LATEXINLINE> evaluated at <LATEXINLINE>$x$</LATEXINLINE>.  
    <INDEX>fixed point<SUBINDEX><ORDER>Newton</ORDER>in Newton<APOS/>s method</SUBINDEX></INDEX>
    Newton<APOS/>s method is the use of the fixed-point method we saw above to
    approximate a solution of the equation by finding a fixed point of the
    function <LATEXINLINE>$f$</LATEXINLINE>.<FOOTNOTE>Elementary calculus books
    usually describe Newton<APOS/>s method in terms of the sequence of
    approximations <LATEXINLINE>$x_{n+1}=x_n-g(x_n)/Dg(x_n)$</LATEXINLINE>.
    Having language for talking about processes and using the idea of fixed
    points simplifies the description of the method.</FOOTNOTE>
    For many functions <LATEXINLINE>$g$</LATEXINLINE> and for sufficiently good
    initial guesses for <LATEXINLINE>$x$</LATEXINLINE>, Newton<APOS/>s method
    converges very rapidly to a solution of
    <LATEXINLINE>$g(x)=0$</LATEXINLINE>.<FOOTNOTE>Newton<APOS/>s method does not
    always converge to an answer, but it can be shown that in favorable cases
    each iteration doubles the number-of-digits accuracy of the approximation
    to the solution. In such cases, 
    <INDEX>Newton<APOS/>s method<SUBINDEX>half-interval method vs.</SUBINDEX></INDEX>
    <INDEX>half-interval method<SUBINDEX>Newton<APOS/>s method vs.</SUBINDEX></INDEX>
    Newton<APOS/>s method will converge much more rapidly than the half-interval
    method.</FOOTNOTE>
  </TEXT>

  <SHORT_PAGE lines="3"/>
  <TEXT>
    In order to implement Newton<APOS/>s method as a
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    we must first express the idea of
    <INDEX>derivative of a function</INDEX>
    <INDEX>function (mathematical)<SUBINDEX>derivative of</SUBINDEX></INDEX>
    <INDEX>differentiation<SUBINDEX>numerical</SUBINDEX></INDEX>
    derivative.  Note that
    <QUOTE>derivative,</QUOTE> like average damping, is something that
    transforms a function into another function.  For instance, the derivative
    of the function <LATEXINLINE>$x\mapsto x^3$</LATEXINLINE> is the function
    <LATEXINLINE>$x \mapsto 3x^2$</LATEXINLINE>.  In general, if
    <LATEXINLINE>$g$</LATEXINLINE> is a function and
    <LATEXINLINE>$dx$</LATEXINLINE> is a small number, then the derivative
    <LATEXINLINE>$Dg$</LATEXINLINE> of <LATEXINLINE>$g$</LATEXINLINE> is the
    function whose value at any number<SPACE/><LATEXINLINE>$x$</LATEXINLINE> is given
    (in the limit of small <LATEXINLINE>$dx$</LATEXINLINE>) by
    <LATEX>
      \[
      \begin{array}{lll}
      Dg(x) &amp; = &amp; \dfrac {g(x+dx) - g(x)}{dx}
      \end{array}
      \]
    </LATEX>
    Thus, we can express the idea of derivative (taking
    <LATEXINLINE>$dx$</LATEXINLINE> to be, say, 0.00001) as the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET PAGE="74">
      <NAME>deriv_definition</NAME>
      <REQUIRES>dx</REQUIRES>
      <EXAMPLE>deriv_example</EXAMPLE>
      <SCHEME>
(define (deriv g)
  (lambda (x)
    (/ (- (g (+ x dx)) (g x))
       dx)))
      </SCHEME>
      <JAVASCRIPT>
function deriv(g) {
    return x => (g(x + dx) - g(x)) / dx;
}
      </JAVASCRIPT>
    </SNIPPET>
    along with the
    <SPLITINLINE>
      <SCHEME>definition</SCHEME>
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <NAME>dx</NAME>
      <SCHEME>
(define dx 0.00001)
      </SCHEME>
      <JAVASCRIPT>
const dx = 0.00001;
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    Like 
<INDEX><DECLARATION>deriv</DECLARATION> (numerical)</INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>average-damp</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><DECLARATION>deriv</DECLARATION> (numerical)</INDEX>
    <SCHEMEINLINE>deriv</SCHEMEINLINE> is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that takes a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    as argument and returns a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    as value.  For example, to approximate the derivative of
    <LATEXINLINE>$x \mapsto x^3$</LATEXINLINE> at 5 (whose exact value is 75)
    we can evaluate
    <SNIPPET PAGE="74">
      <INDEX><DECLARATION>cube</DECLARATION></INDEX>
      <NAME>deriv_example</NAME>
      <REQUIRES>deriv_definition</REQUIRES>
      <EXPECTED>75.00014999664018</EXPECTED>
      <SCHEME>
(define (cube x) (* x x x))

((deriv cube) 5)
      </SCHEME>
      <SCHEMEOUTPUT>
75.00014999664018
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
function cube(x) { return x * x * x; }

deriv(cube)(5);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
75.00014999664018
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    With the aid of <SCHEMEINLINE>deriv</SCHEMEINLINE>, we can express
    Newton<APOS/>s method as a fixed-point process:

    <SNIPPET PAGE="74-75">
      <INDEX><DECLARATION>newton_transform</DECLARATION></INDEX>
      <INDEX><DECLARATION>newtons_method</DECLARATION></INDEX>
      <NAME>newtons_method_definition</NAME>
      <REQUIRES>fixed_definition</REQUIRES>
      <REQUIRES>deriv_definition</REQUIRES>
      <EXAMPLE>sqrt_example4</EXAMPLE>
      <EXPECTED>2.4494897427970397</EXPECTED>
      <SCHEME>
(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point 
    (newton-transform g) guess))
      </SCHEME>
      <JAVASCRIPT>
function newton_transform(g) {
    return x => x - g(x) / deriv(g)(x);
}
function newtons_method(g, guess) {
    return fixed_point(newton_transform(g), guess);
}
      </JAVASCRIPT>
    </SNIPPET>
    The
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>newton-transform</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>newton_transform</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    expresses the formula at the beginning of this section, and
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>newtons-method</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>newtons_method</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is readily defined in terms of this.  It takes as arguments a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that computes the function for which we want to find a zero, together with
    an initial guess.  For instance, to find the 
    square root of <LATEXINLINE>$x$</LATEXINLINE>, we can use
    <INDEX>Newton<APOS/>s method<SUBINDEX><ORDER>square</ORDER>for square roots</SUBINDEX></INDEX>
    Newton<APOS/>s
    method to find a zero of the function
    <LATEXINLINE>$y\mapsto y^2-x$</LATEXINLINE> starting with an initial guess
    of 1.<FOOTNOTE>For finding square roots, Newton<APOS/>s method converges
    rapidly to the correct solution from any starting point.</FOOTNOTE>
    This provides yet another form of the square-root
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <JAVASCRIPT>function:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET PAGE="75" POSTPADDING="no">
      <INDEX><DECLARATION>sqrt</DECLARATION><SUBINDEX><ORDER>Newton</ORDER>with Newton<APOS/>s method</SUBINDEX></INDEX>
      <INDEX><DECLARATION>sqrt</DECLARATION><SUBINDEX><ORDER>fixed</ORDER>as fixed point</SUBINDEX></INDEX>    
      <NAME>sqrt_definition5</NAME>
      <REQUIRES>newtons_method_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>sqrt_example4</EXAMPLE>
      <SCHEME>
(define (sqrt x)
  (newtons-method (lambda (y) (- (square y) x))
                  1.0))
      </SCHEME>
      <JAVASCRIPT>
function sqrt(x) {
    return newtons_method(y => square(y) - x, 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>sqrt_example4</NAME>
      <REQUIRES>sqrt_definition5</REQUIRES>
      <JAVASCRIPT>
sqrt(6);
      </JAVASCRIPT>
    </SNIPPET>
    <INDEX>Newton<APOS/>s method<SUBINDEX><ORDER>diff</ORDER>for differentiable functions<CLOSE/></SUBINDEX></INDEX>
  </TEXT>

  <SUBHEADING>
    <NAME>
      Abstractions and first-class
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    We<APOS/>ve seen two ways to express the square-root computation as an
    instance of a more general method, once as a fixed-point search and once
    using Newton<APOS/>s method.  Since Newton<APOS/>s method was itself
    expressed as a fixed-point process, we actually saw two ways to compute
    square roots as fixed points. Each method begins with a function and finds a 
    <INDEX>fixed point<SUBINDEX><ORDER>transform</ORDER>of transformed function</SUBINDEX></INDEX>
    fixed point of some transformation of the function.  We can express this
    general idea itself as a
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <JAVASCRIPT>function:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET PAGE="75">
      <INDEX><DECLARATION>fixed_point_of_transform</DECLARATION></INDEX>
      <NAME>fixed_point_of_transform_definition</NAME>
      <REQUIRES>fixed_definition</REQUIRES>
      <EXAMPLE>sqrt_example5</EXAMPLE>
      <EXPECTED>2.4494897427875517</EXPECTED>
      <SCHEME>
(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))
      </SCHEME>
      <JAVASCRIPT>
function fixed_point_of_transform(g, transform, guess) {
    return fixed_point(transform(g), guess);
}
      </JAVASCRIPT>
    </SNIPPET>
    This very general
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    takes as its arguments a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>g</SCHEMEINLINE>
    that computes some function, a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that transforms <SCHEMEINLINE>g</SCHEMEINLINE>, and an initial guess.
    The returned result is a fixed point of the transformed function.
  </TEXT>

  <TEXT>
    Using this abstraction, we can recast the first square-root computation
    <INDEX>fixed point<SUBINDEX>square root as</SUBINDEX></INDEX>
    from this section (where we look for a fixed point of the average-damped
    version of <LATEXINLINE>$y \mapsto x/y$</LATEXINLINE>) as an instance of
    this general method:
    <SNIPPET PAGE="75">
      <INDEX><DECLARATION>sqrt</DECLARATION><SUBINDEX><ORDER>fixed</ORDER>as fixed point</SUBINDEX></INDEX>    
      <NAME>sqrt_definition6</NAME>
      <REQUIRES>fixed_point_of_transform_definition</REQUIRES>
      <REQUIRES>average_damp_definition</REQUIRES>
      <EXAMPLE>sqrt_example5</EXAMPLE>
      <EXPECTED>2.4494897427875517</EXPECTED>
      <SCHEME>
(define (sqrt x)
  (fixed-point-of-transform (lambda (y) (/ x y))
                            average-damp
                            1.0))
      </SCHEME>
      <JAVASCRIPT>
function sqrt(x) {
    return fixed_point_of_transform(
               y => x / y,
               average_damp,
               1);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>sqrt_example5</NAME>
      <REQUIRES>sqrt_definition6</REQUIRES>
      <JAVASCRIPT>
sqrt(6);
      </JAVASCRIPT>
    </SNIPPET>
    Similarly, we can express the second square-root computation from this
    section (an instance of
    <INDEX>Newton<APOS/>s method<SUBINDEX><ORDER>square</ORDER>for square roots</SUBINDEX></INDEX>
    Newton<APOS/>s method that finds a fixed point of
    the Newton transform of <LATEXINLINE>$y\mapsto y^2-x$</LATEXINLINE>) as
    <SNIPPET PAGE="76">
      <INDEX><DECLARATION>sqrt</DECLARATION><SUBINDEX><ORDER>fixed</ORDER>as fixed point</SUBINDEX></INDEX>
      <INDEX><DECLARATION>sqrt</DECLARATION><SUBINDEX><ORDER>Newton</ORDER>with Newton<APOS/>s method</SUBINDEX></INDEX>
      <NAME>sqrt_definition7</NAME>
      <REQUIRES>fixed_point_of_transform_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>newtons_method_definition</REQUIRES>
      <EXAMPLE>sqrt_example6</EXAMPLE>
      <SCHEME>
(define (sqrt x)
  (fixed-point-of-transform (lambda (y) (- (square y) x))
                            newton-transform
                            1.0))
      </SCHEME>
      <JAVASCRIPT>
function sqrt(x) {
    return fixed_point_of_transform(
               y => square(y) - x,
               newton_transform,
               1);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>sqrt_example6</NAME>
      <REQUIRES>sqrt_definition7</REQUIRES>
      <JAVASCRIPT>
sqrt(6);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    We began section<SPACE/><REF NAME="sec:higher-order-procedures"/> with the
    observation that compound
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    are a crucial abstraction mechanism, because they permit us to express
    general methods of computing as explicit elements in our programming
    language.  Now we<APOS/>ve seen how higher-order
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    permit us to manipulate these general methods to create further abstractions.
  </TEXT>
  <TEXT>
    As programmers, we should be alert to opportunities to identify the
    underlying abstractions in our programs and to build upon them and
    generalize them to create more powerful abstractions.  This is not to say
    that one should always write programs in the most abstract way possible;
    expert programmers know how to choose the level of abstraction appropriate
    to their task.  But it is important to be able to think in terms of these
    abstractions, so that we can be ready to apply them in new contexts.  The
    significance of higher-order
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    is that they enable us to represent these abstractions explicitly as
    elements in our programming language, so that they can be handled just
    like other computational elements.
  </TEXT>
  <TEXT>
    In general, programming languages impose restrictions on the ways in which
    computational elements can be manipulated.  Elements with the fewest
    restrictions are said to have 
    <INDEX>first-class elements in language</INDEX>
    <EM>first-class</EM> status.  Some of the <QUOTE>rights and
    privileges</QUOTE> of first-class elements are:<FOOTNOTE>The notion of
    first-class status of programming-language
    elements is due to the British computer scientist
    <INDEX>Strachey, Christopher</INDEX>
    Christopher Strachey (1916<ENDASH/>1975).</FOOTNOTE>
    <UL>
      <LI>
	<SPLITINLINE>
	  <SCHEME>They may be named by variables.</SCHEME>
	  <JAVASCRIPT>They may be referred to using names.</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
	They may be passed as arguments to
	<SPLITINLINE>
	  <SCHEME>procedures.</SCHEME>
	  <JAVASCRIPT>functions.</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
	They may be returned as the results of
	<SPLITINLINE>
	  <SCHEME>procedures.</SCHEME>
	  <JAVASCRIPT>functions.</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
	They may be included in data structures.<FOOTNOTE>We<APOS/>ll see
	examples of this after we introduce data structures in
	chapter<SPACE/><REF NAME="chap:data"></REF>.</FOOTNOTE>
      </LI>
    </UL>
    <SPLITINLINE>
      <SCHEME>Lisp,</SCHEME>
      <JAVASCRIPT>JavaScript,</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE><SUBINDEX>first-class <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE> in</SUBINDEX></INDEX>
    <INDEX><FUNCTION/><SUBINDEX>first-class</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	unlike other
      </SCHEME>
      <JAVASCRIPT>
	like other high-level
      </JAVASCRIPT>
    </SPLITINLINE>
    programming languages, awards
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    full first-class status.  This poses challenges for efficient
    implementation, but the resulting gain in expressive power is
    enormous.<FOOTNOTE>The major implementation cost of first-class
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    is that allowing
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    to be returned as values requires reserving storage for a
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s free variables</SCHEME>
      <JAVASCRIPT>function<APOS/>s free names</JAVASCRIPT>
    </SPLITINLINE>
    even while the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is not executing.  
    <SPLITINLINE>
      <SCHEME>
	In the Scheme implementation we will study in
	section<SPACE/><REF NAME="sec:mc-eval"/>, these variables are stored in
	the procedure<APOS/>s
      </SCHEME>
      <JAVASCRIPT>
	In the JavaScript implementation we will study in
	section<SPACE/><REF NAME="sec:mc-eval"/>, these names are stored in the
	function<APOS/>s
      </JAVASCRIPT>
      </SPLITINLINE> environment.</FOOTNOTE>
  </TEXT>

  <EXERCISE>             
    <SPLITINLINE>
      <SCHEME>Define a procedure</SCHEME>
      <JAVASCRIPT>Declare a function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>cubic</SCHEMEINLINE> that can be used together with the 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>newtons-method</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>newtons_method</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    in expressions of the form
    <SNIPPET PAGE="77" HIDE="yes">
      <NAME>cubic_definition</NAME>
      <SCHEME>
;; cubic to be written by student; see EXERCISE 1.40
      </SCHEME>
      <JAVASCRIPT>
// cubic to be written by student; see EXERCISE 1.40
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="77" EVAL="no">
      <NAME>cubic_example</NAME>
      <REQUIRES>newtons_method_definition</REQUIRES>
      <REQUIRES>cubic_definition</REQUIRES>
      <SCHEME>
(newtons-method (cubic a b c) 1)
      </SCHEME>
      <JAVASCRIPT>
newtons_method(cubic(a, b, c), 1)
      </JAVASCRIPT>
    </SNIPPET>
    to approximate zeros of the cubic
    <LATEXINLINE>$x^3 +ax^2 +bx +c$</LATEXINLINE>.
    <SOLUTION>
      <SNIPPET>
	<NAME>cubic_definition_2</NAME>
	<REQUIRES>newtons_method_definition</REQUIRES>
	<REQUIRES>cube_definition</REQUIRES>
	<REQUIRES>square_definition</REQUIRES>
	<EXAMPLE>cubic_example_2</EXAMPLE>
	<EXPECTED>1.5615528128102987</EXPECTED>
	<JAVASCRIPT>
function cubic(a, b, c) {
    return x => cube(x) + a * square(x) + b * x + c;
}
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
      <SNIPPET PAGE="77" HIDE="yes">
        <NAME>cubic_example_2</NAME>
        <REQUIRES>newtons_method_definition</REQUIRES>
        <REQUIRES>cubic_definition</REQUIRES>
        <SCHEME>
(newtons-method (cubic a b c) 1)
        </SCHEME>
        <JAVASCRIPT>
newtons_method(cubic(1, -4, 0), 1);
        </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:1_40"/>
  </EXERCISE>

  <EXERCISE>
    <SPLITINLINE>
      <SCHEME>Define a procedure</SCHEME>
      <JAVASCRIPT>Declare a function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>double</SCHEMEINLINE> that takes a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of one argument as argument and returns a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that applies the original
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    twice.  For example, if <SCHEMEINLINE>inc</SCHEMEINLINE> is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that adds 1 to its argument, then
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>(double inc)</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>double(inc)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    should be a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that adds 2.  What value is returned<SPACE/>by
    <SNIPPET PAGE="77" HIDE="yes">
      <NAME>double_definition</NAME>
      <SCHEME>
;; double to be written by student; see EXERCISE 1.41
      </SCHEME>
      <JAVASCRIPT>
// double to be written by student; see EXERCISE 1.41
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="77" POSTPADDING="no">
      <NAME>double_example</NAME>
      <REQUIRES>double_definition</REQUIRES>
      <REQUIRES>inc_definition</REQUIRES>
      <SCHEME>
(((double (double double)) inc) 5)
      </SCHEME>
      <JAVASCRIPT>
double(double(double))(inc)(5);
      </JAVASCRIPT>
    </SNIPPET>
    <SOLUTION>       
      <SNIPPET>
	<REQUIRES>inc_definition</REQUIRES>
	<EXPECTED>21</EXPECTED>
	<EXAMPLE>double_example_solution</EXAMPLE>
	<JAVASCRIPT>
function double(f) {
    return x => f(f(x));
}
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>double_example_solution</NAME>
	<REQUIRES>inc_definition</REQUIRES>
	<JAVASCRIPT>
double(double(double))(inc)(5); // returns 21
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:1_41"/>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:compose"/>
    Let <LATEXINLINE>$f$</LATEXINLINE> and <LATEXINLINE>$g$</LATEXINLINE> be
    two one-argument functions.  The
    <INDEX>composition of functions</INDEX>
    <INDEX>function (mathematical)<SUBINDEX>composition of</SUBINDEX></INDEX>
    <EM>composition</EM>
    <LATEXINLINE>$f$</LATEXINLINE> after <LATEXINLINE>$g$</LATEXINLINE> is
    defined to be the function <LATEXINLINE>$x\mapsto f(g(x))$</LATEXINLINE>.
    <SPLITINLINE>
      <SCHEME>Define a procedure</SCHEME>
      <JAVASCRIPT>Declare a function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>compose</SCHEMEINLINE> that implements composition.  For
    example, if <SCHEMEINLINE>inc</SCHEMEINLINE> is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that adds 1 to its argument,
    <SNIPPET PAGE="77" HIDE="yes">
      <NAME>compose_definition</NAME>
      <SCHEME>
;; compose to be written by student; see EXERCISE 1.42
      </SCHEME>
      <JAVASCRIPT>
// compose to be written by student; see EXERCISE 1.42
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="77" POSTPADDING="no">
      <NAME>compose_example</NAME>
      <REQUIRES>compose_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>inc_definition</REQUIRES>
      <SCHEME>
((compose square inc) 6)
      </SCHEME>
      <SCHEMEOUTPUT>
49
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
compose(square, inc)(6);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
49
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <WEB_ONLY>returns 49.</WEB_ONLY>
    <SOLUTION>
      <SNIPPET>
	<NAME>compose_definition_solution</NAME>
	<EXAMPLE>compose_example_solution</EXAMPLE>
	<EXPECTED>49</EXPECTED>
	<JAVASCRIPT>
function compose(f, g) {
    return x => f(g(x));
}
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>compose_example_solution</NAME>
	<REQUIRES>inc_definition</REQUIRES>
	<REQUIRES>square_definition</REQUIRES>
	<JAVASCRIPT>
compose(square, inc)(6); // returns 49
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE> 
    If <LATEXINLINE>$f$</LATEXINLINE> is a numerical function and
<INDEX>function (mathematical)<SUBINDEX>repeated application of</SUBINDEX></INDEX>
    <LATEXINLINE>$n$</LATEXINLINE> is a positive integer, then we can form the
    <LATEXINLINE>$n$</LATEXINLINE>th
    <INDEX>function (mathematical)<SUBINDEX>repeated application of</SUBINDEX></INDEX>
    repeated application of
    <LATEXINLINE>$f$</LATEXINLINE>, which is defined to be the function whose
    value at <LATEXINLINE>$x$</LATEXINLINE> is
    <LATEXINLINE>$f(f(\ldots(f(x))\ldots))$</LATEXINLINE>.  For example, if
    <LATEXINLINE>$f$</LATEXINLINE> is the function
    <LATEXINLINE>$x \mapsto x+1$</LATEXINLINE>, then the
    <LATEXINLINE>$n$</LATEXINLINE>th repeated application of
    <LATEXINLINE>$f$</LATEXINLINE> is the function
    <LATEXINLINE>$x \mapsto x+n$</LATEXINLINE>. If
    <LATEXINLINE>$f$</LATEXINLINE> is the operation of squaring a number, then
    the <LATEXINLINE>$n$</LATEXINLINE>th repeated application of
    <LATEXINLINE>$f$</LATEXINLINE> is the function that raises its argument to
    the <LATEXINLINE>$2^n$</LATEXINLINE>th power.  Write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that takes as inputs a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that computes <LATEXINLINE>$f$</LATEXINLINE> and a positive integer
    <LATEXINLINE>$n$</LATEXINLINE> and returns the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that computes the <LATEXINLINE>$n$</LATEXINLINE>th repeated application of
    <LATEXINLINE>$f$</LATEXINLINE>.  Your
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    should be able to be used as follows:
    <SNIPPET PAGE="77" HIDE="yes">
      <NAME>repeated_definition</NAME>
      <SCHEME>
;; repeated to be written by student; see EXERCISE 1.43
      </SCHEME>
      <JAVASCRIPT>
// repeated to be written by student; see EXERCISE 1.43
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET PAGE="77">
      <NAME>repeated_example</NAME>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>repeated_definition</REQUIRES>
      <SCHEME>
((repeated square 2) 5)
      </SCHEME>
      <SCHEMEOUTPUT>
625
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
repeated(square, 2)(5);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
625
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    Hint: You may find it convenient to use
    <SCHEMEINLINE>compose</SCHEMEINLINE> from
    exercise<SPACE/><REF NAME="ex:compose"/>.
    <LABEL NAME="ex:repeated"/>
    <SOLUTION>
      <SNIPPET>
	<NAME>repeated_definition_solution</NAME>
	<REQUIRES>compose_definition_solution</REQUIRES>
        <EXAMPLE>repeated_example_solution</EXAMPLE>
	<EXPECTED>625</EXPECTED>
        <JAVASCRIPT>
function repeated(f, n) {
    return n === 0
           ? x => x
           : compose(f, repeated(f, n - 1));
}
	</JAVASCRIPT>
        <SCHEME>
        </SCHEME>
      </SNIPPET>
      <SNIPPET PAGE="77" HIDE="yes">
        <NAME>repeated_example_solution</NAME>
	<REQUIRES>square_definition</REQUIRES>
        <SCHEME>
((repeated square 2) 5)
        </SCHEME>
        <JAVASCRIPT>
repeated(square, 2)(5); // 625
        </JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE><LABEL NAME="ex:smooth"/> 
  The idea of
  <INDEX>function (mathematical)<SUBINDEX>smoothing of</SUBINDEX></INDEX>
  <INDEX>smoothing a function</INDEX>
  <EM>smoothing</EM> a function is an important concept in
  <INDEX>signal processing<SUBINDEX>smoothing a function</SUBINDEX></INDEX>
  signal processing.  If <LATEXINLINE>$f$</LATEXINLINE> is a function and
  <LATEXINLINE>$dx$</LATEXINLINE> is some small number, then the smoothed
  version of <LATEXINLINE>$f$</LATEXINLINE> is the function whose value at a
  point <LATEXINLINE>$x$</LATEXINLINE> is the average of
  <LATEXINLINE>$f(x-dx)$</LATEXINLINE>, <LATEXINLINE>$f(x)$</LATEXINLINE>, and
  <LATEXINLINE>$f(x+dx)$</LATEXINLINE>.  Write a
  <SPLITINLINE>
    <SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT>
  </SPLITINLINE>
  <SCHEMEINLINE>smooth</SCHEMEINLINE> that takes as input a
  <SPLITINLINE>
    <SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT>
  </SPLITINLINE>
  that computes <LATEXINLINE>$f$</LATEXINLINE> and returns a
  <SPLITINLINE>
    <SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT>
  </SPLITINLINE>
  that computes the smoothed <LATEXINLINE>$f$</LATEXINLINE>.  It is sometimes
  valuable to repeatedly smooth a function (that is, smooth the smoothed
  function, and so on) to obtained the <EM><LATEXINLINE>$n$</LATEXINLINE>-fold
  smoothed function</EM>.  Show how to generate the
  <LATEXINLINE>$n$</LATEXINLINE>-fold smoothed function of any given function
  using <SCHEMEINLINE>smooth</SCHEMEINLINE> and
  <SCHEMEINLINE>repeated</SCHEMEINLINE> from
  exercise<SPACE/><REF NAME="ex:repeated"/>.
  <SOLUTION>
    <SNIPPET>
      <NAME>n_fold_smooth_solution</NAME>
      <REQUIRES>cube_definition</REQUIRES>
      <REQUIRES>repeated_definition_solution</REQUIRES>
      <EXAMPLE>example_1.44</EXAMPLE>
      <EXPECTED>64.00000000399997</EXPECTED>
      <JAVASCRIPT>
const dx = 0.00001;
function smooth(f) {
    return x => (f(x - dx) + f(x) + f(x + dx)) / 3;
}
function n_fold_smooth(f, n) {
    return repeated(smooth, n)(f);
}
      </JAVASCRIPT>
      <SCHEME>
      </SCHEME>
    </SNIPPET>
  </SOLUTION>
  <SNIPPET HIDE="yes">
    <NAME>example_1.44</NAME>
    <JAVASCRIPT>
n_fold_smooth(cube, 5)(4);
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
  </SNIPPET>
    <LABEL NAME="ex:1_44"/>
  </EXERCISE>

  <EXERCISE>
    We saw in section<SPACE/><REF NAME="sec:proc-general-methods"/> that
    attempting to compute square roots by naively finding a fixed point of
    <LATEXINLINE>$y\mapsto x/y$</LATEXINLINE> does not converge, and that this
    can be fixed by average damping.  The same method works for finding cube
    roots as fixed points of the average-damped
    <LATEXINLINE>$y\mapsto x/y^2$</LATEXINLINE>. Unfortunately, the process
    does not work for
    <INDEX>fourth root, as fixed point</INDEX>
    <INDEX>fixed point<SUBINDEX>fourth root as</SUBINDEX></INDEX>
    fourth roots<EMDASH/>a single average damp is not enough to make a
    fixed-point search for <LATEXINLINE>$y\mapsto x/y^3$</LATEXINLINE>
    converge.  On the other hand, if we average-damp twice (i.e., use the
    average damp of the average damp of
    <LATEXINLINE>$y\mapsto x/y^3$</LATEXINLINE>) the fixed-point search does
    converge.  Do some experiments to determine how many average damps are
    required to compute 
    <INDEX><ORDER>nth</ORDER><LATEXINLINE>$n$</LATEXINLINE>th root, as fixed point</INDEX>
    <INDEX>fixed point<SUBINDEX><ORDER>nth</ORDER><LATEXINLINE>$n$</LATEXINLINE>th root as</SUBINDEX></INDEX>
    <LATEXINLINE>$n$</LATEXINLINE>th roots as a fixed-point search based upon
    repeated average damping of <LATEXINLINE>$y\mapsto x/y^{n-1}$</LATEXINLINE>.
    Use this to implement a simple
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for computing <LATEXINLINE>$n$</LATEXINLINE>th roots using 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>fixed-point</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fixed_point</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE> 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>average-damp</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>average_damp</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and the <SCHEMEINLINE>repeated</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of exercise<SPACE/><REF NAME="ex:repeated"/>. Assume that any arithmetic
    operations you need are available as primitives.
    <LABEL NAME="ex:nth-roots"/>
    <SOLUTION>
      <SNIPPET>
	<NAME>nth_root_solution</NAME>
	<REQUIRES>fixed_definition</REQUIRES>
	<REQUIRES>average_damp_definition</REQUIRES>
	<REQUIRES>repeated_definition_solution</REQUIRES>
        <REQUIRES>expt_log_definition</REQUIRES>
	<EXAMPLE>example_1.45</EXAMPLE>
	<EXPECTED>2.000001512995761</EXPECTED>
	<JAVASCRIPT>
function nth_root(n, x) {
    return fixed_point(repeated(average_damp, 
                                math_floor(math_log2(n)))
                       (y => x / fast_expt(y, n - 1)),
                       1);
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>example_1.45</NAME>
	<JAVASCRIPT>
nth_root(5, 32);
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    Several of the numerical methods described in this chapter are instances
    of an extremely general computational strategy known as
    <INDEX>iterative improvement</INDEX>
    <INDEX><USE>sqrt</USE><SUBINDEX><ORDER>iterative</ORDER>as iterative improvement</SUBINDEX></INDEX>
    <INDEX><USE>fixed_point</USE><SUBINDEX><ORDER>iterative</ORDER>as iterative improvement</SUBINDEX></INDEX>
    <INDEX>fixed point<SUBINDEX><ORDER>iterative</ORDER>as iterative improvement</SUBINDEX></INDEX>
    <EM>iterative improvement</EM>.  Iterative improvement says that, to compute something,
    we start with an initial guess for the answer, test if the guess is good
    enough, and otherwise improve the guess and continue the process using the
    improved guess as the new guess.  Write a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>iterative-improve</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>iterative_improve</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    that takes two
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    as arguments: a method for telling whether a guess is good enough and a
    method for improving a guess.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Iterative-improve</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function
      <JAVASCRIPTINLINE>iterative_improve</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    should return as its value a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that takes a guess as argument and keeps improving the guess until it is
    good enough.  Rewrite the <SCHEMEINLINE>sqrt</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of section<SPACE/><REF NAME="sec:sqrt"/> and the 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>fixed-point</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fixed_point</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of section<SPACE/><REF NAME="sec:proc-general-methods"/> in terms of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>iterative-improve</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>iterative_improve</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SOLUTION>
      <SNIPPET>
	<NAME>iterative_improve</NAME>
	<EXAMPLE>example_1.46_1</EXAMPLE>
	<EXPECTED>7.000000141269659</EXPECTED>
	<JAVASCRIPT>
function iterative_improve(is_good_enough, improve) {
    function iterate(guess) {
        return is_good_enough(guess)
               ? guess
               : iterate(improve(guess));
    }
    return iterate;
}		    
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>example_1.46_1</NAME>
	<REQUIRES>square_definition</REQUIRES>
        <REQUIRES>improve</REQUIRES>
        <REQUIRES>is_good_enough</REQUIRES>
	<REQUIRES>iterative_improve</REQUIRES>
	<JAVASCRIPT>
function sqrt(x) {
    return iterative_improve(y => is_good_enough(y, x), 
                             y => improve(y, x))(1);
}

sqrt(49);
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:1_46"/>
  </EXERCISE>

  <INDEX>higher-order <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE><SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE> as returned value<CLOSE/></SUBINDEX></INDEX>
  <INDEX><FUNCTION/><SUBINDEX><ORDER>returned</ORDER>as returned value<CLOSE/></SUBINDEX></INDEX>

</SUBSECTION>
