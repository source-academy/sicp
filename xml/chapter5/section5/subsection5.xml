<SUBSECTION>
  <NAME>
    An Example of Compiled Code
  </NAME>

  <LABEL NAME="sec:compiled-code"/>

  <INDEX>compiler for JavaScript<SUBINDEX>example compilation<OPEN/></SUBINDEX></INDEX>
  <INDEX><USE>factorial</USE><SUBINDEX>compilation of<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    Now that we have seen all the elements of the compiler, let us examine
    an example of compiled code to see how things fit together.  We will
    compile the
    <SPLITINLINE>
      <SCHEME>definition</SCHEME>
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    of a recursive
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>factorial</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>factorial</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	by calling
	<SCHEMEINLINE>compile</SCHEMEINLINE>:
      </SCHEME>
      <JAVASCRIPT>
	passing as first argument to
	<SCHEMEINLINE>compile</SCHEMEINLINE>
	the result of applying
	<SCHEMEINLINE>parse</SCHEMEINLINE> to
	a string representation of the program
	(here using
	<INDEX><ORDER>''</ORDER><JAVASCRIPTINLINE>`</JAVASCRIPTINLINE> (back quote)</INDEX>
	<INDEX>quotation marks<SUBINDEX>back quotes</SUBINDEX></INDEX>
	<INDEX>back quotes</INDEX>
	<INDEX>string(s)<SUBINDEX>typed over multiple lines</SUBINDEX></INDEX>
	back quotes
	<JAVASCRIPTINLINE>`</JAVASCRIPTINLINE><LATEXINLINE>$\ldots$</LATEXINLINE><JAVASCRIPTINLINE>`</JAVASCRIPTINLINE>, which work like
	single and double quotation marks,
	but allow the string to span multiple lines):
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      (compile
      '(define (factorial n)
      (if (= n 1)
            1
            (* (factorial (- n 1)) n)))
      'val
      'next)
      </SCHEME>
      <JAVASCRIPT>
compile(parse(`
function factorial(n) {
    return n === 1
           ? 1
           : factorial(n - 1) * n;
}
              `),
        "val",
        "next");
      </JAVASCRIPT>
    </SNIPPET>
    We have specified that the value of the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>define</SCHEMEINLINE> expression</SCHEME>
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    should be placed in the <SCHEMEINLINE>val</SCHEMEINLINE> register.
    We don<APOS/>t care what the compiled
    code does after executing the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>define</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    so our choice of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    as the linkage
    descriptor is arbitrary.
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Compile</SCHEMEINLINE>
	determines that the
	expression is a definition,
      </SCHEME>
      <JAVASCRIPT>
	The function <SCHEMEINLINE>compile</SCHEMEINLINE>
	expands the function-declaration derived component
	into a constant declaration,
      </JAVASCRIPT>
    </SPLITINLINE>
    so it calls
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-definition</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compile_declaration</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to compile code to compute the value to be assigned (targeted to
    <SCHEMEINLINE>val</SCHEMEINLINE>), followed by code to install the
    <SPLITINLINE>
      <SCHEME>definition,</SCHEME>
      <JAVASCRIPT>declaration,</JAVASCRIPT>
    </SPLITINLINE>
    followed by code to put the value of the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>define</SCHEMEINLINE> (which is the symbol
	<SCHEMEINLINE>ok</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
	declaration (which is the value
	<SCHEMEINLINE>undefined</SCHEMEINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    into the target register, followed finally by the linkage code.
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Env</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	Register <SCHEMEINLINE>env</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is preserved around the computation of the
    value, because it is needed in order to install the
    <SPLITINLINE>
      <SCHEME>
	definition.
      </SCHEME>
      <JAVASCRIPT>
	declaration.
      </JAVASCRIPT>
    </SPLITINLINE>
    Because
    the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    there is no linkage code
    in this case.  The skeleton of the compiled code is thus
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      ^save^ env ^if modified by code to compute value^
      ^compilation of definition value, target^ val^, linkage^ next
      ^restore^ env ^if saved above^
      (perform (op define-variable!)
            (const factorial)
            (reg val)
            (reg env))
      (assign val (const ok))
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>save <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if modified by code to compute value</METAPHRASE>
<METAPHRASE>compilation of declaration value, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE></METAPHRASE>
<METAPHRASE>restore <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if saved above</METAPHRASE>
perform(list(op("assign_symbol_value"),
             constant("factorial"),
             reg("val"),
             reg("env")),
assign("val", constant(undefined))
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The expression that is to be compiled to produce the value for the
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>constant</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>factorial</SCHEMEINLINE>
    is a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>
    expression whose value is the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that computes factorials.
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Compile</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	The function
	<SCHEMEINLINE>compile</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    handles this
    by calling
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-lambda</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_lambda_expression</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which compiles the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body, labels it as a new entry point, and generates the instruction that
    will combine the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body at the new entry point with the runtime environment and assign the
    result to <SCHEMEINLINE>val</SCHEMEINLINE>.  The sequence then skips around
    the compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code, which is inserted at this point.  The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code itself begins by extending the
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s definition</SCHEME>
      <JAVASCRIPT>function<APOS/>s declaration</JAVASCRIPT>
    </SPLITINLINE>
    environment by a frame that binds
    the formal parameter <SCHEMEINLINE>n</SCHEMEINLINE> to the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    argument.  Then comes the actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body.  Since this code for the value of the
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>constant</JAVASCRIPT>
    </SPLITINLINE>
    doesn<APOS/>t modify the <SCHEMEINLINE>env</SCHEMEINLINE> register, the
    optional <SCHEMEINLINE>save</SCHEMEINLINE>
    and <SCHEMEINLINE>restore</SCHEMEINLINE> shown above aren<APOS/>t
    generated.  (The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code at
    <SPLITINLINE><SCHEME><SCHEMEINLINE>entry2</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>entry1</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
     isn<APOS/>t executed at this point,
    so its use of <SCHEMEINLINE>env</SCHEMEINLINE> is irrelevant.)
    Therefore, the skeleton for the compiled code becomes
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      (assign val (op make-compiled-procedure)
            (label entry2)
            (reg env))
      (goto (label after-lambda1))
      entry2
      (assign env (op compiled-procedure-env) (reg proc))
      (assign env (op extend-environment)
            (const (n))
            (reg argl)
            (reg env))
      ^compilation of procedure body^
      after-lambda1
      (perform (op define-variable!)
            (const factorial)
            (reg val)
            (reg env))
      (assign val (const ok))
      </SCHEME>
      <JAVASCRIPT>
$$  assign("val", list(op("make_compiled_function"), label("entry1"), reg("env"))),
  go_to(label("after_lambda2")),
"entry1",
  assign("env", list(op("compiled_function_env"), reg("fun"))),
  assign("env", list(op("extend_environment"), constant(list("n")), reg("argl"), reg("env"))),
  <METAPHRASE>compilation of function body</METAPHRASE>
"after_lambda2",
  perform(list(op("assign_symbol_value"), constant("factorial"), reg("val"), reg("env"))),
  assign("val", constant(undefined))
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body is always compiled (by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-lambda-body</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>compile_lambda_body</JAVASCRIPTINLINE>)</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>as a sequence</SCHEME>
    </SPLITINLINE>
    with target <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE>. As a function body always
	ends with a return statement, which uses the
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE> linkage for its
	return expression, the last component in a function body is always compiled
	with linkage <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The
    <SPLITINLINE>
      <SCHEME>
	sequence
      </SCHEME>
      <JAVASCRIPT>
	body
      </JAVASCRIPT>
    </SPLITINLINE>
    in this case consists of
    a single
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE> expression:
      </SCHEME>
      <JAVASCRIPT>
	return statement:<FOOTNOTE>
  Because of the <JAVASCRIPTINLINE>append_return_undefined</JAVASCRIPTINLINE> in
  <JAVASCRIPTINLINE>compile_lambda_body</JAVASCRIPTINLINE>, the body actually
  consists of a sequence with two return statements. However, the dead code check
  in <JAVASCRIPTINLINE>compile_sequence</JAVASCRIPTINLINE> will stop after the compilation
  of the first return statement,
  so the body effectively consists of only a single return statement.
</FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      (if (= n 1)
      1
      (* (factorial (- n 1)) n))
      </SCHEME>
      <JAVASCRIPT>
return n === 1
       ? 1
       : factorial(n - 1) * n;
      </JAVASCRIPT>
    </SNIPPET>

    <SPLIT>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>compile_return_statement</JAVASCRIPTINLINE>
	generates code to revert the stack using the marker and to restore
	the <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> register,
	and then
	compiles the return expression. This uses the
	same target
	<SCHEMEINLINE>val</SCHEMEINLINE>
	but the linkage is
	<SCHEMEINLINE>"return"</SCHEMEINLINE>, because
	its value is to be returned from the function.
      </JAVASCRIPT>
    </SPLIT>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Compile-if</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	The return expression is a conditional expression
	and thus
	<JAVASCRIPTINLINE>compile_conditional</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    generates code that first computes the predicate (targeted to
    <SCHEMEINLINE>val</SCHEMEINLINE>), then checks the result and branches
    around the true branch if the predicate is false.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Env</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>Registers <SCHEMEINLINE>env</SCHEMEINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and <SCHEMEINLINE>continue</SCHEMEINLINE>
    are preserved around the predicate code, since they may be needed for the
    rest of the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>if</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>conditional</JAVASCRIPT>
    </SPLITINLINE>
    expression.
    <SPLIT>
      <SCHEME>
	Since the <SCHEMEINLINE>if</SCHEMEINLINE> expression
	is the final expression (and only expression) in the sequence making up
	the procedure
	body, its target is <SCHEMEINLINE>val</SCHEMEINLINE> and its linkage is
	<SCHEMEINLINE>return</SCHEMEINLINE>,
	so the
      </SCHEME>
      <JAVASCRIPT>
	The
      </JAVASCRIPT>
    </SPLIT>
    true and false branches are both
    compiled with target <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    (That is, the value of the conditional,
    which is the value computed by either of its branches, is the value of the
    <SPLITINLINE>
      <SCHEME>procedure.)</SCHEME>
      <JAVASCRIPT>function.)</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET LATEX="yes">
      <SCHEME>
      ^save^ continue^,^ env ^if modified by predicate and needed by branches^
      ^compilation of predicate, target^ val^, linkage^ next
      ^restore^ continue^,^ env ^if saved above^
      (test (op false?) (reg val))
      (branch (label false-branch4))
      true-branch5
      ^compilation of true branch, target^ val^, linkage^ return
      false-branch4
      ^compilation of false branch, target^ val^, linkage^ return
      after-if3
      </SCHEME>
      <JAVASCRIPT><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  revert_stack_to_marker(),
  restore("continue"),
  <METAPHRASE>save <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>, <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if modified by predicate and needed by branches</METAPHRASE>
  <METAPHRASE>compilation of predicate, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE></METAPHRASE>
  <METAPHRASE>restore <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>, <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if saved above</METAPHRASE>
  test(list(op("is_falsy"), reg("val"))),
  branch(label("false_branch4")),
"true_branch3",
  <METAPHRASE>compilation of true branch, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE></METAPHRASE>
"false_branch4",
  <METAPHRASE>compilation of false branch, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE></METAPHRASE>
"after_cond5",
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The predicate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(= n 1)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>n === 1</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is a
    <SPLITINLINE>
      <SCHEME>procedure call.</SCHEME>
      <JAVASCRIPT>function application (after expansion of the
      operator-combination derived form).
      </JAVASCRIPT>
    </SPLITINLINE>
    This looks up the
    <SPLITINLINE>
      <SCHEME>
    operator
    (the symbol <SCHEMEINLINE>=</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
	function expression
	(the symbol <JAVASCRIPTINLINE>"==="</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    and places this value in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    It then assembles the arguments <SCHEMEINLINE>1</SCHEMEINLINE> and the value
    of <SCHEMEINLINE>n</SCHEMEINLINE> into <SCHEMEINLINE>argl</SCHEMEINLINE>.
    Then it tests whether
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    contains a primitive or a compound
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    and dispatches to a primitive branch or a compound branch accordingly.
    Both branches resume at the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>after-call</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>after_call</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    label.
    <SPLITINLINE>
      <JAVASCRIPT>
      The compiled branch must set up
      <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> to jump past the primitive
      branch and push a marker to the stack to match the corresponding revert
      operation in the compiled return statement of the function.
      </JAVASCRIPT>
    </SPLITINLINE>
    The requirements to preserve registers around the evaluation of the
    <SPLITINLINE>
      <SCHEME>
	operator and operands
      </SCHEME>
      <JAVASCRIPT>
	function and argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    don<APOS/>t result in
    any saving of registers, because in this case those evaluations don<APOS/>t
    modify the registers in question.
    <SNIPPET LATEX="yes">
      <SCHEME>
      (assign proc
            (op lookup-variable-value) (const =) (reg env))
      (assign val (const 1))
      (assign argl (op list) (reg val))
      (assign val (op lookup-variable-value) (const n) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch17))
      compiled-branch16
      (assign continue (label after-call15))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch17
      (assign val (op apply-primitive-procedure)
            (reg proc)
            (reg argl))
      after-call15
      </SCHEME>
      <JAVASCRIPT><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  assign("fun", list(op("lookup_symbol_value"), constant("==="), reg("env"))),
  assign("val", constant(1)),
  assign("argl", list(op("list"), reg("val"))),
  assign("val", list(op("lookup_symbol_value"), constant("n"), reg("env"))),
  assign("argl", list(op("pair"), reg("val"), reg("argl"))),
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch6")),
"compiled_branch7",
  assign("continue", label("after_call8")),
  save("continue"),
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"primitive_branch6",
  assign("val", list(op("apply_primitive_function"), reg("fun"), reg("argl"))),
"after_call8",
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The true branch, which is the constant 1, compiles (with target
    <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    to
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      (assign val (const 1))
      (goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
$$  assign("val", constant(1)),
  go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
    The code for the false branch is another
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call, where the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is the value of the symbol
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>*</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>"*"</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and the arguments
    are <SCHEMEINLINE>n</SCHEMEINLINE> and the result of another
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call (a call to <SCHEMEINLINE>factorial</SCHEMEINLINE>).
    Each of these calls sets up
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and <SCHEMEINLINE>argl</SCHEMEINLINE> and its own primitive
    and compound branches.  Figure<SPACE/><REF NAME="fig:comp-factorial1"/>
    shows the complete compilation of the
    <SPLITINLINE>
      <SCHEME>
	definition
      </SCHEME>
      <JAVASCRIPT>
	declaration
      </JAVASCRIPT>
    </SPLITINLINE>
    of the <SCHEMEINLINE>factorial</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    Notice that the possible <SCHEMEINLINE>save</SCHEMEINLINE> and
    <SCHEMEINLINE>restore</SCHEMEINLINE> of
    <SCHEMEINLINE>continue</SCHEMEINLINE> and
    <SCHEMEINLINE>env</SCHEMEINLINE> around the predicate, shown above,
    are in fact generated, because these registers are modified by the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call in the predicate and needed for the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call and the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    linkage in the branches.
  </TEXT>

  <SPLITINLINE>
    <SCHEME>
      <INDEX>compiler for Scheme<SUBINDEX>example compilation<CLOSE/></SUBINDEX></INDEX>
    </SCHEME>
    <JAVASCRIPT>
      <INDEX>compiler for JavaScript<SUBINDEX>example compilation<CLOSE/></SUBINDEX></INDEX>
    </JAVASCRIPT>
  </SPLITINLINE>
  
  <EXERCISE>
    Consider the following declaration of a factorial
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    which is slightly different from the one given above:
    <SNIPPET EVAL="no">
      <SCHEME>
      (define (factorial-alt n)
      (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
      </SCHEME>
      <JAVASCRIPT>
function factorial_alt(n) {
    return n === 1
           ? 1
           : n * factorial_alt(n - 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Compile this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    and compare the resulting code with that produced for
    <SCHEMEINLINE>factorial</SCHEMEINLINE>.  Explain any differences you find.
    Does either program execute more efficiently than the other?
  </EXERCISE>

  <EXERCISE>
    Compile the
    <INDEX>iterative process<SUBINDEX>recursive process vs.</SUBINDEX></INDEX>
    <INDEX>recursive process<SUBINDEX>iterative process vs.</SUBINDEX></INDEX>
    iterative factorial
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      (define (factorial n)
      (define (iter product counter)
      (if (&gt; counter n)
            product
            (iter (* counter product)
            (+ counter 1))))
      (iter 1 1))
      </SCHEME>
      <JAVASCRIPT>
function factorial(n) {
    function iter(product, counter) {
        return counter &gt; n
               ? product
               : iter(product * counter, counter + 1);
    }
    return iter(1, 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Annotate the resulting code, showing the essential difference between
    the code for iterative and recursive versions of
    <SCHEMEINLINE>factorial</SCHEMEINLINE> that makes one process build up
    stack space and the other run in constant stack space.
    <LABEL NAME="ex:compiled-fact"/>
  </EXERCISE>

  <FIGURE CONTINUED="yes">
    <SNIPPET EVAL="no">
      <NAME>compiled_factorial_1</NAME>
      <SCHEME>
;; construct the procedure and skip over code for the procedure body
      (assign val
            (op make-compiled-procedure) (label entry2) (reg env))
      (goto (label after-lambda1))

      entry2     ; calls to factorial will enter here
      (assign env (op compiled-procedure-env) (reg proc))
      (assign env
            (op extend-environment) (const (n)) (reg argl) (reg env))
      ;; begin actual procedure body
      (save continue)
      (save env)

      ;; compute (= n 1)
      (assign proc (op lookup-variable-value) (const =) (reg env))
      (assign val (const 1))
      (assign argl (op list) (reg val))
      (assign val (op lookup-variable-value) (const n) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch17))
      compiled-branch16
      (assign continue (label after-call15))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch17
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

      after-call15   ; val now contains result of (= n 1)
      (restore env)
      (restore continue)
      (test (op false?) (reg val))
      (branch (label false-branch4))
      true-branch5  ; return 1
      (assign val (const 1))
      (goto (reg continue))

      false-branch4
      <EM>;; compute and return (* (factorial (- n 1)) n)</EM>
      (assign proc (op lookup-variable-value) (const *) (reg env))
      (save continue)
      (save proc)   ; save * procedure
      (assign val (op lookup-variable-value) (const n) (reg env))
      (assign argl (op list) (reg val))
      (save argl)   ; save partial argument list for *

      ;; compute (factorial (- n 1)), which is the other argument for *
      (assign proc
            (op lookup-variable-value) (const factorial) (reg env))
      (save proc)  ; save factorial procedure
    </SCHEME>
    <JAVASCRIPT>
// construct the function and skip over the code for the function body
  assign("val", list(op("make_compiled_function"), label("entry1"), reg("env"))),
  go_to(label("after_lambda2")),

"entry1",  // calls to factorial will enter here
  assign("env", list(op("compiled_function_env"), reg("fun"))),
  assign("env", list(op("extend_environment"), constant(list("n")), reg("argl"), reg("env"))),

// begin actual function body
  revert_stack_to_marker(),
  restore("continue"),
  save("continue"),
  save("env"),

// compute n === 1
  assign("fun", list(op("lookup_symbol_value"), constant("==="), reg("env"))),
  assign("val", constant(1)),
  assign("argl", list(op("list"), reg("val"))),
  assign("val", list(op("lookup_symbol_value"), constant("n"), reg("env"))),
  assign("argl", list(op("pair"), reg("val"), reg("argl"))),
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch6")),
"compiled_branch7",
  assign("continue", label("after_call8")),
  save("continue"),
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"primitive_branch6",
  assign("val", list(op("apply_primitive_function"), reg("fun"), reg("argl"))),

"after_call8",  // val now contains n === 1
  restore("env"),
  restore("continue"),
  test(list(op("is_falsy"), reg("val"))),
  branch(label("false_branch4")),
"true_branch3", // return 1
  assign("val", constant(1)),
  go_to(reg("continue")),

"false_branch4",
// compute and return factorial(n - 1) * n
  assign("fun", list(op("lookup_symbol_value"), constant("*"), reg("env"))),
  save("continue"),
  save("fun"),
  assign("val", list(op("lookup_symbol_value"), constant("n"), reg("env"))),
  assign("argl", list(op("list"), reg("val"))),
  save("argl"),

// compute factorial(n - 1) which is the other argument for *
  assign("fun", list(op("lookup_symbol_value"), constant("factorial"), reg("env"))),
  save("fun"),
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>
    Compilation of the declaration of the <SCHEMEINLINE>factorial</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    (continued on next page).
  </CAPTION>
  <LABEL NAME="fig:comp-factorial1"/>
  </FIGURE>
  <FIGURE>
  <SNIPPET LATEX="yes">
    <NAME>compiled_factorial_2</NAME>
    <SCHEME>
      ;; compute (- n 1), which is the argument for factorial
      (assign proc (op lookup-variable-value) (const -) (reg env))
      (assign val (const 1))
      (assign argl (op list) (reg val))
      (assign val (op lookup-variable-value) (const n) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (test (op primitive-procedure?) (reg proc))
      (branch label primitive-branch8))
      compiled-branch7
      (assign continue (label after-call6))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch8
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

      after-call6   ; val now contains result of (- n 1)
      (assign argl (op list) (reg val))
      (restore proc) ; restore factorial
      ;; apply factorial
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch11))
      compiled-branch10
      (assign continue (label after-call9))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch11
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

      after-call9      ; val now contains result of (factorial (- n 1))
      (restore argl) ; restore partial argument list for *
      (assign argl (op cons) (reg val) (reg argl))
      (restore proc) ; restore *
      (restore continue)
      ;; apply * and return its value
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch14))
      compiled-branch13
      ;; note that a compound procedure here is called tail-recursively
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch14
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
      (goto (reg continue))
      after-call12
      after-if3
      after-lambda1
      ;; assign the procedure to the variable factorial
      (perform
      (op define-variable!) (const factorial) (reg val) (reg env))
      (assign val (const ok))
    </SCHEME>
    <JAVASCRIPT latex="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
// compute n - 1 which is the argument for factorial
  assign("fun", list(op("lookup_symbol_value"), constant("-"), reg("env"))),
  assign("val", constant(1)),
  assign("argl", list(op("list"), reg("val"))),
  assign("val", list(op("lookup_symbol_value"), constant("n"), reg("env"))),
  assign("argl", list(op("pair"), reg("val"), reg("argl"))),
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch10")),
"compiled_branch11",
  assign("continue", label("after_call12")),
  save("continue"),
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"primitive_branch10",
  assign("val", list(op("apply_primitive_function"), reg("fun"), reg("argl"))),

"after_call12",                     // val now holds result of n - 1
  assign("argl", list(op("list"), reg("val"))),
  restore("fun"),
  // apply factorial
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch14")),
"compiled_branch15",
  assign("continue", label("after_call16")),
  save("continue"),
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"primitive_branch14",
  assign("val", list(op("apply_primitive_function"), reg("fun"), reg("argl"))),

"after_call16",                     // val now has result of factorial(n - 1)
  restore("argl"),                  // restore partial argument list for *
  assign("argl", list(op("pair"), reg("val"), reg("argl"))),
  restore("fun"),                   // restore *
  restore("continue"),
  // apply * and return its value
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch18")),

"compiled_branch19",
// note the compound function here is called tail-recursively
  save("continue"),
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"primitive_branch18",
  assign("val", list(op("apply_primitive_function"), reg("fun"), reg("argl"))),
  go_to(reg("continue")),
"after_call20",
"after_cond5",
"after_lambda2",
  // assign the function to the name factorial
  perform(list(op("assign_symbol_value"), constant("factorial"), reg("val"), reg("env"))),
  assign("val", constant(undefined)),
  go_to(reg("continue"))
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>(continued)</CAPTION>
  <LABEL NAME="fig:continued_1"/>
</FIGURE>

<EXERCISE>
  <LABEL NAME="ex:compiled-code"/>
  What
  <SPLITINLINE>
    <SCHEME>
      expression
    </SCHEME>
    <JAVASCRIPT>
      program
    </JAVASCRIPT>
  </SPLITINLINE>
  was compiled to produce the code shown in
  figure<SPACE/><REF NAME="fig:compilation-example1"/>?
</EXERCISE>
      
  <FIGURE CONTINUED="yes">
  <SNIPPET LATEX="yes">
    <SCHEME>
      (assign val (op make-compiled-procedure) label entry16)
            (reg env))
      (goto (label after-lambda15))
      entry16
      (assign env (op compiled-procedure-env) (reg proc))
      (assign env
            (op extend-environment) (const (x)) (reg argl) (reg env))
      (assign proc (op lookup-variable-value) (const +) (reg env))
      (save continue)
      (save proc)
      (save env)
      (assign proc (op lookup-variable-value) (const g) (reg env))
      (save proc)
      (assign proc (op lookup-variable-value) (const +) (reg env))
      (assign val (const 2))
      (assign argl (op list) (reg val))
      (assign val (op lookup-variable-value) (const x) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch19))
      compiled-branch18
      (assign continue (label after-call17))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch19
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
      after-call17
      (assign argl (op list) (reg val))
      (restore proc)
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch22))
      compiled-branch21
      (assign continue (label after-call20))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch22
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
    </SCHEME>
    <JAVASCRIPT LATEX="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  assign("val", list(op("make_compiled_function"), label("entry1"), reg("env")))
  go_to(label("after_lambda2"))
"entry1"
  assign("env", list(op("compiled_function_env"), reg("fun")))
  assign("env", list(op("extend_environment"), constant(list("x", "g")), reg("argl"), reg("env")))
  revert_stack_to_marker()
  restore("continue")
  assign("fun", list(op("lookup_symbol_value"), constant("g"), reg("env")))
  save("continue")
  save("fun")
  assign("fun", list(op("lookup_symbol_value"), constant("+"), reg("env")))
  assign("val", constant(2))
  assign("argl", list(op("list"), reg("val")))
  assign("val", list(op("lookup_symbol_value"), constant("x"), reg("env")))
  assign("argl", list(op("pair"), reg("val"), reg("argl")))
  test(list(op("is_primitive_function"), reg("fun")))
  branch(label("primitive_branch3"))
"compiled_branch4"
  assign("continue", label("after_call5"))
  save("continue")
  push_marker_to_stack()
  assign("val", list(op("compiled_function_entry"), reg("fun")))
  go_to(reg("val"))
"primitive_branch3"
  assign("val", list(op("apply_primitive_function"), reg("fun"), reg("argl")))
"after_call5"
  assign("argl", list(op("list"), reg("val")))
  restore("fun")
  restore("continue")
  test(list(op("is_primitive_function"), reg("fun")))
  branch(label("primitive_branch7"))
"compiled_branch8"
  save("continue")
  push_marker_to_stack()
  assign("val", list(op("compiled_function_entry"), reg("fun")))
  go_to(reg("val"))
"primitive_branch7"
  assign("val", list(op("apply_primitive_function"), reg("fun"), reg("argl")))
  go_to(reg("continue"))
"after_call9"
"after_lambda2"
  perform(list(op("assign_symbol_value"), constant("f"), reg("val"), reg("env")))
  assign("val", constant(undefined))
  go_to(reg("continue"))
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>An example of compiler output<SPLITINLINE><SCHEME> (continued on next page)</SCHEME></SPLITINLINE>.
  See exercise<SPACE/><REF NAME="ex:compiled-code"/>.
  </CAPTION>
  <LABEL NAME="fig:compilation-example1"/>
  </FIGURE>
  <SPLIT>
    <SCHEME>
  <FIGURE>
    <SNIPPET EVAL="no">
      <SCHEME>
      after-call20
      (assign argl (op list), (reg val))
      (restore env)
      (assign val (op lookup-variable-value) (const x) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (restore proc)
      (restore continue)
      (test (op primitive-procedure?) (reg proc))
      (branch label primitive-branch25))
      compiled-branch24
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch25
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
      (goto (reg continue))
      after-call23
      after-lambda15
      (perform (op define-variable!) (const f) (reg val) (reg env))
      (assign val (const ok))
    </SCHEME>
  </SNIPPET>
    <CAPTION>(continued)</CAPTION>
    <LABEL NAME="fig:continued_2"/>
  </FIGURE>
    </SCHEME>
  </SPLIT>

  <INDEX><USE>factorial</USE><SUBINDEX>compilation of<CLOSE/></SUBINDEX></INDEX>

  <EXERCISE>
    What
    <INDEX>order of evaluation<SUBINDEX>in compiler</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>compiler for Scheme<SUBINDEX>order of operand evaluation</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>compiler for JavaScript<SUBINDEX>order of argument evaluation</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    order of evaluation does our compiler produce for
    <SPLITINLINE>
      <SCHEME>operands of a combination?</SCHEME>
      <JAVASCRIPT>arguments of an application?</JAVASCRIPT>
    </SPLITINLINE>
    Is it left-to-right, right-to-left, or some other order?
    Where in the compiler is this order determined?  Modify the compiler
    so that it produces some other order of evaluation.  (See the
    discussion of order of evaluation for the explicit-control evaluator
    in section<SPACE/><REF NAME="sec:eceval-core"/>.)  How does changing the
    order of
    <SPLITINLINE>
      <SCHEME>operand</SCHEME>
      <JAVASCRIPT>argument</JAVASCRIPT>
    </SPLITINLINE>
    evaluation affect the efficiency of the code that
    constructs the argument list?
  </EXERCISE>

  <EXERCISE>
    One way to understand the compiler<APOS/>s
    <INDEX>compiler for JavaScript<SUBINDEX>stack usage</SUBINDEX></INDEX>
    <INDEX><USE>preserving</USE></INDEX>
    <SCHEMEINLINE>preserving</SCHEMEINLINE> mechanism for
    optimizing stack usage is to see what extra operations would
    be generated if we did not use this idea.  Modify
    <SCHEMEINLINE>preserving</SCHEMEINLINE> so
    that it always generates the <SCHEMEINLINE>save</SCHEMEINLINE> and
    <SCHEMEINLINE>restore</SCHEMEINLINE> operations.
    Compile some simple expressions and identify the unnecessary stack
    operations that are generated.
    Compare the code to that generated with the
    <SCHEMEINLINE>preserving</SCHEMEINLINE> mechanism intact.
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:open-code"/>
    Our compiler is clever about avoiding unnecessary stack operations,
    but it is not clever at all when it comes to compiling calls to the primitive
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    of the language in terms of the primitive operations
    supplied by the machine.  For example, consider how much code is
    compiled to compute
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(+ a 1)</SCHEMEINLINE>:</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>a + 1</JAVASCRIPTINLINE>:</JAVASCRIPT>
    </SPLITINLINE>
    The code sets up an argument list in <SCHEMEINLINE>argl</SCHEMEINLINE>, puts
    the primitive addition
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    (which it finds by looking up the symbol
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>+</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>"+"</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in the environment) into
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>,</JAVASCRIPT>
      </SPLITINLINE>
    and tests whether the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is primitive or compound.  The
    compiler always generates code to perform the test, as well as code
    for primitive and compound branches (only one of which will be executed).
    We have not shown the part of the controller that implements
    primitives, but we presume that these instructions make use of
    primitive arithmetic operations in the machine<APOS/>s data paths.  Consider
    how much less code would be generated if the compiler could
    <INDEX>compiler for JavaScript<SUBINDEX>open-coding of primitives</SUBINDEX></INDEX>
    <INDEX>open-coding of primitives</INDEX>
    <EM>open-code</EM> primitives<EMDASH/>that is, if it could generate code to
    directly use these primitive machine operations.  The expression
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(+ a 1)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>a + 1</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    might be compiled into something as simple as<FOOTNOTE>We have used
    the same symbol <SCHEMEINLINE>+</SCHEMEINLINE> here to denote both the
    source-language
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    and the machine operation.  In general there will not be a
    one-to-one correspondence between primitives of the source language
    and primitives of the machine.</FOOTNOTE>
    <SNIPPET EVAL="no">
      <SCHEME>
(assign val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
      </SCHEME>
      <JAVASCRIPT>
assign("val", list(op("lookup_symbol_value"),
                   constant("a"), reg("env")),
assign("val", list(op("+"), reg("val"), constant(1))
      </JAVASCRIPT>
    </SNIPPET>
    In this exercise we will extend our compiler to support open coding of
    selected primitives.  Special-purpose code will be generated for calls to these primitive
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    instead of the general
    <SPLITINLINE>
      <SCHEME>procedure-application</SCHEME>
      <JAVASCRIPT>function-application</JAVASCRIPT>
    </SPLITINLINE>
    code.  In order to support this, we will augment
    our machine with special argument registers
    <SCHEMEINLINE>arg1</SCHEMEINLINE> and <SCHEMEINLINE>arg2</SCHEMEINLINE>.
    The primitive arithmetic operations of the machine will take their
    inputs from <SCHEMEINLINE>arg1</SCHEMEINLINE> and
    <SCHEMEINLINE>arg2</SCHEMEINLINE>. The results may be put into
    <SCHEMEINLINE>val</SCHEMEINLINE>, <SCHEMEINLINE>arg1</SCHEMEINLINE>, or
    <SCHEMEINLINE>arg2</SCHEMEINLINE>.
    <P/>
    The compiler must be able to recognize the application of an
    open-coded primitive in the source program.  We will augment the
    dispatch in the <SCHEMEINLINE>compile</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to recognize the names of these primitives in addition to the
    <SPLITINLINE>
      <SCHEME>
	<INDEX>reserved words</INDEX>
	reserved words (the special forms)
	it currently recognizes.<FOOTNOTE>Making
	the primitives into reserved words is in general a bad idea, since a user
	cannot then rebind these names to different procedures.
	Moreover, if we add reserved words to
	a compiler that is in use, existing programs that define procedures
	with these names will stop working.  See
	exercise<SPACE/><REF NAME="ex:cte-open-code"/> for ideas on how to avoid
	this problem.</FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	syntactic forms it currently recognizes.
      </JAVASCRIPT>
    </SPLITINLINE>
    For each
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>syntactic</JAVASCRIPT>
    </SPLITINLINE>
    form our compiler has a code
    generator.  In this exercise we will construct a family of code generators
    for the open-coded primitives.
    <OL>
      <LI>
	The open-coded primitives, unlike the
	<SPLITINLINE>
	  <SCHEME>special</SCHEME>
	  <JAVASCRIPT>syntactic</JAVASCRIPT>
	</SPLITINLINE>
	forms, all need their
	<SPLITINLINE>
	  <SCHEME>operands</SCHEME>
	  <JAVASCRIPT>arguments</JAVASCRIPT>
	</SPLITINLINE>
	evaluated.  Write a code generator
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>spread-arguments</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>spread_arguments</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	for use by all the open-coding code generators.
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>Spread-arguments</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    The function
	    <JAVASCRIPTINLINE>spread_arguments</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	should take an
	<SPLITINLINE>
	  <SCHEME>operand</SCHEME>
	  <JAVASCRIPT>argument</JAVASCRIPT>
	</SPLITINLINE>
	list and compile the given
	<SPLITINLINE>
	  <SCHEME>operands</SCHEME>
	  <JAVASCRIPT>arguments</JAVASCRIPT>
	</SPLITINLINE>
	targeted to
	successive argument registers.  Note that an
	<SPLITINLINE>
	  <SCHEME>operand</SCHEME>
	  <JAVASCRIPT>argument</JAVASCRIPT>
	</SPLITINLINE>
	may contain a call
	to an open-coded primitive, so argument registers will have to be
	preserved during
	<SPLITINLINE>
	  <SCHEME>operand</SCHEME>
	  <JAVASCRIPT>argument</JAVASCRIPT>
	</SPLITINLINE>
	evaluation.
      </LI>
      <LI>
	<SPLIT>
	  <JAVASCRIPT>
	    The JavaScript operators
	    <JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,
	    <SCHEMEINLINE>*</SCHEMEINLINE>,
	    <SCHEMEINLINE>-</SCHEMEINLINE>, and <SCHEMEINLINE>+</SCHEMEINLINE>,
	    among others, are implemented in the register machine as
	    primitive functions, and referred to in the global environment
	    with the symbols
	    <JAVASCRIPTINLINE>"==="</JAVASCRIPTINLINE>,
	    <SCHEMEINLINE>"*"</SCHEMEINLINE>,
	    <SCHEMEINLINE>"-"</SCHEMEINLINE>, and
	    <SCHEMEINLINE>"+"</SCHEMEINLINE>. In JavaScript, it is
	    not possible to redeclare these names, because they do not
	    meet the syntactic restrictions for names. This means it is safe
	    to open-code them.
	  </JAVASCRIPT>
	</SPLIT>
	For each of the primitive
	<SPLITINLINE>
	  <SCHEME>procedures</SCHEME>
	  <JAVASCRIPT>functions</JAVASCRIPT>
	</SPLITINLINE>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>=</SCHEMEINLINE>,</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,</JAVASCRIPT>
	</SPLITINLINE>
	<SCHEMEINLINE>*</SCHEMEINLINE>,
	<SCHEMEINLINE>-</SCHEMEINLINE>, and <SCHEMEINLINE>+</SCHEMEINLINE>,
	write a code generator that takes
	<SPLITINLINE>
	  <SCHEME>a combination with that operator,
	  </SCHEME>
	  <JAVASCRIPT>an application with a function expression that
	  names that function,
	  </JAVASCRIPT>
	</SPLITINLINE>
	together with a target and a linkage descriptor, and
	produces code to spread the arguments into the registers and then
	perform the operation targeted to the given target with the given
	linkage.
	<SPLITINLINE>
	  <SCHEME>You need only handle expressions with two operands.</SCHEME>
	</SPLITINLINE>
	Make <SCHEMEINLINE>compile</SCHEMEINLINE> dispatch to these code
	generators.
      </LI>
      <LI>
	Try your new compiler on the <SCHEMEINLINE>factorial</SCHEMEINLINE>
	example.  Compare the resulting code with the result produced without
	open coding.
      </LI>
      <SPLIT>
	<SCHEME>
	  <LI>
	    Extend your code generators for <SCHEMEINLINE>+</SCHEMEINLINE> and
	    <SCHEMEINLINE>*</SCHEMEINLINE> so that they
	    can handle expressions with arbitrary numbers of operands.  An
	    expression with more than two operands will have to be compiled into a
	    sequence of operations, each with only two inputs.
	  </LI>
	</SCHEME>
      </SPLIT>
    </OL>
  </EXERCISE>
</SUBSECTION>
