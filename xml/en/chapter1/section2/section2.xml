<SECTION>
  <NAME>
    <SPLITINLINE>
      <SCHEME>Procedures</SCHEME>
      <JAVASCRIPT>Functions</JAVASCRIPT>
    </SPLITINLINE>
    and the Processes They Generate
  </NAME>

  <SECTIONCONTENT/>

  <LABEL NAME="sec:procedures-and-processes"/> 

  <TEXT>
    We have now considered the elements of programming: We have used
    primitive arithmetic operations, we have combined these operations, and
    we have abstracted these composite operations by 
    <SPLITINLINE>
      <SCHEME>defining them as compound procedures.</SCHEME>
      <JAVASCRIPT>declaring them as compound functions.</JAVASCRIPT>
      </SPLITINLINE>
    But that is not enough to enable us to say that we know
    how to program.  Our situation is analogous to that of someone who has
    learned the rules for how the pieces move in chess but knows nothing
    of typical openings, tactics, or strategy.  Like the novice chess
    player, we don<APOS/>t yet know the common patterns of usage in the domain.
    We lack the knowledge of which moves are worth making 
    <SPLITINLINE>
      <SCHEME>(which procedures are worth defining).</SCHEME>
      <JAVASCRIPT>(which functions are worth declaring).</JAVASCRIPT>
    </SPLITINLINE>
    We lack the experience to predict the consequences of making a move
    <SPLITINLINE>
      <SCHEME>(executing a procedure).</SCHEME>
      <JAVASCRIPT>(executing a function).</JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    The ability to visualize the consequences of the actions under
    consideration is crucial to becoming an expert programmer, just as it
    is in any synthetic, creative activity.  In becoming an expert
    photographer, for example, one must learn how to look at a scene and
    know how dark each region will appear on a print for each possible
    choice of exposure and
    <SPLITINLINE>
      <SCHEME>development.</SCHEME>
      <JAVASCRIPT>processing options.</JAVASCRIPT>
    </SPLITINLINE>
    <COMMENT>
      The term <QUOTE>development</QUOTE> may not be known to the
      mainstream audience in the digital age.
    </COMMENT>
    Only then can one reason backward, planning framing, lighting,
    exposure, and
    <SPLITINLINE>
      <SCHEME>development</SCHEME>
      <JAVASCRIPT>processing</JAVASCRIPT>
    </SPLITINLINE>
    to obtain the desired effects.  So it is with programming, where we are
    planning the course of action to be taken by a process and where we control
    the process by means of a program.  To become experts, we must learn to
    visualize the processes generated by various types of
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    Only after we have developed such a skill can we learn
    to reliably construct programs that exhibit the desired behavior.
  </TEXT>

  <TEXT>
    A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE> 
    is a
    <INDEX><FUNCTION/><SUBINDEX><ORDER>pattern</ORDER> as pattern for local evolution of a process</SUBINDEX></INDEX>
    pattern for the <EM>local evolution</EM> of a
    computational process.  It specifies how each stage of the process is
    built upon the previous stage.  We would like to be able to make
    statements about the overall, or <EM>global</EM>, behavior of a
    process whose local
    <INDEX>local evolution of a process</INDEX>
    <INDEX>process<SUBINDEX>local evolution of</SUBINDEX></INDEX>
    evolution has been specified by a 
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    This is very difficult to do in general, but we can at least try to
    describe some typical patterns of process evolution.
  </TEXT>

  <TEXT>
    In this section we will examine some common <QUOTE>shapes</QUOTE> for
    processes generated by simple 
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    We will also investigate the rates at which these processes consume the
    important computational resources of time and space. The 
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE> 
    we will consider are very simple.  Their role is like that played by test
    patterns in photography: as oversimplified prototypical patterns, rather
    than practical examples in their own right.
  </TEXT>

  <!-- Subsection 1 : Linear Recursion and Iteration -->
  &amp;subsection1.2.1;

  <!-- Subsection 2 : Tree Recursion -->
  &amp;subsection1.2.2;

  <!-- Subsection 3 : Orders of Growth -->
  &amp;subsection1.2.3;

  <!-- Subsection 4 : Exponentiation -->
  &amp;subsection1.2.4;

  <!-- Subsection 5 : Greatest Comman Divisors -->
  &amp;subsection1.2.5;

  <!-- Subsection 6 : Example: Testing for Primality -->
  &amp;subsection1.2.6;

</SECTION>
