<SUBSECTION>
   <NAME>
    队列表示
  </NAME> 

  <LABEL NAME="sec:queues"></LABEL>
   <INDEX>队列<OPEN></OPEN></INDEX> 

   <TEXT>
    修改器
    <SPLITINLINE>
      set-car!
      <JAVASCRIPT><JAVASCRIPTINLINE>set_head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      set-cdr!
      <JAVASCRIPT><JAVASCRIPTINLINE>set_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    使我们能够使用序对来构建无法使用
    <SPLITINLINE>
      cons,
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      car,
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    单独构建的数据结构。本节展示了如何使用序对来表示一个称为队列的数据结构。第<SPACE></SPACE><REF NAME="sec:tables"></REF>节将展示如何表示称为表的数据结构。
  </TEXT> 

  <TEXT> 
    A <EM>队列</EM> is a sequence in which items are inserted at one end
    (called the
    <INDEX>队列<SUBINDEX>尾</SUBINDEX></INDEX>
    <EM>rear</EM> of the queue) and deleted from the other end (the
    <INDEX>队列<SUBINDEX>头</SUBINDEX></INDEX>
    <EM>front</EM>).
    <SPLITINLINE>
      图<SPACE></SPACE><REF NAME="fig:queue-ops_scheme"></REF>
      <JAVASCRIPT>图<SPACE></SPACE><REF NAME="fig:queue-ops"></REF></JAVASCRIPT>
    </SPLITINLINE>
    shows an initially empty queue in which the items
     <SCHEMEINLINE>a</SCHEMEINLINE>  和  <SCHEMEINLINE>b</SCHEMEINLINE>  被插入。然后  <SCHEMEINLINE>a</SCHEMEINLINE>  被移除， <SCHEMEINLINE>c</SCHEMEINLINE>  和  <SCHEMEINLINE>d</SCHEMEINLINE>  被插入，并且  <SCHEMEINLINE>b</SCHEMEINLINE>  被移除。因为项目总是按插入的顺序被移除，所以队列有时被称为
    <INDEX>先入先出缓冲器</INDEX>
    <EM>FIFO</EM>（先入先出）缓冲器。
    <SPLIT>
      
	<FIGURE>
          <FIGURE SRC="img_original/ch3.18.svg"></FIGURE>
          <CAPTION>队列操作。</CAPTION>
          
	</FIGURE>
      
      <JAVASCRIPT>
	<FIGURE>
	  <TABLE>
	    <TR>
	      <TD>
		Operation
	      </TD>
	      <TD>
		Resulting Queue
	      </TD>
	    </TR>
	    <TR>
	      <TD>
		<JAVASCRIPTINLINE>const q = make_queue();</JAVASCRIPTINLINE>
	      </TD>
	      <TD>
	      </TD>
	    </TR>
	    <TR>
	      <TD>
		<JAVASCRIPTINLINE>insert_queue(q, &quot;a&quot;);</JAVASCRIPTINLINE>
	      </TD>
	      <TD>
		<JAVASCRIPTINLINE>a</JAVASCRIPTINLINE>
	      </TD>
	    </TR>
	    <TR>
	      <TD>
		<JAVASCRIPTINLINE>insert_queue(q, &quot;b&quot;);</JAVASCRIPTINLINE>
	      </TD>
	      <TD>
		<JAVASCRIPTINLINE>a  b</JAVASCRIPTINLINE>
	      </TD>
	    </TR>
	    <TR>
	      <TD>
		<JAVASCRIPTINLINE>delete_queue(q);</JAVASCRIPTINLINE>
	      </TD>
	      <TD>
		<JAVASCRIPTINLINE>b</JAVASCRIPTINLINE>
	      </TD>
	    </TR>
	    <TR>
	      <TD>
		<JAVASCRIPTINLINE>insert_queue(q, &quot;c&quot;);</JAVASCRIPTINLINE>
	      </TD>
	      <TD>
		<JAVASCRIPTINLINE>b c</JAVASCRIPTINLINE>
	      </TD>
	    </TR>
	    <TR>
	      <TD>
		<JAVASCRIPTINLINE>insert_queue(q, &quot;d&quot;);</JAVASCRIPTINLINE>
	      </TD>
	      <TD>
		<JAVASCRIPTINLINE>b c d</JAVASCRIPTINLINE>
	      </TD>
	    </TR>
	    <TR>
	      <TD>
		<JAVASCRIPTINLINE>delete_queue(q);</JAVASCRIPTINLINE>
	      </TD>
	      <TD>
		<JAVASCRIPTINLINE>c d</JAVASCRIPTINLINE>
	      </TD>
	    </TR>
	  </TABLE>
          <CAPTION>队列操作。</CAPTION>
          
	</FIGURE>
      </JAVASCRIPT>
    </SPLIT>
   </TEXT>

   <SHORT_PAGE LINES="2"></SHORT_PAGE> 
  <TEXT> 
    在
    <INDEX>数据抽象<SUBINDEX>用于队列<SUBINDEX></SUBINDEX></SUBINDEX></INDEX>
    <INDEX>队列<SUBINDEX>上的操作<SUBINDEX></SUBINDEX></SUBINDEX></INDEX>
    数据抽象方面，我们可以将队列视为由以下一组操作定义的：
     <UL>
       <LI>
	一个构造函数：
	<BR></BR>
        <INDEX><USE>make_queue</USE></INDEX> 
          <SPLITINLINE>
	    (make-queue)
	    <JAVASCRIPT><JAVASCRIPTINLINE>make_queue()</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>
	  <BR></BR>
          返回一个空队列（一个不包含任何项目的队列）。
	  <PDF_ONLY>\vspace{6pt}</PDF_ONLY>
      </LI>
      <LI>
        一个谓词：
        <BR></BR>
        <INDEX><USE>is_empty_queue</USE></INDEX> 
          <SPLITINLINE>
	    (empty-queue? queue)
	    <JAVASCRIPT>
	      <JAVASCRIPTINLINE>is_empty_queue(</JAVASCRIPTINLINE><META>queue</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>
	  <BR></BR>
          用来测试队列是否为空。
	  <PDF_ONLY>\vspace{6pt}</PDF_ONLY>
      </LI>
      <LI>
        一个选择器：
        <BR></BR>
          <INDEX><USE>front_queue</USE></INDEX> 
          <SPLITINLINE>
	    (front-queue queue)
	    <JAVASCRIPT>
	      <JAVASCRIPTINLINE>front_queue(</JAVASCRIPTINLINE><META>queue</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>
	  <BR></BR>
          返回队列前端的对象，如果队列为空则提示错误；它不修改队列。
	  <PDF_ONLY>\vspace{6pt}</PDF_ONLY>
      </LI>
 <LI>
        两个修改器：
	<BR></BR>
          <SPLITINLINE>
	    (insert-queue! queue item)
	    
	    <JAVASCRIPT>
	      <JAVASCRIPTINLINE>insert_queue(</JAVASCRIPTINLINE><META>queue</META><JAVASCRIPTINLINE>, </JAVASCRIPTINLINE><META>item</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>
	  <BR></BR>
          插入
          <INDEX><USE>insert_queue</USE></INDEX> 
	  在队列的尾部插入项目，并以修改后的队列作为其值返回。<PDF_ONLY>\\[4pt]</PDF_ONLY><WEB_ONLY><BR></BR></WEB_ONLY>
          <SPLITINLINE>
	    (delete-queue! queue)
	    <JAVASCRIPT><JAVASCRIPTINLINE>delete_queue(</JAVASCRIPTINLINE><META>queue</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	    </JAVASCRIPT>
	  </SPLITINLINE>
	  <BR></BR>
          移除
          <INDEX><USE>delete_queue</USE></INDEX> 
	  在队列的头部移除项目，并以修改后的队列作为其值返回，如果队列在删除前为空，则提示错误。
      </LI>
     </UL>
  </TEXT>

   <TEXT>
    因为队列是一个项目序列，我们当然可以将其表示为一个普通的列表；队列的前部将是列表的
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    ，在队列中插入一个项目相当于将一个新元素附加到列表的末尾，而从队列中删除一个项目则相当于获取列表的
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    。然而，这种表示是低效的，因为为了插入一个项目，我们必须扫描列表直到到达末尾。由于我们扫描列表的唯一方法是通过连续的
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    操作，这种扫描对于一个包含
    $n$
    项的列表需要
    $\Theta(n)$
    步骤。对列表表示的一种简单修改可以克服这种缺点，使得队列操作可以实现为只需
    $\Theta(1)$
    步骤；也就是说，所需步骤的数量不依赖于队列的长度。
  </TEXT> 

   <TEXT>
    列表表示法的困难在于需要扫描以找到列表的末尾。我们需要扫描的原因是，虽然将列表表示为序对链的标准方法为我们提供了一个指向列表开头的指针，但它没有提供一个易于访问的指向末尾的指针。避免这一缺点的方法是将队列表示为一个列表，外加一个指示列表最后一对的额外指针。这样，当我们要插入一个项目时，我们可以查看尾部指针，从而避免扫描列表。
  </TEXT> 

   <TEXT>
    因此，队列被表示为一对指针，
    <SPLITINLINE>
      front-ptr
      <JAVASCRIPT><JAVASCRIPTINLINE>front_ptr</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      rear-ptr,
      <JAVASCRIPT><JAVASCRIPTINLINE>rear_ptr</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    ，它们分别指示普通列表中的第一个和最后一个对。由于我们希望队列是一个可识别的对象，我们可以使用
    <SPLITINLINE>
      cons
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    来组合这两个指针。因此，队列本身将是这两个指针的
    <SPLITINLINE>
      cons
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    。
    <SPLITINLINE>
      图<SPACE></SPACE><REF NAME="fig:queue-pointers_scheme"></REF>
      <JAVASCRIPT>图<SPACE></SPACE><REF NAME="fig:queue-pointers"></REF></JAVASCRIPT>
    </SPLITINLINE>
    说明了这种表示法。
    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-19.svg"></FIGURE>
          <CAPTION>
	    实现一个具有前端和尾部指针的列表作为队列。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-19.svg"></FIGURE>
          <CAPTION>
	    实现一个具有前端和尾部指针的列表作为队列。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT> 

   <TEXT>
    为了定义队列操作，我们使用以下
    <SPLITINLINE>
      过程，<JAVASCRIPT>函数，</JAVASCRIPT>
    </SPLITINLINE>
    它们使我们能够选择和修改队列的前端和尾部指针：
    
      <NAME>modify_pointers_example</NAME>
      <JAVASCRIPT>
const q = pair(1, 2);
set_front_ptr(q, 42);	
front_ptr(q);
      </JAVASCRIPT>
    
    
      <INDEX><DECLARATION>front_ptr</DECLARATION></INDEX> 
      <INDEX><DECLARATION>rear_ptr</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_front_ptr</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_rear_ptr</DECLARATION></INDEX> 
      <NAME>modify_pointers</NAME>
      <EXAMPLE>modify_pointers_example</EXAMPLE>
      <EXPECTED>42</EXPECTED>
      
(define (front-ptr queue) (car queue))

(define (rear-ptr queue) (cdr queue))

(define (set-front-ptr! queue item) (set-car! queue item))

(define (set-rear-ptr! queue item) (set-cdr! queue item))
      
      <JAVASCRIPT>
function front_ptr(queue) { return head(queue); }
<SHORT_SPACE></SHORT_SPACE>
function rear_ptr(queue) { return tail(queue); }
<SHORT_SPACE></SHORT_SPACE>
function set_front_ptr(queue, item) { set_head(queue, item); }
<SHORT_SPACE></SHORT_SPACE>
function set_rear_ptr(queue, item) { set_tail(queue, item); }
      </JAVASCRIPT>
    
  </TEXT> 

  <TEXT> 
    现在我们可以实现实际的队列操作。如果队列的前端指针是空列表，我们将认为队列为空。
<SNIPPET HIDE="yes">
      <NAME>is_empty_queue_example</NAME>
      <JAVASCRIPT>
const q = pair(null, 2);
is_empty_queue(q);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>is_empty_queue</DECLARATION></INDEX> 
      <REQUIRES>modify_pointers</REQUIRES>
      <NAME>is_empty_queue</NAME>
      <EXAMPLE>is_empty_queue_example</EXAMPLE>
      <EXPECTED>true</EXPECTED>
      <SCHEME>
(define (empty-queue? queue) (null? (front-ptr queue)))
      </SCHEME>
      <JAVASCRIPT>
function is_empty_queue(queue) { return is_null(front_ptr(queue)); }
      </JAVASCRIPT>
    </SNIPPET> 
    <SPLITINLINE>
      make-queue
      <JAVASCRIPT><JAVASCRIPTINLINE>make_queue</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    构造函数返回一个最初为空的队列，一个其
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    均为空列表的序对：
<SNIPPET HIDE="yes">
      <NAME>make_queue_example</NAME>
      <REQUIRES>modify_pointers</REQUIRES>
      <JAVASCRIPT>
const q = make_queue();
front_ptr(q);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_queue</DECLARATION></INDEX> 
      <NAME>make_queue</NAME>
      <EXAMPLE>make_queue_example</EXAMPLE>
      <EXPECTED>null</EXPECTED>
      <SCHEME>
(define (make-queue) (cons &apos;() &apos;()))
      </SCHEME>
      <JAVASCRIPT>
function make_queue() { return pair(null, null); }
      </JAVASCRIPT>
    </SNIPPET> 
    要选择队列前面的项目，我们返回由前端指针指示的序对的
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    ：
<SNIPPET HIDE="yes">
      <NAME>front_queue_example</NAME>
      <JAVASCRIPT>
const q = pair(pair(1, 2), 3);
front_queue(q);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>front_queue</DECLARATION></INDEX> 
      <NAME>front_queue</NAME>
      <REQUIRES>is_empty_queue</REQUIRES>
      <EXAMPLE>front_queue_example</EXAMPLE>
      <EXPECTED>1</EXPECTED>
      <SCHEME>
(define (front-queue queue)
  (if (empty-queue? queue)
      (error &quot;FRONT called with an empty queue&quot; queue)
      (car (front-ptr queue))))
      </SCHEME>
      <JAVASCRIPT>
function front_queue(queue) {
    return is_empty_queue(queue)
           ? error(queue, &quot;front_queue called with an empty queue&quot;)
           : head(front_ptr(queue));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT> 
    要在队列中插入一个项目，我们遵循在
    <SPLITINLINE>
      图<SPACE></SPACE><REF NAME="fig:queue-insert"></REF>中指示的方法。
      <JAVASCRIPT>图<SPACE></SPACE><REF NAME="fig:queue-insert"></REF>中指示的方法。</JAVASCRIPT>
    </SPLITINLINE>
    我们首先创建一个新序对，其
    <SPLITINLINE>
      car
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    是要插入的项，其
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    是空列表。如果队列最初为空，我们将队列的前端和尾部指针设置为这个新序对。否则，我们将队列中的最后一个序对修改为指向新序对，并且也将尾部指针设置为新序对。
    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-20.svg"></FIGURE>
          <CAPTION>
	    使用(insert-queue! q &apos;d)在图<SPACE></SPACE><REF NAME="fig:queue-pointers_scheme"></REF>的队列上的结果。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-20.svg"></FIGURE>
          <CAPTION>
	    使用
	    <JAVASCRIPTINLINE>insert_queue(q, &quot;d&quot;)</JAVASCRIPTINLINE>在图<SPACE></SPACE><REF NAME="fig:queue-pointers"></REF>的队列上的结果。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET HIDE="yes" PAGE="265">
      <NAME>print_queue_example</NAME>
      <REQUIRES>make_queue</REQUIRES>
      <REQUIRES>insert_queue</REQUIRES>
      <REQUIRES>delete_queue</REQUIRES>
      <SCHEME>
      </SCHEME>
      <JAVASCRIPT>
const q1 = make_queue();
insert_queue(q1, &quot;a&quot;);    
insert_queue(q1, &quot;b&quot;);    
delete_queue(q1);
delete_queue(q1);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>insert_queue</DECLARATION></INDEX> 
      <NAME>insert_queue</NAME>
      <REQUIRES>modify_pointers</REQUIRES>
      <REQUIRES>is_empty_queue</REQUIRES>
      <EXAMPLE>print_queue_example</EXAMPLE>
      <EXPECTED>[ null, [ &apos;b&apos;, null ] ]</EXPECTED>
      <SCHEME>
(define (insert-queue! queue item)
  (let ((new-pair (cons item &apos;())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))
      </SCHEME>
      <JAVASCRIPT>
function insert_queue(queue, item) {
    const new_pair = pair(item, null);
    if (is_empty_queue(queue)) {
        set_front_ptr(queue, new_pair);
        set_rear_ptr(queue, new_pair);
    } else {
        set_tail(rear_ptr(queue), new_pair);
        set_rear_ptr(queue, new_pair);
    }
    return queue;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT> 
    要删除队列前面的项目，我们只需修改前端指针，使其现在指向队列中的第二个项目，可以通过跟随第一个项目的
    <SPLITINLINE>
      cdr
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    指针来找到（见
    <SPLITINLINE>图<SPACE></SPACE><REF NAME="fig:queue-delete_scheme"></REF><JAVASCRIPT>图<SPACE></SPACE><REF NAME="fig:queue-delete"></REF></JAVASCRIPT></SPLITINLINE>):<FOOTNOTE>如果第一个项目是队列中的最后一个项目，删除后前端指针将为空列表，这将标记队列为空；我们不需要担心更新尾部指针，它仍将指向被删除的项目，因为
    <SPLITINLINE>
      
	empty-queue?
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>is_empty_queue</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    只查看前端指针。</FOOTNOTE>
    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-21.svg"></FIGURE>
          <CAPTION>
	    在图<SPACE></SPACE><REF NAME="fig:queue-insert_scheme"></REF>的队列上使用(delete-queue! q)的结果。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.8" SRC="img_javascript/ch3-Z-G-21.svg"></FIGURE>
          <CAPTION>
	    在图<SPACE></SPACE><REF NAME="fig:queue-insert"></REF>的队列上使用<JAVASCRIPTINLINE>delete_queue(q)</JAVASCRIPTINLINE>的结果。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET EVAL="yes" POSTPADDING="no">
      <INDEX><DECLARATION>delete_queue</DECLARATION></INDEX> 
      <NAME>delete_queue</NAME>
      <REQUIRES>is_empty_queue</REQUIRES>
      <REQUIRES>modify_pointers</REQUIRES>
      <EXAMPLE>print_queue_example</EXAMPLE>
      <EXPECTED>[ null, [ &apos;b&apos;, null ] ]</EXPECTED>
      <SCHEME>
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error &quot;DELETE! called with an empty queue&quot; queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue)))
      </SCHEME>
      <JAVASCRIPT>
function delete_queue(queue) {
    if (is_empty_queue(queue)) {
        error(queue, &quot;delete_queue called with an empty queue&quot;);
    } else {
        set_front_ptr(queue, tail(front_ptr(queue)));
        return queue;
    }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <EXERCISE> 
    Ben Bitdiddle 决定测试上面描述的队列实现。他在
    <SPLITINLINE>
      Lisp
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    解释器中输入这些
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，并继续尝试它们：
<SNIPPET EVAL="yes">
      <NAME>make_queue_example1</NAME>
      <REQUIRES>make_queue</REQUIRES>
      <SCHEME>
(define q1 (make-queue))
      </SCHEME>
      <JAVASCRIPT>
const q1 = make_queue();
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>insert_queue_example1</NAME>
      <REQUIRES>insert_queue</REQUIRES>
      <REQUIRES>make_queue_example1</REQUIRES>
      <SCHEME>
(insert-queue! q1 &apos;a)
      </SCHEME>
      <JAVASCRIPT>
insert_queue(q1, &quot;a&quot;);
      </JAVASCRIPT>
      <SCHEMEOUTPUT>
            ((a) a)
      </SCHEMEOUTPUT>
      <JAVASCRIPT_OUTPUT>
[[&quot;a&quot;, null], [&quot;a&quot;, null]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>insert_queue_example2</NAME>
      <REQUIRES>insert_queue_example1</REQUIRES>
      <SCHEME>
(insert-queue! q1 &apos;b)
      </SCHEME>
      <JAVASCRIPT>
insert_queue(q1, &quot;b&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[[&quot;a&quot;, [&quot;b&quot;, null]], [&quot;b&quot;, null]]
      </JAVASCRIPT_OUTPUT>
      <SCHEMEOUTPUT>
            ((a b) b)
      </SCHEMEOUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>insert_queue_example2</REQUIRES>
      <REQUIRES>delete_queue</REQUIRES>
      <NAME>delete_queue_example1</NAME>
      <SCHEME>
(delete-queue! q1)
      </SCHEME>
      <JAVASCRIPT>
delete_queue(q1);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[[&quot;b&quot;, null], [&quot;b&quot;, null]]
      </JAVASCRIPT_OUTPUT>
      <SCHEMEOUTPUT>
            ((b) b)
      </SCHEMEOUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>delete_queue_example2</NAME>
      <REQUIRES>delete_queue_example1</REQUIRES>
      <SCHEME>
(delete-queue! q1)
      </SCHEME>
      <JAVASCRIPT>
delete_queue(q1);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
[null, [&quot;b&quot;, null]]
      </JAVASCRIPT_OUTPUT>
      <SCHEMEOUTPUT>
            (() b)
      </SCHEMEOUTPUT>
    </SNIPPET>
     <QUOTE>这全错了！</QUOTE> 他抱怨道。 <QUOTE>解释器的响应显示最后一个项目被插入了两次。当我删除两个项目后，第二个 b 仍然在那，所以即使它应该是空的，队列并没有空。</QUOTE> Eva Lu Ator 建议 Ben 误解了正在发生的事情。 <QUOTE>并不是说项目被插入队列两次，</QUOTE> 她解释道。 <QUOTE>只是标准的 <SPLITINLINE> Lisp <JAVASCRIPT>JavaScript</JAVASCRIPT> </SPLITINLINE> 打印程序不知道如何识别队列的表示。如果你想要正确打印队列，你需要为队列定义自己的打印 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 。</QUOTE> 解释 Eva Lu 所讨论的内容。具体地，展示为什么 Ben 的例子产生了他们所做的打印结果。定义一个 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> <INDEX><USE>print_queue</USE></INDEX> <SPLITINLINE> print-queue <JAVASCRIPT><JAVASCRIPTINLINE>print_queue</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> ，它以队列为输入并打印队列中的项目序列。
<LABEL NAME="ex:3_21"></LABEL>
     <SOLUTION>
      
	<REQUIRES>make_queue</REQUIRES>
	<REQUIRES>modify_pointers</REQUIRES>
	<REQUIRES>insert_queue</REQUIRES>
	<REQUIRES>is_empty_queue</REQUIRES>
	<REQUIRES>delete_queue</REQUIRES>
	<EXAMPLE>ex_3_21_solution_example</EXAMPLE>
	<JAVASCRIPT>
function print_queue(q) {
    return display(head(q));
}
	</JAVASCRIPT>
      
      
	<NAME>ex_3_21_solution_example</NAME>
	<JAVASCRIPT>
const q1 = make_queue();
print_queue(q1); // prints: null
insert_queue(q1, &quot;a&quot;);
print_queue(q1); // prints: [&quot;a&quot;, null]
insert_queue(q1, &quot;b&quot;);
print_queue(q1); // prints: [&quot;a&quot;, [&quot;b&quot;, null]]
delete_queue(q1);
print_queue(q1); // prints: [&quot;b&quot;, null]
	</JAVASCRIPT>
      
    </SOLUTION>
   </EXERCISE>

  <EXERCISE> 
    我们可以将队列构建为具有局部状态的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>队列<SUBINDEX>函数式实现</SUBINDEX></INDEX>
    ，而不是表示为一对指针。局部状态将由指向普通列表开头和结尾的指针组成。因此，
    <SPLITINLINE>
      make-queue
      <JAVASCRIPT><JAVASCRIPTINLINE>make_queue</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    将具有以下形式
<SNIPPET LATEX="yes">
      <SCHEME>
(define (make-queue)
  (let ((front-ptr $\ldots$ )
        (rear-ptr $\ldots$ ))
    definitions of internal procedures
    (define (dispatch m) $\ldots$)
    dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_queue() {
    let front_ptr = $\ldots$;
    let rear_ptr = $\ldots$;
    <METAPHRASE>declarations of internal functions</METAPHRASE>
    function dispatch(m) {$\ldots$}
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET> 
    完成
    <SPLITINLINE>
      make-queue
      <JAVASCRIPT><JAVASCRIPTINLINE>make_queue</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    的定义并使用这种表示提供队列操作的实现。
<LABEL NAME="ex:3_22"></LABEL>
     <SOLUTION>
      
	<EXAMPLE>ex_3_22_example</EXAMPLE>
	<JAVASCRIPT>
// 由GitHub用户devinryu提供	  
	  
function make_queue() {
    let front_ptr = null;
    let rear_ptr = null;
    function is_empty_queue() {
        return is_null(front_ptr);
    }
    function insert_queue(item) {
        let new_pair = pair(item, null);
        if (is_empty_queue()) {
            front_ptr = new_pair;
            rear_ptr = new_pair;
        } else {
            set_tail(rear_ptr, new_pair);
            rear_ptr = new_pair;
        }
    }
    function delete_queue() {
        if (is_empty_queue()) {
            error(&quot;FRONT called with an empty queue&quot;);
        } else {
            front_ptr = tail(front_ptr);
        }
    }
    function print_queue() {
        display(front_ptr);
    }
    function dispatch(m) {
        return m === &quot;insert_queue&quot;
        ? insert_queue
        : m === &quot;delete_queue&quot;
        ? delete_queue
        : m === &quot;is_empty_queue&quot;
        ? is_empty_queue
        : m === &quot;print_queue&quot;
        ? print_queue
        : error(m, &quot;Unknow operation -- DISPATCH&quot;);
    }
    return dispatch;
}
function insert_queue(queue, item) {
    return queue(&quot;insert_queue&quot;)(item);
}
function delete_queue(queue) {
    return queue(&quot;delete_queue&quot;)();
}
function print_queue(queue) {
    return queue(&quot;print_queue&quot;)();
}
	</JAVASCRIPT>
      
      
	<NAME>ex_3_22_example</NAME>
	<JAVASCRIPT>
const q = make_queue();
print_queue(q); // prints: null
insert_queue(q, &quot;a&quot;);
print_queue(q); // prints: [&quot;a&quot;, null]
insert_queue(q, &quot;b&quot;);
print_queue(q); // prints: [&quot;a&quot;, [&quot;b&quot;, null]]
delete_queue(q);
print_queue(q); // prints: [&quot;b&quot;, null]
	</JAVASCRIPT>
      
    </SOLUTION>
   </EXERCISE>

  <EXERCISE> 
    <EM>双端队列</EM>
    <INDEX>队列<SUBINDEX>双端</SUBINDEX></INDEX>
    <INDEX>双端队列</INDEX>
    (<QUOTE>double-ended queue</QUOTE>) 是一个序列，其中项目可以在
    <SPLITINLINE>
      前端或 
      <JAVASCRIPT>前端或 </JAVASCRIPT>
    </SPLITINLINE>
    尾部插入和删除。
    双端队列的操作有构造函数
    <SPLITINLINE>
      make-deque,
      <JAVASCRIPT><JAVASCRIPTINLINE>make_deque</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    谓词
    <SPLITINLINE>
      empty-deque,
      <JAVASCRIPT><JAVASCRIPTINLINE>is_empty_deque</JAVASCRIPTINLINE>,
    </JAVASCRIPT></SPLITINLINE>
    选择器
    <SPLITINLINE>
      front-deque
      <JAVASCRIPT><JAVASCRIPTINLINE>front_deque</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      rear-deque,
      <JAVASCRIPT><JAVASCRIPTINLINE>rear_deque</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    以及修改器
    <SPLITINLINE>
      front-insert-deque!,
      <JAVASCRIPT><JAVASCRIPTINLINE>front_insert_deque</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      front-delete-deque!,
      <JAVASCRIPT><JAVASCRIPTINLINE>front_delete_deque</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      rear-insert-deque!,
      <JAVASCRIPT><JAVASCRIPTINLINE>rear_insert_deque</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    和
  <SPLITINLINE>
      rear-delete-deque。
      <JAVASCRIPT><JAVASCRIPTINLINE>rear_delete_deque</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLITINLINE>
    展示如何使用序对来表示双端队列，并给出这些操作的实现。<FOOTNOTE>注意不要让解释器尝试打印一个包含循环的结构。（见 练习<SPACE></SPACE><REF NAME="ex:make-cycle"></REF>。）</FOOTNOTE>
    所有操作都应该在
     <LATEXINLINE>$\Theta(1)$</LATEXINLINE>  步骤内完成。
     <LABEL NAME="ex:deque"></LABEL>
    <SOLUTION>
      <SNIPPET>
	<JAVASCRIPT>
// solution provided by GitHub user clean99
function make_deque() {
    return pair(null, null);
}

function front_ptr(deque) {
    return head(deque);
}

function rear_ptr(deque) {
    return tail(deque);
}

function set_front_ptr(deque, item) {
    set_head(deque, item);
}

function set_rear_ptr(deque, item) {
    set_tail(deque, item);
}

function is_empty_deque(deque) {
    return is_null(front_ptr(deque))
           ? true
  	   : is_null(rear_ptr(deque))
  	   ? true
  	   : false;
}

function is_one_item_deque(deque) {
    return front_ptr(deque) === rear_ptr(deque);
}

function front_insert_deque(deque, item) {
    // use another pair to store a forward pointer
    const new_pair = pair(pair(item, null), null);
    if (is_empty_deque(deque)) {
        set_front_ptr(deque, new_pair);
        set_rear_ptr(deque, new_pair);
    } else {
        set_tail(new_pair, front_ptr(deque));
        // set forward pointer to new_pair
        set_tail(head(front_ptr(deque)), new_pair);
        set_front_ptr(deque, new_pair);
    }
}

function front_delete_deque(deque) {
    if (is_empty_deque(deque)) {
        error(deque, &quot;front_delete_deque called with an empty deque&quot;);
    } else if(is_one_item_deque(deque)) {
        set_front_ptr(deque, null);
        set_rear_ptr(deque, null);
        return deque;
    } else {
        set_front_ptr(deque, tail(front_ptr(deque)));
        return deque;
    }
}

function rear_insert_deque(deque, item) {
    if (is_empty_deque(deque)) {
        const new_pair = pair(pair(item, null), null);
        set_front_ptr(deque, new_pair);
        set_rear_ptr(deque, new_pair);
    } else {
        // set new_pair forward pointer to last item
        const new_pair = pair(pair(item, rear_ptr(deque)), null);
        set_tail(rear_ptr(deque), new_pair);
        set_rear_ptr(deque, new_pair);
    }
}

function rear_delete_deque(deque) {
    if (is_empty_deque(deque)) {
        error(deque, &quot;rear_delete_deque called with an empty deque&quot;);
    } else if(is_one_item_deque(deque)) {
        set_front_ptr(deque, null);
        set_rear_ptr(deque, null);
        return deque;
    } else {
        // update rear_ptr to last item&apos;s forward pointer
        set_rear_ptr(deque, tail(head(rear_ptr(deque))));
        return deque;
    }
}
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>
   <INDEX>队列<CLOSE></CLOSE></INDEX> 
</SUBSECTION>
