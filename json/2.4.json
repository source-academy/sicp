[{"id":"/sicpjs/2.4","tag":"TITLE","body":"2.4  Multiple Representations for Abstract Data"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    We have introduced data abstraction, a methodology for structuring systems\n    in such a way that much of a program can be specified independent of the\n    choices involved in implementing the data objects that the program\n    manipulates.  For example, we saw in\n    section ","tag":"#text"},{"tag":"REF","body":"2.1.1","href":"/sicpjs/2.1.1"},{"body":" how to separate the task of\n    designing a program that uses rational numbers from the task of implementing\n    rational numbers in terms of the computer language's primitive\n    mechanisms for constructing compound data.  The key idea was to erect an\n    \n    abstraction barrier—in this case, the selectors and constructors for\n    rational numbers\n    (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_rat"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"numer"},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"denom"},{"body":")—that isolates the way rational\n    numbers are used from their underlying representation in terms of list\n    structure.  A similar abstraction barrier isolates the details of the\n    functions\n    that perform rational arithmetic\n    (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_rat"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sub_rat"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_rat"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_rat"},{"body":")\n    from the \"","tag":"#text"},{"body":"higher-level","tag":"#text"},{"body":"\"functions\n    that use rational numbers.  The resulting program has the structure shown\n    in figure ","tag":"#text"},{"tag":"REF","body":"2.1","href":"/sicpjs/2.1.2#fig-2.1"},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    These data-abstraction barriers are powerful tools for controlling\n    complexity.  By isolating the underlying representations of data\n    objects, we can divide the task of designing a large program into\n    smaller tasks that can be performed separately.  But this kind of data\n    abstraction is not yet powerful enough, because it may not always make\n    sense to speak of \"","tag":"#text"},{"body":"the underlying representation","tag":"#text"},{"body":"\" for a\n    data object.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    For one thing, there might be more than one useful representation for\n    a data object, and we might like to design systems that can deal with\n    multiple representations.  To take a simple example, complex numbers\n    may be represented in two almost equivalent ways: in rectangular form\n    (real and imaginary parts) and in polar form (magnitude and angle).\n    Sometimes rectangular form is more appropriate and sometimes polar\n    form is more appropriate.  Indeed, it is perfectly plausible to\n    imagine a system in which complex numbers are represented in both\n    ways, and in which the\n    functions\n    for manipulating complex numbers work with either representation.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    More importantly, programming systems are often designed by many\n    people working over extended periods of time, subject to requirements\n    that change over time.  In such an environment, it is simply not\n    possible for everyone to agree in advance on choices of data\n    representation.  So in addition to the data-abstraction barriers that\n    isolate representation from use, we need abstraction barriers that\n    isolate different design choices from each other and permit different\n    choices to coexist in a single program.  Furthermore, since large\n    programs are often created by combining\n    preexisting\n    modules that were\n    designed in isolation, we need conventions that permit programmers to\n    incorporate modules into larger systems \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"additively","tag":"#text"}]},{"body":", that is,\n    without having to redesign or reimplement these modules.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    In this section, we will learn how to cope with data that may be\n    represented in different ways by different parts of a program.  This\n    requires constructing \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"generic functions","tag":"#text"}]},{"body":"—functions\n    that can operate on data that may be represented in more than one way.  Our\n    main technique for building generic\n    functions\n    will be to work in terms of data objects that have \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"type tags","tag":"#text"}]},{"body":", that is, data objects that include explicit information\n    about how they are to be processed. We will also discuss \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"data-directed","tag":"#text"}]},{"body":" programming, a powerful and convenient\n    implementation strategy for additively assembling systems with generic\n    operations.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    We begin with the simple complex-number example. We will see how\n    type tags and data-directed style enable us to design separate\n    rectangular and polar representations for complex numbers while\n    maintaining the notion of an abstract\n    \"","tag":"#text"},{"body":"complex-number","tag":"#text"},{"body":"\"\n    data object.\n    We will accomplish this by defining arithmetic\n    functions\n    for complex numbers\n    (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_complex"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sub_complex"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_complex"},{"body":",\n      \n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_complex"},{"body":")\n      \n    in terms of generic selectors that access parts of a complex number\n    independent of how the number is represented.  The resulting complex-number\n    system, as shown in\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"2.19","href":"/sicpjs/2.4#fig-2.19"},{"body":",\n      \n    contains two different kinds of\n    \n    abstraction barriers.  The \"","tag":"#text"},{"body":"horizontal","tag":"#text"},{"body":"\" abstraction barriers\n    play the same role as the ones in\n    figure ","tag":"#text"},{"tag":"REF","body":"2.1","href":"/sicpjs/2.1.2#fig-2.1"},{"body":".  They isolate\n    \"","tag":"#text"},{"body":"higher-level","tag":"#text"},{"body":"\" operations from \"","tag":"#text"},{"body":"lower-level","tag":"#text"},{"body":"\"\n    representations.  In addition, there is a \"","tag":"#text"},{"body":"vertical","tag":"#text"},{"body":"\" barrier\n    that gives us the ability to separately design and install alternative\n    representations.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"60%","src":"img_javascript/ch2-Z-G-54.svg","id":"#fig-2.19","captionHref":"/sicpjs/2.4#fig-2.19","captionName":"Figure 2.19 ","captionBody":[{"body":"\n\t    Data-abstraction barriers in the\n\t    complex-number system.\n\t  ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"2.5","href":"/sicpjs/2.5"},{"body":" we will show how to\n    use type tags and data-directed style to develop a generic arithmetic\n    package.  This provides\n    functions\n    (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul"},{"body":", and so\n    on) that can be used to manipulate all sorts of \"","tag":"#text"},{"body":"numbers","tag":"#text"},{"body":"\" and\n    can be easily extended when a new kind of number is needed. In\n    section ","tag":"#text"},{"tag":"REF","body":"2.5.3","href":"/sicpjs/2.5.3"},{"body":", we'll show how to\n    use generic arithmetic in a system that performs symbolic algebra.\n  ","tag":"#text"}]}]