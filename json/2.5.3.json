[{"id":"/sicpjs/2.5.3","tag":"TITLE","body":"2.5.3  \n    Example: Symbolic Algebra"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    The manipulation of symbolic algebraic expressions is a complex\n    process that illustrates many of the hardest problems that occur in\n    the design of large-scale systems.  An\n    \n    algebraic expression, in\n    general, can be viewed as a hierarchical structure, a tree of\n    operators applied to operands.  We can construct algebraic expressions\n    by starting with a set of primitive objects, such as constants and\n    variables, and combining these by means of algebraic operators, such\n    as addition and multiplication.  As in other languages, we form\n    abstractions that enable us to refer to compound objects in simple\n    terms.  Typical abstractions in symbolic algebra are ideas such as\n    linear combination, polynomial, rational function, or trigonometric\n    function.  We can regard these as compound \"","tag":"#text"},{"body":"types,","tag":"#text"},{"body":"\" which are\n    often useful for directing the processing of expressions.  For example, we\n    could describe the expression\n\n    ","tag":"#text"},{"body":"\n      \\[ x^{2}\\, \\sin (y^2+1)+x\\, \\cos 2y+\\cos (y^3 -2y^2) \\]\n    ","tag":"LATEX"},{"body":"\n    as a polynomial in ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" with coefficients that\n    are trigonometric functions of polynomials in\n    ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" whose coefficients are integers.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    We will not attempt to develop a complete algebraic-manipulation\n    system here.  Such systems are exceedingly complex programs, embodying\n    deep algebraic knowledge and elegant algorithms.  What we will do is\n    look at a simple but important part of algebraic manipulation: the\n    arithmetic of polynomials.  We will illustrate the kinds of decisions\n    the designer of such a system faces, and how to apply the ideas of\n    abstract data and generic operations to help organize this effort.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Arithmetic on polynomials","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    Our first task in designing a system for performing arithmetic on\n    polynomials is to decide just what a polynomial is.  Polynomials are\n    normally defined relative to certain variables (the \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"indeterminates","tag":"#text"}]},{"body":" of the polynomial).  For simplicity, we will\n      restrict ourselves to polynomials having just one indeterminate \n      ","tag":"#text"},{"tag":"EM","child":[{"body":"(univariate polynomials","tag":"#text"}]},{"body":").","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/2.5.3#footnote-1"},{"body":" We will define a polynomial to\n      be a sum of terms, each of which is either a coefficient, a power of the\n      indeterminate, or a product of a coefficient and a power of the\n      indeterminate.  A coefficient is defined as an algebraic expression\n      that is not dependent upon the indeterminate of the polynomial.  For\n      example,\n      ","tag":"#text"},{"body":"\n        \\[ 5x^2 +3x +7 \\]\n      ","tag":"LATEX"},{"body":"\n      is a simple polynomial in ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":", and\n      ","tag":"#text"},{"body":"\n        \\[ (y^2 +1)x^3 +(2y)x+1 \\]\n      ","tag":"LATEX"},{"body":"\n      is a polynomial in ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" whose coefficients are\n      polynomials in ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Already we are skirting some thorny issues.  Is the first of these\n    polynomials the same as the polynomial\n    ","tag":"#text"},{"body":"$5y^2 +3y +7$","tag":"LATEX"},{"body":", or not?  A reasonable answer\n    might be \"","tag":"#text"},{"body":"yes, if we are considering a polynomial purely as a\n    mathematical function, but no, if we are considering a polynomial to be a\n    syntactic form.","tag":"#text"},{"body":"\"  The second polynomial is algebraically equivalent\n    to a polynomial in ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" whose coefficients are\n    polynomials in ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":".  Should our system recognize\n    this, or not? Furthermore, there are other ways to represent a\n    polynomial—for example, as a product of factors, or (for a\n    univariate polynomial) as the set of roots, or as a listing of the values\n    of the polynomial at a specified set of points.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/2.5.3#footnote-2"},{"body":"\n    We can finesse these questions by deciding that in our\n    algebraic-manipulation system a \"","tag":"#text"},{"body":"polynomial","tag":"#text"},{"body":"\" will be a\n    particular syntactic form, not its underlying mathematical meaning.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Now we must consider how to go about doing arithmetic on polynomials.\n    In this simple system, we will consider only addition and\n    multiplication.  Moreover, we will insist that two polynomials to be\n    combined must have the same indeterminate.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    We will approach the design of our system by following the familiar\n    discipline of data abstraction.  We will represent polynomials using a\n    data structure called a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"poly","tag":"#text"}]},{"body":", which consists of a variable and a\n    \n    collection of terms.  We assume that we have selectors\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"variable"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"term_list"},{"body":"\n    that extract those parts from a poly and a constructor\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_poly"},{"body":"\n    that assembles a poly from a given variable and a term list.\n    A variable will be just a\n    \n\tstring,\n      \n    so we can use the \n     ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_same_variable"},{"body":"function\n    of section ","tag":"#text"},{"tag":"REF","body":"2.3.2","href":"/sicpjs/2.3.2"},{"body":" to compare\n    variables.\n    The following\n    functions\n    define\n    \n    addition and multiplication of polys:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":261,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0GYBQuRRIA7CAewFcAnAYwFMAaUAWzIGcAXUAMwuJo4BLMsTagAFgEMAbnVCSeggB50AJqGIVmAIzpVQZbvKoBzLXWIc2aAmAAUAFXFze-ISNAAbQZ1A-QHM4GxJ4AnqB0SvQADu7ETBxkAeL+bEncklRoAJS2oE4ufALCpJLR0WEA+oLElXyqemE1JpUAVjKSbDRUgrHynp5kAO5iFGKJeWUV4ZLE4SaCsqSuxR6uAUmSAxGedMwWVgZGgXKZZvuWoHnevmdsTJ1+x87hQ3pybHTRmZIcp6bmSxsXArOLycphOyuB6mNjZUAAb1woBRoCodA41FKENC1Vq9UaoWabQ6XR6sShfBhJjhAG5cABffCgkrg6aVEwWPSCGh2MjRalwxHI1E0ES+DihaJ0SocSQ00AAXhYZTskulsvlguy9NRoDFoi462VnI4fIFASlMrlNJ1IpR6MxVFIAEI-Gw6sQGtwampKcRcnqgyiAPxsqo1T0NKhNYgtdrSTrdXpm6Eq6J2A1-IHawPBvUALgiVCoZCodhuZv5CStmttDHt+aboAARMQkvtAmR1Nwy8k6J9LdKxABaEfh3Gc4jcmgtu1MkFFMGSVSqOxKJiheEItEYrETjlcnq8lsr1QtpiV9eb7I60ALlkeNgUbTX0BbxG7p3Y9lTmd2Ftn20C8vB8M0N3fW9aXvZkl1ZZgKE8N8Px3R19ymKo-2PACEM8ECrwgrc7wfOCPFURZkO3L90JxQ9p2wltyOkfCwMo4j8EIfk9F+EpNW0XYmGiCguFmdRTTybhS2YfUpFiPRQGwUA7E+VZSGwHAcFyRc3FZTo0l5ABrOhQiYdExSoVQhSRPU0Odd1Kk0AY7DMstLLzZswwJH1p1URt8yLOgAEcKC2OwjJMiQ6BXOxnGilyLLhW8-ODMNYrXeK3OSoMiz0shDOMhJJEEJCMsS+kSJ0jxmEkIy+N2Oxt0bA1fEGGgtjquRlSvFsACo5X4ugernXVUUfUhBjIAyKAzcLKgARiYWaUEaptmq4ID+t2JV5DYfSwuM+bCuKis8vaza6CgrKniUnwozoby-Q2yQBtvYVm1RWzSC831VBG4MGR2QdrPe-VxS4DLtty-LcRQI6kKel67RB6i7Nu76fOcuhzNUdzkb1TyvXun6rpBos5WOjKkfzJk9Rp0bSNIGpPioM1ZoW0AlqYRNPAoC63vzNbQARrblSh-bcXZ8mkNas7nt2S6m0EIw7DRwmHrXYWLpWkHPg4TVjplzwOobPGm2+QRyyvNnBKK8tOdAbnedvE3TZBqWTrao3ztvKn-sBuRgfewWIdF3a8vFypYYCIr4Zfb3febJWbo9dG-Up7XTd1-XY+0c6Xdds3bbsc27YOqPHYuuHlLjuWtYTpsAboTwgZJ-Ms-djKua2J2-ubOn-sbfueAZ0ByLYb4OBocQ7GYDOg0+lglUVZUWwmqbohbVugzDNfpq3wtF+Xlemb0DhN9dsMT5Z-fUQCksyxnpgWz4Az2yGUguKoHiPDHaOBuGwejYF5jwnlPcq+BBaf2-rUc621qq1XOg1ekgtTTbSgXEDqAFd4bztILISXBlToN4oglsV8z52m0qpeQHA5RTzrGqWsNomBZgOFZIBe47IlwYRqJhoNLCsPnJQsE6prTyjsKoX4Wg54L1ulwiRmJZ5b1SlFNc8ipFbzvqWcsajmBP20CuaOJhOTqB0aAX+Ii6wAKZGNPh2YrDiMkbPfmDoOGMw9HIxxuN8xhndjorxwZNEPx0XogxNpjGj0cWY8cLCgRWNgpVRmhothGwTEmcketNA6D0JUb4NADLyjoA1Zxw8EmGPXHPGyrjqG0PEPQlsqSyQpgcloXQVAQJKATkPfBAEzwsU4ABBpyZYjNKyW0p+gz0kjNaXOJgV1KJKgAHxlKUKAAA1JBBO3TAIvj6WaeppIhkZJaXoEC+zEyNOGZk6Z2RZlNnmYqJZNp1xmI2b3LZuFdkDIOZMq5JzxnfKab8tpNyrh3MIvCB5yzQA9VeY2LZTFPlnLSYC45YzWwTJRaMmZoL8z3MeWIlZYAiJvOEjhGqdBTkYsuaikCV0VmQqeR0hOC9GIiApeA3ATM5QDBJOcw5Uzsm5PyZyJB8SqHwJlFSo5oy7ABmKQvU0ZKjKUoBdSrF2RZWCKEayW6iYei13KZ+GRHpOA9DjOU6CFUqG3TYJIfYlQ9WCANdIdm0hlryqqbqzITqBp2BdfCAAZAG+yjrnXuqDQ7OaS9lRuo5TYrlyTeXIrVa06oHogohS9mQSoAAvPQZAimB1AFs26GazrZrzaWRFUqBXAtufmelSz6XL1AAABmZVU1l04WzgITTymtQK02VDLVm3N+bRXao8KW4K5ax2lkNUWheGFJxHh5ABadmbZQVvzZ8plcaR59qNtEMgYR2zMCdUeyQeSCmFvwHqQgNQ-jOi2CU1SwJGyEHRNEdEnxLDQKOMWk9oRGw2IlTkoDfrvW1wSHoZglRKwVI+lUrhoaBowaoHBhDvch42NQ-VaIVEF5pWLuxPUNin2YdYgRo1VT3YEctXe1En6vg-oOP+wwARYNiFEpxjDoFODAjIyPFcrQyCRgo2qWD6HKOcEQy4789kR1brnQWsU91uCSYw0lC+vGZMcBviiIsXCKPSfg2BTpTUwb9mHcwWIuIKOVm2o5TwvcbE+ioJwWUsHNN6bkyjUgxGKNmdk9hkDI8f16wo2wHzwWOB+YXu7ILWHAFCdKaW2zkovMYavEl8zxTKkKdus5mLyXaZhdKWBiTrk9DMLIOp+LVSrzVaoLV+roXUtUOaz5hrCnAuwYsx1sEanuAaYoz1-cgWY7dYs+VqhZ5wOQmiOzaI7qi0Ff3Dau1Mo8OFJ28XOaIK9sre06bMMYHj2QiOwd-OBcmzzaiyVqj12DO3eDLl-px2Tt40CZbJ7gllo3de62C7oQxDti4DUIWW2HaZCifIVcC3QgALK7N5cCOHsABl2YY9W1dJOKt00Zfs7Bq8WPXprfnlUnHvdaY4uDE3Qc+P0t2ay8wUny0-Pyf3FjmnqIAZXQZwHfegsOBRuVO5zzEmye8+DCLlA20JeRe8zj+u+YF5ddF-CJZGvlovfxvD0T4nvOi4eOjrjmNJfm7J0wFX-jvsGAsnoNUB3QAAB4HfRjVLroHYYRNiZgcbqO92rfswi6z6Ltu7fIxyqoQ3AeMMz3Jazvkjvyya-rUDzPKIzyZjqyN53Ny9dZ6Dnn0bHPC-F5BsHjD0Ww+Y+e5XzPderfl5lzBMrepUfwUQoj-b-3xuoxNVth1UHfVXcO6P-DHOXtnaTyDyD+rfVLYr43lEuFw+PY+w31fbtYOxeLuXl7P2Kx-eLQDovwYWwg7B2QCHpBbX7Bh-oX+6+QfI754xlEoGe-15t7jpsxqNmLODmrEZOM+1mewwBJOYER+8OqgG+6+QW2guIiaD2F+QOiuye1uoAKugOxeiB5uzeNedg2Btu7W9MFWP+e+yBlQqB5uJuOBfmTOhOUB2WoB5O+8CWzgQBmWIBnAbejczcQuyMcuCuFsluCeGOquwYS6se-uye6BeolW3mGuLu6yOuK+O+QYuEue6mBerW+eHA5eeBt2BBGGlQNBdBxBDBRBzAEePsAhgCAAkE4fmB+mAI+noBkPQBsLuL4BxicELKDn8MwF3h4E8tRhTlznZL8DUnUiDmeheiBPRilqiFsr0peKxFfkBokVsKcgkWQOenkZoUGH3mfhCviiYHYPNvPktv3grGkaSi2B8pkf0tkaeoUUkU-AUUUXhCUXqGUcdosmUq-hBnUeUQ0SiO8uSvkTkZ0XkSYUpDttJkKA8vvE8udhBssbpolB2gpl2uyoyJykkjyj0RejklesKoUhQqBnPnMb0Qvj6gJDsdIlUoqs0TMd0fcUkRqtsVFlqngmLiqLVGcaFC2EoBeE4S9leMoQnlHGBgOqinYAACzOyKGwnMB2DswImqrSqtJ2DYBomZ4Yl2CtpMA4l8o-JIkADsPsuCVmK2cCdxHRDx4JkJ0JrEJJ8JSeiJMqGARJQOJJ2JPJuJtadgHOixyMJJZJwJkqopQKWJ7aDh+AOh4xx29IuAQAA","body":"function add_poly(p1, p2) {\n    return is_same_variable(variable(p1), variable(p2))\n           ? make_poly(variable(p1),\n                       add_terms(term_list(p1), term_list(p2)))\n           : error(list(p1, p2), \"polys not in same var -- add_poly\");\n}\nfunction mul_poly(p1, p2) {\n    return is_same_variable(variable(p1), variable(p2))\n           ? make_poly(variable(p1),\n                       mul_terms(term_list(p1), term_list(p2)))\n           : error(list(p1, p2), \"polys not in same var -- mul_poly\");\n} "}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    To incorporate polynomials into our generic arithmetic system, we need\n    to supply them with type tags.  We'll use the tag\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"polynomial\""},{"body":",\n      \n    and install appropriate operations on tagged polynomials in the operation\n    table.\n    \n\tWe'll embed all our code in an installation function\n\tfor the polynomial package,\n\tsimilar to the installation functions in\n\tsection ","tag":"#text"},{"tag":"REF","body":"2.5.1","href":"/sicpjs/2.5.1"},{"body":":\n\t  ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction install_polynomial_package() {\n    // internal functions\n    // representation of poly\n    function make_poly(variable, term_list) {\n        return pair(variable, term_list);\n    }\n    function variable(p) { return head(p); }\n    function term_list(p) { return tail(p); }\n    $\\langle{}$functions is_same_variable and is_variable from section 2.3.2$\\rangle$\n\n    // representation of terms and term lists\n    $\\langle{}$functions adjoin_term...coeff from text below$\\rangle$\n\n    function add_poly(p1, p2) { ... }\n    $\\langle{}$functions used by add_poly$\\rangle$\n    function mul_poly(p1, p2) { ... }\n    $\\langle{}$functions used by mul_poly$\\rangle$\n\n    // interface to rest of the system\n    function tag(p) { return attach_tag(\"polynomial\", p); }\n    put(\"add\", list(\"polynomial\", \"polynomial\"),\n        (p1, p2) => tag(add_poly(p1, p2)));\n    put(\"mul\", list(\"polynomial\", \"polynomial\"),\n        (p1, p2) => tag(mul_poly(p1, p2)));\n    put(\"make\", \"polynomial\",\n        (variable, terms) => tag(make_poly(variable, terms)));\n    return \"done\";\n}\n\t    "}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    Polynomial addition is performed termwise.  Terms of the same order\n    (i.e., with the same power of the indeterminate) must be combined.\n    This is done by forming a new term of the same order whose coefficient\n    is the sum of the coefficients of the addends.  Terms in one addend\n    for which there are no terms of the same order in the other addend are\n    simply accumulated into the sum polynomial being constructed.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    In order to manipulate term lists, we will assume that we have a\n    constructor \n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_empty_termlist"},{"body":"\n    that returns an empty term list and a constructor \n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_term"},{"body":"\n    that adjoins a new term to a term list.  We will also assume that we have\n    a predicate \n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_empty_termlist"},{"body":"\n    that tells if a given term list is empty, a selector\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"first_term"},{"body":"\n    that extracts the highest-order term from a term list, and a selector \n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"rest_terms"},{"body":"\n    that returns all but the highest-order term.  To manipulate terms,\n    we will suppose that we have a constructor \n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_term"},{"body":"\n    that constructs a term with given order and coefficient, and selectors \n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"order"},{"body":" and \n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"coeff"},{"body":" that return, respectively, the order\n    and the coefficient of the term.  These operations allow us to consider\n    both terms and term lists as data abstractions, whose concrete\n    representations we can worry about separately.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    Here is the\n    function\n    that constructs the term list for the sum of two\n    polynomials;","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/2.5.3#footnote-3"},{"body":"\n\tnote that we slightly extend the syntax of\n\t\n\tconditional statements described in\n      section ","tag":"#text"},{"tag":"REF","body":"1.3.2","href":"/sicpjs/1.3.2"},{"body":" by admitting another conditional\n      statement in place of the block following\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"else"},{"body":":\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":261,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0GYBQuRRIA7CAewFcAnAYwFMAaUAWzIGcAXUAMwuJo4BLMsTagAFgEMAbnVCSeggB50AJqGIVmAIzpVQZbvKoBzLXWIc2aAmAAUAFXFze-ISNAAbQZ1A-QHM4GxJ4AnqB0SvQADu7ETBxkAeL+bEncklRoAJS2oE4ufALCpJLR0WEA+oLElXyqemE1JpUAVjKSbDRUgrHynp5kAO5iFGKJeWUV4ZLE4SaCsqSuxR6uAUmSAxGedMwWVgZGgXKZZvuWoHnevmdsTJ1+x87hQ3pybHTRmZIcp6bmSxsXArOLycphOyuB6mNjZUAAb1woBRoCodA41FKENC1Vq9UaoWabQ6XR6sShfBhJjhAG5cABffCgkrg6aVEwWPSCGh2MjRalwxHI1E0ES+DihaJ0SocSQ00AAXhYZTskulsvlguy9NRoDFoi462VnI4fIFASlMrlNJ1IpR6MxVFIAEI-Gw6sQGtwampKcRcnqgyiAPxsqo1T0NKhNYgtdrSTrdXpm6Eq6J2A1-IHawPBvUALgiVCoZCodhuZv5CStmttDHt+aboAARMQkvtAmR1Nwy8k6J9LdKxABaEfh3Gc4jcmgtu1MkFFMGSVSqOxKJiheEItEYrETjlcnq8lsr1QtpiV9eb7I60ALlkeNgUbTX0BbxG7p3Y9lTmd2Ftn20C8vB8M0N3fW9aXvZkl1ZZgKE8N8Px3R19ymKo-2PACEM8ECrwgrc7wfOCPFURZkO3L90JxQ9p2wltyOkfCwMo4j8EIfk9F+EpNW0XYmGiCguFmdRTTybhS2YfUpFiPRQGwUA7E+VZSGwHAcFyRc3FZTo0l5ABrOhQiYdExSoVQhSRPU0Odd1Kk0AY7DMstLLzZswwJH1p1URt8yLOgAEcKC2OwjJMiQ6BXOxnGilyLLhW8-ODMNYrXeK3OSoMiz0shDOMhJJEEJCMsS+kSJ0jxmEkIy+N2Oxt0bA1fEGGgtjquRlSvFsACo5X4ugernXVUUfUhBjIAyKAzcLKgARiYWaUEaptmq4ID+t2JV5DYfSwuM+bCuKis8vaza6CgrKniUnwozoby-Q2yQBtvYVm1RWzSC831VBG4MGR2QdrPe-VxS4DLtty-LcRQI6kKel67RB6i7Nu76fOcuhzNUdzkb1TyvXun6rpBos5WOjKkfzJk9Rp0bSNIGpPioM1ZoW0AlqYRNPAoC63vzNbQARrblSh-bcXZ8mkNas7nt2S6m0EIw7DRwmHrXYWLpWkHPg4TVjplzwOobPGm2+QRyyvNnBKK8tOdAbnedvE3TZBqWTrao3ztvKn-sBuRgfewWIdF3a8vFypYYCIr4Zfb3febJWbo9dG-Up7XTd1-XY+0c6Xdds3bbsc27YOqPHYuuHlLjuWtYTpsAboTwgZJ-Ms-djKua2J2-ubOn-sbfueAZ0ByLYb4OBocQ7GYDOg0+lglUVZUWwmqbohbVugzDNfpq3wtF+Xlemb0DhN9dsMT5Z-fUQCksyxnpgWz4Az2yGUguKoHiPDHaOBuGwejYF5jwnlPcq+BBaf2-rUc621qq1XOg1ekgtTTbSgXEDqAFd4bztILISXBlToN4oglsV8z52m0qpeQHA5RTzrGqWsNomBZgOFZIBe47IlwYRqJhoNLCsPnJQsE6prTyjsKoX4Wg54L1ulwiRmJZ5b1SlFNc8ipFbzvqWcsajmBP20CuaOJhOTqB0aAX+Ii6wAKZGNPh2YrDiMkbPfmDoOGMw9HIxxuN8xhndjorxwZNEPx0XogxNpjGj0cWY8cLCgRWNgpVRmhothGwTEmcketNA6D0JUb4NADLyjoA1Zxw8EmGPXHPGyrjqG0PEPQlsqSyQpgcloXQVAQJKATkPfBAEzwsU4ABBpyZYjNKyW0p+gz0kjNaXOJgV1KJKgAHxlKUKAAA1JBBO3TAIvj6WaeppIhkZJaXoEC+zEyNOGZk6Z2RZlNnmYqJZNp1xmI2b3LZuFdkDIOZMq5JzxnfKab8tpNyrh3MIvCB5yzQA9VeY2LZTFPlnLSYC45YzWwTJRaMmZoL8z3MeWIlZYAiJvOEjhGqdBTkYsuaikCV0VmQqeR0hOC9GIiApeA3ATM5QDBJOcw5Uzsm5PyZyJB8SqHwJlFSo5oy7ABmKQvU0ZKjKUoBdSrF2RZWCKEayW6iYei13KZ+GRHpOA9DjOU6CFUqG3TYJIfYlQ9WCANdIdm0hlryqqbqzITqBp2BdfCAAZAG+yjrnXuqDQ7OaS9lRuo5TYrlyTeXIrVa06oHogohS9mQSoAAvPQZAimB1AFs26GazrZrzaWRFUqBXAtufmelSz6XL1AAABmZVU1l04WzgITTymtQK02VDLVm3N+bRXao8KW4K5ax2lkNUWheGFJxHh5ABadmbZQVvzZ8plcaR59qNtEMgYR2zMCdUeyQeSCmFvwHqQgNQ-jOi2CU1SwJGyEHRNEdEnxLDQKOMWk9oRGw2IlTkoDfrvW1wSHoZglRKwVI+lUrhoaBowaoHBhDvch42NQ-VaIVEF5pWLuxPUNin2YdYgRo1VT3YEctXe1En6vg-oOP+wwARYNiFEpxjDoFODAjIyPFcrQyCRgo2qWD6HKOcEQy4789kR1brnQWsU91uCSYw0lC+vGZMcBviiIsXCKPSfg2BTpTUwb9mHcwWIuIKOVm2o5TwvcbE+ioJwWUsHNN6bkyjUgxGKNmdk9hkDI8f16wo2wHzwWOB+YXu7ILWHAFCdKaW2zkovMYavEl8zxTKkKdus5mLyXaZhdKWBiTrk9DMLIOp+LVSrzVaoLV+roXUtUOaz5hrCnAuwYsx1sEanuAaYoz1-cgWY7dYs+VqhZ5wOQmiOzaI7qi0Ff3Dau1Mo8OFJ28XOaIK9sre06bMMYHj2QiOwd-OBcmzzaiyVqj12DO3eDLl-px2Tt40CZbJ7gllo3de62C7oQxDti4DUIWW2HaZCifIVcC3QgALK7N5cCOHsABl2YY9W1dJOKt00Zfs7Bq8WPXprfnlUnHvdaY4uDE3Qc+P0t2ay8wUny0-Pyf3FjmnqIAZXQZwHfegsOBRuVO5zzEmye8+DCLlA20JeRe8zj+u+YF5ddF-CJZGvlovfxvD0T4nvOi4eOjrjmNJfm7J0wFX-jvsGAsnoNUB3QAAB4HfRjVLroHYYRNiZgcbqO92rfswi6z6Ltu7fIxyqoQ3AeMMz3Jazvkjvyya-rUDzPKIzyZjqyN53Ny9dZ6Dnn0bHPC-F5BsHjD0Ww+Y+e5XzPderfl5lzBMrepUfwUQoj-b-3xuoxNVth1UHfVXcO6P-DHOXtnaTyDyD+rfVLYr43lEuFw+PY+w31fbtYOxeLuXl7P2Kx-eLQDovwYWwg7B2QCHpBbX7Bh-oX+6+QfI754xlEoGe-15t7jpsxqNmLODmrEZOM+1mewwBJOYER+8OqgG+6+QW2guIiaD2F+QOiuye1uoAKugOxeiB5uzeNedg2Btu7W9MFWP+e+yBlQqB5uJuOBfmTOhOUB2WoB5O+8CWzgQBmWIBnAbejczcQuyMcuCuFsluCeGOquwYS6se-uye6BeolW3mGuLu6yOuK+O+QYuEue6mBerW+eHA5eeBt2BBGGlQNBdBxBDBRBzAEePsAhgCAAkE4fmB+mAI+noBkPQBsLuL4BxicELKDn8MwF3h4E8tRhTlznZL8DUnUiDmeheiBPRilqiFsr0peKxFfkBokVsKcgkWQOenkZoUGH3mfhCviiYHYPNvPktv3grGkaSi2B8pkf0tkaeoUUkU-AUUUXhCUXqGUcdosmUq-hBnUeUQ0SiO8uSvkTkZ0XkSYUpDttJkKA8vvE8udhBssbpolB2gpl2uyoyJykkjyj0RejklesKoUhQqBnPnMb0Qvj6gJDsdIlUoqs0TMd0fcUkRqtsVFlqngmLiqLVGcaFC2EoBeE4S9leMoQnlHGBgOqinYAACzOyKGwnMB2DswImqrSqtJ2DYBomZ4Yl2CtpMA4l8o-JIkADsPsuCVmK2cCdxHRDx4JkJ0JrEJJ8JSeiJMqGARJQOJJ2JPJuJtadgHOixyMJJZJwJkqopQKWJ7aDh+AOh4xx29IuAQAA","body":"function add_terms(L1, L2) {\n    if (is_empty_termlist(L1)) {\n        return L2;\n    } else if (is_empty_termlist(L2)) {\n        return L1;\n    } else {\n        const t1 = first_term(L1);\n        const t2 = first_term(L2);\n        return order(t1) > order(t2)\n               ? adjoin_term(t1, add_terms(rest_terms(L1), L2))\n               : order(t1) < order(t2)\n               ? adjoin_term(t2, add_terms(L1, rest_terms(L2)))\n               : adjoin_term(make_term(order(t1), \n                                       add(coeff(t1), coeff(t2))),\n                             add_terms(rest_terms(L1),\n                                       rest_terms(L2)));\n    }\n} "},{"body":"\n    The most important point to note here is that we used the generic addition\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add"},{"body":" to add together the coefficients of the\n    terms being combined.  This has powerful consequences, as we will see below.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    In order to multiply two term lists, we multiply each term of the first\n    list by all the terms of the other list, repeatedly using\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_term_by_all_terms"},{"body":",\n      \n    which multiplies a given term by all terms in a given term list.  The\n    resulting term lists (one for each term of the first list) are accumulated\n    into a sum.  Multiplying two terms forms a term whose order is the sum of\n    the orders of the factors and whose coefficient is the product of the\n    coefficients of the factors:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":261,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0GYBQuRRIA7CAewFcAnAYwFMAaUAWzIGcAXUAMwuJo4BLMsTagAFgEMAbnVCSeggB50AJqGIVmAIzpVQZbvKoBzLXWIc2aAmAAUAFXFze-ISNAAbQZ1A-QHM4GxJ4AnqB0SvQADu7ETBxkAeL+bEncklRoAJS2oE4ufALCpJLR0WEA+oLElXyqemE1JpUAVjKSbDRUgrHynp5kAO5iFGKJeWUV4ZLE4SaCsqSuxR6uAUmSAxGedMwWVgZGgXKZZvuWoHnevmdsTJ1+x87hQ3pybHTRmZIcp6bmSxsXArOLycphOyuB6mNjZUAAb1woBRoCodA41FKENC1Vq9UaoWabQ6XR6sShfBhJjhAG5cABffCgkrg6aVEwWPSCGh2MjRalwxHI1E0ES+DihaJ0SocSQ00AAXhYZTskulsvlguy9NRoDFoi462VnI4fIFASlMrlNJ1IpR6MxVFIAEI-Gw6sQGtwampKcRcnqgyiAPxsqo1T0NKhNYgtdrSTrdXpm6Eq6J2A1-IHawPBvUALgiVCoZCodhuZv5CStmttDHt+aboAARMQkvtAmR1Nwy8k6J9LdKxABaEfh3Gc4jcmgtu1MkFFMGSVSqOxKJiheEItEYrETjlcnq8lsr1QtpiV9eb7I60ALlkeNgUbTX0BbxG7p3Y9lTmd2Ftn20C8vB8M0N3fW9aXvZkl1ZZgKE8N8Px3R19ymKo-2PACEM8ECrwgrc7wfOCPFURZkO3L90JxQ9p2wltyOkfCwMo4j8EIfk9F+EpNW0XYmGiCguFmdRTTybhS2YfUpFiPRQGwUA7E+VZSGwHAcFyRc3FZTo0l5ABrOhQiYdExSoVQhSRPU0Odd1Kk0AY7DMstLLzZswwJH1p1URt8yLOgAEcKC2OwjJMiQ6BXOxnGilyLLhW8-ODMNYrXeK3OSoMiz0shDOMhJJEEJCMsS+kSJ0jxmEkIy+N2Oxt0bA1fEGGgtjquRlSvFsACo5X4ugernXVUUfUhBjIAyKAzcLKgARiYWaUEaptmq4ID+t2JV5DYfSwuM+bCuKis8vaza6CgrKniUnwozoby-Q2yQBtvYVm1RWzSC831VBG4MGR2QdrPe-VxS4DLtty-LcRQI6kKel67RB6i7Nu76fOcuhzNUdzkb1TyvXun6rpBos5WOjKkfzJk9Rp0bSNIGpPioM1ZoW0AlqYRNPAoC63vzNbQARrblSh-bcXZ8mkNas7nt2S6m0EIw7DRwmHrXYWLpWkHPg4TVjplzwOobPGm2+QRyyvNnBKK8tOdAbnedvE3TZBqWTrao3ztvKn-sBuRgfewWIdF3a8vFypYYCIr4Zfb3febJWbo9dG-Up7XTd1-XY+0c6Xdds3bbsc27YOqPHYuuHlLjuWtYTpsAboTwgZJ-Ms-djKua2J2-ubOn-sbfueAZ0ByLYb4OBocQ7GYDOg0+lglUVZUWwmqbohbVugzDNfpq3wtF+Xlemb0DhN9dsMT5Z-fUQCksyxnpgWz4Az2yGUguKoHiPDHaOBuGwejYF5jwnlPcq+BBaf2-rUc621qq1XOg1ekgtTTbSgXEDqAFd4bztILISXBlToN4oglsV8z52m0qpeQHA5RTzrGqWsNomBZgOFZIBe47IlwYRqJhoNLCsPnJQsE6prTyjsKoX4Wg54L1ulwiRmJZ5b1SlFNc8ipFbzvqWcsajmBP20CuaOJhOTqB0aAX+Ii6wAKZGNPh2YrDiMkbPfmDoOGMw9HIxxuN8xhndjorxwZNEPx0XogxNpjGj0cWY8cLCgRWNgpVRmhothGwTEmcketNA6D0JUb4NADLyjoA1Zxw8EmGPXHPGyrjqG0PEPQlsqSyQpgcloXQVAQJKATkPfBAEzwsU4ABBpyZYjNKyW0p+gz0kjNaXOJgV1KJKgAHxlKUKAAA1JBBO3TAIvj6WaeppIhkZJaXoEC+zEyNOGZk6Z2RZlNnmYqJZNp1xmI2b3LZuFdkDIOZMq5JzxnfKab8tpNyrh3MIvCB5yzQA9VeY2LZTFPlnLSYC45YzWwTJRaMmZoL8z3MeWIlZYAiJvOEjhGqdBTkYsuaikCV0VmQqeR0hOC9GIiApeA3ATM5QDBJOcw5Uzsm5PyZyJB8SqHwJlFSo5oy7ABmKQvU0ZKjKUoBdSrF2RZWCKEayW6iYei13KZ+GRHpOA9DjOU6CFUqG3TYJIfYlQ9WCANdIdm0hlryqqbqzITqBp2BdfCAAZAG+yjrnXuqDQ7OaS9lRuo5TYrlyTeXIrVa06oHogohS9mQSoAAvPQZAimB1AFs26GazrZrzaWRFUqBXAtufmelSz6XL1AAABmZVU1l04WzgITTymtQK02VDLVm3N+bRXao8KW4K5ax2lkNUWheGFJxHh5ABadmbZQVvzZ8plcaR59qNtEMgYR2zMCdUeyQeSCmFvwHqQgNQ-jOi2CU1SwJGyEHRNEdEnxLDQKOMWk9oRGw2IlTkoDfrvW1wSHoZglRKwVI+lUrhoaBowaoHBhDvch42NQ-VaIVEF5pWLuxPUNin2YdYgRo1VT3YEctXe1En6vg-oOP+wwARYNiFEpxjDoFODAjIyPFcrQyCRgo2qWD6HKOcEQy4789kR1brnQWsU91uCSYw0lC+vGZMcBviiIsXCKPSfg2BTpTUwb9mHcwWIuIKOVm2o5TwvcbE+ioJwWUsHNN6bkyjUgxGKNmdk9hkDI8f16wo2wHzwWOB+YXu7ILWHAFCdKaW2zkovMYavEl8zxTKkKdus5mLyXaZhdKWBiTrk9DMLIOp+LVSrzVaoLV+roXUtUOaz5hrCnAuwYsx1sEanuAaYoz1-cgWY7dYs+VqhZ5wOQmiOzaI7qi0Ff3Dau1Mo8OFJ28XOaIK9sre06bMMYHj2QiOwd-OBcmzzaiyVqj12DO3eDLl-px2Tt40CZbJ7gllo3de62C7oQxDti4DUIWW2HaZCifIVcC3QgALK7N5cCOHsABl2YY9W1dJOKt00Zfs7Bq8WPXprfnlUnHvdaY4uDE3Qc+P0t2ay8wUny0-Pyf3FjmnqIAZXQZwHfegsOBRuVO5zzEmye8+DCLlA20JeRe8zj+u+YF5ddF-CJZGvlovfxvD0T4nvOi4eOjrjmNJfm7J0wFX-jvsGAsnoNUB3QAAB4HfRjVLroHYYRNiZgcbqO92rfswi6z6Ltu7fIxyqoQ3AeMMz3Jazvkjvyya-rUDzPKIzyZjqyN53Ny9dZ6Dnn0bHPC-F5BsHjD0Ww+Y+e5XzPderfl5lzBMrepUfwUQoj-b-3xuoxNVth1UHfVXcO6P-DHOXtnaTyDyD+rfVLYr43lEuFw+PY+w31fbtYOxeLuXl7P2Kx-eLQDovwYWwg7B2QCHpBbX7Bh-oX+6+QfI754xlEoGe-15t7jpsxqNmLODmrEZOM+1mewwBJOYER+8OqgG+6+QW2guIiaD2F+QOiuye1uoAKugOxeiB5uzeNedg2Btu7W9MFWP+e+yBlQqB5uJuOBfmTOhOUB2WoB5O+8CWzgQBmWIBnAbejczcQuyMcuCuFsluCeGOquwYS6se-uye6BeolW3mGuLu6yOuK+O+QYuEue6mBerW+eHA5eeBt2BBGGlQNBdBxBDBRBzAEePsAhgCAAkE4fmB+mAI+noBkPQBsLuL4BxicELKDn8MwF3h4E8tRhTlznZL8DUnUiDmeheiBPRilqiFsr0peKxFfkBokVsKcgkWQOenkZoUGH3mfhCviiYHYPNvPktv3grGkaSi2B8pkf0tkaeoUUkU-AUUUXhCUXqGUcdosmUq-hBnUeUQ0SiO8uSvkTkZ0XkSYUpDttJkKA8vvE8udhBssbpolB2gpl2uyoyJykkjyj0RejklesKoUhQqBnPnMb0Qvj6gJDsdIlUoqs0TMd0fcUkRqtsVFlqngmLiqLVGcaFC2EoBeE4S9leMoQnlHGBgOqinYAACzOyKGwnMB2DswImqrSqtJ2DYBomZ4Yl2CtpMA4l8o-JIkADsPsuCVmK2cCdxHRDx4JkJ0JrEJJ8JSeiJMqGARJQOJJ2JPJuJtadgHOixyMJJZJwJkqopQKWJ7aDh+AOh4xx29IuAQAA","body":"function mul_terms(L1, L2) {\n    return is_empty_termlist(L1)\n           ? the_empty_termlist\n           : add_terms(mul_term_by_all_terms(\n                                 first_term(L1), L2),\n                       mul_terms(rest_terms(L1), L2));\n}\nfunction mul_term_by_all_terms(t1, L) {\n    if (is_empty_termlist(L)) {\n        return the_empty_termlist;\n    } else {\n        const t2 = first_term(L);\n        return adjoin_term(\n                   make_term(order(t1) + order(t2),\n                             mul(coeff(t1), coeff(t2))),\n                   mul_term_by_all_terms(t1, rest_terms(L)));\n    }\n} "}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    This is really all there is to polynomial addition and multiplication.\n    Notice that, since we operate on terms using the generic\n    functions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul"},{"body":",\n    our polynomial package is automatically able to handle any type of\n    coefficient that is known about by the generic arithmetic package.\n    If we include a \n    \n    coercion mechanism such as one of those discussed in\n    section ","tag":"#text"},{"tag":"REF","body":"2.5.2","href":"/sicpjs/2.5.2"},{"body":",\n    then we also are automatically able to handle operations on\n    polynomials of different coefficient types, such as\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{l}\n      {\\left[3x^2 +(2+3i)x+7\\right] \\cdot \\left[x^4 +\\frac{2}{3}x^2\n      +(5+3i)\\right]}\n      \\end{array}\n      \\]\n    ","tag":"LATEX"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    Because we installed the polynomial addition and multiplication\n    functions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_poly"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_poly"},{"body":"\n    in the generic arithmetic system as the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add"},{"body":"\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul"},{"body":" operations for type\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"polynomial"},{"body":", our system is also automatically\n    able to handle polynomial operations such as\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{l}\n      {\\left[ (y+1)x^2 +(y^2 +1)x+(y-1)\\right]\\cdot \\left[(y-2)x+(y^3 +7)\\right]}\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    The reason is that when the system tries to combine coefficients, it\n    will dispatch through ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul"},{"body":".  Since the coefficients are themselves\n    polynomials (in ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":"), these will be combined\n    using\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_poly"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_poly"},{"body":".\n    The result is a kind of \n    \"","tag":"#text"},{"body":"data-directed recursion","tag":"#text"},{"body":"\" in which, for example, a call to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_poly"},{"body":"\n    will result in recursive calls to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_poly"},{"body":"\n    in order to multiply the coefficients.  If the coefficients of the\n    coefficients were themselves polynomials (as might be used to represent\n    polynomials in three variables), the data direction would ensure that the\n    system would follow through another level of recursive calls, and so on\n    through as many levels as the structure of the data dictates.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/2.5.3#footnote-4"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Representing term lists","tag":"#text"}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n    Finally, we must confront the job of implementing a good\n    representation for term lists.  A term list is, in effect, a set of\n    coefficients keyed by the order of the term.  Hence, any of the\n    methods for representing sets, as discussed in\n    section ","tag":"#text"},{"tag":"REF","body":"2.3.3","href":"/sicpjs/2.3.3"},{"body":", can be applied to this\n    task.  On the other hand, our\n    functions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_terms"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_terms"},{"body":"\n    always access term lists sequentially from highest to lowest order.\n    Thus, we will use some kind of ordered list representation.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p15","child":[{"body":"\n    How should we structure the list that represents a term list?  One\n    consideration is the \"","tag":"#text"},{"body":"density","tag":"#text"},{"body":"\" of the polynomials we intend\n    to manipulate.  A polynomial is said to be \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"dense","tag":"#text"}]},{"body":" if it has nonzero coefficients in terms of most orders.\n    If it has many zero terms it is said to be \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"sparse","tag":"#text"}]},{"body":".  For example,\n    ","tag":"#text"},{"body":"\n      \\[ A:\\quad x^5 +2x^4 +3x^2 -2x -5 \\]\n    ","tag":"LATEX"},{"body":"\n    is a dense polynomial, whereas\n    ","tag":"#text"},{"body":"\n      \\[ B:\\quad x^{100} +2x^2 +1 \\]\n    ","tag":"LATEX"},{"body":"\n    is sparse.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p16","child":[{"body":"\n\tThe term list of a dense polynomial is most efficiently represented\n\tas a list of the coefficients.\n      \n    For example,\n    \n\tthe polynomial\n      ","tag":"#text"},{"body":"$A$","tag":"LATEX"},{"body":" above would be nicely represented as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(1, 2, 0, 3, -2, -5)"},{"body":".\n      \n    The order of a term in this representation is the length of the sublist\n    beginning with that term's coefficient, decremented by 1.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/2.5.3#footnote-5"},{"body":"  \n    This would be a terrible representation for a sparse polynomial such as\n    ","tag":"#text"},{"body":"$B$","tag":"LATEX"},{"body":": There would be a giant list of zeros\n    punctuated by a few lonely nonzero terms.  A more reasonable representation\n    of the term list of a sparse polynomial is as a list of the nonzero terms,\n    where each term is a list containing the order of the term and the\n    coefficient for that order.  In such a scheme, polynomial\n    ","tag":"#text"},{"body":"$B$","tag":"LATEX"},{"body":" is efficiently represented as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(list(100, 1), list(2, 2), list(0, 1))"},{"body":".\n      \n    As most polynomial manipulations are performed on sparse polynomials, we\n    will use this method.  We will assume that term lists are represented as\n    lists of terms, arranged from highest-order to lowest-order term. Once we\n    have made this decision, implementing the selectors and constructors for\n    terms and term lists is straightforward:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-6","body":"6","href":"/sicpjs/2.5.3#footnote-6"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":261,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0GYBQuRRIA7CAewFcAnAYwFMAaUAWzIGcAXUAMwuJo4BLMsTagAFgEMAbnVCSeggB50AJqGIVmAIzpVQZbvKoBzLXWIc2aAmAAUAFXFze-ISNAAbQZ1A-QHM4GxJ4AnqB0SvQADu7ETBxkAeL+bEncklRoAJS2oE4ufALCpJLR0WEA+oLElXyqemE1JpUAVjKSbDRUgrHynp5kAO5iFGKJeWUV4ZLE4SaCsqSuxR6uAUmSAxGedMwWVgZGgXKZZvuWoHnevmdsTJ1+x87hQ3pybHTRmZIcp6bmSxsXArOLycphOyuB6mNjZUAAb1woBRoCodA41FKENC1Vq9UaoWabQ6XR6sShfBhJjhAG5cABffCgkrg6aVEwWPSCGh2MjRalwxHI1E0ES+DihaJ0SocSQ00AAXhYZTskulsvlguy9NRoDFoi462VnI4fIFASlMrlNJ1IpR6MxVFIAEI-Gw6sQGtwampKcRcnqgyiAPxsqo1T0NKhNYgtdrSTrdXpm6Eq6J2A1-IHawPBvUALgiVCoZCodhuZv5CStmttDHt+aboAARMQkvtAmR1Nwy8k6J9LdKxABaEfh3Gc4jcmgtu1MkFFMGSVSqOxKJiheEItEYrETjlcnq8lsr1QtpiV9eb7I60ALlkeNgUbTX0BbxG7p3Y9lTmd2Ftn20C8vB8M0N3fW9aXvZkl1ZZgKE8N8Px3R19ymKo-2PACEM8ECrwgrc7wfOCPFURZkO3L90JxQ9p2wltyOkfCwMo4j8EIfk9F+EpNW0XYmGiCguFmdRTTybhS2YfUpFiPRQGwUA7E+VZSGwHAcFyRc3FZTo0l5ABrOhQiYdExSoVQhSRPU0Odd1Kk0AY7DMstLLzZswwJH1p1URt8yLOgAEcKC2OwjJMiQ6BXOxnGilyLLhW8-ODMNYrXeK3OSoMiz0shDOMhJJEEJCMsS+kSJ0jxmEkIy+N2Oxt0bA1fEGGgtjquRlSvFsACo5X4ugernXVUUfUhBjIAyKAzcLKgARiYWaUEaptmq4ID+t2JV5DYfSwuM+bCuKis8vaza6CgrKniUnwozoby-Q2yQBtvYVm1RWzSC831VBG4MGR2QdrPe-VxS4DLtty-LcRQI6kKel67RB6i7Nu76fOcuhzNUdzkb1TyvXun6rpBos5WOjKkfzJk9Rp0bSNIGpPioM1ZoW0AlqYRNPAoC63vzNbQARrblSh-bcXZ8mkNas7nt2S6m0EIw7DRwmHrXYWLpWkHPg4TVjplzwOobPGm2+QRyyvNnBKK8tOdAbnedvE3TZBqWTrao3ztvKn-sBuRgfewWIdF3a8vFypYYCIr4Zfb3febJWbo9dG-Up7XTd1-XY+0c6Xdds3bbsc27YOqPHYuuHlLjuWtYTpsAboTwgZJ-Ms-djKua2J2-ubOn-sbfueAZ0ByLYb4OBocQ7GYDOg0+lglUVZUWwmqbohbVugzDNfpq3wtF+Xlemb0DhN9dsMT5Z-fUQCksyxnpgWz4Az2yGUguKoHiPDHaOBuGwejYF5jwnlPcq+BBaf2-rUc621qq1XOg1ekgtTTbSgXEDqAFd4bztILISXBlToN4oglsV8z52m0qpeQHA5RTzrGqWsNomBZgOFZIBe47IlwYRqJhoNLCsPnJQsE6prTyjsKoX4Wg54L1ulwiRmJZ5b1SlFNc8ipFbzvqWcsajmBP20CuaOJhOTqB0aAX+Ii6wAKZGNPh2YrDiMkbPfmDoOGMw9HIxxuN8xhndjorxwZNEPx0XogxNpjGj0cWY8cLCgRWNgpVRmhothGwTEmcketNA6D0JUb4NADLyjoA1Zxw8EmGPXHPGyrjqG0PEPQlsqSyQpgcloXQVAQJKATkPfBAEzwsU4ABBpyZYjNKyW0p+gz0kjNaXOJgV1KJKgAHxlKUKAAA1JBBO3TAIvj6WaeppIhkZJaXoEC+zEyNOGZk6Z2RZlNnmYqJZNp1xmI2b3LZuFdkDIOZMq5JzxnfKab8tpNyrh3MIvCB5yzQA9VeY2LZTFPlnLSYC45YzWwTJRaMmZoL8z3MeWIlZYAiJvOEjhGqdBTkYsuaikCV0VmQqeR0hOC9GIiApeA3ATM5QDBJOcw5Uzsm5PyZyJB8SqHwJlFSo5oy7ABmKQvU0ZKjKUoBdSrF2RZWCKEayW6iYei13KZ+GRHpOA9DjOU6CFUqG3TYJIfYlQ9WCANdIdm0hlryqqbqzITqBp2BdfCAAZAG+yjrnXuqDQ7OaS9lRuo5TYrlyTeXIrVa06oHogohS9mQSoAAvPQZAimB1AFs26GazrZrzaWRFUqBXAtufmelSz6XL1AAABmZVU1l04WzgITTymtQK02VDLVm3N+bRXao8KW4K5ax2lkNUWheGFJxHh5ABadmbZQVvzZ8plcaR59qNtEMgYR2zMCdUeyQeSCmFvwHqQgNQ-jOi2CU1SwJGyEHRNEdEnxLDQKOMWk9oRGw2IlTkoDfrvW1wSHoZglRKwVI+lUrhoaBowaoHBhDvch42NQ-VaIVEF5pWLuxPUNin2YdYgRo1VT3YEctXe1En6vg-oOP+wwARYNiFEpxjDoFODAjIyPFcrQyCRgo2qWD6HKOcEQy4789kR1brnQWsU91uCSYw0lC+vGZMcBviiIsXCKPSfg2BTpTUwb9mHcwWIuIKOVm2o5TwvcbE+ioJwWUsHNN6bkyjUgxGKNmdk9hkDI8f16wo2wHzwWOB+YXu7ILWHAFCdKaW2zkovMYavEl8zxTKkKdus5mLyXaZhdKWBiTrk9DMLIOp+LVSrzVaoLV+roXUtUOaz5hrCnAuwYsx1sEanuAaYoz1-cgWY7dYs+VqhZ5wOQmiOzaI7qi0Ff3Dau1Mo8OFJ28XOaIK9sre06bMMYHj2QiOwd-OBcmzzaiyVqj12DO3eDLl-px2Tt40CZbJ7gllo3de62C7oQxDti4DUIWW2HaZCifIVcC3QgALK7N5cCOHsABl2YY9W1dJOKt00Zfs7Bq8WPXprfnlUnHvdaY4uDE3Qc+P0t2ay8wUny0-Pyf3FjmnqIAZXQZwHfegsOBRuVO5zzEmye8+DCLlA20JeRe8zj+u+YF5ddF-CJZGvlovfxvD0T4nvOi4eOjrjmNJfm7J0wFX-jvsGAsnoNUB3QAAB4HfRjVLroHYYRNiZgcbqO92rfswi6z6Ltu7fIxyqoQ3AeMMz3Jazvkjvyya-rUDzPKIzyZjqyN53Ny9dZ6Dnn0bHPC-F5BsHjD0Ww+Y+e5XzPderfl5lzBMrepUfwUQoj-b-3xuoxNVth1UHfVXcO6P-DHOXtnaTyDyD+rfVLYr43lEuFw+PY+w31fbtYOxeLuXl7P2Kx-eLQDovwYWwg7B2QCHpBbX7Bh-oX+6+QfI754xlEoGe-15t7jpsxqNmLODmrEZOM+1mewwBJOYER+8OqgG+6+QW2guIiaD2F+QOiuye1uoAKugOxeiB5uzeNedg2Btu7W9MFWP+e+yBlQqB5uJuOBfmTOhOUB2WoB5O+8CWzgQBmWIBnAbejczcQuyMcuCuFsluCeGOquwYS6se-uye6BeolW3mGuLu6yOuK+O+QYuEue6mBerW+eHA5eeBt2BBGGlQNBdBxBDBRBzAEePsAhgCAAkE4fmB+mAI+noBkPQBsLuL4BxicELKDn8MwF3h4E8tRhTlznZL8DUnUiDmeheiBPRilqiFsr0peKxFfkBokVsKcgkWQOenkZoUGH3mfhCviiYHYPNvPktv3grGkaSi2B8pkf0tkaeoUUkU-AUUUXhCUXqGUcdosmUq-hBnUeUQ0SiO8uSvkTkZ0XkSYUpDttJkKA8vvE8udhBssbpolB2gpl2uyoyJykkjyj0RejklesKoUhQqBnPnMb0Qvj6gJDsdIlUoqs0TMd0fcUkRqtsVFlqngmLiqLVGcaFC2EoBeE4S9leMoQnlHGBgOqinYAACzOyKGwnMB2DswImqrSqtJ2DYBomZ4Yl2CtpMA4l8o-JIkADsPsuCVmK2cCdxHRDx4JkJ0JrEJJ8JSeiJMqGARJQOJJ2JPJuJtadgHOixyMJJZJwJkqopQKWJ7aDh+AOh4xx29IuAQAA","body":"function adjoin_term(term, term_list) {\n    return is_equal_to_zero(coeff(term))\n           ? term_list\n           : pair(term, term_list);\n}\n\nconst the_empty_termlist = null;\n\nfunction first_term(term_list) { return head(term_list); }\n\nfunction rest_terms(term_list) { return tail(term_list); }\n\nfunction is_empty_termlist(term_list) { return is_null(term_list); }\n\nfunction make_term(order, coeff) { return list(order, coeff); }\n\nfunction order(term) { return head(term); }\n\nfunction coeff(term) { return head(tail(term)); } "},{"body":"\n    where\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_equal_to_zero"},{"body":"\n    is as defined in exercise ","tag":"#text"},{"tag":"REF","body":"2.80","href":"/sicpjs/2.5.1#ex-2.80"},{"body":".  (See also\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.87","href":"/sicpjs/2.5.3#ex-2.87"},{"body":" below.)\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p17","child":[{"body":"\n    Users of the polynomial package will create (tagged) polynomials by means\n    of the\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":246,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAJgHQFY0GYBQuRRIA7CAewFcAnAYwFMAaUAWzIGcAXUAMwuJo4BLMsTagAFgEMAbnVCSeggB50AJqGIVmAIzpVQZbvKoBzLXWIc2aAmAAUAFXFze-ISNAAbQZ1A-QHM4GxJ4AnqB0SvQADu7ETBxkAeL+bEncklRoAJS2oE4ufALCpJLR0WEA+oLElXyqemE1JpUAVjKSbDRUgrHynp5kAO5iFGKJeWUV4ZLE4SaCsqSuxR6uAUmSAxGedMwWVgZGgXKZZvuWoHnevmdsTJ1+x87hQ3pybHTRmZIcp6bmSxsXArOLycphOyuB6mNjZUAAb1woBRoCodA41FKENC1Vq9UaoWabQ6XR6sShfBhJjhAG5cABffCgkrg6aVEwWPSCGh2MjRalwxHI1E0ES+DihaJ0SocSQ00AAXhYZTskulsvlguy9NRoDFoi462VnI4fIFASlMrlNJ1IpR6MxVFIAEI-Gw6sQGtwampKcRcnqgyiAPxsqo1T0NKhNYgtdrSTrdXpm6Eq6J2A1-IHawPBvUALgiVCoZCodhuZv5CStmttDHt+aboAARMQkvtAmR1Nwy8k6J9LdKxABaEfh3Gc4jcmgtu1MkFFMGSVSqOxKJiheEItEYrETjlcnq8lsr1QtpiV9eb7I60ALlkeNgUbTX0BbxG7p3Y9lTmd2Ftn20C8vB8M0N3fW9aXvZkl1ZZgKE8N8Px3R19ymKo-2PACEM8ECrwgrc7wfOCPFURZkO3L90JxQ9p2wltyOkfCwMo4j8EIfk9F+EpNW0XYmGiCguFmdRTTybhS2YfUpFiPRQGwUA7E+VZSGwHAcFyRc3FZTo0l5ABrOhQiYdExSoVQhSRPU0Odd1Kk0AY7DMstLLzZswwJH1p1URt8yLOgAEcKC2OwjJMiQ6BXOxnGilyLLhW8-ODMNYrXeK3OSoMiz0shDOMhJJEEJCMsS+kSJ0jxmEkIy+N2Oxt0bA1fEGGgtjquRlSvFsACo5X4ugernXVUUfUhBjIAyKAzcLKgARiYWaUEaptmq4ID+t2JV5DYfSwuM+bCuKis8vaza6CgrKniUnwozoby-Q2yQBtvYVm1RWzSC831VBG4MGR2QdrPe-VxS4DLtty-LcRQI6kKel67RB6i7Nu76fOcuhzNUdzkb1TyvXun6rpBos5WOjKkfzJk9Rp0bSNIGpPioM1ZoW0AlqYRNPAoC63vzNbQARrblSh-bcXZ8mkNas7nt2S6m0EIw7DRwmHrXYWLpWkHPg4TVjplzwOobPGm2+QRyyvNnBKK8tOdAbnedvE3TZBqWTrao3ztvKn-sBuRgfewWIdF3a8vFypYYCIr4Zfb3febJWbo9dG-Up7XTd1-XY+0c6Xdds3bbsc27YOqPHYuuHlLjuWtYTpsAboTwgZJ-Ms-djKua2J2-ubOn-sbfueAZ0ByLYb4OBocQ7GYDOg0+lglUVZUWwmqbohbVugzDNfpq3wtF+Xlemb0DhN9dsMT5Z-fUQCksyxnpgWz4Az2yGUguKoHiPDHaOBuGwejYF5jwnlPcq+BBaf2-rUc621qq1XOg1ekgtTTbSgXEDqAFd4bztILISXBlToN4oglsV8z52m0qpeQHA5RTzrGqWsNomBZgOFZIBe47IlwYRqJhoNLCsPnJQsE6prTyjsKoX4Wg54L1ulwiRmJZ5b1SlFNc8ipFbzvqWcsajmBP20CuaOJhOTqB0aAX+Ii6wAKZGNPh2YrDiMkbPfmDoOGMw9HIxxuN8xhndjorxwZNEPx0XogxNpjGj0cWY8cLCgRWNgpVRmhothGwTEmcketNA6D0JUb4NADLyjoA1Zxw8EmGPXHPGyrjqG0PEPQlsqSyQpgcloXQVAQJKATkPfBAEzwsU4ABBpyZYjNKyW0p+gz0kjNaXOJgV1KJKgAHxlKUKAAA1JBBO3TAIvj6WaeppIhkZJaXoEC+zEyNOGZk6Z2RZlNnmYqJZNp1xmI2b3LZuFdkDIOZMq5JzxnfKab8tpNyrh3MIvCB5yzQA9VeY2LZTFPlnLSYC45YzWwTJRaMmZoL8z3MeWIlZYAiJvOEjhGqdBTkYsuaikCV0VmQqeR0hOC9GIiApeA3ATM5QDBJOcw5Uzsm5PyZyJB8SqHwJlFSo5oy7ABmKQvU0ZKjKUoBdSrF2RZWCKEayW6iYei13KZ+GRHpOA9DjOU6CFUqG3TYJIfYlQ9WCANdIdm0hlryqqbqzITqBp2BdfCAAZAG+yjrnXuqDQ7OaS9lRuo5TYrlyTeXIrVa06oHogohS9mQSoAAvPQZAimB1AFs26GazrZrzaWRFUqBXAtufmelSz6XL1AAABmZVU1l04WzgITTymtQK02VDLVm3N+bRXao8KW4K5ax2lkNUWheGFJxHh5ABadmbZQVvzZ8plcaR59qNtEMgYR2zMCdUeyQeSCmFvwHqQgNQ-jOi2CU1SwJGyEHRNEdEnxLDQKOMWk9oRGw2IlTkoDfrvW1wSHoZglRKwVI+lUrhoaBowaoHBhDvch42NQ-VaIVEF5pWLuxPUNin2YdYgRo1VT3YEctXe1En6vg-oOP+wwARYNiFEpxjDoFODAjIyPFcrQyCRgo2qWD6HKOcEQy4789kR1brnQWsU91uCSYw0lC+vGZMcBviiIsXCKPSfg2BTpTUwb9mHcwWIuIKOVm2o5TwvcbE+ioJwWUsHNN6bkyjUgxGKNmdk9hkDI8f16wo2wHzwWOB+YXu7ILWHAFCdKaW2zkovMYavEl8zxTKkKdus5mLyXaZhdKWBiTrk9DMLIOp+LVSrzVaoLV+roXUtUOaz5hrCnAuwYsx1sEanuAaYoz1-cgWY7dYs+VqhZ5wOQmiOzaI7qi0Ff3Dau1Mo8OFJ28XOaIK9sre06bMMYHj2QiOwd-OBcmzzaiyVqj12DO3eDLl-px2Tt40CZbJ7gllo3de62C7oQxDti4DUIWW2HaZCifIVcC3QgALK7N5cCOHsABl2YY9W1dJOKt00Zfs7Bq8WPXprfnlUnHvdaY4uDE3Qc+P0t2ay8wUny0-Pyf3FjmnqIAZXQZwHfegsOBRuVO5zzEmye8+DCLlA20JeRe8zj+u+YF5ddF-CJZGvlovfxvD0T4nvOi4eOjrjmNJfm7J0wFX-jvsGAsnoNUB3QAAB4HfRjVLroHYYRNiZgcbqO92rfswi6z6Ltu7fIxyqoQ3AeMMz3Jazvkjvyya-rUDzPKIzyZjqyN53Ny9dZ6Dnn0bHPC-F5BsHjD0Ww+Y+e5XzPderfl5lzBMrepUfwUQoj-b-3xuoxNVth1UHfVXcO6P-DHOXtnaTyDyD+rfVLYr43lEuFw+PY+w31fbtYOxeLuXl7P2Kx-eLQDovwYWwg7B2QCHpBbX7Bh-oX+6+QfI754xlEoGe-15t7jpsxqNmLODmrEZOM+1mewwBJOYER+8OqgG+6+QW2guIiaD2F+QOiuye1uoAKugOxeiB5uzeNedg2Btu7W9MFWP+e+yBlQqB5uJuOBfmTOhOUB2WoB5O+8CWzgQBmWIBnAbejczcQuyMcuCuFsluCeGOquwYS6se-uye6BeolW3mGuLu6yOuK+O+QYuEue6mBerW+eHA5eeBt2BBGGlQNBdBxBDBRBzAEePsAhgCAAkE4fmB+mAI+noBkPQBsLuL4BxicELKDn8MwF3h4E8tRhTlznZL8DUnUiDmeheiBPRilqiFsr0peKxFfkBokVsKcgkWQOenkZoUGH3mfhCviiYHYPNvPktv3grGkaSi2B8pkf0tkaeoUUkU-AUUUXhCUXqGUcdosmUq-hBnUeUQ0SiO8uSvkTkZ0XkSYUpDttJkKA8vvE8udhBssbpolB2gpl2uyoyJykkjyj0RejklesKoUhQqBnPnMb0Qvj6gJDsdIlUoqs0TMd0fcUkRqtsVFlqngmLiqLVGcaFC2EoBeE4S9leMoQnlHGBgOqinYAACzOyKGwnMB2DswImqrSqtJ2DYBomZ4Yl2CtpMA4l8o-JIkADsPsuCVmK2cCdxHRDx4JkJ0JrEJJ8JSeiJMqGARJQOJJ2JPJuJtadgHOixyMJJZJwJkqopQKWJ7aDh+AOh4xx2tIQAA","body":"function make_polynomial(variable, terms) {\n    return get(\"make\", \"polynomial\")(variable, terms);\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.87","id":"#ex-2.87","child":[{"body":"\n    Install\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_equal_to_zero"},{"body":"\n    for polynomials in the generic arithmetic package.  This will allow\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_term"},{"body":"\n    to work for polynomials with coefficients that are themselves polynomials.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.88","id":"#ex-2.88","child":[{"body":"\n    Extend the polynomial system to include\n    \n    subtraction of polynomials.\n    (Hint: You may find it helpful to define a generic negation operation.)\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"function sub_terms(L1, L2) {\n    if (is_empty_termlist(L1)) {\n        return L2;\n    } else if (is_empty_termlist(L2)) {\n        return L1;\n    } else {\n        const t1 = first_term(L1);\n        const t2 = first_term(L2);\n        return order(t1) > order(t2)\n               ? adjoin_term(t1, sub_terms(rest_terms(L1), L2))\n               : order(t1) < order(t2)\n               ? adjoin_term(t2, sub_terms(L1, rest_terms(L2)))\n               : adjoin_term(make_term(order(t1), \n                                       sub(coeff(t1), coeff(t2))),\n                             sub_terms(rest_terms(L1),\n                                       rest_terms(L2)));\n    }\n}\nfunction sub_poly(p1, p2) {\n    return is_same_variable(variable(p1), variable(p2))\n           ? make_poly(variable(p1),\n                       sub_terms(term_list(p1), term_list(p2)))\n           : error(list(p1, p2), \"polys not in same var -- sub_poly\");\n}"}]},{"tag":"EXERCISE","title":"Exercise 2.89","id":"#ex-2.89","child":[{"body":"Declare functions\n    that implement the term-list representation described above as\n    appropriate for dense polynomials.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.90","id":"#ex-2.90","child":[{"body":"\n    Suppose we want to have a polynomial system that is efficient for both\n    sparse and dense polynomials.  One way to do this is to allow both\n    kinds of term-list representations in our system.  The situation is\n    analogous to the complex-number example of\n    section ","tag":"#text"},{"tag":"REF","body":"2.4","href":"/sicpjs/2.4"},{"body":", where we allowed both\n    rectangular and polar representations. To do this we must distinguish\n    different types of term lists and make the operations on term lists\n    generic.  Redesign the polynomial system to implement this generalization.\n    This is a major effort, not a local change.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.91","id":"#ex-2.91","child":[{"body":"\n    A univariate polynomial can be divided by another one to produce a\n    \n    polynomial quotient and a polynomial remainder.  For example,\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      \\dfrac{x^5-1}{x^2 -1} & = & x^3 +x,\\ \\text{remainder }x-1\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    Division can be performed via long division.\n    That is, divide the highest-order term of the dividend by\n    the highest-order term of the divisor.  The result is the first term of the\n    quotient.  Next, multiply the result by the divisor, subtract that\n    from the dividend, and produce the rest of the answer by recursively\n    dividing the difference by the divisor.  Stop when the order of the\n    divisor exceeds the order of the dividend and declare the dividend to\n    be the remainder.  Also, if the dividend ever becomes zero, return\n    zero as both quotient and remainder.\n    \n    We can design a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_poly"},{"body":"function\n    on the model of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_poly"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"mul_poly"},{"body":".\n    The\n    function\n    checks to see if the two polys have the same variable.  If so,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_poly"},{"body":"\n    strips off the variable and passes the problem to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_terms"},{"body":",\n    which performs the division operation on term lists.\n    \n\tThe function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_poly"},{"body":"\n    finally reattaches the variable to the result supplied by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_terms"},{"body":".\n    It is convenient to design\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_terms"},{"body":"\n    to compute both the quotient and the remainder of a division.\n    \n\tThe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_terms"},{"body":"\n    can take two term lists as arguments and return a list of the quotient\n    term list and the remainder term list.\n    \n    Complete the following definition of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_terms"},{"body":"\n    by filling in the missing\n    \n\tparts.\n      \n    Use this to implement\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_poly"},{"body":",\n    which takes two polys as arguments and returns a list of the quotient and\n    remainder polys.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction div_terms(L1, L2) {\n    if (is_empty_termlist(L1)) {\n        return list(the_empty_termlist, the_empty_termlist);\n    } else {\n        const t1 = first_term(L1);\n        const t2 = first_term(L2);\n        if (order(t2) > order(t1)) {\n            return list(the_empty_termlist, L1);\n        } else {\n            const new_c = div(coeff(t1), coeff(t2));\n            const new_o = order(t1) - order(t2);\n            const rest_of_result = $\\langle{}$compute rest of result recursively$\\rangle$;\n            $\\langle{}$form and return complete result$\\rangle$\n        }\n    }\n}\n      "}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"Hierarchies of types in symbolic algebra","tag":"#text"}]},{"tag":"TEXT","id":"#p18","child":[{"body":"\n    Our polynomial system illustrates how objects of one type\n    (polynomials) may in fact be complex objects that have objects of many\n    different types as parts.  This poses no real difficulty in defining\n    generic operations.  We need only install appropriate generic operations\n    for performing the necessary manipulations of the parts of the\n    compound types.  In fact, we saw that polynomials form a kind of\n    \"","tag":"#text"},{"body":"recursive data abstraction,","tag":"#text"},{"body":"\" in that parts of a polynomial may\n    themselves be polynomials.  Our generic operations and our\n    data-directed programming style can handle this complication without\n    much trouble.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p19","child":[{"body":"\n    On the other hand, polynomial algebra is a system for which the data\n    types cannot be naturally arranged in a tower.  For instance, it is\n    possible to have polynomials in ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" whose\n    coefficients are polynomials in ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":".  It is also\n    possible to have polynomials in ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" whose\n    coefficients are polynomials in ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":".  Neither of\n    these types is \"","tag":"#text"},{"body":"above","tag":"#text"},{"body":"\" the other in any natural way, yet it is\n    often necessary to add together elements from each set.  There are several\n    ways to do this.  One possibility is to convert one polynomial to the type\n    of the other by expanding and rearranging terms so that both polynomials\n    have the same principal variable.  One can impose a towerlike structure on\n    this by ordering the variables and thus always converting any polynomial\n    to a \n    \"","tag":"#text"},{"body":"canonical form","tag":"#text"},{"body":"\" with the highest-priority variable\n    dominant and the lower-priority variables buried in the coefficients.\n    This strategy works fairly well, except that the conversion may expand\n    a polynomial unnecessarily, making it hard to read and perhaps less\n    efficient to work with.  The tower strategy is certainly not natural\n    for this domain or for any domain where the user can invent new types\n    dynamically using old types in various combining forms, such as\n    trigonometric functions, power series, and integrals.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p20","child":[{"body":"\n    It should not be surprising that controlling \n    \n    coercion is a serious problem in the design of large-scale\n    algebraic-manipulation systems. Much of the complexity of such systems is\n    concerned with relationships among diverse types.  Indeed, it is fair to\n    say that we do not yet completely understand coercion.  In fact, we do not\n    yet completely understand the concept of a data type.  Nevertheless, what\n    we know provides us with powerful structuring and modularity principles to\n    support the design of large systems.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.92","id":"#ex-2.92","child":[{"body":"\n    By imposing an ordering on variables, extend the polynomial package so\n    that addition and multiplication of polynomials works for polynomials\n    in different variables.  (This is not easy!)\n    ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h4","child":[{"body":"Extended exercise: Rational functions","tag":"#text"}]},{"tag":"TEXT","id":"#p21","child":[{"body":"\n    We can extend our generic arithmetic system to include ","tag":"#text"},{"tag":"EM","child":[{"body":"rational\n    functions","tag":"#text"}]},{"body":".  These are \"","tag":"#text"},{"body":"fractions","tag":"#text"},{"body":"\" whose numerator and\n    denominator are polynomials, such as\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{l}\n      \\dfrac{x+1}{x^3 -1}\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    The system should be able to add, subtract, multiply, and divide\n    rational functions, and to perform such computations as\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      \\dfrac{x+1}{x^3 -1}+\\dfrac{x}{x^2 -1} & = & \\dfrac{x^3 +2x^2 +3x +1}{x^4 +\n      x^3 -x-1}\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    (Here the sum has been simplified by removing common factors.\n    Ordinary \"","tag":"#text"},{"body":"cross multiplication","tag":"#text"},{"body":"\" would have produced a \n    fourth-degree polynomial over a fifth-degree polynomial.)\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p22","child":[{"body":"\n    If we modify our rational-arithmetic package so that it uses generic\n    operations, then it will do what we want, except for the problem\n    of reducing fractions to lowest terms.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.93","id":"#ex-2.93","child":[{"body":" \n    Modify the rational-arithmetic package to use generic operations, but\n    change\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_rat"},{"body":"\n    so that it does not attempt to reduce fractions to lowest terms.  Test\n    your system by calling\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_rational"},{"body":"\n    on two polynomials to produce a rational function\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"const p1 = make_polynomial(\"x\", list(make_term(2, 1), make_term(0, 1)));\nconst p2 = make_polynomial(\"x\", list(make_term(3, 1), make_term(0, 1)));\nconst rf = make_rational(p2, p1);"},{"body":"\n    Now add ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"rf"},{"body":" to itself, using\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add"},{"body":". You will observe that this addition\n    function\n    does not reduce fractions to lowest terms.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p23","child":[{"body":"\n    We can reduce polynomial fractions to lowest terms using the same idea\n    we used with integers: modifying\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_rat"},{"body":"\n    to divide both the numerator and the denominator by their greatest common\n    divisor. The notion of \n    \"","tag":"#text"},{"body":"greatest common divisor","tag":"#text"},{"body":"\" makes sense for polynomials.  In\n    fact, we can compute the GCD of two polynomials using essentially the\n    same Euclid's Algorithm that works for integers.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-7","body":"7","href":"/sicpjs/2.5.3#footnote-7"},{"body":"  The\n    integer version is\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":false,"body":"function gcd(a, b) {\n    return b === 0\n           ? a\n           : gcd(b, a % b);\n}"},{"body":"\n    Using this, we could make the obvious modification to define a GCD\n    operation that works on term lists:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":false,"body":"function gcd_terms(a, b) {\n    return is_empty_termlist(b)\n           ? a\n           : gcd_terms(b, remainder_terms(a, b));\n}"},{"body":"\n    where\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"remainder_terms"},{"body":"\n    picks out the remainder component of the list returned by the term-list\n    division operation\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_terms"},{"body":"\n    that was implemented in exercise ","tag":"#text"},{"tag":"REF","body":"2.91","href":"/sicpjs/2.5.3#ex-2.91"},{"body":".\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.94","id":"#ex-2.94","child":[{"body":"\n    Using\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_terms"},{"body":",\n    implement the\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"remainder_terms"},{"body":"\n    and use this to define\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd_terms"},{"body":"\n    as above.  Now write a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd_poly"},{"body":"\n    that computes the polynomial GCD of two polys. (The\n    function\n    should signal an error if the two polys are not in the same variable.)\n    Install in the system a generic operation\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"greatest_common_divisor"},{"body":"\n    that reduces to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd_poly"},{"body":"\n    for polynomials and to ordinary ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":" for\n    ordinary numbers.  As a test, try\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":false,"body":"const p1 = make_polynomial(\"x\", list(make_term(4, 1), make_term(3, -1),\n                                     make_term(2, -2), make_term(1, 2)));\nconst p2 = make_polynomial(\"x\", list(make_term(3, 1), make_term(1, -1)));\ngreatest_common_divisor(p1, p2);"},{"body":"\n    and check your result by hand.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.95","id":"#ex-2.95","child":[{"body":" \n    Define ","tag":"#text"},{"body":"$P_{1}$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$P_{2}$","tag":"LATEX"},{"body":", and\n    ","tag":"#text"},{"body":"$P_{3}$","tag":"LATEX"},{"body":" to be the polynomials\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"$P_{1}$","tag":"LATEX"},{"body":":\n\t","tag":"#text"}]},{"tag":"TD","child":[{"body":"$x^2 - 2x + 1$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"$P_{2}$","tag":"LATEX"},{"body":":\n\t","tag":"#text"}]},{"tag":"TD","child":[{"body":"$11x^2 + 7$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"$P_{3}$","tag":"LATEX"},{"body":":\n\t","tag":"#text"}]},{"tag":"TD","child":[{"body":"$13x + 5$","tag":"LATEX"}]}]}]},{"body":"\n    Now define ","tag":"#text"},{"body":"$Q_1$","tag":"LATEX"},{"body":" to be the product of\n    ","tag":"#text"},{"body":"$P_1$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$P_2$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$Q_2$","tag":"LATEX"},{"body":" to be the product of\n    ","tag":"#text"},{"body":"$P_1$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$P_3$","tag":"LATEX"},{"body":", and\n    use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"greatest_common_divisor"},{"body":"\n    (exercise ","tag":"#text"},{"tag":"REF","body":"2.94","href":"/sicpjs/2.5.3#ex-2.94"},{"body":") to compute the GCD of\n    ","tag":"#text"},{"body":"$Q_1$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$Q_2$","tag":"LATEX"},{"body":".\n    Note that the answer is not the same as ","tag":"#text"},{"body":"$P_1$","tag":"LATEX"},{"body":".\n    This example introduces noninteger operations into the computation, causing\n    difficulties with the GCD\n    \n\talgorithm.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-8","body":"8","href":"/sicpjs/2.5.3#footnote-8"},{"body":"\n    To understand what is happening, try tracing\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd_terms"},{"body":"\n    while computing the GCD or try performing the division by hand.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p24","child":[{"body":"\n    We can solve the problem exhibited in\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.95","href":"/sicpjs/2.5.3#ex-2.95"},{"body":" if\n    we use the following modification of the GCD algorithm (which really\n    works only in the case of polynomials with integer coefficients).\n    Before performing any polynomial division in the GCD computation, we\n    multiply the dividend by an integer constant factor, chosen to\n    guarantee that no fractions will arise during the division process.\n    Our answer will thus differ from the actual GCD by an integer constant\n    factor, but this does not matter in the case of reducing rational\n    functions to lowest terms; the GCD will be used to divide both the\n    numerator and denominator, so the integer constant factor will cancel\n    out.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p25","child":[{"body":"\n    More precisely, if ","tag":"#text"},{"body":"$P$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$Q$","tag":"LATEX"},{"body":" are polynomials, let\n    ","tag":"#text"},{"body":"$O_1$","tag":"LATEX"},{"body":" be the order of\n    ","tag":"#text"},{"body":"$P$","tag":"LATEX"},{"body":" (i.e., the order of the largest term of\n    ","tag":"#text"},{"body":"$P$","tag":"LATEX"},{"body":") and let ","tag":"#text"},{"body":"$O_2$","tag":"LATEX"},{"body":"\n    be the order of ","tag":"#text"},{"body":"$Q$","tag":"LATEX"},{"body":".  Let\n    ","tag":"#text"},{"body":"$c$","tag":"LATEX"},{"body":" be the leading coefficient of\n    ","tag":"#text"},{"body":"$Q$","tag":"LATEX"},{"body":".  Then it can be shown that, if we multiply\n    ","tag":"#text"},{"body":"$P$","tag":"LATEX"},{"body":" by the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"integerizing factor","tag":"#text"}]},{"body":"$c^{1+O_{1} -O_{2}}$","tag":"LATEX"},{"body":", the resulting polynomial\n    can  be divided by ","tag":"#text"},{"body":"$Q$","tag":"LATEX"},{"body":" by using the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_terms"},{"body":"\n    algorithm without introducing any fractions.  The operation of multiplying\n    the dividend by this constant and then dividing is sometimes called the \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"pseudodivision","tag":"#text"}]},{"body":" of ","tag":"#text"},{"body":"$P$","tag":"LATEX"},{"body":" by\n    ","tag":"#text"},{"body":"$Q$","tag":"LATEX"},{"body":".  The remainder of the division is\n    called the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"pseudoremainder","tag":"#text"}]},{"body":".\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.96","id":"#ex-2.96","child":[{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n        Implement the\n        function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pseudoremainder_terms"},{"body":",\n\t  \n\twhich is just like\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"remainder_terms"},{"body":"\n\texcept that it multiplies the dividend by the integerizing factor\n\tdescribed above before calling\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"div_terms"},{"body":".\n\t  \n        Modify\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd_terms"},{"body":"\n\tto use\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pseudoremainder_terms"},{"body":",\n\t  \n\tand verify that\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"greatest_common_divisor"},{"body":"\n\tnow produces an answer with integer coefficients on the example in\n\texercise ","tag":"#text"},{"tag":"REF","body":"2.95","href":"/sicpjs/2.5.3#ex-2.95"},{"body":".\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        The GCD now has integer coefficients, but they are larger than those\n        of ","tag":"#text"},{"body":"$P_1$","tag":"LATEX"},{"body":".  Modify\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd_terms"},{"body":"\n\tso that it removes common factors from the coefficients of the answer\n\tby dividing all the coefficients by their (integer) greatest common\n\tdivisor.\n      ","tag":"#text"}]}]}]},{"tag":"TEXT","id":"#p26","child":[{"body":"\n    Thus, here is how to reduce a rational function to lowest terms:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tCompute the GCD of the numerator and denominator, using\n\tthe version of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd_terms"},{"body":"\n\tfrom exercise ","tag":"#text"},{"tag":"REF","body":"2.96","href":"/sicpjs/2.5.3#ex-2.96"},{"body":".\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tWhen you obtain the GCD, multiply both numerator and\n\tdenominator by the same integerizing factor before dividing through by\n\tthe GCD, so that division by the GCD will not introduce any noninteger\n\tcoefficients.  As the factor you can use the leading coefficient of\n\tthe GCD raised to the power\n\t","tag":"#text"},{"body":"$1+O_{1} -O_{2}$","tag":"LATEX"},{"body":", where\n\t","tag":"#text"},{"body":"$O_{2}$","tag":"LATEX"},{"body":" is the order of the GCD and\n\t","tag":"#text"},{"body":"$O_{1}$","tag":"LATEX"},{"body":" is the maximum of the orders of the\n\tnumerator and denominator.  This will ensure that dividing the\n\tnumerator and denominator by the GCD will not introduce any fractions.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tThe result of this operation will be a numerator and denominator\n\twith integer coefficients.  The coefficients will normally be very\n\tlarge because of all of the integerizing factors, so the last step is\n\tto remove the redundant factors by computing the (integer) greatest\n\tcommon divisor of all the coefficients of the numerator and the\n\tdenominator and dividing through by this factor.\n      ","tag":"#text"}]}]}]},{"tag":"EXERCISE","title":"Exercise 2.97","id":"#ex-2.97","child":[{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\tImplement this algorithm as a\n\tfunction","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce_terms"},{"body":"\n\tthat takes two term lists ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"d"},{"body":" as arguments and returns a list\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"nn"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"dd"},{"body":",\n\twhich are ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"d"},{"body":" reduced to lowest terms via the\n\talgorithm given above. Also write a\n\tfunction","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce_poly"},{"body":",\n\t  \n\tanalogous to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_poly"},{"body":",\n\t  \n\tthat checks to see if the two polys have the same variable.  If so,\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce_poly"},{"body":"\n\tstrips off the variable and passes the problem to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce_terms"},{"body":",\n\t  \n\tthen reattaches the variable to the two term lists supplied by\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce_terms"},{"body":".\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        Define a\n        function\n        analogous to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce_terms"},{"body":"\n\tthat does what the original\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_rat"},{"body":"\n\tdid for integers:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":false,"body":"function reduce_integers(n, d) {\n    const g = gcd(n, d);\n    return list(n / g, d / g);\n}"},{"body":"\n        and define\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce"},{"body":" as a generic operation that calls\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_generic"},{"body":"\n\tto dispatch\t\n\t\n\t    either to\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce_poly"},{"body":"\n\t(for ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"polynomial"},{"body":" arguments) or\n\tto ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce_integers"},{"body":"\n\t(for\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"javascript_number"},{"body":"\n\targuments). You can now easily make the rational-arithmetic package\n\treduce fractions to lowest terms by having\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_rat"},{"body":"\n\tcall ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reduce"},{"body":" before combining the given\n        numerator and denominator to form a rational number. The system now\n        handles rational expressions in either integers or polynomials.\n        To test your program, try the example at the beginning of this\n        extended exercise:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":false,"body":"const p1 = make_polynomial(\"x\", list(make_term(1, 1), make_term(0, 1)));\nconst p2 = make_polynomial(\"x\", list(make_term(3, 1), make_term(0, -1)));\nconst p3 = make_polynomial(\"x\", list(make_term(1, 1)));\nconst p4 = make_polynomial(\"x\", list(make_term(2, 1), make_term(0, -1)));\n\nconst rf1 = make_rational(p1, p2);\nconst rf2 = make_rational(p3, p4);\n\nadd(rf1, rf2);"},{"body":"\n        See if you get the correct answer, correctly reduced to lowest terms.\n      ","tag":"#text"}]}]}]},{"tag":"TEXT","id":"#p27","child":[{"body":"\n    The GCD computation is at the heart of any system that does operations\n    on rational functions.  The algorithm used above, although\n    mathematically straightforward, is extremely slow.  The slowness is\n    due partly to the large number of division operations and partly to\n    the enormous size of the intermediate coefficients generated by the\n    pseudodivisions.\n    \n    One of the active areas in the development of\n    algebraic-manipulation systems is the design of better algorithms for\n    computing polynomial GCDs.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-9","body":"9","href":"/sicpjs/2.5.3#footnote-9"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/2.5.3#footnote-link-1","child":[{"body":"On the other hand, we will\n      allow polynomials whose coefficients are themselves polynomials in other\n      variables.  This will give us essentially the same representational\n      power as a full multivariate system, although it does lead to coercion\n      problems, as discussed below.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/2.5.3#footnote-link-2","child":[{"body":"For univariate\n    polynomials, giving the value of a polynomial at a given set of points can\n    be a particularly good representation.  This makes polynomial arithmetic\n    extremely simple.  To obtain, for example, the sum of two polynomials\n    represented in this way, we need only add the values of the\n    polynomials at corresponding points.  To transform back to a more\n    familiar representation, we can use the \n    \n    Lagrange interpolation formula, which shows how to recover the coefficients\n    of a polynomial of degree ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" given the values\n    of the polynomial at ","tag":"#text"},{"body":"$n+1$","tag":"LATEX"},{"body":" points.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/2.5.3#footnote-link-3","child":[{"body":"This operation is very much like the ordered\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":"\n    operation we developed in exercise ","tag":"#text"},{"tag":"REF","body":"2.62","href":"/sicpjs/2.3.3#ex-2.62"},{"body":".\n    In fact, if we think of the terms of the polynomial as a set ordered\n    according to the power of the indeterminate, then the program that\n    produces the term list for a sum is almost identical to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/2.5.3#footnote-link-4","child":[{"body":"To\n    make this work completely smoothly, we should also add to our generic\n    arithmetic system the ability to coerce a \"","tag":"#text"},{"body":"number","tag":"#text"},{"body":"\" to a\n    polynomial by regarding it as a polynomial of degree zero whose coefficient\n    is the number.  This is necessary if we are going to perform operations\n    such as\n    ","tag":"#text"},{"body":"\n      \\[\n      {\\left[ x^2 +(y+1)x+5\\right]+ \\left[ x^2 +2x+1\\right]}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    which requires adding the coefficient ","tag":"#text"},{"body":"$y+1$","tag":"LATEX"},{"body":" to\n    the coefficient 2.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/2.5.3#footnote-link-5","child":[{"body":"In\n    these polynomial examples, we assume that we have implemented the generic\n    arithmetic system using the type mechanism suggested in\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.78","href":"/sicpjs/2.5.1#ex-2.78"},{"body":". Thus, coefficients\n    that are ordinary numbers will be represented as the numbers themselves\n    rather than as pairs whose\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    is the\n    string\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"javascript_number\""},{"body":".\n      ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-6","count":6,"href":"/sicpjs/2.5.3#footnote-link-6","child":[{"body":"Although we are assuming\n    that term lists are ordered, we have implemented\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_term"},{"body":"\n    to simply\n    \n\tadjoin the new term to the front of the existing term list.\n      \n    We can get away with this so\n    long as we guarantee that the\n    functions\n    (such as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"add_terms"},{"body":")\n    that use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_term"},{"body":"\n    always call it with a higher-order term than appears in the list.  If we\n    did not want to make such a guarantee, we could have implemented\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_term"},{"body":"\n    to be similar to the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":"\n    constructor for the ordered-list\n    representation of sets\n    (exercise ","tag":"#text"},{"tag":"REF","body":"2.61","href":"/sicpjs/2.3.3#ex-2.61"},{"body":").\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-7","count":7,"href":"/sicpjs/2.5.3#footnote-link-7","child":[{"body":"The fact\n    that \n    \n    Euclid's Algorithm works for polynomials is formalized in algebra\n    by saying that polynomials form a kind of algebraic domain called a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Euclidean ring","tag":"#text"}]},{"body":".  A Euclidean ring is a domain that admits\n    addition, subtraction, and commutative multiplication, together with a\n    way of assigning to each element ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" of the\n    ring a positive integer\n    \"","tag":"#text"},{"body":"measure","tag":"#text"},{"body":"\"","tag":"#text"},{"body":"$m(x)$","tag":"LATEX"},{"body":" with the\n    properties that ","tag":"#text"},{"body":"$m(xy)\\geq m(x)$","tag":"LATEX"},{"body":" for any nonzero\n    ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" and that,\n    given any ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":",\n    there exists a ","tag":"#text"},{"body":"$q$","tag":"LATEX"},{"body":" such that\n    ","tag":"#text"},{"body":"$y=qx+r$","tag":"LATEX"},{"body":" and either\n    ","tag":"#text"},{"body":"$r=0$","tag":"LATEX"},{"body":" or\n    ","tag":"#text"},{"body":"$m(r) < m(x)$","tag":"LATEX"},{"body":".  From an abstract point of\n    view, this is what is needed to prove that Euclid's Algorithm works.\n    For the domain of integers, the measure ","tag":"#text"},{"body":"$m$","tag":"LATEX"},{"body":" of an\n    integer is the absolute value of the integer itself.  For the domain of\n    polynomials, the measure of a polynomial is its degree.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-8","count":8,"href":"/sicpjs/2.5.3#footnote-link-8","child":[{"body":"In JavaScript, division of integers can produce\n\tlimited-precision decimal numbers, and thus we\n\tmay fail to get a valid divisor.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-9","count":9,"href":"/sicpjs/2.5.3#footnote-link-9","child":[{"body":"One extremely efficient and\n    elegant method for computing \n    \n    polynomial GCDs was discovered by \n    \n    Richard Zippel (1979).  The method is a probabilistic algorithm, as is the\n    fast test for primality that we discussed in chapter ","tag":"#text"},{"tag":"REF","body":"1","href":"/sicpjs/1"},{"body":".\n    Zippel's book (1993) describes this method, together with other ways\n    to compute polynomial GCDs.","tag":"#text"}]}]