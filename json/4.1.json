[{"id":"/sicpjs/4.1","tag":"TITLE","body":"4.1  The Metacircular Evaluator"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    Our evaluator for \n    JavaScript \n    will be implemented as a \n    JavaScript \n    program.  It may\n    seem circular to think about evaluating \n    JavaScript \n    programs using an evaluator that is itself implemented in \n    JavaScript.\n    However, evaluation is a process, so it is appropriate to describe the\n    evaluation process using\n    JavaScript,\n    which, after all, is our tool for describing processes.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/4.1#footnote-1"},{"body":"  \n    An evaluator that is written in the same language\n    that it evaluates is said to be\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"metacircular","tag":"#text"}]},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The metacircular evaluator is essentially a \n    JavaScript\n    formulation of the\n    \n    environment model of evaluation described in\n    section ","tag":"#text"},{"tag":"REF","body":"3.2","href":"/sicpjs/3.2"},{"body":".\n    \n\tRecall that the model specifies the\n\tevaluation of function application in two basic steps:\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\t    To evaluate a function application, evaluate the \n\t    subexpressions and then apply the\n\t    value of the function subexpression to the values of the argument\n            subexpressions.\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        To apply a compound\n\tfunction\n\tto a set of arguments, evaluate the\n        body of the\n\tfunction\n\tin a new environment.  To construct this\n        environment, extend the environment part of the\n\tfunction\n\tobject by a\n        frame in which the\n\t\n\tparameters of the\n\tfunction\n\tare bound to\n\tthe arguments to which the\n\tfunction\n\tis applied.\n      ","tag":"#text"}]}]}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    These two rules describe the essence of the evaluation process, a basic\n    \n    cycle in which \n    statements and\n    expressions to be evaluated in environments are reduced to\n    functions\n    to be applied to arguments, which in turn are reduced to new \n    statements and\n    expressions to be evaluated in new environments, and so on, until we get\n    down to\n    \n\tnames,\n      \n    whose values are looked up in the environment, and to \n    operators and primitive functions,\n    which are applied directly (see\n    figure ","tag":"#text"},{"tag":"REF","body":"4.1","href":"/sicpjs/4.1.1#fig-4.1"},{"body":").","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/4.1#footnote-2"},{"body":"\n    This evaluation cycle will be embodied by the interplay between the two\n    critical\n    functions\n    in the evaluator,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":"\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply"},{"body":", which are described in\n    section ","tag":"#text"},{"tag":"REF","body":"4.1.1","href":"/sicpjs/4.1.1"},{"body":"\n    (see figure ","tag":"#text"},{"tag":"REF","body":"4.1","href":"/sicpjs/4.1.1#fig-4.1"},{"body":").\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n\tThe implementation of the evaluator will depend upon functions that\n\tdefine the ","tag":"#text"},{"tag":"EM","child":[{"body":"syntax","tag":"#text"}]},{"body":" of the statements and\n\texpressions to be evaluated.\n\tWe will use\n\t\n\tdata abstraction to make the evaluator independent of the\n\trepresentation of the language.\n\tFor example, rather than committing\n\tto a choice that an assignment is to be represented by a \n\tstring beginning with a name followed by\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"="},{"body":", we use an abstract predicate\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_assignment"},{"body":" to test for an\n\tassignment, and we use abstract\n\tselectors ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assignment_symbol"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assignment_value_expression"},{"body":" to\n\taccess the parts of an assignment.\n\tThe data abstraction layers presented in\n\tsection ","tag":"#text"},{"tag":"REF","body":"4.1.2","href":"/sicpjs/4.1.2"},{"body":"\n\twill allow the evaluator to remain independent of concrete syntactic\n\tissues, such as the keywords of the interpreted language, and of the\n\tchoice of data structures that represent the program components.\n      \n    There are also\n    operations, described in\n    section ","tag":"#text"},{"tag":"REF","body":"4.1.3","href":"/sicpjs/4.1.3"},{"body":", that specify the\n    representation of\n    functions\n    and environments.  For example,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_function"},{"body":"\n    constructs compound\n    functions,","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup_symbol_value"},{"body":"\n    accesses the values of\n    names,\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_primitive_function"},{"body":"\n    applies a primitive\n    function\n    to a given list of arguments.\n  ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/4.1#footnote-link-1","child":[{"body":"Even so,\n    there will remain important aspects of the evaluation process that are not\n    elucidated by our evaluator.  The most important of these are the detailed\n    mechanisms by which\n    functions\n    call other\n    functions\n    and return values to their callers. We will address these issues in\n    chapter ","tag":"#text"},{"tag":"REF","body":"5","href":"/sicpjs/5"},{"body":", where we take a closer look at the evaluation process by\n    implementing the evaluator as a simple register machine.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/4.1#footnote-link-2","child":[{"body":"If we grant ourselves\n    the ability to apply primitives,\n    then what remains for us to implement in the evaluator?  The\n    \n    job of the\n    evaluator is not to specify the primitives of the language, but rather to\n    provide the connective tissue—the means of combination and the means\n    of abstraction—that binds a collection of primitives to form a\n    language.  Specifically:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tThe evaluator enables us to deal with nested expressions. For example,\n\talthough simply applying primitives would suffice for evaluating the\n\texpression\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"2 * 6"},{"body":",\n\tit is not adequate for handling \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"2 * (1 + 5)"},{"body":".\n\t  \n\tAs far as the \n\t\n\t    operator\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"*"},{"body":"\n\tis concerned, its arguments must be numbers, and it would choke if we\n\tpassed it the expression\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"1 + 5"},{"body":"\n\tas an argument.\tOne important role of the evaluator is to choreograph\n\t\n\tcomposition so that\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"1 + 5"},{"body":"\n\tis reduced to 6 before being passed as an \n\t\n\t    argument to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"*"},{"body":".\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tThe evaluator allows us to use\n\tnames.\n\tFor example, the \n\taddition operator\n\thas no way to deal with expressions such as\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x + 1"},{"body":".\n\tWe need an evaluator to keep track of\n\tnames\n\tand obtain their values before invoking the \n\toperators.","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tThe evaluator allows us to define compound\n\tfunctions.\n\t    This involves knowing how to use these functions in evaluating \n\t    expressions and providing a mechanism that enables functions\n\t    to accept arguments.\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"The evaluator provides the other syntactic forms of\n\t  the language such as conditionals and blocks.\n\t","tag":"#text"}]}]}]}]