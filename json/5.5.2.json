[{"id":"/sicpjs/5.5.2","tag":"TITLE","body":"5.5.2  \n    Compiling\n    \n      \n      Components"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In this section and the next we implement the code generators to which the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":"function\n    dispatches.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Compiling linkage code","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    In general, the output of each code generator will end with\n    instructions—generated by the\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_linkage"},{"body":"—that\n      \n    implement the required linkage.  If the linkage is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n    then\n    we must generate the instruction\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"go_to(reg(\"continue\"))"},{"body":".\n      \n    This needs the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register and does not\n    modify any registers.\n    If the linkage is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":",\n      \n    then we needn't include any additional instructions.  Otherwise, the\n    linkage is a label, and we generate a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"go_to"},{"body":"\n    to that label, an instruction that does not need or modify\n    any registers.","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"function compile_linkage(linkage) {\n    return linkage === \"return\"\n           ? make_instruction_sequence(list(\"continue\"), null,\n                                       list(go_to(reg(\"continue\"))))\n           : linkage === \"next\"\n           ? make_instruction_sequence(null, null, null)\n           : make_instruction_sequence(null, null, \n                                       list(go_to(label(linkage))));\n}"},{"body":"\n    The linkage code is appended to an instruction sequence by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register, since a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n    linkage will\n    require the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register:\n    If the given instruction sequence modifies\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" and the linkage code needs it,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" will be saved and restored.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"function end_with_linkage(linkage, instruction_sequence) {\n    return preserving(list(\"continue\"),\n                      instruction_sequence,\n                      compile_linkage(linkage));\n}"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Compiling simple\n    \n\tcomponents\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    The code generators for\n    literal expressions and names\n    construct instruction\n    sequences that assign the required value to the target register\n    and then proceed as specified by the linkage descriptor.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n        The literal value is extracted at compile time from the component being\n        compiled and put into the constant part of the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assign"},{"body":" instruction. For a name, an\n        instruction is generated to use the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup_symbol_value"},{"body":" operation when\n        the compiled program is run, to look up the value associated with a\n        symbol in the current environment. Like a literal value, the symbol is\n        extracted at compile time from the component being compiled. Thus\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"symbol_of_name(component)"},{"body":" is\n        executed only once, when the program is being compiled, and the symbol\n        appears as a constant in the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assign"},{"body":" instruction.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"function compile_literal(component, target, linkage) {\n    const literal = literal_value(component);\n    return end_with_linkage(linkage,\n               make_instruction_sequence(null, list(target),\n                   list(assign(target, constant(literal)))));\n}\nfunction compile_name(component, target, linkage) {\n    const symbol = symbol_of_name(component);\n    return end_with_linkage(linkage,\n               make_instruction_sequence(list(\"env\"), list(target),\n                   list(assign(target,\n                               list(op(\"lookup_symbol_value\"),\n                                    constant(symbol),\n                                    reg(\"env\"))))));\n}"},{"body":"These\n    assignment instructions modify the target register,\n    and the one that looks up a\n    \n\tsymbol\n      \n    needs the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Assignments and\n    declarations\n    are handled much as they are in the\n    interpreter.\n    \n        The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_assignment_declaration"},{"body":"\n        recursively generates code that computes the value to be\n        associated with the symbol and appends to it a two-instruction\n        sequence that updates the value associated with the symbol\n        in the environment and assigns the value of the whole component\n        \n (the assigned value for an assignment or ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":" for a declaration) \n        to the target register. \n        \n        \n        The recursive compilation has target\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" and linkage\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":" so that the code\n        will put its result into ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":"\n        and continue with the code that is appended after it. The\n        appending is done preserving ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":",\n        since the environment is needed for updating the symbol–value\n        association and the code for computing the value could be the compilation\n        of a complex expression that might modify the registers in\n        arbitrary ways.\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"function compile_assignment(component, target, linkage) {\n    return compile_assignment_declaration(\n               assignment_symbol(component),\n               assignment_value_expression(component),\n               reg(\"val\"),\n               target, linkage);\n}\n\nfunction compile_declaration(component, target, linkage) {\n    return compile_assignment_declaration(\n               declaration_symbol(component),\n               declaration_value_expression(component),\n               constant(undefined),\n               target, linkage);\n}\nfunction compile_assignment_declaration(\n             symbol, value_expression, final_value,\n             target, linkage) {\n    const get_value_code = compile(value_expression, \"val\", \"next\");\n    return end_with_linkage(linkage,\n               preserving(list(\"env\"),\n                   get_value_code,\n                   make_instruction_sequence(list(\"env\", \"val\"),\n                                             list(target),\n                       list(perform(list(op(\"assign_symbol_value\"),\n                                         constant(symbol),\n                                         reg(\"val\"),\n                                         reg(\"env\"))),\n                            assign(target, final_value)))));\n}"},{"body":"\n    The appended two-instruction sequence requires\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":"\n    and modifies the target.  Note that although we preserve\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" for this sequence, we do not preserve\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":", because the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"get_value_code"},{"body":"\n    is designed to explicitly place its result in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" for use by this sequence.\n    (In fact, if we did preserve ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":", we would\n    have a bug, because this would cause the previous contents of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" to be restored right after the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"get_value_code"},{"body":"\n    is run.)\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"Compiling\n    \n        conditionals\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    The code for\n    \n\ta conditional\n      \n    compiled with a given target and linkage has the form\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\langle{}$compilation of predicate, target val, linkage \"next\"$\\rangle$\n  test(list(op(\"is_falsy\"), reg(\"val\"))),\n  branch(label(\"false_branch\")),\n\"true_branch\",\n  $\\langle{}$compilation of consequent with given target and given linkage or after_cond$\\rangle$\n\"false_branch\",\n  $\\langle{}$compilation of alternative with given target and linkage$\\rangle$\n\"after_cond\"\n      "}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    To generate this code, we compile the predicate, consequent,\n    and alternative, and combine the resulting code with instructions\n    to test the predicate result and with newly generated labels to mark the\n    true and false branches and the end of the\n    conditional.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.5.2#footnote-1"},{"body":"\n    In this arrangement of code, we must branch around the true branch\n    if the test is false.  The only slight complication is in how the\n    linkage for the true branch should be handled.  If the linkage for the\n    conditional is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n    or a label, then the\n    true and false branches will both use this same linkage.  If the linkage is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":",\n      \n    the true branch ends with a jump around\n    the code for the false branch to the label at the end of the conditional.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"function compile_conditional(component, target, linkage) {\n    const t_branch = make_label(\"true_branch\");\n    const f_branch = make_label(\"false_branch\");\n    const after_cond = make_label(\"after_cond\");\n    const consequent_linkage =\n            linkage === \"next\" ? after_cond : linkage;\n    const p_code = compile(conditional_predicate(component),\n                           \"val\", \"next\");\n    const c_code = compile(conditional_consequent(component),\n                           target, consequent_linkage);\n    const a_code = compile(conditional_alternative(component),\n                           target, linkage);\n    return preserving(list(\"env\", \"continue\"),\n             p_code,\n             append_instruction_sequences(\n               make_instruction_sequence(list(\"val\"), null,\n                 list(test(list(op(\"is_falsy\"), reg(\"val\"))),\n                      branch(label(f_branch)))),\n               append_instruction_sequences(\n                 parallel_instruction_sequences(\n                   append_instruction_sequences(t_branch, c_code),\n                   append_instruction_sequences(f_branch, a_code)),\n                 after_cond)));\n}"},{"body":"\n\t      The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register\n      \n    is preserved around the predicate code\n    because it could be needed by the true and false \n      branches, and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" is preserved because it could\n    be needed by the linkage code in those branches.\n  The code for the true and\n    false branches (which are not executed sequentially) is appended using a\n    special combiner\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"parallel_instruction_sequences"},{"body":"\n    described in\n    section ","tag":"#text"},{"tag":"REF","body":"5.5.4","href":"/sicpjs/5.5.4"},{"body":".\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h4","child":[{"body":"Compiling sequences","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    The compilation of\n    \n        statement sequences\n\tparallels their evaluation\n\tin the explicit-control evaluator with one exception:\n  If a return statement appears anywhere in a sequence, we treat\n  it as if it were the last statement.\n      \n    Each\n    \n        statement\n      \n    of the sequence is compiled—the last\n    \n        statement (or a return statement)\n      \n    with\n    the linkage specified for the sequence, and the other\n    \n        statements\n      \n    with\n    linkage\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":"\n    (to execute the rest of the\n    sequence). The instruction sequences for the individual\n    \n        statements\n      \n    are\n    appended to form a single instruction sequence, such that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" (needed for the rest of the\n    sequence)\n      and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" (possibly needed\n      for the linkage at the end of the sequence)\n      are preserved.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.5.2#footnote-2"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"function compile_sequence(seq, target, linkage) {\n    return is_empty_sequence(seq)\n           ? compile_literal(make_literal(undefined), target, linkage)\n           : is_last_statement(seq) ||\n                 is_return_statement(first_statement(seq))\n           ? compile(first_statement(seq), target, linkage)\n           : preserving(list(\"env\", \"continue\"),\n                 compile(first_statement(seq), target, \"next\"),\n                 compile_sequence(rest_statements(seq), \n                                  target, linkage));\n}"},{"body":"\n      Treating a return statement as if it were the last statement in a sequence\n      avoids compiling any \"","tag":"#text"},{"body":"dead code","tag":"#text"},{"body":"\" after the return statement that can\n      never be executed.\n      Removing the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_return_statement"},{"body":" check does not change the behavior\n      of the object program; however,\n      there are many reasons not to compile dead code, which are beyond the scope of this book\n      (security, compilation time, size of the object code, etc.),\n      and many compilers give warnings for dead code.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/5.5.2#footnote-3"}]},{"tag":"SUBHEADING","id":"#h5","child":[{"body":"\n\t  Compiling blocks\n\t","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n\tA\n\t\n\tblock is compiled by prepending an ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assign"},{"body":" instruction to the compiled\n\tbody of the block. The assignment extends the current environment by a frame\n\tthat binds the names declared in the block to the value\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"*unassigned*\""},{"body":". This operation\n\tboth needs and modifies the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"env"},{"body":" register.\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"function compile_block(stmt, target, linkage) {\n    const body = block_body(stmt);\n    const locals = scan_out_declarations(body);\n    const unassigneds = list_of_unassigned(locals);\n    return append_instruction_sequences(\n               make_instruction_sequence(list(\"env\"), list(\"env\"),\n                   list(assign(\"env\", list(op(\"extend_environment\"),\n                                           constant(locals),\n                                           constant(unassigneds),\n                                           reg(\"env\"))))),\n               compile(body, target, linkage));\n}"}]},{"tag":"SUBHEADING","id":"#h6","child":[{"body":"Compiling\n\t\n\t    lambda\n\t  \n\texpressions","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n\tLambda expressions\n\t\n\tconstruct\n\tfunctions.\n\tThe object code for a lambda expression must have the form\n\t","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\langle{}$construct function object and assign it to target register$\\rangle$\n$\\langle{}$linkage$\\rangle$\n\t  "},{"body":"\n\tWhen we compile the lambda expression, we also generate the code for the\n\tfunction\n\tbody. Although the body won't be executed at the time of\n\tfunction\n\tconstruction, it is convenient to insert it into the object code right after\n\tthe code for the\n\tlambda expression.\n\tIf the linkage for the lambda expression is a label or\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":",\n\t  \n\tthis is fine.  But if the linkage is\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":",\n\t  \n\twe will need to skip around the code for\n\tthe\n\tfunction\n\tbody by using a linkage that jumps to a label that is inserted after the\n\tbody.  The object code thus has the form\n\t","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n$\\langle{}$construct function object and assign it to target register$\\rangle$\n$\\langle{}$code for given linkage$\\rangle$ $or$ go_to(label(\"after_lambda\"))\n$\\langle{}$compilation of function body$\\rangle$\n\"after_lambda\"\n\t  "}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n\t    The function\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_expression"},{"body":"\n\tgenerates the code for constructing the\n\tfunction\n\tobject followed by the code for the\n\tfunction\n\tbody. The\n\tfunction\n\tobject will be constructed at run time by combining the current environment\n\t(the environment at the point of declaration) with the entry point to the\n\tcompiled\n\tfunction\n\tbody (a newly generated label).","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/5.5.2#footnote-4"},{"tag":"SNIPPET","latex":false,"id":8,"eval":false,"body":"function compile_lambda_expression(exp, target, linkage) {\n    const fun_entry = make_label(\"entry\");\n    const after_lambda = make_label(\"after_lambda\");\n    const lambda_linkage =\n            linkage === \"next\" ? after_lambda : linkage;\n    return append_instruction_sequences(\n               tack_on_instruction_sequence(\n                   end_with_linkage(lambda_linkage,\n                       make_instruction_sequence(list(\"env\"),\n                                                 list(target),\n                           list(assign(target,\n                                    list(op(\"make_compiled_function\"),\n                                         label(fun_entry),\n                                         reg(\"env\")))))),\n                   compile_lambda_body(exp, fun_entry)),\n               after_lambda);\n}"},{"body":"\n\t    The function\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_expression"},{"body":"\n\tuses the special combiner\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tack_on_instruction_sequence"},{"body":"\n\t(from section ","tag":"#text"},{"tag":"REF","body":"5.5.4","href":"/sicpjs/5.5.4"},{"body":") rather\n\tthan\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_instruction_sequences"},{"body":"\n\tto append the\n\tfunction\n\tbody to the lambda expression code, because the\n\tbody is not part of the sequence of instructions that will be executed when\n\tthe combined sequence is entered; rather, it is in the sequence only because\n\tthat was a convenient place to put it.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n\t    The function\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_body"},{"body":"\n\tconstructs the code for the body of the\n\tfunction.\n\tThis code begins with a label for the entry point.  Next come instructions\n\tthat will cause the runtime evaluation environment to switch to the correct\n\tenvironment for evaluating the\n\tfunction\n\tbody—namely, the\n\t\n\tenvironment of the\n\tfunction,\n\textended to include the bindings of the\n\t\n\tparameters to the arguments\n\twith which the\n\tfunction\n\tis called.  After this comes the code for the\n\t\n\t\n            function body, augmented to ensure that it ends with a return statement.\n\t  \n            The\n            augmented body is compiled with target ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" so that its return value will be\n            placed in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":".  The linkage descriptor passed to this compilation is\n            irrelevant, as it will be ignored.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/5.5.2#footnote-5"},{"body":"\n\t    Since a linkage argument is required, we arbitrarily pick ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":".\n\t  ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":false,"body":"function compile_lambda_body(exp, fun_entry) {\n    const params  = lambda_parameter_symbols(exp);\n    return append_instruction_sequences(\n        make_instruction_sequence(list(\"env\", \"fun\", \"argl\"),\n                                  list(\"env\"),\n            list(fun_entry,\n                 assign(\"env\",\n                        list(op(\"compiled_function_env\"),\n                             reg(\"fun\"))),\n                 assign(\"env\",\n                        list(op(\"extend_environment\"),\n                             constant(params),\n                             reg(\"argl\"),\n                             reg(\"env\"))))),\n        compile(append_return_undefined(lambda_body(exp)),\n                \"val\", \"next\"));\n}"}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n\t    To ensure that all functions end by executing a return statement,\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_body"},{"body":"\n\t    appends to the lambda body a return statement whose return expression is the literal\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":".\n\t    To do so, it uses the function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_return_undefined"},{"body":",\n\t    which constructs the parser's tagged-list representation (from section ","tag":"#text"},{"tag":"REF","body":"4.1.2","href":"/sicpjs/4.1.2"},{"body":") of a \n\t    sequence consisting of the body and a ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return undefined;"},{"body":" statement.\n\t    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":false,"body":"function append_return_undefined(body) {\n    return list(\"sequence\", list(body,\n                                 list(\"return_statement\",\n                                      list(\"literal\", undefined))));\n}"},{"body":"\n\t    This simple transformation of lambda bodies is a third way to ensure that a\n\t    function that does not return explicitly has the return value\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":".\n\t    In the metacircular evaluator, we used a return-value object, which also played a\n\t    role in stopping a sequence evaluation.\n\t    In the explicit-control evaluator, functions that did not return explicitly continued\n\t    to an entry point that stored ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":"\n\t    in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":".\n\t    See exercise ","tag":"#text"},{"tag":"REF","body":"5.34","href":"/sicpjs/5.5.2#ex-5.34"},{"body":" for a more elegant way\n\t    to handle insertion of return statements.\n\t    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.33","id":"#ex-5.33","child":[{"body":"\n\tFootnote ","tag":"#text"},{"tag":"REF","body":3,"href":"/sicpjs/5.5.2#footnote-3"},{"body":" pointed out that the compiler does not\n\tidentify all instances of\n\t\n\tdead code. What would be required of a compiler to\n\tdetect all instances of dead code?\n\t","tag":"#text"},{"tag":"TEXT","id":"#p15","child":[{"body":"\n\t  Hint: The answer depends on how we define dead code. One possible (and useful)\n\t  definition is \"","tag":"#text"},{"body":"code following a return statement in a sequence","tag":"#text"},{"body":"\"—but\n\t  what about code in the consequent\n\t  branch of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"if (false) "},{"body":"$\\ldots$","tag":"LATEX"},{"body":" or\n\t  code following a\n\t  call to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"run_forever()"},{"body":" in exercise ","tag":"#text"},{"tag":"REF","body":"4.15","href":"/sicpjs/4.1.5#ex-4.15"},{"body":"?\n\t","tag":"#text"}]}]},{"tag":"EXERCISE","title":"Exercise 5.34","id":"#ex-5.34","child":[{"body":"\n        The current design of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_return_undefined"},{"body":"\n        is a bit crude: It always appends a\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return undefined;"},{"body":" to a lambda body, even if there is already a return statement in every execution\n\tpath of the body. Rewrite\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_return_undefined"},{"body":" so that it inserts\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return undefined;"},{"body":" at the end of only\n\tthose paths that do not contain a return statement. Test your\n        solution on the functions below, substituting any expressions for\n        ","tag":"#text"},{"body":"$e_1$","tag":"LATEX"},{"body":" and\n        ","tag":"#text"},{"body":"$e_2$","tag":"LATEX"},{"body":"\n        and any (non-return) statements for\n        ","tag":"#text"},{"body":"$s_1$","tag":"LATEX"},{"body":" and\n\t","tag":"#text"},{"body":"$s_2$","tag":"LATEX"},{"body":".\n        In ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"t"},{"body":", a return statement should be\n\tadded either at both ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"(*)"},{"body":"'s or just at\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"(**)"},{"body":".\n        In ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"w"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"h"},{"body":", a return statement should be added\n\tat one of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"(*)"},{"body":"'s.\n        In ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"m"},{"body":", no return statement should be added.\n\t","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction t(b) {   function w(b) {    function m(b) {    function h(b1, b2) {\n   if (b) {          if (b) {           if (b) {           if (b1) {\n      $s_1~~$              return $e_1;~$         return $e_1;~$         return $e_1$;\n      (*)                                                  } else {\n   } else {          } else {           } else {              if (b2) {\n      $s_2~~$               $s_1~~$               return $e_2$;             $s_1$\n      (*)               (*)                                      (*)\n   }                 }                  }                     } else {\n   (**)              (*)                                         return $e_2$;\n}                 }                  }                        }\n                                                              (*)\n                                                           }\n                                                           (*)\n                                                        }\n\t  "}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.5.2#footnote-link-1","child":[{"body":"We can't just use the labels\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"true_branch"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"false_branch"},{"body":",\n      \n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"after_cond"},{"body":"\n    as shown above, because there might be more than one\n    conditional\n    in the program.\n    \n    The compiler uses the\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_label"},{"body":"\n    to generate labels.\n    \n\tThe function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_label"},{"body":"\n    takes a string as argument and returns a new\n    string that begins with the\n    given string.  For example, successive calls to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_label(\"a\")"},{"body":"\n    would return\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a1\""},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"a2\""},{"body":",\n    and so on.\n    \n\tThe function\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_label"},{"body":"\n    can be implemented similarly to the generation of unique variable names in\n    the query language, as follows:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":false,"body":"let label_counter = 0;\n\nfunction new_label_number() {\n    label_counter = label_counter + 1;\n    return label_counter;\n}\nfunction make_label(string) {\n    return string + stringify(new_label_number());\n}"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.5.2#footnote-link-2","child":[{"body":"\nThe ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register would\nbe needed for a ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\nlinkage, which can result from a compilation by\n","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_and_go"},{"body":"\n(section ","tag":"#text"},{"tag":"REF","body":"5.5.7","href":"/sicpjs/5.5.7"},{"body":").\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/5.5.2#footnote-link-3","child":[{"body":"Our compiler does not detect all dead code. For example,\n      a conditional statement whose consequent and alternative branches both end in a return\n      statement will not stop subsequent statements from being compiled. See\n      exercises ","tag":"#text"},{"tag":"REF","body":"5.33","href":"/sicpjs/5.5.2#ex-5.33"},{"body":" and ","tag":"#text"},{"tag":"REF","body":"5.34","href":"/sicpjs/5.5.2#ex-5.34"},{"body":".\n      ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/5.5.2#footnote-link-4","child":[{"body":"We need machine operations to\n\timplement a data structure for representing compiled\n\tfunctions,\n\tanalogous to the structure for compound\n\tfunctions\n\tdescribed in section ","tag":"#text"},{"tag":"REF","body":"4.1.3","href":"/sicpjs/4.1.3"},{"body":":\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":false,"body":"function make_compiled_function(entry, env) {\n    return list(\"compiled_function\", entry, env);\n}\nfunction is_compiled_function(fun) {\n    return is_tagged_list(fun, \"compiled_function\");\n}\nfunction compiled_function_entry(c_fun) {\n    return head(tail(c_fun));\n}\nfunction compiled_function_env(c_fun) {\n    return head(tail(tail(c_fun)));\n}"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/5.5.2#footnote-link-5","child":[{"body":"\n            The augmented function body is a sequence ending with a return statement.\n            Compilation of a sequence of statements\n            uses the linkage ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":" for all its component statements except the last,\n            for which it uses the given linkage.\n            In this case, the last statement is a return statement, and\n            as we will see in section ","tag":"#text"},{"tag":"REF","body":"5.5.3","href":"/sicpjs/5.5.3"},{"body":",\n            a return statement always uses the\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":" linkage\n\t    descriptor for its return expression. Thus all function bodies will end with a\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"return\""},{"body":"\n\t    linkage, not the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"next\""},{"body":" we\n\t    pass as the linkage argument to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile"},{"body":" in\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_body"},{"body":".","tag":"#text"}]}]