<SUBSECTION>
  <NAME>
    <SPLITINLINE>
      <SCHEME>Generating Execution Procedures for Instructions</SCHEME>
      <PYTHON>Instructions and Their Execution Functions</PYTHON>
    </SPLITINLINE>
  </NAME>

  <LABEL NAME="sec:ex-proc"/>

  <INDEX>execution <SPLITINLINE><SCHEME>procedure</SCHEME><PYTHON>function</PYTHON></SPLITINLINE><SUBINDEX>in register-machine simulator<OPEN/></SUBINDEX></INDEX>
  <INDEX>register-machine language<SUBINDEX>instructions</SUBINDEX><OPEN/></INDEX>

  <TEXT>
    The assembler calls
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-execution-procedure</SCHEMEINLINE></SCHEME>
      <PYTHON>
	<PYTHONINLINE>make_execution_function</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    to generate the execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    for <SPLITINLINE><SCHEME>an</SCHEME><PYTHON>a controller</PYTHON></SPLITINLINE> instruction.
    Like the <SCHEMEINLINE>analyze</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    in the evaluator of section<SPACE/><REF NAME="sec:separating-analysis"/>,
    this dispatches on the type of instruction to generate the appropriate
    execution
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <PYTHON>function.</PYTHON>
    </SPLITINLINE>
    <SPLIT>
      <PYTHON>
        The details of these execution <PYTHON>functions</PYTHON> determine the
        meaning of the individual instructions in the register-machine language.
      </PYTHON>
    </SPLIT>

    <SNIPPET>
      <INDEX><DECLARATION>make_execution_function</DECLARATION></INDEX> 
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Unknown instruction type - - ASSEMBLE"
                     inst))))
      </SCHEME>
      <PYTHON>
function make_execution_function(inst, labels, machine, 
                                 pc, flag, stack, ops) {
    const inst_type = type(inst);
    return inst_type === "assign"
           ? make_assign_ef(inst, machine, labels, ops, pc)
           : inst_type === "test"
           ? make_test_ef(inst, machine, labels, ops, flag, pc)
           : inst_type === "branch"
           ? make_branch_ef(inst, machine, labels, flag, pc)
           : inst_type === "go_to"
           ? make_go_to_ef(inst, machine, labels, pc)
           : inst_type === "save"
           ? make_save_ef(inst, machine, stack, pc)
           : inst_type === "restore"
           ? make_restore_ef(inst, machine, stack, pc)
           : inst_type === "perform"
           ? make_perform_ef(inst, machine, labels, ops, pc)
           : error(inst, "unknown instruction type -- assemble");
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_execution_function</NAME>
      <REQUIRES>make_assign</REQUIRES>
      <REQUIRES>make_test</REQUIRES>
      <REQUIRES>test_instruction_syntax</REQUIRES>
      <REQUIRES>make_branch_5</REQUIRES>
      <REQUIRES>branch_branch_dest</REQUIRES>
      <REQUIRES>make_go_to</REQUIRES>
      <REQUIRES>go_to_go_to_dest</REQUIRES>
      <REQUIRES>make_save</REQUIRES>
      <REQUIRES>save_restore</REQUIRES>
      <REQUIRES>make_perform</REQUIRES>
      <REQUIRES>perform_perform_action</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Unknown instruction type - - ASSEMBLE"
                     inst))))
      </SCHEME>
      <PYTHON>
function make_execution_function(inst, labels, machine, 
                                 pc, flag, stack, ops) {
    return type(inst) === "assign"
           ? make_assign_ef(inst, machine, labels, ops, pc)
           : type(inst) === "test"
           ? make_test_ef(inst, machine, labels, ops, flag, pc)
           : type(inst) === "branch"
           ? make_branch_ef(inst, machine, labels, flag, pc)
           : type(inst) === "go_to"
           ? make_go_to_ef(inst, machine, labels, pc)
           : type(inst) === "save"
           ? make_save_ef(inst, machine, stack, pc)
           : type(inst) === "restore"
           ? make_restore_ef(inst, machine, stack, pc)
           : type(inst) === "push_marker_to_stack"
           ? make_push_marker_to_stack_ef(machine, stack, pc)
           : type(inst) === "revert_stack_to_marker"
           ? make_revert_stack_to_marker_ef(machine, stack, pc)
           : type(inst) === "perform"
           ? make_perform_ef(inst, machine, labels, ops, pc)
           : error(inst, "unknown instruction type -- assemble");
}
      </PYTHON>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
        For each type of instruction in the register-machine language,
        there is a generator that builds an appropriate execution
        procedure. The details of these procedures determine the
        meaning of the individual instructions in the register-machine
        language. We use data abstraction to isolate the detailed
        syntax of register-machine expressions from the general
        execution mechanism, as we did for evaluators in
        section<SPACE/><REF NAME="sec:representing-expressions"/>, by
        using syntax procedures to extract and classify the parts of
        an instruction.
      </SCHEME>
      <PYTHON>
        The elements of the <PYTHONINLINE>controller</PYTHONINLINE> sequence
        received by <PYTHONINLINE>make_machine</PYTHONINLINE> and passed
        to <PYTHONINLINE>assemble</PYTHONINLINE> are strings (for
        labels) and tagged lists (for instructions). The tag in an instruction
        is a string that identifies the instruction type, such as
        <PYTHONINLINE>"go_to"</PYTHONINLINE>, and the remaining elements
        of the list contains the arguments, such as the destination of the
        <PYTHONINLINE>go_to</PYTHONINLINE>.
        The dispatch in <PYTHONINLINE>make_execution_function</PYTHONINLINE> uses
        <SNIPPET>
	  <INDEX><DECLARATION>type</DECLARATION> in register machine</INDEX>
          <NAME>type_function</NAME>
          <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
          <PYTHON>
function type(instruction) { return head(instruction); }
          </PYTHON>
        </SNIPPET>
      </PYTHON>
    </SPLIT>
  </TEXT>
  <SPLIT>
    <PYTHON>
      <TEXT>
        The tagged lists are constructed when the
        <PYTHONINLINE>list</PYTHONINLINE> expression that is the third
        argument to <PYTHONINLINE>make_machine</PYTHONINLINE> is
        evaluated. Each argument to that
        <PYTHONINLINE>list</PYTHONINLINE> is either a string (which
        evaluates to itself) or a call to a constructor for an instruction
        tagged list. For example, <PYTHONINLINE>assign("b", reg("t"))</PYTHONINLINE> calls the constructor
        <PYTHONINLINE>assign</PYTHONINLINE> with arguments
        <PYTHONINLINE>"b"</PYTHONINLINE> and the result of calling the
        constructor <PYTHONINLINE>reg</PYTHONINLINE> with the argument
        <PYTHONINLINE>"t"</PYTHONINLINE>. The constructors and their
        arguments determine the syntax of the individual instructions in the
        register-machine language. The instruction constructors and selectors
        are shown below, along with the execution-function generators that use
        the selectors.
      </TEXT>
    </PYTHON>
  </SPLIT>
  
  <!-- <SPLIT> -->
  <!--   <PYTHON> -->
  <!--     Because we chose a textual representation for the controller in the beginning of -->
  <!--     this chapter that is valid JavaScript syntax, we can now write functions that -->
  <!--     allows us to evaluate the controller text as part of a JavaScript program. When the -->
  <!--     controller text is evaluated, is will generate a data structure representation of -->
  <!--     itself which can be executed by the register machine simulator. -->
  <!--   </PYTHON> -->
  <!-- </SPLIT> -->

  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Assign</SCHEMEINLINE> instructions</SCHEME>
	<PYTHON>The instruction <PYTHONINLINE>assign</PYTHONINLINE>
	</PYTHON>
      </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <INDEX><USE>assign</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>

  <SHORT_PAGE lines="2"/>
  <TEXT>
    The
    <SPLITINLINE>
      <SCHEME>make-assign</SCHEME>
      <PYTHON><PYTHONINLINE>make_assign_ef</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>handles assign</SCHEME>
      <PYTHON>makes execution functions for <PYTHONINLINE>assign</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    instructions:
    <SNIPPET>
      <INDEX><DECLARATION>make_assign_ef</DECLARATION></INDEX> 
      <NAME>make_assign</NAME>
      <REQUIRES>type_function</REQUIRES>
      <REQUIRES>make_operation_exp</REQUIRES>
      <REQUIRES>assign_reg_name</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()     ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))
      </SCHEME>
      <PYTHON>
function make_assign_ef(inst, machine, labels, operations, pc) {
    const target = get_register(machine, assign_reg_name(inst));
    const value_exp = assign_value_exp(inst);
    const value_fun =
        is_operation_exp(value_exp)
        ? make_operation_exp_ef(value_exp, machine, labels, operations)
        : make_primitive_exp_ef(value_exp, machine, labels);
    return () => {
               set_contents(target, value_fun());
               advance_pc(pc); 
           };
}
      </PYTHON>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
        <SCHEMEINLINE>Make-assign</SCHEMEINLINE>
	extracts the target register name (the second element of the instruction)
	and the value expression (the rest of the list that forms the instruction)
	from the <SCHEMEINLINE>assign</SCHEMEINLINE> instruction using the selectors
	<INDEX><DECLARATION>assign-reg-name</DECLARATION></INDEX> 
	<INDEX><DECLARATION>assign-value-exp</DECLARATION></INDEX> 
      </SCHEME>
      <PYTHON>
	The function <PYTHONINLINE>assign</PYTHONINLINE> constructs
	<PYTHONINLINE>assign</PYTHONINLINE> instructions.
	The selectors <PYTHONINLINE>assign_@reg_@name</PYTHONINLINE> and
	<PYTHONINLINE>assign_value_exp</PYTHONINLINE> extract the register name
	and value expression from an <PYTHONINLINE>assign</PYTHONINLINE> instruction.
      </PYTHON>
    </SPLIT>
    <SNIPPET>
      <INDEX><DECLARATION>assign</DECLARATION> (in register machine)<SUBINDEX>instruction constructor</SUBINDEX></INDEX>
      <INDEX>register-machine language<SUBINDEX><DECLARATION>assign</DECLARATION></SUBINDEX></INDEX>
      <INDEX><DECLARATION>assign_reg_name</DECLARATION></INDEX>
      <INDEX><DECLARATION>assign_value_exp</DECLARATION></INDEX>
      <NAME>assign_reg_name</NAME>
      <!-- <NAME>assign_constructor</NAME> -->
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))

(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
      </SCHEME>
      <PYTHON>
function assign(register_name, source) {
    return list("assign", register_name, source);
}
function assign_reg_name(assign_instruction) {
    return head(tail(assign_instruction));
}
function assign_value_exp(assign_instruction) { 
    return head(tail(tail(assign_instruction)));
}
      </PYTHON>
    </SNIPPET>

    <SPLITINLINE>
      <SCHEME>
        The register name is looked up 
      </SCHEME>
      <PYTHON>
        The function <PYTHONINLINE>make_assign_ef</PYTHONINLINE> looks up the register name
      </PYTHON>
    </SPLITINLINE>
    with
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-register</SCHEMEINLINE></SCHEME>
      <PYTHON>
	<PYTHONINLINE>get_register</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    to produce the target register object.  The value expression is passed to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-operation-exp</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_@operation_@exp_@ef</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    if the value is the result of an operation, and
    <SPLITINLINE>
      <PYTHON>
	it is passed
      </PYTHON>
    </SPLITINLINE>
    to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-primitive-exp</SCHEMEINLINE></SCHEME>
      <PYTHON>
	<PYTHONINLINE>make_@primitive_@exp_@ef</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    otherwise.  These
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    (shown below)
    <SPLITINLINE>
      <SCHEME>parse</SCHEME>
      <PYTHON>analyze</PYTHON>
    </SPLITINLINE>
    the value expression and produce an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    for the value.  This is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    of no arguments, called 
    <INDEX><USE>value_fun</USE></INDEX> 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>value-proc</SCHEMEINLINE>,</SCHEME>
      <PYTHON>
      <PYTHONINLINE>value_fun</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    which will be evaluated during the simulation to produce the actual
    value to be assigned to the register.  Notice that the work of looking
    up the register name and
    <SPLITINLINE>
      <SCHEME>parsing</SCHEME>
      <PYTHON>analyzing</PYTHON>
    </SPLITINLINE>
    the value expression is performed
    just once, at assembly time, not every time the instruction is
    simulated.  This saving of work is the reason we use execution
    <INDEX>syntactic analysis, separated from execution<SUBINDEX>in register-machine simulator</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <PYTHON>functions,</PYTHON>
    </SPLITINLINE>
    and corresponds directly to the saving in work we obtained by separating
    program analysis from execution in the evaluator of
    section<SPACE/><REF NAME="sec:separating-analysis"/>.
  </TEXT>

  <TEXT>
    The result returned by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-assign</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>make_assign_ef</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    is the execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    for the <SCHEMEINLINE>assign</SCHEMEINLINE> instruction.  When this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    is called (by the machine model<APOS/>s <SCHEMEINLINE>execute</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure),</SCHEME>
      <PYTHON>function),</PYTHON>
    </SPLITINLINE>
    it sets the contents of the target register to the result obtained by
    executing
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>value-proc</SCHEMEINLINE>.</SCHEME>
      <PYTHON><PYTHONINLINE>value_fun</PYTHONINLINE>.</PYTHON>
    </SPLITINLINE>
    Then it advances the <SCHEMEINLINE>pc</SCHEMEINLINE> to the next instruction
    by running the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    <SNIPPET>
      <INDEX><DECLARATION>advance_pc</DECLARATION></INDEX> 
      <NAME>advance_pc</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
      </SCHEME>
      <PYTHON>
function advance_pc(pc) {
    set_contents(pc, tail(get_contents(pc))); 
}
      </PYTHON>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Advance-pc</SCHEMEINLINE></SCHEME>
      <PYTHON>
	The function
	<PYTHONINLINE>advance_pc</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    is the normal termination for all instructions except
    <SCHEMEINLINE>branch</SCHEMEINLINE> and
    <SPLITINLINE>
      <SCHEME>    
	<SCHEMEINLINE>goto</SCHEMEINLINE>.
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>go_to</PYTHONINLINE>.
      </PYTHON>
    </SPLITINLINE>
    </TEXT>

  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>Test</SCHEMEINLINE>,
	  <SCHEMEINLINE>branch</SCHEMEINLINE>, and
	  <SCHEMEINLINE>goto</SCHEMEINLINE>
	  instructions
	</SCHEME>
	<PYTHON>
	  The instructions
	  <PYTHONINLINE>test</PYTHONINLINE>,
	  <PYTHONINLINE>branch</PYTHONINLINE>, and
	  <PYTHONINLINE>go_to</PYTHONINLINE>
	</PYTHON>
      </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	<INDEX><USE>test</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
	<SCHEMEINLINE>Make-test</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	The function
	<INDEX><USE>test</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
	<PYTHONINLINE>make_test_ef</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    handles <SCHEMEINLINE>test</SCHEMEINLINE> instructions in a similar way.
    It extracts the expression that specifies the condition to be tested and
    generates an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    for it.  At simulation time, the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    for the condition is called, the result is assigned to the
    <SCHEMEINLINE>flag</SCHEMEINLINE> register, and the
    <SCHEMEINLINE>pc</SCHEMEINLINE> is advanced:
    <SNIPPET>
      <INDEX><DECLARATION>make_test_ef</DECLARATION></INDEX> 
      <NAME>make_test</NAME>
      <REQUIRES>advance_pc</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction - - ASSEMBLE" inst))))

(define (test-condition test-instruction)
  (cdr test-instruction))
      </SCHEME>
      <PYTHON>
function make_test_ef(inst, machine, labels, operations, flag, pc) {
    const condition = test_condition(inst);
    if (is_operation_exp(condition)) {
        const condition_fun = make_operation_exp_ef(
                                  condition, machine, 
                                  labels, operations);
        return () => {
                   set_contents(flag, condition_fun());
                   advance_pc(pc); 
               };
    } else {
        error(inst, "bad test instruction -- assemble");
    }
}
      </PYTHON>
    </SNIPPET>
    <SPLIT>
      <PYTHON>
	The function
	<PYTHONINLINE>test</PYTHONINLINE> constructs
	<PYTHONINLINE>test</PYTHONINLINE> instructions. The selector
	<PYTHONINLINE>test_condition</PYTHONINLINE> extracts the condition
	from a test.
	<SNIPPET>
	  <INDEX><DECLARATION>test_condition</DECLARATION></INDEX>
	  <INDEX><DECLARATION>test</DECLARATION> (in register machine)<SUBINDEX>instruction constructor</SUBINDEX></INDEX>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>test</DECLARATION></SUBINDEX></INDEX>
          <NAME>test_instruction_syntax</NAME>
          <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
          <PYTHON>
function test(condition) { return list("test", condition); }
<SHORT_SPACE/>
function test_condition(test_instruction) {
    return head(tail(test_instruction)); 
}
          </PYTHON>
	</SNIPPET>
      </PYTHON>
    </SPLIT>
  </TEXT>

  <TEXT>
    The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    for a <SCHEMEINLINE>branch</SCHEMEINLINE> instruction checks the contents of
    the <SCHEMEINLINE>flag</SCHEMEINLINE> register and either sets the contents
    of the <SCHEMEINLINE>pc</SCHEMEINLINE> to the branch destination (if the
    branch is taken) or else just advances the <SCHEMEINLINE>pc</SCHEMEINLINE>
    (if the branch is not taken).  Notice that the indicated destination in a
    <INDEX><USE>branch</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
    <SCHEMEINLINE>branch</SCHEMEINLINE> instruction must be a label, and the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>make-branch</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>make_branch_ef</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    enforces this.  Notice also that the label is looked up at assembly time,
    not each time the <SCHEMEINLINE>branch</SCHEMEINLINE> instruction is
    simulated.
    <SNIPPET>
      <INDEX><DECLARATION>make_branch_ef</DECLARATION></INDEX> 
      <NAME>make_branch_5</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction - - ASSEMBLE" inst))))

(define (branch-dest branch-instruction)
  (cadr branch-instruction))
      </SCHEME>
      <PYTHON>
function make_branch_ef(inst, machine, labels, flag, pc) {
    const dest = branch_dest(inst);
    if (is_label_exp(dest)) {
        const insts = lookup_label(labels, label_exp_label(dest));
        return () => {
                   if (get_contents(flag)) {
                       set_contents(pc, insts);
                   } else {
                       advance_pc(pc);
                   }
               };
    } else {
        error(inst, "bad branch instruction -- assemble");
    }
}
      </PYTHON>
    </SNIPPET>

    <SPLIT>
      <PYTHON>
	The function <PYTHONINLINE>branch</PYTHONINLINE>
	constructs <PYTHONINLINE>branch</PYTHONINLINE> instructions. The
	selector 
	<PYTHONINLINE>branch_dest</PYTHONINLINE> extracts
	the destination from a branch.
	<SNIPPET>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>branch</DECLARATION></SUBINDEX></INDEX>
	  <INDEX><DECLARATION>branch</DECLARATION> (in register machine)<SUBINDEX>instruction constructor</SUBINDEX></INDEX>
	  <INDEX><DECLARATION>branch_dest</DECLARATION></INDEX>
          <NAME>branch_branch_dest</NAME>
          <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
          <PYTHON>
function branch(label) { return list("branch", label); }
<SHORT_SPACE/>
function branch_dest(branch_instruction) {
    return head(tail(branch_instruction)); 
}
          </PYTHON>
	</SNIPPET>
      </PYTHON>
    </SPLIT>
  </TEXT>

  <TEXT>
    A
    <INDEX><USE>go_to</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>go_to</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    instruction is similar to a branch, except that the destination may be
    specified either as a label or as a register, and there is no condition to
    check<EMDASH/>the <SCHEMEINLINE>pc</SCHEMEINLINE> is always set to the
    new destination.
    <SNIPPET>
      <INDEX><DECLARATION>make_go_to_ef</DECLARATION></INDEX> 
      <NAME>make_go_to</NAME>
      <REQUIRES>is_register_exp</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction - - ASSEMBLE"
            inst)))))

(define (goto-dest goto-instruction)
  (cadr goto-instruction))
      </SCHEME>
      <PYTHON>
function make_go_to_ef(inst, machine, labels, pc) {
    const dest = go_to_dest(inst);
    if (is_label_exp(dest)) {
        const insts = lookup_label(labels, label_exp_label(dest));
        return () => set_contents(pc, insts);
    } else if (is_register_exp(dest)) {
        const reg = get_register(machine, register_exp_reg(dest));
        return () => set_contents(pc, get_contents(reg));
    } else {
        error(inst, "bad go_to instruction -- assemble");
    }
}
      </PYTHON>
    </SNIPPET>

    <SPLIT>
      <PYTHON>
	The function <PYTHONINLINE>go_to</PYTHONINLINE> constructs
	<PYTHONINLINE>go_to</PYTHONINLINE> instructions. The selector 
	<PYTHONINLINE>go_to_dest</PYTHONINLINE> extracts the destination from a
	<PYTHONINLINE>go_to</PYTHONINLINE> instruction.
	<SNIPPET POSTPADDING="no">
	  <INDEX><DECLARATION>go_to</DECLARATION> (in register machine)<SUBINDEX>instruction constructor</SUBINDEX></INDEX>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>go_to</DECLARATION></SUBINDEX></INDEX>
	  <INDEX><DECLARATION>go_to_dest</DECLARATION></INDEX>
          <NAME>go_to_go_to_dest</NAME>
          <REQUIRES>make_go_to</REQUIRES>
          <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
          <PYTHON>
function go_to(label) { return list("go_to", label); }
<SHORT_SPACE/>
function go_to_dest(go_to_instruction) { 
    return head(tail(go_to_instruction)); 
}
          </PYTHON>
	</SNIPPET>
      </PYTHON>
    </SPLIT>
  </TEXT>

  <DO_BREAK_PAGE/>
  <SUBHEADING>
    <NAME>Other instructions</NAME>
  </SUBHEADING>

  <TEXT>
    The stack instructions
    <SCHEMEINLINE>save</SCHEMEINLINE> and <SCHEMEINLINE>restore</SCHEMEINLINE>
    simply use the stack with the designated register and advance the
    <SCHEMEINLINE>pc</SCHEMEINLINE>:
    <SNIPPET>
      <INDEX><DECLARATION>make_save_ef</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_restore_ef</DECLARATION></INDEX> 
      <INDEX><USE>save</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
      <INDEX><USE>restore</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
      <NAME>make_save</NAME>
      <REQUIRES>pop</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
              (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
              (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))    
      (advance-pc pc))))

(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
      </SCHEME>
      <PYTHON>
function make_save_ef(inst, machine, stack, pc) {
    const reg = get_register(machine, stack_inst_reg_name(inst));
    return () => {
               push(stack, get_contents(reg));
               advance_pc(pc);
           };
}
function make_restore_ef(inst, machine, stack, pc) {
    const reg = get_register(machine, stack_inst_reg_name(inst));
    return () => {
               set_contents(reg, pop(stack));
               advance_pc(pc); 
           };
}
      </PYTHON>
    </SNIPPET>

    <SPLIT>
      <PYTHON>
	The functions <PYTHONINLINE>save</PYTHONINLINE> and
	<PYTHONINLINE>restore</PYTHONINLINE> construct
	<PYTHONINLINE>save</PYTHONINLINE> and <PYTHONINLINE>restore</PYTHONINLINE> instructions. The
	selector
	<PYTHONINLINE>stack_inst_reg_name</PYTHONINLINE>
	extracts the register name from such instructions.
	<SNIPPET>
	  <INDEX><DECLARATION>save</DECLARATION> (in register machine)<SUBINDEX>instruction constructor</SUBINDEX></INDEX>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>save</DECLARATION></SUBINDEX></INDEX>
	  <INDEX><DECLARATION>restore</DECLARATION> (in register machine)<SUBINDEX>instruction constructor</SUBINDEX></INDEX>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>restore</DECLARATION></SUBINDEX></INDEX>
	  <INDEX><DECLARATION>stack_inst_reg_name</DECLARATION></INDEX>
	  <NAME>save_restore</NAME>
	  <REQUIRES>make_save</REQUIRES>
	  <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
	  <PYTHON>
function save(reg) { return list("save", reg); }
<SHORT_SPACE/>
function restore(reg) { return list("restore", reg); }
<SHORT_SPACE/>
function stack_inst_reg_name(stack_instruction) {
    return head(tail(stack_instruction));
}
	  </PYTHON>
	</SNIPPET>
      </PYTHON>
    </SPLIT>
  </TEXT>
  
  <TEXT>
    The final instruction type, handled by
    <INDEX><USE>perform</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-perform</SCHEMEINLINE>,</SCHEME>
      <PYTHON>
      <PYTHONINLINE>make_perform_ef</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    generates an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    for the action to be performed.  At simulation time, the action
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    is executed and the <SCHEMEINLINE>pc</SCHEMEINLINE> advanced.
    <SNIPPET>
      <INDEX><DECLARATION>make_perform_ef</DECLARATION></INDEX> 
      <NAME>make_perform</NAME>
      <REQUIRES>is_register_exp</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Bad PERFORM instruction - - ASSEMBLE" inst))))

(define (perform-action inst) (cdr inst))
      </SCHEME>
      <PYTHON>
function make_perform_ef(inst, machine, labels, operations, pc) {
    const action = perform_action(inst);
    if (is_operation_exp(action)) {
        const action_fun = make_operation_exp_ef(action, machine,
                                                 labels, operations);
        return () => { 
                   action_fun(); 
                   advance_pc(pc); 
               };
    } else {
        error(inst, "bad perform instruction -- assemble");
    }
}
      </PYTHON>
    </SNIPPET>

    <SPLIT>
      <PYTHON>
	The function <PYTHONINLINE>perform</PYTHONINLINE> 
	constructs <PYTHONINLINE>perform</PYTHONINLINE> instructions. The
	selector 
	<PYTHONINLINE>perform_@action</PYTHONINLINE> extracts
	the action from a <PYTHONINLINE>perform</PYTHONINLINE> instruction.
	<SNIPPET POSTPADDING="no">
	  <INDEX><DECLARATION>perform</DECLARATION> (in register machine)<SUBINDEX>instruction constructor</SUBINDEX></INDEX>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>perform</DECLARATION></SUBINDEX></INDEX>
	  <INDEX><DECLARATION>perform_action</DECLARATION></INDEX>
          <NAME>perform_perform_action</NAME>
          <REQUIRES>make_perform</REQUIRES>
          <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
          <PYTHON>
function perform(action) { return list("perform", action); }
<SHORT_SPACE/>
function perform_action(perform_instruction) {
    return head(tail(perform_instruction));
}
          </PYTHON>
	</SNIPPET>
      </PYTHON>
    </SPLIT>

  </TEXT>
  
  <SUBHEADING>
    <NAME>Execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    for subexpressions</NAME>
  </SUBHEADING>

  <TEXT>
    The value of a
    <INDEX><USE>reg</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
    <SCHEMEINLINE>reg</SCHEMEINLINE>,
    <INDEX><USE>label</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
    <SCHEMEINLINE>label</SCHEMEINLINE>, or
    <INDEX><USE>constant</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>const</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>constant</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    expression may be needed for assignment to a register
    <SPLITINLINE>
      <SCHEME>(<SCHEMEINLINE>make-assign</SCHEMEINLINE>)</SCHEME>
      <PYTHON>(<PYTHONINLINE>make_assign_ef</PYTHONINLINE>, above)</PYTHON>
    </SPLITINLINE>
    or for input to an operation
    <SPLITINLINE>
      <SCHEME>(<SCHEMEINLINE>make-operation-exp</SCHEMEINLINE>,</SCHEME>
      <PYTHON>
      (<PYTHONINLINE>make_@operation_@exp_@ef</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    below).  The following
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    generates execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    to produce values for these expressions during the simulation:
    <SNIPPET>
      <INDEX><DECLARATION>make_primitive_exp_ef</DECLARATION></INDEX> 
      <NAME>make_primitive_exp</NAME>
      <REQUIRES>lookup_label</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                   (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type - - ASSEMBLE" exp))))
      </SCHEME>
      <PYTHON>
function make_primitive_exp_ef(exp, machine, labels) {
    if (is_constant_exp(exp)) {
        const c = constant_exp_value(exp);
        return () => c;
    } else if (is_label_exp(exp)) {
        const insts = lookup_label(labels, label_exp_label(exp));
        return () => insts;
    } else if (is_register_exp(exp)) {
        const r = get_register(machine, register_exp_reg(exp));
        return () => get_contents(r); 
    } else {
        error(exp, "unknown expression type -- assemble");
    }
}
      </PYTHON>
    </SNIPPET>

    <SPLIT>
      <SCHEME>
        The syntax of <SCHEMEINLINE>reg</SCHEMEINLINE>,
        <SCHEMEINLINE>label</SCHEMEINLINE>, and <SCHEMEINLINE>const</SCHEMEINLINE>
        expressions is determined by
        <SNIPPET>
          <INDEX><DECLARATION>register-exp</DECLARATION></INDEX> 
          <INDEX><DECLARATION>register-exp-reg</DECLARATION></INDEX> 
          <INDEX><DECLARATION>constant-exp</DECLARATION></INDEX> 
          <INDEX><DECLARATION>constant-exp-value</DECLARATION></INDEX> 
          <INDEX><DECLARATION>label-exp</DECLARATION></INDEX> 
          <INDEX><DECLARATION>label-exp-label</DECLARATION></INDEX> 
          <NAME>is_register_exp</NAME>
          <REQUIRES>tagged_list</REQUIRES>
          <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
          <SCHEME>
(define (register-exp? exp) (tagged-list? exp 'reg))

(define (register-exp-reg exp) (cadr exp))

(define (constant-exp? exp) (tagged-list? exp 'const))

(define (constant-exp-value exp) (cadr exp))

(define (label-exp? exp) (tagged-list? exp 'label))

(define (label-exp-label exp) (cadr exp))
          </SCHEME>
        </SNIPPET>
      </SCHEME>
      <PYTHON>
	The syntax of <PYTHONINLINE>reg</PYTHONINLINE>,
	<PYTHONINLINE>label</PYTHONINLINE>, and <PYTHONINLINE>constant</PYTHONINLINE>
        expressions is determined by the following constructor functions, along with
        corresponding predicates and selectors.
	<SNIPPET>
	  <INDEX><DECLARATION>reg</DECLARATION> (in register machine)</INDEX>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>reg</DECLARATION></SUBINDEX></INDEX>
	  <INDEX><DECLARATION>is_register_exp</DECLARATION></INDEX>
	  <INDEX><DECLARATION>register_exp_reg</DECLARATION></INDEX>
	  <INDEX><DECLARATION>constant</DECLARATION> (in register machine)</INDEX>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>constant</DECLARATION></SUBINDEX></INDEX>
	  <INDEX><DECLARATION>is_constant_exp</DECLARATION></INDEX>
	  <INDEX><DECLARATION>constant_exp_value</DECLARATION></INDEX>
	  <INDEX><DECLARATION>label</DECLARATION> (in register machine)</INDEX>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>label</DECLARATION></SUBINDEX></INDEX>
	  <INDEX><DECLARATION>is_label_exp</DECLARATION></INDEX>
	  <INDEX><DECLARATION>label_exp_label</DECLARATION></INDEX>
	  <NAME>is_register_exp0</NAME>
	  <REQUIRES>tagged_list</REQUIRES>
	  <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
	  <PYTHON>
function reg(name) { return list("reg", name); }
<SHORT_SPACE/>
function is_register_exp(exp) { return is_tagged_list(exp, "reg"); }
<SHORT_SPACE/>
function register_exp_reg(exp) { return head(tail(exp)); }

function constant(value) { return list("constant", value); }
<SHORT_SPACE/>
function is_constant_exp(exp) {
    return is_tagged_list(exp, "constant");
}
<SHORT_SPACE/>
function constant_exp_value(exp) { return head(tail(exp)); }

function label(name) { return list("label", name); }
<SHORT_SPACE/>
function is_label_exp(exp) { return is_tagged_list(exp, "label"); }
<SHORT_SPACE/>
function label_exp_label(exp) { return head(tail(exp)); }
	  </PYTHON>
	</SNIPPET>
      </PYTHON>
    </SPLIT>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Assign</SCHEMEINLINE>,
	<SCHEMEINLINE>perform</SCHEMEINLINE>, and
	<SCHEMEINLINE>test</SCHEMEINLINE>
	instructions
      </SCHEME>
      <PYTHON>
	The instructions
	<SCHEMEINLINE>assign</SCHEMEINLINE>,
	<SCHEMEINLINE>perform</SCHEMEINLINE>, and
	<SCHEMEINLINE>test</SCHEMEINLINE>
      </PYTHON>
    </SPLITINLINE>
    may include the application of a machine operation (specified by an
    <INDEX><USE>op</USE> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
    <SCHEMEINLINE>op</SCHEMEINLINE> expression) to some operands (specified
    by <SCHEMEINLINE>reg</SCHEMEINLINE> and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>const</SCHEMEINLINE></SCHEME>
      <PYTHON><PYTHONINLINE>constant</PYTHONINLINE></PYTHON>
    </SPLITINLINE>
    expressions). The following
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    produces an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    for an <QUOTE>operation expression</QUOTE><EMDASH/>a list containing the
    operation and operand expressions from the instruction:
    <SNIPPET>
      <INDEX><DECLARATION>make_operation_exp_ef</DECLARATION></INDEX> 
      <NAME>make_operation_exp</NAME>
      <REQUIRES>lookup_prim</REQUIRES>
      <REQUIRES>make_primitive_exp</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
      </SCHEME>
      <PYTHON>
function make_operation_exp_ef(exp, machine, labels, operations) {
    const op = lookup_prim(operation_exp_op(exp), operations);
    const afuns = map(e => make_primitive_exp_ef(e, machine, labels),
                      operation_exp_operands(exp));
    return () => apply_in_underlying_javascript(
                     op, map(f => f(), afuns));
}
      </PYTHON>
    </SNIPPET>

    <SPLIT>
      <SCHEME>
	The syntax of operation expressions is determined by
	<SNIPPET>
	  <INDEX><DECLARATION>operation-exp</DECLARATION></INDEX> 
	  <INDEX><DECLARATION>operation-exp-op</DECLARATION></INDEX> 
	  <INDEX><DECLARATION>operation-exp-operands</DECLARATION></INDEX> 
	  <NAME>is_operation_exp</NAME>
	  <REQUIRES>tagged_list</REQUIRES>
	  <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
	  <SCHEME>
(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))

(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))

(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
	  </SCHEME>
	</SNIPPET>
      </SCHEME>
      <PYTHON>
	The syntax of operation expressions is determined by<DONT_BREAK_PAGE strength="4"/>
	<SNIPPET>
	  <INDEX><DECLARATION>op</DECLARATION> (in register machine)<SUBINDEX>simulating</SUBINDEX></INDEX>
	  <INDEX>register-machine language<SUBINDEX><DECLARATION>op</DECLARATION></SUBINDEX></INDEX>
	  <INDEX><DECLARATION>is_operation_exp</DECLARATION></INDEX>
	  <INDEX><DECLARATION>operation_exp_op</DECLARATION></INDEX>
	  <INDEX><DECLARATION>operation_exp_operands</DECLARATION></INDEX>
	  <NAME>is_register_exp</NAME>
	  <REQUIRES>is_register_exp0</REQUIRES>
	  <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
	  <PYTHON>
function op(name) { return list("op", name); }
<SHORT_SPACE/>
function is_operation_exp(exp) {
    return is_pair(exp) &amp;&amp; is_tagged_list(head(exp), "op");
}
<SHORT_SPACE/>
function operation_exp_op(op_exp) { return head(tail(head(op_exp))); }
<SHORT_SPACE/>
function operation_exp_operands(op_exp) { return tail(op_exp); }
	  </PYTHON>
	</SNIPPET>
      </PYTHON>
    </SPLIT>

    Observe that the treatment of operation expressions is very much like
    the treatment of
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    applications by the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>analyze-application</SCHEMEINLINE></SCHEME>
      <PYTHON>
	<PYTHONINLINE>analyze_application</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    in the evaluator of section<SPACE/><REF NAME="sec:separating-analysis"/> in
    that we generate an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    for each operand.  
    <SPLITINLINE>
      <SCHEME>
	At simulation time, we call the operand	
	procedures
	and apply the Scheme procedure	
      </SCHEME>
      <PYTHON>
	At simulation time, we call the operand	
	functions
	and apply the JavaScript function
      </PYTHON>
    </SPLITINLINE>
    that simulates the operation to the resulting values. 

    <SPLIT>
      <PYTHON>
	We make use of the function
	<PYTHONINLINE>apply_in_underlying_javascript</PYTHONINLINE>, as we did 
	in <PYTHONINLINE>apply_primitive_function</PYTHONINLINE> in 
	section<SPACE/><REF NAME="sec:running-eval"/>. This is needed to apply
	<PYTHONINLINE>op</PYTHONINLINE> to all elements of the argument list
	<PYTHONINLINE>afuns</PYTHONINLINE> 
	produced by the first <PYTHONINLINE>map</PYTHONINLINE>,
	as if they were separate arguments to
	<PYTHONINLINE>op</PYTHONINLINE>. Without this,
	<PYTHONINLINE>op</PYTHONINLINE> would have been restricted to be a unary
	function.
      </PYTHON>
    </SPLIT>
  </TEXT>
  <TEXT>
  The simulation
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    is found by looking up the operation name in the operation table for the
    machine:
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>lookup_prim</DECLARATION></INDEX> 
      <NAME>lookup_prim</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation - - ASSEMBLE" symbol))))
      </SCHEME>
      <PYTHON>
function lookup_prim(symbol, operations) {
    const val = assoc(symbol, operations);
    return is_undefined(val)
           ? error(symbol, "unknown operation -- assemble")
           : head(tail(val));
}
      </PYTHON>
    </SNIPPET>
  </TEXT>

  <EXERCISE>
    The treatment of machine operations above permits them to operate
    on labels as well as on constants and the contents of registers.
    Modify the expression-processing
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <PYTHON>functions</PYTHON>
    </SPLITINLINE>
    to enforce the condition that operations can be used only with registers
    and constants.
    <LABEL NAME="ex:5_9"/>
  </EXERCISE>

  <SPLIT>
    <SCHEME>
      <!-- Removed from JS version to avoid discussing whether the controller is "text" or not -->
      <EXERCISE>
	Design a new syntax for register-machine instructions and modify the
	simulator to use your new syntax.  Can you implement your new
	syntax without changing any part of the simulator except the
	<SPLITINLINE>
	  <SCHEME>syntax procedures in this section?</SCHEME>
	  <PYTHON>constructor and selector functions in this section?</PYTHON>
	</SPLITINLINE>
	<LABEL NAME="ex:reg-machine-syntax"/>
      </EXERCISE>
    </SCHEME>
  </SPLIT>

  <EXERCISE>
    When we introduced
    <INDEX><USE>save</USE> (in register machine)</INDEX>
    <SCHEMEINLINE>save</SCHEMEINLINE> and
    <INDEX><USE>restore</USE> (in register machine)</INDEX>
    <SPLITINLINE>restore</SPLITINLINE> in
    section<SPACE/><REF NAME="sec:stack-recursion"/>, we didn<APOS/>t specify
    what would happen if you tried to restore a register that was not the last
    one saved, as in the sequence
    <SNIPPET EVAL="no">
      <SCHEME>
(save y)
(save x)
(restore y)
      </SCHEME>
      <PYTHON>
save(y);
save(x);
restore(y);
      </PYTHON>
    </SNIPPET>
    <SHORT_PAGE lines="2"/>There are several reasonable possibilities for the meaning of
    <SCHEMEINLINE>restore</SCHEMEINLINE>:
    <OL>
      <LI>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(restore y)</SCHEMEINLINE></SCHEME>
	  <PYTHON><PYTHONINLINE>restore(y)</PYTHONINLINE>
	  </PYTHON>
	</SPLITINLINE>
	puts into <SCHEMEINLINE>y</SCHEMEINLINE> the last value saved on the
	stack, regardless of what register that value came from.  This is the
	way our simulator behaves.  Show how to take advantage of this
	behavior to eliminate one instruction from the Fibonacci machine of
	section<SPACE/><REF NAME="sec:stack-recursion"/>
	(figure<SPACE/><REF NAME="fig:fib-machine"/>).
      </LI>
      <LI>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(restore y)</SCHEMEINLINE></SCHEME>
	  <PYTHON><PYTHONINLINE>restore(y)</PYTHONINLINE>
	  </PYTHON>
	</SPLITINLINE>
	puts into <SCHEMEINLINE>y</SCHEMEINLINE> the last value saved on the
	stack, but only if that value was saved from
	<SCHEMEINLINE>y</SCHEMEINLINE>; otherwise, it signals an error.  Modify
	the simulator to behave this way.  You will have to change
	<SCHEMEINLINE>save</SCHEMEINLINE> to put the register name on the stack
	along with the value.
      </LI>
      <LI>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(restore y)</SCHEMEINLINE></SCHEME>
	  <PYTHON><PYTHONINLINE>restore(y)</PYTHONINLINE>
	  </PYTHON>
	</SPLITINLINE>
	puts into <SCHEMEINLINE>y</SCHEMEINLINE> the last value saved from
	<SCHEMEINLINE>y</SCHEMEINLINE> regardless of what other registers were
	saved after <SCHEMEINLINE>y</SCHEMEINLINE> and not restored.  Modify the
	simulator to behave this way.  You will have to associate a separate
	stack with each register.  You should make the
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>initialize-stack</SCHEMEINLINE></SCHEME>
	  <PYTHON>
	    <PYTHONINLINE>initialize_stack</PYTHONINLINE>
	  </PYTHON>
	</SPLITINLINE>
	operation initialize all the register stacks.
      </LI>
    </OL>
    <LABEL NAME="ex:stack-behavior"/>
  </EXERCISE>

  <EXERCISE>
    The simulator can be used to help determine the data paths required
    for implementing a machine with a given controller.  Extend
    the assembler to store the following information in the machine model:
    <UL>
      <LI>
	a list of all instructions, with duplicates removed, sorted by
	instruction type
	(<SCHEMEINLINE>assign</SCHEMEINLINE>,
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE>,</SCHEME>
	  <PYTHON><PYTHONINLINE>go_to</PYTHONINLINE>,</PYTHON>
	</SPLITINLINE>
	and so on);
      </LI>
      <LI>
	a list (without duplicates) of the registers used to hold entry points
	(these are the registers referenced by
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE></SCHEME>
	  <PYTHON><PYTHONINLINE>go_to</PYTHONINLINE></PYTHON>
	</SPLITINLINE>
	instructions);
      </LI>
      <LI>
	a list (without duplicates) of the registers that are
	<SCHEMEINLINE>save</SCHEMEINLINE>d
	or <SCHEMEINLINE>restore</SCHEMEINLINE>d;
      </LI>
      <LI>
	for each register, a list (without duplicates) of the sources from
	which it is assigned (for example, the sources for register
	<SCHEMEINLINE>val</SCHEMEINLINE> in the factorial machine of
	figure<SPACE/><REF NAME="fig:fact-machine"/> are
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(const 1)</SCHEMEINLINE></SCHEME>
	  <PYTHON>
	    <PYTHONINLINE>constant(1)</PYTHONINLINE>
	  </PYTHON>
	</SPLITINLINE>
	and
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>((op *) (reg n) (reg val))</SCHEMEINLINE>).
	  </SCHEME>
	  <PYTHON>
	    <PYTHONINLINE>list(op("*"), reg("n"), reg("val"))</PYTHONINLINE>).
	  </PYTHON>
	</SPLITINLINE>
      </LI>
    </UL>
    Extend the message-passing interface to the machine to provide access to
    this new information.  To test your analyzer, define the Fibonacci machine
    from figure<SPACE/><REF NAME="fig:fib-machine"/> and examine the lists you
    constructed.
    <LABEL NAME="ex:simulated-data-paths"/>
  </EXERCISE>

  <EXERCISE>
    Modify the simulator so that it uses the controller sequence to determine
    what registers the machine has rather than requiring a list of registers as
    an argument to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-machine</SCHEMEINLINE>.</SCHEME>
      <PYTHON><PYTHONINLINE>make_machine</PYTHONINLINE>.</PYTHON>
    </SPLITINLINE>
    Instead of preallocating the registers in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-machine</SCHEMEINLINE>,</SCHEME>
      <PYTHON>
      <PYTHONINLINE>make_machine</PYTHONINLINE>,</PYTHON>
    </SPLITINLINE>
    you can allocate them one at a time when they are first seen during assembly
    of the instructions.
    <LABEL NAME="ex:5_12"/>
  </EXERCISE>

  <INDEX>register-machine language<SUBINDEX>instructions</SUBINDEX><CLOSE/></INDEX>
  <INDEX>execution <SPLITINLINE><SCHEME>procedure</SCHEME><PYTHON>function</PYTHON></SPLITINLINE><SUBINDEX>in register-machine simulator<CLOSE/></SUBINDEX></INDEX>

</SUBSECTION>
