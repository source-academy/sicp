  <SECTION>
    <NAME>Storage Allocation and Garbage Collection</NAME>

    <SECTIONCONTENT/>

    <LABEL NAME="sec:storage-allocation"/>
    <INDEX>list-structured memory|(</INDEX>
    <INDEX>memory<SUBINDEX>list-structured|(</SUBINDEX></INDEX>

    <TEXT>
      In section<SPACE/><REF NAME="sec:eceval"/>, we will show how to implement a Scheme
      evaluator as a register machine.  In order to simplify the discussion,
      we will assume that our register machines can be equipped with a <EM>
  list-structured memory</EM>, in which the basic operations for
      manipulating list-structured data are primitive.  Postulating the
      existence of such a memory is a useful abstraction when one is
      focusing on the mechanisms of control in a Scheme interpreter, but
      this does not reflect a realistic view of the actual primitive data
      operations of contemporary computers.  To obtain a more complete
      picture of how a <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> system operates, we must investigate how list
      structure can be represented in a way that is compatible with
      conventional computer memories.
    </TEXT>

    <TEXT>
      There are two considerations in implementing list structure.  The
      first is purely an issue of representation: how to represent the
      <QUOTE>box-and-pointer</QUOTE> structure of <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> pairs, using only the storage
      and addressing capabilities of typical computer memories.  The second
      issue concerns the management of memory as a computation proceeds.
      The operation of a <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> system depends crucially on the ability to
      continually create new data objects.  These include objects that are
      explicitly created by the <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE>
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      being interpreted as well
      as structures created by the interpreter itself, such as environments
      and argument lists.  Although the constant creation of new data
      objects would pose no problem on a computer with an infinite amount of
      rapidly addressable memory, computer memories are available only in
      finite sizes (more<APOS/>s the pity).  <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> systems
      thus provide an 
      <INDEX>automatic storage allocation</INDEX>
      <EM>automatic storage allocation</EM> facility to
      support the illusion of an infinite memory.  When a data object is no
      longer needed, the memory allocated to it is automatically recycled
      and used to construct new data objects.  There are various
      techniques for providing such automatic storage allocation.  The
      method we shall discuss in this section is called <EM>garbage
  collection</EM>.
    </TEXT>

    <!-- Subsection 1 : Memory as Vectors -->
    &subsection5.3.1;

    <!-- Subsection 2 : Maintaining the Illusion of Infinite Memory -->
    &subsection5.3.1;

  </SECTION>
