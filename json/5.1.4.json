[{"id":"/sicpjs/5.1.4","tag":"TITLE","body":"5.1.4  \n    Using a Stack to Implement Recursion"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    With the ideas illustrated so far, we can implement any\n    \n    iterative\n    process by specifying a register machine that has a register\n    corresponding to each state variable of the process.  The machine\n    repeatedly executes a controller loop, changing the contents\n    of the registers, until some termination condition is satisfied.  At\n    each point in the controller sequence, the state of the machine\n    (representing the state of the iterative process) is completely\n    determined by the contents of the registers (the values of the state\n    variables).\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Implementing\n    \n    recursive processes, however, requires an additional\n    mechanism.  Consider the following recursive method for computing\n    factorials, which we first examined in\n    section ","tag":"#text"},{"tag":"REF","body":"1.2.1","href":"/sicpjs/1.2.1"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQEY0BYBQuAzAVwDsBjAFwEsB7E0AgQ0poCcrGAbAChIEpQAb1yhRoVgFMKRVvXoBeRaAygRY9WID8ytRvUAuUPQBUDZhTYce9ALTK+AblwBffExbsu3FI6A","body":"function factorial(n) {\n    return n === 1 \n           ? 1\n           : n * factorial(n - 1);\n} "},{"body":"\n\n    As we see from the\n    function,\n    computing ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":" requires computing\n    ","tag":"#text"},{"body":"$(n-1)!$","tag":"LATEX"},{"body":".  Our GCD machine, modeled on the\n    function","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQEY0BYBQuAzAVwDsBjAFwEsB7E0AczIBMAKAQwBpQAjASlABvXKFGgATgFMKRcfR6gAvMtAAGUAH5Q7UAC5GLVj246ApLz4BuXAF98TNgCZV3DI6tA","body":"function gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n} "},{"body":"\n\n    similarly had to compute another GCD.  But there is an important\n    difference between the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":"function,\n    which reduces the original computation to a new GCD computation, and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":", which requires computing another\n    factorial as a subproblem.  In GCD, the answer to the new GCD computation is\n    the answer to the original problem.  To compute the next GCD, we simply\n    place the new arguments in the input registers of the GCD machine and reuse\n    the machine's data paths by executing the same controller sequence.\n    When the machine is finished solving the final GCD problem, it has completed\n    the entire computation.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    In the case of factorial (or any recursive process) the answer to the\n    new factorial subproblem is not the answer to the original problem.\n    The value obtained for ","tag":"#text"},{"body":"$(n-1)!$","tag":"LATEX"},{"body":" must be\n    multiplied by ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" to get the final answer.  If\n    we try to imitate the GCD design, and solve the factorial subproblem by\n    decrementing the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" register and rerunning the\n    factorial machine, we will no longer have available the old value of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" by which to multiply the result.  We thus\n    need a second factorial machine to work on the subproblem.  This second\n    factorial computation itself has a factorial subproblem, which\n    requires a third factorial machine, and so on.  Since each factorial\n    machine contains another factorial machine within it, the total\n    machine contains an infinite nest of similar machines and hence cannot\n    be constructed from a fixed, finite number of parts.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Nevertheless, we can implement the factorial process as a register\n    machine if we can arrange to use the same components for each nested\n    instance of the machine.  Specifically, the machine that computes\n    ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":"\n    should use the same components to work on the subproblem of computing\n    ","tag":"#text"},{"body":"$(n-1)!$","tag":"LATEX"},{"body":", on the subproblem for\n    ","tag":"#text"},{"body":"$(n-2)!$","tag":"LATEX"},{"body":", and so on.  This is\n    plausible because, although the factorial process dictates that an\n    unbounded number of copies of the same machine are needed to perform a\n    computation, only one of these copies needs to be active at any given\n    time.  When the machine encounters a recursive subproblem, it can\n    suspend work on the main problem, reuse the same physical parts to\n    work on the subproblem, then continue the suspended computation.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    In the subproblem, the contents of the registers will be different\n    than they were in the main problem. (In this case the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" register is decremented.)  In order to be\n    able to continue the suspended computation, the machine must save the\n    contents of any registers that will be needed after the subproblem is\n    solved so that these can be restored to continue the suspended computation.\n    In the case of factorial, we will save the old value of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":", to be restored when we are finished\n    computing the factorial of the decremented ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":"\n    register.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.1.4#footnote-1"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Since there is no a priori limit on the depth of nested\n    recursive calls, we may need to save an arbitrary number of register\n    values.  These values must be restored in the reverse of the order in\n    which they were saved, since in a nest of recursions the last\n    subproblem to be entered is the first to be finished.  This dictates\n    the use of a ","tag":"#text"},{"tag":"EM","child":[{"body":"stack","tag":"#text"}]},{"body":", or \"","tag":"#text"},{"body":"last in, first out","tag":"#text"},{"body":"\" data\n    structure, to save register values.  We can extend the register-machine\n    language to include a stack by adding two kinds of instructions: Values are\n    placed\n    on the stack using a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" instruction and\n    restored from the stack using a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":"\n    instruction.  After a sequence of values has been\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":"d on the stack, a sequence of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":"s will retrieve these values in reverse\n    order.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.1.4#footnote-2"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    With the aid of the stack, we can reuse a single copy of the factorial\n    machine's data paths for each factorial subproblem.  There is a\n    similar design issue in reusing the controller sequence that operates\n    the data paths.  To reexecute the factorial computation, the\n    controller cannot simply loop back to the beginning, as with\n    an iterative process, because after solving the\n    ","tag":"#text"},{"body":"$(n-1)!$","tag":"LATEX"},{"body":" subproblem\n    the machine must still multiply the result by\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".  The controller\n    must suspend its computation of ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":", solve the\n    ","tag":"#text"},{"body":"$(n-1)!$","tag":"LATEX"},{"body":" subproblem,\n    then continue its computation of ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":".  This\n    view of the factorial computation suggests the use of the subroutine\n    mechanism described in section ","tag":"#text"},{"tag":"REF","body":"5.1.3","href":"/sicpjs/5.1.3"},{"body":", which\n    has the controller use a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register to transfer to the part of\n    the sequence that solves a subproblem and then continue where it left off on\n    the main problem. We can thus make a factorial subroutine that returns to\n    the entry point stored in the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":"\n    register. Around each subroutine call, we save and restore\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" just as we do the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" register, since each \"","tag":"#text"},{"body":"level","tag":"#text"},{"body":"\" of\n    the factorial computation will use the same\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register. That is, the factorial\n    subroutine must put a new value in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":"\n    when it calls itself for a subproblem, but it will need the old value in\n    order to return to the place that called it to solve a subproblem.\n  ","tag":"#text"}]},{"tag":"FIGURE","scale":"70%","src":"img_javascript/Fig5.11b.std.svg","id":"#fig-5.11","snippet":{"tag":"SNIPPET","latex":true,"eval":false,"body":"\ncontroller(\n  list(      \n      assign(\"continue\", label(\"fact_done\")), // set up final return address\n    \"fact_loop\",\n      test(list(op(\"=\"), reg(\"n\"), constant(1))),\n      branch(label(\"base_case\")),\n      // Set up for recursive call by saving $\\texttt{n}$ and $\\texttt{continue}$.\n      // Set up $\\texttt{continue}$ so that the computation will continue\n      // at $\\texttt{after\\_fact}$ when the subroutine returns.\n      save(\"continue\"),\n      save(\"n\"),\n      assign(\"n\", list(op(\"-\"), reg(\"n\"), constant(1))),\n      assign(\"continue\", label(\"after_fact\")),\n      go_to(label(\"fact_loop\")),\n    \"after_fact\",\n      restore(\"n\"),\n      restore(\"continue\"),\n      assign(\"val\",                   // $\\texttt{val}$ now contains $n(n-1)!$\n             list(op(\"*\"), reg(\"n\"), reg(\"val\"))),  \n      go_to(reg(\"continue\")),         // return to caller\n    \"base_case\",\n      assign(\"val\", constant(1)),     // base case: 1! = 1\n      go_to(reg(\"continue\")),         // return to caller\n    \"fact_done\"))\n            "},"captionHref":"/sicpjs/5.1.4#fig-5.11","captionName":"Figure 5.11 ","captionBody":[{"body":"A recursive\n      \n      factorial machine.\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n\tFigure ","tag":"#text"},{"tag":"REF","body":"5.11","href":"/sicpjs/5.1.4#fig-5.11"},{"body":"\n    shows the data paths and controller for\n    a machine that implements the recursive\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":"function.\n    The machine has a stack and three registers, called\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":", and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":".  To simplify the data-path diagram,\n    we have not named the register-assignment buttons, only the stack-operation\n    buttons (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sc"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sn"},{"body":"\n    to save registers, ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"rc"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"rn"},{"body":" to restore registers).  To operate the\n    machine, we put in register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" the number whose\n    factorial we wish to compute and start the machine.  When the machine\n    reaches ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fact_done"},{"body":", the computation is finished\n    and the answer will be found in the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":"\n    register.  In the controller sequence, ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" are saved before each recursive call\n    and restored upon return from the call.  Returning from a call is\n    accomplished by branching to the location stored in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":". \n    \n\tThe register\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":"\n    is initialized when the machine starts so that the last return will go to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fact_done"},{"body":".  The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":"\n    register, which holds the result of the factorial computation, is not\n    saved before the recursive call, because the old contents of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":" is not useful after the subroutine returns.\n    Only the new value, which is the value produced by the subcomputation, is\n    needed.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    Although in principle the factorial computation requires an infinite\n    machine, the machine in\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"5.11","href":"/sicpjs/5.1.4#fig-5.11"},{"body":"\n    is actually finite except for the stack, which is potentially unbounded.  Any\n    particular physical implementation of a stack, however, will be of finite\n    size, and this will limit the depth of recursive calls that can be handled\n    by the machine.  This implementation of factorial illustrates the general\n    strategy for realizing recursive algorithms as ordinary register machines\n    augmented by stacks.  When a recursive subproblem is encountered, we save on\n    the stack the registers whose current values will be required after the\n    subproblem is solved, solve the recursive subproblem, then restore the saved\n    registers and continue execution on the main problem.  The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" register must always be saved.\n    Whether there are other registers that need to be saved depends on the\n    particular machine, since not all recursive computations need the original\n    values of registers that are modified during solution of the subproblem\n    (see exercise ","tag":"#text"},{"tag":"REF","body":"5.4","href":"/sicpjs/5.1.4#ex-5.4"},{"body":").\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"A double recursion","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    Let us examine a more complex recursive process, the tree-recursive\n    computation of the\n    \n    Fibonacci numbers, which we introduced in\n    section ","tag":"#text"},{"tag":"REF","body":"1.2.2","href":"/sicpjs/1.2.2"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQEY0BYBQuAzAVwDsBjAFwEsB7E0AqgIwAoSBKUAb11D9ABOAUwpEB9egF5poAAy9+i-gH45CpYoBcoKTIzqNfVfsNaGzNqAC0oDJwDU51vRsAmdgG5cAX3yNWAGyeQA","body":"function fib(n) {\n    return n === 0\n           ? 0\n           : n === 1\n           ? 1\n           : fib(n - 1) + fib(n - 2);\n} "},{"body":"\n\n    Just as with factorial, we can implement the recursive Fibonacci\n    computation as a register machine with registers\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":",\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":".  The machine is more complex than\n    the one for factorial, because there are two places in the controller\n    sequence where we need to perform recursive calls—once to compute\n    Fib","tag":"#text"},{"body":"$(n-1)$","tag":"LATEX"},{"body":" and once to compute\n    Fib","tag":"#text"},{"body":"$(n-2)$","tag":"LATEX"},{"body":".  To set up for each of these calls,\n    we save the registers whose values will be needed later, set the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":"\n    register to the number whose Fib we need to compute recursively\n    (","tag":"#text"},{"body":"$n-1$","tag":"LATEX"},{"body":" or ","tag":"#text"},{"body":"$n-2$","tag":"LATEX"},{"body":"), and\n    assign to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"continue"},{"body":" the entry point in the main\n    sequence to which to return (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"afterfib_n_1"},{"body":" or\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"afterfib_n_2"},{"body":", respectively).  We then go to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fib_loop"},{"body":".  When we return from the\n    recursive call, the answer is in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"val"},{"body":".\n    Figure ","tag":"#text"},{"tag":"REF","body":"5.12","href":"/sicpjs/5.1.4#fig-5.12"},{"body":" shows the controller sequence\n    for this machine.\n    ","tag":"#text"},{"tag":"FIGURE","snippet":{"tag":"SNIPPET","latex":true,"eval":false,"body":"\ncontroller(\n  list(      \n    assign(\"continue\", label(\"fib_done\")),\n  \"fib_loop\",\n    test(list(op(\"<\"), reg(\"n\"), constant(2))),\n    branch(label(\"immediate_answer\")),\n    // set up to compute $\\textrm{Fib}(n-1)$\n    save(\"continue\"),\n    assign(\"continue\", label(\"afterfib_n_1\")),\n    save(\"n\"),                     // save old value of $\\texttt{n}$\n    assign(\"n\", list(op(\"-\"), reg(\"n\"), constant(1))), // clobber $\\texttt{n}$ to $n-1$\n    go_to(label(\"fib_loop\")),      // perform recursive call\n  \"afterfib_n_1\",                  // upon return, $\\texttt{val}$ contains $\\textrm{Fib}(n-1)$\n    restore(\"n\"),\n    restore(\"continue\"),\n    // set up to compute $\\textrm{Fib}(n-2)$\n    assign(\"n\", list(op(\"-\"), reg(\"n\"), constant(2))),\n    save(\"continue\"),\n    assign(\"continue\", label(\"afterfib_n_2\")),\n    save(\"val\"),                   // save $\\textrm{Fib}(n-1)$\n    go_to(label(\"fib_loop\")),\n  \"afterfib_n_2\",                  // upon return, $\\texttt{val}$ contains $\\textrm{Fib}(n-2)$\n    assign(\"n\", reg(\"val\")),       // $\\texttt{n}$ now contains $\\textrm{Fib}(n-2)$\n    restore(\"val\"),                // $\\texttt{val}$ now contains $\\textrm{Fib}(n-1)$\n    restore(\"continue\"),\n    assign(\"val\",                  // $\\textrm{Fib}(n-1) + \\textrm{Fib}(n-2)$\n      list(op(\"+\"), reg(\"val\"), reg(\"n\"))),\n    go_to(reg(\"continue\")),        // return to caller, answer in $\\texttt{val}$\n  \"immediate_answer\",\n    assign(\"val\", reg(\"n\")),       // base case: $\\textrm{Fib}(n) = n$\n    go_to(reg(\"continue\")),\n  \"fib_done\"))\n\t"},"captionHref":"/sicpjs/5.1.4#fig-5.12","captionName":"Figure 5.12 ","captionBody":[{"body":"\n\t    Controller for a machine to compute\n\t    \n\t    Fibonacci numbers.\n\t  ","tag":"#text"}]}]},{"tag":"EXERCISE","title":"Exercise 5.4","id":"#ex-5.4","child":[{"body":"\n    Specify register machines that implement each of the following\n    functions.\n    For each machine, write a controller instruction sequence\n    and draw a diagram showing the data paths.\n    ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\tRecursive exponentiation:\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQEY0BYBQuAzAVwDsBjAFwEsB7E0AUwA8AHCgCgCMAaUEgSlABvXKDGgATgwpEJ9egF4loAAyjxG8QH5QGdZo0AuUJ1AAqRqw48+oALS7+AblwBffMzbsAzL2zOgA","body":"function expt(b, n) {\n    return n === 0\n           ? 1\n           : b * expt(b, n - 1);\n} "}]},{"tag":"LI","child":[{"body":"\n\tIterative exponentiation:\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQEY0BYBQuAzAVwDsBjAFwEsB7E0AUwA8AHCgCgCMAaUEgSlABvAJChQuceOLlqdRqwoB9KhQYAndmRqk163i3U0AJkUqChkqdfUMKRdfW26NoALwfQABivW-1gH5QQxMzCl9-fwAuBTYVPS0dEj1QAFpQDF5OUAAqYKNTcwBuCIBfCNt7R1jlVQ12El4MfhLy3GY2dgBmXmwWoA","body":"function expt(b, n) {\t  \n    function expt_iter(counter, product) {\n        return counter === 0\n               ? product\n               : expt_iter(counter - 1, b * product);\n    }\n    return expt_iter(n, 1);\n} "}]}]}]},{"tag":"EXERCISE","title":"Exercise 5.5","id":"#ex-5.5","child":[{"body":"\n    Hand-simulate the factorial and Fibonacci machines, using some\n    nontrivial input (requiring execution of at least one recursive call).\n    Show the contents of the stack at each significant point in the\n    execution.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.6","id":"#ex-5.6","child":[{"body":"\n    Ben Bitdiddle observes that the Fibonacci machine's controller sequence\n    has an extra ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" and an extra\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":", which can be removed to make a faster\n    machine.  Where are these instructions?\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.1.4#footnote-link-1","child":[{"body":"One might argue that we don't need to save the old\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":"; after we decrement it and solve the\n    subproblem, we could simply increment it to recover the old value.  Although\n    this strategy works for factorial, it cannot work in general, since the old\n    value of a register cannot always be computed from the new one.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.1.4#footnote-link-2","child":[{"body":"In section ","tag":"#text"},{"tag":"REF","body":"5.3","href":"/sicpjs/5.3"},{"body":" we\n    will see how to implement a stack in terms of more primitive\n    operations.","tag":"#text"}]}]