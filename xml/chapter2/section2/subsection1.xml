    <SUBSECTION>
      <NAME>
        Representing Sequences
      </NAME>

      <LABEL NAME="sec:sequences"/>
      <TEXT>

        <SPLIT>
	        <SCHEME>
            <FIGURE>
              <FIGURE src="img_original/ch2-Z-G-13.svg"/>
              <CAPTION>The sequence 1, 2, 3, 4 represented as a chain of pairs. </CAPTION>
              <LABEL NAME="fig:sequence-of-pairs"/>
            </FIGURE>
	        </SCHEME>
	        <JAVASCRIPT>
            <FIGURE>
              <FIGURE src="img_javascript/ch2-Z-G-13.svg"/>
              <CAPTION>The sequence 1, 2, 3, 4 represented as a chain of pairs. </CAPTION>
              <LABEL NAME="fig:sequence-of-pairs"/>
            </FIGURE>
	        </JAVASCRIPT>
        </SPLIT>
      
        One of the useful structures we can build with pairs is a 
        <INDEX>sequence(s)</INDEX>
        <INDEX>sequence(s)<SUBINDEX>represented by pairs</SUBINDEX></INDEX>
        <INDEX>pair(s)<SUBINDEX>used to represent sequence</SUBINDEX></INDEX>
        <EM>
          sequence</EM><EMDASH/>an ordered collection of data objects.  There are, of
        course, many ways to represent sequences in terms of pairs.  One
        particularly straightforward representation is illustrated in
        figure<SPACE/><REF NAME="fig:sequence-of-pairs"/>, where the sequence 1, 2, 3, 4 is
        represented as a chain of pairs.  The <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> of each pair is the
        corresponding item in the chain, and the <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> of the pair is
        the next pair in the chain.  The <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> of the final pair
        signals the end of the sequence by pointing to a distinguished
        value that is not a pair, 
        represented in box-and-pointer diagrams as a diagonal line
        <INDEX>box-and-pointer notation<SUBINDEX>end-of-list marker</SUBINDEX></INDEX>
        and in programs as the value of 
        <!-- \indcode{nil}[end@as end-of-list marker] -->
        <INDEX>end-of-list marker</INDEX>
        <SPLITINLINE>
	  <SCHEME>the variable <SCHEMEINLINE>nil</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>JavaScript<APOS/>s value <JAVASCRIPTINLINE>null</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	  </SPLITINLINE>.
        The entire sequence is constructed by nested <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> operations:

        <SNIPPET PAGE="99">
          <NAME>cons_example</NAME>
          <SCHEME>
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
          </SCHEME>
          <JAVASCRIPT>
pair(1, 
     pair(2, 
          pair(3, 
               pair(4, null))));
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Such a sequence of pairs<SPLITINLINE><SCHEME>, formed by nested <SCHEMEINLINE>cons</SCHEMEINLINE>es,</SCHEME><JAVASCRIPT></JAVASCRIPT></SPLITINLINE> is called a
        <INDEX>list(s)</INDEX>
        <EM>list</EM>, and <SPLITINLINE><SCHEME>Scheme</SCHEME><JAVASCRIPT>our JavaScript environment</JAVASCRIPT></SPLITINLINE> provides a
        primitive called 
        <!--\indprim*{list}-->
        <!--\ind*{primitive
            <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
            (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[list@<SCHEMEINLINE>list</SCHEMEINLINE>]-->
        <SCHEMEINLINE>list</SCHEMEINLINE> to help in constructing 
        lists.<FOOTNOTE>In this book, we use <EM>list</EM> to mean a chain of
          pairs terminated by the end-of-list marker.  In contrast, the term
          <INDEX>list structure<SUBINDEX>list vs.</SUBINDEX></INDEX>
          <INDEX>list(s)<SUBINDEX>list structure vs.</SUBINDEX></INDEX>
          <EM>list structure</EM> refers to any data structure made out of pairs, 
          not just to lists.</FOOTNOTE>
      </TEXT>

      <TEXT>
        The above sequence could be produced by <SPLITINLINE><SCHEME><SCHEMEINLINE>(list 1 2 3 4)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list(1, 2, 3, 4)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  In
        general, 

        <SNIPPET EVAL="no" LATEX="yes">
          <SCHEME>
(list ^a$_{1}$^ ^a$_{2}$^ ^$\ldots$^ ^a$_{n}$^)
          </SCHEME>
          <JAVASCRIPT>
list(a$_{1}$, a$_{2}$, $\ldots$, a$_{n}$)
        </JAVASCRIPT>
        </SNIPPET>

        is equivalent to

        <SNIPPET EVAL="no" LATEX="yes">
          <SCHEME>
(cons ^a$_{1}$^ (cons ^a$_{2}$^ (cons ^$\ldots$^ (cons ^a$_{n}$^ nil) ^$\ldots$^)))
          </SCHEME>
          <JAVASCRIPT>
pair(a$_{1}$, pair(a$_{2}$, pair($\ldots$, pair(a$_{n}$, null)$\ldots$)))
        </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <SPLIT>
        <SCHEME>
      <TEXT>
        Lisp systems conventionally print lists by printing the sequence of
        <INDEX>list(s)<SUBINDEX>printed representation of</SUBINDEX></INDEX>
        elements, enclosed in parentheses.  Thus, the data object in
        figure<SPACE/><REF NAME="fig:sequence-of-pairs"/> is printed as <SCHEMEINLINE>(1 2 3 4)</SCHEMEINLINE>:
      </TEXT>
        </SCHEME>
        <JAVASCRIPT>
          <TEXT>
            Our interpreter prints pairs using a textual representation of
	    box-and-pointer diagrams. The result of
	    <JAVASCRIPTINLINE>pair(1, 2)</JAVASCRIPTINLINE>
            is printed as <JAVASCRIPTINLINE>[1, 2]</JAVASCRIPTINLINE>, and
	    the data object in
          figure<SPACE/><REF NAME="fig:sequence-of-pairs"/> 
          is printed as 
          <JAVASCRIPTINLINE>[1, [2, [3, [4, null]]]]</JAVASCRIPTINLINE>:
          </TEXT>
        </JAVASCRIPT>
      </SPLIT>

      <TEXT>
        <SNIPPET PAGE="100">
          <NAME>one_four</NAME>
          <EXAMPLE>one_four_example</EXAMPLE>
          <SCHEME>
(define one-through-four (list 1 2 3 4))
          </SCHEME>
          <JAVASCRIPT>
const one_through_four = list(1, 2, 3, 4);
          </JAVASCRIPT>
        </SNIPPET>
	
        <SNIPPET PAGE="100"  HIDE="yes">
          <NAME>one_four_example</NAME>
          <SCHEME>
one-through-four	    
          </SCHEME>
          <SCHEMEOUTPUT>
            (1 2 3 4)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
one_through_four;
// displays: [1, [2, [3, [4, null]]]]
          </JAVASCRIPT>
        </SNIPPET>

      </TEXT>

<!--Nice in Scheme is the convention to put question marks behind test functions. This syntax does not work in JavaScript. I use <TT>list</TT> for the test, and <TT>list</TT> for the constructor. Note the JavaScript feature of functions with variable numbers of parameters (accessed in the function body using <TT>arguments[i]</TT>, see <TT>js/javascript.js</TT> for the implementation of <TT>list</TT>).
-->

<SPLIT>
  <SCHEME>
      <TEXT>
        Be careful not to confuse the expression <SCHEMEINLINE>(list 1 2 3 4)</SCHEMEINLINE> with the
        list <SCHEMEINLINE>(1 2 3 4)</SCHEMEINLINE>, which is the result obtained when the expression
        is evaluated.  Attempting to evaluate the expression <SCHEMEINLINE>(1 2 3 4)</SCHEMEINLINE> 
        will signal an error when the interpreter tries to apply the
        procedure
        <SCHEMEINLINE>1</SCHEMEINLINE> to arguments 
        <SCHEMEINLINE>2</SCHEMEINLINE>, <SCHEMEINLINE>3</SCHEMEINLINE>, 
        and <SCHEMEINLINE>4</SCHEMEINLINE>.
      </TEXT>
  </SCHEME>
  <JAVASCRIPT>
    <CHANGE><OMISSION>No such problem in JavaScript</OMISSION></CHANGE>
  </JAVASCRIPT>
</SPLIT>

      <TEXT>
        We can think of 
        <INDEX>list(s)<SUBINDEX>manipulation with <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
        <!--\indprim{car}[list@as list operation]-->
        <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> as selecting the first item in the list, and
        of 
        <!--\indprim{cdr}[list@as list operation]-->
        <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> as selecting the sublist consisting of all but the first
        item.  Nested applications of <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> can be used to
        extract the second, third, and subsequent items in the
        list.<SPLITINLINE><SCHEME><FOOTNOTE>Since nested applications of <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
          are cumbersome to write, Lisp dialects provide abbreviations for
          them<EMDASH/>for instance, 
          <INDEX>nested applications of <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and and <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE></INDEX>
          <!-- \indcode{cadr} -->
          <P>
            <SCHEMEINLINE>(cadr arg)</SCHEMEINLINE> = <SCHEMEINLINE>(car (cdr arg))</SCHEMEINLINE>
          </P>
          The names of all such
          <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
          start with <SCHEMEINLINE>c</SCHEMEINLINE> and end with <SCHEMEINLINE>r</SCHEMEINLINE>.  Each <SCHEMEINLINE>a</SCHEMEINLINE> between them stands for a 
          <!-- \indcode{ca<ELLIPSIS/> r}\indcode{cd<ELLIPSIS/> r} -->
          <SCHEMEINLINE>car</SCHEMEINLINE> operation and
          each <SCHEMEINLINE>d</SCHEMEINLINE> for a <SCHEMEINLINE>cdr</SCHEMEINLINE>
          operation, to be applied in the same order
          in which they appear in the name.  The names <SCHEMEINLINE>car</SCHEMEINLINE>
          and 
          <SCHEMEINLINE>cdr</SCHEMEINLINE>
          persist because simple combinations like <SCHEMEINLINE>cadr</SCHEMEINLINE> are
          pronounceable.</FOOTNOTE></SCHEME></SPLITINLINE>
        The constructor 
        <!--\indprim{cons}[list@as list operation]-->
        <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> makes a list like the original one, 
        but with an additional item at the beginning.

        <SNIPPET PAGE="100">
          <NAME>car_one_four</NAME>
          <REQUIRES>one_four</REQUIRES>
          <SCHEME>
(car one-through-four)
          </SCHEME>
          <SCHEMEOUTPUT>
            1
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
head(one_through_four);
// result: 1	    
          </JAVASCRIPT>
        </SNIPPET>

<!-- Could not resist using <TT>head</TT> and <TT>tail</TT>, 
                   instead of referring to register names of 
                   <A href="http://www.columbia.edu/acis/history/704.html">
                   this awesome machine</A>.
-->

        <SNIPPET PAGE="100">
          <NAME>cdr_one_four</NAME>
          <REQUIRES>one_four</REQUIRES>
          <SCHEME>
(cdr one-through-four)
          </SCHEME>
          <SCHEMEOUTPUT>
            (2 3 4)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
tail(one_through_four);
// result: [2, [3, [4, null]]]
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET PAGE="101">
          <NAME>car_cdr_one_four</NAME>
          <REQUIRES>one_four</REQUIRES>
          <SCHEME>
(car (cdr one-through-four))
          </SCHEME>
          <SCHEMEOUTPUT>
            2
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
head(tail(one_through_four));
// result: 2
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET PAGE="101">
          <NAME>cons_one_four</NAME>
          <REQUIRES>one_four</REQUIRES>
          <SCHEME>
(cons 10 one-through-four)
          </SCHEME>
          <SCHEMEOUTPUT>
            (10 1 2 3 4)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
pair(10, one_through_four);
// result: [10, [1, [2, [3, [4, null]]]]]
          </JAVASCRIPT>
        </SNIPPET>

<!-- Not sure about the choice of the name <TT>pair</TT> here. 
                   Maybe <TT>cons</TT> would be nicer...
-->


        <SNIPPET PAGE="101">
          <NAME>cons5_one_four</NAME>
          <REQUIRES>one_four</REQUIRES>
          <SCHEME>
(cons 5 one-through-four)
          </SCHEME>
          <SCHEMEOUTPUT>
            (5 1 2 3 4)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
pair(5, one_through_four);
// result: [5, [1, [2, [3, [4, null]]]]]
          </JAVASCRIPT>
        </SNIPPET>

      </TEXT>

      <SPLIT>
        <SCHEME>
      <TEXT>
        The value of <SCHEMEINLINE>nil</SCHEMEINLINE>, 
        used to terminate the chain of pairs, can be
        thought of as a sequence of no elements, the 
        <INDEX>empty list</INDEX>
        <!-- \indcode{nil}[empty@as empty list] -->
        <EM>empty list</EM>.  The
        word <EM>nil</EM> is a contraction of the Latin word <EM>nihil</EM>, which
        means <QUOTE>nothing.</QUOTE><FOOTNOTE>It<APOS/>s remarkable how much energy in the
          standardization of Lisp dialects has been dissipated in arguments that
          are literally over nothing: Should <SCHEMEINLINE>nil</SCHEMEINLINE> be an ordinary name?
          Should the value of <SCHEMEINLINE>nil</SCHEMEINLINE> be a symbol?  Should it be a list?
          Should it be a pair?  
          <!-- \indcode{nil}[ordinary@as ordinary variable in Scheme] -->
          In Scheme, <SCHEMEINLINE>nil</SCHEMEINLINE> is an ordinary name, 
          which we use in this section as a variable whose value is
          the end-of-list marker (just as <SCHEMEINLINE>true</SCHEMEINLINE> is an ordinary variable
          that has a true value).  Other dialects of
          Lisp, including Common Lisp, treat <SCHEMEINLINE>nil</SCHEMEINLINE> as a special symbol.  The
          <INDEX>Common Lisp<SUBINDEX>treatment of <SCHEMEINLINE>nil</SCHEMEINLINE></SUBINDEX></INDEX>
          authors of this book, who have endured too many language
          standardization brawls, would like to avoid the entire issue.  Once we
          have introduced quotation in section<SPACE/><REF NAME="sec:symbolic-data"/>, we will
          denote the empty list as <SCHEMEINLINE>'()</SCHEMEINLINE> and dispense with the
          variable <SCHEMEINLINE>nil</SCHEMEINLINE> entirely.</FOOTNOTE>
      </TEXT>
        </SCHEME> 
        <JAVASCRIPT>
      <TEXT>
        The value <JAVASCRIPTINLINE>null</JAVASCRIPTINLINE>, 
        used to terminate the chain of pairs, can be
        thought of as a sequence of no elements, the 
        <INDEX>empty list</INDEX>
        <!-- \indcode{nil}[empty@as empty list] -->
        <EM>empty list</EM>.
      </TEXT>
        </JAVASCRIPT>
      </SPLIT>

      <SUBHEADING>
        <NAME>List operations</NAME>
      </SUBHEADING>

      <INDEX>list(s)<SUBINDEX>operations on|(</SUBINDEX></INDEX>
      <INDEX>list(s)<SUBINDEX>techniques for manipulating|(</SUBINDEX></INDEX>
      <TEXT>
        The use of pairs to represent sequences of elements as lists is
        accompanied by conventional programming techniques for manipulating
        lists by successively 
        <!--\indcodeplus{cdr}{down a list}-->
        <INDEX>list(s)<SUBINDEX>cdring@<SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>ing down</SUBINDEX></INDEX>
        <QUOTE><SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>ing down</QUOTE> the lists.  For example, 
        the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <INDEX>list(s)<SUBINDEX>nth@<LATEXINLINE>$n$</LATEXINLINE>th element of</SUBINDEX></INDEX>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>list-ref</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> takes as arguments a list and a number
        <LATEXINLINE>$n$</LATEXINLINE> and returns the <LATEXINLINE>$n$</LATEXINLINE>th item of the list.  It is customary to
        number the elements of the list beginning with 0.  The method for
        computing <SPLITINLINE><SCHEME><SCHEMEINLINE>list-ref</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is the following:

        <UL>
          <LI>For <LATEXINLINE>$n=0$</LATEXINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>list-ref</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> should return the <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> of the list.
          </LI>n
          <LI>Otherwise, <SPLITINLINE><SCHEME><SCHEMEINLINE>list-ref</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> should return  the <LATEXINLINE>$(n-1)$</LATEXINLINE>st item of the
            <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> of the list.
          </LI>
        </UL>

        <SNIPPET PAGE="101">
          <NAME>list_ref</NAME>
          <EXAMPLE>list_ref_example</EXAMPLE>
          <SCHEME>
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
          </SCHEME>
          <SCHEMEOUTPUT>
            16
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
function list_ref(items, n) {
    return n === 0
           ? head(items)
           : list_ref(tail(items), n - 1);
}
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
// we avoid overriding the predeclared list_ref
// function by using the name list_ref_ here
function list_ref_(items, n) {
    return n === 0
           ? head(items)
           : list_ref_(tail(items), n - 1);
}
          </JAVASCRIPT_RUN>
        </SNIPPET>

        <SNIPPET PAGE="101">
          <NAME>list_ref_example</NAME>
          <REQUIRES>list_ref_example</REQUIRES>
          <SCHEME>
(define squares (list 1 4 9 16 25))
(list-ref squares 3)
          </SCHEME>
          <JAVASCRIPT>
const squares = list(1, 4, 9, 16, 25);
list_ref(squares, 3);
// result: 16
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
const squares = list(1, 4, 9, 16, 25);
list_ref_(squares, 3);
// result: 16
          </JAVASCRIPT_RUN>
          
        </SNIPPET>

        <SNIPPET PAGE="101" HIDE="yes">
          <NAME>manual_squares</NAME>
          <SCHEME>
(define squares (list 1 4 9 16 25))
          </SCHEME>
          <JAVASCRIPT>
const squares = list(1, 4, 9, 16, 25);
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET PAGE="101" HIDE="yes">
          <NAME>manual_odds</NAME>
          <SCHEME>
(define squares (list 1 3 5 7))
          </SCHEME>
          <JAVASCRIPT>
const squares = list(1, 3, 5, 7);
          </JAVASCRIPT>
        </SNIPPET>

      </TEXT>

      <TEXT>
        Often we <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> down the whole list.  To aid in this, <SPLITINLINE><SCHEME>Scheme</SCHEME><JAVASCRIPT>our JavaScript environment</JAVASCRIPT></SPLITINLINE> includes
          a <SPLITINLINE><SCHEME>primitive predicate</SCHEME><JAVASCRIPT>predicate</JAVASCRIPT></SPLITINLINE>
        <!--\ind*{primitive
            <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
            (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[null?@<SCHEMEINLINE>null?</SCHEMEINLINE>]-->
        <INDEX>empty list<SUBINDEX>recognizing with <SCHEMEINLINE>null?</SCHEMEINLINE></SUBINDEX></INDEX>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>null?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>is_null</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, which tests whether its argument is
        the empty list.  The
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <!-- \indcode{length} -->
        <INDEX>list(s)<SUBINDEX>length of</SUBINDEX></INDEX>
        <SCHEMEINLINE>length</SCHEMEINLINE>, which
        returns the number of items in a list, illustrates this typical
        pattern of use:

        <SNIPPET PAGE="102">
          <NAME>length</NAME>
          <EXAMPLE>length_example</EXAMPLE>
          <SCHEME>
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
          </SCHEME>
          <JAVASCRIPT>
function length(items) {
    return is_null(items)
           ? 0
           : 1 + length(tail(items));
}
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
// we avoid overriding the predeclared length
// function by using the name length_ here
function length_(items) {
    return is_null(items)
           ? 0
           : 1 + length_(tail(items));
}
          </JAVASCRIPT_RUN>
        </SNIPPET>

        <SNIPPET PAGE="102" HIDE="yes">
          <NAME>length_example</NAME>
          <SCHEME>
(define odds (list 1 3 5 7))
(length odds)
          </SCHEME>
          <JAVASCRIPT>
const odds = list(1, 3, 5, 7);
length(odds);
// returns: 4
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
const odds = list(1, 3, 5, 7);
length_(odds);
// returns: 4
          </JAVASCRIPT_RUN>
        </SNIPPET>
      </TEXT>

      <TEXT>
        The <SCHEMEINLINE>length</SCHEMEINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        implements a simple recursive plan. The
        reduction step is:

        <UL>
          <LI>The <SCHEMEINLINE>length</SCHEMEINLINE> of any list is 1 plus the <SCHEMEINLINE>length</SCHEMEINLINE> of the
            <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> of the list.
          </LI>
        </UL>
      </TEXT>

      <TEXT>
        This is applied successively until we reach the base case:

        <UL>
          <LI>The <SCHEMEINLINE>length</SCHEMEINLINE> of the empty list is 0.
          </LI>
        </UL>
      </TEXT>

      <TEXT>
        We could also compute <SCHEMEINLINE>length</SCHEMEINLINE> in an iterative style:

        <SNIPPET PAGE="102">
          <NAME>length_iter</NAME>
          <EXAMPLE>length_example</EXAMPLE>
          <SCHEME>
(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
          </SCHEME>
          <JAVASCRIPT>
function length(items) {
    function length_iter(a, count) {
        return is_null(a)
               ? count
               : length_iter(tail(a), count + 1);
    }
    return length_iter(items, 0);
}
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
// we avoid overriding the predeclared length
// function by using the name length_ here
function length_(items) {
    function length_iter(a, count) {
        return is_null(a)
               ? count
               : length_iter(tail(a), count + 1);
    }
    return length_iter(items, 0);
}
          </JAVASCRIPT_RUN>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Another conventional programming technique is to 
        <!--\indcodeplus{cons}{up a list}-->
        <INDEX>list(s)<SUBINDEX>consing@<SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>ing up</SUBINDEX></INDEX>
        <QUOTE><SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> up</QUOTE> an
        answer list while <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>ing down a list, as in the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <!-- \indcode{append} -->
        <INDEX>list(s)<SUBINDEX>combining with <SCHEMEINLINE>append</SCHEMEINLINE></SUBINDEX></INDEX>
        <SCHEMEINLINE>append</SCHEMEINLINE>, which takes two lists as arguments and combines their
        elements to make a new list:

        <SNIPPET PAGE="102">
          <NAME>append_example</NAME>
          <REQUIRES>append</REQUIRES>
          <REQUIRES>manual_squares</REQUIRES>
          <REQUIRES>manual_odds</REQUIRES>
	  <EXAMPLE>append_example_example</EXAMPLE>
          <SCHEME>
(append squares odds)
          </SCHEME>
          <JAVASCRIPT>
append(squares, odds);
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
append_(squares, odds);
          </JAVASCRIPT_RUN>
        </SNIPPET>

        <SNIPPET PAGE="102">
          <NAME>append_example_example</NAME>
          <JAVASCRIPT>
// returns: [1, [4, [9, [16, [25, [1, [3, [5, [7, null]]]]]]]]]
	  </JAVASCRIPT>
	</SNIPPET>

        <SNIPPET PAGE="102">
          <NAME>append_example2</NAME>
          <REQUIRES>append</REQUIRES>
          <REQUIRES>manual_squares</REQUIRES>
          <REQUIRES>manual_odds</REQUIRES>
	  <EXAMPLE>append_example2_example</EXAMPLE>
          <REQUIRES>manual_squares</REQUIRES>
          <SCHEME>
(append odds squares)
          </SCHEME>
          <SCHEMEOUTPUT>
            (1 3 5 7 1 4 9 16 25)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
append(odds, squares);
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
append_(odds, squares);
          </JAVASCRIPT_RUN>
        </SNIPPET>

        <SNIPPET PAGE="102" HIDE="yes">
          <NAME>append_example2_example</NAME>
          <JAVASCRIPT>
// returns: [1, [3, [5, [7, [1, [4, [9, [16, [25, null]]]]]]]]]
	  </JAVASCRIPT>
	</SNIPPET>

	
      </TEXT>

      <TEXT>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>Append</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The function <JAVASCRIPTINLINE>append</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	is also implemented using a recursive plan.
	To <SCHEMEINLINE>append</SCHEMEINLINE>
        lists <SCHEMEINLINE>list1</SCHEMEINLINE> and <SCHEMEINLINE>list2</SCHEMEINLINE>,
	do the following:
        <UL>
          <LI>If <SCHEMEINLINE>list1</SCHEMEINLINE> is the empty list, then the result is just <SCHEMEINLINE>list2</SCHEMEINLINE>.
          </LI>
          <LI>Otherwise, <SCHEMEINLINE>append</SCHEMEINLINE> the <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> of <SCHEMEINLINE>list1</SCHEMEINLINE> and 
            <SCHEMEINLINE>list2</SCHEMEINLINE>, and <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> the <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> of <SCHEMEINLINE>list1</SCHEMEINLINE> onto the result:
          </LI>
        </UL>

        <SNIPPET PAGE="103">
          <NAME>append</NAME>
          <EXAMPLE>append_example_manual</EXAMPLE>
          <SCHEME>
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
          </SCHEME>
          <JAVASCRIPT>
function append(list1, list2) {
    return is_null(list1)
           ? list2
           : pair(head(list1), append(tail(list1), list2));
}
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
// we avoid overriding the predeclared append
// function by using the name append_ here
function append_(list1, list2) {
    return is_null(list1)
           ? list2
           : pair(head(list1), append_(tail(list1), list2));
}
          </JAVASCRIPT_RUN>
        </SNIPPET>
      </TEXT>

      <EXERCISE><LABEL NAME="ex:last"/> 
        Define a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>

        <!-- \indcode{last-pair} -->
        <INDEX>list(s)<SUBINDEX>last pair of</SUBINDEX></INDEX>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>last-pair</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>last_pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> that returns the list that contains only
        the last element of a given (nonempty) list:

        <SNIPPET PAGE="104" HIDE="yes">
          <NAME>last_pair_by_student</NAME>
          <SCHEME>
;; last-pair to be given by student
          </SCHEME>
          <JAVASCRIPT>
// last_pair to be given by student
          </JAVASCRIPT>
        </SNIPPET>

	
        <SNIPPET PAGE="103">
          <NAME>last_pair_example</NAME>
	  <REQUIRES>last_pair_by_student</REQUIRES>
          <SCHEME>
(last-pair (list 23 72 149 34))
          </SCHEME>
          <JAVASCRIPT>
last_pair(list(23, 72, 149, 34));
// result: [34, null]
          </JAVASCRIPT>
        </SNIPPET>
<SOLUTION>
    <SNIPPET>
      <EXAMPLE>last_pair_example</EXAMPLE>
    <JAVASCRIPT>
function last_pair(items) {
    return is_null(tail(items))
           ? items
           : last_pair(tail(items));
}
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET>
  </SOLUTION>
      </EXERCISE>

      <EXERCISE><LABEL NAME="ex:reverse"/>
        Define a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>

        <!-- \indcode{reverse} -->
        <INDEX>list(s)<SUBINDEX>reversing</SUBINDEX></INDEX>
        <SCHEMEINLINE>reverse</SCHEMEINLINE> that takes a list as argument and
        returns a list of the same elements in reverse order:

        <SNIPPET PAGE="103">
          <NAME>reverse_example</NAME>
          <SCHEME>
(reverse (list 1 4 9 16 25))
          </SCHEME>
          <SCHEMEOUTPUT>
            (25 16 9 4 1)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
reverse(list(1, 4, 9, 16, 25));
// result: [25, [16, [9, [4, [1, null]]]]]
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
reverse_(list(1, 4, 9, 16, 25));
// result: [25, [16, [9, [4, [1, null]]]]]
          </JAVASCRIPT_RUN>
        </SNIPPET>
<SOLUTION>
	<SNIPPET>
    <EXAMPLE>reverse_example</EXAMPLE>
	  <JAVASCRIPT>
// naive reverse (what is the runtime?)
function reverse(items) {
    return is_null(items)
           ? null
           : append(reverse(tail(items)),
	            pair(head(items), null));
}
</JAVASCRIPT>
 <JAVASCRIPT_RUN>
// to avoid overriding of builtin reverse function
// use function name reverse_

// naive reverse (what is the runtime?)
function reverse_(items) {
    return is_null(items)
           ? null
           : append(reverse_(tail(items)),
	            pair(head(items), null));
}
</JAVASCRIPT_RUN>
    </SNIPPET>

 <SNIPPET>
    <EXAMPLE>reverse_example</EXAMPLE>
    <JAVASCRIPT>   
// a better version
function reverse(items) {
    function reverse_iter(items, result) {
        return is_null(items)
               ? result
               : reverse_iter(tail(items),
	                      pair(head(items), result));
    }
    return reverse_iter(items, null);
}
	  </JAVASCRIPT>
    <JAVASCRIPT_RUN>   
// to avoid overriding of builtin reverse function
// use function name reverse_

// a better version
function reverse_(items) {
    function reverse_iter(items, result) {
        return is_null(items)
               ? result
               : reverse_iter(tail(items),
	                      pair(head(items), result));
    }
    return reverse_iter(items, null);
}
    </JAVASCRIPT_RUN>
    </SNIPPET>
  </SOLUTION>
      </EXERCISE>

      <EXERCISE> 
        <P>
          Consider the 
          <INDEX>counting change</INDEX>
          change-counting program of
          section<SPACE/><REF NAME="sec:tree-recursion"/>.  It would be nice to be able to
          easily change the currency used by the program, so that we could
          compute the number of ways to change a British pound, for example.  As
          the program is written, the knowledge of the currency is distributed
          partly into the
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          <SPLITINLINE><SCHEME><SCHEMEINLINE>first-denomination</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>first_denomination</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and partly into the
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          <SPLITINLINE><SCHEME><SCHEMEINLINE>count-change</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>count_change</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> (which knows that there are five
          kinds of U.S. coins).  It would be nicer to be able to
          supply a list of coins to be used for making change.
        </P>
        <P>
          We want to rewrite the
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          <SCHEMEINLINE>cc</SCHEMEINLINE> so that its
          second argument is a list of the values of the
          coins to use rather than an integer specifying which coins to use.  We
          could then have lists that defined each kind of currency:
        <SNIPPET PAGE="103">
          <NAME>us_coins</NAME>
          <SCHEME>
(define us-coins (list 50 25 10 5 1))

(define uk-coins (list 100 50 20 10 5 2 1 0.5))
          </SCHEME>
          <JAVASCRIPT>
const us_coins = list(50, 25, 10, 5, 1);
const uk_coins = list(100, 50, 20, 10, 5, 2, 1, 0.5);
          </JAVASCRIPT>
        </SNIPPET>

          We could then call <SCHEMEINLINE>cc</SCHEMEINLINE> as follows:

        <SNIPPET PAGE="103">
          <NAME>cc_example</NAME>
          <REQUIRES>cc</REQUIRES>
          <REQUIRES>us_coins</REQUIRES>
          <SCHEME>
(cc 100 us-coins)
          </SCHEME>
            <SCHEMEOUTPUT>
              292
            </SCHEMEOUTPUT>
          <JAVASCRIPT>
cc(100, us_coins);
          </JAVASCRIPT>
        </SNIPPET>

          To do this will require changing the program <SCHEMEINLINE>cc</SCHEMEINLINE> somewhat.  It will
          still have the same form, but it will access its second argument
          differently, as follows:

        <SNIPPET PAGE="104" HIDE="yes">
          <NAME>cc_helpers</NAME>
          <SCHEME>
;; first-denomination, except-first-denomination
;; and no-more? to be given by student
          </SCHEME>
          <JAVASCRIPT>
// first_denomination, except_first_denomination
// and no_more to be given by student
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET PAGE="104">
          <NAME>cc</NAME>
          <REQUIRES>cc_helpers</REQUIRES>
	  <EXAMPLE>cc_example</EXAMPLE>
          <SCHEME>
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
          </SCHEME>
          <JAVASCRIPT>
function cc(amount, coin_values) {
    return amount === 0
           ? 1
           : amount &lt; 0 || no_more(coin_values)
             ? 0
             : cc(amount,
	          except_first_denomination(coin_values))
               +
               cc(amount - first_denomination(coin_values), 
                  coin_values);
}
          </JAVASCRIPT>
        </SNIPPET>

        </P>
        <P>
          Define the
          <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
          <SPLITINLINE><SCHEME><SCHEMEINLINE>first-denomination</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>first_denomination</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>except-first-denomination</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>except_first_denomination</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and <SPLITINLINE><SCHEME><SCHEMEINLINE>no-more?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>no_more</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> in terms of primitive
          operations on list structures.  Does the order of the list <SPLITINLINE><SCHEME><SCHEMEINLINE>coin-values</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>coin_values</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> affect the answer produced by <SCHEMEINLINE>cc</SCHEMEINLINE>?  Why or why not?
        </P>
<SOLUTION>
    <SNIPPET>
    <REQUIRES>cc</REQUIRES>
    <EXAMPLE>cc_example</EXAMPLE>
    <JAVASCRIPT>
function first_denomination(coin_values) {
    return head(coin_values);
}
function except_first_denomination(coin_values) {
    return tail(coin_values);
}
function no_more(coin_values) {
    return is_null(coin_values);
}
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET>
    The order of the list <JAVASCRIPTINLINE>coin_values</JAVASCRIPTINLINE>
    does not affect the answer given by any correct solution of the problem,
    because the given list represents an unordered collection of denominations.
</SOLUTION>
      </EXERCISE>

      <SPLIT>
        <SCHEME>
	  <EXERCISE>
	    <LABEL NAME="ex:dotted-arglist"/>
        <INDEX>dotted-tail notation<SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>@for
            <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
            parameters</SUBINDEX></INDEX>
        <!--\indsf{define}[dotted@with dotted-tail notation]-->
        <INDEX>argument(s)<SUBINDEX>arbitrary number of</SUBINDEX></INDEX>
        <INDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>arbitrary number of arguments</SUBINDEX></INDEX>
        The
        procedures
        <SCHEMEINLINE>+</SCHEMEINLINE>, <SCHEMEINLINE>*</SCHEMEINLINE>, and <SCHEMEINLINE>list</SCHEMEINLINE> take arbitrary numbers
        of arguments. One way to define such
        procedures
        is to use <SCHEMEINLINE>define</SCHEMEINLINE>
        with <EM>dotted-tail notation</EM>.  In a
        procedure
        definition, a parameter
        list that has a dot before the last parameter name indicates that, when the
        procedure
        is called, the initial parameters (if any) will have as values
        the initial arguments, 
        as usual, but the final parameter<APOS/>s value will be a <EM>list</EM> of
        any remaining arguments.
        For instance, given the definition
        <SNIPPET>
          <SCHEME>
            (define (f x y . z) ^$\langle \textit{body} \rangle$^)
          </SCHEME>
        </SNIPPET>

        the
        procedure
        <SCHEMEINLINE>f</SCHEMEINLINE> can be called with two or more arguments.
        If we evaluate
        <SNIPPET>
          <SCHEME>
            (f 1 2 3 4 5 6)
          </SCHEME>
        </SNIPPET>

        then in the body of <SCHEMEINLINE>f</SCHEMEINLINE>, <SCHEMEINLINE>x</SCHEMEINLINE> will be 1, <SCHEMEINLINE>y</SCHEMEINLINE> will be
        2, and <SCHEMEINLINE>z</SCHEMEINLINE> will be the list <SCHEMEINLINE>(3 4 5 6)</SCHEMEINLINE>.
        Given the definition
        <SNIPPET>
          <SCHEME>
            (define (g . w) ^$\langle \textit{body} \rangle$^)
          </SCHEME>
        </SNIPPET>
        the
        procedure
        <SCHEMEINLINE>g</SCHEMEINLINE> can be called with zero or more arguments.
        If we evaluate
        <SNIPPET>
          <SCHEME>
            (g 1 2 3 4 5 6)
          </SCHEME>
        </SNIPPET>

        then in the body of <SCHEMEINLINE>g</SCHEMEINLINE>, <SCHEMEINLINE>w</SCHEMEINLINE> will be the
        list <SCHEMEINLINE>(1 2 3 4 5 6)</SCHEMEINLINE>.<FOOTNOTE>To define <SCHEMEINLINE>f</SCHEMEINLINE> and <SCHEMEINLINE>g</SCHEMEINLINE> using
          <!--\indsf{lambda}[dotted@with dotted-tail notation]-->
          <SCHEMEINLINE>lambda</SCHEMEINLINE> we would write
          <SNIPPET EVAL="no">
            <SCHEME>
              (define f (lambda (x y . z) ^body^))
              (define g (lambda w ^body^))
            </SCHEME>
        </SNIPPET></FOOTNOTE>

        Use this notation
        to write a
        procedure
        <SCHEMEINLINE>same-parity</SCHEMEINLINE> that takes one or more integers
        and returns a list of all the arguments that have the same even-odd
        parity as the first argument.  For example, 
        <SNIPPET PAGE="104">
          <NAME>same_parity</NAME>
          <SCHEME>
;; same-parity to be given by student
          </SCHEME>
        </SNIPPET>
        <SNIPPET PAGE="104">
          <NAME>same_parity_example</NAME>
          <REQUIRES>same_parity</REQUIRES>
          <SCHEME>
(same-parity 1 2 3 4 5 6 7)
          </SCHEME>
          <SCHEMEOUTPUT>
(1 3 5 7)
          </SCHEMEOUTPUT>
        </SNIPPET>

        <SNIPPET PAGE="104">
          <NAME>same_parity_example2</NAME>
          <REQUIRES>same_parity</REQUIRES>
          <SCHEME>
(same-parity 2 3 4 5 6 7)
          </SCHEME>
          <SCHEMEOUTPUT>
(2 4 6)
          </SCHEMEOUTPUT>
        </SNIPPET>

      </EXERCISE>
      <INDEX>list(s)<SUBINDEX>operations on|)</SUBINDEX></INDEX>
      <INDEX>list(s)<SUBINDEX>techniques for manipulating|)</SUBINDEX></INDEX>
    </SCHEME>
      
    <JAVASCRIPT>

      <EXERCISE>
	In the presence of higher-order functions, it is not strictly necessary
	for functions to have multiple parameters; one would
	suffice.<FOOTNOTE>Exercise 2.20 of the original textbook deals with Scheme
	operators that take variable numbers of arguments. This concept exists
	in JavaScript, but plays a less prominent role. The textbook adaptors
	decided to sneak in currying on this occasion.
      </FOOTNOTE>
	If we have
	a function such as <JAVASCRIPTINLINE>plus</JAVASCRIPTINLINE> that
	naturally requires two parameters, we could write a variant of the function
	to which we pass the arguments one at
	at time. An application of the variant to the first argument could return a
	function that we can then apply to the second argument, and so on. This
	practice<EMDASH/>called
	<EM>currying</EM> and named after the American mathematician and
	logician Haskell Brooks Curry<EMDASH/>is quite common
	in programming languages such as Haskell (the reader might venture a guess 
	after whom this programming language is named) and Ocaml. In JavaScript, a curried
	version of <JAVASCRIPTINLINE>plus</JAVASCRIPTINLINE> looks as follows.
	<SNIPPET>
	  <NAME>currying_plus</NAME>
	  <EXAMPLE>curry_example</EXAMPLE>
	  <JAVASCRIPT>
function plus_curried(x) {	    
    return y => x + y;
}
	  </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET HIDE="yes">
	  <NAME>curry_example</NAME>
	  <JAVASCRIPT>
plus_curried(3)(4);
	  </JAVASCRIPT>
	</SNIPPET>
	Write a function <JAVASCRIPTINLINE>brooks</JAVASCRIPTINLINE>, that
	takes a curried function as first argument and as second argument a list
	of arguments to which the curried function is then applied, one by one,
	in the given order. For example, the following application of
	<JAVASCRIPTINLINE>brooks</JAVASCRIPTINLINE> should have the
	same effect as the call <JAVASCRIPTINLINE>plus_curried(3)(4)</JAVASCRIPTINLINE> above.


	<SNIPPET HIDE="yes">
	  <NAME>currying</NAME>
	  <JAVASCRIPT>
// brooks to be written by the student
	  </JAVASCRIPT>
	</SNIPPET>

	<SNIPPET>
	  <NAME>currying_example</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>currying</REQUIRES>
	  <JAVASCRIPT>
brooks(plus_curried, list(3, 4));
	  </JAVASCRIPT>
	</SNIPPET>

	While we are at it, we might as well curry the function
	<JAVASCRIPTINLINE>brooks</JAVASCRIPTINLINE>! Write
	a function 
	<JAVASCRIPTINLINE>brooks_curried</JAVASCRIPTINLINE> that
	can be applied as follows, to yield the same result 7:

	<SNIPPET HIDE="yes">
	  <NAME>currying_currying</NAME>
	  <JAVASCRIPT>
// brooks_curried to be written by the student
	  </JAVASCRIPT>
	</SNIPPET>

	<SNIPPET>
	  <NAME>currying_currying_example</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>currying_currying</REQUIRES>
	  <JAVASCRIPT>
brooks_curried(list(plus_curried, 3, 4));
	  </JAVASCRIPT>
	</SNIPPET>

	With this function 
	<JAVASCRIPTINLINE>brooks_curried</JAVASCRIPTINLINE>
	what are the results of evaluating the following two statements?

	<SNIPPET>
	  <NAME>currying_currying_example_2</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>currying_currying</REQUIRES>
	  <JAVASCRIPT>
brooks_curried(list(brooks_curried,
                    list(plus_curried, 3, 4)));
	  </JAVASCRIPT>
	</SNIPPET>

	<SNIPPET>
	  <NAME>currying_currying_example_3</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>currying_currying</REQUIRES>
	  <JAVASCRIPT>
brooks_curried(list(brooks_curried,
                    list(brooks_curried, 
                         list(plus_curried, 3, 4))));
	  </JAVASCRIPT>
	</SNIPPET>
		
	<SOLUTION>
	  <OL>
	    <LI>
	      <SNIPPET>
		<NAME>brooks_solution</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <EXAMPLE>currying_example</EXAMPLE>
	  <JAVASCRIPT>
function brooks(f, items) {
    return is_null(items)
           ? f
           : brooks(f(head(items)), tail(items));
}	   
	  </JAVASCRIPT>
	</SNIPPET>
	    </LI>
	    <LI>
	<SNIPPET>
	  <NAME>brooks_curried_solution</NAME>
	  <REQUIRES>brooks_solution</REQUIRES>
	  <EXAMPLE>currying_currying_example</EXAMPLE>
	  <JAVASCRIPT>
function brooks_curried(items) {
    return brooks(head(items), tail(items));
}	   
	  </JAVASCRIPT>
	</SNIPPET>
	    </LI>
	    <LI>
The statement 
	<SNIPPET>
	  <NAME>currying_currying_example_4</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>brooks_curried_solution</REQUIRES>
	  <JAVASCRIPT>
brooks_curried(list(brooks_curried,
                    list(plus_curried, 3, 4)));
	  </JAVASCRIPT>
	</SNIPPET>
	of course evaluates to 7, as does
	    </LI>
	    <LI>
	<SNIPPET>
	  <NAME>currying_currying_example_5</NAME>
	  <REQUIRES>currying_plus</REQUIRES>
	  <REQUIRES>brooks_curried_solution</REQUIRES>
	  <JAVASCRIPT>
brooks_curried(list(brooks_curried,
                    list(brooks_curried, 
                         list(plus_curried, 3, 4))));
	  </JAVASCRIPT>
	</SNIPPET>
	    </LI>
	  </OL>
	</SOLUTION>
	
      </EXERCISE>
      
    </JAVASCRIPT>
      
      </SPLIT>

      <SUBHEADING>
        <NAME>Mapping over lists</NAME>
      </SUBHEADING>

      <INDEX>list(s)<SUBINDEX>mapping over|(</SUBINDEX></INDEX>
      <INDEX>mapping<SUBINDEX>list@over lists|(</SUBINDEX></INDEX>
      <TEXT>
        One extremely useful operation is to apply some transformation
        to each element in a list and generate the list of results.
        For instance, the following
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        scales each number in a list by
        a given factor:

        <SNIPPET PAGE="105">
          <NAME>scale_list</NAME>
          <EXAMPLE>scale_list_example</EXAMPLE>
          <SCHEME>
(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))
          </SCHEME>
          <JAVASCRIPT>
function scale_list(items, factor) {
    return is_null(items)
           ? null
           : pair(head(items) * factor, 
                  scale_list(tail(items), factor));
}
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET PAGE="105" HIDE="yes">
          <NAME>scale_list_example</NAME>
          <SCHEME>
(scale-list (list 1 2 3 4 5) 10)
          </SCHEME>
          <SCHEMEOUTPUT>
            (10 20 30 40 50)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
scale_list(list(1, 2, 3, 4, 5), 10);
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        We can abstract this general idea and capture it as a common pattern
        expressed as a higher-order
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, just as in
        section<SPACE/><REF NAME="sec:higher-order-procedures"/>.  The higher-order
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        here is called <SCHEMEINLINE>map</SCHEMEINLINE>.  <SPLITINLINE><SCHEME><SCHEMEINLINE>Map</SCHEMEINLINE></SCHEME><JAVASCRIPT>The function <JAVASCRIPTINLINE>map</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> takes as arguments a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        of one argument
        and a list, and returns a list of the results produced by
        applying the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        to each element in the list:<SPLITINLINE>
	<SCHEME>
	  <FOOTNOTE><LABEL NAME="foot:generalmap"/>	  
	    Scheme standardly provides a 
          <!-- \indcode{map}[with multiple arguments] -->
          <SCHEMEINLINE>map</SCHEMEINLINE>
	  procedure that is more general
          than the one described here.
          This more general <SCHEMEINLINE>map</SCHEMEINLINE>
          takes a procedure
          of <LATEXINLINE>$n$</LATEXINLINE> arguments,
	  together with <LATEXINLINE>$n$</LATEXINLINE> lists, and
          applies the procedure
          to all the first elements of
          the lists, all the second elements of the lists, and so on, 
          returning a list of the results.  For example:
        <SNIPPET PAGE="105">
          <NAME>general_map_example</NAME>
          <REQUIRES>general_map</REQUIRES>
          <REQUIRES>plus</REQUIRES>
          <SCHEME>
(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
          </SCHEME>
          <SCHEMEOUTPUT>
            (741 852 963)
          </SCHEMEOUTPUT>
        </SNIPPET>

        <SNIPPET PAGE="105">
          <NAME>general_map_example2</NAME>
          <REQUIRES>general_map</REQUIRES>
          <SCHEME>
(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
          </SCHEME>
	</SNIPPET>
	  </FOOTNOTE>
	</SCHEME>
      </SPLITINLINE>

        <!-- \indcode*{map} -->
        <SNIPPET PAGE="105">
          <NAME>map</NAME>
	  <EXAMPLE>map_example</EXAMPLE>
          <SCHEME>
(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
          </SCHEME>
          <JAVASCRIPT>
function map(fun, items) {
    return is_null(items)
           ? null
           : pair(fun(head(items)), 
                  map(fun, tail(items)));
}
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
// we avoid overriding the predeclared map
// function by using the name map_ here
function map_(fun, items) {
    return is_null(items)
           ? null
           : pair(fun(head(items)), 
                  map_(fun, tail(items)));
}
          </JAVASCRIPT_RUN>
        </SNIPPET>

        <SNIPPET PAGE="105">
          <NAME>map_example</NAME>
          <REQUIRES>abs_definition</REQUIRES>
          <REQUIRES>map</REQUIRES>
          <SCHEME>
(map abs (list -10 2.5 -11.6 17))
          </SCHEME>
          <SCHEMEOUTPUT>
            (10 2.5 11.6 17)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
map(abs, list(-10, 2.5, -11.6, 17));
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
map_(abs, list(-10, 2.5, -11.6, 17));
          </JAVASCRIPT_RUN>
        </SNIPPET>

        <SNIPPET PAGE="105">
          <NAME>map_example2</NAME>
          <REQUIRES>map</REQUIRES>
          <SCHEME>
(map (lambda (x) (* x x))
     (list 1 2 3 4))
          </SCHEME>
          <SCHEMEOUTPUT>
            (1 4 9 16)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
map(x => x * x, list(1, 2, 3, 4));
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
map_(x => x * x, list(1, 2, 3, 4));
          </JAVASCRIPT_RUN>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Now we can give a new definition of <SPLITINLINE><SCHEME><SCHEMEINLINE>scale-list</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>scale_list</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> in terms of <SCHEMEINLINE>map</SCHEMEINLINE>:
        <SNIPPET PAGE="106">
          <NAME>scale_list2</NAME>
          <EXAMPLE>scale_list_example</EXAMPLE>
          <SCHEME>
(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
          </SCHEME>
          <JAVASCRIPT>
function scale_list(items, factor) {
    return map(x => x * factor, items);
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>Map</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The function <JAVASCRIPTINLINE>map</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	is an important construct, not only because it captures a
        common pattern, but because it establishes a higher level of
        abstraction in dealing with lists.  In the original definition of <SPLITINLINE><SCHEME><SCHEMEINLINE>scale-list</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>scale_list</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, the recursive structure of the program draws attention to
        the element-by-element processing of the list.  Defining <SPLITINLINE><SCHEME><SCHEMEINLINE>scale-list</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>scale_list</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> in terms of <SCHEMEINLINE>map</SCHEMEINLINE> suppresses that level of detail and
        emphasizes that scaling transforms a list of elements to a list of
        results.  The difference between the two definitions is not that the
        computer is performing a different process (it isn<APOS/>t) but that we
        think about the process differently.  In effect, <SCHEMEINLINE>map</SCHEMEINLINE> helps
        establish an abstraction barrier that isolates the implementation of
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        that transform lists from the details of how the
        elements of the list are extracted and combined.  Like the barriers
        shown in figure<SPACE/><REF NAME="fig:abstraction-barriers"/>, this abstraction gives
        us the flexibility to change the low-level details of how sequences
        are implemented, while preserving the conceptual framework of
        operations that transform sequences to sequences.
        section<SPACE/><REF NAME="sec:sequences-conventional-interfaces"/> expands on this use
        of sequences as a framework for organizing programs.
      </TEXT>

      <EXERCISE><LABEL NAME="ex:square-list"/>
        The
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>square-list</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>square_list</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> takes a list of
        numbers as argument and returns a list of the squares of those
        numbers.


        <SNIPPET PAGE="106">
          <NAME>square_list_example</NAME>
          <SCHEME>
;; square-list to be given by student
(square-list (list 1 2 3 4))
          </SCHEME>
          <SCHEMEOUTPUT>
            (1 4 9 16)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
square_list(list(1, 2, 3, 4));
// returns: [1, [4, [9, [16, null]]]]
          </JAVASCRIPT>
        </SNIPPET>

        Here are two different definitions of <SPLITINLINE><SCHEME><SCHEMEINLINE>square-list</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>square_list</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  Complete
        both of them by filling in the missing expressions:

        <SNIPPET>
	  <EXAMPLE>square_list_example</EXAMPLE>
          <SCHEME>
(define (square-list items)
   (if (null? items)
       nil
       (cons ^??^ ^??^)))
          </SCHEME>
          <JAVASCRIPT>
function square_list(items) {
    return is_null(items) 
           ? null
           : pair(??, ??);
}
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET>
	  <EXAMPLE>square_list_example</EXAMPLE>
          <SCHEME>
(define (square-list items)
   (map ^??^ ^??^))
          </SCHEME>
          <JAVASCRIPT>
function square_list(items) {
   return map(??, ??);
}
          </JAVASCRIPT>
        </SNIPPET>

	<SOLUTION>
    <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>square_list_example</EXAMPLE>
    <JAVASCRIPT>
function square_list(items) {
    return is_null(items)
           ? null
           : pair(square(head(items)),
	          square_list(tail(items)));
}
</JAVASCRIPT>
    </SNIPPET>
  <SNIPPET>
    <REQUIRES>square_definition</REQUIRES>
    <EXAMPLE>square_list_example</EXAMPLE>
    <JAVASCRIPT>  
function square_list(items) {
    return map(square, items);
}
    </JAVASCRIPT>
    </SNIPPET>


  </SOLUTION>
      </EXERCISE>

      <EXERCISE> 
        Louis Reasoner tries to rewrite the first <SPLITINLINE><SCHEME><SCHEMEINLINE>square-list</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>square_list</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        of
        exercise<SPACE/><REF NAME="ex:square-list"/> so that it evolves an iterative
        process:

        <SNIPPET PAGE="106" HIDE="yes">
          <NAME>square_list_warning</NAME>
          <JAVASCRIPT>
// THIS IS NOT A CORRECT SOLUTION	    
	  </JAVASCRIPT>
	</SNIPPET>
	
        <SNIPPET PAGE="106">
          <NAME>square_list2</NAME>
          <REQUIRES>square_definition</REQUIRES>
          <REQUIRES>square_list_warning</REQUIRES>
          <EXAMPLE>square_list_example</EXAMPLE>
          <SCHEME>
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things) 
              (cons (square (car things))
                    answer))))
  (iter items nil))
          </SCHEME>
          <JAVASCRIPT>
function square_list(items) {
    function iter(things, answer) {
        return is_null(things) 
               ? answer
               : iter(tail(things), 
                      pair(square(head(things)), 
                           answer));
    }
    return iter(items, null);
}
          </JAVASCRIPT>
        </SNIPPET>

        Unfortunately, defining <SPLITINLINE><SCHEME><SCHEMEINLINE>square-list</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>square_list</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> this way produces the answer
        list in the reverse order of the one desired.  Why?

        Louis then tries to fix his bug by interchanging the arguments to
        <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:

        <SNIPPET PAGE="106">
          <NAME>square_list3</NAME>
          <REQUIRES>square_definition</REQUIRES>
          <REQUIRES>square_list_warning</REQUIRES>
          <EXAMPLE>square_list_example</EXAMPLE>
          <SCHEME>
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
          </SCHEME>
          <JAVASCRIPT>
function square_list(items) {
   function iter(things, answer) {
       return is_null(things)
              ? answer
              : iter(tail(things), 
                     pair(answer, 
                          square(head(things))));
   }
   return iter(items, null);
}
          </JAVASCRIPT>
        </SNIPPET>

        This doesn<APOS/>t work either.  Explain.
        <LABEL NAME="ex:iter-square-list"/>
<SOLUTION>
  <OL>
    <LI>
      The result list is reversed in the first program
      because the argument list is traversed in the
      given order, from first to last, but squares are added successively to the
      front of the answer list via
      <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>.</JAVASCRIPT></SPLITINLINE>
      The last element of the list is the last one to be added to the answer
      and thus ends up as the first element of the result list.
    </LI>
    <LI>
      The second program makes things worse! The result is not even a list any longer,
      because the elements occupy the tail position of the result list and not the
      head position.
    </LI>
  </OL>
  </SOLUTION>
      </EXERCISE>

      <EXERCISE><LABEL NAME="ex:for-each"/>
        The
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>

        <!-- \indcode{for-each} -->
        <SPLITINLINE><SCHEME><SCHEMEINLINE>for-each</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
	is similar to <SCHEMEINLINE>map</SCHEMEINLINE>.  It takes as arguments a
        <SPLITINLINE><SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        and a list of elements.  However, rather than forming a list of the  results,
	<SPLITINLINE><SCHEME><SCHEMEINLINE>for-each</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
	just applies the
	<SPLITINLINE><SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        to each of the elements in turn, from left to right.
	The values returned by applying the
        <SPLITINLINE><SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        to the elements are not used at
        all<EMDASH/><SPLITINLINE><SCHEME><SCHEMEINLINE>for-each</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is used with
        <SPLITINLINE><SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        that perform an action, such as printing.  For example, 

        <SNIPPET PAGE="104" HIDE="yes">
          <NAME>for_each_by_student</NAME>
          <SCHEME>
;; for_each to be given by student
          </SCHEME>
          <JAVASCRIPT>
// for_each to be given by student
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
// for_each_ to be given by student
	  </JAVASCRIPT_RUN>
        </SNIPPET>

	

        <SNIPPET>
	  <REQUIRES>for_each_by_student</REQUIRES>
          <NAME>for_each_example</NAME>
          <SCHEME>
(for-each 
   (lambda (x) (newline) (display x))
   (list 57 321 88))
          </SCHEME>
          <JAVASCRIPT>
for_each(x => display(x), 
         list(57, 321, 88));
          </JAVASCRIPT>
          <JAVASCRIPT_RUN>
for_each_(x => display(x), 
         list(57, 321, 88));
          </JAVASCRIPT_RUN>
          <SCHEMEOUTPUT>
            57
            321
            88
          </SCHEMEOUTPUT>
        </SNIPPET>

        The value returned by the call to
	<SPLITINLINE><SCHEME><SCHEMEINLINE>for-each</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	(not illustrated above)
        can be something arbitrary, such as true.  Give an
        implementation of
	<SPLITINLINE><SCHEME><SCHEMEINLINE>for-each</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.
        
 <SOLUTION>
    <SNIPPET>
      <NAME>for_each</NAME>
      <EXAMPLE>for_each_example</EXAMPLE>
    <JAVASCRIPT>
function for_each(fun, items) {
    if (is_null(items)){
        return undefined;
    } else {
        fun(head(items));
        for_each(fun, tail(items));
    }
}     
    </JAVASCRIPT>
    <JAVASCRIPT_RUN>
// we avoid overriding the predeclared for_each
// function by using the name for_each_ here
function for_each_(fun, items) {
    if (is_null(items)) {
        return undefined;
    } else {
        fun(head(items));
        for_each_(fun, tail(items));
    }
}     
    </JAVASCRIPT_RUN>
    <SCHEME>
    </SCHEME>
    </SNIPPET>
  </SOLUTION>
      </EXERCISE>
      <INDEX>list(s)<SUBINDEX>mapping over|)</SUBINDEX></INDEX>
      <INDEX>mapping<SUBINDEX>list@over lists|)</SUBINDEX></INDEX>

    </SUBSECTION>
