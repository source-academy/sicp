<SUBSECTION>
  <NAME>
    Local State Variables
  </NAME>

  <LABEL NAME="sec:local-state-variables"></LABEL>
  <INDEX>local state variable<OPEN></OPEN></INDEX>
  <INDEX>state variable<SUBINDEX>local<OPEN></OPEN></SUBINDEX></INDEX>

  <TEXT>
    To illustrate what we mean by having a computational object with
    <INDEX>object(s)<SUBINDEX>with time-varying state</SUBINDEX></INDEX>
    time-varying state, let us model the situation of withdrawing money
    from a
    <INDEX>bank account</INDEX>
    bank account.  We will do this using a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    withdraw, which takes as argument an
    amount to be withdrawn.
    If there is enough money in the account to accommodate the withdrawal,
    then withdraw should return the balance
    remaining after the withdrawal.  Otherwise,
    withdraw should return the message
    <EM>Insufficient funds.</EM> For example, if we begin with <DOLLAR></DOLLAR>100
    in the account, we should obtain the following sequence of responses
    using
    withdraw:
    <SNIPPET EVAL="yes">
      <NAME>withdraw_example</NAME>
      <EXPECTED>75</EXPECTED>
      <REQUIRES>withdraw</REQUIRES>
      
(withdraw 25)
      
      <SCHEMEOUTPUT>
75
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
withdraw(25);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
75
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>withdraw_example2</NAME>
      <REQUIRES>withdraw</REQUIRES>
      <REQUIRES>withdraw_example</REQUIRES>
      <EXPECTED>50</EXPECTED>
      
(withdraw 25)
      
      <SCHEMEOUTPUT>
50
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
withdraw(25);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
50
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>withdraw_example3</NAME>
      <REQUIRES>withdraw</REQUIRES>
      <REQUIRES>withdraw_example</REQUIRES>
      <REQUIRES>withdraw_example2</REQUIRES>
      <EXPECTED>&apos;Insufficient funds&apos;</EXPECTED>
      
(withdraw 60)
      
      <SCHEMEOUTPUT>
&quot;Insufficient funds&quot;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
withdraw(60);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;Insufficient funds&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>withdraw_example4</NAME>
      <REQUIRES>withdraw</REQUIRES>
      <REQUIRES>withdraw_example</REQUIRES>
      <REQUIRES>withdraw_example2</REQUIRES>
      <REQUIRES>withdraw_example3</REQUIRES>
      <EXPECTED>35</EXPECTED>
      
(withdraw 15)
      
      <SCHEMEOUTPUT>
35
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
withdraw(15);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
35
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    Observe that the expression
    <SPLITINLINE>
      (withdraw 25),
      <JAVASCRIPT><JAVASCRIPTINLINE>withdraw(25)</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    evaluated twice, yields different values.  This is a new kind of
    behavior for a
    <SPLITINLINE>
      procedure.
    <JAVASCRIPT>function.</JAVASCRIPT></SPLITINLINE>
    Until now, all our
    <SPLITINLINE>
      procedures
      <JAVASCRIPT>JavaScript functions</JAVASCRIPT>
    </SPLITINLINE>
    could be viewed as specifications for computing mathematical functions.
    A call to a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    computed the value of the function applied to the given arguments,
    and two calls to the same
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    with the same arguments always produced the same
    result.<FOOTNOTE>Actually, this is not quite true. One exception was the 
    <INDEX><USE>math_random</USE> (primitive function)<SUBINDEX>assignment needed for</SUBINDEX></INDEX>
    <INDEX>random-number generator</INDEX>
    random-number generator
    in section<SPACE></SPACE><REF NAME="sec:primality"></REF>.  Another exception
    involved the
    <INDEX>operation-and-type table<SUBINDEX>assignment needed for</SUBINDEX></INDEX>
    operation/type tables we introduced in
    section<SPACE></SPACE><REF NAME="sec:data-directed"></REF>, where the values of two
    calls to get with the same arguments
    depended on intervening calls to put.
    On the other hand, until we introduce assignment, we have no way to
    create such
    <SPLITINLINE>
      procedures
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    ourselves.</FOOTNOTE>
  </TEXT>

  <TEXT>
    <SPLIT>
      
        To implement withdraw, we can use a
	variable balance to indicate the balance of
	money in the account and define withdraw
	as a
        <SPLITINLINE>
	  procedure
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
        that accesses balance.
      
      <JAVASCRIPT>
	So far, all our names have been <EM>immutable</EM>. 
	When a function was applied, the values that its parameters
	referred to never changed, and once a declaration was evaluated,
	the declared name never changed its value.
        To implement functions like
	withdraw, we introduce
	<INDEX>variable<SUBINDEX>declaration</SUBINDEX></INDEX>
	<INDEX>syntactic forms<SUBINDEX>variable declaration</SUBINDEX><FRAGILE></FRAGILE></INDEX>
	<INDEX>declaration<SUBINDEX><ORDER>variable</ORDER>of variable (<JAVASCRIPTINLINE>let</JAVASCRIPTINLINE>)</SUBINDEX></INDEX>
	<EM>variable declarations</EM>, which use the keyword
	<INDEX><USE>let</USE> (keyword)</INDEX>
	<INDEX>keywords<SUBINDEX><ORDER>let</ORDER><USE>let</USE></SUBINDEX></INDEX>
	<JAVASCRIPTINLINE>let</JAVASCRIPTINLINE>, in addition to constant
	declarations, which use the keyword
	<JAVASCRIPTINLINE>const</JAVASCRIPTINLINE>.
        We can declare a variable
	<JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE>
	to indicate the balance of money	
	in the account and define
	withdraw as a function that accesses
	balance.
      </JAVASCRIPT>
    </SPLIT>
    The withdraw
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    checks to see if balance is at least as large
    as the requested amount.  If so,
    withdraw decrements
    balance by amount
    and returns the new value of balance. Otherwise,
    withdraw returns the <EM>Insufficient funds</EM>
    message. Here are the
    <SPLITINLINE>
      definitions
      <JAVASCRIPT>declarations</JAVASCRIPT>
    </SPLITINLINE>
    of balance and
    withdraw:
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>withdraw</DECLARATION></INDEX>
      <NAME>withdraw</NAME>
      <EXAMPLE>withdraw_example</EXAMPLE>
      
(define balance 100)

(define (withdraw amount)
   (if (&gt;= balance amount)
     (begin (set! balance (- balance amount))
            balance)
     &quot;Insufficient funds&quot;))
      
      <JAVASCRIPT>
let balance = 100;

function withdraw(amount) {
    if (balance &gt;= amount) {
        balance = balance - amount;
        return balance;
    } else {
        return &quot;Insufficient funds&quot;;
    }
}
      </JAVASCRIPT>
    </SNIPPET>
    Decrementing balance is accomplished by the 
    <SPLITINLINE>
      expression
    <JAVASCRIPT>expression statement</JAVASCRIPT></SPLITINLINE>
    <DONT_BREAK_PAGE></DONT_BREAK_PAGE>
    <SNIPPET EVAL="no">
      
(set! balance (- balance amount))
      
      <JAVASCRIPT>
balance = balance - amount;
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      
        This uses the set! special form, whose
	syntax is
	<SNIPPET EVAL="no" LATEX="yes">
	  
(set! $\langle \textit{name} \rangle$ $\langle \textit{new-value}\rangle$)
	  
	</SNIPPET>
      
      <JAVASCRIPT>
	The syntax of
	<INDEX>assignment</INDEX>
	<INDEX>assignment<SUBINDEX>assignment expression</SUBINDEX></INDEX>
	<INDEX>variable<SUBINDEX>assignment to</SUBINDEX></INDEX>
	<INDEX>syntactic forms<SUBINDEX>assignment</SUBINDEX></INDEX>
	<INDEX><ORDER>=</ORDER><JAVASCRIPTINLINE>=</JAVASCRIPTINLINE></INDEX>
	<EM>assignment</EM> expressions is
    <SNIPPET EVAL="no" LATEX="yes">
      <JAVASCRIPT>
<META>name</META> = <META>new-value</META>
      </JAVASCRIPT>
    </SNIPPET>
      </JAVASCRIPT>
    </SPLIT>
    Here
    <SPLITINLINE>
      
	<LATEXINLINE>$\langle \textit{name} \rangle$</LATEXINLINE>
	is a symbol 
      
      <JAVASCRIPT>
	<META>name</META>
	has been declared with
	<INDEX>variable<SUBINDEX>parameter as</SUBINDEX></INDEX>
	<JAVASCRIPTINLINE>let</JAVASCRIPTINLINE> or
	as a
	<INDEX>parameters<SUBINDEX><ORDER>variable</ORDER>as variables</SUBINDEX></INDEX>
	function parameter
      </JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      
	<LATEXINLINE>$\langle \textit{new-value} \rangle$</LATEXINLINE>
      
      <JAVASCRIPT>
	<META>new-value</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    is any expression.  
    <SPLITINLINE>
      Set!
      <JAVASCRIPT>The assignment</JAVASCRIPT>
    </SPLITINLINE> 
    changes
    <SPLITINLINE>
      
	<LATEXINLINE>$\langle \textit{name} \rangle$</LATEXINLINE>
      
      <JAVASCRIPT>
	<META>name</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    so that its value is the
    result obtained by evaluating
    <SPLITINLINE>
      
	<LATEXINLINE>$\langle \textit{new-value}\rangle$</LATEXINLINE>.
      
      <JAVASCRIPT>
	<META>new-value</META>.
      </JAVASCRIPT>
    </SPLITINLINE>
    In the case at hand, we are changing balance so
    that its new value will be the result of subtracting
    amount from the previous value of
    balance.<FOOTNOTE>
    <SPLITINLINE>
      
	<INDEX>unspecified values<SUBINDEX><ORDER>set</ORDER>set!</SUBINDEX></INDEX>
	The value of a set! expression is
	implementation-dependent. Set! should be
	used only for its effect, not for its value.
	<INDEX>naming conventions<SUBINDEX><ORDER>!</ORDER>! for assignment and mutation</SUBINDEX></INDEX>
	<INDEX>exclamation point in names</INDEX>
	<INDEX><USE>!</USE><SUBINDEX>in names</SUBINDEX></INDEX> 
	The name set! reflects a naming convention
	used in Scheme: Operations that change the values of variables (or that
	change data structures, as we will see in
	section<SPACE></SPACE><REF NAME="sec:mutable-data"></REF>) are given names that end
	with an exclamation point.  This is similar to the convention of
	designating predicates by names that end with a question mark.
      
      <JAVASCRIPT>
	The
	<INDEX>assignment<SUBINDEX>value of</SUBINDEX></INDEX>
	value of an assignment is the value being assigned to the name.
	Assignment expression statements
	<INDEX>assignment<SUBINDEX>constant/variable declaration vs.</SUBINDEX></INDEX>
	look similar to and should not be
	confused with constant and variable declarations of the form
	<SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
const $name$ = $value$;
          </JAVASCRIPT>
	</SNIPPET>
	and
	<SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
let $name$ = $value$;
          </JAVASCRIPT>
	</SNIPPET>
	in which a newly declared <META>name</META>
	is associated with a <META>value</META>. 
	Assignment expressions look similar to and should not be confused with
	<INDEX>assignment<SUBINDEX>equality test vs.</SUBINDEX></INDEX>
	expressions of the form 
	<SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
$expression_1$ === $expression_2$
          </JAVASCRIPT>
	</SNIPPET>
	which evaluate to <JAVASCRIPTINLINE>true</JAVASCRIPTINLINE>
	if <META>expression</META><LATEXINLINE>$_1$</LATEXINLINE> evaluates to the
	same value as <META>expression</META><LATEXINLINE>$_2$</LATEXINLINE> and to
	<JAVASCRIPTINLINE>false</JAVASCRIPTINLINE> otherwise.
      </JAVASCRIPT>
    </SPLITINLINE></FOOTNOTE>
  </TEXT>

  <TEXT>
    <SPLIT>
      
	<INDEX>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)<SUBINDEX>begin</SUBINDEX></INDEX>
	Withdraw also uses the
	begin 
	special form to cause two expressions to be evaluated in the case where
	the if test is true: first decrementing 
	balance and then returning the value of 
	balance. In general, evaluating the
	expression
	<SNIPPET EVAL="no">
          
(begin $\textit{exp}_{1}$ $\textit{exp}_{2}$ $\ldots$ $\textit{exp}_{k}$)
          
	</SNIPPET>
	causes the expressions <LATEXINLINE>$\textit{exp}_{1}$</LATEXINLINE>
	through <LATEXINLINE>$\textit{exp}_{k}$</LATEXINLINE> to be evaluated in
	sequence and the value of the final expression
	<LATEXINLINE>$\textit{exp}_{k}$</LATEXINLINE> to be returned as the
	value of the entire begin
	form.<FOOTNOTE>We have already used 
	<INDEX>begin<SUBINDEX>implicit in consequent of conditional</SUBINDEX></INDEX>
	    cond and in 
	begin implicitly in our programs, because in
	Scheme the body of a procedure can be a sequence of expressions.  Also,
	the <LATEXINLINE>consequent</LATEXINLINE> part of each clause in a
	<INDEX>cond<SUBINDEX><ORDER>implicit begin</ORDER>implicit begin in consequent</SUBINDEX></INDEX>
	cond expression can be a sequence of
	expressions rather than a single expression.</FOOTNOTE>
      
      <JAVASCRIPT>
	The function <JAVASCRIPTINLINE>withdraw</JAVASCRIPTINLINE> also uses a
	<INDEX>sequence of statements</INDEX>
	<EM>sequence of statements</EM> to cause two statements to be evaluated
	in the case where the <JAVASCRIPTINLINE>if</JAVASCRIPTINLINE> test is
	true: first decrementing  <JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE>
	and then returning the value of
	<JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE>.  
	In general, executing a sequence
	<SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
<META>stmt</META>$_{1}$ <META>stmt</META>$_{2} \ldots$<META>stmt</META>$_{n}$
          </JAVASCRIPT>
        </SNIPPET>
        causes the statements <META>stmt</META><LATEXINLINE>$_{1}$</LATEXINLINE>
	through
	<META>stmt</META><LATEXINLINE>$_{n}$</LATEXINLINE> to be evaluated in
	sequence.<FOOTNOTE>We have already used 
        <INDEX>sequence of statements<SUBINDEX><ORDER>block</ORDER>in block</SUBINDEX></INDEX>
        sequences implicitly in our programs, because in
	JavaScript the body block
	of a function can contain a sequence of function declarations
	followed by a return statement, not
	just a single return statement,
	as discussed in
	section<SPACE></SPACE><REF NAME="sec:block-structure"></REF>.</FOOTNOTE>
	<COMMENT>
	  In JavaScript, the return value of functions is determined by
	  return statements, which
	  can appear in the first statement of a sequence. To make matters
	  even more complex, at JavaScript top level, the value of a sequence is
	  the value of the first component, if the second component is not
	  value-producing. Thus in JavaScript,
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
1; const x = 2;
	    </JAVASCRIPT>
	  </SNIPPET>
	  evaluates to the value 1. We decide to ignore the subtleties of the
	  JavaScript top level here. The return value of non-top-level sequences
	  are determined by the placement of return statements, which we will
	  explain later.
	</COMMENT>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    Although withdraw works as desired, the
    variable balance presents a problem.  As
    specified above, balance is a name defined
    in the
    <SPLITINLINE>
      global
      <JAVASCRIPT>program</JAVASCRIPT>
      </SPLITINLINE> environment and is freely accessible to be examined or
      modified by any
      <SPLITINLINE>
	procedure.
	<JAVASCRIPT>function.</JAVASCRIPT>
      </SPLITINLINE>
      It would be much better if we could somehow make
      balance internal to
      withdraw, so that
      withdraw would be the only
      <SPLITINLINE>
	procedure
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      that could access balance directly and
      any other
      <SPLITINLINE>
	procedure
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      could access balance only indirectly
      (through calls to withdraw).  This would
      more accurately model the notion that
      balance is a local state variable used by
      withdraw to keep track of the state of the
      account.
  </TEXT>

  <DO_BREAK_PAGE></DO_BREAK_PAGE>
  <TEXT>
    We can make balance internal to
    withdraw by rewriting the definition as
    follows:
    <SNIPPET HIDE="yes">
      <NAME>new_withdraw_example</NAME>
      <JAVASCRIPT>
new_withdraw(60);
new_withdraw(60);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>new_withdraw</DECLARATION></INDEX>
      <NAME>new_withdraw</NAME>
      <EXAMPLE>new_withdraw_example</EXAMPLE>
      
(define new-withdraw
  (let ((balance 100))
    (lambda (amount)
      (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))))
      v
      <JAVASCRIPT>
function make_withdraw_balance_100() {
    let balance = 100;
    return amount =&gt; {
               if (balance &gt;= amount) {
                   balance = balance - amount;
                   return balance;
               } else {
                   return &quot;Insufficient funds&quot;;
               }
           };
}
const new_withdraw = make_withdraw_balance_100();
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      
        What we have done here is use let to
	establish an environment with a local variable
	balance, bound to the initial value 100.
        Within this local environment, we use
	lambda to create a procedure that takes
	amount as an argument and behaves like our
        previous withdraw procedure.  This
        procedure<EMDASH></EMDASH>returned as the result of evaluating the
	let expression<EMDASH></EMDASH>is
	new-withdraw,
        which behaves in precisely the same way as
	withdraw but whose variable
	balance is not accessible by any other
        procedure.<FOOTNOTE>In programming-language jargon, the variable
	balance is said to be 
        <INDEX>encapsulated name</INDEX>
        <INDEX>name<SUBINDEX>encapsulated</SUBINDEX></INDEX>
        <EM>encapsulated</EM> within the
	new-withdraw
        procedure. Encapsulation reflects the general system-design principle
	known as the 
        <INDEX>hiding principle</INDEX>
        <INDEX>modularity<SUBINDEX>hiding principle</SUBINDEX></INDEX>
        <EM>hiding principle</EM>: One can make a system more modular and robust
	by protecting parts of the system from each other; that is, by providing
	information access only to those parts of the system that have a
	<QUOTE>need to know.</QUOTE></FOOTNOTE>
      
      <JAVASCRIPT>
        What we have done here is use <JAVASCRIPTINLINE>let</JAVASCRIPTINLINE>
	to establish an environment with a local variable
	<JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE>, bound to the initial
	value 100. Within this local environment, we use a lambda
	expression<FOOTNOTE>Blocks as bodies of lambda expressions were
	introduced in section<SPACE></SPACE><REF NAME="sec:graphics"></REF>.</FOOTNOTE> to
	create a function that takes <JAVASCRIPTINLINE>amount</JAVASCRIPTINLINE>
	as an argument and behaves like our previous
	<JAVASCRIPTINLINE>withdraw</JAVASCRIPTINLINE> function.  This
	function<EMDASH></EMDASH>returned as the result of evaluating the body of the
	<JAVASCRIPTINLINE>make_withdraw_balance_100</JAVASCRIPTINLINE>
	function<EMDASH></EMDASH>behaves in precisely the same way as
	<JAVASCRIPTINLINE>withdraw</JAVASCRIPTINLINE>, but its variable
	<JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE> is not accessible by any
	other function.<FOOTNOTE>In programming-language jargon, the variable
	<JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE> is said to be 
        <INDEX>encapsulated name</INDEX>
        <INDEX>name<SUBINDEX>encapsulated</SUBINDEX></INDEX>
        <EM>encapsulated</EM> within the
	<JAVASCRIPTINLINE>new_withdraw</JAVASCRIPTINLINE> function.
	Encapsulation reflects the general system-design principle known as the 
        <INDEX>hiding principle</INDEX>
        <INDEX>modularity<SUBINDEX>hiding principle</SUBINDEX></INDEX>
        <EM>hiding principle</EM>: One can
        make a system more modular and robust by protecting parts of the
        system from each other; that is, by providing information access only
        to those parts of the system that have a <QUOTE>need to
	know.</QUOTE></FOOTNOTE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <SHORT_PAGE LINES="5"></SHORT_PAGE>
  <TEXT>
    Combining 
    <SPLITINLINE>
      
        set! 
        with local variables 
      
      <JAVASCRIPT>
        assignments with variable declarations
      </JAVASCRIPT>
    </SPLITINLINE>
    is the general programming
    technique we will use for constructing computational objects with
    local state.  Unfortunately, using this technique raises a serious
    problem: When we first introduced
    <SPLITINLINE>
      procedures,
      <JAVASCRIPT>functions,</JAVASCRIPT>
    </SPLITINLINE>
    we also introduced the substitution model of evaluation
    (section<SPACE></SPACE><REF NAME="sec:substitution-model"></REF>) to provide an
    interpretation of what
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application means.  We said that applying a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function whose body is a return statement</JAVASCRIPT>
    </SPLITINLINE>
    should be interpreted as evaluating the
    <SPLITINLINE>
      body of the procedure
      <JAVASCRIPT>return expression of the function</JAVASCRIPT>
    </SPLITINLINE>
    with the
    <SPLITINLINE>
      formal
    </SPLITINLINE>
    parameters replaced by their values.
    <SPLITINLINE>
      <JAVASCRIPT>
	For functions with more complex
	bodies, we need to evaluate the whole body with the
	parameters replaced by their values.
      </JAVASCRIPT>
    </SPLITINLINE>
    The trouble is that,
    as soon as we introduce assignment into our language, substitution is no
    longer an adequate model of
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application.  (We will see why this is so in
    section<SPACE></SPACE><REF NAME="sec:costs-of-assignment"></REF>.)  As a consequence, we
    technically have at this point no way to understand why the
    <SPLITINLINE>
      new-withdraw
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>new_withdraw</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    behaves as claimed above.  In order to really understand a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    such as
    <SPLITINLINE>
      new-withdraw,
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>new_withdraw</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    we will need to develop a new model of
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application.  In section<SPACE></SPACE><REF NAME="sec:environment-model"></REF> we will
    introduce such a model, together with an explanation of 
    <SPLITINLINE>
      set! and local variables.
      <JAVASCRIPT>assignments and variable declarations.</JAVASCRIPT>
    </SPLITINLINE>
    First, however, we examine some variations on the theme established by
    <SPLITINLINE>
      new-withdraw.
      <JAVASCRIPT><JAVASCRIPTINLINE>new_withdraw</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <JAVASCRIPT>
	Parameters of functions as well as names declared with
	<JAVASCRIPTINLINE>let</JAVASCRIPTINLINE> are
	<INDEX>parameters<SUBINDEX><ORDER>variable</ORDER>as variables</SUBINDEX></INDEX>
	variables.
      </JAVASCRIPT>
    </SPLITINLINE>
    The following
    <SPLITINLINE>
      
	procedure, make-withdraw,
      
      <JAVASCRIPT>
	function, <JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    creates <QUOTE>withdrawal processors.</QUOTE>
    The <SPLITINLINE>formal</SPLITINLINE> parameter
    balance in
    <SPLITINLINE>
      make-withdraw
      <JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    specifies the initial amount of money in the
    account.<FOOTNOTE>
    <LABEL NAME="foot:make_withdraw"></LABEL>
    In contrast with
    <SPLITINLINE>
      
	new-withdraw
      
      <JAVASCRIPT>
	make_withdraw_balance_100
      </JAVASCRIPT>
    </SPLITINLINE>
    above, we do not have to use
    let
    to make balance a local variable, since
    <SPLITINLINE>
      formal
    </SPLITINLINE>
    parameters are already
    local. This will be clearer after the discussion of the environment
    model of evaluation in
    section<SPACE></SPACE><REF NAME="sec:environment-model"></REF>.
    (See also
    exercise<SPACE></SPACE><REF NAME="ex:local-state-variable"></REF>.)</FOOTNOTE>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_withdraw</DECLARATION></INDEX> 
      <NAME>make_withdraw</NAME>
      <EXAMPLE>make_withdraw_define</EXAMPLE>
      
(define (make-withdraw balance)
   (lambda (amount)
      (if (&gt;= balance amount)
         (begin (set! balance (- balance amount))
                balance)
         &quot;Insufficient funds&quot;)))
      
      <JAVASCRIPT>
function make_withdraw(balance) {
    return amount =&gt; {
               if (balance &gt;= amount) {
                   balance = balance - amount;
                   return balance;
               } else {
                   return &quot;Insufficient funds&quot;;
               }
           };
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      Make-withdraw
      <JAVASCRIPT>
	The function <JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    can be used as follows to create two objects W1
    and<SPACE></SPACE>W2:
    <SNIPPET EVAL="yes">
      <NAME>make_withdraw_define</NAME>
      <REQUIRES>make_withdraw</REQUIRES>
      
(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))
      
      <JAVASCRIPT>
const W1 = make_withdraw(100);
const W2 = make_withdraw(100);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_withdraw_example1</NAME>
      <REQUIRES>make_withdraw_define</REQUIRES>
      <EXPECTED>50</EXPECTED>
      
(W1 50)
      
      <SCHEMEOUTPUT>
50
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
W1(50);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
50
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_withdraw_example1</REQUIRES>
      <NAME>make_withdraw_example2</NAME>
      <EXPECTED>30</EXPECTED>
      
(W2 70)
      
      <SCHEMEOUTPUT>
30
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
W2(70);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
30
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_withdraw_example3</NAME>
      <REQUIRES>make_withdraw_example2</REQUIRES>
      <EXPECTED>&apos;Insufficient funds&apos;</EXPECTED>
      
(W2 40)
      
      <SCHEMEOUTPUT>
&quot;Insufficient funds&quot;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
W2(40);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;Insufficient funds&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_withdraw_example4</NAME>
      <REQUIRES>make_withdraw_example3</REQUIRES>
      <EXPECTED>10</EXPECTED>
      
(W1 40)
      
      <SCHEMEOUTPUT>
10
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
W1(40); 
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
10
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    Observe that W1 and 
    W2 are completely independent objects, each
    with its own local state variable balance.
    Withdrawals from one do not affect the other.
  </TEXT>

  <TEXT>
    We can also create objects that handle
    <INDEX><DECLARATION>deposit</DECLARATION> message for bank account</INDEX>
    deposits as well as
    withdrawals, and thus we can represent simple bank accounts.  Here is
    a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that returns a <QUOTE>bank-account object</QUOTE> with a specified initial
    balance:
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>make_account</DECLARATION></INDEX> 
      <NAME>make_account</NAME>
      <EXAMPLE>make_account_example_my</EXAMPLE>
      
(define (make-account balance)
   (define (withdraw amount)
      (if (&gt;= balance amount)
         (begin (set! balance (- balance amount))
                balance)
            &quot;Insufficient funds&quot;))
   (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
   (define (dispatch m)
      (cond ((eq? m &apos;withdraw) withdraw)
            ((eq? m &apos;deposit) deposit)
            (else (error &quot;Unknown request - - MAKE-ACCOUNT&quot;
                   m))))
   dispatch)
      
      <JAVASCRIPT>
function make_account(balance) {
    function withdraw(amount) {
        if (balance &gt;= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return &quot;Insufficient funds&quot;;
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    function dispatch(m) {
        return m === &quot;withdraw&quot;
               ? withdraw
               : m === &quot;deposit&quot;
               ? deposit
               : error(m, &quot;unknown request -- make_account&quot;);
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_account_example_my</NAME>
      
(define acc (make-account 100))
((acc &apos;withdraw) 50)
      
      <JAVASCRIPT>
const acc = make_account(100);

acc(&quot;withdraw&quot;)(50);
      </JAVASCRIPT>
    </SNIPPET>
    Each call to make_account sets up an
    environment with a local state variable balance.
    Within this environment, make_account defines
    <SPLITINLINE>
      procedures
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    deposit and
    withdraw that access
    balance and an additional
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    dispatch
    that takes a <QUOTE>message</QUOTE> as input and returns one of the two local
    <SPLITINLINE>
      procedures.
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    The dispatch
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    itself is returned as the value that represents the bank-account object.
    This is precisely the 
    <INDEX>message passing<SUBINDEX>in bank account</SUBINDEX></INDEX>
    <EM>message-passing</EM> style of programming that we saw in
    section<SPACE></SPACE><REF NAME="sec:data-directed"></REF>, although here we are using
    it in conjunction with the ability to modify local variables.
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      
	Make-account
      
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    can be used as follows:
    <SNIPPET EVAL="yes">
      <NAME>make_account_example</NAME>
      <REQUIRES>make_account</REQUIRES>
      
            (define acc (make-account 100))
      
      <JAVASCRIPT>
const acc = make_account(100);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_account_example1</NAME>
      <REQUIRES>make_account_example</REQUIRES>
      <EXPECTED>50</EXPECTED>
      
((acc &apos;withdraw) 50)
      
      <SCHEMEOUTPUT>
50
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
acc(&quot;withdraw&quot;)(50);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
50
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account_example1</REQUIRES>
      <NAME>make_account_example2</NAME>
      <EXPECTED>&apos;Insufficient funds&apos;</EXPECTED>
      
((acc &apos;withdraw) 60)
      
      <SCHEMEOUTPUT>
&quot;Insufficient funds&quot;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
acc(&quot;withdraw&quot;)(60);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;Insufficient funds&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account_example2</REQUIRES>
      <NAME>make_account_example3</NAME>
      <EXPECTED>90</EXPECTED>
      
((acc &apos;deposit) 40)
      
      <SCHEMEOUTPUT>
90
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
acc(&quot;deposit&quot;)(40);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
90
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account_example3</REQUIRES>
      <NAME>make_account_example4</NAME>
      <EXPECTED>30</EXPECTED>
      
((acc &apos;withdraw) 60)
      
      <SCHEMEOUTPUT>
30
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
acc(&quot;withdraw&quot;)(60);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
30
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SHORT_PAGE LINES="4"></SHORT_PAGE>Each call to acc returns the locally defined
    deposit or withdraw
    <SPLITINLINE>
      procedure,
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    which is then applied to the specified amount.
    As was the case with
    <SPLITINLINE>
      
	make-withdraw, another
	call to make-account
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>, another
	call to <JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account</REQUIRES>
      
(define acc2 (make-account 100))
      
      <JAVASCRIPT>
const acc2 = make_account(100);
      </JAVASCRIPT>
    </SNIPPET>
    will produce a completely separate account object, which maintains its
    own local balance.
  </TEXT>

  <EXERCISE>
    <LABEL NAME="ex:make-accumulator"></LABEL>
    An 
    <INDEX>accumulator</INDEX>
    <EM>accumulator</EM> is a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that is called repeatedly with a single numeric argument and accumulates its
    arguments into a sum. Each time it is called, it returns the currently
    accumulated sum. Write a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>make_accumulator</USE></INDEX> 
    <SPLITINLINE>
      make-accumulator
      <JAVASCRIPT><JAVASCRIPTINLINE>make_accumulator</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    that generates accumulators, each maintaining an independent sum.  The
    input to 
    <SPLITINLINE>
      make-accumulator
      <JAVASCRIPT><JAVASCRIPTINLINE>make_accumulator</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    should specify the initial value of the sum; for example
    <SNIPPET EVAL="yes">
      <NAME>make_accumulator_example</NAME>
      
(define A (make-accumulator 5))
      
      <JAVASCRIPT>
const a = make_accumulator(5);
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
// make_accumulator to be written by students
const a = make_accumulator(5);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <NAME>make_accumulator_example1</NAME>
      <REQUIRES>make_accumulator_example</REQUIRES>
      
(A 10)
      
      <SCHEMEOUTPUT>
15
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
a(10);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
15
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes" POSTPADDING="no">
      <NAME>make_accumulator_example2</NAME>
      <REQUIRES>make_accumulator_example1</REQUIRES>
      
(A 10)
      
      <SCHEMEOUTPUT>
25
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
a(10);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
25
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_accumulator_example_solution</NAME>
      
(A 10)
      
      <SCHEMEOUTPUT>
25
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
const a = make_accumulator(5);
a(10);
a(10);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
25
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>make_accumulator_solution</NAME>
	<EXAMPLE>make_accumulator_example_solution</EXAMPLE>
	<EXPECTED>25</EXPECTED>
	<JAVASCRIPT>
function make_accumulator(current) {
    function add(arg) {
        current = current + arg;
        return current;
    }
    return add;
}
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:make-monitored"></LABEL>
    In software-testing applications, it is useful to be able to count the
    number of times a given
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is called during the course of a computation.  Write a
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>make_monitored</USE></INDEX> 
    <INDEX>monitored <SPLITINLINE>procedure<JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE></INDEX>
    <INDEX><FUNCTION></FUNCTION><SUBINDEX>monitored</SUBINDEX></INDEX>
    <SPLITINLINE>
      make-monitored
      <JAVASCRIPT><JAVASCRIPTINLINE>make_monitored</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    that takes as input a
    <SPLITINLINE>
      procedure,
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    f, that itself takes one input.  The result
    returned by 
    <SPLITINLINE>
      make-monitored
      <JAVASCRIPT><JAVASCRIPTINLINE>make_monitored</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is a third
    <SPLITINLINE>
      procedure,
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    say mf, that keeps track of the number of times
    it has been called by maintaining an internal counter. If the input to
    mf is the
    <SPLITINLINE>
      special symbol how-many-calls,
      
      <JAVASCRIPT>string <JAVASCRIPTINLINE>&quot;how many calls&quot;</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    then mf returns the value of the counter.  If
    the input is the 
    <SPLITINLINE>
      special symbol reset-count,
      <JAVASCRIPT>string <JAVASCRIPTINLINE>&quot;reset count&quot;</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    then mf resets the counter to zero.  For any
    other input, mf returns the result of calling
    f on that input and increments the counter.
    For instance, we could make a monitored version of the
    sqrt
    <SPLITINLINE>
      procedure:
      <JAVASCRIPT>function:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="yes">
      <NAME>make_monitored_example</NAME>
      
    (define s (make-monitored sqrt))
      
      <JAVASCRIPT>
const s = make_monitored(math_sqrt);
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
// make_monitored function to be written by students
const s = make_monitored(math_sqrt);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET EVAL="yes">
      <REQUIRES>make_monitored_example</REQUIRES>
      <NAME>make_monitored_example1</NAME>
      
(s 100)
      
      <SCHEMEOUTPUT>
10
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
s(100);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
10
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes" POSTPADDING="no">
      <REQUIRES>make_monitored_example1</REQUIRES>
      <NAME>make_monitored_example2</NAME>
      
(s &apos;how-many-calls?)
      
      <SCHEMEOUTPUT>
1
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
s(&quot;how many calls&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
1
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<NAME>make_monitored_example3</NAME>
	<JAVASCRIPT>
const s = make_monitored(math_sqrt);
s(100);
display(s(&quot;how many calls&quot;));
s(5);
display(s(&quot;how many calls&quot;));
        </JAVASCRIPT>
	<JAVASCRIPT_TEST>
const s = make_monitored(math_sqrt);
s(100);
s(&quot;how many calls&quot;);
s(5);
s(&quot;how many calls&quot;);
	</JAVASCRIPT_TEST>
      </SNIPPET>
      <SNIPPET>
	<EXAMPLE>make_monitored_example3</EXAMPLE>
	<EXPECTED>2</EXPECTED>
	<JAVASCRIPT>
function make_monitored(f) {
    let counter = 0; //initialized to 0
    function mf(cmd) {
        if (cmd === &quot;how many calls&quot;) {
            return counter;
        } else if (cmd === &quot;reset count&quot;) {
            counter = 0;
            return counter;
        } else {
            counter = counter + 1;
            return f(cmd);
        }
    }
    return mf;
}
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <LONG_PAGE LINES="3"></LONG_PAGE>
  <EXERCISE>
    <LABEL NAME="ex:password-protection"></LABEL>
    Modify the 
    <SPLITINLINE>
      make-account
      <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    so that it creates
    <INDEX>bank account<SUBINDEX>password-protected</SUBINDEX></INDEX>
    <INDEX>password-protected bank account</INDEX>
    password-protected accounts.  That is, 
    <SPLITINLINE>
      make-account
      <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    should take a
    <SPLITINLINE>
      symbol
      <JAVASCRIPT>string</JAVASCRIPT>
    </SPLITINLINE>
    as an additional argument, as in
    <SNIPPET EVAL="yes">
      <NAME>make_account_exercise</NAME>
      
            (define acc (make-account 100 &apos;secret-password))
      
      <JAVASCRIPT>
const acc = make_account(100, &quot;secret password&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
// make_account function to be written by students
const acc = make_account(100, &quot;secret password&quot;);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    The resulting account object should process a request only if it is
    accompanied by the password with which the account was created, and
    should otherwise return a complaint:
    <SNIPPET EVAL="yes">
      <REQUIRES>make_account_exercise</REQUIRES>
      <NAME>make_account_exercise_example1</NAME>
      
((acc &apos;secret-password &apos;withdraw) 40)
      
      <SCHEMEOUTPUT>
60
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
acc(&quot;secret password&quot;, &quot;withdraw&quot;)(40);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
60
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="yes" POSTPADDING="no">
      <NAME>make_account_exercise_example2</NAME>
      <REQUIRES>make_account_exercise_example1</REQUIRES>
      
((acc &apos;some-other-password &apos;deposit) 50)
      
      <SCHEMEOUTPUT>
&quot;Incorrect password&quot;
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
acc(&quot;some other password&quot;, &quot;deposit&quot;)(40);  
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;Incorrect password&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
        <NAME>make_account_password_protected</NAME>
	<EXPECTED>&apos;Incorrect Password&apos;</EXPECTED>
	<JAVASCRIPT>
function make_account(balance, p) {
    function withdraw(amount) {
        if (balance &gt;= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return &quot;Insufficient funds&quot;;
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    function dispatch(m, q) {
        if (p === q) {
            return m === &quot;withdraw&quot;
                   ? withdraw
                   : m === &quot;deposit&quot;
                   ? deposit
                   : &quot;Unknown request: make_account&quot;;
        } else {
            return q =&gt; &quot;Incorrect Password&quot;;
        }
    }
    return dispatch;
}

const a = make_account(100, &quot;eva&quot;);
a(&quot;withdraw&quot;, &quot;eva&quot;)(50); //withdraws 50
a(&quot;withdraw&quot;, &quot;ben&quot;)(40); //incorrect password
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:3_4"></LABEL>
    Modify the 
    <SPLITINLINE>
      make-account
      <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of exercise<SPACE></SPACE><REF NAME="ex:password-protection"></REF> by adding another
    local state variable so that, if an account is accessed more than seven
    consecutive times with an incorrect password, it invokes the
    <SPLITINLINE>
      procedure
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      call-the-cops.
      <JAVASCRIPT><JAVASCRIPTINLINE>call_the_cops</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SOLUTION>
      <SNIPPET>
	<NAME>mka</NAME>
	<EXAMPLE>mka_example</EXAMPLE>
	<EXPECTED>&apos;calling the cops because you have exceeded the max no of failed attempts&apos;</EXPECTED>
	<JAVASCRIPT>
function call_the_cops(reason) {
    return &quot;calling the cops because &quot; + reason;
}
function make_account(balance, p) {

    let invalid_attempts = 0; //initializes to 0

    function withdraw(amount) {
        if (balance &gt;= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return &quot;Insufficient funds&quot;;
        }
    }

    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }

    function calling_the_cops(_) {
        return call_the_cops(&quot;you have exceeded &quot; +
                             &quot;the max no of failed attempts&quot;);
    }

    function dispatch(m, q) {
        if (invalid_attempts &lt; 7) {
            if (p === q) {
                return m === &quot;withdraw&quot;
                       ? withdraw
                       : m === &quot;deposit&quot;
                       ? deposit
                       : &quot;Unknown request: make_account&quot;;
            } else {
                invalid_attempts = invalid_attempts + 1;
                return x =&gt; &quot;Incorrect Password&quot;;
            }
        } else {
            return calling_the_cops;
        }
    }

    return dispatch;

}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>mka_example</NAME>
	<JAVASCRIPT>
const a = make_account(100, &quot;rosebud&quot;);
a(&quot;withdraw&quot;, &quot;rosebad&quot;)(50);
a(&quot;withdraw&quot;, &quot;rosebad&quot;)(50);
a(&quot;withdraw&quot;, &quot;rosebad&quot;)(50);
a(&quot;withdraw&quot;, &quot;rosebad&quot;)(50);
a(&quot;withdraw&quot;, &quot;rosebad&quot;)(50);
a(&quot;withdraw&quot;, &quot;rosebad&quot;)(50);
a(&quot;withdraw&quot;, &quot;rosebad&quot;)(50);
a(&quot;withdraw&quot;, &quot;rosebad&quot;)(50);
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>
  <INDEX>local state variable<CLOSE></CLOSE></INDEX>
  <INDEX>state variable<SUBINDEX>local<CLOSE></CLOSE></SUBINDEX></INDEX>
  <LONG_PAGE LINES="3"></LONG_PAGE>
</SUBSECTION>
