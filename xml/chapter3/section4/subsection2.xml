<SUBSECTION>
  <NAME>
    Mechanisms for Controlling Concurrency
  </NAME>

  <INDEX>concurrency<SUBINDEX>mechanisms for controlling|(</SUBINDEX></INDEX>

  <TEXT>
    We<APOS/>ve seen that the difficulty in dealing with concurrent processes is
    rooted in the need to consider the interleaving of the order of events
    in the different processes.  For example, suppose we have two
    processes, one with three ordered events <LATEXINLINE>$(a,b,c)$</LATEXINLINE>
    and one with three ordered events <LATEXINLINE>$(x,y,z)$</LATEXINLINE>.  If the
    two processes run concurrently, with no constraints on how their execution is
    interleaved, then there are 20 different possible orderings for the events that
    are consistent with the individual orderings for the two processes:
    <LATEX>
      \[ \begin{array}{cccc}
      (a,b,c,x,y,z) &amp; (a,x,b,y,c,z) &amp; (x,a,b,c,y,z) &amp; (x,a,y,z,b,c)\\
      (a,b,x,c,y,z) &amp; (a,x,b,y,z,c) &amp; (x,a,b,y,c,z) &amp; (x,y,a,b,c,z)\\
      (a,b,x,y,c,z) &amp; (a,x,y,b,c,z) &amp; (x,a,b,y,z,c) &amp; (x,y,a,b,z,c)\\
      (a,b,x,y,z,c) &amp; (a,x,y,b,z,c) &amp; (x,a,y,b,c,z) &amp; (x,y,a,z,b,c)\\
      (a,x,b,c,y,z) &amp; (a,x,y,z,b,c) &amp; (x,a,y,b,z,c) &amp; (x,y,z,a,b,c)
      \end{array} \]
    </LATEX>
    As programmers designing this system, we would have to consider the
    effects of each of these 20 orderings and check that each behavior is
    acceptable.  Such an approach rapidly becomes unwieldy as the numbers
    of processes and events increase.
  </TEXT>

  <TEXT>
    A more practical approach to the design of concurrent systems is to
    devise general mechanisms that allow us to constrain the interleaving
    of concurrent processes so that we can be sure that the program
    behavior is correct.  Many mechanisms have been developed for this
    purpose.  In this section, we describe one of them, the <EM>
    serializer</EM>.
  </TEXT>

  <SUBHEADING>
    <NAME>Serializing access to shared state</NAME>
  </SUBHEADING>

  <INDEX>serializer|(</INDEX>

  <TEXT>
    Serialization implements the following idea: Processes will execute
    concurrently, but there will be certain collections of
    <SPLITINLINE><SCHEME>procedures</SCHEME>
    <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    that cannot be executed concurrently.  More precisely, serialization
    creates distinguished sets of
    <SPLITINLINE><SCHEME>procedures</SCHEME>
    <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    such that only one execution of a
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    in each serialized set is permitted to happen at a time. If some
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    in the set is being executed, then a process that
    attempts to execute any
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    in the set will be forced to wait
    until the first execution has finished.
  </TEXT>

  <TEXT>
    We can use serialization to control access to shared variables.
    For example, if we want to update a shared variable based on the
    previous value of that variable, we put the access to the previous
    value of the variable and the assignment of the new value to the
    variable in the same
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.
    We then ensure that no other
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that assigns to the variable can run concurrently with this
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    by serializing all of these
    <SPLITINLINE><SCHEME>procedures</SCHEME>
    <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    with the same serializer.  This guarantees that the value of the
    variable cannot be changed between an access and the corresponding
    assignment.
  </TEXT>

  <SPLIT>
    <SCHEME>
      <SUBHEADING>
        <NAME>Serializers in Scheme</NAME>
      </SUBHEADING>
    </SCHEME>
    <JAVASCRIPT>
      <SUBHEADING>
        <NAME>Serializers in JavaScript</NAME>
      </SUBHEADING>
    </JAVASCRIPT>
  </SPLIT>

  <TEXT>
    To make the above mechanism more concrete, suppose that we have
    extended 
    <SPLITINLINE><SCHEME>Scheme</SCHEME>
    <JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE>
    to include a
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    called 
    <!--  \indcode{parallel-execute} -->
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>parallel-execute</SCHEMEINLINE>:</SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>parallel_execute</JAVASCRIPTINLINE>:
      </JAVASCRIPT>
    </SPLITINLINE>

    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
        (parallel-execute ^p$_{1}$^ ^p$_{2}$^ ^$\ldots$^ ^p$_{k}$^)
      </SCHEME>
      <JAVASCRIPT>
parallel_execute( f$_{1}$, f$_{2}$, $\ldots$, f$_{k}$ )
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
        Each <LATEXINLINE>p</LATEXINLINE> must be a procedure of no arguments.  
        <SCHEME>Parallel-execute</SCHEME>
        creates a separate process for each
        <LATEXINLINE>p</LATEXINLINE>, which applies
        <LATEXINLINE>p</LATEXINLINE> (to no arguments).
      </SCHEME>
      <JAVASCRIPT>
        Each <LATEXINLINE>f</LATEXINLINE> must be a function of no arguments.  
        The function <JAVASCRIPTINLINE>parallel_execute</JAVASCRIPTINLINE>
        creates a separate process for each
        <LATEXINLINE>f</LATEXINLINE>, which applies
        <LATEXINLINE>f</LATEXINLINE> (to no arguments).
      </JAVASCRIPT>
    </SPLITINLINE>
    These processes all
    run concurrently.<FOOTNOTE>
    <SPLIT>
      <SCHEME>
        <SCHEMEINLINE>Parallel-execute</SCHEMEINLINE> is not part of standard Scheme,
        but it can be implemented in MIT Scheme. In our implementation, the new
        concurrent processes also run concurrently with the original Scheme process.
        Also, in our implementation, the value returned by
        <SCHEMEINLINE>parallel-execute</SCHEMEINLINE> is a special control object that
        can be used to halt the newly created processes.
      </SCHEME>
      <JAVASCRIPT>
        The function <JAVASCRIPTINLINE>parallel_execute</JAVASCRIPTINLINE> is not
        part of the JavaScript standard, but it can be implemented using the
        <JAVASCRIPTINLINE>SharedArrayBuffer</JAVASCRIPTINLINE> feature mentioned            
        in section<SPACE/><REF NAME="sec:nature-of-time"/>.
      </JAVASCRIPT>
    </SPLIT>
  </FOOTNOTE>
  </TEXT>

  <TEXT>
    As an example of how this is used, consider
    <SNIPPET EVAL="no">
      <SCHEME>
(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
  (lambda () (set! x (+ x 1))))
      </SCHEME>
      <JAVASCRIPT>
let x = 10;

parallel_execute( () => { x = x * x; },
                  () => { x = x + 1; } );
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    This creates two concurrent
    processes<EMDASH/><LATEXINLINE>$P_1$</LATEXINLINE>, which
    sets <SCHEMEINLINE>x</SCHEMEINLINE> to
    <SCHEMEINLINE>x</SCHEMEINLINE> times <SCHEMEINLINE>x</SCHEMEINLINE>,
    and <LATEXINLINE>$P_2$</LATEXINLINE>, which increments
    <SCHEMEINLINE>x</SCHEMEINLINE>.  After execution is complete,
    <SCHEMEINLINE>x</SCHEMEINLINE> will be left with one of five possible
    values, depending on the interleaving of the events of
    <LATEXINLINE>$P_1$</LATEXINLINE> and <LATEXINLINE>$P_2$</LATEXINLINE>:
    <UL>
      <LI>
      101: <LATEXINLINE>$P_1$</LATEXINLINE>
      sets <SCHEMEINLINE>x</SCHEMEINLINE> to 100 and then
      <LATEXINLINE>$P_2$</LATEXINLINE> increments
      <SCHEMEINLINE>x</SCHEMEINLINE> to 101.
      </LI>
      <LI>
      121: <LATEXINLINE>$P_2$</LATEXINLINE> increments <SCHEMEINLINE>x</SCHEMEINLINE> to 11 and then
      <LATEXINLINE>$P_1$</LATEXINLINE> sets <SCHEMEINLINE>x</SCHEMEINLINE> to
      <SCHEMEINLINE>x</SCHEMEINLINE> times <SCHEMEINLINE>x</SCHEMEINLINE>.
      </LI>
      <LI>
      110: <LATEXINLINE>$P_2$</LATEXINLINE> changes
      <SCHEMEINLINE>x</SCHEMEINLINE> from 10 to 11 between the two
      times that <LATEXINLINE>$P_1$</LATEXINLINE> accesses the value of
      <SCHEMEINLINE>x</SCHEMEINLINE> during the evaluation of
      <JAVASCRIPTINLINE>x * x</JAVASCRIPTINLINE>.
      </LI>
      <LI>
      11:  <LATEXINLINE>$P_2$</LATEXINLINE> accesses <SCHEMEINLINE>x</SCHEMEINLINE>, then
      <LATEXINLINE>$P_1$</LATEXINLINE> sets <SCHEMEINLINE>x</SCHEMEINLINE> to 100,
      then <LATEXINLINE>$P_2$</LATEXINLINE> sets <SCHEMEINLINE>x</SCHEMEINLINE>.
      </LI>
      <LI>
      100: <LATEXINLINE>$P_1$</LATEXINLINE> accesses <SCHEMEINLINE>x</SCHEMEINLINE> (twice),
      then <LATEXINLINE>$P_2$</LATEXINLINE> sets <SCHEMEINLINE>x</SCHEMEINLINE> to 11,
      then <LATEXINLINE>$P_1$</LATEXINLINE> sets <SCHEMEINLINE>x</SCHEMEINLINE>.
      </LI>
    </UL>
  </TEXT>

  <TEXT>
    We can constrain the concurrency by using serialized
    <SPLITINLINE><SCHEME>procedures,</SCHEME>
    <JAVASCRIPT>functions,</JAVASCRIPT></SPLITINLINE>
    which are created by <EM>serializers</EM>. Serializers are constructed by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-serializer</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_serializer</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    whose implementation is given below.  A serializer takes a
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    as argument and returns a serialized
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that behaves like the original
    <SPLITINLINE><SCHEME>procedure.</SCHEME>
    <JAVASCRIPT>function.</JAVASCRIPT></SPLITINLINE>
    All calls to a given serializer return serialized
    <SPLITINLINE><SCHEME>procedures</SCHEME>
    <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    in the same set.
  </TEXT>

  <TEXT>
    Thus, in contrast to the example above, executing
    <SNIPPET EVAL="no">
      <SCHEME>
            (define x 10)

            (define s (make-serializer))

            (parallel-execute (s (lambda () (set! x (* x x))))
            (s (lambda () (set! x (+ x 1)))))
      </SCHEME>
      <JAVASCRIPT>
let x = 10;

const s = make_serializer();

parallel_execute(s( () => { x = x * x; }),
                 s( () => { x = x + 1; } ));
      </JAVASCRIPT>
    </SNIPPET>
    can produce only two possible values for
    <SCHEMEINLINE>x</SCHEMEINLINE>, 101 or 121.
    The other possibilities are eliminated, because the execution of
    <LATEXINLINE>$P_1$</LATEXINLINE> and
    <LATEXINLINE>$P_2$</LATEXINLINE> cannot be interleaved.
  </TEXT>

  <TEXT>
    Here is a version of the
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE>
    </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    from section<SPACE/><REF NAME="sec:local-state-variables"/>,
    where the deposits and withdrawals have been serialized:
    <SNIPPET EVAL="no">
      <SCHEME>
        <INDEX>bank account<SUBINDEX>serialized</SUBINDEX></INDEX>
            <!--  \indcode*{make-account}[with serialization] -->
            (define (make-account balance)
              (define (withdraw amount)
                (if (&gt;= balance amount)
                  (begin (set! balance (- balance amount))
                    balance)
                  "Insufficient funds"))
              (define (deposit amount)
                (set! balance (+ balance amount))
                  balance)
              (let ((protected (make-serializer)))
                (define (dispatch m)
                  (cond ((eq? m 'withdraw) (protected withdraw))
                  ((eq? m 'deposit) (protected deposit))
                  ((eq? m 'balance) balance)
                  (else (error "Unknown request - - MAKE-ACCOUNT"
                  m))))
                  dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_account(balance) {
    function withdraw(amount) {
        if (balance &gt; amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "Insufficient funds";
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    const protector = make_serializer();
    function dispatch(m) {
        return m === "withdraw"
               ? protector(withdraw)
               : m === "deposit"
                 ? protector(deposit)
                 : m === "balance"
                   ? balance
                   : Error("Unknown request in make_account",
                           m);
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    With this implementation, two processes cannot be withdrawing from or
    depositing into a single account concurrently.  This eliminates the source
    of the error illustrated in figure<SPACE/><REF NAME="fig:bank-access"/>,
    where Peter changes the account balance between the times when Paul accesses
    the balance to compute the new value and when Paul actually performs the
    assignment.  On the other hand, each account has its own serializer,
    so that deposits and withdrawals for different accounts can proceed
    concurrently.
  </TEXT>

  <EXERCISE>
    Which of the five possibilities in the parallel execution shown above
    remain if we instead serialize execution as follows:

    <SNIPPET EVAL="no">
      <SCHEME>
            (define x 10)

            (define s (make-serializer))

            (parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))
            (s (lambda () (set! x (+ x 1)))))
      </SCHEME>
      <JAVASCRIPT>
let x = 10;

const s = make_serializer();

parallel_execute( () => { x = s( () => x * x ); }, 
                  s( () => { x = x + 1; } ) );
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE>
    Give all possible values of <SCHEMEINLINE>x</SCHEMEINLINE>
    that can result from executing

    <SNIPPET EVAL="no">
      <SCHEME>
            (define x 10)

            (parallel-execute (lambda () (set! x (* x x)))
            (lambda () (set! x (* x x x))))
      </SCHEME>
      <JAVASCRIPT>
let x = 10;

parallel_execute( () => { x = x * x; }, 
                  () => { x = x * x * x; } );
      </JAVASCRIPT>
    </SNIPPET>

    Which of these possibilities remain if we instead use serialized
    <SPLITINLINE><SCHEME>procedures:</SCHEME>
    <JAVASCRIPT>functions:</JAVASCRIPT></SPLITINLINE>

    <SNIPPET EVAL="no">
      <SCHEME>
            (define x 10)

            (define s (make-serializer))

            (parallel-execute (s (lambda () (set! x (* x x))))
            (s (lambda () (set! x (* x x x)))))
      </SCHEME>
      <JAVASCRIPT>
let x = 10;

const s = make_serializer();

parallel_execute( s( () => x = x * x ) , 
                  s( () => x = x * x * x ) )
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE><LABEL NAME="ex:bensconcern"/>
  Ben Bitdiddle worries that it would be better to implement the bank
  account as follows (where the commented line has been changed):

  <SNIPPET EVAL="no">
    <SCHEME>
            <!--  \indcode*{make-account}[with serialization] -->
            (define (make-account balance)
            (define (withdraw amount)
            (if (&gt;= balance amount)
            (begin (set! balance (- balance amount))
            balance)
            "Insufficient funds"))
            (define (deposit amount)
            (set! balance (+ balance amount))
            balance)
            (let ((protected (make-serializer)))
            (define (dispatch m)
            (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
            ((protected (lambda () balance)))) <EM>; serialized</EM>
            (else (error "Unknown request - - MAKE-ACCOUNT"
            m))))
            dispatch))
    </SCHEME>
    <JAVASCRIPT>
function make_account(balance) {
    function withdraw(amount) {
        if (balance > amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "Insufficient funds";
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    const protected_ = make_serializer();
    function dispatch(m) {
        return m === "withdraw"
               ? protected_(withdraw)
                 : m === "deposit"
                   ? protected_(deposit)
                   : m === "balance"
                     ? protected_( () => balance )() // serialized
                     : error("Unknown request in make_account",
                             m);
                    }
                }
                return dispatch;
            }
    </JAVASCRIPT>
  </SNIPPET>
  because allowing unserialized access to the bank balance can
  result in anomalous behavior.  Do you agree?  Is there any
  scenario that demonstrates Ben<APOS/>s concern?
  </EXERCISE>

  <EXERCISE>
    Ben Bitdiddle suggests that it<APOS/>s a waste of time to
    create a new serialized
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    in response to every <SCHEMEINLINE>withdraw</SCHEMEINLINE> and
    <SCHEMEINLINE>deposit</SCHEMEINLINE> message.  He says that
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
    could be changed so that the calls to
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>protected</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>protected_</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    are done outside the <SCHEMEINLINE>dispatch</SCHEMEINLINE>
    <SPLITINLINE><SCHEME>procedure.</SCHEME>
    <JAVASCRIPT>function.</JAVASCRIPT></SPLITINLINE>
    That is, an account would return the same serialized
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    (which was created at the same time as the account) each time
    it is asked for a withdrawal
    <SPLITINLINE><SCHEME>procedure.</SCHEME>
    <JAVASCRIPT>function.</JAVASCRIPT></SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
            <!--  \indcode*{make-account}[with serialization] -->
            (define (make-account balance)
            (define (withdraw amount)
            (if (&gt;= balance amount)
            (begin (set! balance (- balance amount))
            balance)
            "Insufficient funds"))
            (define (deposit amount)
            (set! balance (+ balance amount))
            balance)
            (let ((protected (make-serializer)))
            (let ((protected-withdraw (protected withdraw))
            (protected-deposit (protected deposit)))
            (define (dispatch m)
            (cond ((eq? m 'withdraw) protected-withdraw)
            ((eq? m 'deposit) protected-deposit)
            ((eq? m 'balance) balance)
            (else (error "Unknown request - - MAKE-ACCOUNT"
            m))))
            dispatch)))
      </SCHEME>
      <JAVASCRIPT>
function make_account(balance) {
    function withdraw(amount) {
        if (balance > amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "Insufficient funds";
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    const protected_ = make_serializer();
    const protected_withdraw = protected_(withdraw);
    const protected_deposit = protected_(deposit);
    function dispatch(m) {
        return m === "withdraw"
               ? protected_withdraw
               : m === "deposit"
                 ? protected_deposit
                 : m === "balance"
                   ? balance
                   : error("Unknown request in make_account",
                           m);
    }
    return dispatch;
}
      </JAVASCRIPT>            
    </SNIPPET>

    Is this a safe change to make?  In particular, is there any
    difference in what concurrency is allowed by these two versions
    of
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>? 
  </EXERCISE>
  <INDEX>serializer|)</INDEX>

  <SUBHEADING>
    <NAME>Complexity of using multiple shared resources</NAME>
  </SUBHEADING>

  <INDEX>serializer<SUBINDEX>with multiple shared resources|(</SUBINDEX></INDEX>
  <INDEX>shared resources|(</INDEX>
  <TEXT>
    Serializers provide a powerful abstraction that helps isolate the
    complexities of concurrent programs so that they can be dealt with
    carefully and (hopefully) correctly.  However, while using serializers
    is relatively straightforward when there is only a single shared
    resource (such as a single bank account), concurrent programming can
    be treacherously difficult when there are multiple shared resources.
  </TEXT>

  <TEXT>
    To illustrate one of the difficulties that can arise, suppose we wish to swap
    the balances in two bank accounts.  We access each account to find the
    balance, compute the difference between the balances, withdraw this
    difference from one account, and deposit it in the other account.  We
    could implement this as
    follows:<FOOTNOTE>We have simplified <SCHEMEINLINE>exchange</SCHEMEINLINE>
    by exploiting the fact that our <SCHEMEINLINE>deposit</SCHEMEINLINE>
    message accepts negative amounts.  (This is a serious bug in our banking
    system!)</FOOTNOTE>

    <SNIPPET EVAL="no">
      <INDEX>bank account<SUBINDEX>exchanging balances</SUBINDEX></INDEX>
      <!--  \indcode*{exchange} -->
      <SCHEME>
            (define (exchange account1 account2)
              (let ((difference (- (account1 'balance)
                                   (account2 'balance))))
                ((account1 'withdraw) difference)
                ((account2 'deposit) difference)))
      </SCHEME>
      <JAVASCRIPT>
function exchange(account1, account2) {
    const difference = account1("balance") - account2("balance");
    account1("withdraw")(difference);
    account2("deposit")(difference);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    This
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    works well when only a single process is trying to do
    the exchange.  Suppose, however, that Peter and Paul both have access
    to accounts <LATEXINLINE>$a_1$</LATEXINLINE>, <LATEXINLINE>$a_2$</LATEXINLINE>,
    and <LATEXINLINE>$a_3$</LATEXINLINE>, and that
    Peter exchanges <LATEXINLINE>$a_1$</LATEXINLINE> and
    <LATEXINLINE>$a_2$</LATEXINLINE> while Paul concurrently exchanges
    <LATEXINLINE>$a_1$</LATEXINLINE> and <LATEXINLINE>$a_3$</LATEXINLINE>.
    Even with account deposits and withdrawals
    serialized for individual accounts (as in the
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    shown above in this section),
    <SCHEMEINLINE>exchange</SCHEMEINLINE> can still
    produce incorrect results.  For example, Peter might compute the
    difference in the balances for
    <LATEXINLINE>$a_1$</LATEXINLINE> and <LATEXINLINE>$a_2$</LATEXINLINE>, but then Paul
    might change the balance in <LATEXINLINE>$a_1$</LATEXINLINE> before Peter is able
    to complete the exchange.<FOOTNOTE>If the account balances start out as <DOLLAR/>10,
    <DOLLAR/>20, and <DOLLAR/>30, then after any number of concurrent exchanges, the
    balances should still be <DOLLAR/>10, <DOLLAR/>20, and
    <DOLLAR/>30 in some order.  Serializing the deposits to individual accounts is not
    sufficient to guarantee this.
    See exercise<SPACE/><REF NAME="ex:exchange-bug"/>.</FOOTNOTE>
    For correct behavior, we must arrange for the <SCHEMEINLINE>exchange</SCHEMEINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    to lock out any other concurrent accesses to the accounts during the
    entire time of the exchange.
  </TEXT>

  <TEXT>
    One way we can accomplish this is by using both accounts<APOS/> serializers
    to serialize the entire <SCHEMEINLINE>exchange</SCHEMEINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.
    To do this, we will arrange for access to an account<APOS/>s serializer.
    Note that we are deliberately
    breaking the modularity of the bank-account object by exposing the
    serializer.  The following version of
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is identical to the original version given in
    Section<SPACE/><REF NAME="sec:local-state-variables"/>, except that a serializer is
    provided to protect the balance variable, and the serializer is
    exported via message passing:

    <SNIPPET EVAL="no">
      <SCHEME>
            <!--  \indcode*{make-account-and-serializer} -->
            (define (make-account-and-serializer balance)
            (define (withdraw amount)
            (if (&gt;= balance amount)
            (begin (set! balance (- balance amount))
            balance)
            "Insufficient funds"))
            (define (deposit amount)
            (set! balance (+ balance amount))
            balance)
            (let ((balance-serializer (make-serializer)))
            (define (dispatch m)
            (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request - - MAKE-ACCOUNT"
            m))))
            dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_account_and_serializer(balance) {
    function withdraw(amount) {
        if (balance > amount) {
            balance = balance - amount;
        } else {
            "Insufficient funds";
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    const balance_serializer = make_serializer();
    function dispatch(m) {
        if (m === "withdraw") {
            return withdraw;
        } else if (m === "deposit") {
            return deposit;
        } else if (m === "balance") {
            return balance;
        } else if (m === "serializer") {
            return balance_serializer;
        } else {
            return "Unknown request - - MAKE-ACCOUNT";
        }
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    We can use this to do serialized deposits and withdrawals.  However,
    unlike our earlier serialized account, it is now the responsibility of
    each user of bank-account objects to explicitly manage the
    serialization, for example as
    follows:<FOOTNOTE>Exercise<SPACE/><REF NAME="ex:export-serializer"/>
    investigates why
    deposits and withdrawals are no longer automatically serialized
    by the account.</FOOTNOTE>

    <SNIPPET EVAL="no">
      <SCHEME>
            <!-- \indcodeplus*{deposit}{, with external serializer}-->
            (define (deposit account amount)
            (let ((s (account 'serializer))
            (d (account 'deposit)))
            ((s d) amount)))
      </SCHEME>
      <JAVASCRIPT>
function deposit(account, amount) {
    const s = account("serializer");
    const d = account("deposit");
    s(d(amount));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Exporting the serializer in this way gives us enough flexibility to
    implement a serialized exchange program.  We simply
    serialize the original
    <SCHEMEINLINE>exchange</SCHEMEINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    with the serializers for both accounts:

    <SNIPPET EVAL="no">
      <SCHEME>
            <!--  \indcode*{serialized-exchange} -->
            (define (serialized-exchange account1 account2)
            (let ((serializer1 (account1 'serializer))
            (serializer2 (account2 'serializer)))
            ((serializer1 (serializer2 exchange))
            account1
            account2)))
      </SCHEME>
      <JAVASCRIPT>
function serialized_exchange(account1, account2) {
    const serializer1 = account1("serializer");
    const serializer2 = account2("serializer");
    serializer1(serializer2(exchange))(account1, account2);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <EXERCISE>
    Suppose that the balances in three accounts start out as <DOLLAR/>10, <DOLLAR/>20,
    and <DOLLAR/>30, and that multiple processes run, exchanging the balances in
    the accounts.  Argue that if the processes are run sequentially,
    after any number of concurrent exchanges, the account balances should be 
    <DOLLAR/>10, <DOLLAR/>20, and <DOLLAR/>30 in some order.
    Draw a timing diagram like the one in Figure<SPACE/><REF NAME="fig:bank-access"/> to
    show how this condition can be violated if the exchanges are
    implemented using the first version of the account-exchange program in
    this section.  On the other hand, argue that even with this
    <SCHEMEINLINE>exchange</SCHEMEINLINE> program, the sum of the balances
    in the accounts will be preserved.  Draw a timing diagram to show how
    even this condition would be violated if we did not serialize the
    transactions on individual accounts.
    <LABEL NAME="ex:exchange-bug"/>
  </EXERCISE>

  <EXERCISE>
    <INDEX>bank account<SUBINDEX>transferring money</SUBINDEX></INDEX>
    Consider the problem of transferring an amount from one account to
    another.  Ben Bitdiddle claims that this can be accomplished with the
    following
    <SPLITINLINE><SCHEME>procedure,</SCHEME>
    <JAVASCRIPT>function,</JAVASCRIPT></SPLITINLINE>
    even if there are multiple people concurrently
    transferring money among multiple accounts, using any account
    mechanism that serializes deposit and withdrawal transactions, for
    example, the version of
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT>
      <JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE>
    </JAVASCRIPT>
    </SPLITINLINE>
    in the text above.

    <SNIPPET EVAL="no">
      <SCHEME>
            (define (transfer from-account to-account amount)
            ((from-account 'withdraw) amount)
            ((to-account 'deposit) amount))
      </SCHEME>
      <JAVASCRIPT>
function transfer(from_account, to_account, amount) {
    from_account("withdraw")(amount);
    to_account("deposit")(amount);
}
      </JAVASCRIPT>
    </SNIPPET>

    Louis Reasoner claims that there is a problem here, and that we need
    to use a more sophisticated method, such as the one required for
    dealing with the exchange problem.  Is Louis right?  If not, what is
    the essential difference between the transfer problem and the exchange
    problem?  (You should assume that the balance in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>from-account</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>from_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is at least <SCHEMEINLINE>amount</SCHEMEINLINE>.)
  </EXERCISE>

  <EXERCISE>
    Louis Reasoner thinks our bank-account system is unnecessarily complex
    and error-prone now that deposits and withdrawals aren<APOS/>t
    automatically serialized. He suggests that
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>make-account-and-serializer</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>make_account_and_serializer</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    should have exported the serializer 
    <SPLITINLINE>
      <SCHEME>
        (for use by such procedures as
        <SCHEMEINLINE>serialized-exchange</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
        (for use by such functions as
        <JAVASCRIPTINLINE>serialized_exchange</JAVASCRIPTINLINE>)        
      </JAVASCRIPT>
    </SPLITINLINE>
    in addition to (rather than instead of) using it to serialize accounts and
    deposits as
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    did. He proposes to redefine accounts as follows:
    <SNIPPET EVAL="no">
      <SCHEME>
            (define (make-account-and-serializer balance)
            (define (withdraw amount)
            (if (&gt;= balance amount)
            (begin (set! balance (- balance amount))
            balance)
            "Insufficient funds"))
            (define (deposit amount)
            (set! balance (+ balance amount))
            balance)
            (let ((balance-serializer (make-serializer)))
            (define (dispatch m)
            (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request - - MAKE-ACCOUNT"
            m))))
            dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_account_and_serializer(balance) {
    function withdraw(amount) {
        if (balance > amount) {
            balance = balance - amount;
        } else {
            "Insufficient funds";
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    const balance_serializer = make_serializer();
    function dispatch(m) {
        return m === "withdraw"
               ? balance_serializer(withdraw)
               : m === "deposit"
                 ? balance_serializer(deposit)
                 : m === "balance"
                   ? balance
                   : m === "serializer"
                     ? balance_serializer
                     : error("Unknown request in make_account",
                             m);
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET>

    Then deposits are handled as with the original
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE>:</SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE>:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
        (define (deposit account amount)
        ((account 'deposit) amount))
      </SCHEME>
      <JAVASCRIPT>
function deposit(account, amount) {
    account("deposit")(amount);
}
      </JAVASCRIPT>
    </SNIPPET>
    Explain what is wrong with Louis's reasoning.  In particular,
    consider what happens when
    <SPLITINLINE><SCHEME><SCHEMEINLINE>serialized-exchange</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>serialized_exchange</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is called.
    <LABEL NAME="ex:export-serializer"/>
  </EXERCISE>
  <INDEX>serializer<SUBINDEX>with multiple shared resources|)</SUBINDEX></INDEX>
  <INDEX>shared resources|)</INDEX>

  <SUBHEADING>
    <NAME>Implementing serializers</NAME>
  </SUBHEADING>

  <INDEX>serializer<SUBINDEX>implementing|(</SUBINDEX></INDEX>

  <TEXT>
    We implement serializers in terms of a more primitive synchronization
    mechanism called a 
    <INDEX>mutex</INDEX>
    <EM>mutex</EM>.  A mutex is an object that supports
    two operations<EMDASH/>the mutex can be 
    <INDEX>acquire a mutex</INDEX>
    <EM>acquired</EM>, and the mutex can be
    <INDEX>release a mutex</INDEX>
    <EM>released</EM>.  Once a mutex has been acquired, no other acquire
    operations on that mutex may proceed until the mutex is
    released.<FOOTNOTE>The term <QUOTE>mutex</QUOTE> is an abbreviation for 
    <INDEX>mutual exclusion</INDEX>
    <EM>mutual
    exclusion</EM>.  The general problem of arranging a mechanism that permits
    concurrent processes to safely share resources is called the mutual
    exclusion problem.  Our mutex is a simple variant of the 
    <INDEX>semaphore</INDEX>
    <EM>semaphore</EM> mechanism (see exercise<SPACE/><REF NAME="ex:semaphore"/>),
    which was introduced in the 
    <INDEX>THE Multiprogramming System</INDEX>
    <QUOTE>THE</QUOTE> Multiprogramming System developed at the
    <INDEX>Technological University of Eindhoven</INDEX>
    Technological University of Eindhoven and named for the university<APOS/>s
    initials in Dutch (<CITATION>Dijkstra 1968a</CITATION>).  The acquire and
    release operations were originally called 
    <INDEX>P@P operation on semaphore</INDEX>
    <INDEX>V@V operation on semaphore</INDEX>
    <INDEX>Dijkstra, Edsger Wybe</INDEX>
    P and V, from the Dutch
    words <EM>passeren</EM> (to pass) and <EM>vrijgeven</EM> (to release), in
    reference to the semaphores used on railroad systems.  Dijkstra<APOS/>s
    classic exposition (1968b) was one of the first to clearly present the
    issues of concurrency control, and showed how to use semaphores to
    handle a variety of concurrency problems.</FOOTNOTE>
    In our implementation, each serializer has an associated mutex.  Given a
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SCHEMEINLINE>p</SCHEMEINLINE>, the serializer returns a
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    that acquires the mutex, runs <SCHEMEINLINE>p</SCHEMEINLINE>,
    and then releases the mutex.  This ensures that only one of the
    <SPLITINLINE><SCHEME>procedures</SCHEME>
    <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
    produced by the serializer can be running at once, which is
    precisely the serialization property that we need to guarantee.

    <SNIPPET EVAL="no">
      <SCHEME>
            <!--  \indcode*{make-serializer} -->
            (define (make-serializer)
            (let ((mutex (make-mutex)))
            (lambda (p)
            (define (serialized-p . args)
            (mutex 'acquire)
            (let ((val (apply p args)))
            (mutex 'release)
            val))
            serialized-p)))
      </SCHEME>
      <JAVASCRIPT>
function make_serializer() {
    const mutex = make_mutex();
    return p => {
        function serialized_p(args) {
            mutex("acquire");
            const val = p(args);
            mutex("release");
            return val;
        }
        return serialized_p;   
    };
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The mutex is a mutable object (here we<APOS/>ll use a one-element
    list, which we<APOS/>ll refer to as a 
    <INDEX>cell, in serializer implementation</INDEX>
    <EM>cell</EM>) that can hold the value
    true or false.  When the value is false, the mutex is available to be
    acquired.  When the value is true, the mutex is unavailable, and any
    process that attempts to acquire the mutex must wait.
  </TEXT>

  <TEXT>
    Our mutex constructor
    <SPLITINLINE><SCHEME><SCHEMEINLINE>make-mutex</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>make_mutex</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    begins by initializing the cell
    contents to false.  To acquire the mutex, we test the cell.  If the
    mutex is available, we set the cell contents to true and proceed.
    Otherwise, we wait in a loop, attempting to acquire over and over
    again, until we find that the mutex is
    available.<FOOTNOTE>In most time-shared operating systems,
    processes that are 
    <INDEX>blocked process</INDEX>
    blocked by a mutex do
    <INDEX>busy-waiting</INDEX>
    not waste time <QUOTE>busy-waiting</QUOTE> as above.  Instead, the system
    schedules another process to run while the first is waiting, and the blocked
    process is awakened when the mutex becomes available.</FOOTNOTE>
    To release the mutex, we set the cell contents to false.

    <SNIPPET EVAL="no">
      <SCHEME>
            <!--  \indcode*{make-mutex} -->
            (define (make-mutex)
            (let ((cell (list false)))            
            (define (the-mutex m)
            (cond ((eq? m 'acquire)
            (if (test-and-set! cell)
            (the-mutex 'acquire))) <EM>; retry</EM>
            ((eq? m 'release) (clear! cell))))
            the-mutex))

            (define (clear! cell)
            (set-car! cell false))
      </SCHEME>
      <JAVASCRIPT>
function make_mutex() {
    const cell = list(false);
    function the_mutex(m) {
        return m === "aquire"
               ? ( test_and_set(cell)
                   ? the_mutex("aquire") // retry
                   : true )
               : m === "release"
                 ? clear(cell)
                 : error("Unknown request in mutex",
                         m);
    }
    return the_mutex;
}
function clear(cell) {
    set_head(cell, false);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Test-and-set!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function <JAVASCRIPTINLINE>test_and_set</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    tests the cell and returns the result of the
    test.  In addition, if the test was false,
    <SPLITINLINE><SCHEME><SCHEMEINLINE>test-and-set!</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>test_and_set</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    sets the cell contents to true before returning false.  We can express this
    behavior as the following
    <SPLITINLINE><SCHEME>procedure:</SCHEME>
    <JAVASCRIPT>function:</JAVASCRIPT></SPLITINLINE>

    <SNIPPET EVAL="no">
      <SCHEME>
            <!--  \indcode*{test-and-set!} -->
            (define (test-and-set! cell)
            (if (car cell)
            true
            (begin (set-car! cell true)
            false)))
      </SCHEME>
      <JAVASCRIPT>
function test_and_set(cell) {
    if (head(cell)) {
        return true;
    } else {
        set_head(cell, true);
        return false;
    }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    However, this implementation of
    <SPLITINLINE><SCHEME><SCHEMEINLINE>test-and-set!</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>test_and_set</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
    does not suffice as it stands.  There is a crucial subtlety here, which is the
    essential place where concurrency control enters the system: The
    <SPLITINLINE><SCHEME><SCHEMEINLINE>test-and-set!</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>test_and_set</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operation must be performed 
    <INDEX>atomic requirement for
    <SPLITINLINE><SCHEME>test-and-set!</SCHEME>
    <JAVASCRIPT>test_and_set</JAVASCRIPT></SPLITINLINE></INDEX>
    <EM>atomically</EM>. That is, we must guarantee that, once a process has tested
    the cell and found it to be false, the cell contents will actually be set to true
    before any other process can test the cell.  If we do not make this
    guarantee, then the mutex can fail in a way similar to the
    bank-account failure in Figure<SPACE/><REF NAME="fig:bank-access"/>.  (See
    exercise<SPACE/><REF NAME="ex:atomic-test-and-set"/>.)
  </TEXT>

  <TEXT>
    The actual implementation of
    <SPLITINLINE><SCHEME><SCHEMEINLINE>test-and-set!</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>test_and_set</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    depends on the details of how our system runs concurrent processes.
    For example, we might be executing concurrent processes on a sequential
    processor using a 
    <INDEX>time slicing</INDEX>
    time-slicing mechanism that cycles through the processes,
    permitting each process to run for a short time before interrupting it
    and moving on to the next process.  In that case,
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>test-and-set!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>test_and_set</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    can work by disabling time slicing during the testing and
    setting.
    <SPLITINLINE>
	<SCHEME>
      <FOOTNOTE>
        In MIT Scheme for a single processor, which uses a time-slicing
        model, <SCHEMEINLINE>test-and-set!</SCHEMEINLINE>
        can be implemented as follows:
        <!--  \indcode{without-interrupts} -->
        <INDEX>MIT Scheme<SUBINDEX>without@without-interrupts</SUBINDEX></INDEX>
        <SNIPPET EVAL="no">
          <SCHEME>
              <!--  \indcode*{test-and-set!} -->
              (define (test-and-set! cell)
              (without-interrupts
              (lambda ()
              (if (car cell)
              true
              (begin (set-car! cell true)
              false)))))
          </SCHEME>
        </SNIPPET>
        Without-interrupts disables
        time-slicing interrupts while its procedure
        argument is being executed.
      </FOOTNOTE>
      </SCHEME>
    </SPLITINLINE>
  Alternatively, multiprocessing computers provide instructions that
  support atomic operations directly in
  hardware.<FOOTNOTE>There are many variants of such
  <INDEX>atomic operations supported in hardware</INDEX>
  instructions<EMDASH/>including test-and-set, test-and-clear, swap,
  compare-and-exchange, load-reserve, and store-conditional<EMDASH/>whose
  design must be carefully matched to the machine<APOS/>s
  processor<ENDASH/>memory interface.
  One issue that arises here is to determine what happens
  if two processes attempt to acquire the same resource
  at exactly the same time by using such an instruction.
  This requires some mechanism for making a decision about
  which process gets control. Such a mechanism is called an 
  <INDEX>arbiter</INDEX>
  <EM>arbiter</EM>.  Arbiters usually boil down to some sort of hardware
  device. Unfortunately, it is possible to prove that one cannot physically
  construct a fair arbiter that works 100% of the time unless one
  allows the arbiter an arbitrarily long time to make its decision.
  The fundamental phenomenon here was originally observed by the
  fourteenth-century French philosopher 
  <INDEX>Buridan, Jean</INDEX>
  Jean Buridan in his commentary on
  <INDEX>Aristotle<APOS/>s <EM>De caelo</EM>
  (Buridan<APOS/>s commentary on)</INDEX>
  Aristotle<APOS/>s <EM>De caelo</EM>.  Buridan argued that a perfectly
  rational
  <INDEX>dog, perfectly rational, behavior of</INDEX>
  dog placed between two equally attractive sources of food will starve
  to death, because it is incapable of deciding which to go to first.</FOOTNOTE>
  </TEXT>

  <EXERCISE>
    Suppose that we implement
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>test-and-set!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>test_and_set</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    using an ordinary
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    as shown in the text, without attempting to make the operation
    atomic.  Draw a timing diagram like the one in
    figure<SPACE/><REF NAME="fig:bank-access"/> to demonstrate how the mutex
    implementation can fail by allowing two processes to acquire the mutex
    at the same time.
    <LABEL NAME="ex:atomic-test-and-set"/>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:semaphore"/>
    <INDEX>semaphore<SUBINDEX>of size <LATEXINLINE>$n$</LATEXINLINE></SUBINDEX></INDEX>
    A semaphore (of size <LATEXINLINE>$n$</LATEXINLINE>) is a generalization of a mutex.
    Like a mutex, a semaphore supports acquire and release operations, but it is
    more general in that up to <LATEXINLINE>$n$</LATEXINLINE> processes can acquire it
    concurrently.  Additional processes that attempt to acquire the
    semaphore must wait for release operations.  Give implementations of
    semaphores
    <OL>
      <LI>in terms of mutexes
      </LI>
      <LI>
        in terms of atomic
        <SPLITINLINE>
          <SCHEME><SCHEMEINLINE>test-and-set!</SCHEMEINLINE></SCHEME>
          <JAVASCRIPT><JAVASCRIPTINLINE>test_and_set</JAVASCRIPTINLINE></JAVASCRIPT>
        </SPLITINLINE>
        operations.
      </LI>
    </OL>
  </EXERCISE>
  <INDEX>serializer<SUBINDEX>implementing|)</SUBINDEX></INDEX>

  <SUBHEADING>
    <NAME>Deadlock</NAME>
  </SUBHEADING>

  <INDEX>concurrency<SUBINDEX>deadlock|(</SUBINDEX></INDEX>
  <INDEX>deadlock|(</INDEX>

  <TEXT>
    <!-- 
         %Even with the serialization technique discussed above,
         %account exchanging still has a problem.
    -->
    Now that we have seen how to implement serializers, we can see
    that account exchanging still has a problem, even with the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>serialized-exchange</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>serialized_exchange</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    above.
    Imagine that Peter attempts to exchange <LATEXINLINE>$a_1$</LATEXINLINE>
    with <LATEXINLINE>$a_2$</LATEXINLINE> while Paul concurrently attempts to
    exchange <LATEXINLINE>$a_2$</LATEXINLINE>
    with <LATEXINLINE>$a_1$</LATEXINLINE>.
    Suppose that Peter<APOS/>s process reaches the point where
    it has entered a serialized
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    protecting <LATEXINLINE>$a_1$</LATEXINLINE> and, just
    after that, Paul<APOS/>s process enters a serialized
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    protecting
    <LATEXINLINE>$a_2$</LATEXINLINE>.  Now Peter cannot proceed (to
    enter a serialized
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    protecting <LATEXINLINE>$a_2$</LATEXINLINE>) until Paul exits
    the serialized
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    protecting <LATEXINLINE>$a_2$</LATEXINLINE>.  Similarly, Paul
    cannot proceed until Peter exits the serialized
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    protecting <LATEXINLINE>$a_1$</LATEXINLINE>.  Each process is
    stalled forever, waiting for the other.  This situation is
    called a <EM>deadlock</EM>.  Deadlock is always a danger in systems
    that provide concurrent access to multiple shared resources.
  </TEXT>

  <TEXT>
    <INDEX>deadlock<SUBINDEX>avoidance</SUBINDEX></INDEX>
    One way to avoid the deadlock in this situation is to give each
    account a unique identification number and rewrite
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>serialized-exchange</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>serialized_exchange</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    so that a process will always attempt to enter a
    <SPLITINLINE><SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    protecting the
    lowest-numbered account first.  Although this method works well for
    the exchange problem, there are other situations that require more
    sophisticated deadlock-avoidance techniques, or where deadlock cannot
    be avoided at all.  (See exercises<SPACE/><REF NAME="ex:deadlock-avoid"/>
    and<SPACE/><REF NAME="ex:deadlock-cannot-avoid"/>.)<FOOTNOTE>The general
    technique for avoiding deadlock by numbering the
    <INDEX>deadlock<SUBINDEX>recovery</SUBINDEX></INDEX>
    shared resources and acquiring them in order is due to 
    <INDEX>Havender, J.</INDEX>
    <INDEX>Gray, Jim</INDEX>
    <INDEX>Reuter, Andreas</INDEX>
    Havender
    (1968).  Situations where deadlock cannot be avoided require
    <EM>deadlock-recovery</EM> methods, which entail having processes
    <QUOTE>back out</QUOTE> of the deadlocked state and try again.
    Deadlock-recovery mechanisms are widely used in database management
    systems, a topic that
    is treated in detail in
    <CITATION>Gray and Reuter 1993</CITATION>.</FOOTNOTE>
  </TEXT>

  <EXERCISE>
    <!--  \indcode*{serialized-exchange}[with deadlock avoidance] -->
    Explain in detail why the deadlock-avoidance method described above,
    (i.e., the accounts are numbered, and each process attempts to acquire
    the smaller-numbered account first) avoids deadlock in the exchange
    problem.  Rewrite
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>serialized-exchange</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>serialized_exchange</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to incorporate this idea. (You will also need to modify
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    so that each account is created with a number, which can be accessed by
    sending an appropriate message.)
    <LABEL NAME="ex:deadlock-avoid"/>
  </EXERCISE>

  <EXERCISE>
    Give a scenario where the deadlock-avoidance mechanism described
    above does not work.  (Hint: In the exchange problem, each process
    knows in advance which accounts it will need to get access to.  Consider a
    situation where a process must get access to some shared resources before it
    can know which additional shared resources it will require.)
    <LABEL NAME="ex:deadlock-cannot-avoid"/>
  </EXERCISE>
  <INDEX>concurrency<SUBINDEX>deadlock|)</SUBINDEX></INDEX>
  <INDEX>deadlock|)</INDEX>


  <SUBHEADING>
    <NAME>Concurrency, time, and communication</NAME>
  </SUBHEADING>

  <TEXT>
    We<APOS/>ve seen how programming concurrent systems requires controlling the
    ordering of events when different processes access shared
    state, and we<APOS/>ve seen how to achieve this control through judicious
    use of serializers.  But the problems of concurrency
    lie deeper than this, because, from a fundamental point of view, it<APOS/>s
    not always clear what is meant by <QUOTE>shared state.</QUOTE>
  </TEXT>

  <TEXT>
    Mechanisms such as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>test-and-set!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>test_and_set</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    require processes to examine a
    global shared flag at arbitrary times.  This is problematic and
    inefficient to implement in modern high-speed processors, where
    due to optimization techniques such as pipelining and cached memory,
    the contents of memory
    may not be in a consistent state at every instant.  In contemporary
    multiprocessing systems, therefore, the serializer paradigm is being
    supplanted by new approaches to concurrency
    control.<FOOTNOTE>One such alternative to serialization is called 
    <INDEX>barrier synchronization</INDEX>
    <EM>barrier synchronization</EM>.  The programmer permits concurrent processes
    to execute as they please, but establishes certain synchronization points
    (<QUOTE>barriers</QUOTE>) through which no process can proceed until all the
    processes have reached the barrier.  Modern processors provide machine
    instructions that permit programmers to establish synchronization
    points at places where consistency is required.  The 
    <INDEX>PowerPC</INDEX>
    PowerPC<LATEXINLINE>$^{\textrm{TM}}$</LATEXINLINE>, for example,
    includes for this purpose two instructions called
    <INDEX>SYNC</INDEX>
    SYNC and 
    <INDEX>EIEIO</INDEX>
    EIEIO (Enforced In-order Execution of Input/Output).</FOOTNOTE>
  </TEXT>

  <TEXT>
    The problematic aspects of shared state also arise
    in large, distributed systems.  For
    instance, imagine a
    distributed banking system where individual branch banks maintain
    local values for bank balances and periodically compare these with
    values maintained by other branches.  In such a system the value of
    <QUOTE>the account balance</QUOTE> would be undetermined, except right after
    synchronization.
    If Peter deposits money in an account he holds
    jointly with Paul, when should we say that the account balance has
    changed<EMDASH/>when the balance in the local branch changes, or not until
    after the synchronization?  
    And if Paul accesses the account from a
    different branch, what are the reasonable constraints to place on the
    banking system such that the behavior is <QUOTE>correct</QUOTE>?  
    The only thing that might matter for
    correctness is the behavior observed by Peter and Paul individually
    and the <QUOTE>state</QUOTE> of the account immediately after synchronization.
    Questions about the
    <QUOTE>real</QUOTE> account balance or the order of events between
    synchronizations may be irrelevant or meaningless.<FOOTNOTE>This may seem
    like a strange point of view, but there are
    <INDEX>credit-card accounts, international</INDEX>
    systems that work this way.  International charges to credit-card
    accounts, for example, are normally cleared on a per-country basis,
    and the charges made in different countries are periodically
    reconciled.  Thus the account balance may be different in
    different countries.</FOOTNOTE>
  </TEXT>

  <TEXT>
    <INDEX>time<SUBINDEX>communication and</SUBINDEX></INDEX>
    The basic phenomenon here is that synchronizing different processes,
    establishing shared state, or imposing an order on events requires
    communication among the processes.  In essence, any notion of time in
    concurrency control must be intimately tied to
    communication.<FOOTNOTE>For distributed
    systems, this perspective was pursued by 
    <INDEX>Lamport, Leslie</INDEX>
    Lamport (1978), who showed how
    to use communication to establish <QUOTE>global clocks</QUOTE> that can be
    used to establish orderings on events in distributed systems.</FOOTNOTE>
    It is intriguing that a similar connection between time and
    communication also arises in the 
    <INDEX>relativity, theory of</INDEX>
    Theory of Relativity, where the speed of light (the
    fastest signal that can be used to synchronize events) is a
    fundamental constant relating time and space.  The
    complexities we encounter in dealing with time and state in our
    computational models may in fact mirror a fundamental complexity of
    the physical universe.
    <INDEX>concurrency|)</INDEX>
    <INDEX>concurrency<SUBINDEX>mechanisms for controlling|)</SUBINDEX></INDEX>
  </TEXT>

</SUBSECTION>
