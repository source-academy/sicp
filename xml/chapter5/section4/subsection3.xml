<SUBSECTION>
  <NAME>
    Conditionals, Assignments<SPLITINLINE><SCHEME>, and Definitions</SCHEME><JAVASCRIPT>, and Declarations</JAVASCRIPT></SPLITINLINE>
  </NAME>

  <LABEL NAME="sec:cond-assign-def-evaluation"/>
  <TEXT>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>conditionals</SUBINDEX></INDEX>
    As with the metacircular evaluator,
    <SPLITINLINE>
      <SCHEME>
        special
      </SCHEME>
      <JAVASCRIPT>
        syntactic
      </JAVASCRIPT>
    </SPLITINLINE>
    forms are handled by
    selectively evaluating fragments of the
    <SPLITINLINE>
      <SCHEME>
        expression.
      </SCHEME>
      <JAVASCRIPT>
        component.
      </JAVASCRIPT>
    </SPLITINLINE>
    For
    <SPLITINLINE>
      <SCHEME>
	an <SCHEMEINLINE>if</SCHEMEINLINE> expression, 
      </SCHEME>
      <JAVASCRIPT>
	a conditional,
      </JAVASCRIPT>
    </SPLITINLINE>
    we must evaluate the predicate and decide, based on the
    value of predicate, whether to evaluate the consequent or the
    alternative.
  </TEXT>

  <TEXT>
    Before evaluating the predicate, we save the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE> expression 
      </SCHEME>
      <JAVASCRIPT>
	conditional
      </JAVASCRIPT>
    </SPLITINLINE>
    itself so that we can later extract the consequent or
    alternative.  We also save the environment, which we will need later in
    order to evaluate the consequent or the alternative, and we save
    <SCHEMEINLINE>continue</SCHEMEINLINE>, which we will need later in order to
    return to the evaluation of the
    <SPLITINLINE>
      <SCHEME>
        expression
      </SCHEME>
      <JAVASCRIPT>
        statement
      </JAVASCRIPT>
    </SPLITINLINE>
    that is waiting for the value of
    the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	      conditional.<FOOTNOTE>In this chapter, we will use the function
        <JAVASCRIPTINLINE>is_falsy</JAVASCRIPTINLINE> to test the value of
        the predicate. This allows us to write the consequent and the
        alternate branches in the same order as they appear in a conditional,
        and simply fall through to the consequent branch when the predicate
        holds. The function is declared as the opposite of the
        <JAVASCRIPTINLINE>is_truthy</JAVASCRIPTINLINE> function used to
        test predicates of conditionals in section<SPACE/><REF NAME="sec:core-of-evaluator"/>.
	<INDEX><DECLARATION>is_falsy</DECLARATION><SUBINDEX>why used in explicit-control evaluator</SUBINDEX></INDEX>
      </FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><DECLARATION>ev_conditional</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
ev-if
(save exp)                    <EM>; save expression for later</EM>
(save env)
(save continue)
(assign continue (label ev-if-decide))
(assign exp (op if-predicate) (reg exp))
(goto (label eval-dispatch))  <EM>; evaluate the predicate</EM>
      </SCHEME>
      <JAVASCRIPT>
"ev_conditional",
      save("comp"), // save conditional for later
      save("env"),
      save("continue"),
      assign("continue", label("ev_conditional_decide")),
      assign("comp", list(op("conditional_predicate"), reg("comp"))),
      go_to(label("eval_dispatch")), // evaluate the predicate
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    When we return from evaluating the predicate, we test whether it was
    true or false and, depending on the result, place either the
    consequent or the alternative in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    before
    going to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Notice that restoring <SCHEMEINLINE>env</SCHEMEINLINE> and
    <SCHEMEINLINE>continue</SCHEMEINLINE> here sets up
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to have the correct environment and
    to continue at the right place to receive the value of the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE> expression. 
      </SCHEME>
      <JAVASCRIPT>
	conditional.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
ev-if-decide
(restore continue)
(restore env)
(restore exp)
(test (op true?) (reg val))
(branch (label ev-if-consequent))
ev-if-alternative
(assign exp (op if-alternative) (reg exp))
(goto (label eval-dispatch))
ev-if-consequent
(assign exp (op if-consequent) (reg exp))
(goto (label eval-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_conditional_decide",
      restore("continue"),
      restore("env"),
      restore("comp"),
      test(list(op("is_falsy"), reg("val"))),
      branch(label("ev_conditional_alternative")),
      
"ev_conditional_consequent",
      assign("comp", list(op("conditional_consequent"), reg("comp"))),
      go_to(label("eval_dispatch")),
      
"ev_conditional_alternative",
      assign("comp", list(op("conditional_alternative"), reg("comp"))),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  
  <SUBHEADING> 
    <NAME>Assignments and <SPLITINLINE><SCHEME>definitions</SCHEME><JAVASCRIPT>declarations</JAVASCRIPT></SPLITINLINE></NAME>
  </SUBHEADING>

  <TEXT>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>assignments</SUBINDEX></INDEX>
    Assignments are handled by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-assignment</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_assignment</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which is reached from
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    with the assignment expression in <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>.  The
    code at
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>ev-assignment</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_assignment</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    first evaluates the value part of the expression and then installs the new
    value in the environment.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Set-variable-value!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>assign_symbol_value</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is assumed to be available as a machine operation.
    <INDEX><DECLARATION>ev_assignment</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
ev-assignment
(assign unev (op assignment-variable) (reg exp))
(save unev)                   <EM>; save variable for later</EM>
(assign exp (op assignment-value) (reg exp))
(save env)
(save continue)
(assign continue (label ev-assignment-1))
(goto (label eval-dispatch))  <EM>; evaluate the assignment value</EM>
ev-assignment-1
(restore continue)
(restore env)
(restore unev)
(perform
(op set-variable-value!) (reg unev) (reg val) (reg env))
(assign val (const ok))
(goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
"ev_assignment",
      assign("unev", list(op("assignment_symbol"), reg("comp"))),
      save("unev"), // save variable for later
      assign("comp", list(op("assignment_value_expression"), reg("comp"))),
      save("env"),
      save("continue"),
      assign("continue", label("ev_assignment_1")),
      go_to(label("eval_dispatch")), // evaluate assignment value
      
"ev_assignment_1",
      restore("continue"),
      restore("env"),
      restore("unev"),
      perform(list(op("assign_symbol_value"),
                   reg("unev"), reg("val"), reg("env"))),
      go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>declarations</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
        Definitions are handled in a similar way:
      </SCHEME>
      <JAVASCRIPT>
        Declarations of variables and constants are handled in a similar way.
        Note that whereas the value of an assignment is the value that was assigned,
        the value of a declaration is
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>. This is handled by
        setting <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> to
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> before continuing. 
        As in the metacircular evaluator, we transform a function declaration
        into a constant declaration whose value expression is a lambda expression. This happens at
        <JAVASCRIPTINLINE>ev_function_declaration</JAVASCRIPTINLINE> which makes the
        transformation in place in <JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE> and
        falls through to <JAVASCRIPTINLINE>ev_declaration</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
      </SPLITINLINE>
      <INDEX><DECLARATION>ev_function_declaration</DECLARATION></INDEX> 
      <INDEX><DECLARATION>ev_declaration</DECLARATION></INDEX> 
      <INDEX><DECLARATION>ev_declaration_assign</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
ev-definition
(assign unev (op definition-variable) (reg exp))
(save unev)                   <EM>; save variable for later</EM>
(assign exp (op definition-value) (reg exp))
(save env)
(save continue)
(assign continue (label ev-definition-1))
(goto (label eval-dispatch))  <EM>; evaluate the definition value</EM>
ev-definition-1
(restore continue)
(restore env)
(restore unev)
(perform
(op define-variable!) (reg unev) (reg val) (reg env))
(assign val (const ok))
(goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
"ev_function_declaration",
      assign("comp", list(op("function_decl_to_constant_decl"), reg("comp"))),

"ev_declaration",
      assign("unev", list(op("declaration_symbol"),
                          reg("comp"))),
      save("unev"), // save declared name
      assign("comp", list(op("declaration_value_expression"),
                          reg("comp"))),
      save("env"),
      save("continue"),
      assign("continue", label("ev_declaration_assign")),
      go_to(label("eval_dispatch")), // evaluate declaration value
      
"ev_declaration_assign",
      restore("continue"),
      restore("env"),
      restore("unev"),
      perform(list(op("assign_symbol_value"),
                   reg("unev"), reg("val"), reg("env"))),
      assign("val", constant(undefined)),
      go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  
  <EXERCISE>
    <LABEL NAME="ex:derived-expressions"/>
    <INDEX>derived components in evaluator<SUBINDEX>adding to explicit-control evaluator</SUBINDEX></INDEX>
    <SPLIT>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme<SUBINDEX>derived expressions</SUBINDEX></INDEX>
	<INDEX>explicit-control evaluator for Scheme<SUBINDEX>special forms (additional)</SUBINDEX></INDEX>
	Extend the evaluator to handle derived expressions such as
	<SCHEMEINLINE>cond</SCHEMEINLINE>,
	<SCHEMEINLINE>let</SCHEMEINLINE>, and so on
	(section<SPACE/><REF NAME="sec:representing-expressions"/>).
	You may <QUOTE>cheat</QUOTE> and assume that the syntax
	transformers such as <SCHEMEINLINE>cond-&gt;if</SCHEMEINLINE> are available
	as machine operations.<FOOTNOTE>This isn<APOS/>t really cheating.  In an
	actual implementation built from scratch, we would use our explicit-control
	evaluator to interpret a Scheme program that performs source-level
	transformations
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>like cond-&gt;if</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE></JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE> in a syntax phase that runs before execution.</FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript<SUBINDEX>derived components</SUBINDEX></INDEX>
	<INDEX>explicit-control evaluator for JavaScript<SUBINDEX>syntactic forms (additional)</SUBINDEX></INDEX>
	Extend the evaluator to handle while 
	loops, by translating them to applications of a function
	<JAVASCRIPTINLINE>while_loop</JAVASCRIPTINLINE>, as shown in
	exercise<SPACE/><REF NAME="ex:while_loop"/>.
	You can then paste the declaration of the function
	<JAVASCRIPTINLINE>while_loop</JAVASCRIPTINLINE> in front of user programs.
	You may <QUOTE>cheat</QUOTE> and assume that the syntax transformer
	<JAVASCRIPTINLINE>while_to_application</JAVASCRIPTINLINE> is available
	as a machine operation.<FOOTNOTE>This isn<APOS/>t really cheating.  In an
	actual implementation built from scratch, we would use our explicit-control
	evaluator to interpret a JavaScript program that performs source-level
	transformations like
	<JAVASCRIPTINLINE>while_to_application</JAVASCRIPTINLINE>
	in a syntax phase that runs before execution.</FOOTNOTE> Refer to
	exercise<SPACE/><REF NAME="ex:while_loop"/> to discuss whether
	this approach works if return, break and continue statements are allowed
	inside the while loop. If not,
	how can you modify the explicit control evaluator to run programs 
	with while loops that include these statements?
      </JAVASCRIPT>
    </SPLIT>
  </EXERCISE>

  <SPLIT>
    <JAVASCRIPT>
      <EXERCISE>
        <LABEL NAME="ex:save_marker1"/>
        Implement the equivalent of
        <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE> by using <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> to
        store a special marker value on the stack<FOOTNOTE>If you implement save and restore using a dedicated
        stack per register, you will need to insert and remove the marker across all stacks.</FOOTNOTE>. Use a restoring loop for
        implicit and explicit returns that restores from the stack until it hits
        the marker. Note that this will require restoring a value to a 
        register other than the one it was saved from. This is necessary because the only
        way to pop from the stack is by restoring to a register. 
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>
  
  <EXERCISE>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>syntactic forms (additional)</SUBINDEX></INDEX>
    <SPLIT>
      <SCHEME>
	      Implement <SCHEMEINLINE>cond</SCHEMEINLINE> as a new basic special form
	      without reducing it to <SCHEMEINLINE>if</SCHEMEINLINE>. You will have to
	      construct a loop that tests the predicates of successive
	      <SCHEMEINLINE>cond</SCHEMEINLINE> clauses until you find one that is
	      true, and then use <SCHEMEINLINE>ev-sequence</SCHEMEINLINE> to evaluate
	      the actions of the clause.
      </SCHEME>
      <JAVASCRIPT>
        <LABEL NAME="ex:save_marker2"/>
        Implement <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE> by extending the evaluator
        with two new instructions, similar to <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> and <JAVASCRIPTINLINE>restore</JAVASCRIPTINLINE>, implemented by
        no-argument functions
        <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE>.
        You will have
        to add cases to the stack's dispatch function as well. Note
        that you do not need to actually insert a marker in the stack.
        Instead, you can add a local state variable to the stack to keep track
        of the position of the last
        <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> before a call to <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLIT>
      <LABEL NAME="ex:eceval-cond"/>
  </EXERCISE>

  <EXERCISE>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>normal-order evaluation</SUBINDEX></INDEX>
    <INDEX>normal-order evaluation<SUBINDEX><ORDER>explicit</ORDER>in explicit-control evaluator</SUBINDEX></INDEX>
    Modify the evaluator so that it uses normal-order evaluation,
    based on the lazy evaluator of
    section<SPACE/><REF NAME="sec:lazy-evaluation"/>.
  </EXERCISE>
</SUBSECTION>
