[{"id":"/sicpjs/3.4","tag":"TITLE","body":"3.4  Concurrency: Time Is of the Essence"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    We've seen the power of computational objects with local state as\n    tools for modeling.  Yet, as\n    section ","tag":"#text"},{"tag":"REF","body":"3.1.3","href":"/sicpjs/3.1.3"},{"body":"\n    warned, this power extracts a price: the loss of referential\n    transparency, giving rise to a thicket of questions about sameness and\n    change, and the need to abandon the substitution model of evaluation in\n    favor of the more intricate environment model.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The central issue lurking beneath the complexity of state, sameness,\n    and change is that by introducing assignment we are forced to admit\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"time","tag":"#text"}]},{"body":" into our computational models.  Before we introduced\n    assignment, all our programs were timeless, in the sense that any\n    expression that has a value always has the same value.  In contrast,\n    recall the example of modeling withdrawals from a bank account\n    and returning the resulting balance,\n    introduced at the beginning of\n    section ","tag":"#text"},{"tag":"REF","body":"3.1.1","href":"/sicpjs/3.1.1"},{"body":":\n\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":12,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQBYBQWA2BTAF1ACMBDXMgOwGN9QBeUARgAZWBuHAMwFdbCASwD2VUAHdBhABYATAE5lxACjIBbYf0IBKUAG8soI6EHdQy8pVr0AfE3WaqO-YeNvL1Oo1IVP9ALSgDlpcbm7yRLzyYh7WocYAvqD4uADO9AZhxhGEUWIARJBUqbzc3II0gvhOoHxUsqn58UYJWK1YkjIKSsoATACs2hxAA","body":"withdraw(25); ","output":"75"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":14,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQBYBQWA2BTAF1ACMBDXMgOwGN9QBeUARgAZWBuHAMwFdbCASwD2VUAHdBhABYATAE5lxACjIBbYf0IBKUAG8soI6EHdQy8pVr0AfE3WaqO-YeNvL1Oo1IVP9ALSgDlpcbm7yRLzyYh7WocYAvqD4uADO9AZhxhGEUWIARJBUqbzc3II0gvhOoHxUsqn58UYJWK1YkjIKSsoATACs2lwdUnKKKgNDQA","body":"withdraw(25); ","output":"50"},{"body":"\n    Here successive evaluations of the same expression yield different\n    values.  This behavior arises from the fact that the execution of\n    assignments (in this case, assignments to the variable\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"balance"},{"body":") delineates ","tag":"#text"},{"tag":"EM","child":[{"body":"moments in time","tag":"#text"}]},{"body":"\n    when values change.  The result of evaluating an expression depends not\n    only on the expression itself, but also on whether the evaluation occurs\n    before or after these moments.  Building models in terms of computational\n    objects with local state forces us to confront time as an essential concept\n    in programming.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    We can go further in structuring computational models to match our\n    perception of the physical world.  Objects in the world do not change\n    one at a time in sequence.  Rather we perceive them as acting\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"concurrently","tag":"#text"}]},{"body":"—all at once.  So it is often natural to\n    model systems as collections of \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"threads","tag":"#text"}]},{"body":" (sequences of computational steps)\n       \n    that execute concurrently.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/3.4#footnote-1"},{"body":"\n    Just as we can make our programs modular by\n    organizing models in terms of objects with separate local state, it is\n    often appropriate to divide computational models into parts that evolve\n    separately and concurrently.  Even if the programs are to be executed on\n    a sequential computer, the practice of writing programs as if they were\n    to be executed concurrently forces the programmer to avoid inessential\n    timing constraints and thus makes programs more modular.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    In addition to making programs more modular, concurrent computation\n    can provide a speed advantage over sequential computation.  Sequential\n    computers execute only one operation at a time, so the amount of time\n    it takes to perform a task is proportional to the total number of\n    operations performed.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/3.4#footnote-2"},{"body":"\n    However, if it is possible to decompose a problem into pieces that are\n    relatively independent and need to communicate only rarely, it may be\n    possible to allocate pieces to separate computing processors,\n    producing a speed advantage proportional to the number of processors\n    available.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Unfortunately, the complexities introduced by assignment become even\n    more problematic in the presence of concurrency.  The fact of\n    concurrent execution, either because the world operates in parallel or\n    because our computers do, entails additional complexity in our\n    understanding of time.\n  ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/3.4#footnote-link-1","child":[{"body":"\n    Such sequential threads are called \"","tag":"#text"},{"body":"processes","tag":"#text"},{"body":"\"\n    throughout the book, but in this section we use the term\n    \"","tag":"#text"},{"body":"thread","tag":"#text"},{"body":"\" to emphasize their access to shared\n    memory.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/3.4#footnote-link-2","child":[{"body":"Most real processors actually execute a few\n    operations at a time, following a strategy called \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"pipelining","tag":"#text"}]},{"body":".  Although this technique greatly improves the\n    effective\n    utilization of the hardware, it is used only to speed up the execution\n    of a sequential instruction stream, while retaining the behavior of\n    the sequential program.","tag":"#text"}]}]