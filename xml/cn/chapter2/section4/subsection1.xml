<SUBSECTION>
   <SHORT_PAGE LINES="1"></SHORT_PAGE> 
   <NAME>
    复数的表示
  </NAME> 

  <LABEL NAME="sec:representations-complex-numbers"></LABEL>
   <INDEX>复数<SUBINDEX>直角坐标 vs. 极坐标形式<SPACE></SPACE></SUBINDEX><OPEN></OPEN></INDEX> 

   <TEXT>
    我们将开发一个系统，用于对复数
    执行算术运算，作为一个简单但不现实的程序示例，该程序使用通用运算。我们首先讨论复数作为有序对的两种可能表示形式：直角坐标（实部和虚部）和极坐标（模长和角度）。<FOOTNOTE>在实际计算系统中，由于直角坐标和极坐标之间转换的舍入误差，直角坐标形式大多数时候比极坐标形式更可取。这就是为什么复数示例是不现实的。然而，它为使用通用运算设计系统提供了清楚的说明，并为本章后面开发的更重要的系统提供了良好的介绍。</FOOTNOTE> Section<SPACE></SPACE><REF NAME="sec:manifest-types"></REF>
    将展示如何通过使用类型标签和通用运算，使两种表示形式可以在一个系统中共存。
  </TEXT> 
   <TEXT>
    类似有理数，复数自然表示为有序对。复数集可视为一个具有两个正交轴的二维空间，一个是<QUOTE>实数</QUOTE>轴，另一个是<QUOTE>虚数</QUOTE>轴。(见
    figure<SPACE></SPACE><REF NAME="fig:complex-plane"></REF>。）从这一视角来看，复数$z=x+iy$（其中
    $i^{2} =-1$）可以看作平面中一个点，其实部坐标为$x$，虚部坐标为$y$。在这种表示中，复数的加法归结为坐标的加法：
    
      \[
        \begin{array}{lll}
      \mbox{实部}(z_{1}+z_{2}) &amp; = &amp; 
         \mbox{实部}(z_{1})+\mbox{实部}(z_{2}) \\[1ex]
      \mbox{虚部}(z_{1} +z_{2}) &amp; = &amp; 
         \mbox{虚部}(z_1)+\mbox{虚部}(z_2)
        \end{array}
      \]
    
  </TEXT> 
   <TEXT>
    当乘复数时，更自然的是考虑将复数表示为极坐标形式，作为幅度和角度（$r$ 和 $A$，参见
    figure<SPACE></SPACE><REF NAME="fig:complex-plane"></REF>）。两个复数的乘积是一个通过一个复数的长度来拉伸另一个复数并通过另一个的角度旋转得到的向量：
    
      \[
        \begin{array}{lll}
      \mbox{模长}(z_{1}\cdot z_{2}) &amp; = &amp; 
      \mbox{模长}(z_{1})\cdot\mbox{模长}(z_{2})\\[1ex]
      \mbox{角度}(z_{1}\cdot z_{2}) &amp; = &amp; 
      \mbox{角度}(z_{1})+\mbox{角度}(z_{2})
        \end{array}
      \]
    
  </TEXT> 
   <TEXT>
    因此，复数有两种不同的表示形式，适用于不同的运算。然而，从使用复数写程序的人的角度来看，数据抽象原则建议无论计算机使用哪种表示形式，所有用于操作复数的运算都应可以使用。例如，能够找到用直角坐标指定的复数的模长通常是有用的。同样，能够确定用极坐标指定的复数的实部通常是有用的。
    <FIGURE>
      <FIGURE SPLIT_SCALE="0.5" WEB_SCALE="0.6" SCALE="0.59" SRC="img_original/ch2-Z-G-59.svg"></FIGURE>
      <CAPTION>复数作为平面中的点。</CAPTION>
      
    </FIGURE>
  </TEXT> 
   <SHORT_PAGE LINES="2"></SHORT_PAGE> 
  <TEXT>
    为了设计这样的系统，我们可以遵循与在<SPAN STYLE="white-space: pre;"> </SPAN><INDEX>有理数包</INDEX>
    中设计有理数包相同的数据抽象策略。假设复数操作是通过四个选择器实现的：
    <SPLITINLINE>
      实部,
      <JAVASCRIPT><JAVASCRIPTINLINE>实部</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      虚部,
      <JAVASCRIPT><JAVASCRIPTINLINE>虚部</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      模长,
      <JAVASCRIPT><JAVASCRIPTINLINE>模长</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    和
<SCHEMEINLINE>angle</SCHEMEINLINE> .  Also assume that we have two
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    for constructing complex numbers:
    <SPLITINLINE>
      make-from-real-imag
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    返回具有指定实部和虚部的复数，以及
    <SPLITINLINE>
      
	make-from-mag-ang
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>make_from_mag_ang</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    返回具有指定幅度和角度的复数。这些
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    具有这样一个属性，对于任何复数
     <SCHEMEINLINE>z</SCHEMEINLINE> , both
     <SNIPPET EVAL="no">
      <SCHEME>
(make-from-real-imag (real-part z) (imag-part z))
      </SCHEME>
      <JAVASCRIPT>
make_from_real_imag(real_part(z), imag_part(z));
      </JAVASCRIPT>
    </SNIPPET> 
    和
     <SNIPPET EVAL="no">
      <SCHEME>
(make-from-mag-ang (magnitude z) (angle z))
      </SCHEME>
      <JAVASCRIPT>
make_from_mag_ang(magnitude(z), angle(z));
      </JAVASCRIPT>
    </SNIPPET> 
    生成等于的复数
<SCHEMEINLINE>z</SCHEMEINLINE>.
  </TEXT>
  <LONG_PAGE LINES="2"></LONG_PAGE>
  <TEXT> 
    使用这些构造函数和选择器，我们可以像在节<SPAN STYLE="white-space: pre;"> </SPAN><REF NAME="sec:rationals"></REF>中为有理数所做的那样，使用构造函数和选择器指定的<QUOTE>抽象数据</QUOTE>来实现复数的算术运算。如上面的公式所示，我们可以在实部和虚部的基础上对复数进行加减法运算，而在模长和角度的基础上进行复数的乘除法运算：
     <SNIPPET EVAL="no">
      <INDEX><DECLARATION>add_complex</DECLARATION></INDEX> 
      <INDEX><DECLARATION>sub_complex</DECLARATION></INDEX> 
      <INDEX><DECLARATION>mul_complex</DECLARATION></INDEX> 
      <INDEX><DECLARATION>div_complex</DECLARATION></INDEX> 
      <NAME>complex_number_calculation</NAME>
      <SCHEME>
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))

(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))

(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))

(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
      </SCHEME>
      <JAVASCRIPT>
function add_complex(z1, z2) {
    return make_from_real_imag(real_part(z1) + real_part(z2),
                               imag_part(z1) + imag_part(z2));
}
function sub_complex(z1, z2) {
    return make_from_real_imag(real_part(z1) - real_part(z2),
                               imag_part(z1) - imag_part(z2));
}
function mul_complex(z1, z2) {
    return make_from_mag_ang(magnitude(z1) * magnitude(z2),
                             angle(z1) + angle(z2));
}
function div_complex(z1, z2) {
    return make_from_mag_ang(magnitude(z1) / magnitude(z2),
                             angle(z1) - angle(z2));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
   <TEXT>
    为了完成复数包，我们必须选择一种表示方式，并且必须用原语数和原语列表结构实现构造函数和选择器。有两种明显的方法可以做到这一点：我们可以将复数以<QUOTE>直角坐标形式</QUOTE>表示为一个对（实部，虚部），或者以<QUOTE>极坐标形式</QUOTE>表示为一个对（模长，角度）。我们该选择哪一种？

  </TEXT> 
  <TEXT> 
    为了使不同的选择具体化，假设有两个程序员，Ben Bitdiddle 和 Alyssa P. Hacker，他们正在独立设计复数系统的表示。
    Ben 选择用<INDEX>复数<SUBINDEX>直角坐标表示</SUBINDEX></INDEX> 
    将复数表示为直角坐标形式。选择这种方式后，选择复数的实部和虚部变得很简单，构造具有给定实部和虚部的复数也是如此。
    为了找到模长和角度，或者构造一个具有给定模长和角度的复数，他使用三角关系
<LATEX>
      \[
      \begin{array}{lllllll}
      x &amp; = &amp; r\ \cos A &amp; \quad \quad \quad &amp; r &amp; = &amp; \sqrt{x^2 +y^2} \\
      y &amp; = &amp; r\ \sin A &amp;             &amp; A &amp;= &amp; \arctan (y,x)
      \end{array}
      \]
    </LATEX> 
    将实部和虚部关联起来的 (
<LATEXINLINE>$x$</LATEXINLINE>,
    <LATEXINLINE>$y$</LATEXINLINE> ) 与模长和角度
     <LATEXINLINE>$(r, A)$</LATEXINLINE>. <FOOTNOTE>反正切函数
    在这里
    <SPLITINLINE>
      
	通过 Scheme<APOS></APOS>s
	<INDEX>反正切</INDEX>
	<INDEX><USE>math_atan2</USE> (原语函数)</INDEX>
	<INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>math_atan2</USE><ECMA>Math.atan2</ECMA></SUBINDEX></INDEX>
	atan 过程计算，
      
      <JAVASCRIPT>
	通过 JavaScript<APOS></APOS>s
	<INDEX>反正切</INDEX>
	<INDEX><USE>math_atan2</USE> (原语函数)</INDEX>
	<INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>math_atan2</USE><ECMA>Math.atan2</ECMA></SUBINDEX></INDEX>
	<JAVASCRIPTINLINE>math_atan2</JAVASCRIPTINLINE> 函数计算，
      </JAVASCRIPT>
    </SPLITINLINE>
    被定义为接受两个参数
    $y$<SPACE></SPACE>和 $x$
    并返回其正切为 $y/x$ 的角度。
    参数的符号决定了角度的象限。</FOOTNOTE>
    因此，Ben<APOS></APOS>的表示方式是通过以下选择器
    和构造函数给出的：
<SNIPPET>
      <INDEX><DECLARATION>real_part</DECLARATION><SUBINDEX>rectangular representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>imag_part</DECLARATION><SUBINDEX>rectangular representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>magnitude</DECLARATION><SUBINDEX>rectangular representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>angle</DECLARATION><SUBINDEX>rectangular representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>make_from_real_imag</DECLARATION><SUBINDEX>rectangular representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>make_from_mag_ang</DECLARATION><SUBINDEX>rectangular representation</SUBINDEX></INDEX>
      <NAME>make_complex_number1</NAME>
      <REQUIRES>complex_number_calculation</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>make_complex_number_example</EXAMPLE>
      <EXPECTED>-3</EXPECTED>
      <SCHEME>
(define (real-part z) (car z))

(define (imag-part z) (cdr z))

(define (magnitude z)
  (sqrt (+ (square (real-part z)) (square (imag-part z)))))

(define (angle z)
  (atan (imag-part z) (real-part z)))

(define (make-from-real-imag x y) (cons x y))

(define (make-from-mag-ang r a) 
  (cons (* r (cos a)) (* r (sin a))))
      </SCHEME>
      <JAVASCRIPT>
function real_part(z) { return head(z); }
<SHORT_SPACE></SHORT_SPACE>
function imag_part(z) { return tail(z); }
<SHORT_SPACE></SHORT_SPACE>
function magnitude(z) {
    return math_sqrt(square(real_part(z)) + square(imag_part(z)));
}
function angle(z) {
    return math_atan2(imag_part(z), real_part(z));
}
function make_from_real_imag(x, y) { return pair(x, y); }

function make_from_mag_ang(r, a) {
    return pair(r * math_cos(a), r * math_sin(a));
}
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET HIDE="yes">
      <NAME>make_complex_number_example</NAME>
      <JAVASCRIPT>
const my_co_num_1 = make_from_real_imag(2.5, -0.5);
const my_co_num_2 = make_from_real_imag(2.5, -0.5);

const result = add_complex(my_co_num_1,
                           mul_complex(my_co_num_2,
                                       my_co_num_2));

imag_part(result);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <LONG_PAGE LINES="2"></LONG_PAGE>
  <TEXT> 
    相比之下，Alyssa 选择将复数表示为 
    <INDEX>复数<SUBINDEX>极坐标表示</SUBINDEX></INDEX> 极坐标形式。
    <SHRINK_PARAGRAPH LINES="1"></SHRINK_PARAGRAPH>
    对她来说，选择模长和角度是直接的，但她必须使用 
    <INDEX>三角关系</INDEX> 三角关系来获取实部和虚部。
    Alyssa<APOS></APOS>的表示是：
<SNIPPET>
      <INDEX><DECLARATION>real_part</DECLARATION><SUBINDEX>polar representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>imag_part</DECLARATION><SUBINDEX>polar representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>magnitude</DECLARATION><SUBINDEX>polar representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>angle</DECLARATION><SUBINDEX>polar representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>make_from_real_imag</DECLARATION><SUBINDEX>polar representation</SUBINDEX></INDEX>
      <INDEX><DECLARATION>make_from_mag_ang</DECLARATION><SUBINDEX>polar representation</SUBINDEX></INDEX>
      <NAME>make_complex_number2</NAME>
      <REQUIRES>complex_number_calculation</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>make_complex_number_example</EXAMPLE>
      <EXPECTED>-3</EXPECTED>
      <SCHEME>
(define (real-part z)
  (* (magnitude z) (cos (angle z))))

(define (imag-part z)
  (* (magnitude z) (sin (angle z))))

(define (magnitude z) (car z))

(define (angle z) (cdr z))

(define (make-from-real-imag x y) 
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))

(define (make-from-mag-ang r a) (cons r a))
      </SCHEME>
      <JAVASCRIPT>
function real_part(z) {
    return magnitude(z) * math_cos(angle(z));
}
function imag_part(z) {
    return magnitude(z) * math_sin(angle(z));
}
function magnitude(z) { return head(z); }
<SHORT_SPACE></SHORT_SPACE>
function angle(z) { return tail(z); }
<SHORT_SPACE></SHORT_SPACE>
function make_from_real_imag(x, y) {
    return pair(math_sqrt(square(x) + square(y)),
                math_atan2(y, x));
}
function make_from_mag_ang(r, a) { return pair(r, a); }
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
   <TEXT>
    数据抽象的规范确保相同的 
    <SPLITINLINE>
      
	add-complex,
      
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>add_@complex</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      
	sub-complex,
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>sub_complex</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      
	mul-complex,
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>mul_complex</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      
	div-complex
      
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>div_complex</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    实现能与 Ben 以及 Alyssa 的表示方式一起工作。
  </TEXT> 
</SUBSECTION>
