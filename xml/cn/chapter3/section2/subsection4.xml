<SUBSECTION> 
  <LONG_PAGE LINES="2"></LONG_PAGE>
   <NAME>
    内部
    <SPLITINLINE>
      定义
      <JAVASCRIPT>声明</JAVASCRIPT>
    </SPLITINLINE>
  </NAME> 

  <LABEL NAME="sec:env-internal-def"></LABEL>
   <INDEX>块结构<SUBINDEX><ORDER>环境</ORDER>在环境模型中<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>求值的环境模型<SUBINDEX>内部声明<OPEN></OPEN></SUBINDEX></INDEX> 
   <INDEX>内部声明<SUBINDEX><ORDER>环境</ORDER>在环境模型中<OPEN></OPEN></SUBINDEX></INDEX> 

   <SPLIT>
    <JAVASCRIPT>
      <TEXT>
	在本节中，我们处理包含声明的函数体或其他块（例如条件语句的分支）的求值。每个块为块中声明的名称开启一个新的作用域。为了在给定的环境中求值一个块，我们通过一个新的框架扩展该环境，该框架包含在块体中直接声明的所有名称（即，不在嵌套块内），然后在新构建的环境中求值该块体。
      </TEXT>
    </JAVASCRIPT>
  </SPLIT> 
  <TEXT> 
    第 <SPACE></SPACE><REF NAME="sec:black-box"></REF> 节介绍了
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    可以有内部
    <SPLITINLINE>
      
	定义
      
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    ，从而形成一个块结构，如在
    <INDEX><USE>sqrt</USE><SUBINDEX><ORDER>环境</ORDER>在环境模型中<OPEN></OPEN></SUBINDEX></INDEX>
    计算平方根的下面的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ：
<SNIPPET EVAL="yes">
      <NAME>another_sqrt</NAME>
      <REQUIRES>abs_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>average_definition</REQUIRES>
      <EXAMPLE>sqrt_example7</EXAMPLE>
      <EXPECTED>2.2360688956433634</EXPECTED>
      <SCHEME>
(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
      </SCHEME>
      <JAVASCRIPT>
function sqrt(x) {
    function is_good_enough(guess) {
        return abs(square(guess) - x) &lt; 0.001;
    }
    function improve(guess) {
        return average(guess, x / guess);
    }
    function sqrt_iter(guess){
        return is_good_enough(guess)
               ? guess
               : sqrt_iter(improve(guess));
    }
    return sqrt_iter(1);
}
      </JAVASCRIPT>
    </SNIPPET> 
    现在我们可以使用环境模型来理解这些内部
    <SPLITINLINE>
      
	定义
      
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    是如何按预期行为的。
    <SPLITINLINE>
      
    图 <SPACE></SPACE><REF NAME="fig:sqrt-internal_scheme"></REF>
      
      <JAVASCRIPT>
    图 <SPACE></SPACE><REF NAME="fig:sqrt-internal"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    显示在求值表达式
    <SPLITINLINE>
      (sqrt 2)
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt(2)</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    时，内部
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      good-enough?
      <JAVASCRIPT><JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    首次被调用的时刻。
<SCHEMEINLINE>guess</SCHEMEINLINE>  等于<SPACE></SPACE>1.
    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch3-Z-G-12.svg"></FIGURE>
          <CAPTION>
	    sqrt 过程含有内部定义。
	  </CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SRC="img_javascript/ch3-Z-G-12.svg"></FIGURE>
          <CAPTION>The
	    sqrt 函数含有内部声明。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
   </TEXT>

  <TEXT> 
    观察环境的结构。
    <SPLITINLINE>
      
	Sqrt 是全局环境中的一个符号，被绑定为
      
      <JAVASCRIPT>
      名称
      sqrt 已在程序环境中绑定
      </JAVASCRIPT>
    </SPLITINLINE>
    到一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    对象，其关联的环境是
    <SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境。当 
<SCHEMEINLINE>sqrt</SCHEMEINLINE>  被调用时，一个新的环境 E1 被形成，隶属于
    <SPLITINLINE>
      全局
      <JAVASCRIPT>程序</JAVASCRIPT>
    </SPLITINLINE>
    环境，其中参数  <SCHEMEINLINE>x</SCHEMEINLINE>  被绑定到<SPACE></SPACE>2。身体的  <SCHEMEINLINE>sqrt</SCHEMEINLINE>  然后在<SPACE></SPACE>E1 中求值。
    <SPLIT>
      
	由于sqrt体中的第一个表达式是
      
      <JAVASCRIPT>
	该段是一个包含局部函数声明的块，因此 E1 被扩展为一个新的帧用于这些声明，结果形成了一个新环境 E2。块体随后在 E2 中求值。因为体中的第一条语句是
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET EVAL="no">
      <REQUIRES>abs_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(define (good-enough? guess)
  (&lt; (abs (- (square guess) x)) 0.001))
      </SCHEME>
      <JAVASCRIPT>
function is_good_enough(guess) {
    return abs(square(guess) - x) &lt; 0.001;
}
      </JAVASCRIPT>
    </SNIPPET>
     <SPLIT>
      
	求值这个表达式定义了在环境<SPACE></SPACE>E1 中的过程
	good-enough?。
      
      <JAVASCRIPT>
	求值这个声明在环境<SPACE></SPACE>E2 中创建了函数
	<JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLIT>
    <SPLIT>
      
	更精确地说，符号 
	good-enough? 被添加到 E1 的第一个帧，
	与一个过程对象绑定，其关联的环境是 E1。
      
      <JAVASCRIPT>
	更精确地说，
	名称  <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
	在 E2 的第一个帧中被绑定到一个函数
	对象，其关联的环境是 E2。
      </JAVASCRIPT>
    </SPLIT>
    类似地，
     <SCHEMEINLINE>improve</SCHEMEINLINE> and 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    were defined as
    <SPLITINLINE>
      <SCHEME>procedures in E1.</SCHEME>
      <JAVASCRIPT>functions in E2.</JAVASCRIPT>
    </SPLITINLINE>
    For conciseness,
    <SPLITINLINE>
      <SCHEME>
	figure<SPACE></SPACE><REF NAME="fig:sqrt-internal_scheme"></REF>
      </SCHEME>
      <JAVASCRIPT>
	figure<SPACE></SPACE><REF NAME="fig:sqrt-internal"></REF>
      </JAVASCRIPT>
    </SPLITINLINE>
    shows only the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    object for 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>good-enough?</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
  <!-- Error occurred while translating this section --></TEXT>

  <TEXT> 
    在本地
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    被定义之后，表达式
    <SPLITINLINE>
      (sqrt-iter 1.0)
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_@iter(1)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    仍在环境
    <SPLITINLINE>
      E1
      <JAVASCRIPT>E2</JAVASCRIPT>
    </SPLITINLINE>
    中求值。因此在
    <SPLITINLINE>
      E1 中绑定到的过程对象
      <JAVASCRIPT>E2 中绑定到的函数对象</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      sqrt-iter
      以 1 作为参数被调用。 这创建了一个新的环境 E2，其中
      
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_@iter</JAVASCRIPTINLINE>
      以 1 作为参数被调用。这创建了一个新的环境 E3，其中
      </JAVASCRIPT>
    </SPLITINLINE>
     <SCHEMEINLINE>guess</SCHEMEINLINE> ，<SPLITINLINE>sqrt-iter,<JAVASCRIPT><JAVASCRIPTINLINE>sqrt_@iter</JAVASCRIPTINLINE>,</JAVASCRIPT></SPLITINLINE>的参数被绑定到 1。<SPLITINLINE>sqrt-iter<JAVASCRIPT>函数<JAVASCRIPTINLINE>sqrt_@iter</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>反过来调用了<SPLITINLINE>good-enough?<JAVASCRIPT><JAVASCRIPTINLINE>is_@good_@enough</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>，并使用这个值。 <SCHEMEINLINE>guess</SCHEMEINLINE>
     <SPLITINLINE>
      
	(来自 E2) 作为 good-enough? 的参数。
      
      <JAVASCRIPT>
	(来自 E3) 作为 <JAVASCRIPTINLINE>is_@good_@enough</JAVASCRIPTINLINE> 的参数。
      </JAVASCRIPT>
    </SPLITINLINE>
    这设置了另一个环境，
    <SPLITINLINE>
      
	E3，其中guess (good-enough? 的参数)
      
      <JAVASCRIPT>
	E4，其中guess (<JAVASCRIPTINLINE>is_@good_@enough</JAVASCRIPTINLINE> 的参数)
      </JAVASCRIPT>
    </SPLITINLINE>
    被绑定到 1。虽然
    <SPLITINLINE>
      sqrt-iter
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_@iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      good-enough?
      <JAVASCRIPT><JAVASCRIPTINLINE>is_@good_@enough</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    都有一个名称为
<SCHEMEINLINE>guess</SCHEMEINLINE> ，这些是位于不同帧中的两个独立局部变量。
    <SPLIT>
      
	此外，E2 和 E3 都以 E1 作为它们的外层环境，因为
	sqrt-iter 和
	good-enough? 过程
	都以 E1 作为它们的环境部分。
      
      <JAVASCRIPT>
	此外，E3 和 E4 都以 E2 作为它们的外层环境，因为
	<JAVASCRIPT><JAVASCRIPTINLINE>sqrt_@iter</JAVASCRIPTINLINE></JAVASCRIPT>
	和
	<JAVASCRIPTINLINE>is_@good_@enough</JAVASCRIPTINLINE> 函数
	都以 E2 作为它们的环境部分。
      </JAVASCRIPT>
    </SPLIT>
    这一结果的一个后果是，
    <SPLITINLINE>
      
	符号
      
      <JAVASCRIPT>
	名称
      </JAVASCRIPT>
    </SPLITINLINE>
     <SCHEMEINLINE>x</SCHEMEINLINE> ，出现在
    <SPLITINLINE>
      good-enough?
      <JAVASCRIPT><JAVASCRIPTINLINE>is_@good_@enough</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    函数体中的符号将引用
<SCHEMEINLINE>x</SCHEMEINLINE> ，出现在 E1 中，即值为 <SCHEMEINLINE>x</SCHEMEINLINE> ，其原始的  <SCHEMEINLINE>sqrt</SCHEMEINLINE>
     <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    被调用。
    <INDEX><USE>sqrt</USE><SUBINDEX><ORDER>环境</ORDER>在环境模型中<CLOSE></CLOSE></SUBINDEX></INDEX>
   </TEXT>

   <TEXT>
    因此，环境模型解释了使得本地
    <SPLITINLINE>
      过程定义
      <JAVASCRIPT>函数声明</JAVASCRIPT>
    </SPLITINLINE>
    成为模块化程序的一种有用技术的两个关键属性：
    <UL>
      <LI>
	本地
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	的名称不会干扰
	外部于封闭
	<SPLITINLINE>
	  过程,
	  <JAVASCRIPT>函数,</JAVASCRIPT>
	</SPLITINLINE>
	的名称，因为本地
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	的名称将被绑定在
	<SPLITINLINE>
	  过程运行时创建的帧中,
	  <JAVASCRIPT>块求值时创建的帧中,</JAVASCRIPT>
	</SPLITINLINE>
	而不是在
	<SPLITINLINE>
	  全局
	  <JAVASCRIPT>程序</JAVASCRIPT>
	</SPLITINLINE>
	环境中。
      </LI>
      <LI>
	本地
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	可以访问封闭
	<SPLITINLINE>
	  过程,
	  <JAVASCRIPT>函数,</JAVASCRIPT>
	</SPLITINLINE>
	的参数，只需使用参数名称作为自由
	<SPLITINLINE>
	  变量。
	  <JAVASCRIPT>名称。</JAVASCRIPT>
	</SPLITINLINE>
	这是因为本地
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	的体是在一个从属于封闭
	<SPLITINLINE>
	  过程
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
	的求值环境中进行求值的。
      </LI>
    </UL>
  </TEXT> 
  <EXERCISE> 
    在第<SPACE></SPACE><REF NAME="sec:env-local-state"></REF>节中，我们看到环境模型如何描述具有局部状态的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的行为。现在我们了解了内部
    <SPLITINLINE>
      
	定义
      
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    的工作原理。
    <INDEX>求值的环境模型<SUBINDEX>消息传递</SUBINDEX></INDEX>
    <INDEX>消息传递<SUBINDEX>环境模型与</SUBINDEX></INDEX>
    一个典型的消息传递
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    包含这两个方面。考虑第<SPACE></SPACE><REF NAME="sec:local-state-variables"></REF>节中的
    <INDEX>银行账户</INDEX>
    银行账户
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ：
    <SHORT_PAGE LINES="1"></SHORT_PAGE>
<SNIPPET EVAL="yes">
      <INDEX><USE>make_account</USE><SUBINDEX><ORDER>environment</ORDER>in environment model</SUBINDEX><FRAGILE></FRAGILE></INDEX>
      <NAME>another_make_account</NAME>
      <EXAMPLE>another_make_account_example</EXAMPLE>
      <EXPECTED>30</EXPECTED>
      <SCHEME>
(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m &apos;withdraw) withdraw)
          ((eq? m &apos;deposit) deposit)
          (else (error &quot;Unknown request - - MAKE-ACCOUNT&quot;
                       m))))
  dispatch)
      </SCHEME>
      <JAVASCRIPT>
function make_account(balance) {
    function withdraw(amount) {
        if (balance &gt;= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return &quot;Insufficient funds&quot;;
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;  
    }
    function dispatch(m) {
        return m === &quot;withdraw&quot;
               ? withdraw
               : m === &quot;deposit&quot;
               ? deposit
               : error(m, &quot;Unknown request: make_account&quot;);
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET> 
    显示由一系列互动生成的环境结构
<SNIPPET EVAL="no">
      <NAME>another_make_account_example</NAME>
      <SCHEME>
            (define acc (make-account 50))
      </SCHEME>
      <JAVASCRIPT>
const acc = make_account(50);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
const acc = make_account(50);
acc(&quot;withdraw&quot;)(20);
      </JAVASCRIPT_TEST>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <NAME>another_make_account_example_2</NAME>
      <SCHEME>
            ((acc &apos;deposit) 40)
      </SCHEME>
      <SCHEMEOUTPUT>
	90
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
acc(&quot;deposit&quot;)(40);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
90
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <NAME>another_make_account_example_3</NAME>
      <SCHEME>
            ((acc &apos;withdraw) 60)
      </SCHEME>
      <SCHEMEOUTPUT>
	30
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
acc(&quot;withdraw&quot;)(60);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
30
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    局部状态在哪里  
<SCHEMEINLINE>acc</SCHEMEINLINE> 保留？假设我们定义了另一个账户 <SNIPPET EVAL="no"> 
      <SCHEME>
            (define acc2 (make-account 100))
      </SCHEME>
      <JAVASCRIPT>
const acc2 = make_account(100);
      </JAVASCRIPT>
    </SNIPPET> 
    两个账户的局部状态如何保持独立？环境结构中哪些部分是共享的？ 
<SCHEMEINLINE>acc</SCHEMEINLINE> 和 <SCHEMEINLINE>acc2</SCHEMEINLINE> ? <LABEL NAME="ex:two-accounts"></LABEL>
  </EXERCISE>

   <SUBHEADING><NAME>更多关于块</NAME></SUBHEADING> 

   <TEXT>
    如我们所见，在
    <JAVASCRIPTINLINE>sqrt</JAVASCRIPTINLINE> 中声明的名称的作用域是整个
    <JAVASCRIPTINLINE>sqrt</JAVASCRIPTINLINE> 的主体。这解释了为什么
    <INDEX>相互递归</INDEX>
    <INDEX>递归<SUBINDEX>相互</SUBINDEX></INDEX>
    <EM>相互递归</EM>能够工作，如这种（相当浪费的）检查非负整数是否为偶数的方法。
    
      <NAME>f_is_even_is_odd</NAME>
      <JAVASCRIPT>
function f(x) {
    function is_even(n) {
        return n === 0
               ? true
               : is_odd(n - 1);
    }
    function is_odd(n) {
        return n === 0
               ? false
               : is_even(n - 1);
    }
    return is_even(x);
}
      </JAVASCRIPT>
    
    当
    <JAVASCRIPTINLINE>is_even</JAVASCRIPTINLINE> 在调用
    <JAVASCRIPTINLINE>f</JAVASCRIPTINLINE> 时被调用，环境图看起来像
    <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE> 被调用时图<SPACE></SPACE><REF NAME="fig:sqrt-internal"></REF>中的那样。函数
    <JAVASCRIPTINLINE>is_even</JAVASCRIPTINLINE> 和
    <JAVASCRIPTINLINE>is_odd</JAVASCRIPTINLINE> 在 E2 中被绑定到指向 E2 的函数对象作为评估这些函数调用的环境。因此
    <JAVASCRIPTINLINE>is_odd</JAVASCRIPTINLINE> 在
    <JAVASCRIPTINLINE>is_even</JAVASCRIPTINLINE> 的体内指的是正确的函数。虽然
    <JAVASCRIPTINLINE>is_odd</JAVASCRIPTINLINE>
    是在
    <JAVASCRIPTINLINE>is_even</JAVASCRIPTINLINE> 之后定义的，
    这与
    <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE> 的体内的名称
    <JAVASCRIPTINLINE>improve</JAVASCRIPTINLINE>
    和名字
    <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>
    本身指的是正确的函数没有区别。
  </TEXT> 
   <TEXT>
    有了一种处理块内声明的方法，我们可以
    重新审视顶层的名称声明。在第<SPACE></SPACE><REF NAME="sec:env-model-rules"></REF>节中，我们看到
    顶层声明的名称被添加到程序
    帧中。一个更好的解释是整个程序被放置在一个
    隐含块中，该块在全局环境中求值。
    上述块的处理方式然后处理了顶层：
    全局环境通过一个包含所有在隐含块中声明的名称绑定的帧来扩展。该帧是
    程序帧，产生的
    环境是
    <INDEX>程序环境</INDEX>
    程序环境。
  </TEXT> 
   <TEXT>
    我们说过，一个块<APOS></APOS>的主体是在包含块体内直接声明的所有名称的环境中求值的。
    在进入块时，局部声明的名称被放入环境中，但没有关联的值。在块主体求值期间对其声明的求值，然后将表达式右侧的求值结果赋值给该名称，就像声明是一个赋值一样。由于名称添加到环境中与声明的求值是分开的，并且整个块都在名称的作用域中，一个错误的程序可能会尝试
    <INDEX>声明<SUBINDEX>在使用名称之前</SUBINDEX></INDEX>
    在其声明求值之前访问名称的值；
    对未赋值名称的求值会引发错误。<FOOTNOTE>
    
    这解释了为什么在第 1 章中的脚注<SPACE></SPACE><REF NAME="foot:tdz"></REF>中程序会出现问题。
    从为名称创建绑定到对名称的声明进行求值之间的时间称为
    <INDEX>时间死区（TDZ）</INDEX>
    <INDEX>TDZ（时间死区）</INDEX>
    <EM>时间死区</EM>（TDZ）。</FOOTNOTE>
  </TEXT> 
   <INDEX>求值的环境模型<CLOSE></CLOSE></INDEX> 
   <INDEX>块结构<SUBINDEX><ORDER>环境</ORDER>在环境模型中<CLOSE></CLOSE></SUBINDEX></INDEX> 
   <INDEX>求值的环境模型<SUBINDEX>内部声明<CLOSE></CLOSE></SUBINDEX></INDEX> 
   <INDEX>内部声明<SUBINDEX><ORDER>环境</ORDER>在环境模型中<CLOSE></CLOSE></SUBINDEX></INDEX> 
</SUBSECTION>
