[{"id":"/sicpjs/3.3.3","tag":"TITLE","body":"3.3.3  \n    Representing Tables"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    When we studied various ways of representing sets in chapter ","tag":"#text"},{"tag":"REF","body":"2","href":"/sicpjs/2"},{"body":", we\n    mentioned in section ","tag":"#text"},{"tag":"REF","body":"2.3.3","href":"/sicpjs/2.3.3"},{"body":" the task of\n    maintaining a table of records\n    \n    indexed by identifying keys.  In the\n    implementation of data-directed programming in\n    section ","tag":"#text"},{"tag":"REF","body":"2.4.3","href":"/sicpjs/2.4.3"},{"body":", we made extensive use of\n    two-dimensional tables, in which information is stored and retrieved\n    using two keys.  Here we see how to build tables as mutable list\n    structures.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    We first consider a\n    \n    one-dimensional table, in which each value is\n    stored under a single key.  We implement the table as a list of\n    records, each of which is implemented as a pair consisting of a key\n    and the associated value. The records are glued together to form a\n    list by pairs whose\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"s\n    point to successive records.  These gluing pairs are called the \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"backbone","tag":"#text"}]},{"body":" of the table.  In order to have a place that we can\n    change when we add a new record to the table, we build the table as a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"headed list","tag":"#text"}]},{"body":".  A headed list has a special backbone pair at the\n    beginning, which holds a dummy \"","tag":"#text"},{"body":"record","tag":"#text"},{"body":"\"—in this case\n    the arbitrarily chosen \n    string ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"*table*\""},{"body":".\n      \n\tFigure ","tag":"#text"},{"tag":"REF","body":"3.22","href":"/sicpjs/3.3.3#fig-3.22"},{"body":"\n    shows the box-and-pointer diagram for the table\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"a: 1\nb: 2\nc: 3"},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ch3-Z-G-22.svg","id":"#fig-3.22","captionHref":"/sicpjs/3.3.3#fig-3.22","captionName":"Figure 3.22 ","captionBody":[{"body":"A table represented as a headed list. ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    To extract information from a table we use the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":"function,\n    which takes a key as argument and returns the associated value (or\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":"\n    if\n    there is no value stored under that key).\n    The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":"\n    is defined in terms of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assoc"},{"body":" operation,\n    which expects a key and a list of records as arguments. Note that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assoc"},{"body":" never sees the dummy record.  \n    The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assoc"},{"body":"\n    returns the record that has the given key as its\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/3.3.3#footnote-1"},{"body":"The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":"\n    then checks to see that the resulting record returned by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assoc"},{"body":" is not\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"undefined"},{"body":",\n    and returns the value (the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":")\n    of the record.\n\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":16,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaALYCGA1gKYD6p9ARgDbMAUASlABvLKHGgATs1L5JNbuQDOpPgCIAVBx7MNagQG4sAXxwESFaqHKElzSapYBPADSgAbvW75mb7byFRCVBiahUpZlDJABNQAF5QeiUlSmI+Zz96cm4+f2YBQzEJclxQPmVWImjmXBtmaL5pKOiCkSLg8TtSdiycvJd2jqGJAAcsyT4x8gmMjy8fAUzs3K4AgqNg41Bmbjs24dAunuWmyhi3T298jYlTYOlZeVA1SkY1I1M8IjIqBUpX-AjdLMVygPKBQahWykCLNeKJZKpYGgjjLcGFe4yOQ0CpVGp1BqnGICQbDAD8oDxtUI9VJQwAXGDeo1ImcWh8vhZfgiUmlZkTokoIZjHjilKxCPhuDkBUK6R0KVSCfLgozmABHfBeZFuAAWzHoDX1hpZzSFBRVEgpxsJrJicoOEkZSV5OqZJztgvWJhwUPCMISDBYPR0giMNjsDnU9DUbgAjAAGPyFbj-RiA6OxsGGIA","body":"function lookup(key, table) {\n    const record = assoc(key, tail(table));\n    return is_undefined(record)\n           ? undefined\n           : tail(record);\n}\nfunction assoc(key, records) {\n    return is_null(records)\n           ? undefined\n           : equal(key, head(head(records)))\n           ? head(records)\n           : assoc(key, tail(records));\n} "}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    To insert a value in a table under a specified key, we first use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assoc"},{"body":" to see if there is already a record in\n    the table with this key. If not, we form a new record by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"ing\n    the key with the value, and insert this at the head of the table's\n    list of records, after the dummy record.  If there already is a record with\n    this key, we set the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    of this record to the designated new value.  The header of the table\n    provides us with a fixed location to modify in order to insert the new\n    record.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/3.3.3#footnote-2"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":15,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaADaWUDW+ADgBSMCmAngDSikAhgCNanAJSgA3llBzQxagGdSoAE6dFagCagAvKEFKllYhx78h5WmyGiJ4gNyz5G0vjU1ySgPpFtnLjkhJzabBpa2uIu8rFyAPyg-oHBoTFx8gBcAoLW4ZqUOk5YAL54RGRUNEYmZlx86gU6SpIysW4eXr6E+LQ2EYXaLekZoInJQSHaIxnZnACO+II29fwAFpyCYRtb+ZEt4tGjsYk7YQPNR8dy2TWm5g1W-U1Dh85l5SQU1KDBSpxqUgPfgAN2W+E4lhEYla6UUhBUjUi+kMxnuqxyeTsMOKsXIuFAbG8fkIAUmoT2g0O0hmcn+pB8T1s0MhtOuoBYuTUbE55G5GLBtAh4ihWJZh1x8hKoE4tH+NOO9MZuWekVB4IkzliZXanHcnlAACImIb3kA","body":"function insert(key, value, table) {\n    const record = assoc(key, tail(table));\n    if (is_undefined(record)) {\n        set_tail(table,\n                 pair(pair(key, value), tail(table)));\n    } else {\n        set_tail(record, value);\n    }\n    return \"ok\";\n} "}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    To construct a new table, we simply create a list containing\n    \n\tjust the string ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"\"*table*\""},{"body":":\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaALYCGA1gKYD6p9ARgDbMAUASlABvLKHGgATs1L5JNbuQDOpPgCIAVBx7MNagQG4sAXyA","body":"function make_table() {\n    return list(\"*table*\");\n} "}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Two-dimensional tables","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    In a two-dimensional table, each value is indexed by two keys.  We can\n    construct such a table as a one-dimensional table in which each key\n    identifies a subtable.\n    \n        Figure ","tag":"#text"},{"tag":"REF","body":"3.23","href":"/sicpjs/3.3.3#fig-3.23"},{"body":"\n    shows the box-and-pointer diagram for the table\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"\"math\":\n    \"+\":  43\n    \"-\":  45\n    \"*\":  42\n\"letters\":\n    \"a\":  97\n    \"b\":  98"},{"body":"\n    which has two subtables.  (The subtables don't need a special header\n    \n\tstring,\n      \n    since the key that identifies the subtable serves this purpose.)\n    ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ch3-Z-G-23.svg","id":"#fig-3.23","captionHref":"/sicpjs/3.3.3#fig-3.23","captionName":"Figure 3.23 ","captionBody":[{"body":"A two-dimensional table.","tag":"#text"}]}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    When we look up an item, we use the first key to identify the correct\n    subtable.  Then we use the second key to identify the record within the\n    subtable.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":65,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaAIYDO9lxAFANYCmAngDSgBOHYpX4ATegEpQAbyyh5AjqXz8a5egH1C+ADY6Wg4WMlyFZhQH5QRUR1zlCHUafNmAXKA4BHfLX2deUAALDlpRFhCwgyERcQl4l1d5K0jww1iTJPc6RmZ2bj5SWnJ9dON4gG4sAF8cAhIKalAAW1pODSKAIx0OFilZM2FCelJQHWY-DtpujlAAXjH1UhYAIgAqLp61lYkqs3qyKhpxyjZ8AAd8rg0ARj4AjQAmfsTB6hHQenxOzdmFhiYrAed1ARRKLHGxEmv0qrwU5FwoBY6g0NjsDicLC+P2mPXiMjhrkEylU1kItnsjlEeyS1U8OnoswGWQUQw+ZVE8xygKuT0KxX02Jhu0J5mJKjUmjRlMxHIkopZyTJFIxzkVLI8YNKMTEIqytTMBoUB0aamGHH4y2B924fNAADc-PgOC8smzRkLcX9uXlraCBRCJjopjNYVkEUiUdLVVjvsKCerPkopuDIdCvTwFYnzsV+BClryQTnyHmHo8+I6dM74pnE3X-amgyG8WHafTGQn1e7FEZOf9ckDbeWG4K417W4qI8ipeT0VTor38cz64zSCnRziZrX64ri3m97zh5Xq-zwZ7QxOWXSOAymVnXKv1wvYhWnS6aYqja4v6AfyajqAojqDmpDEEELDNK6STiqSzTzHMCwrCcZznCs95mFYyEXOhCgeHBCGIQ4jKWmhO5WERFqkDh8geBa-AiBBfArEQbCEJQADuNCUOcFq0KaoAALQCf6Mw7B+v6JDBNBAfQIFgVUtR4EQhxNBRlqFja1xHm+-Khp28jduePRcgCvq2iCWosMK4lTlGs4yuERkulBD7JpZvzbjuB46AWfoHmWr5Vs5p76MKeoKNet76eY3YciZA6HiFsabi24lmLZM4qvOcouSyj6WU5nk7goB7+UOgUniOyVhWlEXtneib5QGHIVe+oo-j+UmgCspwrApdTKfxWGXH6AUiXi0WGWOMzxTyfrueO4XyBlqL2TGTlLqKXXRlS4mRR2y4xe8oxxf2c3lVVG1LWKSgSqAdlZbKOqiPKZHKnOTjUaAmrNc9121Ip3ajAsPkjKsGxetsIpqcsKy0CsTGdAjoA3AADIUIrDas8OI8jpC7EAA","body":"function lookup(key_1, key_2, table) {\n    const subtable = assoc(key_1, tail(table));\n    if (is_undefined(subtable)) {\n        return undefined;\n    } else {\n        const record = assoc(key_2, tail(subtable));\n        return is_undefined(record)\n               ? undefined\n               : tail(record);\n    }\n} "}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    To insert a new item under a pair of keys, we use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assoc"},{"body":" to see if there is a subtable stored\n    under the first key.  If not, we build a new subtable containing the single\n    record\n    (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"key_2"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"value"},{"body":") and insert it into the table under the\n    first key.  If a subtable already exists for the first key, we insert the\n    new record into this subtable, using the insertion method for\n    one-dimensional tables described above:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":9,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaAIYDO9lxAFANYCmAngDSgBOHYpX4ATegEpQAbyyh5AjqXz8a5egH1C+ADY6Wg4WMlyFZhQH5QRUR1zlCHUafNmAXKA4BHfLX2deUAALDlpRFhCwgyERcQl4l1d5K0jww1iTJPc6RmZ2bj5SWnJ9dON4gG4sAF8cAhIKalAHeg5+UnyuDQBGPgCNACY+ADc-fA5C2gAjHQ4pWTNhQnpSUHp8KaKZjlAAXhymVn7e0CKSli3ZysTyXFAWdQ0bOwcnFnXN6av5xLNW0g0Z30lwmvyyZgADsV+CwdOoOsc+FDyDD+kNQKMdON4pNziD4hIqmZqp4dK0ZGD5EsVoojKI9gc8mjcfoPvjCZTmncHppnvZHGkYmJ4hTwQp-oDiqyNiCeJyxQpkTClZ1BiMxnMWe8ZV85tcsiSOGSdgsFRKgdE6eqsXMiUlasTEoJlKpQAAiShsN1VapAA","body":"function insert(key_1, key_2, value, table) {\n    const subtable = assoc(key_1, tail(table));\n    if (is_undefined(subtable)) {\n        set_tail(table,\n                 pair(list(key_1, pair(key_2, value)), tail(table)));\n    } else {\n        const record = assoc(key_2, tail(subtable));\n        if (is_undefined(record)) {\n            set_tail(subtable,\n                     pair(pair(key_2, value), tail(subtable)));\n        } else {\n            set_tail(record, value);\n        }\n    }\n    return \"ok\";\n} "}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Creating local tables","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":" and \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"insert"},{"body":"\n    operations defined above take the table as an argument.  This enables us to\n    use programs that access more than one table.  Another way to deal with\n    multiple tables is to have separate ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":" and \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"insert"},{"body":"functions\n    for each table.  We can do this by representing a table procedurally, as an\n    object that maintains an internal table as part of its local state. When\n    sent an appropriate message, this \"","tag":"#text"},{"body":"table object","tag":"#text"},{"body":"\" supplies the\n    function\n    with which to operate on the internal table.  Here is a generator for\n    two-dimensional tables represented in this fashion:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":9,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaAIYDO9lxAFANYCmAngDSgBOHYpX4ATegEpQAbyyh5AjqXz8a5egH1C+ADY6Wg4WMlyFZhQH5QRUR1zlCHUafNmAXKA4BHfLX2deUAALDlpRFhCwgyERcQl4l1d5K0jww1iTJPc6RmZ2bj5SWnJ9dON4gG4sAF8cAhIKalAAW1pODSKAIx0OFilZM2FCelJQHWY-DtpujlAAXjH1UhYAIgAqLp61lYkqs3qyKhpxyjZ8AAd8rg0ARj4AjQAmfsTB6hHQenxOzdmFhiYrAed1ARRKLHGxEmv0qrwU5FwoBY6g0NjsDicLC+P2mPXiMjhrkEylU1kItnsjlEeyS1U8OnoswGWQUQw+ZVE8xygKuT0KxX02Jhu0J5mJKjUmjRlMxHIkopZyTJFIxzkVLI8YNKMTEIqytTMBoUB0aamGHH4y2B924fNAADc-PgOC8smzRkLcX9uXlraCBRCJjopjNYVkEUiUdLVVjvsKCerPkopuDIdCvTwFYnzsV+BClryQTnyHmHo8+I6dM74pnE3X-amgyG8WHafTGQn1e7FEZOf9ckDbeWG4K417W4qI8ipeT0VTor38cz64zSCnRziZrX64ri3m97zh5Xq-zwZ7QxOWXSOAymVnXKv1wvYhWnS6aYqja4v6AfyajqAojqDmpDEEELDNK6STiqSzTzHMCwrCcZznCs95mFYyEXOhCgeHBCGIQ4jKWmhO5WERFqkDh8geBa-AiBBfArEQbCEJQADuNCUOcFq0KaoAALQCf6Mw7B+v6JDBNBAfQIFgVU1RAA","body":"function make_table() {\n    const local_table = list(\"*table*\");\n    function lookup(key_1, key_2) {\n        const subtable = assoc(key_1, tail(local_table));\n        if (is_undefined(subtable)) {\n            return undefined;\n        } else {\n            const record = assoc(key_2, tail(subtable));\n            return is_undefined(record)\n                   ? undefined\n                   : tail(record);\n        }\n    }\n    function insert(key_1, key_2, value) {\n        const subtable = assoc(key_1, tail(local_table));\n        if (is_undefined(subtable)) {\n            set_tail(local_table,\n                     pair(list(key_1, pair(key_2, value)),\n                          tail(local_table)));\n        } else {\n            const record = assoc(key_2, tail(subtable));\n            if (is_undefined(record)) {\n                set_tail(subtable,\n                         pair(pair(key_2, value), tail(subtable)));\n            } else {\n                set_tail(record, value);\n            }\n        }\n    }\n    function dispatch(m) {\n        return m === \"lookup\"\n               ? lookup\n               : m === \"insert\"\n               ? insert\n               : error(m, \"unknown operation -- table\");\n    }\n    return dispatch;\n} "}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    Using\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_table"},{"body":",\n    we could\n    \n    implement the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"get"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"put"},{"body":" operations used in\n    section ","tag":"#text"},{"tag":"REF","body":"2.4.3","href":"/sicpjs/2.4.3"},{"body":" for data-directed\n    programming, as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":48,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaAIYDO9lxAFANYCmAngDSgBOHYpX4ATegEpQAbyyh5AjqXz8a5egH1C+ADY6Wg4WMlyFZhQH5QRUR1zlCHUafNmAXKA4BHfLX2deUAALDlpRFhCwgyERcQl4l1d5K0jww1iTJPc6RmZ2bj5SWnJ9dON4gG4sAF8cAhIKalAAW1pODSKAIx0OFilZM2FCelJQHWY-DtpujlAAXjH1UhYAIgAqLp61lYkqs3qyKhpxyjZ8AAd8rg0ARj4AjQAmfsTB6hHQenxOzdmFhiYrAed1ARRKLHGxEmv0qrwU5FwoBY6g0NjsDicLC+P2mPXiMjhrkEylU1kItnsjlEeyS1U8OnoswGWQUQw+ZVE8xygKuT0KxX02Jhu0J5mJKjUmjRlMxHIkopZyTJFIxzkVLI8YNKMTEIqytTMBoUB0aamGHH4y2B924fNAADc-PgOC8smzRkLcX9uXlraCBRCJjopjNYVkEUiUdLVVjvsKCerPkopuDIdCvTwFYnzsV+BClryQTnyHmHo8+I6dM74pnE3X-amgyG8WHafTGQn1e7FEZOf9ckDbeWG4K417W4qI8ipeT0VTor38cz64zSCnRziZrX64ri3m97zh5Xq-zwZ7QxOWXSOAymVnXKv1wvYhWnS6aYqja4v6AfyajqAojqDmpDEEELDNK6STiqSzTzHMCwrCcZznCs95mFYyEXOhCgeHBCGIQ4jKWmhO5WERFqkDh8geBa-AiBBfArEQbCEJQADuNCUOcFq0KaoAALQCf6Mw7B+v6JDBNBAfQIFgVUtRYN23G8aazbeq07S-H0VTdgA5koXIqfwfFHOpqxYahIrduc+CjAsxmmdQ5krBRJEilgtnLCstArExnR+aANwAAwigZ3m+f5YlAA","body":"const operation_table = make_table();\nconst get = operation_table(\"lookup\");\nconst put = operation_table(\"insert\"); "},{"body":"The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"get"},{"body":"\n    takes as arguments two keys, and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"put"},{"body":" takes\n    as arguments two keys and a value.  Both operations access the same\n    local table, which is encapsulated within the object created by the\n    call to \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_table"},{"body":".","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.24","id":"#ex-3.24","child":[{"body":" \n    In the table implementations above, the keys are\n    \n    tested for equality using \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"equal"},{"body":"\n    (called by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assoc"},{"body":").  This is not always the\n    appropriate test.  For instance, we might have a table with numeric keys in\n    which we don't need an exact match to the number we're looking\n    up, but only a number within some tolerance of it. Design a table\n    constructor \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_table"},{"body":"\n    that takes as an argument a \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"same_key"},{"body":"function\n    that will be used to test \"","tag":"#text"},{"body":"equality","tag":"#text"},{"body":"\" of keys.  \n    The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_table"},{"body":"\n    should return a ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"dispatch"},{"body":"function\n    that can be used to access appropriate \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":" and \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"insert"},{"body":"functions\n    for a local table.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":10,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCyCB7AGwFcAXAS3wDtQAjAT1AHFzSAJY20YgZwFMATqADGhPgEMqATik4AZsSrCK1UAFtxAaz4B9UuNpiAFD3Frd2+gEpQAbyyhHI6j1KhC+YeMJ6DY0AC87uSuRgBEAFT6hnwRYVYA3A5OCkoqNOI8PJ5GlgA0oAJ8wvgCACY8NvZONYV8pMQCNCE6VMSEhEZFJeWVybUDjgD83FRlfHLkVHxl-YO1AFygpuY6lrl89AUAFhJlRrvi+92lFVbnc-NOI4fHxad9VwNLmdnCG1ug+uSdJ73nSRqAF85qllJQaB58JpiAAHD5VS5OEpUVx1HplQKgV45fJfcQ-IweLw+aJiAFIxxFBpNUAtRTjSbTO4YqyU+YjBkTKYzdmDJbfX73cqJOYgmpg9J01GCUgfAoAN28xD4iPmKLRf0xQRx7zxgqJnm8vhiFPm5DkoCM9LG3OZXWFZXOdj5A34pF8hOJxrJfDyrqeNVhBIERmD5FDeKVJFVBQN3tJflVZsDQNAfEI-BdgZq7s9QoxiuVqsBqYDdRpNDC0LCpcc4pSinBqjKIWDpGE2yMajVg2pjRoakCASCYShMNhYXL13c+GhcOnjiWQ5Ho6m-AEpCnOZn69li9AS0EAlK3YKYUUmio+AA7qB8LDBOIpQBaF-4mLxOugBtU+oD0BWx4dtOySEEsA1NwHyfdITX8IING0OC+CMIxxAKWgbACAA+bFhyCTCkkg0AAHN6ixaCBGfCFkPCcc4S-CCXDcWEyAox8qNg31wj3TcvyAA","body":"// Solution by GitHub user clean99\n\nfunction make_table(same_key) {\n    const local_table = list(\"*table*\");\n    function assoc(key, records) {\n        return is_null(records)\n               ? undefined\n               : same_key(key, head(head(records)))\n               ? head(records)\n               : assoc(key, tail(records));\n    }\n    function lookup(key) {\n        const record = assoc(key, tail(local_table));\n        return is_undefined(record)\n               ? undefined\n               : tail(record);\n    }\n    function insert(key, value) {\n        const record = assoc(key, tail(local_table));\n        if (is_undefined(record)) {\n               set_tail(local_table,\n                        pair(pair(key, value), tail(local_table)));\n            } else {\n               set_tail(record, value);\n            }\n            return \"ok\";\n    }\n    function dispatch(m) {\n        return m === \"lookup\"\n               ? lookup\n               : m === \"insert\"\n               ? insert\n               : error(m, \"unknow operation -- table\");\n    }\n    return dispatch;\n}\n\nconst operation_table = make_table((a, b) => a === b);\nconst get = operation_table(\"lookup\");\nconst put = operation_table(\"insert\"); "}]},{"tag":"EXERCISE","title":"Exercise 3.25","id":"#ex-3.25","child":[{"body":" \n    Generalizing one- and two-dimensional tables, show how to implement a\n    table in which values are stored under an\n    \n    arbitrary number of keys and\n    different values may be stored under different numbers of keys.\n    The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":" and \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"insert"},{"body":"functions\n    should take as input a list of keys used to access the table.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":11,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCyUBjAewDsAXAJwEsAjAV1IFMATUagT1AHFLSAJW6qFoBnBuVClJlYgGsANjgBmtYvlKUSoAIbDhhfAAoZDNgBpQ5BkXJNh54VoC2DAPrG2ASlABvLKAsMpLTkxKCUwi7EtHJyBpbWth5+-qAA-ELETAyK0szJ-gBcoA7ObiZGJuYAFgxaTAY1dXFWhDbCHh35aaCN9fGtiV1FOnqG7uakWpSx-W0e9k6u7h4A3FgAvjhYyqrqmo5axi6T1HIMBiVLJl6+-kTEwqSgcvpacsdapwygALzP4aQDAAiABUJzOQNWODuJEeoAA5oEXAA3N60b5-SbTNbJHZqDShcIfL4GUg3LqWIIhMIRAAOU3IpK8ADJmT1avUyb8fn9QeCGEC1v5NriVPjNC9CDJaLSKmx2j4uni9qFJdLaS5EcQxJQxiY7BJPmdySkUpRFKADESojE5e0TaaUpTgqF+ULHZtHQRYU93C4AIy-dlNdztd2m+5wv2WOGYqaxUNQr2Rp6zFh-Eb6OUBibx0lGhjzYqLMqecNmi1WiIqLI5bV9Fo2DqKr3+Z3UmvZXJMcvCrr+c2W63RBMmFwxskOr3t0KI0gotHnNNJj2gBhyURhStE-kGOcLuTo5oJDpTx0z56EKUyzUMbVUPVsccMR7mfeow9LxtMDq90DrNcN2+W5WzEchWgMAByaQP0oFh3EgldTU9FIULbQIXUva8NS1HVHwNF58DeYljXdEVRV2AkwgeMRAVDcwP3RM9lSo6RRHIedcIfO0GMXXMvjPGEHl9MdAz+Xo7SQlIU1AaMXyeONpkkv8ZLTINM0fHNDSU-ki0uUspIHbdq0yLt62PAZmxAr1ByrSIR2zCcrP7R1RHnLFYhcr1+VMLzHXpShGQCxk-X9XjPyLDz8wE38-IA9dN2s1sZO1AB3FxhAEfkgzkAFgTBAtIT-U03I+JS-NNHyKpSYKDFq0LzDSjKsoLSK810pJWxSQzHTY2jb3vXVHPk8L0Uahh0sy6hdOK-8XPioCW1bWzh1tOTHmcrr-FKqK01GwtZoWxLqpWiJd3fRcLKbTatoHGiOIGvDhtfUBGIYN8kTeq6fx65DAOO26hLhJqpuyv5csefL+SK6rtqRXbv3GyaWoE2bTT6h6uKG9bSH2pHmum1q0bmrq0NQroyYxzi7ye+jXr4y8iPeGbkhFfwWM0JhwnpUh8CqAxHDPC9HG5Xk1RlIEXPScXaRcooRZ5Xkqclr10ipuXQAVnlQCBYQqkIVKVcddIDC8H4AD4lq9LnhFpOQtDYAxCOIlmuovZ3mYLP8ycKNdyHAxlHHMIEVBkYgDdAQhaTELQVVAABaePDS+GG+3QqlQhtnm+bWEUZLBzXDlcXcGAAR1oN4oSwGS5yDXdIJlxC1hk2l6DrgsoKppvq59Yp9dS9uSUgvWDe7rBW8BCHASBLRIXMf0oQnp28qBaggWD-A59AAAmRf6GXyGgSYdedYFYPFC3lAq6z+3HbnA-p9n081hvh290CB-gTXjfIVi1+74-lPYEx9g5nx1hfZ+OAl5AJnifVeW8F4v25rfd+k8V5P1itAle38dab2DsfIsu8kG2xQffGBOCgSb0gVgw+a8iyIKwP-VBn94HPyAA","body":"// contributed by GitHub user tttinkl\n\nfunction assoc(key, records, same_key) {\n  return is_null(records)\n    ? undefined\n    : same_key(key, head(head(records)))\n    ? head(records)\n    : assoc(key, tail(records), same_key);\n}\n\n\nfunction make_table(same_key) {\n  const local_table = list(\"*table\");\n\n  const get_value = tail;\n\n  function is_table(t) {\n    return is_pair(t) && head(t) === \"*table\";\n  }\n\n  function lookup(keys) {\n    function lookup_generic(keys, table) {\n      if (is_null(keys)) {\n        return table;\n      }\n      const key_1 = head(keys);\n      const key_rest = tail(keys);\n      const record = assoc(key_1, tail(table), same_key);\n      if (is_undefined(record)) {\n        return undefined;\n      }\n      if (is_null(key_rest)) {\n        return get_value(record);\n      } else if (is_table(get_value(record))) {\n        return lookup_generic(key_rest, get_value(record));\n      } else {\n        error('invalid key');\n      }\n    }\n    return lookup_generic(keys, local_table);\n  }\n\n\n  function insert(keys, value) {\n    function insert_generic(keys, value, table) {\n      const key_1 = head(keys);\n      const key_rest = tail(keys);\n      const record = assoc(key_1, tail(table), same_key);\n      if (is_undefined(record)) {\n        if (is_null(key_rest)) {\n          set_tail(\n            table,\n            pair(pair(key_1, value), tail(table)));\n        } else {\n          const new_subtable = list(\"*table\");\n          set_tail(\n            table,\n            pair(pair(key_1, new_subtable), tail(table))\n          );\n          insert_generic(key_rest, value, new_subtable);\n        }\n      } else {\n        if (is_null(key_rest)) {\n          set_tail(record, value);\n        } else {\n          if (is_table(get_value(record))) {\n            insert_generic(key_rest, value, get_value(record));\n          } else {\n            const new_subtable = list(\"*table\");\n            set_tail(record, new_subtable);\n            insert_generic(key_rest, value, new_subtable);\n          }\n        }\n      }\n    }\n    insert_generic(keys, value, local_table);\n  }\n\n  function dispatch(m) {\n    return m === \"lookup\"\n      ? lookup\n      : m === \"insert\"\n      ? insert\n      : m === \"show\"\n      ? () => {\n        display(local_table);\n        return local_table;\n      }\n      : error(m, \"unknow operation -- table\");\n  }\n  return dispatch;\n}\n\nconst table = make_table(equal);\n\nconst get = table('lookup');\nconst put = table('insert');\nconst show = table('show'); "}]},{"tag":"EXERCISE","title":"Exercise 3.26","id":"#ex-3.26","child":[{"body":"\n    To search a table as implemented above, one needs to scan through the\n    list of records.  This is basically the unordered list representation of\n    section ","tag":"#text"},{"tag":"REF","body":"2.3.3","href":"/sicpjs/2.3.3"},{"body":".  For large tables, it\n    may be more efficient to structure the table in a different manner.\n    Describe a table implementation where the (key, value) records are organized\n    using a\n    \n    binary tree, assuming that keys can be ordered in some way\n    (e.g., numerically or alphabetically).  (Compare\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.66","href":"/sicpjs/2.3.3#ex-2.66"},{"body":" of chapter ","tag":"#text"},{"tag":"REF","body":"2","href":"/sicpjs/2"},{"body":".)\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":12,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCyUAHAJwHsA3ASwBMBTS0AIwE9QBxcgFwAkBXe0bgM7VCoGhQB2hRtxwAzbuIDG7csXGhq49lIAU26tQCUoAN6hC1dt0LqAFtQCGlPRaMBuUAF8s8pSrWgADbUsuwA+vSEDkq2LgbGZhZWNqD2TnoO5IFxRoYe3r7KquqE5ADmtuGR0Yqx+kam5pbWdo7O7JnZHVk5hn35PgpFAQC2DgDW1GH1OprajAA0QSHsS6UV7AmgWKC7TcnqgeQC7LNaUkvBoWvllXlY3rhg46Sgx0HHp5OLoKQOgdwjIM-MVQE4AFbEcjiMJCL6kJZwhI7PZJFpvARhcTcQLZJEovaE3YAflAY0m01cOheS2xuNpOMChgJRL2AC5Um1qaRjABefmc9JzXRI5msomkuEs8UctLOF7GAA8gucwsYOlF0tZpPJUxmao1lkMCy14rNuwhUJhcO5lxWESiMUNm2NpvN4vWlQdNVimvdoA5uspBjO82drv9kauVUdtXDJsj-st0Nhllt5luMZ94f6DzkQ386iDHXowR0yMJwXYQWIin+0wcpeooF5oDpgTcLMKhZrxHG3HwOjK5FImjC3yW9TCxFkYQsimIhEoAgr4vIslAOmOWMZOWns-ni+XfVMbsJaJS7c7Zs8GkCQlPkYX4hOoHYtm3apbGnO6qnM7nagFyXFdr39Z9X3fbdvm-OU9A-TE1XuSML3UYdRxhGD+VbKDMRgs93VJXCwjVAjzQ5dCxxg5ViO+MizVJQJiD7AchxHKjqB+ejEz2aNvSdf8DyAo8VzFHjCQ5JiWMHSjMM4pZuPEz0swE1x90A4Dj2Q8VvEJXS9m7UFoSEQgviWHlH3FKsmk078pP7QdxkuWt6xLYJtNZdct0xdsdEPJcTxMeimLrQIGybb9k2tNMjhOalzONGtQvC9ywNZW9qHvZsgsjPBKGINtiCg8QyjdfTdnK0BDICMo03GVdWVQlUMh6ezWKcpLXMbdzcz0rsC1BIhoVOBqiSayhjnwQIHHVEKuqbDyvH6kEAgmgR8Acdg4xGUbz2aFIRhbAUACI2vwY63VJWr2DdQMjtbY7jOEdgLoYt4X2e26yV2bDQGOoatFe8VSQBm6zQ5YQSEIHQRiWY7IcXY7Fsq8bJs22pO0eCDq2rVti266hy07bHQGu79TlO5iHKR4m1FffBuFxt8dEej7TJprASdB8mWdBjmnlAAAVew32oV8LAEHF2AEHAGdOFA4coDm5Z0ABGOGHGVxmdAAJjh+gtdOPW-sUQ2dAAFjh6gzYAVjh2R+dBomcDWqaZqHNMdf6UA8sm6bGAEDljoNoA","body":"// provided by GitHub user devinryu\n\nfunction entry(tree) { return head(tree); }\nfunction left_branch(tree) { return head(tail(tree)); }\nfunction right_branch(tree) { return head(tail(tail(tree))); }\nfunction make_tree(entry, left, right) { \n    return list(entry, left, right);\n}\n\n// kv is list(key, value)\nfunction adjoin_set(kv, set) {\n    return is_null(set)\n           ? make_tree(kv, null, null)\n           : head(kv) === head(entry(set))\n           ? set\n           : head(kv) < head(entry(set))\n           ? make_tree(entry(set),\n                       adjoin_set(kv, left_branch(set)),\n                       right_branch(set))\n           : make_tree(entry(set),\n                       left_branch(set),\n                       adjoin_set(kv, right_branch(set)));\n}\n\nfunction make_table() {\n    let local_table = null;\n    function lookup(given_key, tree_of_records) {\n        if (is_null(tree_of_records)) {\n            return null;\n        } else {\n            const this_entry = entry(tree_of_records);\n            const this_key = head(this_entry);\n            return given_key === this_key \n                   ? this_entry\n                   : given_key < this_key\n                   ? lookup(given_key, \n                            left_branch(tree_of_records))\n                   : lookup(given_key, \n                            right_branch(tree_of_records));\n        }\n    }\n    function insert(k, v) {\n        let record = lookup(k, local_table);\n        if(is_null(record)) {\n            local_table = adjoin_set(list(k, v), local_table);\n        } else {\n            // do nothing\n        }\n    }\n    function get(k) {\n        return head(tail(lookup(k, local_table)));\n    }\n    function print() {\n        return display(local_table);\n    }\n    function dispatch(m) {\n        return m === \"lookup\"\n        ? get\n        : m === \"insert\"\n        ? insert\n        : m  === \"print\"\n        ? print\n        : error(m, \"error\");\n    }\n    return dispatch;\n} "}]},{"tag":"EXERCISE","title":"Exercise 3.27","id":"#ex-3.27","child":[{"tag":"EM","child":[{"body":"Memoization","tag":"#text"}]},{"body":"\n    (also called ","tag":"#text"},{"tag":"EM","child":[{"body":"tabulation","tag":"#text"}]},{"body":") is a technique that\n    enables a\n    function\n    to record, in a local table, values that have previously been computed.\n    This technique can make a vast difference in the performance of a program.\n    A memoized\n    function\n    maintains a table in which values of previous calls are stored\n    using as keys the arguments that produced the values.  When the\n    memoized\n    function\n    is asked to compute a value, it first checks the table to see if the value\n    is already there and, if so, just returns that value.  Otherwise, it\n    computes the new value in the ordinary way and stores this in the table.\n    As an example of memoization, recall from\n    section ","tag":"#text"},{"tag":"REF","body":"1.2.2","href":"/sicpjs/1.2.2"},{"body":" the exponential process for\n    computing Fibonacci numbers:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":13,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaLuQEYAUhAlKAN5ajegBOApqXy8aNALwTQABi485PAPzTZ8uQC5Q4yQEYVq7kt371tBs1ABaUNrYBqU0xpWATCwDcWAL446TAGzuQA","body":"function fib(n) {\n    return n === 0\n           ? 0\n           : n === 1\n           ? 1\n           : fib(n - 1) + fib(n - 2);\n} "},{"body":"\n    The memoized version of the same\n    function\n    is\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":14,"eval":true,"prependLength":45,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaALYCGA1gKYD6p9ARgDbMAUASlABvLKHGgATs1L5JNbuQDOpPgCIAVBx7MNagQG4sAXxwESFaqG6VKjfAAc+LAJ4AaUNt5DRE0MWoVKWYAyQATUABeUHolJUpiZ2Z3T3pybj4vZgFDMQlpWXlQZVYiMOZcckJmML5pULCBPL8WgH5QMoqqmuaWiQAuVPS6kMpw3NNzMioaWPjE1w96sbClH16CuRoSwnxuDOXwtd6+0HbOyuqwk77B5gBHfHoMxdAAC2Z6Wo+vkYa1nI3NrvT61Q6rJqnPyDOYJJIpDjDcEAoymPBEaZWKpKZiSVSvABuz3wzA8WXWfgChCC4KiMTicNeiIy5NyfnIuFAfBKF26YNG4wppxxpHYaRZXF4biBUPEDjSkj48vIisJxOyZPFmUl2RyRj8xlAzG4OJEMpFYqRArCHiJ3BJbIkpj8myKajsalRZgxlhotGYtEo5AAXvxcELxFSglk6QwWGKdIJ9fkZFtQAAPKIAPjNsr6UdIoAc0gJVHwSm4LlYAVoDnwpBqrGkSj2hciMrz1ls9ic6c1OkdnfEHK5PMI5UuNSVJbLFarNbrDbCTeYLe4pByuaH+cChebrbpuD46cH24k2Nxqj7wTXpH73mTZ5ThRo+-Xj6HhuNpt8T+faeLZhS0octK2rSha3rRs31ID9O2dPNjC9LACzoANKFYSpOFjdCQ34GhIhzAjImiAAGDs-2BcjKO3QZiOiABGCiaPEdomJYztBn9QNMPITg+BoABaUAGKEABqZiOLQnisIE0BhIAJkhKTxFyLBuIw2SAFZDCAA","body":"const memo_fib = memoize(n => n === 0\n                              ? 0\n                              : n === 1\n                              ? 1\n                              : memo_fib(n - 1) +\n                                memo_fib(n - 2)\n                        ); "},{"body":"\n    where the memoizer is defined as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":15,"eval":true,"prependLength":30,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHTpQKCwMwK4B2AxgC4CWA9oaALYCGA1gKYD6p9ARgDbMAUASlABvLKHGgATs1L5JNbuQDOpPgCIAVBx7MNagQG4sAXxwESFaqG6VKjfAAc+LAJ4AaUNt5DRE0MWoVKWYAyQATUABeUHolJUpiZ2Z3T3pybj4vZgFDMQlpWXlQZVYiMOZcckJmML5pULCBPL8WgH5QMoqqmuaWiQAuVPS6kMpw3NNzMioaWPjE1w96sbClH16CuRoSwnxuDOXwtd6+0HbOyuqwk77B5gBHfHoMxdAAC2Z6Wo+vkYa1nI3NrvT61Q6rJqnPyDOYJJIpDjDcEAoymPBEaZWKpKZiSVSvABuz3wzA8WXWfgChCC4KiMTicNeiIy5NyfnIuFAfBKF26YNG4wppxxpHYaRZXF4biBUPEDjSkj48vIisJxOyZPFmUl2RyRj8xlAzG4OJEMpFYqRArCHiJ3BJbIkpj8myKajsalRZgxlhotGYtEo5AAXvxcELxFSglk6QwWGKdIJ9fkZFtQAAPKIAPjNsr6UdIoAc0gJVHwSm4LlYAVoDnwpBqrGkSj2hciMrz1ls9ic6c1OkdnfEHK5PMI5UuNSVJbLFarNbrDbCTeYLe4pByuaH+cChebrbpuD46cH24k2Nxqj7wTXpH73mTZ5ThRo+-Xj6HhuNpt8T+faeLZhS0octK2rSha3rRs31ID9O2dPNjFRIA","body":"function memoize(f) {\n    const table = make_table();\n    return x => {\n               const previously_computed_result =\n                   lookup(x, table);\n               if (is_undefined(previously_computed_result)) {\n                   const result = f(x);\n                   insert(x, result, table);\n                   return result;\n               } else {\n                   return previously_computed_result;\n               }\n           };\n} "},{"body":"\n    Draw an environment diagram to analyze the computation of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"memo_fib(3)"},{"body":".\n    Explain why \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"memo_fib"},{"body":"\n    computes the ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"th Fibonacci number in a number\n    of steps proportional to ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":". Would the scheme\n    still work if we had simply defined \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"memo_fib"},{"body":"\n    to be\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"memoize(fib)"},{"body":"?","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/3.3.3#footnote-link-1","child":[{"body":"\n\tBecause ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"assoc"},{"body":" uses\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"equal"},{"body":", it can recognize keys that\n\tare strings, numbers, or list structure.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/3.3.3#footnote-link-2","child":[{"body":"Thus, the first backbone pair is the object that represents\n    the table \"","tag":"#text"},{"body":"itself","tag":"#text"},{"body":"\"; that is, a pointer to the table is a\n    pointer to this pair.  This same backbone pair always starts the table.\n    If we did not arrange things in this way,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"insert"},{"body":"\n    would have to return a new value for the start of the table\n    when it added a new record.","tag":"#text"}]}]