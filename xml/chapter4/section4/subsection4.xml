<SUBSECTION>
  <NAME>
    Implementing the Query System
  </NAME>

  <LABEL NAME="sec:implementing-the-query-system"/>
  <TEXT>
    Section<SPACE/><REF NAME="sec:how-query-works"/> described how the query
    system works. Now we fill in the details by presenting a complete
    implementation of the system.
  </TEXT>

  <SUBSUBSECTION>
    <NAME>The Driver Loop and Instantiation</NAME>
    <LABEL NAME="sec:query-driver"/>

    <TEXT>
      <INDEX>driver loop<SUBINDEX>query@in query interpreter</SUBINDEX></INDEX>
      <INDEX>query interpreter<SUBINDEX>driver loop|(</SUBINDEX></INDEX>
      The driver loop for the query system repeatedly reads input
      <SPLITINLINE>
	<SCHEME>
	  expressions.
	</SCHEME>
	<JAVASCRIPT>
	  expressions as strings and parses them.
	</JAVASCRIPT>
      </SPLITINLINE>
      If the expression is
      a rule or assertion to be added to
      the data base, then the information is added.  Otherwise the
      <SPLITINLINE>
	<SCHEME>
	  input
	</SCHEME>
	<JAVASCRIPT>
	  expression
	</JAVASCRIPT>
      </SPLITINLINE>
      is assumed to be a query.  The driver passes this query to
      the evaluator
      <SPLITINLINE><SCHEME><SCHEMEINLINE>qeval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate_query</JAVASCRIPTINLINE>
      </JAVASCRIPT>
      </SPLITINLINE>
      together with an initial frame stream consisting of a single empty frame.
      The result of the evaluation is a stream of frames generated by satisfying
      the query with variable values found in the data base.  These frames are
      used to form a new stream consisting of copies of the original query in
      which the variables are instantiated with values supplied by the stream of
      frames, and this final stream is
      <SPLITINLINE>
	<SCHEME>printed at the terminal:</SCHEME>
	<JAVASCRIPT>displayed:</JAVASCRIPT>
      </SPLITINLINE>
      <SNIPPET HIDE="yes">
	<NAME>lp_header</NAME>
	<JAVASCRIPT>
// functions from SICP JS 4.4.4
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>functions_4_4_4</NAME>
	<REQUIRES>functions_4_1_1</REQUIRES>
	<REQUIRES>functions_4_1_2</REQUIRES>
	<REQUIRES>functions_4_1_3</REQUIRES>
	<REQUIRES>functions_4_1_4</REQUIRES>
	<REQUIRES>lp_header</REQUIRES>
	<REQUIRES>contract_question_mark</REQUIRES>
	<REQUIRES>process_query</REQUIRES>
	<REQUIRES>is_assertion</REQUIRES>
	<REQUIRES>instantiate</REQUIRES>
	<REQUIRES>evaluate_query</REQUIRES>
	<REQUIRES>singleton_stream</REQUIRES>
	<REQUIRES>add_rule_or_assertion</REQUIRES>
	<REQUIRES>put_and</REQUIRES>
	<REQUIRES>disjoin</REQUIRES>
	<REQUIRES>negate</REQUIRES>
	<REQUIRES>javascript_value</REQUIRES>
	<REQUIRES>display_stream</REQUIRES>
	<REQUIRES>always_true</REQUIRES>
	<JAVASCRIPT>
	</JAVASCRIPT>
      </SNIPPET>
      <INDEX>prompts<SUBINDEX>query interpreter</SUBINDEX></INDEX>
      <!--  \indcode*{query-driver-loop} -->
      <SNIPPET>
	<NAME>query_driver_loop</NAME>
	<REQUIRES>functions_4_4_4</REQUIRES>
	<EXAMPLE>append_to_form_example_4</EXAMPLE>
	<SCHEME>
(define input-prompt ";;; Query input:")
(define output-prompt ";;; Query results:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
              (instantiate q
               frame
               (lambda (v f)
                 (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
  (query-driver-loop)))))
	</SCHEME>
	<JAVASCRIPT>
const input_prompt = "Query input:";
const output_prompt = "Query results:";

function query_driver_loop() {
    const input = user_read(input_prompt);
    const q = parse_query(input);
    if (is_assertion(q)) {
        add_rule_or_assertion(assertion_body(q));
        display("Assertion added to data base.");
    } else {
        display(output_prompt);
        display_stream(
          stream_map(
            frame =>
              unparse_query(
                instantiate(q, frame, (v, ignore) => v)),
            evaluate_query(q, singleton_stream(null))));
    }
    query_driver_loop();
}
	</JAVASCRIPT>
	<JAVASCRIPT_RUN>
const input_prompt = "Query input:";

function query_driver_loop() {
    const input = prompt(input_prompt);
    if (is_null(input)) {
        display("--- evaluator terminated ---");
    } else {
        const q = parse_query(input);
        display("---- driver loop input -----");
        display(unparse_query(q));
        if (is_assertion(q)) {
            add_rule_or_assertion(assertion_body(q));
            display("Assertion added to data base.");
        } else {
            display("------ query results -------", "");
            display_stream(
              stream_map(
                frame =>
                  unparse_query(
		    instantiate(q, frame, (v, ignore) => v)),
                evaluate_query(q, singleton_stream(null))));
        }
        query_driver_loop();
    }
}
	</JAVASCRIPT_RUN>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>parse_query_verbose</NAME>
	<REQUIRES>functions_4_4_4</REQUIRES>
	<EXAMPLE>process_query_example_1</EXAMPLE>
	<JAVASCRIPT>
function parse_query_verbose(input, verbosity) {
    const q = parse_query(input);
    if (verbosity !== "silent") {
        display("--- process query input  ---"); 
        display(unparse_query(q)); } else {}
    if (is_assertion(q)) {
        add_rule_or_assertion(assertion_body(q));
        if (verbosity !== "silent") {
            display("----- assertion added ------"); } else {}
    } else {
        display("------ query results -------");
        display_stream(
            stream_map(
                frame =>
                    unparse_query(
                        instantiate(q, frame, (v, f) => v)),
                evaluate_query(q, singleton_stream(null))));
    }
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>process_query_example_1</NAME>
	<JAVASCRIPT>
parse_query_verbose('assert(son("Adam", "Cain"))');
parse_query_verbose('son("Adam", x)');	  
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>first_answer</NAME>
	<REQUIRES>functions_4_4_4</REQUIRES>
	<EXAMPLE>process_query_example_1</EXAMPLE>
	<JAVASCRIPT>
function process_query(input, verbosity) {
    if (is_null(input)) {
        display("--- evaluator terminated ---");
    } else {
        const q = parse_query(input);
        display("---- driver loop input -----");
        display(unparse_query(q));
        if (is_assertion(q)) {
            add_rule_or_assertion(assertion_body(q));
            display("Assertion added to data base.");
        } else {
            display("------ query results -------", "");
            display_stream(
              stream_map(
                frame =>
                  unparse_query(
		    instantiate(q, frame, (v, ignore) => v)),
                evaluate_query(q, singleton_stream(null))));
        }
    }
}
    
function first_answer(input) {
    const q = parse_query(input);
    const frames = evaluate_query(q, singleton_stream(null));
    return is_null(frames)
           ? "no matching data"
           : unparse_query(instantiate(q, head(frames), (v, f) => v));
}
	</JAVASCRIPT>
      </SNIPPET>
      <INDEX>abstract syntax<SUBINDEX>in query interpreter</SUBINDEX></INDEX>
      <SPLIT>
	<SCHEME>
	  Here, as in the other evaluators in this chapter,
	  we use an abstract syntax for expressions of the query language.
	  The implementation of the
	  expression syntax, including the predicate
	  <SCHEMEINLINE>assertion-to-be-added?</SCHEMEINLINE>
	  and the selector
	  <SCHEMEINLINE>add-assertion-body</SCHEMEINLINE>,
	  is given in section<SPACE/><REF NAME="sec:query-syntax"/>.
	  <SCHEMEINLINE>Add\?rule\?or-assertion!</SCHEMEINLINE>
	  is defined in section<SPACE/><REF NAME="sec:query-db"/>.
	</SCHEME>
	<JAVASCRIPT>
	  Here, as in the other evaluators in this chapter,
	  we transform expressions of the query language given as strings
	  into abstract expressions at the appropriate conceptual level. The function
	  <JAVASCRIPTINLINE>parse_query</JAVASCRIPTINLINE> that performs
	  the transformation, the predicate
	  <JAVASCRIPTINLINE>is_assertion</JAVASCRIPTINLINE>,
	  and the selector
	  <JAVASCRIPTINLINE>assertion_body</JAVASCRIPTINLINE> are
	  declared in section<SPACE/><REF NAME="sec:query-syntax"/>.
	  The function <JAVASCRIPTINLINE>add_rule_or_assertion</JAVASCRIPTINLINE>
	  is declared in section<SPACE/><REF NAME="sec:query-db"/>.
	  After the query is instantiated, it is transformed back
	  into a string by 
	  <JAVASCRIPTINLINE>unparse_query</JAVASCRIPTINLINE>
	  (section<SPACE/><REF NAME="sec:query-syntax"/>)
	  before being displayed.
	</JAVASCRIPT>
      </SPLIT>
      <TEXT>

      <TEXT>
	<SPLIT>
	  <SCHEME>
	    Before doing any processing on an input expression, the driver loop
	    transforms it syntactically into a form that makes the processing more
	    efficient. This involves changing the 
	    <INDEX>pattern variable<SUBINDEX>representation of</SUBINDEX></INDEX>
	    <INDEX>query interpreter
	    <SUBINDEX>pattern-variable representation</SUBINDEX></INDEX>
	    representation of pattern variables.  When the query is instantiated, any
	    variables that remain unbound are transformed back to the input
	    representation before being printed.  These transformations are performed
	    by the two procedures
	    <SCHEMEINLINE>query-syntax\?process</SCHEMEINLINE>
	    and
	    <SCHEMEINLINE>contract-question-mark</SCHEMEINLINE>
	    (section<SPACE/><REF NAME="sec:query-syntax"/>).
	  </SCHEME>
	</SPLIT>
      </TEXT>
      <TEXT>
      <INDEX>query interpreter<SUBINDEX>instantiation|(</SUBINDEX></INDEX>
      To instantiate an expression, we copy it, replacing any variables in
      the expression by their values in a given frame.  The values are
      themselves instantiated, since they could contain variables (for
      example, if
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      in <SCHEMEINLINE>exp</SCHEMEINLINE> is bound to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      as the result of unification and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      is in turn bound to<SPACE/>5).  The action to take if a variable cannot be
      instantiated is given by a
      <SPLITINLINE>
	<SCHEME>procedural</SCHEME>
	<JAVASCRIPT>functional</JAVASCRIPT>
      </SPLITINLINE>
      argument to
      <SCHEMEINLINE>instantiate</SCHEMEINLINE>.
      <SNIPPET HIDE="yes">
	<NAME>append_to_form_example_5</NAME>
	<REQUIRES>parse_query_verbose</REQUIRES>
	<REQUIRES>first_answer</REQUIRES>
	<JAVASCRIPT>
parse_query_verbose('assert(                           \
rule(append_to_form(null, y, y)))                ', "verbose");
parse_query_verbose('assert(                           \
rule(append_to_form(pair(u, v), y, pair(u, z)),  \
     append_to_form(v, y, z)))                   ', "verbose");
	  
first_answer('append_to_form(x, y, list("a", "b", "c", "d"))');
// parse_query_verbose('append_to_form(x, y, list("a", "b", "c", "d"))', "");
	</JAVASCRIPT>
      </SNIPPET>
      <!--  \indcode*{instantiate} -->
      <SNIPPET>
	<NAME>instantiate</NAME>
	<REQUIRES>make_binding</REQUIRES>
	<REQUIRES>is_var</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (instantiate exp frame unbound-var-handler)
(define (copy exp)
  (cond ((var? exp)
         (let ((binding (binding-in-frame exp frame)))
           (if binding
               (copy (binding-value binding))
               (unbound-var-handler exp frame))))
        ((pair? exp)
         (cons (copy (car exp)) (copy (cdr exp))))
        (else exp)))
  (copy exp))
	</SCHEME>
	<JAVASCRIPT>
function instantiate(exp, frame, unbound_var_handler) {
    function copy(exp) {
        if (is_$_name(exp)) {
            const binding = binding_in_frame(exp, frame);
            return is_undefined(binding)
                   ? unbound_var_handler(exp, frame)
                   : copy(binding_value(binding));
        } else if (is_pair(exp)) {
            return pair(copy(head(exp)), copy(tail(exp)));
        } else {
            return exp;
        }
    }
    return copy(exp);
}
	</JAVASCRIPT>
      </SNIPPET>
      The
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      that manipulate bindings are defined in
      section<SPACE/><REF NAME="sec:query-bindings"/>.
      <INDEX>query interpreter<SUBINDEX>instantiation|)</SUBINDEX></INDEX>
      <INDEX>query interpreter<SUBINDEX>driver loop|)</SUBINDEX></INDEX>
    </TEXT>
  </SUBSUBSECTION>

  <SUBSUBSECTION>
    <NAME>The Evaluator</NAME>
    <LABEL NAME="sec:query-eval"/>

    <TEXT>
      <INDEX>query interpreter<SUBINDEX>query evaluator|(</SUBINDEX></INDEX>
      The
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>qeval</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>evaluate_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>procedure,</SCHEME>
	<JAVASCRIPT>function,</JAVASCRIPT>
      </SPLITINLINE>
      called by the
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>query-driver-loop</SCHEMEINLINE>,
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>query_driver_loop</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      is the basic evaluator of the query system.  It takes as inputs a query
      and a stream of frames, and it returns a stream of extended frames.
      It identifies
      <SPLITINLINE>
	<SCHEME>special</SCHEME>
	<JAVASCRIPT>syntactic</JAVASCRIPT>
      </SPLITINLINE>
      forms by a 
      <INDEX>data-directed programming
      <SUBINDEX>in query interpreter</SUBINDEX></INDEX>
      data-directed dispatch using <SCHEMEINLINE>get</SCHEMEINLINE> and
      <SCHEMEINLINE>put</SCHEMEINLINE>, just as we did in implementing generic
      operations in chapter<SPACE/>2.  Any query that is not identified as a
      <SPLITINLINE>
	<SCHEME>special</SCHEME>
	<JAVASCRIPT>syntactic</JAVASCRIPT>
      </SPLITINLINE>
      form is assumed to be a simple query, to be processed by
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>simple-query</SCHEMEINLINE>.
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>simple_query</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
      <!--  \indcode*{qeval} -->
      <SNIPPET>
	<NAME>evaluate_query</NAME>
	<REQUIRES>operation_table_from_chapter_3</REQUIRES>
	<REQUIRES>operation_table</REQUIRES>
	<REQUIRES>simple_query</REQUIRES>
	<REQUIRES>type</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
	</SCHEME>
	<JAVASCRIPT>
function evaluate_query(query, frame_stream) {
    const qfun = get(type(query), "evaluate_query");
    return is_undefined(qfun)
           ? simple_query(query, frame_stream)
           : qfun(contents(query), frame_stream);
}
	</JAVASCRIPT>
      </SNIPPET>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Type</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The functions <JAVASCRIPTINLINE>type</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and <SCHEMEINLINE>contents</SCHEMEINLINE>, defined in
      section<SPACE/><REF NAME="sec:query-syntax"/>, implement 
      <SPLITINLINE>
	<SCHEME>
	  the abstract syntax of the special forms.
	</SCHEME>
	<JAVASCRIPT>
	  the abstract syntax of the syntactic forms.
	</JAVASCRIPT>
      </SPLITINLINE>
    </TEXT>

    <SUBHEADING>
      <NAME>Simple queries</NAME>
    </SUBHEADING>

    <INDEX>simple query<SUBINDEX>processing|(</SUBINDEX></INDEX>
    <TEXT>
      The
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>simple-query</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>simple_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      handles simple queries.  It takes as arguments a simple query (a pattern)
      together with a stream of frames, and it returns the stream formed by
      extending each frame by all data-base matches of the query.
      <!--  \indcode*{simple-query} -->
      <SNIPPET>
	<NAME>simple_query</NAME>
	<REQUIRES>stream_flatmap</REQUIRES>
	<REQUIRES>find_assertions</REQUIRES>
	<REQUIRES>apply_rules</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
	</SCHEME>
	<JAVASCRIPT>
function simple_query(query_pattern, frame_stream) {
    return stream_flatmap(
               frame => 
                   stream_append_delayed(
                       find_assertions(query_pattern, frame),
                       () => apply_rules(query_pattern, frame)),
               frame_stream);
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      For each frame in the input stream, we use
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>find-assertions</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>find_assertions</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      (section<SPACE/><REF NAME="sec:query-match"/>) to match the pattern
      against all assertions in the data base, producing a stream of extended
      frames, and we use
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>apply-rules</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>apply_rules</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      (section<SPACE/><REF NAME="sec:query-unify"/>) to apply
      all possible rules, producing another stream of extended frames.
      These two streams are combined (using
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>stream\?append\?delayed</SCHEMEINLINE>,
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>stream_append_delayed</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      section<SPACE/><REF NAME="sec:query-streams"/>) to make a stream of all
      the ways that the given pattern can be satisfied consistent with the
      original frame (see exercise<SPACE/><REF NAME="ex:q-why-not-append"/>).
      The streams for the individual input frames are combined using
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>stream-flatmap</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>stream_flatmap</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      (section<SPACE/><REF NAME="sec:query-streams"/>) to form one large stream
      of all the ways that any of the frames in the original input stream can be
      extended to produce a match with the given pattern.
      <INDEX>simple query<SUBINDEX>processing|)</SUBINDEX></INDEX>
    </TEXT>

    <SUBHEADING>
      <NAME>Compound queries</NAME>
    </SUBHEADING>

    <INDEX>compound query<SUBINDEX>processing|(</SUBINDEX></INDEX>
    <TEXT>
      <!-- \indcodeplus{and}{(query language)}[evaluation of]-->
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>And</SCHEMEINLINE> queries are handled as illustrated in
	  figure<SPACE/><REF NAME="fig:query-and_scheme"/>
	  by the
	</SCHEME>
	<JAVASCRIPT>
	  We handle <JAVASCRIPTINLINE>and</JAVASCRIPTINLINE>
	  queries as illustrated in
	  figure<SPACE/><REF NAME="fig:query-and"/>
	  with the
	</JAVASCRIPT>
      </SPLITINLINE>
      <SCHEMEINLINE>conjoin</SCHEMEINLINE>
      <SPLITINLINE>
	<SCHEME>procedure. <SCHEMEINLINE>Conjoin</SCHEMEINLINE></SCHEME>
        <JAVASCRIPT>function, which</JAVASCRIPT>
      </SPLITINLINE>
      takes as inputs the conjuncts and the frame stream and returns the stream
      of extended frames.  First, <SCHEMEINLINE>conjoin</SCHEMEINLINE> processes
      the stream of frames to find the stream of all possible frame extensions
      that satisfy the first query in the conjunction.  Then, using this as the
      new frame stream, it recursively applies
      <SCHEMEINLINE>conjoin</SCHEMEINLINE> to the rest of the queries.
      <!-- mutual recursion -->
      <!--  \indcode*{conjoin} -->
      <SNIPPET EVAL="no">
	<NAME>conjoin</NAME>
	<REQUIRES>is_empty_conjunction</REQUIRES>
	<SCHEME>
(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
	</SCHEME>
	<JAVASCRIPT>
function conjoin(conjuncts, frame_stream) {
    return is_empty_conjunction(conjuncts)
           ? frame_stream
           : conjoin(rest_conjuncts(conjuncts),
                     evaluate_query(first_conjunct(conjuncts),
	                            frame_stream));
}
	</JAVASCRIPT>
      </SNIPPET>
      The
      <SPLITINLINE>
	<SCHEME>expression</SCHEME>
	<JAVASCRIPT>statement</JAVASCRIPT>
      </SPLITINLINE>
      <SNIPPET>
	<NAME>put_and</NAME>
	<REQUIRES>operation_table_from_chapter_3</REQUIRES>
	<REQUIRES>operation_table</REQUIRES>
	<REQUIRES>conjoin</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(put 'and 'qeval conjoin)
	</SCHEME>
	<JAVASCRIPT>
put("and", "evaluate_query", conjoin);
	</JAVASCRIPT>
      </SNIPPET>
      sets up
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>qeval</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>evaluate_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      to dispatch to <SCHEMEINLINE>conjoin</SCHEMEINLINE> when an
      <SCHEMEINLINE>and</SCHEMEINLINE>
      <SPLITINLINE>
	<SCHEME>form</SCHEME>
      </SPLITINLINE>
      is encountered.
    </TEXT>

    <TEXT>
      <!--  \indcodeplus{or}{(query language)}[evaluation of]-->
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>Or</SCHEMEINLINE> queries are handled
	</SCHEME>
	<JAVASCRIPT>
	  We handle <SCHEMEINLINE>or</SCHEMEINLINE> queries
	</JAVASCRIPT>
      </SPLITINLINE>
      similarly, as shown in
      <SPLITINLINE>
	<SCHEME>
      figure<SPACE/><REF NAME="fig:query-or_scheme"/>.
	</SCHEME>
	<JAVASCRIPT>
      figure<SPACE/><REF NAME="fig:query-or"/>.
	</JAVASCRIPT>
      </SPLITINLINE>
      The output streams for the various disjuncts of the
      <SCHEMEINLINE>or</SCHEMEINLINE> are computed separately and merged using
      the
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>interleave-delayed</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>interleave_delayed</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      from section<SPACE/><REF NAME="sec:query-streams"/>.
      (See exercises<SPACE/><REF NAME="ex:q-why-not-append"/>
      and<SPACE/><REF NAME="ex:q-why-interleave"/>.)
      <!-- mutual recursion -->
      <!--  \indcode*{disjoin} -->
      <SNIPPET>
	<NAME>disjoin</NAME>
	<REQUIRES>operation_table_from_chapter_3</REQUIRES>
	<REQUIRES>operation_table</REQUIRES>
	<REQUIRES>is_empty_conjunction</REQUIRES>
	<REQUIRES>stream_append_delayed</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))

(put 'or 'qeval disjoin)
	</SCHEME>
	<JAVASCRIPT>
function disjoin(disjuncts, frame_stream) {
    return is_empty_disjunction(disjuncts)
           ? null
           : interleave_delayed(
                 evaluate_query(first_disjunct(disjuncts), frame_stream),
	         () => disjoin(rest_disjuncts(disjuncts), frame_stream));
}
put("or", "evaluate_query", disjoin);
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      The predicates and selectors for the
      <SPLITINLINE>
	<SCHEME>syntax</SCHEME>
	<JAVASCRIPT>representation</JAVASCRIPT>
      </SPLITINLINE>
      of conjuncts and disjuncts
      are given in section<SPACE/><REF NAME="sec:query-syntax"/>.
    </TEXT>

    <SUBHEADING>
      <NAME>Filters</NAME>
    </SUBHEADING>

    <TEXT>
      <!-- \indcodeplus{not}{(query language)}[evaluation of]-->
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>Not</SCHEMEINLINE> is
	</SCHEME>
	<JAVASCRIPT>
	  Queries formed with <SCHEMEINLINE>not</SCHEMEINLINE> are
	</JAVASCRIPT>
      </SPLITINLINE>
      handled by the method outlined in
      section<SPACE/><REF NAME="sec:how-query-works"/>.  We attempt to extend
      each frame in the input stream to satisfy the query being negated, and we
      include a given frame in the output stream only if it cannot be extended.
      <!-- mutual recursion -->
      <!--  \indcode*{negate} -->
      <SNIPPET>
	<NAME>negate</NAME>
	<REQUIRES>operation_table_from_chapter_3</REQUIRES>
	<REQUIRES>operation_table</REQUIRES>
	<REQUIRES>stream_flatmap</REQUIRES>
	<REQUIRES>singleton_stream</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null? (qeval (negated-query operands)
                              (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))

(put 'not 'qeval negate)
	</SCHEME>
	<JAVASCRIPT>
function negate(args, frame_stream) {
    return stream_flatmap(
              frame =>
	         is_null(evaluate_query(negated_query(args),
                                        singleton_stream(frame)))
	         ? singleton_stream(frame)
		 : null,
	      frame_stream);
}
put("not", "evaluate_query", negate);
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      <!-- \indcodeplus{lisp-value}{(query language)}[evaluation of]-->
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Lisp-value</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>
	  The function
	  <JAVASCRIPTINLINE>javascript_value</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      is a filter similar to <SCHEMEINLINE>not</SCHEMEINLINE>.  Each frame in
      the stream is used to instantiate the variables in the pattern, the
      indicated predicate is applied, and the frames for which the predicate
      returns false are filtered out of the input stream.  An error results
      if there are unbound pattern variables.
      <!-- mutual recursion -->
	<SNIPPET HIDE="yes">
	  <NAME>compound_queries_5_example</NAME>
	  <REQUIRES>compound_queries_4</REQUIRES>
	  <REQUIRES>first_answer</REQUIRES>
	  <JAVASCRIPT>
first_answer('and(salary(person, amount), javascript_value(amount &gt; 50000))');
// parse_query_verbose('and(salary(person, amount), javascript_value(amount &gt; 50000))', "verbose");
	  </JAVASCRIPT>
	</SNIPPET>
        <!-- \indcodeplus*{lisp-value}{(query interpreter)}-->
	<SNIPPET>
	  <NAME>javascript_value</NAME>
	  <REQUIRES>operation_table_from_chapter_3</REQUIRES>
	  <REQUIRES>operation_table</REQUIRES>
	  <REQUIRES>stream_flatmap</REQUIRES>
	  <REQUIRES>execute</REQUIRES>
	  <REQUIRES>singleton_stream</REQUIRES>
	  <EXAMPLE>compound_queries_5_example</EXAMPLE>
	  <SCHEME>
(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error "Unknown pat var - - LISP-VALUE" v))))
              (singleton-stream frame)
              the-empty-stream))
        frame-stream))

        (put 'lisp-value 'qeval lisp-value)
	  </SCHEME>
	  <JAVASCRIPT>
function javascript_value(args, frame_stream) {
  return stream_flatmap(
           frame =>
               execute(instantiate(
                           javascript_expression(args), frame,
                           (v, f) =>
                               error(v, 
                                     "Unknown pat var -- " +
                                     "javascript_value")))
               ? singleton_stream(frame)
               : null,
           frame_stream);
}
put("javascript_value", "evaluate_query", javascript_value);
	  </JAVASCRIPT>
	</SNIPPET>
    </TEXT>

    <TEXT>
      <SPLIT>
	<SCHEME>
	  <SCHEMEINLINE>Execute</SCHEMEINLINE>,
	  which applies the predicate to the arguments, must
	  <SCHEMEINLINE>eval</SCHEMEINLINE>
	  the predicate expression to get the procedure
	  to apply. However, it must not evaluate the arguments, since they are
	  already the actual arguments, not expressions whose evaluation
	  (in Lisp) will produce the arguments.
	  Note that
	  <SCHEMEINLINE>execute</SCHEMEINLINE> is implemented using
	  <!-- \indprim{eval}[used in query interpreter]-->
	  <SCHEMEINLINE>eval</SCHEMEINLINE>
	  and <SCHEMEINLINE>apply</SCHEMEINLINE> from the
	  underlying Lisp system.
	</SCHEME>
	<JAVASCRIPT>
	  The function <JAVASCRIPTINLINE>execute</JAVASCRIPTINLINE>
	  uses <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
	  from section<SPACE/><REF NAME="sec:mc-eval"/> and thus
	  can apply operator combinations to literal values and instantiated
	  variables.
	</JAVASCRIPT>
      </SPLIT>
      <COMMENT>
	The original is more restrictive here. We think that allowing
	primitive functions to be applied is at the same simpler and
	more powerful. (We could do away with the syntax functions
	<SCHEMEINLINE>predicate</SCHEMEINLINE> and
	<SCHEMEINLINE>args</SCHEMEINLINE>.)
      </COMMENT>
      <SNIPPET>
	<NAME>execute</NAME>
	<REQUIRES>functions_4_1_1</REQUIRES>
	<REQUIRES>functions_4_1_2</REQUIRES>
	<REQUIRES>functions_4_1_3</REQUIRES>
	<REQUIRES>functions_4_1_4</REQUIRES>
	<REQUIRES>is_empty_conjunction</REQUIRES>
	<EXAMPLE>compound_queries_5_example</EXAMPLE>
	<SCHEME>
(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
	</SCHEME>
	<JAVASCRIPT>
function execute(exp) {
    return evaluate(exp, the_global_environment);
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      The
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>always-true</SCHEMEINLINE> special form</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>always_true</JAVASCRIPTINLINE> syntactic form
	</JAVASCRIPT>
      </SPLITINLINE>
      provides for a query that is always satisfied.  It ignores its contents
      (normally empty) and simply passes through all the frames in the input
      stream.
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Always-true</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The <JAVASCRIPTINLINE>always_true</JAVASCRIPTINLINE>
	expression
	</JAVASCRIPT>
      </SPLITINLINE>
      is used by the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>rule-body</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>rule_body</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      selector (section<SPACE/><REF NAME="sec:query-syntax"/>)
      <INDEX>rule (query language)<SUBINDEX>without body</SUBINDEX></INDEX>
      to provide bodies for rules that were defined without bodies (that is,
      rules whose bodies are always satisfied).
      <!--  \indcode*{always-true} -->
      <SNIPPET>
	<NAME>always_true</NAME>
	<REQUIRES>operation_table_from_chapter_3</REQUIRES>
	<REQUIRES>operation_table</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (always-true ignore frame-stream) frame-stream)

(put 'always-true 'qeval always-true)
	</SCHEME>
	<JAVASCRIPT>
function always_true(ignore, frame_stream) {
    return frame_stream;
}
put("always_true", "evaluate_query", always_true);    
	</JAVASCRIPT>
      </SNIPPET>
      <SPLITINLINE>
	<SCHEME>The selectors that define the syntax of</SCHEME>
	<JAVASCRIPT>The selectors for the syntactic forms</JAVASCRIPT>
      </SPLITINLINE>
      <SCHEMEINLINE>not</SCHEMEINLINE>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>lisp-value</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>javascript_value</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      are given in section<SPACE/><REF NAME="sec:query-syntax"/>.
      <INDEX>compound query<SUBINDEX>processing|)</SUBINDEX></INDEX>
      <INDEX>query interpreter<SUBINDEX>query evaluator|)</SUBINDEX></INDEX>
    </TEXT>
  </SUBSUBSECTION>

  <SUBSUBSECTION>
    <NAME>Finding Assertions by Pattern Matching</NAME>
    <LABEL NAME="sec:query-match"/>
    
    <TEXT>
      <INDEX>query interpreter<SUBINDEX>pattern matching|(</SUBINDEX></INDEX>
      <INDEX>pattern matching<SUBINDEX>implementation|(</SUBINDEX></INDEX>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Find-assertions</SCHEMEINLINE>,
	</SCHEME>
	<JAVASCRIPT>
	  The function <JAVASCRIPTINLINE>find_assertions</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      called by
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>simple-query</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>simple_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      (section<SPACE/><REF NAME="sec:query-eval"/>), takes as input a pattern
      and a frame. It returns a stream of frames, each extending the given one
      by a data-base match of the given pattern.  It uses
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>fetch-assertions</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>fetch_assertions</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      (section<SPACE/><REF NAME="sec:query-db"/>) to get a stream of all the
      assertions in the data base that should be checked for a match against the
      pattern and the frame.  The reason for
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>fetch-assertions</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>fetch_assertions</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      here is that we can often apply simple tests that will eliminate many of
      the entries in the data base from the pool of candidates for a successful
      match. The system would still work if we eliminated
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>fetch-assertions</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>fetch_assertions</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and simply checked a stream of all assertions in the data base, but
      the computation would be less efficient because we would need to make
      many more calls to the matcher.
      <!--  \indcode*{find-assertions} -->
      <SNIPPET>
	<NAME>find_assertions</NAME>
	<REQUIRES>stream_flatmap</REQUIRES>
	<REQUIRES>check_an_assertion</REQUIRES>
	<REQUIRES>fetch_assertions</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (find-assertions pattern frame)
  (stream-flatmap (lambda (datum)
                    (check-an-assertion datum pattern frame))
                  (fetch-assertions pattern frame)))
	</SCHEME>
	<JAVASCRIPT>
function find_assertions(pattern, frame) {
    return stream_flatmap(
              datum =>
                 check_an_assertion(datum, pattern, frame),
              fetch_assertions(pattern, frame));
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Check-an-assertion</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT>
	  The function <JAVASCRIPTINLINE>check_an_assertion</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      takes as arguments a data object (assertion), a pattern, and a frame and
      returns either a one-element stream containing the extended frame or
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>the-empty-stream</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>null</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      if the match fails.
      <SNIPPET>
	<NAME>check_an_assertion</NAME>
	<REQUIRES>pattern_match</REQUIRES>
	<REQUIRES>singleton_stream</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
	</SCHEME>
	<JAVASCRIPT>
function check_an_assertion(assertion, query_pat, query_frame) {
    const match_result = pattern_match(query_pat, assertion, 
                                       query_frame);
    return match_result === "failed"
           ? null
           : singleton_stream(match_result);
}
	</JAVASCRIPT>
      </SNIPPET>
      The basic pattern matcher returns either the
      <SPLITINLINE>
	<SCHEME>symbol <SCHEMEINLINE>failed</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>string <JAVASCRIPTINLINE>"failed"</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      or an extension of the given frame.  The basic idea of the matcher is to
      check the pattern against the data, element by element, accumulating
      bindings for the pattern variables.  If the pattern and the data
      object are the same, the match succeeds and we return the frame of
      bindings accumulated so far.  Otherwise, if the pattern is a variable
      we extend the current frame by binding the variable to the data, so
      long as this is consistent with the bindings already in the frame.  If
      the pattern and the data are both pairs, we (recursively) match the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      of the pattern against the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      of the data to produce a frame; in this frame we then match the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      of the pattern against the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      of the data.  If none of these cases are applicable, the match fails and
      we return the
      <SPLITINLINE>
	<SCHEME>symbol <SCHEMEINLINE>failed</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT>string <JAVASCRIPTINLINE>"failed"</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
      <!--  \indcode*{pattern-match} -->
      <SNIPPET>
	<NAME>pattern_match</NAME>
	<REQUIRES>extend_if_consistent</REQUIRES>
	<REQUIRES>is_var</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match (cdr pat)
                        (cdr dat)
                        (pattern-match (car pat)
                                       (car dat)
                                       frame)))
        (else 'failed)))
	</SCHEME>
	<JAVASCRIPT>
function pattern_match(pat, dat, frame) {
    return frame === "failed" 
           ? "failed"
           : equal(pat, dat) 
           ? frame   
           : is_name(pat) 
           ? extend_if_consistent(pat, dat, frame)
           : is_pair(pat) &amp;&amp; is_pair(dat)
           ? pattern_match(tail(pat),
                           tail(dat),
                           pattern_match(head(pat),
                                         head(dat),
                                         frame))
           : "failed";
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      Here is the
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      that extends a frame by adding a new binding, if this is consistent with
      the bindings already in the frame:
      <!-- mutual recursion -->
      <!-- <REQUIRES>pattern_match</REQUIRES> -->
      <!--  \indcode*{extend-if-consistent} -->
      <SNIPPET>
	<NAME>extend_if_consistent</NAME>
	<REQUIRES>make_binding</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
	</SCHEME>
	<JAVASCRIPT>
function extend_if_consistent(variable, data, frame) {
    const binding = binding_in_frame(variable, frame);
    return is_undefined(binding)
           ? extend(variable, data, frame)
           : pattern_match(binding_value(binding), data, frame);
}
	</JAVASCRIPT>
      </SNIPPET>
      If there is no binding for the variable in the frame, we simply add
      the binding of the variable to the data.  Otherwise we match, in the
      frame, the data against the value of the variable in the frame.  If
      the stored value contains only constants, as it must if it was stored
      during pattern matching by
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>extend-if-consistent</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>extend_if_consistent</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      then the match simply tests whether the stored and new values are the
      same.  If so, it returns the unmodified frame; if not, it returns a failure
      indication.  The stored value may, however, contain pattern variables
      if it was stored during unification (see
      section<SPACE/><REF NAME="sec:query-unify"/>). The recursive match of the
      stored pattern against the new data will add or check bindings for the
      variables in this pattern.  For example, suppose we have a frame in which
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      is bound to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f ?y)</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list("f", $y)</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      is unbound, and we wish to augment this frame by a binding of
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f b)</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list("f", "b")</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
      We look up
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      and find that it is bound to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f ?y)</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list("f", $y)</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
      This leads us to match
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f ?y)</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list("f", $y)</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      against the proposed new value
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f b)</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list("f", "b")</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      in the same frame.  Eventually this match extends the frame by adding a
      binding of
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>b</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>"b"</JAVASCRIPTINLINE>.</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?X</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The variable <JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      remains bound to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f ?y)</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list("f", $y)</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
      We never modify a stored binding and we never store more than one binding
      for a given variable.
    </TEXT>

    <TEXT>
      The
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      used by
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>extend-if-consistent</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>
	<JAVASCRIPTINLINE>extend_if_consistent</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      to manipulate bindings are defined in
      section<SPACE/><REF NAME="sec:query-bindings"/>.
    </TEXT>

    <SPLIT>
      <SCHEME>
	<SUBHEADING>
	  <NAME>Patterns with dotted tails</NAME>
	</SUBHEADING>

	<INDEX>dotted-tail notation
	<SUBINDEX>query@in query pattern</SUBINDEX></INDEX>
	<TEXT>
	  If a pattern contains a dot followed by a pattern variable, the
	  pattern variable matches the rest of the data list (rather than the
	  next element of the data list), just as one would expect with the
	  dotted-tail notation described in
	  exercise<SPACE/><REF NAME="ex:dotted-arglist"/>. Although the pattern
	  matcher we have just implemented doesn<APOS/>t look for dots, it does
	  behave as we want.  This is because the Lisp
	  <SCHEMEINLINE>read</SCHEMEINLINE> primitive, which is used by
	  <SCHEMEINLINE>query-driver-loop</SCHEMEINLINE> to read the query
	  and represent it as a list structure, treats dots in a special way.
	</TEXT>

	<TEXT>
	  <!-- \indprim{read}[dotted-tail notation handling by] -->
	  <INDEX>dotted-tail notation
	  <SUBINDEX>read@<SCHEMEINLINE>read</SCHEMEINLINE> and</SUBINDEX></INDEX>
	  When <SCHEMEINLINE>read</SCHEMEINLINE> sees a dot, instead of making
	  the next item be the
	  next element of a list (the <SCHEMEINLINE>car</SCHEMEINLINE> of a
	  <SCHEMEINLINE>cons</SCHEMEINLINE> whose
	  <SCHEMEINLINE>cdr</SCHEMEINLINE> will be the rest of the list) it
	  makes the next item be the <SCHEMEINLINE>cdr</SCHEMEINLINE> of the
	  list structure.  For example, the list structure produced by
	  <SCHEMEINLINE>read</SCHEMEINLINE> for the pattern
	  <SCHEMEINLINE>(computer ?type)</SCHEMEINLINE> could be constructed
	  by evaluating the expression
	  <SCHEMEINLINE>(cons 'computer (cons '?type '()))</SCHEMEINLINE>,
	  and that for <SCHEMEINLINE>(computer ?type)</SCHEMEINLINE> could be
	  constructed by evaluating the expression
	  <SCHEMEINLINE>(cons 'computer '?type)</SCHEMEINLINE>.
	</TEXT>

	<TEXT>
	  Thus, as <SCHEMEINLINE>pattern-match</SCHEMEINLINE> recursively
	  compares <SCHEMEINLINE>car</SCHEMEINLINE>s and
	  <SCHEMEINLINE>cdr</SCHEMEINLINE>s of a data list and a pattern that
	  had a dot, it eventually matches the variable after the dot (which is
	  a <SCHEMEINLINE>cdr</SCHEMEINLINE> of the pattern) against a sublist
	  of the data list, binding the variable to that list.  For example,
	  matching the pattern <SCHEMEINLINE>(computer ?type)</SCHEMEINLINE>
	  against <SCHEMEINLINE>(computer programmer trainee)</SCHEMEINLINE>
	  will match <SCHEMEINLINE>?type</SCHEMEINLINE> against the list
	  <SCHEMEINLINE>(programmer trainee)</SCHEMEINLINE>.
	  <INDEX>query interpreter<SUBINDEX>pattern matching|)</SUBINDEX></INDEX>
	  <INDEX>pattern matching<SUBINDEX>implementation|)</SUBINDEX></INDEX>
	</TEXT>
      </SCHEME>
      <JAVASCRIPT>
	<COMMENT>
	  Dotted tail notation is unnecessary in the JavaScript edition. We
	  simply use the <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE> constructor
	  rather than the <JAVASCRIPTINLINE>list</JAVASCRIPTINLINE> constructor
	  when we want to refer to the rest of a list, as shown in
	  section<SPACE/><REF NAME="sec:deductive-info-retrieval"/>.
	  See also section<SPACE/><REF NAME="sec:query-syntax"/>.
	</COMMENT>
      </JAVASCRIPT>
    </SPLIT>
  </SUBSUBSECTION>

  <SUBSUBSECTION>
    <NAME>Rules and Unification</NAME>
    <LABEL NAME="sec:query-unify"/>
    
    <TEXT>
      <INDEX>rule (query language)<SUBINDEX>applying|(</SUBINDEX></INDEX>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Apply-rules</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>
	  The function <JAVASCRIPTINLINE>apply_rules</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      is the rule analog of
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>find-assertions</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>find_assertions</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      (section<SPACE/><REF NAME="sec:query-match"/>).  It takes as input a
      pattern and a frame, and it forms a stream of extension frames by applying
      rules from the data base.
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Stream-flatmap</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>
	  The function <JAVASCRIPTINLINE>stream_flatmap</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      maps
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>apply-a-rule</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>apply_a_rule</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      down the stream of possibly applicable rules (selected by
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>fetch-rules</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>fetch_rules</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      section<SPACE/><REF NAME="sec:query-db"/>) and combines the resulting
      streams of frames.
      <!-- mutual recursion -->
      <!--  \indcode*{apply-rules} -->
      <SNIPPET>
	<NAME>apply_rules</NAME>
	<REQUIRES>stream_flatmap</REQUIRES>
	<REQUIRES>apply_a_rule</REQUIRES>
	<REQUIRES>fetch_rules</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
	</SCHEME>
	<JAVASCRIPT>
function apply_rules(pattern, frame) {
    return stream_flatmap(
              rule => 
                 apply_a_rule(rule, pattern, frame),
              fetch_rules(pattern, frame));
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Apply-a-rule</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>
	  The function <JAVASCRIPTINLINE>apply_a_rule</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      applies rules using the method outlined in
      section<SPACE/><REF NAME="sec:how-query-works"/>.  It first augments its
      argument frame by unifying the rule conclusion with the pattern in the
      given frame.  If this succeeds, it evaluates the rule body in this new
      frame.
    </TEXT>

    <TEXT>
      Before any of this happens, however, the program renames all the variables
      in the rule with unique new names.  The reason for this is to prevent the
      variables for different rule applications from becoming confused with each
      other.  For instance, if two rules both use a variable 
      <SPLITINLINE>
	<SCHEME>named<SPACE/><SCHEMEINLINE>?x</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT>named<SPACE/><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE>,</JAVASCRIPT>
      </SPLITINLINE>
      then each one may add a binding for
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      to the frame when it is applied.  These two
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE><APOS/>s</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE><APOS/>s</JAVASCRIPT>
      </SPLITINLINE>
      have nothing to do with each other, and we should not be fooled into
      thinking that the two bindings must be consistent.  Rather than rename
      variables, we could devise a more clever environment structure; however,
      the renaming approach we have chosen here is the most straightforward,
      even if not the most efficient.  (See
      exercise<SPACE/><REF NAME="ex:query-local-names"/>.)  Here is the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>apply-a-rule</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>apply_a_rule</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>procedure:</SCHEME>
	<JAVASCRIPT>function:</JAVASCRIPT>
      </SPLITINLINE>
      <SNIPPET>
	<NAME>apply_a_rule</NAME>
	<REQUIRES>rename_variables_in</REQUIRES>
	<REQUIRES>unify_match</REQUIRES>
	<REQUIRES>singleton_stream</REQUIRES>
	<REQUIRES>is_rule</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (apply-a-rule rule query-pattern query-frame)
 (let ((clean-rule (rename-variables-in rule)))
       (let ((unify-result
             (unify-match query-pattern
                          (conclusion clean-rule)
                          query-frame)))
   (if (eq? unify-result 'failed)
       the-empty-stream
       (qeval (rule-body clean-rule)
              (singleton-stream unify-result))))))
	</SCHEME>
	<JAVASCRIPT>
function apply_a_rule(rule, query_pattern, query_frame) {
    const clean_rule = rename_variables_in(rule);
    const unify_result = 
             unify_match(query_pattern,
                         conclusion(clean_rule),
                         query_frame);
    return unify_result === "failed"
           ? null
           : evaluate_query(rule_body(clean_rule),
                            singleton_stream(unify_result));
}
	</JAVASCRIPT>
      </SNIPPET>
      The selectors
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>rule-body</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>rule_body</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      and <SCHEMEINLINE>conclusion</SCHEMEINLINE> that extract parts
      of a rule are defined in section<SPACE/><REF NAME="sec:query-syntax"/>.
    </TEXT>

    <TEXT>
      We generate unique variable names by associating a unique identifier
      (such as a number) with each rule application and combining this
      identifier with the original variable names.  For example, if the
      rule-application identifier is 7, we might change each
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      in the rule to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x-7</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x_7</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      and each
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      in the rule to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y-7</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y_7</JAVASCRIPTINLINE>.</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>(<SCHEMEINLINE>Make-new-variable</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>(The functions
	<JAVASCRIPTINLINE>make_new_variable</JAVASCRIPTINLINE>
      </JAVASCRIPT></SPLITINLINE>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>new-rule-application\?id</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>new_rule_application_id</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      are included with the syntax
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      in section<SPACE/><REF NAME="sec:query-syntax"/>.)
      <SNIPPET>
	<NAME>rename_variables_in</NAME>
	<REQUIRES>new_rule_application_id</REQUIRES>
	<REQUIRES>is_var</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
	</SCHEME>
	<JAVASCRIPT>
function rename_variables_in(rule) {
    const rule_application_id = new_rule_application_id();
    function tree_walk(exp) {
        return is_name(exp) 
               ? make_new_variable(exp, rule_application_id)
               : is_pair(exp)
               ? pair(tree_walk(head(exp)),
                      tree_walk(tail(exp)))
               : exp;
    }
    return tree_walk(rule);
}
	</JAVASCRIPT>
      </SNIPPET>
      <INDEX>rule (query language)<SUBINDEX>applying|)</SUBINDEX></INDEX>
    </TEXT>

    <TEXT>
      <INDEX>query interpreter<SUBINDEX>unification|(</SUBINDEX></INDEX>
      <INDEX>unification<SUBINDEX>implementation|(</SUBINDEX></INDEX>
      The unification algorithm is implemented as a
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      that takes as inputs two patterns and a frame and returns either the
      extended frame or the
      <SPLITINLINE>
	<SCHEME>symbol <SCHEMEINLINE>failed</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT>string <JAVASCRIPTINLINE>"failed"</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
      The unifier is like the pattern matcher except that it is
      symmetrical<EMDASH/>variables are allowed on both sides of the match.
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Unify-match</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The function <JAVASCRIPTINLINE>unify_match</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      is basically the same as
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>pattern-match</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>pattern_match</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      except that there is extra code (marked
      <QUOTE><SCHEMEINLINE>***</SCHEMEINLINE></QUOTE> below) to handle
      the case where the object on the right side of the match is a variable.
      <!--  \indcode*{unify-match} -->
      <SNIPPET>
	<NAME>unify_match</NAME>
	<REQUIRES>extend_if_possible</REQUIRES>
	<REQUIRES>is_var</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame))  <EM>; ***</EM>
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
	</SCHEME>
	<JAVASCRIPT>
function unify_match(p1, p2, frame) {
    return frame === "failed"
           ? "failed"
           : equal(p1, p2)
           ? frame
           : is_name(p1) 
           ? extend_if_possible(p1, p2, frame)
           : is_name(p2) 
           ? extend_if_possible(p2, p1, frame)  // ***
           : is_pair(p1) &amp;&amp; is_pair(p2)
           ? unify_match(tail(p1),
                         tail(p2),
                         unify_match(head(p1),
                                     head(p2),
                                     frame))
           : "failed";
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      In unification, as in one-sided pattern matching, we want to accept a
      proposed extension of the frame only if it is consistent with existing
      bindings.  The
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>extend-if-possible</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>extend_if_possible</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      used in unification is the same as the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>extend-if-consistent</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>extend_if_consistent</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      used in pattern matching except for two special checks, marked
      <QUOTE><SCHEMEINLINE>***</SCHEMEINLINE></QUOTE> in the program below.  In
      the first case, if the variable we are trying to match is not bound, but
      the value we are trying to match it with is itself a (different) variable,
      it is necessary to check to see if the value is bound, and if so, to match
      its value.  If both parties to the match are unbound, we may bind either
      to the other.
    </TEXT>

    <TEXT>
      The second check deals with attempts to bind a variable to a pattern
      that includes that variable.  Such a situation can occur whenever a
      variable is repeated in both patterns.  Consider, for example,
      unifying the two patterns
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(?x ?x)</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list($x, $x)</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(?y ^expression involving^ ?y)</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>list($y,</JAVASCRIPTINLINE>
	  <LATEXINLINE>$\langle\textit{expression involving}$</LATEXINLINE>
	  <JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE><LATEXINLINE>$\rangle$</LATEXINLINE><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      in a frame where both
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      are unbound.  First
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      is matched against
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>,</JAVASCRIPT>
      </SPLITINLINE>
      making a binding of
      <SPLITINLINE>
	<SCHEME>
	<SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>.</JAVASCRIPT>
      </SPLITINLINE>
      Next, the same
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      is matched against the given
      <SPLITINLINE>
	<SCHEME>
	  expression involving	  
	  <SCHEMEINLINE>?y</SCHEMEINLINE>.
	</SCHEME>
	<JAVASCRIPT>
	  expression involving
	  <JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
      Since
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      is already bound to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>,</JAVASCRIPT>
      </SPLITINLINE>
      this results in matching
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      against the
      <SPLITINLINE>
	<SCHEME>
	  expression.
	</SCHEME>
	<JAVASCRIPT>
	  expression.
	</JAVASCRIPT>
      </SPLITINLINE>
      If we think of the unifier as finding a set of
      values for the pattern variables that make the patterns the same, then
      these patterns imply instructions to find a
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      such that
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      is equal to the expression involving
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>.</JAVASCRIPT>
      </SPLITINLINE>
      There is no general method for solving such equations, so we reject such
      bindings; these cases are recognized by the predicate 
      <SPLITINLINE><SCHEME><SCHEMEINLINE>depends-on?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>depends_on</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.<FOOTNOTE>In general,
      unifying
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>?y</SCHEMEINLINE>
	  with an expression involving
	</SCHEME>
	<JAVASCRIPT>
	  with an expression involving
	  <JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      <INDEX>fixed point<SUBINDEX>unification and</SUBINDEX></INDEX>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      would require our being able to find a fixed point of the equation
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>?y</SCHEMEINLINE>
	  <LATEXINLINE>$ = \textit{expression involving}$</LATEXINLINE>	  
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>
	  <LATEXINLINE>$ = \textit{expression involving}$</LATEXINLINE>	  
	</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>.</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>
	  It is sometimes possible to syntactically form an expression that appears
	  to be the solution.  For example,
	  <SCHEMEINLINE>?y</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT>
	  It is sometimes possible to syntactically form an expression that appears
	  to be the solution.  For example,
	  <JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      <LATEXINLINE>$=$</LATEXINLINE>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f ?y)</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list("f", $y)</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      seems to have the fixed point
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f (f (f </SCHEMEINLINE><ELLIPSIS/>
	<SCHEMEINLINE>)))</SCHEMEINLINE>,
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>list("f", list("f", list("f",</JAVASCRIPTINLINE>
	  <ELLIPSIS/>
	  <JAVASCRIPTINLINE>)))</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      which we can produce by beginning with the expression
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f ?y)</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list("f", $y)</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and repeatedly substituting
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(f ?y)</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list("f", $y)</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      for
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE>.</JAVASCRIPT>
      </SPLITINLINE>
      Unfortunately, not every such equation has a meaningful fixed point.  The
      issues that arise here are similar to the issues of manipulating 
      <INDEX>infinite series</INDEX>
      infinite series in mathematics.  For example, we know that 2 is the
      solution to the equation <LATEXINLINE>$y = 1 + y/2$</LATEXINLINE>.
      Beginning with the expression <LATEXINLINE>$1 + y/2$</LATEXINLINE> and
      repeatedly substituting <LATEXINLINE>$1 + y/2$</LATEXINLINE> for
      <LATEXINLINE>$y$</LATEXINLINE> gives
      <LATEX>
        \[ 2 = y = 1 + y/2 = 1 + (1+y/2)/2 = 1 + 1/2 + y/4 =\cdots, \]
      </LATEX>
      which leads to
      <LATEX>
        \[ 2 = 1 + 1/2 + 1/4 + 1/8 +\cdots. \]
      </LATEX>
      However, if we try the same manipulation beginning with the
      observation that <LATEXINLINE>$-1$</LATEXINLINE> is the solution to the
      equation <LATEXINLINE>$y = 1 + 2y$</LATEXINLINE>, we obtain
      <LATEX>
        \[ -1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = \cdots, \]
      </LATEX>
      which leads to 
      <LATEX>
        \[ -1 = 1 + 2 + 4 + 8 +\cdots. \]
      </LATEX>
      Although the formal manipulations used in deriving these two equations
      are identical, the first result is a valid assertion about infinite
      series but the second is not.  Similarly, for our unification results,
      reasoning with an arbitrary syntactically constructed expression may
      lead to errors.</FOOTNOTE>
      On the other hand, we do not want to reject attempts
      to bind a variable to itself.  For example, consider unifying
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(?x<SPACE/>?x)</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list($x, $x)</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>(?y<SPACE/>?y)</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>list($y, $y)</JAVASCRIPTINLINE>.</JAVASCRIPT>
      </SPLITINLINE>
      The second attempt to bind
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      to
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      matches
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>(the stored value of <SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>(the stored value of
	<JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>)
      against
      <SPLITINLINE>
	<SCHEME>
	<SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>(the new value of <SCHEMEINLINE>?x</SCHEMEINLINE>).</SCHEME>
	<JAVASCRIPT>(the new value of
	<JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>).
      </SPLITINLINE>
      This is taken care of by the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>equal?</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>equal</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      clause of
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>unify-match</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>unify_match</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
	<!-- mutual recursion -->
	<!-- <REQUIRES>unify_match</REQUIRES> -->
        <!--  \indcode*{extend-if-possible} -->
      <SNIPPET>
	<NAME>extend_if_possible</NAME>
	<REQUIRES>make_binding</REQUIRES>
	<REQUIRES>depends_on</REQUIRES>
	<REQUIRES>is_var</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                      <EM>; ***</EM>
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)     <EM>; ***</EM>
           'failed)
          (else (extend var val frame)))))
	</SCHEME>
	<JAVASCRIPT>
function extend_if_possible(variable, value, frame) {
    const binding = binding_in_frame(variable, frame);
    if (! is_undefined(binding)) {
        return unify_match(binding_value(binding), 
                            value, frame); 
    } else if (is_name(value)) {                      // ***
        const binding = binding_in_frame(value, frame);
        return ! is_undefined(binding)
               ? unify_match(variable,
                             binding_value(binding),
                             frame)
               : extend(variable, value, frame);
    } else if (depends_on(value, variable, frame)) { // ***
        return "failed";
    } else {
        return extend(variable, value, frame);
    }
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Depends-on?</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The function <JAVASCRIPTINLINE>depends_on</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      is a predicate that tests whether an expression proposed to be the value
      of a pattern variable depends on the variable. This must be done relative
      to the current frame because the expression may contain occurrences of a
      variable that already has a value that depends on our test variable.
      The structure of
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>depends-on?</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>depends_on</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      is a simple recursive tree walk in which we substitute for the values of
      variables whenever necessary.
      <SNIPPET>
	<NAME>depends_on</NAME>
	<REQUIRES>is_var</REQUIRES>
	<REQUIRES>make_binding</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
                true
                (let ((b (binding-in-frame e frame)))
                  (if b
                      (tree-walk (binding-value b))
                      false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
        (tree-walk exp))
	</SCHEME>
	<JAVASCRIPT>
function depends_on(expression, variable, frame) {
    function tree_walk(e) {
        if (is_name(e)) {
            if (equal(variable, e)) {
                return true;
            } else {
                const b = binding_in_frame(e, frame);
                return is_undefined(b)
                       ? false
                       : tree_walk(binding_value(b));
            }
	} else {
            return is_pair(e) 
                   ? tree_walk(head(e)) || tree_walk(tail(e))
                   : false;
        }
    }
    return tree_walk(expression);
}
	</JAVASCRIPT>
      </SNIPPET>
      <INDEX>query interpreter<SUBINDEX>unification|)</SUBINDEX></INDEX>
      <INDEX>unification<SUBINDEX>implementation|)</SUBINDEX></INDEX>
    </TEXT>

  </SUBSUBSECTION>

  <SUBSUBSECTION>
    <NAME>Maintaining the Data Base</NAME>
    <LABEL NAME="sec:query-db"/>
    
    <INDEX>query interpreter<SUBINDEX>data base|(</SUBINDEX></INDEX>
    <TEXT>
      <INDEX>data base
      <SUBINDEX>indexing</SUBINDEX></INDEX><INDEX>indexing a data base</INDEX>
      One important problem in designing logic programming languages is that
      of arranging things so that as few irrelevant data-base entries as
      possible will be examined in checking a given pattern. For this purpose,
      we will represent an assertion as a list whose head is a string that
      represents the kind of information of the assertion.
      <SPLITINLINE>
	<SCHEME>
	  Then, 
	  in addition to storing all assertions in one big stream,
	  we store all assertions whose
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>s</SCHEME>
	    <JAVASCRIPT>heads</JAVASCRIPT>
	  </SPLITINLINE>
	  are
	  <SPLITINLINE>
	    <SCHEME>constant symbols</SCHEME>
	    <JAVASCRIPT>strings</JAVASCRIPT>
	  </SPLITINLINE>
	  in separate streams, in a table indexed by the
	  <SPLITINLINE>
	    <SCHEME>symbol.</SCHEME>
	    <JAVASCRIPT>string.</JAVASCRIPT>
	  </SPLITINLINE>
	  To fetch an assertion that may match a pattern, we
	  <SPLITINLINE>
	    <SCHEME>
	      first
	    </SCHEME>
	  </SPLITINLINE>
	  check
	  to see if the
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
	    <JAVASCRIPT>head</JAVASCRIPT>
	  </SPLITINLINE>
	  of the pattern is a
	  <SPLITINLINE>
	    <SCHEME>constant symbol.</SCHEME>
	    <JAVASCRIPT>string.</JAVASCRIPT>
	  </SPLITINLINE>
	  If so, we return (to be tested using
	  the matcher) all the stored assertions that have the same
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>.</SCHEME>
	    <JAVASCRIPT>head.</JAVASCRIPT>
	  </SPLITINLINE>
	  If the pattern<APOS/>s
	  <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>head</JAVASCRIPT>
	  </SPLITINLINE>
	  is not a
	  <SPLITINLINE>
	    <SCHEME>constant symbol,</SCHEME>
	    <JAVASCRIPT>string,</JAVASCRIPT>
	  </SPLITINLINE>
	  we return all the stored assertions.
	  Cleverer
	  methods could also take advantage of information in the frame, or try also
	  to optimize the case where the
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
	    <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
	  </SPLITINLINE>
	  of the pattern is not a
	  <SPLITINLINE>
	    <SCHEME>constant symbol.</SCHEME>
	    <JAVASCRIPT>string.</JAVASCRIPT>
	  </SPLITINLINE>
	  We avoid building our criteria
	  for indexing (using the
	  <SPLITINLINE>
	    <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE>,</SCHEME>
	    <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>,</JAVASCRIPT>
	  </SPLITINLINE>
	  handling only the case of
	  <SPLITINLINE>
	    <SCHEME>constant symbols)</SCHEME>
	    <JAVASCRIPT>strings)</JAVASCRIPT>
	  </SPLITINLINE>
	  into the program; instead
	  we call on predicates and selectors that embody our criteria.
	</SCHEME>
	<JAVASCRIPT>
	  We store the assertions 
	  in separate streams, in a table indexed by the
	  string that is the head of the assertion.
	  To fetch an assertion that may match a pattern, we
	  return (to be tested using
	  the matcher) all the stored assertions that have the same
	  head.
	  Cleverer
	  methods could also take advantage of information in the frame.
	  We avoid building our criteria
	  for indexing 
	  into the program; instead
	  we call on predicates and selectors that embody our criteria.
	</JAVASCRIPT>
      </SPLITINLINE>
      <!--  \indcode*{fetch-assertions} -->
      <SNIPPET>
	<NAME>fetch_assertions</NAME>
	<REQUIRES>get_stream</REQUIRES>
	<REQUIRES>index_key_of</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define THE-ASSERTIONS the-empty-stream)

(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))

(define (get-all-assertions) THE-ASSERTIONS)

(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
	</SCHEME>
	<JAVASCRIPT>
function fetch_assertions(pattern, frame) {
    return get_indexed_assertions(pattern);
}
function get_indexed_assertions(pattern) {
    return get_stream(index_key_of(pattern), "assertion-stream");
}
	</JAVASCRIPT>
      </SNIPPET>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Get-stream</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The function <JAVASCRIPTINLINE>get_stream</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      looks up a stream in the table and returns an empty stream if nothing is
      stored there.
      <SNIPPET>
	<NAME>get_stream</NAME>
	<REQUIRES>operation_table_from_chapter_3</REQUIRES>
	<REQUIRES>operation_table</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
	</SCHEME>
	<JAVASCRIPT>
function get_stream(key1, key2) {
    const s = get(key1, key2);
    return is_undefined(s) ? null : s;
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      <SPLIT>
	<SCHEME>
	  Rules are stored similarly, using the
	  <SCHEMEINLINE>car</SCHEMEINLINE>
	  of the rule conclusion.  Rule conclusions are arbitrary patterns, however,
	  so they differ from assertions in that they can contain variables.
	  A pattern whose
	  <SCHEMEINLINE>car</SCHEMEINLINE>
	  is a constant symbol can match rules whose conclusions start with a
	  variable as well as rules whose conclusions have the same
	  <SCHEMEINLINE>car</SCHEMEINLINE>.
	  Thus, when fetching rules that might match a pattern whose
	  <SCHEMEINLINE>car</SCHEMEINLINE> is a
	  constant symbol we fetch all rules whose conclusions start with a
	  variable as well as those whose conclusions have the same
	  <SCHEMEINLINE>car</SCHEMEINLINE>
	  as the pattern.  For this purpose we store all rules whose conclusions
	  start with a variable in a separate stream in our table, indexed by the
	  symbol <SCHEMEINLINE>?</SCHEMEINLINE>.
	</SCHEME>
	<JAVASCRIPT>
	  Rules are stored similarly, using the head
	  of the rule conclusion.  
	  A pattern 
	  can match rules whose conclusions have the same head.
	  Thus, when fetching rules that might match a pattern
	  we fetch all rules whose conclusions have the same head
	  as the pattern.
	</JAVASCRIPT>
      </SPLIT>
      <!--  \indcode*{fetch-rules} -->
      <SNIPPET>
	<NAME>fetch_rules</NAME>
	<REQUIRES>get_stream</REQUIRES>
	<REQUIRES>index_key_of</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define THE-RULES the-empty-stream)

(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))

(define (get-all-rules) THE-RULES)

(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
	</SCHEME>
	<JAVASCRIPT>
function fetch_rules(pattern, frame) {
    return get_indexed_rules(pattern);
}
function get_indexed_rules(pattern) {
    return get_stream(index_key_of(pattern), "rule-stream");
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>
    <TEXT>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Add-rule-or-assertion!</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The function
	<JAVASCRIPTINLINE>add_rule_or_assertion</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      is used by
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>query-driver-loop</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>query_driver_loop</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      to add assertions and rules to the data base.  Each item is stored in the
      index.
        <!--  \indcode*{add-rule-or-assertion!} -->
      <SNIPPET>
	<NAME>add_rule_or_assertion</NAME>
	<REQUIRES>is_rule</REQUIRES>
	<REQUIRES>store_assertion_in_index</REQUIRES>
	<REQUIRES>fetch_assertions</REQUIRES>
	<REQUIRES>fetch_rules</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))

(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
          'ok))

(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
	</SCHEME>
	<JAVASCRIPT>
function add_rule_or_assertion(assertion) {
    return is_rule(assertion) 
           ? add_rule(assertion)
           : add_assertion(assertion);
}
function add_assertion(assertion) {
    store_assertion_in_index(assertion);
    return "ok";
}
function add_rule(rule) {
    store_rule_in_index(rule);
    return "ok";
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>  
      To actually store an assertion or a rule, we store it in the appropriate stream.
      <SNIPPET>
	<NAME>store_assertion_in_index</NAME>
	<REQUIRES>operation_table_from_chapter_3</REQUIRES>
	<REQUIRES>operation_table</REQUIRES>
	<REQUIRES>index_key_of</REQUIRES>
	<REQUIRES>get_stream</REQUIRES>
	<REQUIRES>is_rule</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
          (get-stream key 'assertion-stream)))
      (put key
           'assertion-stream
           (cons-stream assertion
                        current-assertion-stream))))))

(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
            (get-stream key 'rule-stream)))
        (put key
             'rule-stream
             (cons-stream rule
                          current-rule-stream)))))))
	</SCHEME>
	<JAVASCRIPT>
function store_assertion_in_index(assertion) {
    const key = index_key_of(assertion);
    const current_assertion_stream =
                get_stream(key, "assertion-stream");
    put(key, "assertion-stream",
        pair(assertion, () => current_assertion_stream));
}

function store_rule_in_index(rule) {
    const pattern = conclusion(rule);
    const key = index_key_of(pattern);
    const current_rule_stream =
                get_stream(key, "rule-stream");
    put(key, "rule-stream",
        pair(rule, () => current_rule_stream));
}    
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>
    <TEXT>
      <SPLIT>
	<SCHEME>
	  The following
	  procedures
	  define how the data-base index is used.  A pattern (an assertion or a rule
	  conclusion) will be stored in the table if it starts with a variable or a
	  constant symbol.
	  <SNIPPET>
	    <NAME>is_indexable</NAME>
	    <REQUIRES>is_var</REQUIRES>
	    <EXAMPLE>append_to_form_example_5</EXAMPLE>
	    <SCHEME>
	      (define (indexable? pat)
	      (or (constant-symbol? (car pat))
	      (var? (car pat))))
	    </SCHEME>
	  </SNIPPET>
	  The key under which a pattern is stored in the table is either
	  <SCHEMEINLINE>?</SCHEMEINLINE>
	  (if it starts with a variable) or the
	  constant symbol
	  with which it starts.
	</SCHEME>
	<JAVASCRIPT>
	  The key under which a pattern
	  (an assertion or rule conclusion)
	  is stored in the table is the
	string it starts with.
	</JAVASCRIPT>
      </SPLIT>
      <SNIPPET>
	<NAME>index_key_of</NAME>
	<REQUIRES>is_var</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
	</SCHEME>
	<JAVASCRIPT>
function index_key_of(pat) {
    return(head(pat));
}
	</JAVASCRIPT>
      </SNIPPET>
      <SPLIT>
	<SCHEME>
	  The index will be used to retrieve items that might match a pattern if
	  the pattern starts with a
	constant symbol.
	<SNIPPET>
	  <NAME>use_index</NAME>
	  <EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (use-index? pat)
  (constant-symbol? (car pat)))
	</SCHEME>
	</SNIPPET>
	</SCHEME>
      </SPLIT>
      </TEXT>

      <SPLIT>
	<SCHEME>
    <EXERCISE>
      What is the purpose of the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>let</SCHEMEINLINE> bindings</SCHEME>
	<JAVASCRIPT>constant declarations</JAVASCRIPT>
      </SPLITINLINE>
      in the
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>add-assertion!</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>add_assertion</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>add-rule!</SCHEMEINLINE>?</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>add_rule</JAVASCRIPTINLINE>?</JAVASCRIPT>
      </SPLITINLINE>
      What would be wrong with the following implementation of
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>add-assertion!</SCHEMEINLINE>?</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>add_assertion</JAVASCRIPTINLINE>?
	</JAVASCRIPT>
      </SPLITINLINE>
      Hint: Recall the definition of the infinite stream of ones in
      section<SPACE/><REF NAME="sec:infinite-streams"/>:
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>(define ones (cons-stream 1 ones))</SCHEMEINLINE>.
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>const ones = pair(1, () => ones);</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
	</SPLITINLINE>
      <SNIPPET>
	<NAME>add_assertion</NAME>
	<REQUIRES>store_assertion_in_index</REQUIRES>
	<REQUIRES>fetch_assertions</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
	</SCHEME>
	<JAVASCRIPT>
function add_assertion(assertion) {
    store_assertion_in_index(assertion);
    return "ok";
}
	</JAVASCRIPT>
      </SNIPPET>
    </EXERCISE>
    <INDEX>query interpreter<SUBINDEX>data base|)</SUBINDEX></INDEX>
	</SCHEME>
      </SPLIT>
      
  </SUBSUBSECTION>

  <SUBSUBSECTION>
    <NAME>Stream Operations</NAME>
    <LABEL NAME="sec:query-streams"/>
    
    <INDEX>query interpreter<SUBINDEX>stream operations|(</SUBINDEX></INDEX>
    <TEXT>
      The query system uses a few stream operations that were not presented
      in chapter<SPACE/>3.
    </TEXT>

    <TEXT>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Stream-append-delayed</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The functions
	<JAVASCRIPTINLINE>stream_append_delayed</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>interleave-delayed</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>interleave_delayed</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      are just like
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>stream\?append</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>stream_append</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and
      <SCHEMEINLINE>interleave</SCHEMEINLINE>
      (section<SPACE/><REF NAME="sec:exploiting-streams"/>),
      except that they take a delayed argument (like the
      <SCHEMEINLINE>integral</SCHEMEINLINE>
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      in section<SPACE/><REF NAME="sec:streams-and-delayed-evaluation"/>).
      This postpones looping in some cases (see
      exercise<SPACE/><REF NAME="ex:q-why-not-append"/>).
        <!--  \indcode*{stream-append-delayed} -->
        <!--  \indcode*{interleave-delayed} -->
      <SNIPPET>
	<NAME>stream_append_delayed</NAME>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed (stream-cdr s1) delayed-s2))))

(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed (force delayed-s2)
                           (delay (stream-cdr s1))))))
	</SCHEME>
	<JAVASCRIPT>
function stream_append_delayed(s1, delayed_s2) {
    return is_null(s1)
           ? delayed_s2()
           : pair(head(s1),
                  () => stream_append_delayed(stream_tail(s1),
                                              delayed_s2));
}
					      
function interleave_delayed(s1, delayed_s2) {
    return is_null(s1)
           ? delayed_s2()
           : pair(head(s1),
                  () => interleave_delayed(
                            delayed_s2(),
                            () => stream_tail(s1)));
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Stream-flatmap</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT>The function
	<JAVASCRIPTINLINE>stream_flatmap</JAVASCRIPTINLINE>,</JAVASCRIPT>
      </SPLITINLINE>
      which is used throughout the query evaluator to map a
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      over a stream of frames and combine the resulting streams of frames,
      is the stream analog of the <SCHEMEINLINE>flatmap</SCHEMEINLINE>
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      introduced for ordinary lists in
      section<SPACE/><REF NAME="sec:nested-mappings"/>. Unlike ordinary
      <SCHEMEINLINE>flatmap</SCHEMEINLINE>, however, we accumulate the streams
      with an interleaving process, rather than simply appending them (see
      exercises<SPACE/><REF NAME="ex:q-why-interleave"/>
      and<SPACE/><REF NAME="ex:q-why-delay"/>).
        <!--  \indcode*{stream-flatmap} -->
        <!--  \indcode*{flatten-stream} -->
      <SNIPPET>
	<NAME>stream_flatmap</NAME>
	<REQUIRES>stream_append_delayed</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))

(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
	</SCHEME>
	<JAVASCRIPT>
function stream_flatmap(fun, s) {
    return flatten_stream(stream_map(fun, s));
}
function flatten_stream(stream) {
    return is_null(stream)
           ? null
           : interleave_delayed(
                 head(stream),
                 () => flatten_stream(stream_tail(stream)));
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      The evaluator also uses the following simple
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      to generate a stream consisting of a single element:
        <!--  \indcode*{singleton-stream} -->
      <SNIPPET>
	<NAME>singleton_stream</NAME>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (singleton-stream x)
  (cons-stream x the-empty-stream))
	</SCHEME>
	<JAVASCRIPT>
function singleton_stream(x) {
    return pair(x, () => null);
}
	</JAVASCRIPT>
      </SNIPPET>
      <INDEX>query interpreter<SUBINDEX>stream operations|)</SUBINDEX></INDEX>
    </TEXT>
  </SUBSUBSECTION>

  <SUBSUBSECTION>
    <NAME>
      Query 
      <SPLITINLINE>
	<SCHEME>Syntax Procedures</SCHEME>
	<JAVASCRIPT>Syntax Functions</JAVASCRIPT>
      </SPLITINLINE>
    </NAME>
    <LABEL NAME="sec:query-syntax"/>

    <SPLIT>
      <JAVASCRIPT>
	<TEXT>
	  The driver loop uses 
	  <JAVASCRIPTINLINE>parse_query</JAVASCRIPTINLINE>
	  to transform an input string into an abstract expression
	  representing an assertion, a rule, or a query,
	  and 
	  <JAVASCRIPTINLINE>unparse_query</JAVASCRIPTINLINE>
	  to transform an instantiated query back to a string.
	  The input is designed to look like a
	  JavaScript expression, so that we can use the
	  <JAVASCRIPTINLINE>parse</JAVASCRIPTINLINE> function 
	  from section<SPACE/><REF NAME="sec:representing-expressions"/> to
	  transform the input string into a tagged-list representation and
	  to support JavaScript notation in the
	  <JAVASCRIPTINLINE>javascript_value</JAVASCRIPTINLINE> syntactic form.
	  For example, 
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
parse('assert(salary(list("Bitdiddle", "Ben"), 122000));')
	    </JAVASCRIPT>
	  </SNIPPET>
	  yields
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
list("application",
     list("name", "assert"),
     list(list("application",
               list("name", "salary"),
               list(list("application",
                         list("name", "list"),
                         list(list("literal", "Bitdiddle"), 
                              list("literal", "Ben"))),
                    list("literal", 122000)))))	      
	    </JAVASCRIPT>
	  </SNIPPET>
	  The tag
	  <JAVASCRIPTINLINE>"application"</JAVASCRIPTINLINE> indicates that
	  syntactically,
	  the asssertion would be treated as a function application in JavaScipt.
	  We will use a more appropriate, query-language-specific, representation
	  to identify and manipulate assertions, rules, and queries.
	  Figure<SPACE/><REF NAME="fig:syntax-abstraction-lp"/> depicts the three
	  abstraction barriers used in this section and how the functions
	  <JAVASCRIPTINLINE>parse_query</JAVASCRIPTINLINE> and
	  <JAVASCRIPTINLINE>unparse_query</JAVASCRIPTINLINE> bridge them.
	  Using the same example,
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
parse_query('assert(salary(list("Bitdiddle", "Ben"), 122000))');
	    </JAVASCRIPT>
	  </SNIPPET>
	  yields
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
list("assert", list("salary", list("Bitdiddle", "Ben"), 122000))
	    </JAVASCRIPT>
	  </SNIPPET>
	  and 
	  <JAVASCRIPTINLINE>unparse_query</JAVASCRIPTINLINE> transforms it back into a string:
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
unparse_query(parse_query('assert(salary(list("Bitdiddle", "Ben"), 122000))'));
	    </JAVASCRIPT>
	    <JAVASCRIPT_OUTPUT>
'assert(salary(list("Bitdiddle", "Ben"), 122000))'
	    </JAVASCRIPT_OUTPUT>
	  </SNIPPET>
          <FIGURE>
            <FIGURE src="img_javascript/ch4-syntax-abstraction-logic-programming.svg"></FIGURE>
            <CAPTION>Syntax abstraction in the query system.</CAPTION>
            <LABEL NAME="fig:syntax-abstraction-lp"/>
          </FIGURE>
	</TEXT>
      <SUBHEADING>
      <NAME>The function <JAVASCRIPTINLINE>parse_query</JAVASCRIPTINLINE></NAME>
      </SUBHEADING>
      <TEXT>
	  <INDEX>query interpreter
	  <SUBINDEX>pattern-variable representation|(</SUBINDEX></INDEX>
	  <INDEX>pattern variable
	  <SUBINDEX>representation of|(</SUBINDEX></INDEX>
	  The function <JAVASCRIPTINLINE>parse_query</JAVASCRIPTINLINE>
	  transforms an input string into the query-language-specific
	  representation. 
	  The string (looking like a JavaScript expression)
	  is transformed into a statement string by attaching a semicolon at the
	  end, and <JAVASCRIPTINLINE>parse</JAVASCRIPTINLINE> translates
	  the statement into a JavaScript syntax representation according to the
	  specification of
	  section<SPACE/><REF NAME="sec:representing-expressions"/>.
	  The function <JAVASCRIPTINLINE>query_syntax_process</JAVASCRIPTINLINE>
	  recursively transforms that JavaScript syntax representation into
	  the query-language-specific representation by tagging the
	  subexpressions of assertions, rules, and queries with their kind of information
	  or syntactic form and by
	  transforming applications of
	  <JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
	  and <JAVASCRIPTINLINE>list</JAVASCRIPTINLINE> to JavaScript pairs
	  and lists, respectively.
	  <SNIPPET>
	    <NAME>process_query</NAME>
	    <REQUIRES>functions_4_1_2</REQUIRES>
	    <EXAMPLE>append_to_form_example_5</EXAMPLE>
	    <JAVASCRIPT>
function parse_query(input) {
    const exp = parse(input + ";");
    return query_syntax_process(exp);
}

function query_syntax_process(exp) {
    if (is_application(exp)) {
      const function_symbol = symbol_of_name(function_expression(exp));
      if (function_symbol === "javascript_value") {
          return pair(function_symbol, arg_expressions(exp));
      } else {
          const processed_args = map(query_syntax_process, arg_expressions(exp));
          return function_symbol === "pair"
                 ? pair(head(processed_args), head(tail(processed_args)))
                 : function_symbol === "list"
                 ? processed_args
                 : pair(function_symbol, processed_args);
      }
    } else if (is_name(exp)) {
      return exp;
    } else if (is_literal(exp)) {
      return literal_value(exp);
    } else {
      error(exp, "unknown query syntax -- query_syntax_process");
    }
}
	    </JAVASCRIPT>
	  </SNIPPET>
	  For example, the query-language-specific representation of the pattern
	  <JAVASCRIPTINLINE>job($x, $y)</JAVASCRIPTINLINE> is 
	  <JAVASCRIPTINLINE>list("job", list("name", "$x"), list("name", "$y"))</JAVASCRIPTINLINE>.
      </TEXT>
      <TEXT>
	  An exception to this processing is the
	  <JAVASCRIPTINLINE>javascript_value</JAVASCRIPTINLINE>
	  syntactic form. Since the instantiated
	  representation
	  of the argument of this syntactic form is passed to the
	  <JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>
	  function of section<SPACE/><REF NAME="sec:core-of-evaluator"/>,
	  the original JavaScript syntax representation coming from
	  <JAVASCRIPTINLINE>parse</JAVASCRIPTINLINE>	  
	  needs to remain intact in the query-language-specific representation.
	  In this example
	  of section<SPACE/><REF NAME="sec:deductive-info-retrieval"/>
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
and(salary($person, $amount), javascript_value($amount &gt; 50000))	  
	    </JAVASCRIPT>
	  </SNIPPET>
	  <JAVASCRIPTINLINE>parse_query</JAVASCRIPTINLINE> produces a data structure
	  that combines the query-language specific representation with the JavaScript
	  syntax respresentation:
	  <SNIPPET EVAL="no">
	    <JAVASCRIPT>
parse_query("and(salary($person, $amount), javascript_value($amount &gt; 50000))");
	    </JAVASCRIPT>
	    <JAVASCRIPT_OUTPUT>
	      
	    </JAVASCRIPT_OUTPUT>
	  </SNIPPET>
	  needs to instantiate both occurrences of the variable
	  <JAVASCRIPTINLINE>$amount</JAVASCRIPTINLINE>.
      </TEXT>
      
      <SUBHEADING>
	<NAME>The function <JAVASCRIPTINLINE>unparse_query</JAVASCRIPTINLINE></NAME>
      </SUBHEADING>

      <TEXT>
	The function <JAVASCRIPTINLINE>unparse_query</JAVASCRIPTINLINE>
	distinguishes between simple queries, which are unparsed using
	<JAVASCRIPTINLINE>unparse_term</JAVASCRIPTINLINE>, and 
	compound queries, whose components are unparsed recursively.
	  <SNIPPET>
	    <NAME>contract_question_mark</NAME>
	    <REQUIRES>functions_4_1_2</REQUIRES>
	    <REQUIRES>unparse_term</REQUIRES>
	    <EXAMPLE>append_to_form_example_5</EXAMPLE>
	    <JAVASCRIPT>
function unparse_query(query) {
    return is_null(member(head(query), list("and", "or", "not")))
           ? unparse(head(query), tail(query), unparse_term)
           : unparse(head(query), tail(query), unparse_query);
}
function unparse(expression_head, args, arg_unparse) {	
    return expression_head + "(" + comma_separated(map(arg_unparse, args)) + ")";
}
function comma_separated(strings) {
    return accumulate((s, acc) => s + (acc === "" ? "" : ", " + acc),
                      "", strings);
}
	    </JAVASCRIPT>
	  </SNIPPET>
	  The function <JAVASCRIPTINLINE>unparse_term</JAVASCRIPTINLINE>
	  formats any remaining unbound pattern variables (taking
	  the symbol after its tag) and JavaScript literals (using
	  <JAVASCRIPTINLINE>stringify</JAVASCRIPTINLINE>).
	  Lists and
          pairs of data are formatted to look like applications of JavaScript's
          list and pair constructors, respectively.
	  The subexpression of
	  <JAVASCRIPTINLINE>javascript_value</JAVASCRIPTINLINE> queries
	  may contain JavaScript syntactic forms other than literals
	  such as operator combinations,
	  which are handled
	  by transforming them into strings according to the JavaScript
	  syntax described in section<SPACE/><REF NAME="sec:representing-expressions"/>.
	  (See also exercise<SPACE/><REF NAME="ex:parse"/>).
	  <SNIPPET LATEX="yes">
	    <NAME>unparse_term</NAME>
	    <REQUIRES>is_data_list</REQUIRES>
	    <JAVASCRIPT>
function unparse_term(arg) {
    return is_var(arg)
           ? head(tail(arg))
           : is_operator_combination(arg)
           ? "(" + unparse_term(operator_combination_first_operand(arg)) +
             " " + operator_combination_operator_symbol(arg) +
             " " + unparse_term(operator_combination_second_operand(arg)) +
             ")"
	   $\langle processing$ $of$ $other$ $JavaScript$ $non$-$literal$ $syntactic$ $forms \rangle$
           : is_data_list(arg)
           ? unparse("list", arg, unparse_term)
           : is_pair(arg) 
           ? unparse("pair", list(head(arg), tail(arg)), unparse_term)
           : stringify(arg); // literals
}
	    </JAVASCRIPT>
	  </SNIPPET>
	  The function
	  <JAVASCRIPTINLINE>is_data_list</JAVASCRIPTINLINE> ensures
	  that variables, represented by tagged lists,
	  are not mistaken for data lists.
	  <SNIPPET LATEX="yes">
	    <NAME>is_data_list</NAME>
	    <JAVASCRIPT>
function is_data_list(x) {
    return is_null(x) ||
           (is_pair(x) &amp;&amp;
            is_null(member(head(x), 
                           list("var", "operator_combination", "literal", 
                                $\langle tags$ $of$ $other$ $syntactic$ $forms \rangle$))) &amp;&amp;
            is_data_list(tail(x)));
}
	    </JAVASCRIPT>
	  </SNIPPET>
      </TEXT>

      <SUBHEADING>
	<NAME>Predicates, Selectors, and Constructors</NAME>
      </SUBHEADING>
      
      <TEXT>
	For the syntax predicate
	<JAVASCRIPTINLINE>is_dollar_name</JAVASCRIPTINLINE> that	
	identifies JavaScript names that start with a dollar
	sign, we assume there is a function <JAVASCRIPTINLINE>char_at</JAVASCRIPTINLINE> that
	returns a single-character string containing the character of the given string
	at the given position.<FOOTNOTE>The actual way to get the string that
	contains the first
	character from of a string <JAVASCRIPTINLINE>s</JAVASCRIPTINLINE> in JavaScript is
	<JAVASCRIPTINLINE>s.charAt(0)</JAVASCRIPTINLINE>.
      </FOOTNOTE>
      <SNIPPET EVAL="no">
	<JAVASCRIPT>
function is_dollar_name(exp) {
    const symbol = symbol_of_name(exp);
    return char_at(symbol, 0) === "$";
}	  
	</JAVASCRIPT>
      </SNIPPET>
	</TEXT>
	<TEXT>
	  The predicate for identifying
	  variables in the query-language-specific representation
	  checks for the tag
	  <JAVASCRIPTINLINE>"var"</JAVASCRIPTINLINE>.
	  <SNIPPET>
	    <NAME>is_var</NAME>
	    <REQUIRES>functions_4_1_2</REQUIRES>
	    <EXAMPLE>append_to_form_example_5</EXAMPLE>
	    <JAVASCRIPT>
function is_var(exp) {
    return is_tagged_list(exp, "var");
}
	    </JAVASCRIPT>
	  </SNIPPET>
	</TEXT>
	<TEXT>
	  Unique variables are constructed during rule application
	  (in section<SPACE/><REF NAME="sec:query-unify"/>) by means of
	  the following functions.
	  The unique identifier for a rule application is a number, which is
	  incremented each time a rule is applied.
	  <SNIPPET>
	    <NAME>new_rule_application_id</NAME>
	    <EXAMPLE>append_to_form_example_5</EXAMPLE>
	    <JAVASCRIPT>
let rule_counter = 0;

function new_rule_application_id() {
    rule_counter = rule_counter + 1;
    return rule_counter;
}
function make_new_var(variable, rule_application_id) {
    return list("var", head(tail(variable)) + stringify(rule_application_id));
}
	    </JAVASCRIPT>
	  </SNIPPET>
	</TEXT>
      </JAVASCRIPT>
    </SPLIT>

    <INDEX>query interpreter
    <SUBINDEX>syntax of query language|(</SUBINDEX></INDEX>
    <TEXT>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Type</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT>The functions <JAVASCRIPTINLINE>type</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and <SCHEMEINLINE>contents</SCHEMEINLINE>, used by
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>qeval</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>evaluate_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      (section<SPACE/><REF NAME="sec:query-eval"/>), specify that a
      <SPLITINLINE>
	<SCHEME>special form</SCHEME>
	<JAVASCRIPT>syntactic form</JAVASCRIPT>
      </SPLITINLINE>
      is identified by
      <SPLITINLINE>
	<SCHEME>the symbol in its <SCHEMEINLINE>car</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT>the string in its head.
	</JAVASCRIPT>
      </SPLITINLINE>
      They are the same as the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>type-tag</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>type_tag</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and <SCHEMEINLINE>contents</SCHEMEINLINE>
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      in section<SPACE/><REF NAME="sec:manifest-types"/>, except for the
      error message.
      <SNIPPET>
	<NAME>type</NAME>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<REQUIRES>functions_4_1_2</REQUIRES>
	<SCHEME>
(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Unknown expression TYPE" exp)))

(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Unknown expression CONTENTS" exp)))
	</SCHEME>
	<JAVASCRIPT>
function type(exp) {
    return is_pair(exp)
           ? head(exp)
           : error(exp, "Unknown expression type");
}
function contents(exp) {
    return is_pair(exp)
           ? tail(exp)
           : error(exp, "Unknown expression contents");
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      The following
      <SPLITINLINE>
	<SCHEME>procedures,</SCHEME>
	<JAVASCRIPT>functions,</JAVASCRIPT>
      </SPLITINLINE>
      used by
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>query-driver-loop</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>query_driver_loop</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      (in section<SPACE/><REF NAME="sec:query-driver"/>), specify
      that rules and assertions are added to the data base by expressions of
      the form
      <SPLITINLINE>
	<SCHEME>
	<SCHEMEINLINE>(assert! ^rule-or-assertion^)</SCHEMEINLINE>:</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>assert(</JAVASCRIPTINLINE><LATEXINLINE>$\textit{rule-or-assertion}$</LATEXINLINE><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>:
	</JAVASCRIPT>
      </SPLITINLINE>
      <SNIPPET>
	<NAME>is_assertion</NAME>
	<REQUIRES>type</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))

(define (add-assertion-body exp)
  (car (contents exp)))
	</SCHEME>
	<JAVASCRIPT>
function is_assertion(exp) {
    return type(exp) === "assert";
}
function assertion_body(exp) {
    return head(contents(exp));
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>

    <TEXT>
      <SPLITINLINE>
	<SCHEME>
	  Here are the syntax definitions for the <SCHEMEINLINE>and</SCHEMEINLINE>,
	</SCHEME>
	<JAVASCRIPT>
	  Here are the declarations of the predicates and selectors
	  for the <SCHEMEINLINE>and</SCHEMEINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      <SCHEMEINLINE>or</SCHEMEINLINE>, <SCHEMEINLINE>not</SCHEMEINLINE>, and
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>lisp-value</SCHEMEINLINE> special forms
	</SCHEME>
	<JAVASCRIPT>
	  <JAVASCRIPTINLINE>javascript_value</JAVASCRIPTINLINE>
	  syntactic forms
	</JAVASCRIPT>
      </SPLITINLINE>
      (section<SPACE/><REF NAME="sec:query-eval"/>):
      <SNIPPET>
	<NAME>is_empty_conjunction</NAME>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))

(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))

(define (negated-query exps) (car exps))

(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
	</SCHEME>
	<JAVASCRIPT>
function is_empty_conjunction(exps) { return is_null(exps); }
function first_conjunct(exps) { return head(exps); }
function rest_conjuncts(exps) { return tail(exps); }

function is_empty_disjunction(exps) { return is_null(exps); }
function first_disjunct(exps) { return head(exps); }
function rest_disjuncts(exps) { return tail(exps); }

function negated_query(exps) { return head(exps); }

function javascript_expression(exps) { return head(exps); }
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>
    <TEXT>
      The following three
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>
	  define the syntax of rules:
	</SCHEME>
	<JAVASCRIPT>
	  define the query-language-specific representation of rules;
	</JAVASCRIPT>
      </SPLITINLINE>
      <SNIPPET>
	<NAME>is_rule</NAME>
	<REQUIRES>functions_4_1_2</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (rule? statement)
  (tagged-list? statement 'rule))

(define (conclusion rule) (cadr rule))

(define (rule-body rule)
  (if (null? (cddr rule))
      '(always-true)
      (caddr rule)))
	</SCHEME>
	<JAVASCRIPT>
function is_rule(assertion) {
    return is_tagged_list(assertion, "rule");
}
function conclusion(rule) {
    return head(tail(rule));
}
function rule_body(rule) {
    return is_null(tail(tail(rule)))
           ? list("always_true")
           : head(tail(tail(rule)));
}
	</JAVASCRIPT>
      </SNIPPET>
    </TEXT>
    <SPLIT>
      <SCHEME>
	<TEXT>
	  <INDEX>query interpreter
	  <SUBINDEX>pattern-variable representation|(</SUBINDEX></INDEX>
	  <INDEX>pattern variable
	  <SUBINDEX>representation of|(</SUBINDEX></INDEX>
	  <SCHEMEINLINE>Query-driver-loop</SCHEMEINLINE>
	  (section<SPACE/><REF NAME="sec:query-driver"/>) calls
	  <SCHEMEINLINE>query-syntax-process</SCHEMEINLINE>
	  to transform pattern variables in the expression, which
	  have the form <SCHEMEINLINE>?symbol</SCHEMEINLINE>,
	  into the internal format <SCHEMEINLINE>(? symbol)</SCHEMEINLINE>.
	  That is to say, a pattern such as
	  <SCHEMEINLINE>(job ?x ?y)</SCHEMEINLINE> is actually represented
	  internally by the system as
	  <SCHEMEINLINE>(job (? x) (? y))</SCHEMEINLINE>. This increases the
	  efficiency of query processing, since it means that the system can
	  check to see if an expression is a pattern variable by checking
	  whether the <SCHEMEINLINE>car</SCHEMEINLINE> of the expression is the
	  symbol <SCHEMEINLINE>?</SCHEMEINLINE>, rather than having to extract
	  characters from the symbol. The syntax transformation is accomplished
	  by the following procedure:<FOOTNOTE>Most Lisp systems give the user
	  the ability to modify the ordinary <SCHEMEINLINE>read</SCHEMEINLINE>
	  procedure to perform such transformations by defining 
	  <INDEX>reader macro character</INDEX>
	  <!-- \indprim{read}[macro characters]-->
	  <!-- \indcodeplus{'}{(single quote)}[read@
	       <SCHEMEINLINE>read</SCHEMEINLINE> and]-->
	  <!-- \indsf{quote}[read@<SCHEMEINLINE>read</SCHEMEINLINE> and]-->
	  <EM>reader macro characters</EM>.  Quoted
	  expressions are already handled in this way: The reader automatically
	  translates <SCHEMEINLINE>'expression</SCHEMEINLINE> into
	  <SCHEMEINLINE>(quote expression)</SCHEMEINLINE> before the
	  evaluator sees it.  We could arrange for
	  <SCHEMEINLINE>?expression</SCHEMEINLINE> to be transformed into
	  <SCHEMEINLINE>(? expression)</SCHEMEINLINE> in the same way; however,
	  for the sake of clarity we have included the transformation
	  procedure here explicitly.
	  <P/>
	  <INDEX>character strings<SUBINDEX>primitive
	  procedures for</SUBINDEX></INDEX>
	  <SCHEMEINLINE>Expand-question-mark</SCHEMEINLINE> and
	  <SCHEMEINLINE>contract-question-mark</SCHEMEINLINE> use several
	  procedures with <SCHEMEINLINE>string</SCHEMEINLINE> in their names.
	  These are Scheme primitives.</FOOTNOTE>
          <!--  \indcode*{map-over-symbols} -->
	  <SNIPPET>
	    <NAME>query_process_scheme</NAME>
	    <SCHEME>
(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))

(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))

(define (expand-question-mark symbol)
  (let ((chars (symbol-&gt;string symbol)))
    (if (string=? (substring chars 0 1) "?")
        (list '?
              (string-&gt;symbol
               (substring chars 1 (string-length chars))))
        symbol)))
	    </SCHEME>
	  </SNIPPET>
	</TEXT>
	<TEXT>
	  Once the variables are transformed in this way, the variables in a
	  pattern are lists starting with	  
	  <SCHEMEINLINE>?</SCHEMEINLINE>,
	  and the constant symbols
	  (which need to be recognized for
	  data-base indexing, section<SPACE/><REF NAME="sec:query-db"/>) are
	  just the symbols.
	  <SNIPPET>
	    <NAME>is_var_scheme</NAME>
	    <REQUIRES>functions_4_1_2</REQUIRES>
	    <EXAMPLE>append_to_form_example_5</EXAMPLE>
	    <SCHEME>
	      (define (var? exp)
	      (tagged-list? exp '?))

	      (define (constant-symbol? exp) (symbol? exp))
	    </SCHEME>
	  </SNIPPET>
	</TEXT>
	<TEXT>
	  Unique variables are constructed during rule application
	  (in section<SPACE/><REF NAME="sec:query-unify"/>) by means of
	  the following procedures.
	  The unique identifier for a rule application is a number, which is
	  incremented each time a rule is applied.
	  <SNIPPET>
	    <NAME>new_rule_application_id</NAME>
	    <EXAMPLE>append_to_form_example_5</EXAMPLE>
	    <SCHEME>
	      (define rule-counter 0)

	      (define (new-rule-application-id)
	      (set! rule-counter (+ 1 rule-counter))
	      rule-counter)

	      (define (make-new-variable var rule-application-id)
	      (cons '? (cons rule-application-id (cdr var))))
	    </SCHEME>
	  </SNIPPET>
	</TEXT>
	<TEXT>
	  When <SCHEMEINLINE>query-driver-loop</SCHEMEINLINE> instantiates the
	  query to print the answer, it converts any unbound pattern variables
	  back to the right form for printing, using
	  <SNIPPET>
	    <NAME>contract_question_mark_scheme</NAME>
	    <SCHEME>
(define (contract-question-mark variable)
  (string-&gt;symbol
   (string-append "?" 
     (if (number? (cadr variable))
         (string-append (symbol-&gt;string (caddr variable))
                                     "-"
                                     (number-&gt;string (cadr variable)))
         (symbol-&gt;string (cadr variable))))))
	    </SCHEME>
	  </SNIPPET>
	  <INDEX>query interpreter
	  <SUBINDEX>pattern-variable representation|)</SUBINDEX></INDEX>
	  <INDEX>pattern variable<SUBINDEX>representation of|)</SUBINDEX></INDEX>
	  <INDEX>query interpreter
	  <SUBINDEX>syntax of query language|)</SUBINDEX></INDEX>
	</TEXT>
      </SCHEME>
      </SPLIT>
  </SUBSUBSECTION>

  <SUBSUBSECTION>
    <NAME>Frames and Bindings</NAME>
    <LABEL NAME="sec:query-bindings"/>

    <TEXT>
      <INDEX>query interpreter<SUBINDEX>frame|(</SUBINDEX></INDEX>
      <INDEX>frame (query interpreter)<SUBINDEX>representation</SUBINDEX></INDEX>
      Frames are represented as lists of bindings, which are
      variable-value pairs:
      <SNIPPET>
	<NAME>make_binding</NAME>
	<REQUIRES>operation_table_from_chapter_3</REQUIRES>
	<REQUIRES>operation_table</REQUIRES>
	<EXAMPLE>append_to_form_example_5</EXAMPLE>
	<SCHEME>
(define (make-binding variable value)
  (cons variable value))

(define (binding-variable binding)
  (car binding))

(define (binding-value binding)
  (cdr binding))

(define (binding-in-frame variable frame)
  (assoc variable frame))

(define (extend variable value frame)
  (cons (make-binding variable value) frame))
	</SCHEME>
	<JAVASCRIPT>
function make_binding(variable, value) {
    return pair(variable, value);
}
function binding_variable(binding) {
    return head(binding);
}
function binding_value(binding) {
    return tail(binding);
}
function binding_in_frame(variable, frame) {
    return assoc(variable, frame);
}
function extend(variable, value, frame) {
    return pair(make_binding(variable, value), frame);
}
	</JAVASCRIPT>
      </SNIPPET>
      <INDEX>query interpreter<SUBINDEX>frame|)</SUBINDEX></INDEX>
    </TEXT>

    <EXERCISE>
      Louis Reasoner wonders why the
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>simple-query</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>simple_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      and <SCHEMEINLINE>disjoin</SCHEMEINLINE>
      <SPLITINLINE>
	<SCHEME>procedures</SCHEME>
	<JAVASCRIPT>functions</JAVASCRIPT>
      </SPLITINLINE>
      (section<SPACE/><REF NAME="sec:query-eval"/>) are implemented using
      <SPLITINLINE>
	<SCHEME>
	  explicit <SCHEMEINLINE>delay</SCHEMEINLINE>
	  operations, 
	</SCHEME>
	<JAVASCRIPT>delayed expressions</JAVASCRIPT>
      </SPLITINLINE>
      rather than being defined as follows:
      <!-- mutual recursion -->
      <SNIPPET EVAL="no">
	<NAME>simple_query_pattern</NAME>
	<REQUIRES>stream_flatmap</REQUIRES>
	<REQUIRES>find_assertions</REQUIRES>
	<REQUIRES>apply_rules</REQUIRES>
	<REQUIRES>is_empty_conjunction</REQUIRES>
	<SCHEME>
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append (find-assertions query-pattern frame)
                    (apply-rules query-pattern frame)))
   frame-stream))

(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts) frame-stream)
       (disjoin (rest-disjuncts disjuncts) frame-stream))))
	</SCHEME>
	<JAVASCRIPT>
function simple_query(query_pattern, frame_stream) {
    return stream_flatmap(
               frame =>
                   stream_append(
                       find_assertions(query_pattern, frame),
                       apply_rules(query_pattern, frame)),
               frame_stream);
}
function disjoin(disjuncts, frame_stream) {
    return is_empty_disjunction(disjuncts)
           ? null
           : interleave(
                 evaluate_query(first_disjunct(disjuncts), frame_stream),
                 disjoin(rest_disjuncts(disjuncts), frame_stream));
}
	</JAVASCRIPT>
      </SNIPPET>
      Can you give examples of queries where these simpler definitions would
      lead to undesirable behavior?
      <LABEL NAME="ex:q-why-not-append"/>
    </EXERCISE>

    <EXERCISE>
      Why do <SCHEMEINLINE>disjoin</SCHEMEINLINE> and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>stream-flatmap</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>stream_flatmap</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      interleave the streams rather than simply append them?  Give examples that
      illustrate why interleaving works better.  (Hint: Why did we use
      <SCHEMEINLINE>interleave</SCHEMEINLINE> in
      section<SPACE/><REF NAME="sec:exploiting-streams"/>?)
      <LABEL NAME="ex:q-why-interleave"/>
    </EXERCISE>

    <EXERCISE><LABEL NAME="ex:q-why-delay"/>
    Why does
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>flatten-stream</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>flatten_stream</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    use
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>delay</SCHEMEINLINE> explicitly?</SCHEME>
      <JAVASCRIPT>a delayed expression in its body?</JAVASCRIPT>
    </SPLITINLINE>
    What would be wrong with defining it as follows:
    <SNIPPET EVAL="no">
      <NAME>flatten_stream</NAME>
      <SCHEME>
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
      </SCHEME>
      <JAVASCRIPT>
function flatten_stream(stream) {
    return is_null(stream)
           ? null
           : interleave(head(stream),
                        flatten_stream(stream_tail(stream)));
}
      </JAVASCRIPT>
    </SNIPPET>
    </EXERCISE>

    <EXERCISE>
      <!--  \indcode{stream-flatmap} -->
      Alyssa P. Hacker proposes to use a simpler version of
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>stream-flatmap</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>stream_flatmap</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      in <SCHEMEINLINE>negate</SCHEMEINLINE>,
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>lisp-value</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>javascript_value</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>find-assertions</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>find_assertions</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
      She observes that the
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      that is mapped over the frame stream in these cases always produces either
      the empty stream or a singleton stream, so no interleaving is needed when
      combining these streams.
      <OL>
	<LI>
          Fill in the missing expressions in Alyssa<APOS/>s program.
          <SNIPPET EVAL="no" LATEX="yes">
	    <NAME>simple_stream_flatmap</NAME>
	    <SCHEME>
(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))

(define (simple-flatten stream)
  (stream-map ^??^
              (stream-filter ^??^ stream)))
	    </SCHEME>
	    <JAVASCRIPT>
function simple_stream_flatmap(fun, s) {
    return simple_flatten(stream_map(fun, s));
}
function simple_flatten(stream) {
    return stream_map($\langle ?? \rangle$,
                      stream_filter($\langle ?? \rangle$, stream));
}
	    </JAVASCRIPT>
          </SNIPPET>
	</LI>
	<LI>
          Does the query system<APOS/>s behavior change if we change it in this
	  way?
	</LI>
      </OL>
    </EXERCISE>

    <EXERCISE>
      <INDEX>query language<SUBINDEX>extensions to</SUBINDEX></INDEX>
      <INDEX>compound query<SUBINDEX>processing</SUBINDEX></INDEX>
      <!-- \indcodeplus{unique}{(query language)}-->
      Implement for the query language a
      <SPLITINLINE>
	<SCHEME>new special form called
	<SCHEMEINLINE>unique</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT>syntactic form called
	<JAVASCRIPTINLINE>unique</JAVASCRIPTINLINE>.</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>Unique</SCHEMEINLINE>
	</SCHEME>
	<JAVASCRIPT>
	  Applictions of <JAVASCRIPTINLINE>unique</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      should succeed if there is precisely one item in the data base satisfying
      a specified query.  For example,
      <SNIPPET EVAL="no">
	<NAME>unique_example_1</NAME>
	<SCHEME>
(unique (job ?x (computer wizard)))
	</SCHEME>
	<JAVASCRIPT>
unique(job($x, list("computer", "wizard")))
	</JAVASCRIPT>
      </SNIPPET>
      should print the one-item stream
      <SNIPPET EVAL="no">
	<NAME>unique_example_2</NAME>
	<SCHEME>
(unique (job (Bitdiddle Ben) (computer wizard)))
	</SCHEME>
	<JAVASCRIPT>
unique(job(list("Bitdiddle", "Ben"), list("computer", "wizard")))
	</JAVASCRIPT>
      </SNIPPET>
      since Ben is the only computer wizard, and
      <SNIPPET EVAL="no">
	<NAME>unique_example_3</NAME>
	<SCHEME>
(unique (job ?x (computer programmer)))
	</SCHEME>
	<JAVASCRIPT>
unique(job($x, list("computer", "programmer")))
	</JAVASCRIPT>
      </SNIPPET>
      should print the empty stream, since there is more than one computer
      programmer.  Moreover,
      <SNIPPET EVAL="no">
	<NAME>unique_example_4</NAME>
	<SCHEME>
(and (job ?x ?j) (unique (job ?anyone ?j)))
	</SCHEME>
	<JAVASCRIPT>
and(job($x, $j), unique(job($anyone, $j)))
	</JAVASCRIPT>
      </SNIPPET>
      should list all the jobs that are filled by only one person, and the
      people who fill them.
      <P/>
      There are two parts to implementing <SCHEMEINLINE>unique</SCHEMEINLINE>.
      The first is to write a
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      that handles this
      <SPLITINLINE>
	<SCHEME>special</SCHEME>
	<JAVASCRIPT>syntactic</JAVASCRIPT>
      </SPLITINLINE>
      form, and the second is to make
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>qeval</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>evaluate_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      dispatch to that
      <SPLITINLINE>
	<SCHEME>procedure.</SCHEME>
	<JAVASCRIPT>function.</JAVASCRIPT>
      </SPLITINLINE>
      The second part is trivial, since
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>qeval</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>evaluate_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      does its dispatching in a data-directed way.  If your
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      is called
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>uniquely-asserted</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>uniquely_asserted</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      all you need to do is
      <SNIPPET EVAL="no">
	<NAME>put_unique</NAME>
	<REQUIRES>operation_table_from_chapter_3</REQUIRES>
	<REQUIRES>operation_table</REQUIRES>
	<SCHEME>
(put 'unique 'qeval uniquely-asserted)
	</SCHEME>
	<JAVASCRIPT>
put("unique", "evaluate_query", uniquely_asserted);
	</JAVASCRIPT>
      </SNIPPET>
      and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>qeval</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>evaluate_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      will dispatch to this
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      for every query whose
      <SCHEMEINLINE>type</SCHEMEINLINE>
      <SPLITINLINE>
	<SCHEME>(<SCHEMEINLINE>car</SCHEMEINLINE>)</SCHEME>
	<JAVASCRIPT>(<JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>)</JAVASCRIPT>
      </SPLITINLINE>
      is the
      <SPLITINLINE>
	<SCHEME>symbol</SCHEME>
	<JAVASCRIPT>string</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>unique</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>"unique"</JAVASCRIPTINLINE></JAVASCRIPT>
      </SPLITINLINE>
      <P/>
      The real problem is to write the
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>uniquely-asserted</SCHEMEINLINE>.</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>uniquely_asserted</JAVASCRIPTINLINE>.
	</JAVASCRIPT>
      </SPLITINLINE>
      This should take as input the <SCHEMEINLINE>contents</SCHEMEINLINE>
      <SPLITINLINE>
	<SCHEME>(<SCHEMEINLINE>cdr</SCHEMEINLINE>)</SCHEME>
	<JAVASCRIPT>(tail)</JAVASCRIPT>
      </SPLITINLINE>
      of the <SCHEMEINLINE>unique</SCHEMEINLINE> query, together with a stream
      of frames.  For each frame in the stream, it should use
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>qeval</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>evaluate_query</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      to find the stream of all extensions to the frame that satisfy the given
      query.  Any stream that does not have exactly one item in it should be
      eliminated.  The remaining streams should be passed back to be accumulated
      into one big stream that is the result of the
      <SCHEMEINLINE>unique</SCHEMEINLINE> query.  This is similar to the
      implementation of the <SCHEMEINLINE>not</SCHEMEINLINE>
      <SPLITINLINE>
	<SCHEME>special</SCHEME>
	<JAVASCRIPT>syntactic</JAVASCRIPT>
      </SPLITINLINE>
      form.
      <P/>
      Test your implementation by forming a query that lists all people who
      supervise precisely one person.
      <LABEL NAME="ex:unique"/>
    </EXERCISE>

    <EXERCISE>
      <INDEX>query interpreter<SUBINDEX>improvements to</SUBINDEX></INDEX>
      <!-- \indcodeplus{and}{(query language)}[evaluation of]-->
      <INDEX>compound query<SUBINDEX>processing</SUBINDEX></INDEX>
      Our implementation of <SCHEMEINLINE>and</SCHEMEINLINE> as a series
      combination of queries
      <SPLITINLINE>
	<SCHEME>
	  (figure<SPACE/><REF NAME="fig:query-and_scheme"/>)
	</SCHEME>
	<JAVASCRIPT>
	  (figure<SPACE/><REF NAME="fig:query-and"/>)
	</JAVASCRIPT>
      </SPLITINLINE>
      is
      elegant, but it is inefficient because in processing the second query of
      the <SCHEMEINLINE>and</SCHEMEINLINE> we must scan the data base for each
      frame produced by the first query.  If the data base has
      <LATEXINLINE>$N$</LATEXINLINE> elements, and a typical query produces a
      number of output frames proportional to <LATEXINLINE>$N$</LATEXINLINE>
      (say <LATEXINLINE>$N/k$</LATEXINLINE>), then scanning the data base for
      each frame produced by the first query will require
      <LATEXINLINE>$N^{2}/k$</LATEXINLINE> calls to the pattern matcher.
      Another approach would be to process the two clauses of the
      <SCHEMEINLINE>and</SCHEMEINLINE> separately, then look for all pairs of
      output frames that are compatible.  If each query produces
      <LATEXINLINE>$N/k$</LATEXINLINE> output frames, then this means that we
      must perform <LATEXINLINE>$N^{2}/k^{2}$</LATEXINLINE> compatibility
      checks<EMDASH/>a factor of <LATEXINLINE>$k$</LATEXINLINE> fewer than the
      number of matches required in our current  method.
      <P/>
      Devise an implementation of <SCHEMEINLINE>and</SCHEMEINLINE> that uses
      this strategy.  You  must implement a
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      that takes two frames as inputs, checks whether the bindings in the
      frames are compatible, and, if so, produces a frame that merges the two
      sets of bindings.  This operation is similar to unification.
      <LABEL NAME="ex:q-exponential-and"/>
    </EXERCISE>

    <EXERCISE>
      <INDEX>query interpreter<SUBINDEX>improvements to</SUBINDEX></INDEX>
      <INDEX>query interpreter
      <SUBINDEX>problems with <SCHEMEINLINE>not</SCHEMEINLINE> and
      <SCHEMEINLINE>lisp-value</SCHEMEINLINE></SUBINDEX></INDEX>
      <INDEX>compound query<SUBINDEX>processing</SUBINDEX></INDEX>
      <!-- \indcodeplus{not}{(query language)}[evaluation of]-->
      <!-- \indcodeplus{lisp-value}{(query language)}[evaluation of]-->
      In section<SPACE/><REF NAME="sec:math-logic"/> we saw that
      <SCHEMEINLINE>not</SCHEMEINLINE> and
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>lisp-value</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>javascript_value</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      can cause the query language to give <QUOTE>wrong</QUOTE> answers if
      these filtering operations are applied to frames in which variables
      are unbound.  Devise a way to fix this shortcoming.  One idea is to
      perform the filtering in a <QUOTE>delayed</QUOTE> manner by appending to
      the frame a <QUOTE>promise</QUOTE> to filter that is fulfilled only when
      enough variables have been bound to make the operation possible.  We could
      wait to perform filtering until all other operations have been performed.
      However, for efficiency<APOS/>s sake, we would like to perform filtering
      as soon as possible so as to cut down on the number of intermediate frames
      generated.
      <LABEL NAME="ex:not-query-filter"/>
    </EXERCISE>

    <EXERCISE>
      <INDEX>nondeterministic programming vs.<SPACE/>Scheme programming</INDEX>
      Redesign the query language as a nondeterministic program to be
      implemented using the evaluator of
      section<SPACE/><REF NAME="sec:nondeterministic-evaluation"/>, rather than as a stream
      process.  In this approach, each query will produce a single answer
      (rather than the stream of all answers) and the user can type
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
      to see more answers.  You should find that much of the mechanism we built
      in this section is subsumed by nondeterministic search and backtracking.
      You will probably also find, however, that your new query language has
      subtle differences in behavior from the one implemented here.  Can you
      find examples that illustrate this difference?
      <LABEL NAME="ex:query-lang-amb"/>
    </EXERCISE>


    <EXERCISE>
      <INDEX>environment<SUBINDEX>renaming vs.</SUBINDEX></INDEX>
      <INDEX>query interpreter<SUBINDEX><SPLITINLINE><SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
      </SPLITINLINE> interpreter vs.</SUBINDEX></INDEX>
      When we implemented the
      <SPLITINLINE>
	<SCHEME>Lisp</SCHEME>
	<JAVASCRIPT>JavaScript</JAVASCRIPT>
      </SPLITINLINE>
      evaluator in section<SPACE/><REF NAME="sec:mc-eval"/>, we saw how to use
      local environments to avoid name conflicts between the parameters of
      <SPLITINLINE>
	<SCHEME>procedures.</SCHEME>
	<JAVASCRIPT>functions.</JAVASCRIPT>
      </SPLITINLINE>
      For example, in evaluating
      <SNIPPET>
	<NAME>sum_of_squares_in_lp</NAME>
	<SCHEME>
(define (square x)
  (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
	</SCHEME>
	<JAVASCRIPT>
function square(x) {
    return x * x;
}
function sum_of_squares(x, y) {
    return square(x) + square(y);
}
sum_of_squares(3, 4);
	</JAVASCRIPT>
      </SNIPPET>
      there is no confusion between the <SCHEMEINLINE>x</SCHEMEINLINE> in
      <SCHEMEINLINE>square</SCHEMEINLINE> and the <SCHEMEINLINE>x</SCHEMEINLINE>
      in
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>sum-of-squares</SCHEMEINLINE>,</SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>,
	</JAVASCRIPT>
      </SPLITINLINE>
      because we evaluate the body of each
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      in an environment that is specially constructed to contain
      bindings for the local
      <SPLITINLINE>
	<SCHEME>variables.</SCHEME>
	<JAVASCRIPT>names.</JAVASCRIPT>
      </SPLITINLINE>
      In the query system, we used a
      different strategy to avoid name conflicts in applying rules.  Each
      time we apply a rule we rename the variables with new names that are
      guaranteed to be unique.  The analogous strategy for the
      <SPLITINLINE>
	<SCHEME>Lisp</SCHEME>
	<JAVASCRIPT>JavaScript</JAVASCRIPT>
      </SPLITINLINE>
      evaluator would be to do away with local environments and simply
      rename the variables in the body of a
      <SPLITINLINE>
	<SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT>
      </SPLITINLINE>
      each time we apply the
      <SPLITINLINE>
	<SCHEME>procedure.</SCHEME>
	<JAVASCRIPT>function.</JAVASCRIPT>
      </SPLITINLINE>
      <P/>
      Implement for the query language a rule-application method that uses
      environments rather than renaming.  See if you can build on your
      environment structure to create constructs in the query language for
      dealing with large systems, such as the rule analog of
      block-structured
      <SPLITINLINE>
	<SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT></SPLITINLINE>
      Can you relate any of this to the problem of making deductions in a
      context (e.g., <QUOTE>If I supposed that <LATEXINLINE>$P$</LATEXINLINE>
      were true, then I would be able to deduce <LATEXINLINE>$A$</LATEXINLINE>
      and <LATEXINLINE>$B$</LATEXINLINE>.</QUOTE>) as a method of problem
      solving?  (This problem is open-ended.)
      <INDEX>block structure<SUBINDEX>query@in query language</SUBINDEX></INDEX>
      <INDEX>environment<SUBINDEX>query@in query interpreter</SUBINDEX></INDEX>
      <INDEX>query interpreter<SUBINDEX>environment structure in</SUBINDEX></INDEX>
      <INDEX>rule (query language)<SUBINDEX>applying</SUBINDEX></INDEX>
      <LABEL NAME="ex:query-local-names"/>
    </EXERCISE>
  </SUBSUBSECTION>
</SUBSECTION>
