<SUBSECTION>
   <NAME>
    带标签数据
  </NAME> 

  <LABEL NAME="sec:manifest-types"></LABEL>
   <INDEX>复数<SUBINDEX>表示为带标签数据</SUBINDEX><OPEN></OPEN></INDEX> 
   <INDEX>带标签数据<OPEN></OPEN></INDEX> 
   <INDEX>数据<SUBINDEX>带标签</SUBINDEX><OPEN></OPEN></INDEX> 

   <TEXT>
    数据抽象的一种方式是将其视为最少承诺原则的应用。
    <INDEX>最少承诺原则</INDEX>
    <INDEX>最少承诺原则, 原则</INDEX>
    <QUOTE>最少承诺原则。</QUOTE> 在第<SPACE></SPACE><REF NAME="sec:representations-complex-numbers"></REF>节中实现复数系统时，我们可以使用 Ben 的直角坐标表示或 Alyssa 的极坐标表示。选择器和构造器形成的抽象屏障使我们能够将具体数据对象表示选择推迟到最后一刻，从而在系统设计中保持最大的灵活性。
  </TEXT> 
   <TEXT>
    最少承诺原则可以被推向更极端的程度。
    如果我们愿意，我们可以在设计选择器和构造器之后仍然保持表示的模糊性，并选择使用 Ben 的表示和 Alyssa 的表示。不过，如果将两种表示都包括在一个系统中，我们将需要某种方式来区分极坐标形式的数据和直角坐标形式的数据。否则，例如，如果我们被要求找到对magnitude为<SPACE></SPACE>$(3,4)$的对的模长，我们将不知道是回答 5（按直角坐标形式解释）还是 3<SPACE></SPACE>（按极坐标形式解释）。一种简单的方法是包括一个<INDEX>类型标签</INDEX>，即<EM>类型标签</EM><EMDASH></EMDASH>
    <SPLITINLINE>
      符号 rectangular
      <JAVASCRIPT>字符串 <JAVASCRIPTINLINE>&quot;rectangular&quot;</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    或者
    <SPLITINLINE>
      polar<EMDASH></EMDASH>作为
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>&quot;polar&quot;</JAVASCRIPTINLINE><EMDASH></EMDASH>作为
      </JAVASCRIPT>
    </SPLITINLINE>
    每个复数的一部分。然后，当我们需要处理一个复数时，我们可以使用标签来决定应用哪个选择器。
  </TEXT> 
  <TEXT> 
    为了操作带标签数据，我们假设我们有
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      type-tag
      <JAVASCRIPT><JAVASCRIPTINLINE>type_tag</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和  <SCHEMEINLINE>contents</SCHEMEINLINE>  从数据对象中提取标签和实际内容（在复数的情况下为极坐标或直角坐标）。我们还将假设有一个 
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      attach-tag
      <JAVASCRIPT><JAVASCRIPTINLINE>attach_tag</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    ，它接受一个标签和内容并生成一个带标签的数据对象。实现这一点的一种简单方法是使用普通列表结构：
     <SNIPPET>
      <INDEX><DECLARATION>attach_tag</DECLARATION></INDEX> 
      <INDEX><DECLARATION>type_tag</DECLARATION></INDEX> 
      <INDEX><DECLARATION>contents</DECLARATION></INDEX> 
      <NAME>attach_tag</NAME>
      <EXAMPLE>attach_tag_example</EXAMPLE>
      <EXPECTED>&apos;frequency_list&apos;</EXPECTED>
      <SCHEME>
(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (type-tag datum)
  (if (pair? datum)
    (car datum)
    (error &quot;Bad tagged datum -- TYPE-TAG&quot; datum)))

(define (contents datum)
  (if (pair? datum)
    (cdr datum)
    (error &quot;Bad tagged datum -- CONTENTS&quot; datum)))
      </SCHEME>
      <JAVASCRIPT>
function attach_tag(type_tag, contents) {
    return pair(type_tag, contents);
}
function type_tag(datum) {
    return is_pair(datum)
           ? head(datum)
           : error(datum, &quot;bad tagged datum -- type_tag&quot;);
}
function contents(datum) {
    return is_pair(datum)
           ? tail(datum)
           : error(datum, &quot;bad tagged datum -- contents&quot;);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>attach_tag_example</NAME>
      <JAVASCRIPT>
const f_1 = list(&quot;A&quot;, 4);
const my_frequency_1 = 
    attach_tag(&quot;frequency_list&quot;, f_1);

type_tag(my_frequency_1);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
   <TEXT>
    <SPLITINLINE>
      
        使用这些过程，
      
      <JAVASCRIPT>
	使用
	<JAVASCRIPTINLINE>type_tag</JAVASCRIPTINLINE>，
      </JAVASCRIPT>
    </SPLITINLINE>
    我们可以定义谓词
    <SPLITINLINE>
      rectangular?
      <JAVASCRIPT><JAVASCRIPTINLINE>is_rectangular</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      
      polar?，
      <JAVASCRIPT><JAVASCRIPTINLINE>is_polar</JAVASCRIPTINLINE>，</JAVASCRIPT>
    </SPLITINLINE>
    分别识别直角坐标和极坐标数字：
    
      <INDEX><DECLARATION>is_rectangular</DECLARATION></INDEX> 
      <INDEX><DECLARATION>is_polar</DECLARATION></INDEX> 
      <NAME>rectangular_or_polar</NAME>
      <EXAMPLE>rectangular_or_polar_example</EXAMPLE>
      <REQUIRES>attach_tag</REQUIRES>
      
(define (rectangular? z)
  (eq? (type-tag z) &apos;rectangular))

(define (polar? z)
  (eq? (type-tag z) &apos;polar))
      
      <JAVASCRIPT>
function is_rectangular(z) {
    return type_tag(z) === &quot;rectangular&quot;;
}
function is_polar(z) {
    return type_tag(z) === &quot;polar&quot;;
}
      </JAVASCRIPT>
    
  </TEXT> 
  <TEXT> 
    有了类型标签，Ben 和 Alyssa 现在可以修改他们的代码，使他们的两种不同表示能够在同一系统中共存。每当 Ben 构造一个复数时，他将其标记为直角坐标。每当 Alyssa 构造一个复数时，她将其标记为极坐标。此外，Ben 和 Alyssa 必须确保他们的
    <SPLITINLINE>
      过程</SPLITINLINE>
      <JAVASCRIPT>函数</JAVASCRIPT>
    &lt;/SPLITINLINE&gt;
    的名称不冲突。一种方法是让 Ben 附加后缀【40:10†cn.txt】。  <SCHEMEINLINE>rectangular</SCHEMEINLINE>  给他每个表示过程的名称添加后缀，并让 Alyssa 添加【44:4†cn.txt】。  <SCHEMEINLINE>polar</SCHEMEINLINE>  到她们的名字。以下是来自第<SPACE></SPACE><REF NAME="sec:representations-complex-numbers"></REF>节的 Ben更新的直角坐标表示【48:4†cn.txt】。  <SNIPPET>
      <INDEX><DECLARATION>real_part_rectangular</DECLARATION></INDEX> 
      <INDEX><DECLARATION>imag_part_rectangular</DECLARATION></INDEX> 
      <INDEX><DECLARATION>magnitude_rectangular</DECLARATION></INDEX> 
      <INDEX><DECLARATION>angle_rectangular</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_from_real_imag_rectangular</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_from_mag_ang_rectangular</DECLARATION></INDEX> 
      <NAME>make_complex_number_rectangular</NAME>
      <REQUIRES>attach_tag</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>make_complex_number_rectangular_example</EXAMPLE>
      <EXPECTED>1.932653061713073</EXPECTED>
      <SCHEME>
(define (real-part-rectangular z) (car z))

(define (imag-part-rectangular z) (cdr z))

(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))

(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))

(define (make-from-real-imag-rectangular x y)
  (attach-tag &apos;rectangular (cons x y)))

(define (make-from-mag-ang-rectangular r a) 
  (attach-tag &apos;rectangular
              (cons (* r (cos a)) (* r (sin a)))))
      </SCHEME>
      <JAVASCRIPT>
function real_part_rectangular(z) { return head(z); }
<SHORT_SPACE></SHORT_SPACE>
function imag_part_rectangular(z) { return tail(z); }
<SHORT_SPACE></SHORT_SPACE>
function magnitude_rectangular(z) {
    return math_sqrt(square(real_part_rectangular(z)) +
                     square(imag_part_rectangular(z)));
}
function angle_rectangular(z) {
    return math_atan2(imag_part_rectangular(z),
                     real_part_rectangular(z));
}
function make_from_real_imag_rectangular(x, y) {
    return attach_tag(&quot;rectangular&quot;, pair(x, y));
}
function make_from_mag_ang_rectangular(r, a) {
    return attach_tag(&quot;rectangular&quot;,
                      pair(r * math_cos(a), r * math_sin(a)));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_complex_number_rectangular_example</NAME>
      <JAVASCRIPT>
const bens_co_num = make_from_mag_ang_rectangular(	  
                        3.0, 0.7);

imag_part_rectangular(contents(bens_co_num));
      </JAVASCRIPT>
    </SNIPPET> 
    以下是 Alyssa 更新的极坐标表示：
     <SNIPPET>
      <INDEX><DECLARATION>real_part_polar</DECLARATION></INDEX> 
      <INDEX><DECLARATION>imag_part_polar</DECLARATION></INDEX> 
      <INDEX><DECLARATION>magnitude_polar</DECLARATION></INDEX> 
      <INDEX><DECLARATION>angle_polar</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_from_real_imag_polar</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_from_mag_ang_polar</DECLARATION></INDEX> 
      <NAME>make_complex_number_polar</NAME>
      <REQUIRES>attach_tag</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>make_complex_number_polar_example</EXAMPLE>
      <EXPECTED>1.932653061713073</EXPECTED>
      <SCHEME>
(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))

(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))

(define (magnitude-polar z) (car z))

(define (angle-polar z) (cdr z))

(define (make-from-real-imag-polar x y) 
  (attach-tag &apos;polar
              (cons (sqrt (+ (square x) (square y)))
              (atan y x))))

(define (make-from-mag-ang-polar r a)
  (attach-tag &apos;polar (cons r a)))
      </SCHEME>
      <JAVASCRIPT>
function real_part_polar(z) {
    return magnitude_polar(z) * math_cos(angle_polar(z));
}
function imag_part_polar(z) {
    return magnitude_polar(z) * math_sin(angle_polar(z));
}
function magnitude_polar(z) { return head(z); }
<SHORT_SPACE></SHORT_SPACE>
function angle_polar(z) { return tail(z); }
<SHORT_SPACE></SHORT_SPACE>
function make_from_real_imag_polar(x, y) {
    return attach_tag(&quot;polar&quot;,
                      pair(math_sqrt(square(x) + square(y)),
                           math_atan2(y, x)));
}
<ALLOW_BREAK></ALLOW_BREAK>
function make_from_mag_ang_polar(r, a) {
    return attach_tag(&quot;polar&quot;, pair(r, a));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_complex_number_polar_example</NAME>
      <JAVASCRIPT>
const alyssas_co_num = make_from_mag_ang_polar(
                           3.0, 0.7);

imag_part_polar(contents(alyssas_co_num));
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
     <INDEX>选择器<SUBINDEX>通用选择器</SUBINDEX></INDEX>
    <INDEX>通用 <SPLITINLINE>过程<JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE><SUBINDEX>通用选择器</SUBINDEX></INDEX>
    每个通用选择器都实现为一个
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，该过程检查其参数的标签并调用适当的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，用于处理该类型的数据。例如，为了获得复数的实部，
    <SPLITINLINE>
      real-part
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    检查标签以确定是否使用 Ben 的
    <SPLITINLINE>
      real-part-rectangular
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part_rectangular</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    或 Alyssa 的
    <SPLITINLINE>
      real-part-polar.
      <JAVASCRIPT><JAVASCRIPTINLINE>real_part_polar</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    无论哪种情况，我们都使用 【16:8†cn.txt】。  <SCHEMEINLINE>contents</SCHEMEINLINE>  提取裸露的、无标签的数据并根据需要将其发送到直角坐标或极坐标
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>：
     <SNIPPET>
      <INDEX><DECLARATION>real_part</DECLARATION><SUBINDEX>with tagged data</SUBINDEX></INDEX>
      <INDEX><DECLARATION>imag_part</DECLARATION><SUBINDEX>with tagged data</SUBINDEX></INDEX>
      <INDEX><DECLARATION>magnitude</DECLARATION><SUBINDEX>with tagged data</SUBINDEX></INDEX>
      <INDEX><DECLARATION>angle</DECLARATION><SUBINDEX>with tagged data</SUBINDEX></INDEX>
      <NAME>make_complex_number</NAME>
      <REQUIRES>rectangular_or_polar</REQUIRES>
      <REQUIRES>make_complex_number_rectangular</REQUIRES>
      <REQUIRES>make_complex_number_polar</REQUIRES>
      <EXAMPLE>make_complex_number_example_2</EXAMPLE>
      <EXPECTED>1.932653061713073</EXPECTED>
      <SCHEME>
(define (real-part z)
  (cond ((rectangular? z) 
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error &quot;Unknown type -- REAL-PART&quot; z))))

(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else (error &quot;Unknown type -- IMAG-PART&quot; z))))

(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error &quot;Unknown type -- MAGNITUDE&quot; z))))

(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else (error &quot;Unknown type -- ANGLE&quot; z))))
      </SCHEME>
      <JAVASCRIPT>
function real_part(z) {
    return is_rectangular(z)
           ? real_part_rectangular(contents(z))
           : is_polar(z)
           ? real_part_polar(contents(z))
           : error(z, &quot;unknown type -- real_part&quot;);
}
function imag_part(z) {
    return is_rectangular(z)
           ? imag_part_rectangular(contents(z))
           : is_polar(z)
           ? imag_part_polar(contents(z))
           : error(z, &quot;unknown type -- imag_part&quot;);
}
function magnitude(z) {
    return is_rectangular(z)
           ? magnitude_rectangular(contents(z))
           : is_polar(z)
           ? magnitude_polar(contents(z))
           : error(z, &quot;unknown type -- magnitude&quot;);
}
function angle(z) {
    return is_rectangular(z)
           ? angle_rectangular(contents(z))
           : is_polar(z)
           ? angle_polar(contents(z))
           : error(z, &quot;unknown type -- angle&quot;);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>make_complex_number_example_2</NAME>
      <JAVASCRIPT>
const alyssas_co_num = make_from_mag_ang_polar(	  
                           3.0, 0.7);

imag_part(alyssas_co_num);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
   <TEXT>
    为了实现复数算术运算，我们可以使用相同的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      add-complex,
      <JAVASCRIPT><JAVASCRIPTINLINE>add_complex</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      sub-complex,
      <JAVASCRIPT><JAVASCRIPTINLINE>sub_complex</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      mul-complex,
      <JAVASCRIPT><JAVASCRIPTINLINE>mul_complex</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      div-complex
      <JAVASCRIPT><JAVASCRIPTINLINE>div_complex</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    来自第<SPACE></SPACE><REF NAME="sec:representations-complex-numbers"></REF>节，
    因为它们调用的选择器是通用的，因此可以与任何表示一起使用。例如，
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      add-complex
      <JAVASCRIPT><JAVASCRIPTINLINE>add_complex</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    仍然是
    
      
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
      
      <JAVASCRIPT>
function add_complex(z1, z2) {
   return make_from_real_imag(real_part(z1) + real_part(z2),
                              imag_part(z1) + imag_part(z2));
}
      </JAVASCRIPT>
    
  </TEXT> 
   <TEXT>
    最后，我们必须选择是使用 Ben 的表示还是 Alyssa 的表示来构造复数。一个合理的选择是，在我们具有实部和虚部时构造直角坐标数，而在我们具有模长和角度时构造极坐标数：
    
      <INDEX><DECLARATION>make_from_real_imag</DECLARATION></INDEX> 
      <INDEX><DECLARATION>make_from_mag_ang</DECLARATION></INDEX> 
      <NAME>make_complex_number_generic</NAME>
      <REQUIRES>make_complex_number</REQUIRES>
      <REQUIRES>make_complex_number_rectangular</REQUIRES>
      <REQUIRES>make_complex_number_polar</REQUIRES>
      <EXAMPLE>make_complex_number_generic_example</EXAMPLE>
      <EXPECTED>1.932653061713073</EXPECTED>
      
(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))

(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
      
      <JAVASCRIPT>
function make_from_real_imag(x, y) {
    return make_from_real_imag_rectangular(x, y);
}
function make_from_mag_ang(r, a) {
    return make_from_mag_ang_polar(r, a);
}
      </JAVASCRIPT>
    
    
      <NAME>make_complex_number_generic_example</NAME>
      <JAVASCRIPT>
const alyssas_co_num = make_from_mag_ang(	  
                           3.0, 0.7);

imag_part(alyssas_co_num);
      </JAVASCRIPT>
    
  </TEXT> 
   <TEXT>
    <SPLIT>
      
        <FIGURE>
          <FIGURE SRC="img_original/ch2-Z-G-62.svg"></FIGURE>
          <CAPTION>通用复数算术系统的结构。</CAPTION>
          
        </FIGURE>
      
      <JAVASCRIPT>
        <FIGURE>
          <FIGURE SPLIT_SCALE="1" WEB_SCALE="0.6" SCALE="0.65" SRC="img_javascript/ch2-Z-G-62.svg"></FIGURE>
          <CAPTION>
	    结构
	    <INDEX>复数算术<SUBINDEX>系统结构</SUBINDEX></INDEX>
	    的通用复数算术系统。
	  </CAPTION>
          
        </FIGURE>
      </JAVASCRIPT>
    </SPLIT>
    <PDF_ONLY>$\!$</PDF_ONLY>结果复数系统的结构如
    <SPLITINLINE>
      
	图<SPACE></SPACE><REF NAME="fig:generic-complex-system_scheme"></REF>所示。
      
      <JAVASCRIPT>
	图<SPACE></SPACE><REF NAME="fig:generic-complex-system"></REF>所示。
      </JAVASCRIPT>
    </SPLITINLINE>
    该系统被分解为三个相对独立的部分：复数算术运算，Alyssa 的极坐标实现，以及 Ben 的直角坐标实现。 極座標和直角坐標實現可以由 Ben 和 Alyssa 分別完成，這兩者都可以用作第三個程序員實現復數算術的
    <SPLITINLINE>
      过程
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，以抽象构造器/选择器接口的方式。
  </TEXT> 
   <TEXT>
    因为每个数据对象都有其类型标签，所以选择器以通用方式操作
    <INDEX>选择器<SUBINDEX>通用选择器</SUBINDEX></INDEX>
    <INDEX>通用 <SPLITINLINE>过程<JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE><SUBINDEX>通用选择器</SUBINDEX></INDEX>
    。即，每个选择器的定义行为取决于应用的数据类型。注意将不同表示进行接口的通用机制：在给定的表示实现中（比如 Alyssa 的极坐标包），复数是一个无类型的对（幅度、角度）。当通用选择器操作一个极坐标类型的数字时，它会去掉标签并将内容传给 Alyssa 的代码。相反，当 Alyssa 构造一个用于通用的数字时，她将其标记为一种类型，以便能被高层的
    <SPLITINLINE>
      过程识别。
      <JAVASCRIPT>函数。</JAVASCRIPT>
    </SPLITINLINE>
    这种在数据对象从一个层次到另一个层次传递时去除和附加标签的纪律可以是一个重要的组织策略，如我们将在第<SPACE></SPACE><REF NAME="sec:generic-operators"></REF>节中看到的那样。
    <INDEX>复数<SUBINDEX>表示为带标签数据</SUBINDEX><CLOSE></CLOSE></INDEX>
    <INDEX>带标签数据<CLOSE></CLOSE></INDEX>
    <INDEX>数据<SUBINDEX>带标签</SUBINDEX><CLOSE></CLOSE></INDEX>
  </TEXT> 
</SUBSECTION>
