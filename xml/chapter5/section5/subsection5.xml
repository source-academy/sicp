<SUBSECTION>
  <NAME>
    An Example of Compiled Code
  </NAME>

  <LABEL NAME="sec:compiled-code"/>
  <INDEX>compiler for JavaScript<SUBINDEX>example compilation<OPEN/></SUBINDEX></INDEX>
  <INDEX><USE>factorial</USE><SUBINDEX>compilation of<OPEN/></SUBINDEX></INDEX>
  <TEXT>
    Now that we have seen all the elements of the compiler, let us examine
    an example of compiled code to see how things fit together.  We will
    compile the
    <SPLITINLINE>
      <SCHEME>definition</SCHEME>
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    of a recursive
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>factorial</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>factorial</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    by calling <SCHEMEINLINE>compile</SCHEMEINLINE><SPLITINLINE><JAVASCRIPT> (the <JAVASCRIPTINLINE>\</JAVASCRIPTINLINE> characters below are needed in JavaScript to allow a string literal to span multiple lines</JAVASCRIPT><FOOTNOTE>The \ character is not part of the strings, but simply tells the parser that the string literal continues on the next line. The string <SNIPPET><JAVASCRIPT>
"a \
 b"
</JAVASCRIPT></SNIPPET>parses exactly like the string <JAVASCRIPTINLINE>"a  b"</JAVASCRIPTINLINE>.</FOOTNOTE>)</SPLITINLINE>:
    <SNIPPET EVAL="no">
      <SCHEME>
      (compile
      '(define (factorial n)
      (if (= n 1)
            1
            (* (factorial (- n 1)) n)))
      'val
      'next)
      </SCHEME>
      <JAVASCRIPT>
compile(parse("                                    \
    function factorial(n) {                        \
        return n === 1 ? 1 : n * factorial(n - 1); \
    }"),
    "val",
    "next");
      </JAVASCRIPT>
    </SNIPPET>

    We have specified that the value of the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>define</SCHEMEINLINE> expression</SCHEME>
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    should be placed in the <SCHEMEINLINE>val</SCHEMEINLINE> register.
    We don<APOS/>t care what the compiled
    code does after executing the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>define</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>declaration</JAVASCRIPT>
    </SPLITINLINE>
    so our choice of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>next</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    as the linkage
    descriptor is arbitrary.
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Compile</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function <SCHEMEINLINE>compile</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    determines that the
    <SPLITINLINE>
      <SCHEME>
	expression is a definition,
      </SCHEME>
      <JAVASCRIPT>
	statement is a constant declaration
      </JAVASCRIPT>
    </SPLITINLINE>
    so it calls
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-definition</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compile_declaration</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to compile code to compute the value to be assigned (targeted to
    <SCHEMEINLINE>val</SCHEMEINLINE>), followed by code to install the
    <SPLITINLINE>
      <SCHEME>definition,</SCHEME>
      <JAVASCRIPT>declaration,</JAVASCRIPT>
    </SPLITINLINE>
    followed by code to put the value of the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>define</SCHEMEINLINE> (which is the symbol
	<SCHEMEINLINE>ok</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
	declaration (which is the value
	<SCHEMEINLINE>undefined</SCHEMEINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>    
    into the target register, followed finally by the linkage code.
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Env</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	Register <SCHEMEINLINE>env</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>    
    is preserved around the computation of the
    value, because it is needed in order to install the
    <SPLITINLINE>
      <SCHEME>
	definition.
      </SCHEME>
      <JAVASCRIPT>
	declaration.
      </JAVASCRIPT>
    </SPLITINLINE>    
    Because
    the linkage is
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>next</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    there is no linkage code
    in this case.  The skeleton of the compiled code is thus
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      ^save^ env ^if modified by code to compute value^
      ^compilation of definition value, target^ val^, linkage^ next
      ^restore^ env ^if saved above^
      (perform (op define-variable!)
            (const factorial)
            (reg val)
            (reg env))
      (assign val (const ok))
      </SCHEME>
      <JAVASCRIPT>
<METAPHRASE>save <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if modified by code to compute value</METAPHRASE>
<METAPHRASE>compilation of declaration value, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE></METAPHRASE>
<METAPHRASE>restore <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if saved above</METAPHRASE>
perform(list(op("assign_symbol_value"),
             constant("factorial"),
             reg("val"),
             reg("env")),
assign("val", constant(undefined))
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The expression that is to be compiled to produce the value for the
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>constant</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>factorial</SCHEMEINLINE>
    is a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>
    expression whose value is the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that computes factorials.
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Compile</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	The function
	<SCHEMEINLINE>compile</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    handles this
    by calling
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-lambda</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_lambda_expression</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which compiles the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body, labels it as a new entry point, and generates the instruction that
    will combine the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body at the new entry point with the runtime environment and assign the
    result to <SCHEMEINLINE>val</SCHEMEINLINE>.  The sequence then skips around
    the compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code, which is inserted at this point.  The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code itself begins by extending the
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s definition</SCHEME>
      <JAVASCRIPT>function<APOS/>s declaration</JAVASCRIPT>
    </SPLITINLINE>
    environment by a frame that binds
    the formal parameter <SCHEMEINLINE>n</SCHEMEINLINE> to the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    argument.  Then comes the actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body.  Since this code for the value of the
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>constant</JAVASCRIPT>
    </SPLITINLINE>
    doesn<APOS/>t modify the <SCHEMEINLINE>env</SCHEMEINLINE> register, the
    optional <SCHEMEINLINE>save</SCHEMEINLINE>
    and <SCHEMEINLINE>restore</SCHEMEINLINE> shown above aren<APOS/>t
    generated.  (The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    code at
    <SCHEMEINLINE>entry2</SCHEMEINLINE> isn<APOS/>t executed at this point,
    so its use of <SCHEMEINLINE>env</SCHEMEINLINE> is irrelevant.)
    Therefore, the skeleton for the compiled code becomes
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
      (assign val (op make-compiled-procedure)
            (label entry2)
            (reg env))
      (goto (label after-lambda1))
      entry2
      (assign env (op compiled-procedure-env) (reg proc))
      (assign env (op extend-environment)
            (const (n))
            (reg argl)
            (reg env))
      ^compilation of procedure body^
      after-lambda1
      (perform (op define-variable!)
            (const factorial)
            (reg val)
            (reg env))
      (assign val (const ok))
      </SCHEME>
      <JAVASCRIPT>
$$  assign("val", list(op("make_compiled_function"),
                     label(entry2), 
                     reg("env"))),
  go_to(label("after_lambda1")),
"entry2",
  assign("env", list(op("compiled_function_env"), reg("fun"))),
  assign("env", list(op("extend_environment"), 
                     constant("n"), 
                     reg("argl"), 
                     reg("env"))),
  <METAPHRASE>compilation of function body</METAPHRASE>
"after_lambda1",
  perform(list(op("assign_symbol_value"), 
               constant("factorial"), 
               reg("val"), 
               reg("env"))),
  assign("val", constant(undefined))
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    body is always compiled (by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-lambda-body</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>compile_lambda_body</JAVASCRIPTINLINE>)</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>as a sequence</SCHEME>
    </SPLITINLINE>
    with target <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return_undefined"</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The
    <SPLITINLINE>
      <SCHEME>
	sequence
      </SCHEME>
      <JAVASCRIPT>
	body
      </JAVASCRIPT>
    </SPLITINLINE>
    in this case consists of
    a single
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE> expression:
      </SCHEME>
      <JAVASCRIPT>
	return statement:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      (if (= n 1)
      1
      (* (factorial (- n 1)) n))
      </SCHEME>
      <JAVASCRIPT>
return n === 1 
       ? 1 
       : factorial(n - 1) * n;
      </JAVASCRIPT>
    </SNIPPET>

    <SPLIT>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>compile_return_statement</JAVASCRIPTINLINE>
	compiles the return expression with the same target
	<SCHEMEINLINE>val</SCHEMEINLINE> but with linkage
	<SCHEMEINLINE>"return"</SCHEMEINLINE>, because the return
	expression is the last
  <SPLITINLINE>
    <SCHEME>
      expression
    </SCHEME>
    <JAVASCRIPT>
      statement
    </JAVASCRIPT>
  </SPLITINLINE>
  to be evaluated in the
	body, and its value is to be returned from the function.
      </JAVASCRIPT>
    </SPLIT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Compile-if</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The return expression is a
      <SPLITINLINE>
        <SCHEME>
          conditional expression 
        </SCHEME>
        <JAVASCRIPT>
          conditional
        </JAVASCRIPT>
      </SPLITINLINE>
      and thus
      <JAVASCRIPTINLINE>compile_conditional</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    generates code that first computes the predicate (targeted to
    <SCHEMEINLINE>val</SCHEMEINLINE>), then checks the result and branches
    around the true branch if the predicate is false.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Env</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>Registers <SCHEMEINLINE>env</SCHEMEINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and <SCHEMEINLINE>continue</SCHEMEINLINE>
    are preserved around the predicate code, since they may be needed for the
    rest of the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>if</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>conditional</JAVASCRIPT>
    </SPLITINLINE>
    expression.
    <SPLIT>
      <SCHEME>
    Since the
    <SCHEMEINLINE>if</SCHEMEINLINE> expression 
    is the final
    expression (and only expression) in the sequence making up
    the procedure
    body, its target is <SCHEMEINLINE>val</SCHEMEINLINE> and its linkage is
	<SCHEMEINLINE>return</SCHEMEINLINE>,
    so
    the
      </SCHEME>
      <JAVASCRIPT>
	The
      </JAVASCRIPT>
    </SPLIT>
    true and false branches are both
    compiled with target <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    (That is, the value of the conditional,
    which is the value computed by either of its branches, is the value of the
    <SPLITINLINE>
      <SCHEME>procedure.)</SCHEME>
      <JAVASCRIPT>function.)</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET LATEX="yes">
      <SCHEME>
      ^save^ continue^,^ env ^if modified by predicate and needed by branches^
      ^compilation of predicate, target^ val^, linkage^ next
      ^restore^ continue^,^ env ^if saved above^
      (test (op false?) (reg val))
      (branch (label false-branch4))
      true-branch5
      ^compilation of true branch, target^ val^, linkage^ return
      false-branch4
      ^compilation of false branch, target^ val^, linkage^ return
      after-if3
      </SCHEME>
      <JAVASCRIPT><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  <METAPHRASE>save <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>, <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if modified by predicate and needed by branches</METAPHRASE>
  <METAPHRASE>compilation of predicate, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"next"</JAVASCRIPTINLINE></METAPHRASE>
  <METAPHRASE>restore <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>, <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> if saved above</METAPHRASE>
  test(list(op("is_falsy"), reg("val"))),
  branch(label("false_branch5")),
"true_branch4",
  <METAPHRASE>compilation of true branch, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE></METAPHRASE>
"false_branch5",
  <METAPHRASE>compilation of false branch, target <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, linkage <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE></METAPHRASE>
"after_cond3",
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The predicate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(= n 1)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>n === 1</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call. This looks up the
    <SPLITINLINE>
      <SCHEME>
    operator 
    (the symbol <SCHEMEINLINE>===</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
	function expression
	(the symbol <JAVASCRIPTINLINE>"==="</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    and places this value in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    It then assembles the arguments <SCHEMEINLINE>1</SCHEMEINLINE> and the value
    of <SCHEMEINLINE>n</SCHEMEINLINE> into <SCHEMEINLINE>argl</SCHEMEINLINE>.
    Then it tests whether
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    contains a primitive or a compound
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    and dispatches to a primitive branch or a compound branch accordingly.
    Both branches resume at the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>after-call</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>after_call</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    label.  The requirements to preserve registers
    around the evaluation of the
    <SPLITINLINE>
      <SCHEME>
	operator and operands
      </SCHEME>
      <JAVASCRIPT>
	function and argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    don<APOS/>t result in
    any saving of registers, because in this case those evaluations don<APOS/>t
    modify the registers in question.

    <SNIPPET LATEX="yes">
      <SCHEME>
      (assign proc
            (op lookup-variable-value) (const =) (reg env))
      (assign val (const 1))
      (assign argl (op list) (reg val))
      (assign val (op lookup-variable-value) (const n) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch17))
      compiled-branch16
      (assign continue (label after-call15))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch17
      (assign val (op apply-primitive-procedure)
            (reg proc)
            (reg argl))
      after-call15
      </SCHEME>
      <JAVASCRIPT latex="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  assign("fun", list(op("lookup_symbol_value"), constant("==="), 
                     reg("env"))),
  assign("val", constant(1)),
  assign("argl", list(op("list"), reg("val"))),
  assign("val", list(op("lookup_symbol_value"), constant(n), 
                     reg("env"))),
  assign("argl", list(op("pair"), reg("val"), reg("argl"))),
  test(list(op("primitive_function"), reg("fun"))),
  branch(label("primitive_branch17")),
"compiled_branch16",
  assign("continue", label("after_call15")),
  save("continue"),
  save_marker(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"primitive_branch17",
  assign("val", list(op("apply_primitive_function"), reg("fun"), 
                     reg("argl"))),
"after_call15"
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The true branch, which is the constant 1, compiles (with target
    <SCHEMEINLINE>val</SCHEMEINLINE> and linkage
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>)
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>)
      </JAVASCRIPT>
    </SPLITINLINE>
    to
    <SNIPPET EVAL="no">
      <SCHEME>
      (assign val (const 1))
      (goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
assign("val", constant(1)),
restore_marker(),
restore("continue"),
go_to(reg("continue"))
      </JAVASCRIPT>
    </SNIPPET>

    The code for the false branch is another a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call, where the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is the value of the symbol
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>*</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>"*"</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and the arguments
    are <SCHEMEINLINE>n</SCHEMEINLINE> and the result of another
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call (a call to <SCHEMEINLINE>factorial</SCHEMEINLINE>).
    Each of these calls sets up
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and <SCHEMEINLINE>argl</SCHEMEINLINE> and its own primitive
    and compound branches.  Figure<SPACE/><REF NAME="fig:comp-factorial1"/>
    shows the complete compilation of the
    <SPLITINLINE>
      <SCHEME>
	definition
      </SCHEME>
      <JAVASCRIPT>
	declaration
      </JAVASCRIPT>
    </SPLITINLINE>
    of the <SCHEMEINLINE>factorial</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    Notice that the possible <SCHEMEINLINE>save</SCHEMEINLINE> and
    <SCHEMEINLINE>restore</SCHEMEINLINE> of
    <SCHEMEINLINE>continue</SCHEMEINLINE> and
    <SCHEMEINLINE>env</SCHEMEINLINE> around the predicate, shown above,
    are in fact generated, because these registers are modified by the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call in the predicate and needed for the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call and the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>return</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    linkage in the branches.
    <SPLITINLINE>
      <SCHEME>
	<INDEX>compiler for Scheme<SUBINDEX>example compilation<CLOSE/></SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>compiler for JavaScript<SUBINDEX>example compilation<CLOSE/></SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <EXERCISE>
    Consider the following declaration of a factorial
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    which is slightly different from the one given above:
    <SNIPPET EVAL="no">
      <SCHEME>
      (define (factorial-alt n)
      (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
      </SCHEME>
      <JAVASCRIPT>
function factorial_alt(n) {
    return n === 1  
           ? 1
           : n * factorial_alt(n - 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Compile this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    and compare the resulting code with that produced for
    <SCHEMEINLINE>factorial</SCHEMEINLINE>.  Explain any differences you find.
    Does either program execute more efficiently than the other?
  </EXERCISE>

  <EXERCISE>
    <INDEX>iterative process<SUBINDEX>recursive process vs.</SUBINDEX></INDEX>
    <INDEX>recursive process<SUBINDEX>iterative process vs.</SUBINDEX></INDEX>
    Compile the iterative factorial
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      (define (factorial n)
      (define (iter product counter)
      (if (&gt; counter n)
            product
            (iter (* counter product)
            (+ counter 1))))
      (iter 1 1))
      </SCHEME>
      <JAVASCRIPT>
function factorial(n) {
    function iter(product, counter) {
        return counter &gt; n
               ? product
               : iter(product * counter, counter + 1);
    }

    return iter(1, 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Annotate the resulting code, showing the essential difference between
    the code for iterative and recursive versions of
    <SCHEMEINLINE>factorial</SCHEMEINLINE> that makes one process build up
    stack space and the other run in constant stack space.
    <LABEL NAME="ex:compiled-fact"/>
  </EXERCISE>

  <FIGURE CONTINUED="yes">
    <SNIPPET EVAL="no">
      <NAME>compiled_factorial_1</NAME>
      <SCHEME>
;; construct the procedure and skip over code for the procedure body
      (assign val
            (op make-compiled-procedure) (label entry2) (reg env))
      (goto (label after-lambda1))

      entry2     ; calls to factorial will enter here
      (assign env (op compiled-procedure-env) (reg proc))
      (assign env
            (op extend-environment) (const (n)) (reg argl) (reg env))
      ;; begin actual procedure body
      (save continue)
      (save env)

      ;; compute (= n 1)
      (assign proc (op lookup-variable-value) (const =) (reg env))
      (assign val (const 1))
      (assign argl (op list) (reg val))
      (assign val (op lookup-variable-value) (const n) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch17))
      compiled-branch16
      (assign continue (label after-call15))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch17
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

      after-call15   ; val now contains result of (= n 1)
      (restore env)
      (restore continue)
      (test (op false?) (reg val))
      (branch (label false-branch4))
      true-branch5  ; return 1
      (assign val (const 1))
      (goto (reg continue))

      false-branch4
      <EM>;; compute and return (* (factorial (- n 1)) n)</EM>
      (assign proc (op lookup-variable-value) (const *) (reg env))
      (save continue)
      (save proc)   ; save * procedure
      (assign val (op lookup-variable-value) (const n) (reg env))
      (assign argl (op list) (reg val))
      (save argl)   ; save partial argument list for *

      ;; compute (factorial (- n 1)), which is the other argument for *
      (assign proc
            (op lookup-variable-value) (const factorial) (reg env))
      (save proc)  ; save factorial procedure
    </SCHEME>
    <JAVASCRIPT>
// construct the function and skip over code for the function body
  assign("val",
    list(op("make_compiled_function"), label("entry2"), reg("env"))),
  go_to(label("after_lambda1")),

"entry2",     // calls to factorial will enter here
  assign("env", list(op("compiled_function_env"), reg("fun"))),
  assign("env",
    list(op("extend_environment"), constant(list("n")),
         reg("argl"), reg("env"))),
// begin actual procedure body
  restore_marker(),
  restore("continue"),
  save("continue"),
  save("env"),

// compute n === 1
  assign("fun", list(op("lookup_symbol_value"), 
                     constant("==="), reg("env"))),
  assign("val", constant(1)),
  assign("argl", list(op("list","), reg("val"))),
  assign("val", list(op("lookup_symbol_value"), 
                     constant(n), reg("env"))),
  assign("argl, list(op("pair"), reg("val"), reg("argl"))),
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch17")),
"compiled_branch16",
  assign("continue", label("after_call15")),
  save("continue"),
  save_marker(),
  assign(val, list(op("compiled_function_entry"), 
                   reg("fun"))),
  go_to(reg("val")),
"primitive_branch17",
  assign("val",
    list(op("apply_primitive_function"), 
         reg("fun"), reg("argl"))),
"after_call15",            // val now contains result of n === 1
  restore("env"),
  restore("continue"),
  test(list(op("is_falsy"), reg("val"))),
  branch(label("false_branch4")),
"true_branch5",            // return 1
  assign("val", constant(1)),
  go_to(reg("continue")),
"false_branch4",
// compute &amp; return factorial(n - 1) * n
  assign("fun", list(op("lookup_symbol_value"),
                     constant("*"), reg("env"))),
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>
    Compilation of the declaration of the <SCHEMEINLINE>factorial</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
  <INDEX><USE>factorial</USE><SUBINDEX>compilation of</SUBINDEX></INDEX>
  (continued on next page).
  </CAPTION>
  <LABEL NAME="fig:comp-factorial1"/>
    </FIGURE>


    <FIGURE CONTINUED="yes">
  <SNIPPET LATEX="yes">
    <NAME>compiled_factorial_2</NAME>
    <SCHEME>
      ;; compute (- n 1), which is the argument for factorial
      (assign proc (op lookup-variable-value) (const -) (reg env))
      (assign val (const 1))
      (assign argl (op list) (reg val))
      (assign val (op lookup-variable-value) (const n) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (test (op primitive-procedure?) (reg proc))
      (branch label primitive-branch8))
      compiled-branch7
      (assign continue (label after-call6))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch8
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

      after-call6   ; val now contains result of (- n 1)
      (assign argl (op list) (reg val))
      (restore proc) ; restore factorial
      ;; apply factorial
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch11))
      compiled-branch10
      (assign continue (label after-call9))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch11
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

      after-call9      ; val now contains result of (factorial (- n 1))
      (restore argl) ; restore partial argument list for *
      (assign argl (op cons) (reg val) (reg argl))
      (restore proc) ; restore *
      (restore continue)
      ;; apply * and return its value
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch14))
      compiled-branch13
      ;; note that a compound procedure here is called tail-recursively
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch14
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
      (goto (reg continue))
      after-call12
      after-if3
      after-lambda1
      ;; assign the procedure to the variable factorial
      (perform
      (op define-variable!) (const factorial) (reg val) (reg env))
      (assign val (const ok))
    </SCHEME>
    <JAVASCRIPT latex="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  save("continue"),
  save("fun"),            // save * function
  assign("val", list(op("lookup_symbol_value"), 
                     constant(n), reg("env"))),
  assign("argl", list(op("list"), reg("val"))),
  save("argl"),            // save partial argument list for *

// compute factorial(n - 1), which is the other argument for *
  assign("fun",
    list(op("lookup_symbol_value"), constant("factorial"), reg("env"))),
  save("fun"),            // factorial function

// compute n - 1, which is the argument for factorial
  assign("fun", list(op("lookup_symbol_value"), 
                     constant("-"), reg("env"))),
  assign("val", constant(1)),
  assign("argl", list(op("list","), reg("val"))),
  assign("val", list(op("lookup_symbol_value"), constant(n), 
                     reg("env"))),
  assign("argl", list(op("pair"), reg("val"), reg("argl"))),
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch8")),
"compiled_branch7"
  assign("continue", label("after_call6")),
  save("continue"),
  save_marker(),
  assign(val, list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"primitive_branch8",
  assign("val", list(op("apply_primitive_function"), 
                     reg("fun"), reg("argl"))),
  
"after_call6",            // val now contains result of n - 1
  assign("argl", list(op("list"), reg("val"))),
  restore("fun"),         // restore factorial
                          // apply factorial
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch11")),
"compiled_branch10",
  assign("continue", label("after_call9")),
  save("continue"),
  save_marker(),
  assign(val, list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"primitive_branch11",
  assign("val", list(op("apply_primitive_function"), 
                     reg("fun"), reg("argl"))),
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>(continued)</CAPTION>
    <LABEL NAME="fig:continued_1"/>
    </FIGURE>

    <FIGURE>
      <SNIPPET EVAL="no">
	<NAME>compiled_factorial_3</NAME>
      <JAVASCRIPT>
"after_call9",            // val now has result of factorial(n - 1)
  restore("argl"),        // restore partial argument list for *
  assign("argl", list(op("pair"), reg("val"), reg("argl"))),
  restore("fun"),         // restore *
  restore("continue"),    

// apply * and return its value
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch14")),
"compiled_branch13",
// note that compound function here is called tail-recursively
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
"primitive_branch14",
  assign("val", list(op("apply_primitive_function"), 
                     reg("fun"), reg("argl"))),
  go_to(reg("continue")),
"after_call12",
"after_cond3",
"after_lambda1",
// assign the function to the name factorial
  perform(list(op("assign_symbol_value"), 
               constant("factorial"), reg("val"), reg("env"))),
  assign("val", constant(undefined))
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>(continued)</CAPTION>
    <LABEL NAME="fig:continued_11"/>
    </FIGURE>

      <EXERCISE>
	<LABEL NAME="ex:compiled-code"/>
  What expression was compiled to produce the code shown in
  figure<SPACE/><REF NAME="fig:compilation-example1"/>?
      </EXERCISE>
      
  <FIGURE CONTINUED="yes">
  <SNIPPET LATEX="yes">
    <SCHEME>
      (assign val (op make-compiled-procedure) label entry16)
            (reg env))
      (goto (label after-lambda15))
      entry16
      (assign env (op compiled-procedure-env) (reg proc))
      (assign env
            (op extend-environment) (const (x)) (reg argl) (reg env))
      (assign proc (op lookup-variable-value) (const +) (reg env))
      (save continue)
      (save proc)
      (save env)
      (assign proc (op lookup-variable-value) (const g) (reg env))
      (save proc)
      (assign proc (op lookup-variable-value) (const +) (reg env))
      (assign val (const 2))
      (assign argl (op list) (reg val))
      (assign val (op lookup-variable-value) (const x) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch19))
      compiled-branch18
      (assign continue (label after-call17))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch19
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
      after-call17
      (assign argl (op list) (reg val))
      (restore proc)
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-branch22))
      compiled-branch21
      (assign continue (label after-call20))
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch22
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
    </SCHEME>
    <JAVASCRIPT latex="yes"><!-- The $$ below is a hack to ensure the leading spaces are not consumed-->
$$  assign("val", list(op("make_compiled_function"),
                     label("entry16")),
        reg env)),
  go_to(label("after_lambda15")),
"entry16",
  assign(env, list(op("compiled_function_env"), 
                   reg("fun"))),
  assign("env", list(op("extend_environment","), 
                     constant("x"), reg("argl"), reg("env"))),
  assign("fun", list(op("lookup_symbol_value"), 
                     constant("+"), reg("env"))),
  save("continue"),
  save("fun"),
  save("env"),
  assign("fun", list(op("lookup_symbol_value"),
                     constant("g"), reg("env"))),
  save("fun"),
  assign("fun", list(op("lookup_symbol_value"),
                     constant("+"), reg("env"))),
  assign("val", constant(2)),
  assign("argl", list(op("list"), reg("val"))),
  assign("val", list(op("lookup_symbol_value"),
                     constant("x"), reg("env"))),
  assign("argl, list(op("pair"), reg("val"), reg("argl"))),
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch19")),
"compiled_branch18",
  assign("continue", label("after_call17")),
  save("continue"),
  save_marker(),
  assign(val, list(op("compiled_function_entry"), 
                   reg("fun"))),
  go_to(reg("val")),
"primitive_branch19",
  assign("val", list(op("apply_primitive_function"), 
                     reg("fun"), reg("argl"))),
"after_call17",
  assign("argl", list(op("list"), reg("val"))),
  restore("fun"),
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch22")),
"compiled_branch21",
  assign("continue", label("after_call20")),
  save("continue"),
  save_marker(),
  assign(val, list(op("compiled_function_entry"), 
                   reg("fun"))),
  go_to(reg("val")),
    </JAVASCRIPT>
  </SNIPPET>
  <CAPTION>An example of compiler output (continued on next page).
  See exercise<SPACE/><REF NAME="ex:compiled-code"/>.
  </CAPTION>
  <LABEL NAME="fig:compilation-example1"/>
  </FIGURE>


  <FIGURE>
  <SNIPPET EVAL="no">
    <SCHEME>
      after-call20
      (assign argl (op list), (reg val))
      (restore env)
      (assign val (op lookup-variable-value) (const x) (reg env))
      (assign argl (op cons) (reg val) (reg argl))
      (restore proc)
      (restore continue)
      (test (op primitive-procedure?) (reg proc))
      (branch label primitive-branch25))
      compiled-branch24
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      primitive-branch25
      (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
      (goto (reg continue))
      after-call23
      after-lambda15
      (perform (op define-variable!) (const f) (reg val) (reg env))
      (assign val (const ok))
    </SCHEME>
    <JAVASCRIPT>
"primitive_branch22",
  assign("val", list(op("apply_primitive_function"),
                     reg("fun"), reg("argl"))),
"after_call20",
  assign("argl", list(op("list"), reg("val"))),
  restore("env"),
  assign("val", list(op("lookup_symbol_value"),
                   constant("x"), reg("env"))),
  assign("argl", list(op("pair"), reg("val"), reg("argl"))),
  restore("fun"),
  restore("continue"),
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_branch25")),
"compiled_branch24",
  save("continue"),
  save_marker(),
  assign("val", list(op("compiled_function_entry"), 
                     reg("fun"))),
  go_to(reg("val")),
"primitive_branch25",
  assign("val", list(op("apply_primitive_function"), 
                     reg("fun"), reg("argl"))),
  go_to(reg("continue")),
"after_call23",
"after_lambda15",
  perform(list(op("assign_symbol_value"), 
               constant("f"), reg("val"), reg("env"))),
  assign("val", constant(undefined))
    </JAVASCRIPT>
  </SNIPPET>
    <CAPTION>(continued)</CAPTION>
    <LABEL NAME="fig:continued_2"/>
  </FIGURE>

  <EXERCISE> 
    <INDEX>order of evaluation<SUBINDEX>in compiler</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>compiler for Scheme<SUBINDEX>order of operand evaluation</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>compiler for JavaScript<SUBINDEX>order of argument evaluation</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    What order of evaluation does our compiler produce for
    <SPLITINLINE>
      <SCHEME>operands of a combination?</SCHEME>
      <JAVASCRIPT>arguments of an application?</JAVASCRIPT>
    </SPLITINLINE>
    Is it left-to-right, right-to-left, or some other order?
    Where in the compiler is this order determined?  Modify the compiler
    so that it produces some other order of evaluation.  (See the
    discussion of order of evaluation for the explicit-control evaluator
    in section<SPACE/><REF NAME="sec:eceval-core"/>.)  How does changing the
    order of
    <SPLITINLINE>
      <SCHEME>operand</SCHEME>
      <JAVASCRIPT>argument</JAVASCRIPT>
    </SPLITINLINE>
    evaluation affect the efficiency of the code that
    constructs the argument list?
  </EXERCISE>

  <EXERCISE>
    <INDEX>compiler for JavaScript<SUBINDEX>stack usage</SUBINDEX></INDEX>
    <INDEX><USE>preserving</USE></INDEX> 
    One way to understand the compiler<APOS/>s
    <SCHEMEINLINE>preserving</SCHEMEINLINE> mechanism for
    optimizing stack usage is to see what extra operations would
    be generated if we did not use this idea.  Modify
    <SCHEMEINLINE>preserving</SCHEMEINLINE> so
    that it always generates the <SCHEMEINLINE>save</SCHEMEINLINE> and
    <SCHEMEINLINE>restore</SCHEMEINLINE> operations.
    Compile some simple expressions and identify the unnecessary stack
    operations that are generated.
    Compare the code to that generated with the
    <SCHEMEINLINE>preserving</SCHEMEINLINE> mechanism intact.
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:open-code"/>
    <INDEX>compiler for JavaScript<SUBINDEX>open coding of primitives</SUBINDEX></INDEX>
    <INDEX>open coding of primitives</INDEX>
    Our compiler is clever about avoiding unnecessary stack operations,
    but it is not clever at all when it comes to compiling calls to the primitive
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    of the language in terms of the primitive operations
    supplied by the machine.  For example, consider how much code is
    compiled to compute
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(+ a 1)</SCHEMEINLINE>:</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>a + 1</JAVASCRIPTINLINE>:</JAVASCRIPT>
    </SPLITINLINE>
    The code sets up an argument list in <SCHEMEINLINE>argl</SCHEMEINLINE>, puts
    the primitive addition
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    (which it finds by looking up the symbol
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>+</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>"+"</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in the environment) into
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>,</JAVASCRIPT>
      </SPLITINLINE>
    and tests whether the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is primitive or compound.  The
    compiler always generates code to perform the test, as well as code
    for primitive and compound branches (only one of which will be executed).
    We have not shown the part of the controller that implements
    primitives, but we presume that these instructions make use of
    primitive arithmetic operations in the machine<APOS/>s data paths.  Consider
    how much less code would be generated if the compiler could <EM>
    open-code</EM> primitives<EMDASH/>that is, if it could generate code to
    directly use these primitive machine operations.  The expression
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(+ a 1)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>a + 1</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    might be compiled into something as simple as<FOOTNOTE>We have used
    the same symbol <SCHEMEINLINE>+</SCHEMEINLINE> here to denote both the
    source-language
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    and the machine operation.  In general there will not be a
    one-to-one correspondence between primitives of the source language
    and primitives of the machine.</FOOTNOTE>
    <SNIPPET EVAL="no">
      <SCHEME>
(assign val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
      </SCHEME>
      <JAVASCRIPT>
assign("val", list(op("lookup_symbol_value"), 
                   constant("a"), reg("env")),
assign("val", list(op("+"), reg("val"), constant(1))
      </JAVASCRIPT>
    </SNIPPET>
    In this exercise we will extend our compiler to support open coding of
    selected primitives.  Special-purpose code will be generated for calls to these primitive
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    instead of the general
    <SPLITINLINE>
      <SCHEME>procedure-application</SCHEME>
      <JAVASCRIPT>function-application</JAVASCRIPT>
    </SPLITINLINE>
    code.  In order to support this, we will augment
    our machine with special argument registers
    <SCHEMEINLINE>arg1</SCHEMEINLINE> and <SCHEMEINLINE>arg2</SCHEMEINLINE>.
    The primitive arithmetic operations of the machine will take their
    inputs from <SCHEMEINLINE>arg1</SCHEMEINLINE> and
    <SCHEMEINLINE>arg2</SCHEMEINLINE>. The results may be put into
    <SCHEMEINLINE>val</SCHEMEINLINE>, <SCHEMEINLINE>arg1</SCHEMEINLINE>, or
    <SCHEMEINLINE>arg2</SCHEMEINLINE>.
    <P/>
    The compiler must be able to recognize the application of an
    open-coded primitive in the source program.  We will augment the
    dispatch in the <SCHEMEINLINE>compile</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to recognize the names of these primitives in addition to the
    <SPLITINLINE>
      <SCHEME>
	<INDEX>reserved words</INDEX>
	reserved words (the special forms)
	it currently recognizes.<FOOTNOTE>Making
	the primitives into reserved words is in general a bad idea, since a user
	cannot then rebind these names to different
	<SPLITINLINE>
	  <SCHEME>procedures.</SCHEME>
	  <JAVASCRIPT>functions.</JAVASCRIPT>
	</SPLITINLINE>
	Moreover, if we add reserved words to
	a compiler that is in use, existing programs that define
	<SPLITINLINE>
	  <SCHEME>procedures</SCHEME>
	  <JAVASCRIPT>functions</JAVASCRIPT>
	</SPLITINLINE>
	with these names will stop working.  See
	exercise<SPACE/><REF NAME="ex:cte-open-code"/> for ideas on how to avoid
	this problem.</FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	syntactic forms it currently recognizes.
      </JAVASCRIPT>
    </SPLITINLINE>
    For each
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>syntactic</JAVASCRIPT>
    </SPLITINLINE>
    form our compiler has a code
    generator.  In this exercise we will construct a family of code generators
    for the open-coded primitives.
    <OL>
      <LI>
	The open-coded primitives, unlike the
	<SPLITINLINE>
	  <SCHEME>special</SCHEME>
	  <JAVASCRIPT>syntactic</JAVASCRIPT>
	</SPLITINLINE>
	forms, all need their
	<SPLITINLINE>
	  <SCHEME>operands</SCHEME>
	  <JAVASCRIPT>arguments</JAVASCRIPT>
	</SPLITINLINE>
	evaluated.  Write a code generator
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>spread-arguments</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>spread_arguments</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	for use by all the open-coding code generators.
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>Spread-arguments</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    The function
	    <JAVASCRIPTINLINE>spread_arguments</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	should take an
	<SPLITINLINE>
	  <SCHEME>operand</SCHEME>
	  <JAVASCRIPT>argument</JAVASCRIPT>
	</SPLITINLINE>
	list and compile the given
	<SPLITINLINE>
	  <SCHEME>operands</SCHEME>
	  <JAVASCRIPT>arguments</JAVASCRIPT>
	</SPLITINLINE>
	targeted to
	successive argument registers.  Note that an
	<SPLITINLINE>
	  <SCHEME>operand</SCHEME>
	  <JAVASCRIPT>argument</JAVASCRIPT>
	</SPLITINLINE>
	may contain a call
	to an open-coded primitive, so argument registers will have to be
	preserved during
	<SPLITINLINE>
	  <SCHEME>operand</SCHEME>
	  <JAVASCRIPT>argument</JAVASCRIPT>
	</SPLITINLINE>
	evaluation.
      </LI>
      <LI>
	<SPLIT>
	  <JAVASCRIPT>
	    The JavaScript operators 
	    <JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,
	    <SCHEMEINLINE>*</SCHEMEINLINE>,
	    <SCHEMEINLINE>-</SCHEMEINLINE>, and <SCHEMEINLINE>+</SCHEMEINLINE>,
	    among others, are implemented in the register machine as
	    primitive functions, and referred to in the global environment
	    with the symbols
	    <JAVASCRIPTINLINE>"==="</JAVASCRIPTINLINE>,
	    <SCHEMEINLINE>"*"</SCHEMEINLINE>,
	    <SCHEMEINLINE>"-"</SCHEMEINLINE>, and
	    <SCHEMEINLINE>"+"</SCHEMEINLINE>. In JavaScript, it is 
	    not possible to redeclare these names, because they do not
	    meet the syntactic restrictions for names. This means it is safe
	    to open-code them.
	  </JAVASCRIPT>
	</SPLIT>
	For each of the primitive
	<SPLITINLINE>
	  <SCHEME>procedures</SCHEME>
	  <JAVASCRIPT>functions</JAVASCRIPT>
	</SPLITINLINE>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>=</SCHEMEINLINE>,</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>===</JAVASCRIPTINLINE>,</JAVASCRIPT>
	</SPLITINLINE>
	<SCHEMEINLINE>*</SCHEMEINLINE>,
	<SCHEMEINLINE>-</SCHEMEINLINE>, and <SCHEMEINLINE>+</SCHEMEINLINE>,
	write a code generator that takes 
	<SPLITINLINE>
	  <SCHEME>a combination with that operator,
	  </SCHEME>
	  <JAVASCRIPT>an application with a function expression that
	  names that function,
	  </JAVASCRIPT>
	</SPLITINLINE>
	together with a target and a linkage descriptor, and
	produces code to spread the arguments into the registers and then
	perform the operation targeted to the given target with the given
	linkage.
	<SPLITINLINE>
	  <SCHEME>You need only handle expressions with two operands.</SCHEME>
	</SPLITINLINE>
	Make <SCHEMEINLINE>compile</SCHEMEINLINE> dispatch to these code
	generators.
      </LI>
      <LI>
	Try your new compiler on the <SCHEMEINLINE>factorial</SCHEMEINLINE>
	example.  Compare the resulting code with the result produced without
	open coding.
      </LI>
      <SPLIT>
	<SCHEME>
	  <LI>
	    Extend your code generators for <SCHEMEINLINE>+</SCHEMEINLINE> and
	    <SCHEMEINLINE>*</SCHEMEINLINE> so that they
	    can handle expressions with arbitrary numbers of operands.  An
	    expression with more than two operands will have to be compiled into a
	    sequence of operations, each with only two inputs.
	  </LI>
	</SCHEME>
      </SPLIT>
    </OL>
  </EXERCISE>
  <EXERCISE>
    <LABEL NAME="ex:dead-code"/>
    <INDEX>compiler for JavaScript<SUBINDEX>dead code analysis</SUBINDEX></INDEX>

    Footnote<SPACE/><REF NAME="foot:dead-code"/> shows that the compiler does not
    identify all instances of dead code. What would be required of a compiler to
    properly detect all instances of dead code? 
  </EXERCISE>
</SUBSECTION>
