[{"id":"/sicpjs/1.1.5","tag":"TITLE","body":"1.1.5  \n    The Substitution Model for \n    \n      \n      \n        Function\n      \n    \n    Application"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n        To evaluate a function application, the interpreter follows the process\n\tdescribed in section ","tag":"#text"},{"tag":"REF","body":"1.1.4","href":"/sicpjs/1.1.4"},{"body":".\n      \n    That is, the interpreter evaluates the elements of the\n    \n        application\n      \n    and\tapplies the\n    \n\tfunction\n      \n    (which is the value of the\n    \n\tfunction expression of the application)\n      \n    to the arguments (which are the values of the\n    \n\targument expressions of the application).\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n\tWe can assume that the application of primitive\n\tfunctions is handled by the interpreter or libraries. \n      \n    For compound\n    \n\tfunctions,\n      \n    the application process is as follows:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n        To apply a compound\n\t\n\t    function\n\t  \n\tto arguments, \n\t\n\t    evaluate the return expression of the function\n\t  \n\twith each\n\t\n\tparameter replaced by the corresponding argument.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/1.1.5#footnote-1"}]}]},{"body":"\n    To illustrate this process, let's evaluate the\n    \n\tapplication\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":13,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToKwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9chUpRr0CAWwD6VPPsYsOdHgBpQAT35DRY9hKn0mbLn1ABqN2a52ymr4xOTUtHiczPbCouKStHR6hsamHhbMPqjWmfIATLxB6pyYhUA","body":"f(5) "},{"body":"\n    where ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":" is the\n    \n\tfunction declared\n      \n    in section ","tag":"#text"},{"tag":"REF","body":"1.1.4","href":"/sicpjs/1.1.4"},{"body":".\n    We begin by retrieving the\n    \n\treturn expression\n      \n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"sum_of_squares(a + 1, a * 2)"},{"body":"\n    Then we replace the parameter ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" \n    by the argument 5:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"sum_of_squares(5 + 1, 5 * 2)"},{"body":"\n    Thus the problem reduces to the evaluation of\n    \n\tan application\n      \n    with two\n    \n\targuments\n      \n    and \n    \n\ta function expression\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_of_squares"},{"body":".\n      \n    Evaluating this\n    \n\tapplication\n      \n    involves three subproblems.  We must evaluate the\n    function expression\n    to get the\n    \n\tfunction\n      \n    to be applied, and we must evaluate the\n    \n\targument expressions\n      \n    to get the arguments. Now\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5 + 1"},{"body":"\n    produces 6 and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5 * 2"},{"body":"\n    produces 10, so we must apply the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_of_squares"},{"body":" function\n      \n    to 6 and 10. These values are substituted for the\n    \n    parameters ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" and \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":" in the body of \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_of_squares"},{"body":",\n      \n    reducing the expression to\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"square(6) + square(10)"},{"body":"\n    If we use the\n    \n\tdeclaration\n      \n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":", this reduces to\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"(6 * 6) + (10 * 10)"},{"body":"\n    which reduces by multiplication to\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"36 + 100"},{"body":"\n    and finally to\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"136"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    The process we have just described is called the ","tag":"#text"},{"tag":"EM","child":[{"body":"substitution\n    model","tag":"#text"}]},{"body":" for \n    function \n    application.  It can be taken as a model that\n    determines the \"","tag":"#text"},{"body":"meaning","tag":"#text"},{"body":"\" of \n    function \n    application, insofar as the\n    functions \n    in this chapter are concerned.  However, there are two\n    points that should be stressed:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n        The purpose of the substitution is to help us think about\n        function \n        application, not to provide a description of how the interpreter\n\treally works.  Typical interpreters do not evaluate\n        function  \n        applications by manipulating the text of a \n        function to substitute values for the \n        parameters. In practice, the \"","tag":"#text"},{"body":"substitution","tag":"#text"},{"body":"\" is\n\taccomplished by using a local environment for the\n        \n\tparameters. We will discuss this more fully in chapters 3 and\n        4 when we examine the implementation of an interpreter in detail.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        Over the course of this book, we will present a sequence of\n\tincreasingly elaborate models of how interpreters work, culminating\n        with a complete implementation of an interpreter and compiler in\n        chapter ","tag":"#text"},{"tag":"REF","body":"5","href":"/sicpjs/5"},{"body":".  The substitution model is only the first of\n\tthese models—a way to get started thinking formally\n\tabout the evaluation process.  In general, when \n        \n        modeling phenomena in science and engineering, we begin with\n\tsimplified, incomplete models. As we examine things in greater detail,\n\tthese simple models become inadequate and must be replaced by more\n\trefined models. The substitution model is no exception.  In particular,\n\twhen we address in chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":" the use of\n        functions \n        with \"","tag":"#text"},{"body":"mutable data,","tag":"#text"},{"body":"\" we will see that the substitution\n\tmodel breaks down and must be replaced by a more complicated model of\n        function \n        application.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/1.1.5#footnote-2"}]}]}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Applicative order versus normal order","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    According to the description of evaluation given in\n    \n\tsection ","tag":"#text"},{"tag":"REF","body":"1.1.4","href":"/sicpjs/1.1.4"},{"body":",\n      \n    the interpreter first evaluates the\n    \n\tfunction\n      \n    and\n    \n\targument expressions\n      \n    and then applies the resulting\n    \n\tfunction\n      \n    to the resulting arguments. This is not the only way to perform evaluation.\n    An alternative evaluation model would not evaluate the\n    \n\targuments\n      \n    until their values were needed.  Instead it would first substitute\n    \n\targument\n      \n    expressions for parameters until it obtained an expression involving\n    only \n    operators and primitive functions,\n    and would then perform the evaluation.  If we\n    used this method, the evaluation of\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":false,"body":"f(5)"},{"body":"\n    would proceed according to the sequence of expansions\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":false,"body":"sum_of_squares(5 + 1, 5 * 2)\n\nsquare(5 + 1)     + square(5 * 2)\n\n(5 + 1) * (5 + 1) + (5 * 2) * (5 * 2)"},{"body":"\n    followed by the reductions\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":false,"body":"6    *    6    +    10   *   10\n\n    36         +        100\n\n              136"},{"body":"\n    This gives the same answer as our previous evaluation model, but the\n    process is different.  In particular, the evaluations of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5 + 1"},{"body":"\n    and \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5 * 2"},{"body":"\n    are each performed twice here, corresponding to the reduction of the\n    expression\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":false,"body":"x * x"},{"body":"\n    with ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" replaced respectively by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5 + 1"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5 * 2"},{"body":".      \n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    This alternative \"","tag":"#text"},{"body":"fully expand and then reduce","tag":"#text"},{"body":"\"\n    evaluation method is known as \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"normal-order evaluation","tag":"#text"}]},{"body":", in contrast to the \"","tag":"#text"},{"body":"evaluate\n    the arguments and then apply","tag":"#text"},{"body":"\" method that the interpreter actually\n    uses, which is called \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"applicative-order evaluation","tag":"#text"}]},{"body":".  It can be shown that, for \n    function\n    applications that can be modeled using substitution (including all the \n    functions\n    in the first two chapters of this book) and that yield legitimate values,\n    normal-order and applicative-order evaluation produce the same value.\n    (See exercise ","tag":"#text"},{"tag":"REF","body":"1.5","href":"/sicpjs/1.1.6#ex-1.5"},{"body":"\n    for an instance of an \"","tag":"#text"},{"body":"illegitimate","tag":"#text"},{"body":"\" value where normal-order\n    and applicative-order evaluation do not give the same result.)\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n\tJavaScript\n\t\n    uses applicative-order evaluation, partly because of the\n    additional efficiency obtained from avoiding multiple evaluations of\n    expressions such as those illustrated with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5 + 1"},{"body":" \n\tand ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"5 * 2"},{"body":"\n    above and, more significantly, because normal-order evaluation\n    becomes much more complicated to deal with when we leave the realm of\n    functions\n    that can be modeled by substitution.  On the other hand,\n    normal-order evaluation can be an extremely valuable tool, and we will\n    investigate some of its implications in chapters 3 and 4.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/1.1.5#footnote-3"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/1.1.5#footnote-link-1","child":[{"body":"If the\n\tbody of the function is a sequence of statements, the\n\tbody is evaluated with the parameters replaced, and the value of the\n\tapplication is the value of the return expression of the first\n\treturn statement encountered.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/1.1.5#footnote-link-2","child":[{"body":"Despite the\n        simplicity of the substitution idea, it turns out to be\n\tsurprisingly complicated to give a rigorous mathematical\n\tdefinition of the substitution process.  The problem arises\n\tfrom the possibility of confusion between the names used for the \n        parameters of a function \n        and the (possibly identical) names used in the expressions\n        to which the \n        function \n        may be applied.  Indeed, there is a long\n        history of erroneous definitions of ","tag":"#text"},{"tag":"EM","child":[{"body":"substitution","tag":"#text"}]},{"body":" in the\n        literature of logic and programming semantics.  \n        \n        See Stoy 1977 for a\n        careful discussion of substitution.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/1.1.5#footnote-link-3","child":[{"body":"In\n    chapter 3 we will introduce ","tag":"#text"},{"tag":"EM","child":[{"body":"stream processing","tag":"#text"}]},{"body":", which is a\n    way of handling apparently \"","tag":"#text"},{"body":"infinite","tag":"#text"},{"body":"\" data structures\n    by incorporating a limited form of normal-order evaluation.  In\n    section ","tag":"#text"},{"tag":"REF","body":"4.2","href":"/sicpjs/4.2"},{"body":" we will modify the\n    JavaScript\n    interpreter to produce a normal-order variant of\n    JavaScript.","tag":"#text"}]}]