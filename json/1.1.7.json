[{"id":"/sicpjs/1.1.7","tag":"TITLE","body":"1.1.7  Example: Square Roots by Newton's Method"},{"tag":"TEXT","id":"#p1","child":[{"body":"Functions,\n    as introduced above, are much like ordinary mathematical functions.  They\n    specify a value that is determined by one or more parameters.  But there\n    is an important difference between mathematical functions and computer\n    functions.\n        Computer functions\n      \n    must be effective.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    As a case in point, consider the problem of computing square\n    roots.  We can define the square-root function as\n    ","tag":"#text"},{"body":"\n      \\[\n      \\sqrt{x}\\ =\\text{ the }y\\text{ such that }y \\geq 0\\text{ and }\n      y^2\\ =\\ x\n      \\]\n    ","tag":"LATEX"},{"body":"\n    This describes a perfectly legitimate mathematical function.  We could\n    use it to recognize whether one number is the square root of another, or\n    to derive facts about square roots in general.  On the other hand, the\n    definition does not describe a\n    computer function.\n    Indeed, it tells us almost nothing about how to actually find the square\n    root of a given number.  It will not help matters to rephrase this\n    definition in\n    pseudo-JavaScript:","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction sqrt(x) {\n    return the y $\\texttt{with}$ y >= 0 && square(y) === x;\n}\n      "},{"body":"\n    This only begs the question.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    The contrast between\n    \n        mathematical function and computer function\n      \n    is a reflection of the general distinction between describing properties of\n    things and describing how to do things, or, as it is sometimes referred to,\n    the distinction between\n    \n    declarative knowledge and imperative knowledge. In\n    \n    mathematics we are usually concerned with declarative (what is)\n    descriptions, whereas in computer science we are usually concerned\n    with imperative (how to) descriptions.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/1.1.7#footnote-1"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    How does one compute\n    \n    square roots?  The most common way is to use\n    Newton's method of successive approximations, which says that whenever\n    we have a guess ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" for the value of the square\n    root of a number ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":", we can perform a simple\n    manipulation to get a better guess (one closer to the actual square root)\n    by averaging ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" with\n    ","tag":"#text"},{"body":"$x/y$","tag":"LATEX"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/1.1.7#footnote-2"},{"body":"\n    For example, we can compute the square root of 2 as follows.  Suppose our\n    initial guess is 1:\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      \\textrm{Guess} & \\textrm{Quotient} & \\textrm{Average}\\\\[1em]\n      1      & {\\displaystyle \\frac{2}{1} = 2}           & {\\displaystyle \\frac{(2+1)}{2} = 1.5} \\\\[1em]\n      1.5    & {\\displaystyle \\frac{2}{1.5} = 1.3333}    & {\\displaystyle \\frac{(1.3333+1.5)}{2} = 1.4167} \\\\[1em]\n      1.4167 & {\\displaystyle \\frac{2}{1.4167} = 1.4118} & {\\displaystyle \\frac{(1.4167+1.4118)}{2} = 1.4142} \\\\[1em]\n      1.4142 & \\ldots & \\ldots\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    Continuing this process, we obtain better and better approximations to the\n    square root.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Now let's formalize the process in terms of functions.  We start with\n    a value for the\n    \n    radicand (the number whose square root we are trying to compute) and a value\n    for the guess.  If the guess is good enough for our purposes, we are done;\n    if not, we must repeat the process with an improved guess.  We write this\n    basic strategy as a\n    \n        function:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":21,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq0KJgB9AHMqKgATIOEiKgIQgAsWEIJhJiYAGjUHPgERMQl6ZhYrGzsUtKYuHU5QAB5FNAUFFH0jfF8zWjoAN2FBOhDhdiyATxynfNdQdlAAalBx0DAAJjafU39QCgBbAAdBKj7k1PSs2sc8l0Le-sHhirO1ZdBHqvWOzfMrQTIgijI-ROlXOEyuBQCwTCkWisXiSTeoNyThRqjeyJRAk0Pz+AKBuwORwep0y2VBHxx-0BghYAGYsisAKwcXRAA","body":"function sqrt_iter(guess, x) {\n    return is_good_enough(guess, x)\n           ? guess\n           : sqrt_iter(improve(guess, x), x);\n} "},{"body":"\n    A guess is improved by averaging it with the quotient of the radicand and\n    the old guess:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDANwFMAnOgcyYAoAPAGlABPAJSgA3tlBTQLJmQItavUAGohosACYA3NgC+uQqUo1QFALYAHFlWZd2BJgGcnAnqInSZchbUasObgdnV1AeUDBgl2FdA2wLa1tuAGYBTQBWGKA","body":"function improve(guess, x) {\n    return average(guess, x / guess);\n} "},{"body":"\n    where\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDANwFMAnOgcyYAoAPAGlABPAJSgA3tlBTQLJmQItavUAGohosACYA3NgC+uRqw7cAzAIBsw7UA","body":"function average(x, y) {\n    return (x + y) / 2;\n} "},{"body":"\n    We also have to say what we mean by \"","tag":"#text"},{"body":"good enough.","tag":"#text"},{"body":"\"  The\n    following will do for illustration, but it is not really a very good\n    test.  (See exercise ","tag":"#text"},{"tag":"REF","body":"1.7","href":"/sicpjs/1.1.7#ex-1.7"},{"body":".)\n    The idea is to improve the answer until it is close enough so that its\n    square differs from the radicand by less than a predetermined\n    tolerance (here 0.001):","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/1.1.7#footnote-3"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":9,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq0KJgB9AHMqKgATIOEiKgIQgAsWEIJhJiYAGjUHPgERMQl6ZhYrGzsUtKYuHU5QAB5FNAUFFH0jbEDQ8KiYuMSWdAAWFCyAJg5dIA","body":"function is_good_enough(guess, x) {\n    return abs(square(guess) - x) < 0.001;\n} "},{"body":"\n    Finally, we need a way to get started.  For instance, we can always guess\n    that the square root of any number\n    is 1:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":27,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq0KJgB9AHMqKgATIOEiKgIQgAsWEIJhJiYAGjUHPgERMQl6ZhYrGzsUtKYuHU5QAB5FNAUFFH0jfF8zWjoAN2FBOhDhdiyATxynfNdQdlAAalBx0DAAJjafU39QCgBbAAdBKj7k1PSs2sc8l0Le-sHhirO1ZdBHqvWOzfMrQTIgijI-ROlXOEyuBQCwTCkWisXiSTeoNyThRqjeyJRAk0Pz+AKBuwORwep0y2VBHxMfm+ll+9h4GKmhRx-0BghYKHJ3mwOJYAFYOLogA","body":"function sqrt(x) {\n    return sqrt_iter(1, x);\n} "},{"body":"\n    If we type these\n    \n\tdeclarations\n      \n    to the interpreter, we can use ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":"\n    just as we can use any\n    \n        function:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":31,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq0KJgB9AHMqKgATIOEiKgIQgAsWEIJhJiYAGjUHPgERMQl6ZhYrGzsUtKYuHU5QAB5FNAUFFH0jfF8zWjoAN2FBOhDhdiyATxynfNdQdlAAalBx0DAAJjafU39QCgBbAAdBKj7k1PSs2sc8l0Le-sHhirO1ZdBHqvWOzfMrQTIgijI-ROlXOEyuBQCwTCkWisXiSTeoNyThRqjeyJRAk0Pz+AKBuwORwep0y2VBHxMfm+ll+9h4GKmhRx-0BghYKHJ3mwOJYAE4OLogA","body":"sqrt(9); ","output":"3.00009155413138"},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":31,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq0KJgB9AHMqKgATIOEiKgIQgAsWEIJhJiYAGjUHPgERMQl6ZhYrGzsUtKYuHU5QAB5FNAUFFH0jfF8zWjoAN2FBOhDhdiyATxynfNdQdlAAalBx0DAAJjafU39QCgBbAAdBKj7k1PSs2sc8l0Le-sHhirO1ZdBHqvWOzfMrQTIgijI-ROlXOEyuBQCwTCkWisXiSTeoNyThRqjeyJRAk0Pz+AKBuwORwep0y2VBHxMfm+ll+9h4GKmhRx-0BghYKHJ3mwOPZzXmoAAzJgOLogA","body":"sqrt(100 + 37); ","output":"11.704699917758145"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":31,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq0KJgB9AHMqKgATIOEiKgIQgAsWEIJhJiYAGjUHPgERMQl6ZhYrGzsUtKYuHU5QAB5FNAUFFH0jfF8zWjoAN2FBOhDhdiyATxynfNdQdlAAalBx0DAAJjafU39QCgBbAAdBKj7k1PSs2sc8l0Le-sHhirO1ZdBHqvWOzfMrQTIgijI-ROlXOEyuBQCwTCkWisXiSTeoNyThRqjeyJRAk0Pz+AKBuwORwep0y2VBHxMfm+ll+9h4GKmhRx-0BghYKHJ3mwOJKNLILBWXAWPIAzBwOLogA","body":"sqrt(sqrt(2) + sqrt(3)); ","output":"1.7739279023207892"},{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":31,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq0KJgB9AHMqKgATIOEiKgIQgAsWEIJhJiYAGjUHPgERMQl6ZhYrGzsUtKYuHU5QAB5FNAUFFH0jfF8zWjoAN2FBOhDhdiyATxynfNdQdlAAalBx0DAAJjafU39QCgBbAAdBKj7k1PSs2sc8l0Le-sHhirO1ZdBHqvWOzfMrQTIgijI-ROlXOEyuBQCwTCkWisXiSTeoNyThRqjeyJRAk0Pz+AKBuwORwep0y2VBHxMfm+ll+9h4GKmhRx-0BghYKHJ3mwpVswxx7OaCg4HF0QA","body":"square(sqrt(1000)); ","output":"1000.000369924366"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    The ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":" program also illustrates that the\n    simple\n    \n\tfunctional\n      \n    language we have introduced so far is sufficient for writing any purely\n    numerical program that one could write in, say, C or Pascal.  This might\n    seem surprising, since we have not included in our language any iterative\n    \n    (looping) constructs that direct the computer to do something over and over\n    again.\n    \n\tThe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":",\n      \n    on the other hand, demonstrates how iteration can be accomplished using no\n    special construct other than the ordinary ability to call a\n    function.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/1.1.7#footnote-4"}]},{"tag":"EXERCISE","title":"Exercise 1.6","id":"#ex-1.6","child":[{"body":"\n        Alyssa P. Hacker doesn't like the syntax of\n        \n\tconditional\n\texpressions, involving the characters ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"?"},{"body":"\n\tand ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":":"},{"body":".\n\t\"","tag":"#text"},{"body":"Why can't I just\n\tdeclare an ordinary conditional function whose application \n\tworks just like conditional expressions?","tag":"#text"},{"body":"\"\n\tshe asks.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/1.1.7#footnote-5"},{"body":"\n\tAlyssa's friend Eva Lu Ator claims this can indeed be\n\tdone, and she declares a ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"conditional"},{"body":"\n\tfunction as follows:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQSaATCymgQwBsAKABwCcBTJiVZl+AGlBkAFvyIB9Eu1YEAzuND92ahUtX8AlKADeASBOgLobJdACyBXrT6CKw0aAD8kmfMXK1oABcGlr8Ov78ANzYAL5AA","body":"function conditional(predicate, then_clause, else_clause) {\t\t    \n    return predicate ? then_clause : else_clause;\n} "},{"body":"\n        Eva demonstrates the program for Alyssa:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":11,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQSaATCymgQwBsAKABwCcBTJiVZl+AGlBkAFvyIB9Eu1YEAzuND92ahUtX8AlKADeASBOgLobJdACyBXrT6CKw0aAD8kmfMXK1oABcGlr8Ov78ANzYAL649ERMLEQcnABMoAC82aAAzBIADBIArPqRQA","body":"conditional(2 === 3, 0, 5); ","output":"5"},{"tag":"SNIPPET","latex":false,"id":12,"eval":true,"prependLength":5,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQSaATCymgQwBsAKABwCcBTJiVZl+AGlBkAFvyIB9Eu1YEAzuND92ahUtX8AlKADeASBOgLobJdACyBXrT6CKw0aAD8kmfMXK1oABcGlr8Ov78ANzYAL649ERMLEQcnCigALxZqBIADBIArPqRQA","body":"conditional(1 === 1, 0, 5); ","output":"0"},{"body":"\n\tDelighted, Alyssa uses\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"conditional"},{"body":" to rewrite the square-root\n        program:\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":13,"eval":true,"prependLength":25,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQSaATCymgQwBsAKABwCcBTJiVZl+AGlBkAFvyIB9Eu1YEAzuND92ahUtX8AlKADeASBOgLobJdACyBXrT6CKw0aAD8kmfMXK1oABcGlr8Ov78ANzYAL64hKQstKwARiqcAB6GRtaWdg60GaAAfAC8oAAMnqBFwQC0NdFx+MTk1LQqAI4ErAKZ2bkW+Y41oABUjbHxrUmgFCpyAOZUVAxyslQEi1KciwT8KioSWcaDtvz2I6npXT19ewcqhg0nADyVaBUVKE3Tie2gVgAN34vFYi34mQkAE8BjZhrRMqAANSgWGgMAAJl+LX+NDmAFs+FQQbt9odjnC8hcCoCQWCIWTHscMaAHod9DiEm18V1eGQ5MxQUyKTUqUMaSN6EQmEkOJx5ksVmsNlsduyjmKxGcbLq9TYNdr9cbjXyBULeAqibwSZDDVqdSanSaspyptgzYLRJaAMwSTEAVk5QA","body":"function sqrt_iter(guess, x) {\n    return conditional(is_good_enough(guess, x),\n                       guess,\n                       sqrt_iter(improve(guess, x),\n                                 x));\n} "},{"body":"\n        What happens when Alyssa attempts to use this to compute square roots?\n        Explain.\n        ","tag":"#text"}],"solution":[{"body":"\n\t  Any call of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":"\n\t  leads immediately to an infinite loop. The reason for this is our\n\t  applicative-order evaluation. The evaluation of the return expression\n\t  of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":" needs to evaluate\n\t  its arguments first, including the recursive call of\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":", regardless whether the\n\t  predicate evaluates to ","tag":"#text"},{"tag":"EM","child":[{"body":"true","tag":"#text"}]},{"body":" or ","tag":"#text"},{"tag":"EM","child":[{"body":"false","tag":"#text"}]},{"body":". The same of\n\t  course happens with the recursive call, and thus the function\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"conditional"},{"body":" never actually gets\n\t  applied.\n\t","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 1.7","id":"#ex-1.7","child":[{"body":"\n    The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    test used in computing square roots will not be very effective for finding\n    the square roots of very small numbers. Also, in real computers, arithmetic\n    operations are almost always performed with limited precision.  This makes\n    our test inadequate for very large numbers.  Explain these statements, with\n    examples showing how the test fails for small and large numbers.  An\n    alternative strategy for implementing\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    is to watch how ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"guess"},{"body":" changes from one\n    iteration to the next and to stop when the change is a very small fraction\n    of the guess.  Design a square-root\n    \n        function\n      \n    that uses this kind of end test.  Does this work better for small and\n    large numbers?\n    ","tag":"#text"}],"solution":[{"body":"\n      The absolute tolerance of 0.001 is too large when computing the square\n      root of a small value. For example,\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt(0.0001)"},{"body":"\n      results in 0.03230844833048122 instead of the expected value 0.01,\n      an error of over 200%.\n      \n      On the other hand, for very large values, rounding errors might make\n      the algorithm fail to ever get close enough to the square root, in which\n      case it will not terminate.\n      \n      The following program alleviates the problem by replacing an absolute\n      tolerance with a relative tolerance.\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":14,"eval":true,"prependLength":27,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGvQBuwwXQDmw9gBpQATy68BQ0eNrtQAalcuMAAmfSN8YnJqWiYAR0Eydnc+ARExCVB4xIB9CjJrFhRnTnDjKLNaCgBbAAdBKisWWwJhJiYSlM90n0trOwcWto61UDAh9o4yyNMYrISyPILBZtb2zp5U-h7MiiYc2yoqABMc4SIqAlsAC1Xhzq3PT1UJpken-k1sxfzCmvrGoM1iNOJ1piZouZ4gQ6CJkptut5MlIAFR6Qy4Eg0JhkLwAGzolCsOTIVDx-VIwlA8gUaAU9JQ+ghlVAewOR1O50uNzu6zUXTSSNojFY0NhQOGXB0nFAAB5QK9QGiRASicISWSKSRhNNjntagSXCxvixafSFCgOFNsHqmAa6EaTQAWc2ut1W3RAA","body":"const relative_tolerance = 0.0001;\nfunction is_good_enough(guess, x) {\n    return abs(square(guess) - x) < guess * relative_tolerance;\n} "}]},{"tag":"EXERCISE","title":"Exercise 1.8","id":"#ex-1.8","child":[{"body":"\n    Newton's method for\n    \n    cube roots is based on the fact that if\n    ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" is an\n    approximation to the cube root of ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":", then a better approximation is\n    given by the value\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{lll}\n      \\dfrac{x/y^{2}+2y} {3}\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    Use this formula to implement a cube-root\n    \n\tfunction\n      \n    analogous to the square-root\n    function.\n    (In section ","tag":"#text"},{"tag":"REF","body":"1.3.4","href":"/sicpjs/1.3.4"},{"body":" we will see how to\n    implement Newton's method in general as an abstraction of these\n    square-root and cube-root\n    functions.)","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":15,"eval":true,"prependLength":9,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToOwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqBIEGw9l14Cho8ZNAAqNW72HjxctVoUTAD6AOZUVAAmQcJEVAQhABYsIQTCTEwANGp2fAIiYhL0zCyW1smp6Vw6nKAAPIpoCgoo+kYmfuYRFABuAMzsWQCeOQ6OBbTsoADUoMOgYL2t+L5mAQC2AA6CVN02KWmZ2Ty5-PnOoF19k2DlB577lVkATPcVTBxL7asWVsJB21QyLd0lkavY8k5CoFQuEojE4olgYdOCdRgJVA8mKi0aBNKU-gCgRRNttdkjQRwKUtsPj-uEgb1npgPkA","body":"function is_good_enough(guess, x) {\n    return abs(cube(guess) - x) < 0.001;\n}\nfunction div3(x, y) {\n     return (x + y) / 3;\n}\nfunction improve(guess, x) {\n    return div3(x / (guess * guess), 2 * guess);\n}\nfunction cube_root(guess, x) {\n    return is_good_enough(guess, x)\n           ? guess\n           : cube_root(improve(guess, x), x);\n} "}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/1.1.7#footnote-link-1","child":[{"body":"Declarative and\n    imperative descriptions are intimately related, as indeed are\n    mathematics and computer science.  For instance, to say that the\n    answer produced by a program is\n    \"","tag":"#text"},{"body":"correct","tag":"#text"},{"body":"\" is to make a declarative statement about the program.\n    There is a large amount of research aimed at establishing techniques for\n    \n    proving that programs are correct, and much of the technical difficulty of\n    this subject has to do with negotiating the transition between imperative\n    statements (from which programs are constructed) and declarative statements\n    (which can be used to deduce things).\n    \n\tIn a related vein, programming language designers have explored\n\tso-called\n\t\n\tvery high-level languages, in which one actually programs in terms of\n\tdeclarative statements.\n      \n    The idea is to make interpreters sophisticated\n    enough so that, given \"","tag":"#text"},{"body":"what is","tag":"#text"},{"body":"\" knowledge specified by the\n    programmer, they can generate \"","tag":"#text"},{"body":"how to","tag":"#text"},{"body":"\" knowledge automatically.\n    This cannot be done in general, but there are important areas where progress\n    has been made.  We shall revisit this idea in chapter ","tag":"#text"},{"tag":"REF","body":"4","href":"/sicpjs/4"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/1.1.7#footnote-link-2","child":[{"body":"This square-root algorithm is\n    actually a special case of Newton's method, which is a general\n    technique for finding roots of equations.  The square-root algorithm itself\n    was developed by Heron of\n    \n    Alexandria in the first century CE.  We will see how to express\n    the general Newton's method as a\n    \n        JavaScript function\n      \n    in section ","tag":"#text"},{"tag":"REF","body":"1.3.4","href":"/sicpjs/1.3.4"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/1.1.7#footnote-link-3","child":[{"body":"We will usually give\n    \n    predicates names starting with ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_"},{"body":", to help us remember that they\n    are predicates.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/1.1.7#footnote-link-4","child":[{"body":"Readers who are worried about the efficiency issues involved in using\n    \n\tfunction\n      \n    calls to implement iteration should note the remarks on \"","tag":"#text"},{"body":"tail\n    recursion","tag":"#text"},{"body":"\" in\n    section ","tag":"#text"},{"tag":"REF","body":"1.2.1","href":"/sicpjs/1.2.1"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/1.1.7#footnote-link-5","child":[{"body":"\n\tAs a Lisp hacker from the original ","tag":"#text"},{"tag":"EM","child":[{"body":"Structure and Interpretation\n\tof Computer Programs","tag":"#text"}]},{"body":", Alyssa prefers a simpler, more uniform\n\tsyntax.","tag":"#text"}]}]