[{"id":"/sicpjs/4.4","tag":"TITLE","body":"4.4  Logic Programming"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In chapter ","tag":"#text"},{"tag":"REF","body":"1","href":"/sicpjs/1"},{"body":" we stressed that computer science deals with\n    \n    imperative\n    (how to) knowledge, whereas mathematics deals with declarative (what\n    is) knowledge.  Indeed, programming languages require that the\n    programmer express knowledge in a form that indicates the step-by-step\n    methods for solving particular problems.  On the other hand,\n    high-level languages provide, as part of the language implementation,\n    a substantial amount of methodological knowledge that frees\n    the user from concern with numerous details of how a specified\n    computation will progress.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Most programming languages, including\n    JavaScript,\n    are organized around\n    computing the values of mathematical functions.  Expression-oriented\n    languages\n    \n\t(such as Lisp, C, Python, and JavaScript)\n      \n    capitalize on the\n    \"","tag":"#text"},{"body":"pun","tag":"#text"},{"body":"\" that an expression that describes the value of a\n    function may also be interpreted as a means of computing that value.\n    Because of this, most programming languages are strongly biased toward\n    unidirectional computations (computations with well-defined inputs and\n    outputs). There are, however, radically different programming languages\n    that relax this bias.  We saw one such example in\n    section ","tag":"#text"},{"tag":"REF","body":"3.3.5","href":"/sicpjs/3.3.5"},{"body":", where the objects of\n    computation were arithmetic constraints.  In a constraint system the\n    direction and the order of computation are not so well specified; in\n    carrying out a computation the system must therefore provide more detailed\n    \"","tag":"#text"},{"body":"how to","tag":"#text"},{"body":"\" knowledge than would be the case with an ordinary\n    arithmetic computation.  This does not mean, however, that the user is\n    released altogether from the responsibility of providing imperative\n    knowledge. There are many constraint networks that implement the same set\n    of constraints, and the user must choose from the set of mathematically\n    equivalent networks a suitable network to specify a particular computation.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    The nondeterministic program evaluator of\n    section ","tag":"#text"},{"tag":"REF","body":"4.3","href":"/sicpjs/4.3"},{"body":" also moves\n    away from the view that programming is about constructing algorithms for\n    computing unidirectional functions.  In a nondeterministic language,\n    expressions can have more than one value, and, as a result, the\n    computation is\n    dealing with\n    \n    relations rather than with single-valued functions.  Logic\n    programming extends this idea by combining a relational vision of programming\n    with a powerful kind of symbolic pattern matching called \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"unification","tag":"#text"}]},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/4.4#footnote-1"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    This approach, when it works, can be a very\n    \n    powerful way to write programs.\n    Part of the power comes from the fact that a single \"","tag":"#text"},{"body":"what is","tag":"#text"},{"body":"\"\n    fact can be used to solve a number of different problems that would have\n    different \"","tag":"#text"},{"body":"how to","tag":"#text"},{"body":"\" components.  As an example, consider the \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" operation, which takes two lists as\n    arguments and combines their elements to form a single list.  In a procedural\n    language such as\n    JavaScript,\n    we could define ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" in terms of the\n    basic list constructor\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":",\n    as we did in section ","tag":"#text"},{"tag":"REF","body":"2.2.1","href":"/sicpjs/2.2.1"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAFgHQoFCYGYFcA7AYwBcBLAewNAEMAHOgUwIBMAKADwBpQBPASlABvUKNCYxoAE6MSeKdTIBnAPoE8AGw2d+EyftAB+PnoNiAXKDo0yUtgAtGNdh3496TVmxI3trngL8ANyYAL5AA","body":"function append(x, y) {    \n    return is_null(x)\n           ? y\n           : pair(head(x), append(tail(x), y));\n} "},{"body":"This\n    function\n    can be regarded as a translation into\n    JavaScript\n    of the following two rules, the first of which covers the case where the\n    first list is empty and the second of which handles the case of a nonempty\n    list, which is a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    of two parts:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tFor any list ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":", the empty list and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" to\n\tform ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":".\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tFor any ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"u"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"v"},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":", and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"z"},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair(u, v)"},{"body":"\n\tand ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":"\n\tto form\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair(u, z)"},{"body":"\n\tif ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"v"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" to form\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"z"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/4.4#footnote-2"}]}]},{"body":"\n    Using the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":"function,\n    we can answer questions such as\n    ","tag":"#text"},{"tag":"EPIGRAPH","child":[{"body":"\n      Find the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" of\n      ","tag":"#text"},{"child":[{"tag":"JAVASCRIPTINLINE","body":"list(\"a\", \"b\")"}]},{"body":"\n      and\n      ","tag":"#text"},{"child":[{"tag":"JAVASCRIPTINLINE","body":"list(\"c\", \"d\")"},{"body":".\n      ","tag":"#text"}]},{}]},{"body":"\n    But the same two rules are also sufficient for answering the following\n    sorts of questions, which the\n    function\n    can't answer:\n    ","tag":"#text"},{"tag":"EPIGRAPH","child":[{"body":"\n      Find a list ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":"\n      that\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":"s with\n      ","tag":"#text"},{"child":[{"tag":"JAVASCRIPTINLINE","body":"list(\"a\", \"b\")"}]},{"body":"\n      to produce\n      ","tag":"#text"},{"child":[]},{}]},{"tag":"EPIGRAPH","child":[{"body":"\n      Find all ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":"\n      that ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" to form\n      ","tag":"#text"},{"child":[{"tag":"JAVASCRIPTINLINE","body":"list(\"a\", \"b\", \"c\", \"d\")"},{"body":".\n\t","tag":"#text"}]},{}]},{"body":"\n    In a\n    \n    logic programming language, the programmer writes an\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":"\"","tag":"#text"},{"body":"function","tag":"#text"},{"body":"\"\n    by stating the two rules about ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" given\n    above.\n    \"","tag":"#text"},{"body":"How to","tag":"#text"},{"body":"\" knowledge is provided automatically by the\n    interpreter to allow this single pair of rules to be used to answer all\n    three types of questions about\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/4.4#footnote-3"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Contemporary logic programming languages (including the one we\n    implement here) have substantial deficiencies, in that their general\n    \"","tag":"#text"},{"body":"how to","tag":"#text"},{"body":"\" methods can lead them into spurious infinite loops or\n    other undesirable behavior. Logic programming is an active field of research\n    in computer science.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/4.4#footnote-4"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Earlier in this chapter we explored the technology of implementing\n    interpreters and described the elements that are essential to an\n    interpreter for a\n    JavaScript-like\n    language (indeed, to an interpreter for any conventional language).  Now we\n    will apply these ideas to discuss an interpreter for a logic programming\n    language.  We call this\n    language the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"query language","tag":"#text"}]},{"body":", because it is very useful for\n    retrieving information from data bases by formulating \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"queries","tag":"#text"}]},{"body":", or questions, expressed in the language.  Even though the\n    query language is very different from\n    JavaScript,\n    we will find it convenient to describe the language in terms of the same\n    general framework we have been using all along: as a collection of primitive\n    elements, together with means of combination that enable us to combine\n    simple elements to create more complex elements and means of abstraction\n    that enable us to regard complex elements as single conceptual units.  An\n    interpreter for a logic programming language is considerably more complex\n    than an interpreter for a language like\n    JavaScript.\n    Nevertheless, we will see\n    that our\n    \n    query-language interpreter contains many of the same elements\n    found in the interpreter of section ","tag":"#text"},{"tag":"REF","body":"4.1","href":"/sicpjs/4.1"},{"body":".  In\n    particular, there will be an \"","tag":"#text"},{"body":"evaluate","tag":"#text"},{"body":"\" part that classifies\n    expressions according to type and an \"","tag":"#text"},{"body":"apply","tag":"#text"},{"body":"\" part that\n    implements the language's abstraction mechanism\n    (functions\n    in the case of\n    JavaScript,\n    and ","tag":"#text"},{"tag":"EM","child":[{"body":"rules","tag":"#text"}]},{"body":" in the case of logic programming).  Also, a central role\n    is played in the implementation by a frame data structure, which determines\n    the correspondence between symbols and their associated values.  One\n    additional interesting aspect of our query-language implementation is\n    that we make substantial use of streams, which were introduced in\n    chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":".\n  ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/4.4#footnote-link-1","child":[{"body":"Logic programming has grown out of a long\n    \n    history of research in\n    \n    automatic theorem proving.  Early theorem-proving\n    programs could accomplish very little, because they exhaustively searched\n    the space of possible proofs.  The major breakthrough that made such a\n    search plausible was the discovery in the early 1960s of the \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"unification algorithm","tag":"#text"}]},{"body":" and the \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"resolution principle","tag":"#text"}]},{"body":" (Robinson 1965).  \n    Resolution was used, for example, by \n    \n    Green and Raphael (1968) (see also Green 1969) as the\n    basis for a deductive question-answering system.  During most of this period,\n    researchers concentrated on algorithms that are guaranteed to find a proof if\n    one exists.  Such algorithms were difficult to control and to direct toward\n    a proof.  \n    \n    Hewitt (1969) recognized the possibility of merging the control structure of\n    a programming language with the operations of a logic-manipulation system,\n    leading to the work in automatic search mentioned in\n    section ","tag":"#text"},{"tag":"REF","body":"4.3.1","href":"/sicpjs/4.3.1"},{"body":"\n    (footnote ","tag":"#text"},{"tag":"REF","body":5,"href":"/sicpjs/4.3.1#footnote-5"},{"body":").  At the same time that this\n    was being done,\n    \n    Colmerauer, in Marseille, was developing rule-based systems for manipulating\n    natural language (see Colmerauer et al. 1973).\n    He invented a programming language called \n    \n    Prolog for representing those rules.  \n    Kowalski (1973; 1979)\n    in Edinburgh, recognized that execution of a Prolog program could be\n    interpreted as proving theorems (using a proof technique called linear \n    \n    Horn-clause resolution).  The merging of the last two strands led to the\n    logic-programming movement.  Thus, in assigning credit for the development\n    of logic programming, the French can point to Prolog's genesis at the \n    \n    University of Marseille, while the British can highlight the work at the \n    \n    University of Edinburgh. According to people at \n    \n    MIT, logic programming was developed by these groups in an attempt to figure\n    out what Hewitt was talking about in his brilliant but impenetrable Ph.D.\n    thesis.  For a history of logic\n    programming, see\n    Robinson 1983.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/4.4#footnote-link-2","child":[{"body":"To see the correspondence\n\tbetween the rules and the\n\tfunction,\n\tlet ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" in the\n\tfunction\n\t(where ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" is nonempty) correspond to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair(u, v)"},{"body":"\n\tin the rule.  Then ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"z"},{"body":" in the rule corresponds\n\tto the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail(x)"},{"body":"\n\tand ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/4.4#footnote-link-3","child":[{"body":"This certainly does not\n    relieve the user of the entire problem of how to compute the answer. There\n    are many different mathematically equivalent sets of rules for formulating\n    the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" relation, only some of which can be\n    turned into effective devices for computing in any direction.  In addition,\n    sometimes \"","tag":"#text"},{"body":"what is","tag":"#text"},{"body":"\" information gives no clue\n    \"","tag":"#text"},{"body":"how to","tag":"#text"},{"body":"\" compute an answer.  For example, consider the problem\n    of computing the ","tag":"#text"},{"body":"$y$","tag":"LATEX"},{"body":" such that\n    ","tag":"#text"},{"body":"$y^2 = x$","tag":"LATEX"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/4.4#footnote-link-4","child":[{"body":"Interest in logic programming peaked\n    \n    during the early 1980s when the Japanese government began an ambitious\n    project aimed at building superfast computers optimized to run logic\n    programming languages.  The speed of such computers was to be measured\n    in LIPS (Logical Inferences Per Second) rather than the usual FLOPS\n    (FLoating-point Operations Per Second).  Although the project\n    succeeded in developing hardware and software as originally planned,\n    the international computer industry moved in a different direction.\n    See \n    Feigenbaum and Shrobe 1993 for an overview evaluation\n    of the Japanese project.  The logic programming community has also moved on\n    to consider relational programming based on techniques other than\n    simple pattern matching, such as the ability to deal with numerical\n    constraints such as the ones illustrated in the constraint-propagation\n    system of section ","tag":"#text"},{"tag":"REF","body":"3.3.5","href":"/sicpjs/3.3.5"},{"body":".","tag":"#text"}]}]