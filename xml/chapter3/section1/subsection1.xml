    <SUBSECTION>
      <NAME>
        Local State Variables
      </NAME>

      <LABEL NAME="sec:local-state-variables"/>
      <INDEX>local state variable|(</INDEX>
      <INDEX>state variable<SUBINDEX>local|(</SUBINDEX></INDEX>

      <TEXT>
        <INDEX>bank account</INDEX>
        <INDEX>object(s)<SUBINDEX>with time-varying state</SUBINDEX></INDEX>
        To illustrate what we mean by having a computational object with
        time-varying state, let us model the situation of withdrawing money
        from a bank account.  We will do this using a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SCHEMEINLINE>withdraw</SCHEMEINLINE>, which takes as argument an <SCHEMEINLINE>amount</SCHEMEINLINE> 
  to be withdrawn.
        If there is enough money in the account to accommodate the withdrawal,
        then <SCHEMEINLINE>withdraw</SCHEMEINLINE> should return the balance remaining after the
        withdrawal.  Otherwise, <SCHEMEINLINE>withdraw</SCHEMEINLINE> should return the message <EM>
        Insufficient funds.</EM> For example, if we begin with <DOLLAR/>100 in the
        account, we should obtain the following sequence of responses using
        <SCHEMEINLINE>withdraw</SCHEMEINLINE>:

        <SNIPPET EVAL="yes">
          <NAME>withdraw_example</NAME>
          <REQUIRES>withdraw</REQUIRES>
          <SCHEME>
(withdraw 25) ;; output: 75
          </SCHEME>
          <SCHEMEOUTPUT>
75
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
withdraw(25); // output: 75
          </JAVASCRIPT>
        </SNIPPET>
       
        <SNIPPET EVAL="yes">
          <NAME>withdraw_example2</NAME>
          <REQUIRES>withdraw</REQUIRES>
          <REQUIRES>withdraw_example</REQUIRES>
          <SCHEME>
(withdraw 25) ;; output: 50
          </SCHEME>
          <SCHEMEOUTPUT>
50
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
withdraw(25); // output: 50
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET EVAL="yes">
          <NAME>withdraw_example3</NAME>
          <REQUIRES>withdraw</REQUIRES>
          <REQUIRES>withdraw_example</REQUIRES>
          <REQUIRES>withdraw_example2</REQUIRES>
          <SCHEME>
(withdraw 60) ;; output: "Insufficient funds"
          </SCHEME>
          <SCHEMEOUTPUT>
"Insufficient funds"
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
withdraw(60); // output: "Insufficient funds"
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET EVAL="yes">
          <NAME>withdraw_example4</NAME>
          <REQUIRES>withdraw</REQUIRES>
          <REQUIRES>withdraw_example</REQUIRES>
          <REQUIRES>withdraw_example2</REQUIRES>
          <REQUIRES>withdraw_example3</REQUIRES>
          <SCHEME>
(withdraw 15) ;; output: 35
          </SCHEME>
          <SCHEMEOUTPUT>
35
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
withdraw(15); // output: 35
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Observe that the expression <SPLITINLINE><SCHEME><SCHEMEINLINE>(withdraw 25)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>withdraw(25)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, evaluated twice,
        yields different values.  This is a new kind of behavior for a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.  Until now, all our
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        could be viewed as
        specifications for computing mathematical functions.  A call to a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        computed the value of the function applied to the given
        arguments, and two calls to the same
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        with the
        same arguments always produced the same result.<FOOTNOTE>Actually,
          this is not quite true.  One exception was the 
          <!-- \indprim{random}[assignment needed for] -->
          <INDEX>random-number generator</INDEX>
          random-number generator
          in section<SPACE/><REF NAME="sec:primality"/>.  Another exception involved the
          <INDEX>operation-and-type table<SUBINDEX>assignment needed for</SUBINDEX></INDEX>
          operation/type tables we introduced in section<SPACE/><REF NAME="sec:data-directed"/>,
          where the values of two calls to <SCHEMEINLINE>get</SCHEMEINLINE> with the same arguments
          depended on intervening calls to <SCHEMEINLINE>put</SCHEMEINLINE>.
          On the other hand, until we introduce
          assignment, we have no way to create such
          <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
          ourselves.</FOOTNOTE>
      </TEXT>

      <TEXT>
	<SPLIT>
	  <JAVASCRIPT>
	    So far, all our names were <EM>constants</EM> as declared by the keyword
	    <JAVASCRIPTINLINE>const</JAVASCRIPTINLINE>. Once declared, they did not change their value,
	    as appropriate for constants.
	    To implement functions like  <SCHEMEINLINE>withdraw</SCHEMEINLINE>, we introduce a new kind
	    of declaration<EMDASH/><EM>variable declarations</EM> using the keyword <JAVASCRIPTINLINE>let</JAVASCRIPTINLINE>
	    instead of <JAVASCRIPTINLINE>const</JAVASCRIPTINLINE>.
            After declaring a variable <JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE>,
	    to indicate the balance of money in the account, we can define <SCHEMEINLINE>withdraw</SCHEMEINLINE>
            as a function that accesses <SCHEMEINLINE>balance</SCHEMEINLINE>.
	</JAVASCRIPT>
	<SCHEME>
        To implement <SCHEMEINLINE>withdraw</SCHEMEINLINE>, we can use a variable <SCHEMEINLINE>balance</SCHEMEINLINE> to
        indicate the balance of money in the account and define <SCHEMEINLINE>withdraw</SCHEMEINLINE>
        as a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        that accesses <SCHEMEINLINE>balance</SCHEMEINLINE>.
	</SCHEME>
	</SPLIT>
	The <SCHEMEINLINE>withdraw</SCHEMEINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        checks to see if <SCHEMEINLINE>balance</SCHEMEINLINE> is at least as large as the
        requested <SCHEMEINLINE>amount</SCHEMEINLINE>.  If so, <SCHEMEINLINE>withdraw</SCHEMEINLINE> decrements <SCHEMEINLINE>balance</SCHEMEINLINE> by <SCHEMEINLINE>amount</SCHEMEINLINE> and returns the new value of <SCHEMEINLINE>balance</SCHEMEINLINE>.
        Otherwise, <SCHEMEINLINE>withdraw</SCHEMEINLINE> returns the <EM>Insufficient funds</EM>
        message.
	Here are the <SPLITINLINE><SCHEME>definitions</SCHEME><JAVASCRIPT>declarations</JAVASCRIPT></SPLITINLINE> of
	<SCHEMEINLINE>balance</SCHEMEINLINE> and <SCHEMEINLINE>withdraw</SCHEMEINLINE>:

        <SNIPPET EVAL="yes">
          <NAME>withdraw</NAME>
          <EXAMPLE>withdraw_example</EXAMPLE>
          <SCHEME>
(define balance 100)

(define (withdraw amount)
   (if (&gt;= balance amount)
     (begin (set! balance (- balance amount))
            balance)
     "Insufficient funds"))
          </SCHEME>
          <JAVASCRIPT>
let balance = 100;

function withdraw(amount) {
   if (balance &gt;= amount) {
      balance = balance - amount;
      return balance;
   } else {
      return "Insufficient funds";
   }
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Decrementing <SCHEMEINLINE>balance</SCHEMEINLINE> is accomplished by the 
        <SPLITINLINE><SCHEME>expression</SCHEME><JAVASCRIPT>statement</JAVASCRIPT></SPLITINLINE>

        <SNIPPET EVAL="no">
          <SCHEME>
(set! balance (- balance amount))
          </SCHEME>
          <JAVASCRIPT>
balance = balance - amount;
          </JAVASCRIPT>
        </SNIPPET>

        <!--\indsf*{set!}
            \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[set@<SCHEMEINLINE>set!</SCHEMEINLINE>]
          -->
        <SPLIT>
          <SCHEME>
        This uses the <SCHEMEINLINE>set!</SCHEMEINLINE> special form, whose syntax is
          </SCHEME>
          <JAVASCRIPT>
            The syntax of such <EM>assignment statements</EM> is
          </JAVASCRIPT>
        </SPLIT>
        <SNIPPET EVAL="no" LATEX="yes">
          <SCHEME>
(set! ^$\langle \textit{name} \rangle$^ ^$\langle \textit{new-value}\rangle$^)
          </SCHEME>
          <JAVASCRIPT>
$\textit{name}$ = $\textit{new-value}$;
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Here <LATEXINLINE>$\textit{name}$</LATEXINLINE> is a symbol and 
<LATEXINLINE>$\textit{new-value}$</LATEXINLINE> is any expression.  
<SPLITINLINE><SCHEME>Set!</SCHEME><JAVASCRIPT>The assignment</JAVASCRIPT></SPLITINLINE> 
changes <LATEXINLINE>$\textit{name}$</LATEXINLINE> so that its value is the result obtained by
evaluating <LATEXINLINE>$\textit{new-value}$</LATEXINLINE>.  In the case at hand, 
we are changing <SCHEMEINLINE>balance</SCHEMEINLINE> so that its new value will be the result of 
subtracting <SCHEMEINLINE>amount</SCHEMEINLINE> from the previous value 
of <SCHEMEINLINE>balance</SCHEMEINLINE>.<SPLIT><SCHEME><FOOTNOTE>
          <!-- \indsf{set!}[value of] -->
          <INDEX>unspecified values<SUBINDEX>set@<SCHEMEINLINE>set!</SCHEMEINLINE></SUBINDEX></INDEX>
          The value of 
    a <SCHEMEINLINE>set!</SCHEMEINLINE> expression is implementation-dependent.
          <SCHEMEINLINE>Set!</SCHEMEINLINE> should be used only for its effect, not for its value.

          <INDEX>naming conventions<SUBINDEX>!@<SCHEMEINLINE>!</SCHEMEINLINE> for assignment and mutation</SUBINDEX></INDEX>
          <INDEX>exclamation point in names</INDEX>
          <!-- \indcodeplus{!}{in names} -->
          The name
          <SCHEMEINLINE>set!</SCHEMEINLINE> reflects a naming convention used in Scheme: Operations
          that change the values of variables (or that change data structures,
          as we will see in section<SPACE/><REF NAME="sec:mutable-data"/>) are given names that
          end with an exclamation point.  This is similar to the convention of
          designating predicates by names that end with a question mark.</FOOTNOTE></SCHEME>
          <JAVASCRIPT>
            <FOOTNOTE>Note that assignment statements look similar to and should not be confused
            with constant and variable declarations of the form
            <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
const $\textit{name}$ = $\textit{value}$;
          </JAVASCRIPT>
            </SNIPPET>
	    and
            <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
let $\textit{name}$ = $\textit{value}$;
          </JAVASCRIPT>
            </SNIPPET>
            in which a newly declared <LATEXINLINE>$\textit{name}$</LATEXINLINE>
            is associated with a <LATEXINLINE>$\textit{value}$</LATEXINLINE>. Also similar in looks but not
	    in meaning are expressions of the form 
            <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
$\textit{expression}_1$ === $\textit{expression}_2$
          </JAVASCRIPT>
            </SNIPPET>
	    which evaluate to <JAVASCRIPTINLINE>true</JAVASCRIPTINLINE>
	    if <LATEXINLINE>$\textit{expression}_1$</LATEXINLINE> evaluates to the same value as
	    <LATEXINLINE>$\textit{expression}_2$</LATEXINLINE> and to
	    <JAVASCRIPTINLINE>false</JAVASCRIPTINLINE>, otherwise.
            </FOOTNOTE>
          </JAVASCRIPT>
        </SPLIT>
      </TEXT>

      <TEXT>
        <!--\indsf*{begin}
            \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[begin@<SCHEMEINLINE>begin</SCHEMEINLINE>]
          -->
        <SPLIT>
          <SCHEME><SCHEMEINLINE>Withdraw</SCHEMEINLINE> also uses the <SCHEMEINLINE>begin</SCHEMEINLINE> 
          special form to cause
          two expressions to be evaluated
          in the case where the <SCHEMEINLINE>if</SCHEMEINLINE> test is true: first decrementing 
          <SCHEMEINLINE>balance</SCHEMEINLINE> and then returning the value of 
          <SCHEMEINLINE>balance</SCHEMEINLINE>.  

          In general, evaluating the expression

        <SNIPPET EVAL="no">
          <SCHEME>
(begin ^$\textit{exp}_{1}$^ ^$\textit{exp}_{2}$^ ^$\ldots$^ ^$\textit{exp}_{k}$^)
          </SCHEME>
        </SNIPPET>

        causes the expressions <LATEXINLINE>$\textit{exp}_{1}$</LATEXINLINE> through <LATEXINLINE>$\textit{exp}_{k}$</LATEXINLINE> to be evaluated in sequence and the value of the final expression
        <LATEXINLINE>$\textit{exp}_{k}$</LATEXINLINE> to be returned as the value of the entire 
        <SCHEMEINLINE>begin</SCHEMEINLINE>
        form.<FOOTNOTE>We have already used 
          <!--\indsf{begin}[implicit in consequent of <SCHEMEINLINE>cond</SCHEMEINLINE> and in -->
          <SCHEMEINLINE>begin</SCHEMEINLINE> implicitly in our
          programs, because in Scheme the body of a
          procedure can be a sequence
          of expressions.  Also, the <LATEXINLINE>consequent</LATEXINLINE> part of each clause in a
          <!--\indsf{cond}[implicit begin@implicit <SCHEMEINLINE>begin</SCHEMEINLINE> in consequent] -->
          <SCHEMEINLINE>cond</SCHEMEINLINE> expression can be a sequence of expressions rather than a
          single expression.</FOOTNOTE>
          </SCHEME>
          <JAVASCRIPT>The function <JAVASCRIPTINLINE>withdraw</JAVASCRIPTINLINE> 
          also uses a <EM>sequential composition</EM>
          to cause two expressions to be evaluated
          in the case where the <JAVASCRIPTINLINE>if</JAVASCRIPTINLINE> test is true: first decrementing 
          <JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE> and then returning the value of 
          <JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE>.  

          In general, executing the statement

        <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
$\textit{stmt}_{1}$ $\textit{stmt}_{2}$
          </JAVASCRIPT>
        </SNIPPET>
 
        causes the statements <LATEXINLINE>$\textit{stmt}_{1}$</LATEXINLINE> and <LATEXINLINE>$\textit{stmt}_{2}$</LATEXINLINE> to be evaluated in sequence.<FOOTNOTE>We have already used 
          <!--\indsf{begin}[implicit in consequent of <SCHEMEINLINE>cond</SCHEMEINLINE> and in -->
          sequential composition implicitly in our
          programs, because in JavaScript the body of a
          function can be a sequence
          of statements, not just a single
	  <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> statement,
	  as discussed in
	  section<SPACE/><REF NAME="sec:block-structure"/>.</FOOTNOTE>
          </JAVASCRIPT>
        </SPLIT>
      </TEXT>

      <TEXT>
        Although <SCHEMEINLINE>withdraw</SCHEMEINLINE> works as desired, the variable
        <SCHEMEINLINE>balance</SCHEMEINLINE> presents a problem.  As specified above, <SCHEMEINLINE>balance</SCHEMEINLINE>
        is a name defined in the <SPLITINLINE><SCHEME>global</SCHEME><JAVASCRIPT>program</JAVASCRIPT></SPLITINLINE> environment and is freely accessible
        to be examined or modified by any
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.  It would be much better
        if we could somehow make <SCHEMEINLINE>balance</SCHEMEINLINE> internal to <SCHEMEINLINE>withdraw</SCHEMEINLINE>, so
        that <SCHEMEINLINE>withdraw</SCHEMEINLINE> would be the only
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        that could access <SCHEMEINLINE>balance</SCHEMEINLINE> directly and any other
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        could access <SCHEMEINLINE>balance</SCHEMEINLINE>
        only indirectly (through calls to <SCHEMEINLINE>withdraw</SCHEMEINLINE>).  This would more
        accurately model the notion that <SCHEMEINLINE>balance</SCHEMEINLINE> is a local state
        variable used by <SCHEMEINLINE>withdraw</SCHEMEINLINE> to keep track of the state of the
        account.
      </TEXT>

      <TEXT>
        We can make <SCHEMEINLINE>balance</SCHEMEINLINE> internal to <SCHEMEINLINE>withdraw</SCHEMEINLINE> by rewriting the definition as follows:

        <SNIPPET HIDE="yes">
          <NAME>new_withdraw_example</NAME>
	  <REQUIRES>new_withdraw</REQUIRES>
          <JAVASCRIPT>
new_withdraw(60);
new_withdraw(60);
	  </JAVASCRIPT>
	</SNIPPET>
	
        <SNIPPET EVAL="yes">
	  <NAME>new_withdraw</NAME>
	  <EXAMPLE>new_withdraw_example</EXAMPLE>
          <SCHEME>
(define new-withdraw
  (let ((balance 100))
    (lambda (amount)
      (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))))
          </SCHEME>
          <JAVASCRIPT>
function make_withdraw() {
    let balance = 100;
    return amount => {
        if (balance &gt;= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "insufficient funds";
        }
    };
}
const new_withdraw = make_withdraw();
          </JAVASCRIPT>
  </SNIPPET>
        </TEXT>

      <TEXT>
        <SPLIT>
          <SCHEME>
        What we have done here is use <SCHEMEINLINE>let</SCHEMEINLINE> to establish an environment
        with a local variable <SCHEMEINLINE>balance</SCHEMEINLINE>, bound to the initial value 100.
        Within this local environment, we use <SCHEMEINLINE>lambda</SCHEMEINLINE> to create a
	procedure that takes <SCHEMEINLINE>amount</SCHEMEINLINE> as an argument and behaves like our
        previous <SCHEMEINLINE>withdraw</SCHEMEINLINE>
	procedure.  This
        procedure<EMDASH/>returned as the
        result of evaluating the <SCHEMEINLINE>let</SCHEMEINLINE> expression<EMDASH/>is
	<SCHEMEINLINE>new-withdraw</SCHEMEINLINE>,
        which behaves in precisely the same way as <SCHEMEINLINE>withdraw</SCHEMEINLINE> but whose
        variable <SCHEMEINLINE>balance</SCHEMEINLINE> is not accessible by any other
        procedure.<FOOTNOTE>In programming-language jargon, the variable
	<SCHEMEINLINE>balance</SCHEMEINLINE> is said to be 
          <INDEX>encapsulated name</INDEX>
          <INDEX>name<SUBINDEX>encapsulated</SUBINDEX></INDEX>
          <EM>encapsulated</EM> within the <SCHEMEINLINE>new-withdraw</SCHEMEINLINE>
          procedure. Encapsulation reflects the general
          system-design principle known as the 
          <INDEX>hiding principle</INDEX>
          <INDEX>modularity<SUBINDEX>hiding principle</SUBINDEX></INDEX>
          <EM>hiding principle</EM>: One can
          make a system more modular and robust by protecting parts of the
          system from each other; that is, by providing information access only
          to those parts of the system that have a <QUOTE>need to know.</QUOTE></FOOTNOTE>
          </SCHEME>
          <JAVASCRIPT>
            What we have done here is use <JAVASCRIPTINLINE>let</JAVASCRIPTINLINE>
	    to establish an environment
            with a local variable <JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE>, bound to the initial
	    value 100.
            Within this local environment, we use function definition<FOOTNOTE>Blocks as bodies
	    of function definition expressions were introduced in
	    section<SPACE/><REF NAME="sec:graphics"/>.
	    </FOOTNOTE> to create a
	    function that takes <JAVASCRIPTINLINE>amount</JAVASCRIPTINLINE> as an argument and behaves
	    like our previous <JAVASCRIPTINLINE>withdraw</JAVASCRIPTINLINE>
            function.  This
	    function<EMDASH/>returned as the
            result of evaluating the body of the <JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE>
	    function<EMDASH/>behaves in precisely
	    the same way as
	    <JAVASCRIPTINLINE>withdraw</JAVASCRIPTINLINE> but whose
            variable <JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE> is not accessible by any other
	    function.<FOOTNOTE>In programming-language jargon, the variable
	    <JAVASCRIPTINLINE>balance</JAVASCRIPTINLINE> is said to be 
            <INDEX>encapsulated name</INDEX>
            <INDEX>name<SUBINDEX>encapsulated</SUBINDEX></INDEX>
            <EM>encapsulated</EM> within the <JAVASCRIPTINLINE>new_withdraw</JAVASCRIPTINLINE>
	    function.  Encapsulation reflects the general system-design principle known as the 
            <INDEX>hiding principle</INDEX>
            <INDEX>modularity<SUBINDEX>hiding principle</SUBINDEX></INDEX>
            <EM>hiding principle</EM>: One can
            make a system more modular and robust by protecting parts of the
            system from each other; that is, by providing information access only
            to those parts of the system that have a <QUOTE>need to know.</QUOTE></FOOTNOTE>
          </JAVASCRIPT>
        </SPLIT>
      </TEXT>

      <TEXT>
        Combining 
        <SPLITINLINE>
          <SCHEME>
          <SCHEMEINLINE>set!</SCHEMEINLINE> 
          with local variables 
          </SCHEME>
          <JAVASCRIPT>
            assignment statements with variable statements
          </JAVASCRIPT>
        </SPLITINLINE>
        is the general programming
        technique we will use for constructing computational objects with
        local state.  Unfortunately, using this technique raises a serious
        problem: When we first introduced
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>, 
        we also introduced the substitution model of evaluation
        (section<SPACE/><REF NAME="sec:substitution-model"/>) to provide an interpretation of
        what
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        application means.  We said that applying a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        should be interpreted as evaluating the body of the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        with the
        formal parameters replaced by their values.  The trouble is that, as
        soon as we introduce assignment into our language, substitution is no
        longer an adequate model of
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        application.  (We will see why
        this is so in section<SPACE/><REF NAME="sec:costs-of-assignment"/>.)  As a
        consequence, we technically have at this point no way to understand
        why the <SPLITINLINE><SCHEME><SCHEMEINLINE>new-withdraw</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>new_withdraw</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        behaves as claimed above.  In
        order to really understand a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        such as <SPLITINLINE><SCHEME>new-withdraw</SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>new_withdraw</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, we
        will need to develop a new model of
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        application.  In
        section<SPACE/><REF NAME="sec:environment-model"/> we will introduce such a model,
        together with an explanation of 
        <SPLITINLINE><SCHEME><SCHEMEINLINE>set!</SCHEMEINLINE> and local variables</SCHEME><JAVASCRIPT>assignment statements and variable statements</JAVASCRIPT></SPLITINLINE>.
        First, however, we examine some variations on the theme established by
        <SPLITINLINE><SCHEME><SCHEMEINLINE>new-withdraw</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.
      </TEXT>

      <TEXT>
	<SPLIT>
	  <SCHEME>
        The following
        procedure, <SCHEMEINLINE>make-withdraw</SCHEMEINLINE>, creates <QUOTE>withdrawal
        processors.</QUOTE>
	  </SCHEME>
	  <JAVASCRIPT>
        The following
	function, <JAVASCRIPTINLINE>make_withdraw_with_balance</JAVASCRIPTINLINE>,
	abstracts the initial balance into a parameter.
	  </JAVASCRIPT>
	</SPLIT>
	The formal parameter <SCHEMEINLINE>balance</SCHEMEINLINE> in
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>make-withdraw</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw_with_balance</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	specifies the initial amount of money in the
        account.<FOOTNOTE>In contrast
	with <SPLITINLINE><SCHEME><SCHEMEINLINE>new-withdraw</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>make_withdraw</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
	above, we do not
        have to use
	<SPLITINLINE><SCHEME><SCHEMEINLINE>let</SCHEMEINLINE></SCHEME>
	<JAVASCRIPT><JAVASCRIPTINLINE>let</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
	to make <SCHEMEINLINE>balance</SCHEMEINLINE> a local variable, since
        formal parameters are already local.  This will be clearer after the
        discussion of the environment model of evaluation
	in section<SPACE/><REF NAME="sec:environment-model"/>.
        (See also exercise<SPACE/><REF NAME="ex:local-state-variable"/>.)</FOOTNOTE>

        <SNIPPET EVAL="yes">
          <NAME>make_withdraw</NAME>
          <SCHEME>
            <!-- \indcode*{make-withdraw} -->
(define (make-withdraw balance)
   (lambda (amount)
      (if (&gt;= balance amount)
         (begin (set! balance (- balance amount))
                balance)
         "Insufficient funds")))
          </SCHEME>
          <JAVASCRIPT>
function make_withdraw_with_balance(balance) {
    return amount => {
        if (balance &gt;= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "insufficient funds";
        }
    };
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>Make-withdraw</SCHEMEINLINE></SCHEME><JAVASCRIPT>The function <JAVASCRIPTINLINE>make_withdraw_with_balance</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> can be used as follows to create two objects
        <SPLITINLINE><SCHEME><SCHEMEINLINE>W1</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>w1</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
and 
<SPLITINLINE><SCHEME><SCHEMEINLINE>W2</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>w2</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:

        <SNIPPET EVAL="yes">
          <REQUIRES>make_withdraw</REQUIRES>
          <NAME>make_withdraw_define</NAME>
          <SCHEME>
(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))
          </SCHEME>
          <JAVASCRIPT>
const w1 = make_withdraw_with_balance(100);
const w2 = make_withdraw_with_balance(100);
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET EVAL="yes">
          <REQUIRES>make_withdraw_define</REQUIRES>
          <NAME>make_withdraw_example1</NAME>
          <SCHEME>
(W1 50) ;; output: 50
          </SCHEME>
          <SCHEMEOUTPUT>
50
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
w1(50); // output: 50
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET EVAL="yes">
          <REQUIRES>make_withdraw_example1</REQUIRES>
          <NAME>make_withdraw_example2</NAME>
          <SCHEME>
(W2 70) ;; output: 30
          </SCHEME>
          <JAVASCRIPT>
w2(70); // output: 30
          </JAVASCRIPT>
          <SCHEMEOUTPUT>
30
          </SCHEMEOUTPUT>
        </SNIPPET>

        <SNIPPET EVAL="yes">
          <REQUIRES>make_withdraw_example2</REQUIRES>
          <NAME>make_withdraw_example3</NAME>
          <SCHEME>
(W2 40) ;; output: "Insufficient funds"
          </SCHEME>
          <JAVASCRIPT>
w2(40); // output: "Insufficient funds"
          </JAVASCRIPT>
          <SCHEMEOUTPUT>
"Insufficient funds"
          </SCHEMEOUTPUT>
        </SNIPPET>

        <SNIPPET EVAL="yes">
          <REQUIRES>make_withdraw_example3</REQUIRES>
          <NAME>make_withdraw_example4</NAME>
          <SCHEME>
(W1 40) ;; output: 10
          </SCHEME>
          <JAVASCRIPT>
w1(40); // output: 10
          </JAVASCRIPT>
          <SCHEMEOUTPUT>
10
          </SCHEMEOUTPUT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Observe that 
<SPLITINLINE><SCHEME><SCHEMEINLINE>W1</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>w1</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
and 
<SPLITINLINE><SCHEME><SCHEMEINLINE>W2</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>w2</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> 
are completely independent objects,
        each with its own local state variable <SCHEMEINLINE>balance</SCHEMEINLINE>.  Withdrawals
        from one do not affect the other.
      </TEXT>

      <TEXT>
        We can also create objects that handle deposits as well as
        withdrawals, and thus we can represent simple bank accounts.  Here is
        a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        that returns a <QUOTE>bank-account object</QUOTE> with
        a specified initial balance:

        <SNIPPET EVAL="yes">
          <NAME>make_account</NAME>
          <SCHEME>
            <!-- \indcode*{make-account} -->
            <!--\indcodeplus*{deposit}{message for bank account}-->
(define (make-account balance)
   (define (withdraw amount)
      (if (&gt;= balance amount)
         (begin (set! balance (- balance amount))
                balance)
            "Insufficient funds"))
   (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
   (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request - - MAKE-ACCOUNT"
                   m))))
   dispatch)
          </SCHEME>
          <JAVASCRIPT>
function make_account(balance) {
    function withdraw(amount) {
        if (balance &gt;= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "Insufficient funds";
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    function dispatch(m) {
        if (m === "withdraw") {
            return withdraw;
        } else if (m === "deposit") {
            return deposit;
        } else {
            return "Unknown request - - MAKE-ACCOUNT";
        }
    }
    return dispatch;
}
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Each call to <SCHEMEINLINE>make_account</SCHEMEINLINE> sets up an environment with a local
        state variable <SCHEMEINLINE>balance</SCHEMEINLINE>.
	Within this environment, <SCHEMEINLINE>make_account</SCHEMEINLINE> defines
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        <SCHEMEINLINE>deposit</SCHEMEINLINE> and <SCHEMEINLINE>withdraw</SCHEMEINLINE>
        that access <SCHEMEINLINE>balance</SCHEMEINLINE> and an additional
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SCHEMEINLINE>dispatch</SCHEMEINLINE>
        that takes a <QUOTE>message</QUOTE> as input and returns one of the two local
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.
	The <SCHEMEINLINE>dispatch</SCHEMEINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        itself is returned as the
        value that represents the bank-account object.
        This is precisely the 
        <INDEX>message passing<SUBINDEX>in bank account</SUBINDEX></INDEX>
        <EM>message-passing</EM>
        style of programming that we saw in section<SPACE/><REF NAME="sec:data-directed"/>, although
        here we are using it in conjunction with the ability to modify local
        variables.
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>make_account</SCHEMEINLINE> can be used as follows:

        <SNIPPET EVAL="yes">
          <NAME>make_account_example</NAME>
          <REQUIRES>make_account</REQUIRES>
          <SCHEME>
            (define acc (make-account 100))
          </SCHEME>
    <JAVASCRIPT>
const acc = make_account(100);
    </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET EVAL="yes">
          <REQUIRES>make_account_example</REQUIRES>
          <NAME>make_account_example1</NAME>
          <SCHEME>
            ((acc 'withdraw) 50)
          </SCHEME>
    <JAVASCRIPT>
(acc("withdraw"))(50);
    </JAVASCRIPT>
          <SCHEMEOUTPUT>
            50
          </SCHEMEOUTPUT>
        </SNIPPET>

        <SNIPPET EVAL="yes">
          <REQUIRES>make_account_example1</REQUIRES>
          <NAME>make_account_example2</NAME>
          <SCHEME>
            ((acc 'withdraw) 60)
          </SCHEME>
    <JAVASCRIPT>
(acc("withdraw"))(60);
    </JAVASCRIPT>
          <SCHEMEOUTPUT>
            "Insufficient funds"
          </SCHEMEOUTPUT>
        </SNIPPET>

        <SNIPPET EVAL="yes">
          <REQUIRES>make_account_example2</REQUIRES>
          <NAME>make_account_example3</NAME>
          <SCHEME>
            ((acc 'deposit) 40)
          </SCHEME>
    <JAVASCRIPT>
(acc("deposit"))(40);
    </JAVASCRIPT>
          <SCHEMEOUTPUT>
            90
          </SCHEMEOUTPUT>
        </SNIPPET>

        <SNIPPET EVAL="yes">
          <REQUIRES>make_account_example3</REQUIRES>
          <NAME>make_account_example4</NAME>
          <SCHEME>
            ((acc 'withdraw) 60)
          </SCHEME>
    <JAVASCRIPT>
(acc("withdraw"))(60);
    </JAVASCRIPT>
          <SCHEMEOUTPUT>
            30
          </SCHEMEOUTPUT>
          
        </SNIPPET>
      </TEXT>

      <TEXT>
        Each call to <SCHEMEINLINE>acc</SCHEMEINLINE> returns the locally defined <SCHEMEINLINE>deposit</SCHEMEINLINE> or
        <SCHEMEINLINE>withdraw</SCHEMEINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, which is then applied to the specified <SCHEMEINLINE>amount</SCHEMEINLINE>.  As was the case with <SCHEMEINLINE>make_withdraw</SCHEMEINLINE>, another call to <SCHEMEINLINE>make_account</SCHEMEINLINE>

        <SNIPPET EVAL="yes">
          <REQUIRES>make_account</REQUIRES>
          <SCHEME>
            (define acc2 (make-account 100))
          </SCHEME>
    <JAVASCRIPT>
const acc2 = make_account(100);
    </JAVASCRIPT>
        </SNIPPET>

        will produce a completely separate account object, which maintains its
        own local <SCHEMEINLINE>balance</SCHEMEINLINE>.
      </TEXT>

      <EXERCISE><LABEL NAME="ex:make-accumulator"/>
        An 
        <INDEX>accumulator</INDEX>
        <EM>accumulator</EM> is a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        that is called repeatedly with a
        single numeric argument and accumulates its arguments into a sum.
        Each time it is called, it returns the currently accumulated sum.
        Write a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>

        <!-- \indcode{make-accumulator} -->
<SPLITINLINE><SCHEME><SCHEMEINLINE>make-accumulator</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_accumulator</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
that generates accumulators,
        each maintaining an independent sum.  The input to 
<SPLITINLINE><SCHEME><SCHEMEINLINE>make-accumulator</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_accumulator</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
should specify the initial value of the sum; for
        example

<SNIPPET EVAL="yes">
  <NAME>make_accumulator_example</NAME>
  <SCHEME>
(define A (make-accumulator 5))
  </SCHEME>
  <JAVASCRIPT>
// make_accumulator to be written by students
const a = make_accumulator(5);
  </JAVASCRIPT>
</SNIPPET>

  <SNIPPET EVAL="yes">
    <REQUIRES>make_accumulator_example</REQUIRES>
    <NAME>make_accumulator_example1</NAME>
    <SCHEME>
(A 10)  ;; output: 15
    </SCHEME>
    <JAVASCRIPT>
a(10);  // output: 15
    </JAVASCRIPT>
          <SCHEMEOUTPUT>
            15
          </SCHEMEOUTPUT>
        </SNIPPET>
        
  <SNIPPET HIDE="yes">
    <NAME>make_accumulator_example1_solution</NAME>
    <SCHEME>
(A 10)  ;; output: 15
    </SCHEME>
    <JAVASCRIPT>
a(10);  // output: 15
    </JAVASCRIPT>
          <SCHEMEOUTPUT>
            15
          </SCHEMEOUTPUT>
        </SNIPPET>
        
  <SNIPPET EVAL="yes">
    <REQUIRES>make_accumulator_example1</REQUIRES>
    <NAME>make_accumulator_example2</NAME>
    <SCHEME>
(A 10)  ;; output: 25
    </SCHEME>
    <JAVASCRIPT>
a(10);  // output: 25
    </JAVASCRIPT>
    <SCHEMEOUTPUT>
      25
    </SCHEMEOUTPUT>
  </SNIPPET>

  <SNIPPET HIDE="yes">
    <NAME>make_accumulator_example2_solution</NAME>
    <SCHEME>
(A 10)  ;; output: 25
    </SCHEME>
    <JAVASCRIPT>
a(10);  // output: 25
    </JAVASCRIPT>
    <SCHEMEOUTPUT>
      25
    </SCHEMEOUTPUT>
  </SNIPPET>

  <SOLUTION>
        <SNIPPET>
    <EXAMPLE>make_accumulator_example</EXAMPLE>
    <EXAMPLE>make_accumulator_example1_solution</EXAMPLE>
    <EXAMPLE>make_accumulator_example2_solution</EXAMPLE>
    <JAVASCRIPT>
function make_accumulator(current) {
    function add(arg) {
        current = current + arg;
        return current;
    }
    return add;
}
    </JAVASCRIPT>
    </SNIPPET>
  </SOLUTION>
      </EXERCISE>

      <EXERCISE><LABEL NAME="ex:make-monitored"/>
        In software-testing applications, it is useful to be able to count the
        number of times a given
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        is called during the course of a
        computation.  Write a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <!-- \indcode{make-monitored} -->
        <INDEX>monitored
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE></INDEX>
        <INDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>monitored</SUBINDEX></INDEX>
<SPLITINLINE><SCHEME><SCHEMEINLINE>make-monitored</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_monitored</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
that takes as
        input a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, <SCHEMEINLINE>f</SCHEMEINLINE>, that itself takes one input.  The result
        returned by 
<SPLITINLINE><SCHEME><SCHEMEINLINE>make-monitored</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_monitored</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
is a third
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, say <SCHEMEINLINE>mf</SCHEMEINLINE>,
        that keeps track of the number of times it has been called by
        maintaining an internal counter. If the input to <SCHEMEINLINE>mf</SCHEMEINLINE> is the
<SPLITINLINE><SCHEME>special symbol <SCHEMEINLINE>how-many-calls</SCHEMEINLINE></SCHEME><JAVASCRIPT>string <JAVASCRIPTINLINE>"how many calls?"</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, 
then <SCHEMEINLINE>mf</SCHEMEINLINE> returns the
        value of the counter.  If the input is the 
<SPLITINLINE><SCHEME>special symbol <SCHEMEINLINE>reset-count</SCHEMEINLINE></SCHEME><JAVASCRIPT>string <JAVASCRIPTINLINE>"reset count"</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, then <SCHEMEINLINE>mf</SCHEMEINLINE> resets the counter to zero.  For any other
        input, <SCHEMEINLINE>mf</SCHEMEINLINE> returns the result of calling <SCHEMEINLINE>f</SCHEMEINLINE> on that input
        and increments the counter.  For instance, we could make a monitored
        version of the <SCHEMEINLINE>sqrt</SCHEMEINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>:

<SNIPPET EVAL="yes">
  <NAME>make_monitored_example</NAME>
  <SCHEME>
    (define s (make-monitored sqrt))
  </SCHEME>
  <JAVASCRIPT>
// make_monitored function to be written by students
const s = make_monitored(math_sqrt);
    </JAVASCRIPT>
        </SNIPPET>

<SNIPPET EVAL="yes">
  <REQUIRES>make_monitored_example</REQUIRES>
  <NAME>make_monitored_example1</NAME>
  <SCHEME>
    (s 100)
  </SCHEME>
  <JAVASCRIPT>
s(100);
    </JAVASCRIPT>
          <SCHEMEOUTPUT>
            10
          </SCHEMEOUTPUT>
        </SNIPPET>

<SNIPPET EVAL="yes">
  <REQUIRES>make_monitored_example1</REQUIRES>
  <NAME>make_monitored_example2</NAME>
  <SCHEME>
    (s 'how-many-calls?)
  </SCHEME>
  <JAVASCRIPT>
s("how many calls?"); // returns 1
    </JAVASCRIPT>
  <SCHEMEOUTPUT>
    1
  </SCHEMEOUTPUT>
</SNIPPET>

<SOLUTION>

  <SNIPPET>
    <NAME>make_monitored_example3</NAME>
	  <JAVASCRIPT>
const s = make_monitored(math_sqrt);
s(100);
display(s("how many calls"));
s(5);
display(s("how many calls"));
          </JAVASCRIPT>
  </SNIPPET>
  <SNIPPET>
	  <EXAMPLE>make_monitored_example3</EXAMPLE>
	  <JAVASCRIPT>
function make_monitored(f) {
    let counter = 0; //initialized to 0
    function mf(cmd) {
        if (cmd === "how many calls") {
            return counter;
        } else if (cmd === "reset count") {
            counter = 0;
            return counter;
        } else {
            counter = counter + 1;
            return f(cmd);
        }
    }
    return mf;
}
    </JAVASCRIPT>
    </SNIPPET>
  </SOLUTION>
	      
      </EXERCISE>


      <EXERCISE><LABEL NAME="ex:password-protection"/>
        <INDEX>bank account<SUBINDEX>password-protected</SUBINDEX></INDEX>
        <INDEX>password-protected bank account</INDEX>
        Modify the 
<SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        so that it creates
        password-protected accounts.  That is, 
<SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
should take
        a symbol as an additional argument, as in

        <SNIPPET EVAL="yes">
          <NAME>make_account_exercise</NAME>
          <SCHEME>
            (define acc (make-account 100 'secret-password))
          </SCHEME>
          <JAVASCRIPT>
// make_account function to be written by students
const acc = make_account(100, "secret password");
    </JAVASCRIPT>
        </SNIPPET>

        The resulting account object should process a request only if it is
        accompanied by the password with which the account was created, and
        should otherwise return a complaint:

        <SNIPPET EVAL="yes">
          <REQUIRES>make_account_exercise</REQUIRES>
          <NAME>make_account_exercise_example1</NAME>
          <SCHEME>
((acc 'secret-password 'withdraw) 40) ;; result: 60
          </SCHEME>
          <JAVASCRIPT>
(acc("secret password", "withdraw"))(40); // result: 60
    </JAVASCRIPT>
          <SCHEMEOUTPUT>
            60
          </SCHEMEOUTPUT>
        </SNIPPET>

        <SNIPPET EVAL="yes">
          <REQUIRES>make_account_exercise_example1</REQUIRES>
          <SCHEME>
((acc 'some-other-password 'deposit) 50)  ;; result: incorrect password
          </SCHEME>
          <JAVASCRIPT>
(acc("some other password", "deposit"))(40);  
// result: incorrect password
	  </JAVASCRIPT>
          <SCHEMEOUTPUT>
            "Incorrect password"
          </SCHEMEOUTPUT>
        </SNIPPET>


	<SOLUTION>
        <SNIPPET>
        <NAME>make_account_password_protected</NAME>
    <JAVASCRIPT>
function make_account(balance, p) {
    function withdraw(amount) {
        if (balance >= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "Insufficient funds";
        }
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    function dispatch(m, q) {
        if (p === q) {
            if (m === "withdraw") {
                return withdraw;
            } else if (m === "deposit") {
                return deposit;
            } else {
                return "Unknown request - make_account";
            }
    	} else {
            return q => "Incorrect Password";
        }
    }
    return dispatch;
}

const a = make_account(100, "eva");
(a("withdraw", "eva"))(50); //withdraws 50
(a("withdraw", "ben"))(40); //incorrect password
    </JAVASCRIPT>
    </SNIPPET>
  </SOLUTION>

      </EXERCISE>


      <EXERCISE>
        Modify the 
<SPLITINLINE><SCHEME><SCHEMEINLINE>make-account</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_account</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        of
        exercise<SPACE/><REF NAME="ex:password-protection"/> by adding another local state
        variable so that, if an account is accessed more than seven
        consecutive times with an incorrect password, it invokes the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
<SPLITINLINE><SCHEME><SCHEMEINLINE>call-the-cops</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>call_the_cops</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>. 
     	
  <SOLUTION>
    <SNIPPET>
      <EXAMPLE>mka_example</EXAMPLE>
    <JAVASCRIPT>
function make_account(balance, p) {

    let invalid_attempts = 0; //initializes to 0

    function withdraw(amount) {
        if (balance >= amount) {
            balance = balance - amount;
            return balance;
        } else {
            return "Insufficient funds";
        }
    }

    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }

    function call_the_cops() {
        return "calling the cops as you have exceeded " +
               "the max no of failed attempts";
    }

    function dispatch(m, q) {
        if (invalid_attempts &lt;= 7) {
            if (p === q) {
                if (m === "withdraw") {
                    return withdraw;
                } else if (m === "deposit") {
                    return deposit;
                } else {
                    return "Unknown request - make_account";
                }
            } else {
                invalid_attempts = invalid_attempts + 1;
    	        return "Incorrect Password";
            }
        } else {
            return call_the_cops();
        }
    }

    return dispatch;

}
    </JAVASCRIPT>
   </SNIPPET>

    <SNIPPET HIDE="yes">
      <NAME>mka_example</NAME>
    <JAVASCRIPT>
const a = make_account(100, "eva");
(a("withdraw", "eva"))(50);
(a("withdraw", "eva"))(50);
(a("withdraw", "eva"))(50);
(a("withdraw", "eva"))(50);
(a("withdraw", "eva"))(50);
(a("withdraw", "eva"))(50);
    </JAVASCRIPT>
    </SNIPPET>
    
  </SOLUTION>
	      
	</EXERCISE>
      <INDEX>local state variable|)</INDEX>
      <INDEX>state variable<SUBINDEX>local|)</SUBINDEX></INDEX>

    </SUBSECTION>
