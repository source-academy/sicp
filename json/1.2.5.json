[{"id":"/sicpjs/1.2.5","tag":"TITLE","body":"1.2.5  Greatest Common Divisors"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    The greatest common divisor (GCD) of two integers\n    ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":" is defined\n    to be the largest integer that divides both ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":"\n    and ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":" with no remainder. For example, the GCD\n    of 16 and 28 is 4.  In chapter ","tag":"#text"},{"tag":"REF","body":"2","href":"/sicpjs/2"},{"body":", when we investigate how to\n    implement rational-number arithmetic, we will need to be able to compute\n    GCDs in order to reduce rational numbers to lowest terms.  (To reduce a\n    rational number to lowest terms, we must divide both the numerator and the\n    denominator by their GCD.  For example, 16/28 reduces to 4/7.)  One way to\n    find the GCD of two integers is to factor them and search for common\n    factors, but there is a famous algorithm that is much more efficient.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The idea of the algorithm is based on the observation that, if\n    ","tag":"#text"},{"body":"$r$","tag":"LATEX"},{"body":" is the remainder when\n    ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" is divided by \n    ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":", then the common divisors of\n    ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":" are \n    precisely the same as the common divisors of ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":"\n    and ","tag":"#text"},{"body":"$r$","tag":"LATEX"},{"body":".  Thus, we can use the equation\n    ","tag":"#text"},{"body":"\n      \\[\\begin{array}{lll}\n      \\textrm{GCD} (a, b) &=& \\textrm{GCD}(b, r)\n      \\end{array}\\]\n    ","tag":"LATEX"},{"body":"\n    to successively reduce the problem of computing a GCD to the problem of\n    computing the GCD of smaller and smaller pairs of integers.  For example,\n    ","tag":"#text"},{"body":"\n      \\[\\begin{array}{lll}\n      \\textrm{GCD}(206,40) & = & \\textrm{GCD}(40,6) \\\\\n                           & = & \\textrm{GCD}(6,4) \\\\\n                           & = & \\textrm{GCD}(4,2) \\\\\n                           & = & \\textrm{GCD}(2,0) \\\\\n                           & = & 2\n      \\end{array}\\]\n    ","tag":"LATEX"},{"body":"\n    reduces ","tag":"#text"},{"body":"$\\textrm{GCD}(206, 40)$","tag":"LATEX"},{"body":" to\n    ","tag":"#text"},{"body":"$\\textrm{GCD}(2, 0)$","tag":"LATEX"},{"body":", which is 2.  It is\n    possible to show that starting with any two positive integers and\n    performing repeated reductions will always eventually produce a pair\n    where the second number is 0.  Then the GCD is the other\n    number in the pair.  This method for computing the GCD is\n    known as ","tag":"#text"},{"tag":"EM","child":[{"body":"Euclid's Algorithm","tag":"#text"}]},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/1.2.5#footnote-1"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    It is easy to express Euclid's Algorithm as a \n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQCY0FYBQuAzAVwDsBjAFwEsB7E0AczIBMAKAQwBpQAjASlABvXKFGgATgFMKRcfR6gAvMtAAGUAH5Q7UAC5GLVj246ApLz4BuXAF98TNhlXcUGK0A","body":"function gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n} "},{"body":"\n    This generates an iterative process, whose number of steps grows as\n    the logarithm of the numbers involved.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    The fact that the number of steps required by Euclid's Algorithm has\n    \n    logarithmic growth bears an interesting relation to the\n    \n    Fibonacci numbers:\n    ","tag":"#text"},{"tag":"EPIGRAPH","child":[{},{"tag":"B","child":[{"body":"Lamé's Theorem:","tag":"#text"}]},{},{},{"body":"\n      If Euclid","tag":"#text"},{"body":"'","tag":"#text"},{"body":"s Algorithm\n      requires ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" steps to compute the GCD of some\n      pair, then the smaller number in the pair must be greater than or equal\n      to the ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":"th Fibonacci number.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/1.2.5#footnote-2"},{}]}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    We can use this theorem to get an order-of-growth estimate for Euclid's\n    Algorithm.  Let ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" be the smaller of the two\n    inputs to the\n    function.\n    If the process takes ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" steps, then we must have \n    ","tag":"#text"},{"body":"$n\\geq {\\textrm{Fib}} (k)\\approx\\phi^k/\\sqrt{5}$","tag":"LATEX"},{"body":".\n    Therefore the number of steps ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" grows as the\n    logarithm (to the base ","tag":"#text"},{"body":"$\\phi$","tag":"LATEX"},{"body":") of\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":". Hence, the order of growth is\n    ","tag":"#text"},{"body":"$\\Theta(\\log n)$","tag":"LATEX"},{"body":".\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 1.20","id":"#ex-1.20","child":[{"body":" \n    The process that a \n    function\n    generates is of course dependent on the rules used by the interpreter.\n    As an example, consider the iterative ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd"},{"body":"function\n    given above. Suppose we were to interpret this \n    function\n    using\n    \n    normal-order evaluation, as discussed in\n    section ","tag":"#text"},{"tag":"REF","body":"1.1.5","href":"/sicpjs/1.1.5"},{"body":". (The\n    normal-order-evaluation rule for\n    conditional expressions\n    is described\n    in exercise ","tag":"#text"},{"tag":"REF","body":"1.5","href":"/sicpjs/1.1.6#ex-1.5"},{"body":".)  \n    Using the substitution method (for normal order), illustrate the process\n    generated in evaluating \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd(206, 40)"},{"body":"\n    and indicate the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"remainder"},{"body":" operations that are\n    actually performed. How many ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"remainder"},{"body":"\n    operations are actually performed in the normal-order evaluation of \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"gcd(206, 40)"},{"body":"?\n    In the applicative-order evaluation?\n    ","tag":"#text"}],"solution":[{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\t      Using normal-order evaluation, the process undergoes 18 remainder\n\t      operations. 14 while evaluating the condition, rest during final\n\t      reduction phase.\n              ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"gcd(206, 40)\n40 === 0 ? 206 : gcd(40, 206 % 40)\ngcd(40, 206 % 40)\n206 % 40 === 0 ? 40 : gcd(206 % 40,\n                          40 % (206 % 40))\n// remainder operation (1)\n6 === 0 ? 40 : gcd(206 % 40,\n                   40 % (206 % 40))\ngcd(206 % 40, 40 % (206 % 40))\n40 % (206 % 40) === 0 \n    ? 206 % 40 \n    : gcd(40 % (206 % 40),\n          (206 % 40) % (40 % (206 % 40)))\n// remainder operations (2) and (3)\n4 === 0 \n    ? 206 % 40 \n    : gcd(40 % (206 % 40),\n          (206 % 40) % (40 % (206 % 40)))\ngcd(40 % (206 % 40), (206 % 40) % (40 % (206 % 40)))\n(206 % 40) % (40 % (206 % 40)) === 0 \n    ? 40 % (206 % 40)\n    : gcd((206 % 40) % (40 % (206 % 40)), \n          (40 % (206 % 40)) % ((206 % 40) % (40 % \n                                             (206 % 40)))\n// remainder operations (4), (5), (6), (7)\n2 === 0\n    ? 40 % (206 % 40)\n    : gcd((206 % 40) % (40 % (206 % 40)), \n          (40 % (206 % 40)) % ((206 % 40) % (40 % \n                                             (206 % 40))))\ngcd((206 % 40) % (40 % (206 % 40)), \n    (40 % (206 % 40)) % ((206 % 40) % (40 % (206 % 40)))\n(40 % (206 % 40)) % ((206 % 40) % (40 % (206 % 40))) === 0\n    ? (206 % 40) % (40 % (206 % 40)) \n    : gcd((40 % (206 % 40)) % ((206 % 40) % (40 % \n                                             (206 % 40)),\n          ((206 % 40) % (40 % (206 % 40))) %\n          ((40 % (206 % 40)) % ((206 % 40) % (40 % \n                                             (206 % 40))))\n// remainder operations \n                    (8), (9), (10), (11), (12), (13), (14)\n0 === 0\n    ? (206 % 40) % (40 % (206 % 40)) \n    : gcd((40 % (206 % 40)) % ((206 % 40) % (40 % \n                                             (206 % 40)),\n          ((206 % 40) % (40 % (206 % 40))) %\n          ((40 % (206 % 40)) % ((206 % 40) % (40 % \n                                             (206 % 40))))\n(206 % 40) % (40 % (206 % 40))    \n// remainder operations (15), (16), (17), (18)\n2"}]},{"tag":"LI","child":[{"body":"\n\t      Using application order evaluation, the process performs 4\n\t      remainder operations.\n              ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"gcd(206, 40)\n40 === 0 ? 206 : gcd(40, 206 % 40)\ngcd(40, 206 % 40)\n// remainder operation (1)\ngcd(40, 6)\n6 === 0 ? 40 : gcd(6, 40 % 6)\ngcd(6, 40 % 6)\n// remainder operation (2)\ngcd(6, 4)\n4 === 0 ? 6 : gcd(4, 6 % 4)\ngcd(4, 6 % 4)\n// remainder operation (3)\ngcd(4, 2)\n2 === 0 ? 4 : gcd(2, 4 % 2)\ngcd(2, 4 % 2)\n// remainder operation (4)\ngcd(2, 0)\n0 === 0 ? 2 : gcd(0, 2 % 0)\n2"}]}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/1.2.5#footnote-link-1","child":[{"body":"Euclid's \n    Algorithm is so\n    called because it appears in Euclid's\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Elements","tag":"#text"}]},{"body":" (Book 7,\n    ca. 300 BCE).  According to\n    \n    Knuth (1997a), it can be considered the\n    oldest known nontrivial algorithm.  The ancient Egyptian method of\n    multiplication (exercise ","tag":"#text"},{"tag":"REF","body":"1.18","href":"/sicpjs/1.2.4#ex-1.18"},{"body":") is surely\n    older, but, as Knuth explains, Euclid's Algorithm is the oldest known\n    to have been presented as a general algorithm, rather than as a set of\n    illustrative examples.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/1.2.5#footnote-link-2","child":[{"body":"This\n      theorem was proved in 1845 by\n      \n      Gabriel Lamé, a\n      French mathematician and engineer known chiefly for his contributions\n      to mathematical physics.  To prove the theorem, we consider pairs\n      ","tag":"#text"},{"body":"$(a_k ,b_k)$","tag":"LATEX"},{"body":", where \n      ","tag":"#text"},{"body":"$a_k\\geq b_k$","tag":"LATEX"},{"body":", for which Euclid's\n      Algorithm terminates in ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" steps. The proof is\n      based on the claim that, if\n      ","tag":"#text"},{"body":"$(a_{k+1},\\ b_{k+1}) \\rightarrow (a_{k},\\ b_{k})       \\rightarrow (a_{k-1},\\ b_{k-1})$","tag":"LATEX"},{"body":" are three successive pairs\n      in the reduction process, then we must have \n      ","tag":"#text"},{"body":"$b_{k+1}\\geq b_{k} + b_{k-1}$","tag":"LATEX"},{"body":".\n      To verify the claim, consider that a reduction step is defined by applying\n      the transformation ","tag":"#text"},{"body":"$a_{k-1} = b_{k}$","tag":"LATEX"},{"body":", \n      ","tag":"#text"},{"body":"$b_{k-1} =       \\textrm{remainder of}\\ a_{k}\\ \\textrm{divided by}\\ b_{k}$","tag":"LATEX"},{"body":".  \n      The second equation means that\n      ","tag":"#text"},{"body":"$a_{k} = qb_{k} + b_{k-1}$","tag":"LATEX"},{"body":" for some positive\n      integer ","tag":"#text"},{"body":"$q$","tag":"LATEX"},{"body":". And since\n      ","tag":"#text"},{"body":"$q$","tag":"LATEX"},{"body":" must be at least 1 we have \n      ","tag":"#text"},{"body":"$a_{k} = qb_{k} + b_{k-1} \\geq b_{k} + b_{k-1}$","tag":"LATEX"},{"body":".\n      But in the previous reduction step we have\n      ","tag":"#text"},{"body":"$b_{k+1}= a_{k}$","tag":"LATEX"},{"body":". Therefore,\n      ","tag":"#text"},{"body":"$b_{k+1} = a_{k}\\geq b_{k} + b_{k-1}$","tag":"LATEX"},{"body":".\n      This verifies the claim.  Now we can prove the theorem by induction on\n      ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":", the number of steps that the algorithm\n      requires to terminate. The result is true for\n      ","tag":"#text"},{"body":"$k=1$","tag":"LATEX"},{"body":", since this merely requires that\n      ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":" be at least as large as \n      ","tag":"#text"},{"body":"$\\text{Fib}(1)=1$","tag":"LATEX"},{"body":". Now, assume that the result\n      is true for all integers less than or equal to\n      ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" and establish the result for \n      ","tag":"#text"},{"body":"$k+1$","tag":"LATEX"},{"body":".  Let\n      ","tag":"#text"},{"body":"$(a_{k+1},\\ b_{k+1})\\rightarrow(a_{k},\\ b_{k})       \\rightarrow(a_{k-1},\\ b_{k-1})$","tag":"LATEX"},{"body":" be successive pairs in the\n      reduction process.  By our induction hypotheses, we have\n      ","tag":"#text"},{"body":"$b_{k-1}\\geq {\\textrm{Fib}}(k-1)$","tag":"LATEX"},{"body":" and \n      ","tag":"#text"},{"body":"$b_{k}\\geq {\\textrm{Fib}}(k)$","tag":"LATEX"},{"body":".  Thus, applying\n      the claim we just proved together with the definition of the Fibonacci\n      numbers gives\n      ","tag":"#text"},{"body":"$b_{k+1} \\geq b_{k} + b_{k-1}\\geq {\\textrm{Fib}}(k) +       {\\textrm{Fib}}(k-1) = {\\textrm{Fib}}(k+1)$","tag":"LATEX"},{"body":", which completes\n      the proof of Lamé's Theorem.","tag":"#text"}]}]