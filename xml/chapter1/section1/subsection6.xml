<SUBSECTION>
  <NAME>
    Conditional Expressions and Predicates
  </NAME>
  <LABEL NAME="sec:conditionals"/>

  <TEXT>
    The expressive power of the class of
    <SPLITINLINE>
      <SCHEME>
	procedures
      </SCHEME>
      <PYTHON>
	functions
      </PYTHON>
    </SPLITINLINE>
    that we can define at this point is very limited, because we have no way to
    make tests and to perform different operations depending on the result of a
    test.
    <SPLIT>
      <SCHEME>
        For instance, we cannot define a procedure that computes the 
        <INDEX>absolute value</INDEX>
        absolute
        value of a number by testing whether the number is positive, negative,
        or zero and taking different actions in the different cases according
        to the rule
        <LATEX>
      \[\begin{array}{lll}
          |x| &amp; = &amp; \left\{ \begin{array}{rl}
          x   &amp; \mbox{if $x&gt;0$} \\
          0   &amp; \mbox{if $x=0$} \\
          -x  &amp; \mbox{if $x&lt;0$}
          \end{array}
          \right.
      \end{array}\]
        </LATEX>
        This construct is called a
        <INDEX>case analysis<SUBINDEX>general</SUBINDEX></INDEX>
	<EM>case analysis</EM>, and
        there is a special form in Lisp for notating such a case
        analysis.  It is called 
        <INDEX><DECLARATION>cond</DECLARATION></INDEX> 
        <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>cond</ORDER><SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX>conditional expression<SUBINDEX><ORDER>cond</ORDER><SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
        <SCHEMEINLINE>cond</SCHEMEINLINE> (which stands for
        <QUOTE>conditional</QUOTE>), and it is used as follows:
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX> 
          <NAME>abs_definition</NAME>
          <EXAMPLE>abs_example</EXAMPLE>
          <SCHEME>
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((&lt; x 0) (- x))))
          </SCHEME>
        </SNIPPET>
        <SNIPPET EVAL="no">
          <NAME>abs_example</NAME>
          <SCHEME>
(abs (- 5))
          </SCHEME>
        </SNIPPET>
        The general form of a conditional expression is
        <SNIPPET EVAL="no" LATEX="yes">
          <SCHEME>
(cond ($\langle p_1 \rangle $ $\langle e_1 \rangle$)
      ($\langle p_2 \rangle $ $\langle e_2 \rangle$)
      $\vdots$
      ($\langle p_n \rangle $ $\langle e_n \rangle$))
          </SCHEME>
        </SNIPPET>
        consisting of the symbol <SCHEMEINLINE>cond</SCHEMEINLINE> followed by
        <INDEX>parentheses<SUBINDEX><ORDER>delimiting cond</ORDER>delimiting <SCHEMEINLINE>cond</SCHEMEINLINE> clauses</SUBINDEX></INDEX>
        parenthesized pairs of expressions
	<SCHEMEINLINE>(</SCHEMEINLINE><LATEXINLINE>$\langle p\ e \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE>
        called 
        <INDEX>clause, of a <SCHEMEINLINE>cond</SCHEMEINLINE></INDEX>
        <INDEX><DECLARATION>cond</DECLARATION><SUBINDEX>clause</SUBINDEX></INDEX>
        <EM>clauses</EM>. The first expression in each pair is a 
        <INDEX>predicate<SUBINDEX><ORDER>cond</ORDER>of <SCHEMEINLINE>cond</SCHEMEINLINE> clause</SUBINDEX></INDEX>
	<INDEX>conditional expression<SUBINDEX>predicate, consequent, alternative of</SUBINDEX></INDEX>
        <EM>predicate</EM><EMDASH/>that is, an expression whose value is
	interpreted as either true or false.<FOOTNOTE>
        <QUOTE>Interpreted as either
        <INDEX>true</INDEX>
	<INDEX>false</INDEX>
        <INDEX><DECLARATION>\#t</DECLARATION></INDEX>
	<INDEX><DECLARATION>true</DECLARATION></INDEX>
        <INDEX><DECLARATION>\#f</DECLARATION></INDEX>
	<INDEX><DECLARATION>false</DECLARATION></INDEX> 
	true or false</QUOTE>
        means this: In Scheme, there are two distinguished values that are
        denoted by the constants 
        <SCHEMEINLINE>#t</SCHEMEINLINE> and <SCHEMEINLINE>#f</SCHEMEINLINE>.  
        When the interpreter checks a predicate<APOS/>s value, it interprets 
        <SCHEMEINLINE>#f</SCHEMEINLINE> as false.  Any other value
        is treated as true.  (Thus, providing <SCHEMEINLINE>#t</SCHEMEINLINE>
	is logically unnecessary, but it is convenient.)  In this book we will
	use names <SCHEMEINLINE>true</SCHEMEINLINE> and
	<SCHEMEINLINE>false</SCHEMEINLINE>, 
        which are associated with the values <SCHEMEINLINE>#t</SCHEMEINLINE> and 
        <SCHEMEINLINE>#f</SCHEMEINLINE> respectively.</FOOTNOTE>
      </SCHEME>
      <PYTHON>
	<COMMENT>
	  We start with conditional expressions here, because they fit nicer
	  into the substitution model. Note that all functions in sections
	  1.1.1 to 1.1.7 have a single return statement as their body, which
	  enforces the emphasis on conditional expressions. Conditional
	  statements are introduced in 1.3.2.
	</COMMENT>
        For instance, we cannot declare a function that computes the 
        <INDEX>absolute value</INDEX>
        absolute value of a number by testing whether the number is nonnegative
	and taking different actions in each case according to the rule
        <LATEX>
      \[\begin{array}{lll}
          |x| &amp; = &amp; \left\{ \begin{array}{rl}
          x   &amp; \mbox{if $x \geq 0$} \\
          -x  &amp; \mbox{otherwise}
          \end{array}
          \right.
      \end{array}\]
        </LATEX>
	<COMMENT>
	  We simplify the example so that we can get away with a single
	  conditional expression.
	</COMMENT>
        This construct is a
	<INDEX>case analysis</INDEX>
	<EM>case analysis</EM> and can be written
	in JavaScript using a <EM>conditional expression</EM> as
        <SNIPPET>
	  <INDEX><DECLARATION>abs</DECLARATION></INDEX>
          <NAME>abs_definition</NAME>
          <EXAMPLE>abs_example</EXAMPLE>
          <PYTHON>
function abs(x) {
    return x &gt;= 0 ? x : - x;
}
          </PYTHON>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <NAME>abs_example</NAME>
	  <REQUIRES>abs_definition</REQUIRES>
	  <EXPECTED>5</EXPECTED>
          <PYTHON>
abs(-5);
          </PYTHON>
        </SNIPPET>
	which could be expressed in English as <QUOTE>If <LATEXINLINE>$x$</LATEXINLINE> is
	greater than or equal to zero, return<SPACE/><LATEXINLINE>$x$</LATEXINLINE>; otherwise
	return <LATEXINLINE>$- x$</LATEXINLINE>.</QUOTE>
        The general form of a conditional expression is
        <SNIPPET EVAL="no" LATEX="yes">
          <PYTHON>
<META>predicate</META> ? <META>consequent-expression</META> : <META>alternative-expression</META>
          </PYTHON>
        </SNIPPET>
        Conditional
	<INDEX>conditional expression</INDEX>
	<INDEX>syntactic forms<SUBINDEX>conditional expression</SUBINDEX></INDEX>
	<INDEX><PYTHONINLINE>?</PYTHONINLINE><SPACE/><PYTHONINLINE>:</PYTHONINLINE><ORDER>;3</ORDER></INDEX>
	<INDEX>predicate<SUBINDEX><ORDER>conditional</ORDER>of conditional expression</SUBINDEX></INDEX>
	<INDEX><ORDER>true</ORDER><USE>true</USE> (keyword)</INDEX>
	<INDEX><ORDER>false</ORDER><USE>false</USE> (keyword)</INDEX>
	<INDEX>keywords<SUBINDEX><ORDER>true</ORDER><USE>true</USE></SUBINDEX></INDEX>
	<INDEX>keywords<SUBINDEX><ORDER>false</ORDER><USE>false</USE></SUBINDEX></INDEX>
	<INDEX>expression<SUBINDEX>primitive boolean</SUBINDEX></INDEX>
	<INDEX>boolean values (true, false)</INDEX>
	expressions begin with a
        <META>predicate</META><EMDASH/>that is, 
        an expression whose value is either
	<EM>true</EM> or <EM>false</EM>, two distinguished
	<EM>boolean</EM> values in JavaScript.
	The primitive boolean expressions
	<PYTHONINLINE>true</PYTHONINLINE> and
	<PYTHONINLINE>false</PYTHONINLINE> trivially evaluate
	to the boolean values true and false, respectively.
	The <META>predicate</META> 
        is followed by a question mark, the 
        <META>consequent-expression</META>, 
        a colon, and finally the
        <META>alternative-expression</META>.
      </PYTHON>
    </SPLIT>
  </TEXT>
  <SPLIT>
    <SCHEME>
      <TEXT>
        Conditional expressions are
        <INDEX><DECLARATION>cond</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
        <INDEX>evaluation<SUBINDEX><ORDER>of cond</ORDER>of <SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
	evaluated as follows.  The predicate
        <LATEXINLINE>$\langle p_1 \rangle$</LATEXINLINE> is evaluated first.
	If its value is false, then
        <LATEXINLINE>$\langle p_2 \rangle$</LATEXINLINE> is evaluated.  
        If <LATEXINLINE>$\langle p_2 \rangle$</LATEXINLINE><APOS/>s 
        value is also false, then
        <LATEXINLINE>$\langle p_3 \rangle$</LATEXINLINE> is evaluated.  
        This process continues until a predicate is
        found whose value is true, in which case the interpreter returns the
        value of the corresponding 
        <INDEX>consequent<SUBINDEX><ORDER>cond</ORDER>of <SCHEMEINLINE>cond</SCHEMEINLINE> clause</SUBINDEX></INDEX>
        <EM>consequent expression</EM>
	<LATEXINLINE>$\langle e \rangle$</LATEXINLINE> of the
        clause as the value of the conditional expression.  If none of the
        <LATEXINLINE>$\langle p \rangle$</LATEXINLINE><APOS/>s
	is found to be true, the value of the <SCHEMEINLINE>cond</SCHEMEINLINE>
	is undefined.
      </TEXT>
    </SCHEME>
    <PYTHON>
      <TEXT>
        To
	<INDEX>evaluation<SUBINDEX>of conditional expression</SUBINDEX></INDEX>
	<INDEX>conditional expression<SUBINDEX>evaluation of</SUBINDEX></INDEX>
	evaluate a conditional expression,
	the interpreter starts by evaluating the 
        <META>predicate</META> 
        of the expression. If the
	<META>predicate</META> 
        evaluates to true, the interpreter evaluates the
        <INDEX>consequent<SUBINDEX><ORDER>conditional expression</ORDER>of conditional expression</SUBINDEX></INDEX>
        <META>consequent-expression</META> and returns its value as the value of the conditional.
        If the <META>predicate</META>
	evaluates to false, it evaluates the
        <INDEX>alternative<SUBINDEX><ORDER>conditional expression</ORDER>of conditional expression</SUBINDEX></INDEX>
        <META>alternative-expression</META> and returns its value as the value of the
	conditional.<FOOTNOTE>
	<INDEX>conditional expression<SUBINDEX>non-boolean value as predicate</SUBINDEX></INDEX>
	Conditionals in full JavaScript accept any value, not just a boolean, as the result of evaluating
	the <META>predicate</META> expression (see footnote<SPACE/><REF NAME="foot:truthy"/>
	in section<SPACE/><REF NAME="sec:eval-data-structures"/> for details). The programs in this book
	use only boolean values as predicates of conditionals.
      </FOOTNOTE>
      </TEXT>
    </PYTHON>
  </SPLIT>
  <SPLIT>
    <SCHEME>
      <TEXT>
        The word
        <INDEX>predicate</INDEX>
	<EM>predicate</EM> is used for procedures that return true
        or false, as well as for expressions that evaluate to true or false.
        The absolute-value procedure <SCHEMEINLINE>abs</SCHEMEINLINE> makes use of the 
        <INDEX><USE>&gt;</USE> (primitive numeric comparison predicate)</INDEX>   
        <INDEX><USE>&lt;</USE> (primitive numeric comparison predicate)</INDEX>   
        <INDEX><USE>=</USE> (primitive numeric equality predicate)</INDEX>   
        <INDEX><USE>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</USE><SUBINDEX><ORDER>&gt;</ORDER><SCHEMEINLINE>&gt;</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX><USE>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</USE><SUBINDEX><ORDER>&lt;</ORDER><SCHEMEINLINE>&lt;</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX><USE>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</USE><SUBINDEX><ORDER>=</ORDER><SCHEMEINLINE>=</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX>number(s)<SUBINDEX>comparison of</SUBINDEX></INDEX>
        <INDEX>number(s)<SUBINDEX>equality of</SUBINDEX></INDEX>
        <INDEX>equality<SUBINDEX><ORDER>numbers</ORDER>of numbers</SUBINDEX></INDEX>
        primitive predicates <SCHEMEINLINE>&gt;</SCHEMEINLINE>, 
        <SCHEMEINLINE>&lt;</SCHEMEINLINE>, and 
        <SCHEMEINLINE>=</SCHEMEINLINE>.<FOOTNOTE>
	<SCHEMEINLINE>Abs</SCHEMEINLINE> also uses
        <INDEX><USE>-</USE> (primitive subtraction procedure)<SUBINDEX>as negation</SUBINDEX></INDEX>
        <INDEX><USE>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</USE><SUBINDEX><ORDER>-</ORDER><SCHEMEINLINE>-</SCHEMEINLINE></SUBINDEX></INDEX>
        the <QUOTE>minus</QUOTE> operator <SCHEMEINLINE>-</SCHEMEINLINE>, 
        which, when used with a single
        operand, as in <SCHEMEINLINE>(- x)</SCHEMEINLINE>, 
        indicates negation.</FOOTNOTE> These take two numbers as arguments and
	test whether the first number is, respectively, greater than, less than,
	or equal to the second number, returning true or false accordingly.
      </TEXT>
    </SCHEME>
    <PYTHON>
      <TEXT>
        The word
        <INDEX>predicate</INDEX>
	<EM>predicate</EM> is used for operators and functions that
	return true or false, as well as for expressions that
	evaluate to true or false. The absolute-value function
	<PYTHONINLINE>abs</PYTHONINLINE> makes use of the
	<INDEX><USE>&gt;=</USE> (numeric comparison operator)</INDEX>
	<INDEX><OPERATOR/><SUBINDEX><USE>&gt;=</USE> (numeric comparison)</SUBINDEX><FRAGILE/></INDEX>
        <INDEX>number(s)<SUBINDEX>comparison of</SUBINDEX></INDEX>
        <INDEX>number(s)<SUBINDEX>equality of</SUBINDEX></INDEX>
        primitive predicate <PYTHONINLINE>&gt;=</PYTHONINLINE>,
	an operator that takes two numbers as arguments and tests whether the
	first number is greater than or equal to the second number, returning
	true or false accordingly.
      </TEXT>
    </PYTHON>
  </SPLIT>
  <SPLIT>
    <SCHEME>
      <TEXT>
        Another way to write the absolute-value procedure is
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX> 
          <EXAMPLE>abs_example</EXAMPLE>
          <SCHEME>
(define (abs x)
  (cond ((&lt; x 0) (- x))
    (else x)))
          </SCHEME>
        </SNIPPET>
        which could be expressed in English as 
        <QUOTE>If <LATEXINLINE>$x$</LATEXINLINE> is less than zero
        return <LATEXINLINE>$- x$</LATEXINLINE>; otherwise return 
        <LATEXINLINE>$x$</LATEXINLINE>.</QUOTE>  
        <INDEX><DECLARATION>else</DECLARATION> (special symbol in <SCHEMEINLINE>cond</SCHEMEINLINE>)</INDEX>
        <SCHEMEINLINE>Else</SCHEMEINLINE> is a special symbol that can be used
	in place of the <LATEXINLINE>$\langle p \rangle$</LATEXINLINE> in the
	final clause of a <SCHEMEINLINE>cond</SCHEMEINLINE>.  
        This causes the <SCHEMEINLINE>cond</SCHEMEINLINE> to return as its value 
        the value of the corresponding
	<LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
        whenever all previous clauses have been bypassed. In fact, any
	expression that always evaluates to a true value could be used as the
	<LATEXINLINE>$\langle p \rangle$</LATEXINLINE> here.
      </TEXT>
    </SCHEME>
    <PYTHON>
    </PYTHON>
  </SPLIT>
  <SPLIT>
    <SCHEME>
      <TEXT>
        Here is yet another way to write the absolute-value procedure:
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX> 
          <EXAMPLE>abs_example</EXAMPLE>
          <SCHEME>
(define (abs x)
  (if (&lt; x 0)
    (- x)
    x))
          </SCHEME>
        </SNIPPET>
        <INDEX>conditional expression<SUBINDEX><ORDER>if</ORDER><SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        This uses the
        <INDEX><DECLARATION>if</DECLARATION></INDEX>
        <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>if</ORDER><SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
	special form <SCHEMEINLINE>if</SCHEMEINLINE>, a restricted 
        type of conditional that can be used when there are precisely 
        <INDEX>case analysis<SUBINDEX><ORDER>two</ORDER>with two cases (<SCHEMEINLINE>if</SCHEMEINLINE>)</SUBINDEX></INDEX>
        two cases in the case
        analysis.  The general form of an <SCHEMEINLINE>if</SCHEMEINLINE>
	expression is
        <SNIPPET EVAL="no"  LATEX="yes">
          <SCHEME>
(if $\langle \textit{predicate} \rangle$ $\langle \textit{consequent}\rangle$ $\langle \textit{alternative}\rangle$)
          </SCHEME>
        </SNIPPET>
        To
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
        <INDEX>evaluation<SUBINDEX><ORDER>of if</ORDER>of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX>predicate, consequent, and alternative of</SUBINDEX></INDEX>
	evaluate an <SCHEMEINLINE>if</SCHEMEINLINE> expression, 
        the interpreter starts by evaluating the 
        <INDEX>predicate<SUBINDEX><ORDER>if</ORDER>of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        <LATEXINLINE>$\langle \textit{predicate}\rangle$</LATEXINLINE> 
        part of the expression.  
        If the <LATEXINLINE>$\langle \textit{predicate}\rangle$</LATEXINLINE> 
        evaluates to a true value, the interpreter then evaluates the 
        <INDEX>consequent<SUBINDEX><ORDER>if</ORDER>of <SCHEMEINLINE>if</SCHEMEINLINE></SUBINDEX></INDEX>
        <LATEXINLINE>$\langle \textit{consequent}\rangle$</LATEXINLINE> 
        and returns its value.  Otherwise it evaluates the 
        <INDEX>alternative of <SCHEMEINLINE>if</SCHEMEINLINE></INDEX>
        <LATEXINLINE>$\langle \textit{alternative}\rangle$</LATEXINLINE> 
        and returns its value.<FOOTNOTE>A minor 
        difference
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX><ORDER>cond</ORDER><SCHEMEINLINE>cond</SCHEMEINLINE> vs.</SUBINDEX></INDEX>
        <INDEX><DECLARATION>cond</DECLARATION><SUBINDEX><ORDER>if</ORDER><SCHEMEINLINE>if</SCHEMEINLINE> vs.</SUBINDEX></INDEX>
        <INDEX>sequence of expressions<SUBINDEX>in consequent of <SCHEMEINLINE>cond</SCHEMEINLINE></SUBINDEX></INDEX>
	between <SCHEMEINLINE>if</SCHEMEINLINE> and 
        <SCHEMEINLINE>cond</SCHEMEINLINE> is that the
        <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
        part of each <SCHEMEINLINE>cond</SCHEMEINLINE> 
        clause may be a sequence of expressions.
        If the corresponding <LATEXINLINE>$\langle p \rangle$</LATEXINLINE> 
        is found to be true, 
        the expressions 
        <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
        are evaluated in sequence and the value of the final
        expression in the sequence is returned as the value of the 
        <SCHEMEINLINE>cond</SCHEMEINLINE>.
        In an <SCHEMEINLINE>if</SCHEMEINLINE> expression, however, 
        the <LATEXINLINE>$\langle \textit{consequent}\rangle$</LATEXINLINE> and
        <LATEXINLINE>$\langle \textit{alternative}\rangle$</LATEXINLINE> must
	be single expressions.<LABEL NAME="foot:cond-consequent"/></FOOTNOTE>
      </TEXT>
    </SCHEME>
    <PYTHON>
      <LONG_PAGE lines="1"/>
      <TEXT>
      If we prefer to handle the zero case separately, we can specify the function
      that computes the absolute value of a number by writing
        <LATEX>
      \[\begin{array}{lll}
          |x| &amp;=&amp; \left\{ \begin{array}{rl}
          x   &amp; \mbox{if $x &gt; 0$} \\
          0   &amp; \mbox{if $x = 0$} \\
          -x  &amp; \mbox{otherwise}
          \end{array}
          \right.
          \end{array}\]
        </LATEX>
	In JavaScript, we express a case analysis with multiple cases by nesting
	conditional expressions as alternative expressions inside other conditional expressions:
        <SNIPPET>
          <INDEX><DECLARATION>abs</DECLARATION></INDEX>
          <EXAMPLE>abs_example</EXAMPLE>
          <PYTHON>
function abs(x) {
    return x &gt; 0
           ? x
           : x === 0
           ? 0
           : - x;
}
	  </PYTHON>
        </SNIPPET>
	Parentheses are not needed around the alternative expression
	<PYTHONINLINE>x === 0 ? 0 : - x</PYTHONINLINE>, because
	the conditional-expression syntactic form
	<INDEX>conditional expression<SUBINDEX><ORDER>alternative</ORDER>as alternative of conditional expression</SUBINDEX></INDEX>
	<INDEX>associativity<SUBINDEX><ORDER>conditional expression</ORDER>of conditional expression</SUBINDEX></INDEX>
	<INDEX>conditional expression<SUBINDEX>right-associativity of</SUBINDEX></INDEX>
	<INDEX>right-associative</INDEX>
	is right-associative.
	The interpreter ignores spaces and line breaks, here inserted for readability
	to align the
	<PYTHONINLINE>?</PYTHONINLINE><APOS/>s
	and <PYTHONINLINE>:</PYTHONINLINE><APOS/>s under the first predicate
	of the case analysis.
	The general form of a
	<INDEX>case analysis<SUBINDEX>general</SUBINDEX></INDEX>
	case analysis is
  <DO_BREAK_PAGE/>
	<SNIPPET LATEX="yes" EVAL="no">
	  <PYTHON>
<META>p</META>$_1$
? <META>e</META>$_1$
: <META>p</META>$_2$
? <META>e</META>$_2$
$\vdots$
: <META>p</META>$_n$
? <META>e</META>$_n$
: <META>final-alternative-expression</META>
	  </PYTHON>
	</SNIPPET>
	We call a predicate <LATEXINLINE>$p_i$</LATEXINLINE>
	together with its consequent expression
	<LATEXINLINE>$e_i$</LATEXINLINE>
	a
	<INDEX>clause of a case analysis</INDEX>
	<INDEX>predicate<SUBINDEX><ORDER>clause</ORDER>of clause</SUBINDEX></INDEX>
	<EM>clause</EM>. A case analysis
	can be seen as a sequence of clauses, followed by a final
	alternative expression.
	<INDEX>case analysis<SUBINDEX><ORDER>sequence</ORDER>as sequence of clauses</SUBINDEX></INDEX>
	According to the evaluation of conditional expressions,
	a case analysis is evaluated by first evaluating
	the predicate <META>p</META><LATEXINLINE>$_1$</LATEXINLINE>.
	If its value is false, then <META>p</META><LATEXINLINE>$_2$</LATEXINLINE>
	is evaluated.
	If <META>p</META><LATEXINLINE>$_2$</LATEXINLINE><APOS/>s
	value is also false, then <META>p</META><LATEXINLINE>$_3$</LATEXINLINE>
	is evaluated. This process continues until a predicate is
        found whose value is true, in which case the interpreter returns the
        value of the corresponding
	<INDEX>consequent<SUBINDEX><ORDER>clause</ORDER>of clause</SUBINDEX></INDEX>
	consequent expression
	<META>e</META>
	of the clause
	as the value of the case analysis.
	If none of the
	<META>p</META><APOS/>s
	is found to be true, the value of the case analysis
	is the value of the final alternative expression.
      </TEXT>
    </PYTHON>
  </SPLIT>
  <SPLIT>
    <SCHEME>
      <TEXT>
        In addition to primitive predicates such as
	<SCHEMEINLINE>&lt;</SCHEMEINLINE>,
	<SCHEMEINLINE>=</SCHEMEINLINE>, and <SCHEMEINLINE>&gt;</SCHEMEINLINE>,
	there are logical composition operations, which enable us to construct
	compound predicates.  The three most frequently used are these:
        <UL>
          <LI>
            <INDEX><DECLARATION>and</DECLARATION></INDEX> 
            <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>and</ORDER><SCHEMEINLINE>and</SCHEMEINLINE></SUBINDEX></INDEX>
            <INDEX><DECLARATION>and</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
            <INDEX>evaluation<SUBINDEX><ORDER>of and</ORDER>of <SCHEMEINLINE>and</SCHEMEINLINE></SUBINDEX></INDEX>
	    <SCHEMEINLINE>(and</SCHEMEINLINE>
	    <LATEXINLINE>$\langle e_1\rangle \ldots \langle e_n \rangle$
	    </LATEXINLINE>
	    <SCHEMEINLINE>)</SCHEMEINLINE><BR/>
            The interpreter evaluates the expressions
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> one at a time, 
            in left-to-right order.  If any
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> evaluates to false, 
            the value of the <SCHEMEINLINE>and</SCHEMEINLINE> expression is
	    false, and the rest of the
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS/>s 
            are not evaluated. If all
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS/>s
	    evaluate to true values, the value of the
	    <SCHEMEINLINE>and</SCHEMEINLINE>
            expression is the value of the last one.
          </LI>
          <LI>
            <INDEX><DECLARATION>or</DECLARATION></INDEX> 
            <INDEX><DECLARATION>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>or</ORDER><SCHEMEINLINE>or</SCHEMEINLINE></SUBINDEX></INDEX>
            <INDEX><DECLARATION>or</DECLARATION><SUBINDEX>evaluation of</SUBINDEX></INDEX>
            <INDEX>evaluation<SUBINDEX><ORDER>of or</ORDER>of <SCHEMEINLINE>or</SCHEMEINLINE></SUBINDEX></INDEX>
            <SCHEMEINLINE>(or</SCHEMEINLINE> <LATEXINLINE>$\langle e_1 \rangle\ldots \langle e_n \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE><BR/>
            The interpreter evaluates the expressions 
            <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> one at a time, in
	    left-to-right order.  If any
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE>
	    evaluates to a true value, that value is returned as the value of the
	    <SCHEMEINLINE>or</SCHEMEINLINE> expression, and the rest of the
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS/>s are not
	    evaluated. If all
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><APOS/>s
	    evaluate to false, the value of the
	    <SCHEMEINLINE>or</SCHEMEINLINE> expression is false.
          </LI>
          <LI>
            <INDEX><DECLARATION>not</DECLARATION></INDEX> 
            <INDEX><DECLARATION>primitive procedures (those marked <EM>ns</EM> are not in the IEEE Scheme standard)</DECLARATION><SUBINDEX><ORDER>not</ORDER><SCHEMEINLINE>not</SCHEMEINLINE></SUBINDEX></INDEX>
            <SCHEMEINLINE>(not</SCHEMEINLINE>
	    <LATEXINLINE>$\langle e \rangle$</LATEXINLINE><SCHEMEINLINE>)
	    </SCHEMEINLINE><BR/>
            The value of a <SCHEMEINLINE>not</SCHEMEINLINE> expression is true
            when the expression <LATEXINLINE>$\langle e \rangle$</LATEXINLINE> 
            evaluates to false, and false otherwise.
          </LI>
        </UL>
        <INDEX><DECLARATION>and</DECLARATION><SUBINDEX>why a special form</SUBINDEX></INDEX>
        <INDEX><DECLARATION>or</DECLARATION><SUBINDEX>why a special form</SUBINDEX></INDEX>
        Notice that <SCHEMEINLINE>and</SCHEMEINLINE> and
	<SCHEMEINLINE>or</SCHEMEINLINE> are special forms, not procedures,
        because the subexpressions are not necessarily all evaluated.
        <SCHEMEINLINE>Not</SCHEMEINLINE> is an ordinary procedure.
      </TEXT>
    </SCHEME>
    <PYTHON>
      <LONG_PAGE lines="1"/>
      <TEXT>
        In addition to primitive predicates such as
	<INDEX><USE>&gt;</USE> (numeric comparison operator)<FRAGILE/></INDEX>
        <INDEX><ORDER>&gt;=0</ORDER><PYTHONINLINE>&lt;</PYTHONINLINE> (numeric comparison operator)</INDEX> 
	<INDEX><ORDER>&gt;=1</ORDER><PYTHONINLINE>&lt;=</PYTHONINLINE> (numeric comparison operator)<FRAGILE/></INDEX>
	<INDEX><USE>===</USE><SUBINDEX><ORDER>numeric</ORDER>as numeric equality operator</SUBINDEX><FRAGILE/></INDEX>
	<INDEX><USE>"!==</USE><ORDER>;4</ORDER><SUBINDEX>as numeric comparison operator<ORDER>numeric</ORDER></SUBINDEX><FRAGILE/></INDEX>
	<INDEX><OPERATOR/><SUBINDEX><USE>&gt;</USE> (numeric comparison)</SUBINDEX><FRAGILE/></INDEX>
	<INDEX><OPERATOR/><SUBINDEX><ORDER>===1</ORDER><USE>&lt;</USE> (numeric comparison)</SUBINDEX><FRAGILE/></INDEX>
	<INDEX><OPERATOR/><SUBINDEX><ORDER>===2</ORDER><USE>&lt;=</USE> (numeric comparison)</SUBINDEX><FRAGILE/></INDEX>
	<INDEX><OPERATOR/><SUBINDEX><USE>===</USE> (for numeric comparison)</SUBINDEX><FRAGILE/></INDEX>
	<INDEX><OPERATOR/><SUBINDEX><USE>"!==</USE> (for numeric comparison)<ORDER>;4</ORDER></SUBINDEX><FRAGILE/></INDEX>
        <INDEX>equality<SUBINDEX><ORDER>numbers</ORDER>of numbers</SUBINDEX></INDEX>
        <PYTHONINLINE>&gt;=</PYTHONINLINE>, 
        <PYTHONINLINE>&gt;</PYTHONINLINE>, 
        <PYTHONINLINE>&lt;</PYTHONINLINE>, 
        <PYTHONINLINE>&lt;=</PYTHONINLINE>, 
        <PYTHONINLINE>===</PYTHONINLINE>, and
        <PYTHONINLINE>!==</PYTHONINLINE> that are applied to
	numbers,<FOOTNOTE>For now, we restrict these operators to number
	arguments. In sections<SPACE/><REF NAME="sec:strings"/>
	and<SPACE/><REF NAME="sec:mutable-list-structure"/>, we shall
	generalize the equality and inequality predicates
	<PYTHONINLINE>===</PYTHONINLINE> and
	<PYTHONINLINE>!==</PYTHONINLINE>.</FOOTNOTE>
	there are logical composition operations, which enable us to construct
	compound predicates. The three most frequently used are these:
        <UL>
          <LI>
	    <META>expression</META><LATEXINLINE>$_1$</LATEXINLINE> <PYTHONINLINE>&amp;&amp;</PYTHONINLINE>
	    <META>expression</META><LATEXINLINE>$_2$</LATEXINLINE><BR/>
	    This operation expresses
	    <INDEX>syntactic sugar<SUBINDEX><ORDER>;1</ORDER><PYTHONINLINE>&amp;&amp;</PYTHONINLINE> and {\tt "|"|} as</SUBINDEX></INDEX>
	    <INDEX><USE>&amp;&amp;</USE> (logical conjunction)<ORDER>;1</ORDER><FRAGILE/></INDEX>
	    <INDEX><USE>&amp;&amp;</USE> (logical conjunction)<SUBINDEX>evaluation of</SUBINDEX><ORDER>;1</ORDER><FRAGILE/></INDEX>
	    <INDEX>syntactic forms<SUBINDEX>logical conjunction (<PYTHONINLINE>&amp;&amp;</PYTHONINLINE>)</SUBINDEX><FRAGILE/></INDEX>
	    <INDEX>logical conjunction<FRAGILE/></INDEX>
	    <INDEX>conjunction</INDEX>
            <INDEX>evaluation<SUBINDEX>of <PYTHONINLINE>&amp;&amp;</PYTHONINLINE><ORDER>of ;1</ORDER></SUBINDEX><FRAGILE/></INDEX>
	    <EM>logical conjunction</EM>, meaning roughly 
	    the same as the English word <QUOTE>and.</QUOTE>
	    This syntactic form is syntactic sugar<FOOTNOTE>
            Syntactic forms that are simply convenient
            alternative surface structures for things that can be written in more
            uniform ways are sometimes called <EM>syntactic sugar</EM>, to use a
            phrase coined by 
            <INDEX>Landin, Peter</INDEX>
            <INDEX>syntactic sugar</INDEX>
	    Peter Landin.	    
	    </FOOTNOTE> for<BR/>
	    <META>expression</META><LATEXINLINE>$_1$</LATEXINLINE> <PYTHONINLINE>?</PYTHONINLINE>
	    <META>expression</META><LATEXINLINE>$_2$</LATEXINLINE> <PYTHONINLINE>:</PYTHONINLINE>
	    <PYTHONINLINE>false</PYTHONINLINE>.
          </LI>
          <LI>
            <META>expression</META><LATEXINLINE>$_1$</LATEXINLINE>
            <PYTHONINLINE>||</PYTHONINLINE>
            <META>expression</META><LATEXINLINE>$_2$</LATEXINLINE><BR/>
	    This operation expresses
	    <INDEX>{\tt "|"|} (logical disjunction)<ORDER>;2</ORDER><FRAGILE/></INDEX>
	    <INDEX>{\tt "|"|} (logical disjunction)<ORDER>;2</ORDER><SUBINDEX>evaluation of</SUBINDEX><FRAGILE/></INDEX>
	    <INDEX>syntactic forms<SUBINDEX>logical disjunction ({\tt "|"|})</SUBINDEX><FRAGILE/></INDEX>
	    <INDEX>logical disjunction<FRAGILE/></INDEX>
	    <INDEX>disjunction</INDEX>
            <INDEX>evaluation<SUBINDEX>of {\tt "|"|}<ORDER>of ;2</ORDER></SUBINDEX><FRAGILE/></INDEX>
	    <EM>logical disjunction</EM>, meaning roughly
	    the same as the English word <QUOTE>or.</QUOTE>
	    This syntactic form is syntactic sugar for<BR/>
	    <META>expression</META><LATEXINLINE>$_1$</LATEXINLINE> <PYTHONINLINE>?</PYTHONINLINE>
	    <PYTHONINLINE>true</PYTHONINLINE> <PYTHONINLINE>:</PYTHONINLINE>
	    <META>expression</META><LATEXINLINE>$_2$</LATEXINLINE>.

          </LI>
          <LI>
            <PYTHONINLINE>!</PYTHONINLINE>
	    <META>expression</META><BR/>
	    This operation expresses
	    <INDEX><USE>"!</USE> (logical negation operator)<ORDER>;399</ORDER></INDEX>
	    <INDEX><OPERATOR/><SUBINDEX><ORDER>;399</ORDER><USE>"!</USE> (logical negation)</SUBINDEX><FRAGILE/></INDEX>
	    <INDEX>negation<SUBINDEX>logical (<PYTHONINLINE>"!</PYTHONINLINE>)</SUBINDEX></INDEX>
	    <EM>logical negation</EM>, meaning
	    roughly the same as the English word <QUOTE>not.</QUOTE>
            The value of the expression is true when
	    <META>expression</META>
	    evaluates to false, and false when
	    <META>expression</META>
	    evaluates to true.
          </LI>
        </UL>
        Notice that <PYTHONINLINE>&amp;&amp;</PYTHONINLINE> and 
        <PYTHONINLINE>||</PYTHONINLINE> are syntactic forms,
	not operators;
	<INDEX><USE>&amp;&amp;</USE> (logical conjunction)<ORDER>;1</ORDER><SUBINDEX>why a syntactic form</SUBINDEX><FRAGILE/></INDEX>
	<INDEX>{\tt "|"|} (logical disjunction)<ORDER>;2</ORDER><SUBINDEX>why a syntactic form</SUBINDEX><FRAGILE/></INDEX>
	their right-hand
        expression is not always evaluated. The operator
        <PYTHONINLINE>!</PYTHONINLINE>, on the other hand, 
        follows the evaluation rule of section
	<REF NAME="sec:evaluating-combinations"/>.
        It is a <EM>unary</EM> operator, which means that it takes only
	one argument, whereas the arithmetic operators and primitive predicates
	discussed so far
	are <EM>binary</EM>, taking two arguments. The operator
        <PYTHONINLINE>!</PYTHONINLINE> precedes its argument;
	we call it a
        <INDEX><USE>-</USE><SUBINDEX>as numeric negation operator</SUBINDEX></INDEX>
        <INDEX><OPERATOR/><SUBINDEX><USE>-</USE> (numeric negation operator)</SUBINDEX></INDEX>
	<INDEX>negation<SUBINDEX>numeric (<PYTHONINLINE>-</PYTHONINLINE>)</SUBINDEX></INDEX>
	<INDEX>binary operator</INDEX>
	<INDEX>unary operator</INDEX>
	<INDEX>prefix operator</INDEX>
	<EM>prefix operator</EM>. Another prefix operator is
	the numeric negation operator, an example of
	which is the expression <PYTHONINLINE>- x</PYTHONINLINE>
	in the <PYTHONINLINE>abs</PYTHONINLINE> functions above.
      </TEXT>
    </PYTHON>
  </SPLIT>

  <SPLIT>
    <SCHEME>
      <TEXT>
        As an example of how these are used, the condition that a 
        number <LATEXINLINE>$x$</LATEXINLINE> be in the range
	<LATEXINLINE>$5 &lt; x &lt; 10$</LATEXINLINE> may be expressed as
        <SNIPPET EVAL="no">
          <SCHEME>
(and (> x 5) (&lt; x 10))
          </SCHEME>
        </SNIPPET>
      </TEXT>
    </SCHEME>
    <PYTHON>
      <TEXT>
        As an example of how these predicates are used, the condition that a 
        number <LATEXINLINE>$x$</LATEXINLINE> be in the range
	<LATEXINLINE>$5 &lt; x &lt; 10$</LATEXINLINE> may be expressed as
        <SNIPPET EVAL="no">
          <PYTHON>
x &gt; 5 &amp;&amp; x &lt; 10 
          </PYTHON>
        </SNIPPET>
        The syntactic form
	<PYTHONINLINE>&amp;&amp;</PYTHONINLINE>
        has lower precedence than the comparison operators
        <PYTHONINLINE>&gt;</PYTHONINLINE>
	and<SPACE/><PYTHONINLINE>&lt;</PYTHONINLINE>, and 
	the conditional-expression syntactic form
	<LATEXINLINE>$\cdots$</LATEXINLINE><PYTHONINLINE>?</PYTHONINLINE><LATEXINLINE>$\cdots$</LATEXINLINE><PYTHONINLINE>:</PYTHONINLINE><LATEXINLINE>$\cdots$</LATEXINLINE>
	has lower precedence than any other operator we have encountered so far,
	a property we used in
	the <PYTHONINLINE>abs</PYTHONINLINE> functions above.
      </TEXT>
    </PYTHON>
  </SPLIT>
  <TEXT>
    As another example, we can
    <SPLITINLINE>
      <SCHEME>
	define
      </SCHEME>
      <PYTHON>
	declare
      </PYTHON>
    </SPLITINLINE>
    a predicate to test whether one number is 
    <SPLITINLINE>
      <SCHEME>
	<INDEX><USE>&gt;=</USE></INDEX> 
      </SCHEME>
    </SPLITINLINE>
    greater than or equal to another as    
    <SNIPPET>
      <EXAMPLE>geq_example</EXAMPLE>
      <SCHEME>
(define (&gt;= x y)
  (or (&gt; x y) (= x y)))
      </SCHEME>
      <PYTHON>
function greater_or_equal(x, y) {
    return x &gt; y || x === y;
}
      </PYTHON>
    </SNIPPET>
    or alternatively as
    <SPLITINLINE>
      <SCHEME>
	<INDEX><USE>&gt;=</USE></INDEX> 
      </SCHEME>
    </SPLITINLINE>
    <SNIPPET>
      <EXAMPLE>geq_example</EXAMPLE>
      <SCHEME>
(define (&gt;= x y)
  (not (&lt; x y)))
      </SCHEME>
      <PYTHON>
function greater_or_equal(x, y) {
    return ! (x &lt; y);
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>geq_example</NAME>
      <SCHEME>
(&gt;= 7 4)
      </SCHEME>
      <PYTHON>
greater_or_equal(7, 4);
      </PYTHON>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
      </SCHEME>
      <PYTHON>
        The function <PYTHONINLINE>greater_or_equal</PYTHONINLINE>,
	when applied to two numbers, behaves the same as the operator
	<PYTHONINLINE>&gt;=</PYTHONINLINE>. Unary operators have
        <INDEX>precedence<SUBINDEX><ORDER>unary</ORDER>of unary operators</SUBINDEX></INDEX>
	higher precedence than binary operators, which makes the
	parentheses in this example necessary.
      </PYTHON>
    </SPLIT>
  </TEXT>

  <LONG_PAGE lines="1"/>
  <EXERCISE>
    Below is a sequence of
    <SPLITINLINE>
      <SCHEME>
	expressions.
      </SCHEME>
      <PYTHON>
	statements.
      </PYTHON>
    </SPLITINLINE>
    What is the result printed by the interpreter in response to each
    <SPLITINLINE>
      <SCHEME>
        expression?
      </SCHEME>
      <PYTHON>
	statement?
      </PYTHON>
    </SPLITINLINE>
    Assume that the sequence is to be evaluated in the order
    in which it is presented.
    <SNIPPET>
      <NAME>ten</NAME>
      <EXPECTED>10</EXPECTED>
      <SCHEME>
10
      </SCHEME>
      <PYTHON>
10;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>five_plus_three_plus_four</NAME>
      <EXPECTED>12</EXPECTED>
      <SCHEME>
(+ 5 3 4)
      </SCHEME>
      <PYTHON>
5 + 3 + 4;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>nine_minus_one</NAME>
      <EXPECTED>8</EXPECTED>
      <SCHEME>
(- 9 1)
      </SCHEME>
      <PYTHON>
9 - 1;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>six_over_two</NAME>
      <EXPECTED>3</EXPECTED>
      <SCHEME>
(/ 6 2)
      </SCHEME>
      <PYTHON>
6 / 2;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>two_times_four_etc</NAME>
      <EXPECTED>6</EXPECTED>
      <SCHEME>
(+ (* 2 4) (- 4 6))
      </SCHEME>
      <PYTHON>
2 * 4 + (4 - 6);
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>definea</NAME>
      <EXPECTED>undefined</EXPECTED>
      <SCHEME>
(define a 3)
      </SCHEME>
      <PYTHON>
const a = 3;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>defineb</NAME>
      <REQUIRES>definea</REQUIRES>
      <EXPECTED>undefined</EXPECTED>
      <SCHEME>
(define b (+ a 1))
      </SCHEME>
      <PYTHON>
const b = a + 1;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_plus_b_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>19</EXPECTED>
      <SCHEME>
(+ a b (* a b))
      </SCHEME>
      <PYTHON>
a + b + a * b;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_equal_b</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>false</EXPECTED>
      <SCHEME>
(= a b)
      </SCHEME>
      <PYTHON>
a === b;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>b_gt_a_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>4</EXPECTED>
      <SCHEME>
(if (and (> b a) (&lt; b (* a b)))
  b
  a)
      </SCHEME>
      <PYTHON>
b &gt; a &amp;&amp; b &lt; a * b ? b : a;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_equal_four_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>16</EXPECTED>
      <SCHEME>
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
      </SCHEME>
      <PYTHON>
a === 4
? 6
: b === 4
? 6 + 7 + a
: 25;
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>two_plus_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>6</EXPECTED>
      <SCHEME>
(+ 2 (if (> b a) b a))
      </SCHEME>
      <PYTHON>
2 + (b &gt; a ? b : a);
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>a_greater_b_etc</NAME>
      <REQUIRES>defineb</REQUIRES>
      <EXPECTED>16</EXPECTED>
      <SCHEME>
(* (cond ((> a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))
      </SCHEME>
      <PYTHON>
(a &gt; b
 ? a
 : a &lt; b
 ? b
 : -1)
*
(a + 1);
      </PYTHON>
    </SNIPPET>
    <SPLIT>
      <PYTHON>
	The parentheses around the conditional expressions in the last two statements
	are necessary because the
	<INDEX>conditional expression<SUBINDEX><ORDER>operand</ORDER>as operand of operator combination</SUBINDEX><FRAGILE/></INDEX>
	conditional-expression syntactic form has lower
	<INDEX>precedence<SUBINDEX><ORDER>conditional expression</ORDER>of conditional expression</SUBINDEX></INDEX>
	<INDEX>conditional expression<SUBINDEX>precedence of</SUBINDEX></INDEX>
	precedence than the arithmetic operators
	<PYTHONINLINE>+</PYTHONINLINE> and
	<PYTHONINLINE>*</PYTHONINLINE>.
      </PYTHON>
    </SPLIT>
    <LABEL NAME="ex:1_1"/>
  </EXERCISE>

  <EXERCISE>
    Translate the following expression into 
    <SPLITINLINE>
      <SCHEME>
        prefix form
      </SCHEME>
      <PYTHON>
        JavaScript
      </PYTHON>
    </SPLITINLINE>
    <PDF_ONLY>
      \par\medskip
    </PDF_ONLY>
    <LATEX>
      $\begin{array}{l}
      \quad~~\dfrac{5+4+\left(2-\left(3-(6+\frac{4}{5})\right)\right)}{3 (6-2) (2-7)}
      \end{array}$
    </LATEX>
    <SOLUTION>   
      <SNIPPET>
	<PYTHON>
(5 + 4 + (2 - (3 - (6 + 4 / 5)))) 
/
(3 * (6 - 2) * (2 - 7));
	</PYTHON>
      </SNIPPET>
    </SOLUTION>
    <LABEL NAME="ex:1_2"/>
  </EXERCISE>
  <EXERCISE>
    <SPLITINLINE>
      <SCHEME>
        Define a procedure
      </SCHEME>
      <PYTHON>
	Declare a function
      </PYTHON>
    </SPLITINLINE>
    that takes three numbers as arguments and returns
    the sum of the squares of the two larger numbers.
    <SOLUTION>
      <SNIPPET>
        <EXAMPLE>larger_two_square_example</EXAMPLE>
        <REQUIRES>square_definition</REQUIRES>
        <PYTHON>
function f(x, y, z) {
   return square(x) + square(y) + square(z) -
          // subtract the square of the smallest
          square(x &gt; y ? (y &gt; z ? z : y) : (x &gt; z ? z : x));
}
        </PYTHON>
        <SCHEME>
(define (f x y z)
   (let ((smallest (if (&gt; x y) (if (&gt; y z) z y) (if (&gt; x z) z x))))
      (- (+ (square x) (square y) (square z)) (square smallest))))
        </SCHEME>
      </SNIPPET>
    </SOLUTION>
    <SNIPPET HIDE="yes">
      <NAME>larger_two_square_example</NAME>
      <SCHEME>
(f 4 7 2)
      </SCHEME>
      <PYTHON>
f(4, 7, 2);
      </PYTHON>
    </SNIPPET>
    <LABEL NAME="ex:1_3"/>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:a-plus-abs-b"/>
    <SPLIT>
      <SCHEME>
	Observe that our model of evaluation allows for
	<INDEX>combination<SUBINDEX>compound expression as operator of</SUBINDEX></INDEX>
	<INDEX>compound expression<SUBINDEX><ORDER>operator</ORDER>as operator of combination</SUBINDEX></INDEX>
	<INDEX>operator of a combination<SUBINDEX>compound expression as</SUBINDEX></INDEX>
	combinations whose
	operators are compound expressions.  Use this observation to describe
	the behavior of the following procedure:
	<SNIPPET>
          <SCHEME>
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
          </SCHEME>
	</SNIPPET>
      </SCHEME>
      <PYTHON>
	Observe that our model of evaluation allows for
	<INDEX>function application<SUBINDEX>compound expression as function expression of</SUBINDEX></INDEX>
	<INDEX>compound expression<SUBINDEX><ORDER>function expression</ORDER>as function expression of application</SUBINDEX></INDEX>
	<INDEX>function expression<SUBINDEX>compound expression as</SUBINDEX></INDEX>
	applications
	whose function expressions are compound expressions. Use this observation
	to describe the behavior of <PYTHONINLINE>a_plus_abs_b</PYTHONINLINE>:
	<SNIPPET POSTPADDING="no">
          <EXAMPLE>plusminusexample</EXAMPLE>
          <PYTHON>
function plus(a, b) { return a + b; }
<SHORT_SPACE/>
function minus(a, b) { return a - b; }
<SHORT_SPACE/>
function a_plus_abs_b(a, b) {
    return (b >= 0 ? plus : minus)(a, b);
}
          </PYTHON>
	</SNIPPET>
	<SNIPPET HIDE="yes">
          <NAME>plusminusexample</NAME>
          <PYTHON>
a_plus_abs_b(5, -4);
          </PYTHON>
	</SNIPPET>
	<COMMENT>
	  Note that in conditional expressions in JavaScript, we cannot directly
	  use the operators <PYTHONINLINE>+</PYTHONINLINE> and
	  <PYTHONINLINE>-</PYTHONINLINE> as in Scheme, and instead we
	  must use the names <PYTHONINLINE>plus</PYTHONINLINE> and
	  <PYTHONINLINE>minus</PYTHONINLINE> because in infix notation,
	  only operator symbols are allowed in the middle, not compound
	  expressions.
	</COMMENT>
	<SOLUTION>
	  According to section<SPACE/><REF NAME="sec:substitution-model"/>, evaluation
	  of an application proceeds as follows:
	  <OL>
	    <LI>Evaluate the subexpressions of the application.
	    </LI>
            <LI>Evaluate the return expression of the result of
	    the function expression with each
	    parameter replaced by the corresponding result of the respective
	    argument expression.
            </LI>
	  </OL>
	  Thus the evaluation of the application 
	  <PYTHONINLINE>a_plus_abs_b(5, -4)</PYTHONINLINE>
	  (1) evaluates <PYTHONINLINE>a_plus_abs_b</PYTHONINLINE>,
	  resulting in the function given above, and the arguments are
	  already values. So we need to evaluate (2) the return expression
	  of the function, with the parameters replaced by the arguments, thus:
	  <PYTHONINLINE>(-4 >= 0 ? plus : minus)(5, -4)</PYTHONINLINE>.
	  With the same rules, we need to (1) evaluate the function expression,
	  which in this case is the conditional expression
	  <PYTHONINLINE>-4 >= 0 ? plus : minus</PYTHONINLINE>. Since
	  the predicate evaluates to false, the function expression
	  evaluates to <PYTHONINLINE>minus</PYTHONINLINE>. The arguments,
	  again (1) are already values. Thus we end up evaluating (2) the body of
	  <PYTHONINLINE>minus</PYTHONINLINE> with the parameters
	  <PYTHONINLINE>a</PYTHONINLINE> and
	  <PYTHONINLINE>b</PYTHONINLINE> replaced by 5 and -4,
	  respectively, resulting in
	  <PYTHONINLINE>5 - (-4)</PYTHONINLINE>, which will finally
	  evaluate to 9.
	</SOLUTION>
      </PYTHON>
    </SPLIT>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:normal-order-vs-appl-order-test"/>
    Ben Bitdiddle has invented a test to determine whether the interpreter
    he is faced with is using
    <INDEX>normal-order evaluation<SUBINDEX>applicative order vs.</SUBINDEX></INDEX>
    <INDEX>applicative-order evaluation<SUBINDEX>normal order vs.</SUBINDEX></INDEX>
    applicative-order evaluation or normal-order
    evaluation. He 
    <SPLITINLINE>
      <SCHEME>
	defines the following two procedures:
      </SCHEME>
      <PYTHON>
	declares the following two functions:
      </PYTHON>
      </SPLITINLINE>
      <SNIPPET>
	<NAME>ptest</NAME>
	<SCHEME>
(define (p) (p))

(define (test x y)
  (if (= x 0)
    0
    y))
	</SCHEME>
	<PYTHON>
function p() { return p(); }

function test(x, y) {
    return x === 0 ? 0 : y;
}
	</PYTHON>
      </SNIPPET>
      <START_KEEP_TOGETHER/><NOINDENT/>
      Then he evaluates the
      <SPLITINLINE>
	<SCHEME>expression</SCHEME>
	<PYTHON>statement</PYTHON>
      </SPLITINLINE>
      <SNIPPET>
	<REQUIRES>ptest</REQUIRES>
	<SCHEME>
(test 0 (p))
	</SCHEME>
	<PYTHON>
test(0, p());
	</PYTHON>
      </SNIPPET>
      <STOP_KEEP_TOGETHER/>
      What behavior will Ben observe with an interpreter that uses
      applicative-order evaluation?  What behavior will he observe with an
      interpreter that uses normal-order evaluation?  Explain your answer.
      <INDEX>normal-order evaluation<SUBINDEX><ORDER>conditional</ORDER>of conditional expressions</SUBINDEX></INDEX>
      <INDEX>conditional expression<SUBINDEX>normal-order evaluation of</SUBINDEX></INDEX>
      (Assume that the evaluation rule for 
      <SPLITINLINE>
	<SCHEME>
          the special form <SCHEMEINLINE>if</SCHEMEINLINE> 
	</SCHEME>
	<PYTHON>
          conditional expressions
	</PYTHON>
      </SPLITINLINE>
      is the same whether the interpreter is using normal or applicative order:
      The predicate expression is evaluated first, and the result determines
      whether to evaluate the consequent or the alternative expression.)
      <SOLUTION>		
	<SPLIT>
	  <PYTHON>
	    In applicative-order evaluation of
	    <PYTHONINLINE>test(0, p())</PYTHONINLINE>,
	    we need to evaluate the argument expressions before we can evaluate
	    the return expression of the function
	    <PYTHONINLINE>test</PYTHONINLINE>.
	    The evaluation of the argument expression
	    <PYTHONINLINE>p()</PYTHONINLINE>
	    will not terminate, however: It will keep evaluating application
	    expressions of the form 
	    <PYTHONINLINE>p()</PYTHONINLINE>, and thus the evaluation of
            <PYTHONINLINE>test(0, p())</PYTHONINLINE> will not produce a
	    legitimate value. In normal-order evaluation, on the other hand,
	    the function application
	    <PYTHONINLINE>test(0, p())</PYTHONINLINE>
	    would immediately evaluate the return expression of the function
	    <PYTHONINLINE>test</PYTHONINLINE>,
	    <PYTHONINLINE>x === 0 ? 0 : y</PYTHONINLINE>
	    after replacing the parameter
	    <PYTHONINLINE>x</PYTHONINLINE> with
	    <PYTHONINLINE>0</PYTHONINLINE> and
	    <PYTHONINLINE>y</PYTHONINLINE> with
	    <PYTHONINLINE>p()</PYTHONINLINE>.
	    The result of the replacing would be
	    <PYTHONINLINE>0 === 0 ? 0 : p()</PYTHONINLINE>.
	    The evaluation of the predicate
	    <PYTHONINLINE>0 === 0</PYTHONINLINE>
	    results in true and thus the conditional
	    expression evaluates to 0, without any need to
	    evaluate <PYTHONINLINE>p()</PYTHONINLINE>.
	  </PYTHON>
	</SPLIT>
      </SOLUTION>
  </EXERCISE>
</SUBSECTION>
