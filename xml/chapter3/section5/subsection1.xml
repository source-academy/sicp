<SUBSECTION>
  <NAME>
    Streams Are Delayed Lists
  </NAME>

  <LABEL NAME="sec:delayed-lists"/>

  <INDEX>stream(s)<SUBINDEX>implemented as delayed lists<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    As we saw in
    section<SPACE/><REF NAME="sec:sequences-conventional-interfaces"/>,
    sequences can serve as standard interfaces for combining program
    modules.  We formulated powerful abstractions for manipulating
    sequences, such as <SCHEMEINLINE>map</SCHEMEINLINE>,
    <SCHEMEINLINE>filter</SCHEMEINLINE>, and
    <SCHEMEINLINE>accumulate</SCHEMEINLINE>, that capture a wide variety of
    operations in a manner that is both succinct and elegant.
  </TEXT>

  <TEXT>
    Unfortunately, if we represent sequences as lists, this elegance is
    bought at the price of severe inefficiency with respect to both the
    time and space required by our computations.
    When we represent manipulations on sequences as transformations
    of lists, our programs must construct and copy data structures (which
    may be huge) at every step of a process.
  </TEXT>

  <TEXT>
    To see why this is true, let us compare two programs for computing the
    sum of all the prime numbers in an interval.  The first program is
    written in standard iterative style:<FOOTNOTE>Assume that we have a
    predicate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>prime?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_prime</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    (e.g., as in section<SPACE/><REF NAME="sec:primality"/>) that
    tests for primality.</FOOTNOTE>
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>sum_primes</DECLARATION></INDEX> 
      <REQUIRES>prime_definition</REQUIRES>
      <NAME>sum_primes1</NAME>
      <EXAMPLE>sum_primes1_example</EXAMPLE>
      <EXPECTED>3437</EXPECTED>
      <SCHEME>
(define (sum-primes a b)
  (define (iter count accum)
    (cond ((&gt; count b) accum)
          ((prime? count) (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
      </SCHEME>
      <JAVASCRIPT>
function sum_primes(a, b) {
    function iter(count, accum) {
        return count &gt; b
               ? accum
               : is_prime(count)
               ? iter(count + 1, count + accum)
               : iter(count + 1, accum);
    }
    return iter(a, 0);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="yes" HIDE="yes">
      <NAME>sum_primes1_example</NAME>
      <JAVASCRIPT>
sum_primes(7, 182);    
      </JAVASCRIPT>
    </SNIPPET>
    The second program performs the same computation using the sequence
    operations of
    section<SPACE/><REF NAME="sec:sequences-conventional-interfaces"/>:
    <SNIPPET EVAL="yes">
      <INDEX><DECLARATION>sum_primes</DECLARATION></INDEX> 
      <NAME>sum_primes2</NAME>
      <REQUIRES>prime_definition</REQUIRES>
      <REQUIRES>enumerate_interval</REQUIRES>
      <EXAMPLE>sum_primes1_example</EXAMPLE>
      <EXPECTED>3437</EXPECTED>
      <SCHEME>
(define (sum-primes a b)
  (accumulate +
              0
              (filter prime? (enumerate-interval a b))))
      </SCHEME>
      <JAVASCRIPT>
function sum_primes(a, b) {
    return accumulate((x, y) => x + y,
                      0,
                      filter(is_prime, 
                             enumerate_interval(a, b)));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    In carrying out the computation, the first program needs to store only
    the sum being accumulated.  In contrast, the filter in the second
    program cannot do any testing until 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>enumerate-interval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>enumerate_interval</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    has constructed a complete list of the numbers in the interval.
    The filter generates another list, which in turn is passed to 
    <SCHEMEINLINE>accumulate</SCHEMEINLINE> before being collapsed to form
    a sum.  Such large intermediate storage is not needed by the first program,
    which we can think of as enumerating the interval incrementally, adding
    each prime to the sum as it is generated.
  </TEXT>

  <TEXT>
    The inefficiency in using lists becomes painfully apparent if we use
    the sequence paradigm to compute the second prime in the interval from
    10,000 to 1,000,000 by evaluating the expression
    <SNIPPET EVAL="no">
      <NAME>painfully</NAME>
      <REQUIRES>prime_definition</REQUIRES>
      <REQUIRES>enumerate_interval</REQUIRES>
      <SCHEME>
(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
      </SCHEME>
      <JAVASCRIPT>
head(tail(filter(is_prime,
                 enumerate_interval(10000, 1000000))));
      </JAVASCRIPT>
    </SNIPPET>
    This expression does find the second prime, but the computational overhead
    is outrageous. We construct a list of almost a million integers, filter
    this list by testing each element for primality, and then ignore almost
    all of the result.  In a more traditional programming style, we would
    interleave the enumeration and the filtering, and stop when we reached
    the second prime.
  </TEXT>

  <TEXT>
    Streams are a clever idea that allows one to use sequence
    manipulations without incurring the costs of manipulating sequences as
    lists.  With streams we can achieve the best of both worlds: We can
    formulate programs elegantly as sequence manipulations, while attaining
    the efficiency of incremental computation.  The basic idea is to arrange
    to construct a stream only partially, and to pass the partial
    construction to the program that consumes the stream.  If the consumer
    attempts to access a part of the stream that has not yet been
    constructed, the stream will automatically construct just enough more
    of itself to produce the required part, thus preserving the illusion
    that the entire stream exists.  In other words, although we will write
    programs as if we were processing complete sequences, we design our
    stream implementation to automatically and transparently interleave
    the construction of the stream with its use.
  </TEXT>

  <COMMENT>
    The special form <SCHEMEINLINE>delay</SCHEMEINLINE> allowed the authors
    of the original version to (1) hide the lambda being constructed, and (2)
    elegantly sneak in the memoization optimization. There are no special forms
    in JavaScript, so the lambda expression in the tail of a stream must be
    explicit. This is not much
    of a loss; streams are somewhat demystified with explicit lambda expressions.
    We decided to <EM>not</EM> use memoization as default, in order to keep
    stream tails in their bare lambda expression simplicity. We mention
    memoization at the end of this section as an optional optimization, and
    refer to this variant in a few exercises in the following sections.
  </COMMENT>
  
  <SPLIT>
    <SCHEME>
      <TEXT>
        On the surface, streams are just lists with different names for the
	procedures that manipulate them.  There is a constructor,
        <INDEX>cons-stream</INDEX>
        <SCHEMEINLINE>cons-stream</SCHEMEINLINE>, and two selectors, 
        <INDEX><USE>stream-car</USE></INDEX> 
        <SCHEMEINLINE>stream-car</SCHEMEINLINE> and 
        <INDEX><USE>stream-cdr</USE></INDEX> 
        <SCHEMEINLINE>stream-cdr</SCHEMEINLINE>, which satisfy the constraints
        \begin{eqnarray*}
        \mbox{(stream-car (cons-stream x y))} &amp;=&amp; \mbox{x} \\
        \mbox{(stream-cdr (cons-stream x y))} &amp;=&amp; \mbox{y}
        \end{eqnarray*}
        There is a distinguishable object, 
        <INDEX>empty stream</INDEX>
	<INDEX>stream(s)<SUBINDEX>empty</SUBINDEX></INDEX>
        <INDEX><USE>the-empty-stream</USE></INDEX> 
        <SCHEMEINLINE>the-empty-stream</SCHEMEINLINE>, which
        cannot be the result of any <SCHEMEINLINE>cons-stream</SCHEMEINLINE>
	operation, and which can be identified with the predicate 
        <INDEX><USE>stream-null?</USE></INDEX> 
        <SCHEMEINLINE>stream-null?</SCHEMEINLINE>.<FOOTNOTE>In the MIT
	implementation, 
        <INDEX><USE>the-empty-stream</USE><SUBINDEX>in MIT Scheme</SUBINDEX></INDEX>
        <INDEX><USE>stream-null?</USE><SUBINDEX>in MIT Scheme</SUBINDEX></INDEX>
        <INDEX>MIT Scheme<SUBINDEX><ORDER>empty</ORDER>the empty stream</SUBINDEX></INDEX>
        <SCHEMEINLINE>the-empty-stream</SCHEMEINLINE> is the
        same as the empty list <SCHEMEINLINE>'()</SCHEMEINLINE>, and
	<SCHEMEINLINE>stream-null?</SCHEMEINLINE> is the same
        as <SCHEMEINLINE>null?</SCHEMEINLINE>.</FOOTNOTE>
      </TEXT>

      <TEXT>
        Thus we can make and use streams, in just the same way as we can make
        and use lists, to represent aggregate data arranged in a sequence.  In
        particular, we can build stream analogs of the list operations from
        chapter<SPACE/>2, such as <SCHEMEINLINE>list-ref</SCHEMEINLINE>,
	<SCHEMEINLINE>map</SCHEMEINLINE>, and
	<SCHEMEINLINE>for-each</SCHEMEINLINE>:<FOOTNOTE>This should bother you.
	The fact that we are defining such similar procedures
        for streams and lists indicates that we are missing some
        underlying abstraction.  Unfortunately, in order to exploit this
        abstraction, we will need to exert finer control over the process of
        evaluation than we can at present.  We will discuss this point further
        at the end of
	section<SPACE/><REF NAME="sec:streams-and-delayed-evaluation"/>.
        In section<SPACE/><REF NAME="sec:lazy-evaluation"/>, we<APOS/>ll
	develop a framework that unifies lists and streams.</FOOTNOTE>
        <SNIPPET EVAL="no"> 
          <INDEX><DECLARATION>stream-ref</DECLARATION></INDEX> 
          <INDEX><DECLARATION>stream-map</DECLARATION></INDEX> 
          <INDEX><DECLARATION>stream-for-each</DECLARATION></INDEX> 
          <SCHEME>
(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Stream-for-each</SCHEMEINLINE> is useful for viewing
	streams:
        <SNIPPET>
          <INDEX><DECLARATION>display-stream</DECLARATION></INDEX> 
          <INDEX><DECLARATION>display-line</DECLARATION></INDEX> 
          <SCHEME>
(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        To make the stream implementation automatically and transparently
        interleave the construction of a stream with its use, we will arrange
        for the <SCHEMEINLINE>cdr</SCHEMEINLINE> of a stream to be evaluated
	when it is accessed by the <SCHEMEINLINE>stream-cdr</SCHEMEINLINE>
	procedure rather than when the stream is constructed by
	<SCHEMEINLINE>cons-stream</SCHEMEINLINE>.  This implementation choice
	is reminiscent of our discussion of rational numbers in
        section<SPACE/><REF NAME="sec:abstraction-barriers"/>, where we saw
	that we can choose to implement rational numbers so that the reduction
	of numerator and denominator to lowest terms is performed either at
        construction time or at selection time.  The two rational-number
        implementations produce the same data abstraction, but the choice has
        an effect on efficiency.  There is a similar relationship between
        streams and ordinary lists.  As a data abstraction, streams are the
        same as lists.  The difference is the time at which the elements are
        evaluated.  With ordinary lists, both the
	<SCHEMEINLINE>car</SCHEMEINLINE> and the <SCHEMEINLINE>cdr</SCHEMEINLINE>
        are evaluated at construction time.  With streams, the
	<SCHEMEINLINE>cdr</SCHEMEINLINE> is evaluated at selection time.
      </TEXT>

      <TEXT>
        Our implementation of streams will be based on a special form called
        <INDEX>delay</INDEX>
	<INDEX>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)<SUBINDEX>delay</SUBINDEX></INDEX>
        <SCHEMEINLINE>delay</SCHEMEINLINE>.  Evaluating
	<SCHEMEINLINE>(delay ^exp^)</SCHEMEINLINE>
	does not evaluate the expression <LATEXINLINE>exp</LATEXINLINE>, but
	rather returns a so-called
        <INDEX>delayed object</INDEX>
        <EM>delayed object</EM>, which we can think of as a
	<QUOTE>promise</QUOTE> to evaluate <LATEXINLINE>exp</LATEXINLINE> at
	some future time. As a companion to <SCHEMEINLINE>delay</SCHEMEINLINE>,
	there is a procedure called 
        <INDEX><USE>force</USE></INDEX> 
        <SCHEMEINLINE>force</SCHEMEINLINE> that takes a delayed object as
        argument and performs the evaluation<EMDASH/>in effect, forcing the
        <SCHEMEINLINE>delay</SCHEMEINLINE> to fulfill its promise.  We will see
	below how <SCHEMEINLINE>delay</SCHEMEINLINE> and
	<SCHEMEINLINE>force</SCHEMEINLINE> can be implemented, but first let us
	use these to construct streams.
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Cons-stream</SCHEMEINLINE>
        <INDEX>special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)<SUBINDEX>cons-stream</SUBINDEX></INDEX>
        <INDEX>cons-stream</INDEX>
	is a special form defined so that
        <SNIPPET EVAL="no">
          <SCHEME>
(cons-stream ^a^ ^b^)
          </SCHEME>
        </SNIPPET>
        is equivalent to
        <SNIPPET EVAL="no">
          <SCHEME>
(cons ^a^ (delay ^b^))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        What this means is that we will construct streams using pairs.  However,
        rather than placing the value of the rest of the stream
        into the <SCHEMEINLINE>cdr</SCHEMEINLINE> of the
        pair we will put there a promise to compute the rest if it is ever
        requested.  <SCHEMEINLINE>Stream-car</SCHEMEINLINE> and
	<SCHEMEINLINE>stream-cdr</SCHEMEINLINE> can now be defined as procedures:
        <SNIPPET>
          <INDEX><DECLARATION>stream-car</DECLARATION></INDEX> 
          <INDEX><DECLARATION>stream-cdr</DECLARATION></INDEX> 
          <SCHEME>
(define (stream-car stream) (car stream))

(define (stream-cdr stream) (force (cdr stream)))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Stream-car</SCHEMEINLINE> selects the
	<SCHEMEINLINE>car</SCHEMEINLINE> of the pair;
	<SCHEMEINLINE>stream-cdr</SCHEMEINLINE> selects the
	<SCHEMEINLINE>cdr</SCHEMEINLINE> of the pair and evaluates the delayed
	expression found there to obtain the rest of the
	stream.<FOOTNOTE>Although <SCHEMEINLINE>stream-car</SCHEMEINLINE> and
         <INDEX>cons-stream<SUBINDEX>why a special form</SUBINDEX></INDEX>
         <INDEX>delay<SUBINDEX>why a special form</SUBINDEX></INDEX>
        <SCHEMEINLINE>stream-cdr</SCHEMEINLINE> can be defined as procedures,
	<SCHEMEINLINE>cons-stream</SCHEMEINLINE> must be a special form.  If
	<SCHEMEINLINE>cons-stream</SCHEMEINLINE> were a procedure, then,
        according to our model of evaluation, evaluating
	<SCHEMEINLINE>(cons-stream ^a^ ^b^)</SCHEMEINLINE>
	would automatically cause <LATEXINLINE>b</LATEXINLINE> to be
	evaluated, which is precisely what we do not want to happen.  For the
	same reason, <SCHEMEINLINE>delay</SCHEMEINLINE> must be a special form,
	though <SCHEMEINLINE>force</SCHEMEINLINE> can be an ordinary
	procedure.</FOOTNOTE>
        <INDEX>stream(s)<SUBINDEX>implemented as delayed lists<CLOSE/></SUBINDEX></INDEX>
      </TEXT>

      <SUBHEADING> 
        <NAME>The stream implementation in action</NAME>
      </SUBHEADING>

      <TEXT>
        To see how this implementation behaves, let us analyze the
        <QUOTE>outrageous</QUOTE> prime computation we saw above, reformulated
	in terms of streams:
        <SNIPPET>
          <SCHEME>
(stream-car
 (stream-cdr
  (stream-filter prime?
                 (stream-enumerate-interval 10000 1000000))))
          </SCHEME>
        </SNIPPET>
        We will see that it does indeed work efficiently.
      </TEXT>

      <TEXT>
        We begin by calling
	<SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE> with the
	arguments 10,000 and 1,000,000.
	<SCHEMEINLINE>Stream-enumerate-interval</SCHEMEINLINE> is the stream
	analog of <SCHEMEINLINE>enumerate-interval</SCHEMEINLINE>
        (section<SPACE/><REF NAME="sec:sequence-operations"/>):
        <SNIPPET>
          <INDEX><DECLARATION>stream-enumerate-interval</DECLARATION></INDEX> 
          <SCHEME>
(define (stream-enumerate-interval low high)
  (if (&gt; low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
          </SCHEME>
        </SNIPPET>
        and thus the result returned by
	<SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE>, formed by the
	<SCHEMEINLINE>cons-stream</SCHEMEINLINE>, is<FOOTNOTE>The numbers shown
	here do not really appear in the delayed expression.  What actually
	appears is the original expression, in an environment in which the
	variables are bound to the appropriate numbers.  For example,
	<SCHEMEINLINE>(+ low 1)</SCHEMEINLINE> with
        <SCHEMEINLINE>low</SCHEMEINLINE> bound to 10,000 actually appears where
	<SCHEMEINLINE>10001</SCHEMEINLINE> is shown.</FOOTNOTE>
        <SNIPPET>
          <SCHEME>
(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
          </SCHEME>
        </SNIPPET>
        That is, <SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE> returns
	a stream represented as a pair whose <SCHEMEINLINE>car</SCHEMEINLINE>
        is 10,000 and whose <SCHEMEINLINE>cdr</SCHEMEINLINE> is a promise to
	enumerate more of the interval if so requested.  This stream is now
	filtered for primes, using the stream analog of the
	<SCHEMEINLINE>filter</SCHEMEINLINE> procedure
        (section<SPACE/><REF NAME="sec:sequence-operations"/>):
        <SNIPPET>
          <INDEX><DECLARATION>stream-filter</DECLARATION></INDEX> 
          <SCHEME>
(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
          </SCHEME>
        </SNIPPET>
        <SCHEMEINLINE>Stream-filter</SCHEMEINLINE> tests the
	<SCHEMEINLINE>stream-car</SCHEMEINLINE> of the stream (the
	<SCHEMEINLINE>car</SCHEMEINLINE> of the pair, which is 10,000).
	Since this is not prime,
        <SCHEMEINLINE>stream-filter</SCHEMEINLINE> examines the
	<SCHEMEINLINE>stream-cdr</SCHEMEINLINE> of its input
        stream.  The call to <SCHEMEINLINE>stream-cdr</SCHEMEINLINE> forces
	evaluation of the delayed
	<SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE>, which now returns
        <SNIPPET>
          <SCHEME>
(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
          </SCHEME>
        </SNIPPET>
        <SCHEMEINLINE>Stream-filter</SCHEMEINLINE> now looks at the
	<SCHEMEINLINE>stream-car</SCHEMEINLINE> of this stream,
        10,001, sees that this is not prime either, forces another
	<SCHEMEINLINE>stream-cdr</SCHEMEINLINE>, and so on, until
	<SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE> yields
        the prime 10,007, whereupon <SCHEMEINLINE>stream-filter</SCHEMEINLINE>,
	according to its definition, returns
        <SNIPPET>
          <SCHEME>
(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
          </SCHEME>
        </SNIPPET>
        which in this case is
        <SNIPPET>
          <SCHEME>
(cons 10007
      (delay
       (stream-filter
        prime?
        (cons 10008
              (delay
               (stream-enumerate-interval 10009
                                          1000000))))))
          </SCHEME>
        </SNIPPET>
        This result is now passed to <SCHEMEINLINE>stream-cdr</SCHEMEINLINE> in
	our original expression.  This forces the delayed
	<SCHEMEINLINE>stream-filter</SCHEMEINLINE>, which in turn keeps forcing
	the delayed <SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE> until
	it finds the next prime, which is 10,009.  Finally, the result passed to
	<SCHEMEINLINE>stream-car</SCHEMEINLINE>	in our original expression is
        <SNIPPET>
          <SCHEME>
(cons 10009
      (delay
       (stream-filter
        prime?
        (cons 10010
              (delay
               (stream-enumerate-interval 10011
                                          1000000))))))
          </SCHEME>
        </SNIPPET>
        <SCHEMEINLINE>Stream-car</SCHEMEINLINE> returns 10,009, and the
	computation is complete. Only as many integers were tested for primality
	as were necessary to find the second prime, and the interval was
	enumerated only as far as was necessary to feed the prime filter.
      </TEXT>

      <TEXT>
        In general, we can think of delayed evaluation as 
        <INDEX>programming<SUBINDEX>demand-driven</SUBINDEX></INDEX>
        <QUOTE>demand-driven</QUOTE>
        programming, whereby each stage in the stream process is activated
        only enough to satisfy the next stage.  What we have done is to
        <INDEX>order of events<SUBINDEX>decoupling apparent from actual</SUBINDEX></INDEX>
        decouple the actual order of events in the computation from the apparent
	structure of our procedures. We write procedures as if the streams
	existed <QUOTE>all at once</QUOTE> when, in reality, the computation is
        performed incrementally, as in traditional programming styles.
      </TEXT>

      <SUBHEADING> 
        <NAME>Implementing <SCHEMEINLINE>delay</SCHEMEINLINE> and
	<SCHEMEINLINE>force</SCHEMEINLINE></NAME>
      </SUBHEADING>

      <TEXT>
        Although
        <INDEX>delay<SUBINDEX>implementation using lambda</SUBINDEX></INDEX>
	<SCHEMEINLINE>delay</SCHEMEINLINE> and
	<SCHEMEINLINE>force</SCHEMEINLINE> may seem like mysterious operations,
	their implementation is really quite straightforward.
        <SCHEMEINLINE>Delay</SCHEMEINLINE> must package an expression so that it
	can be evaluated later on demand, and we can accomplish this simply by
	treating the expression as the body of a procedure.
	<SCHEMEINLINE>Delay</SCHEMEINLINE> can be a special form such that
        <SNIPPET EVAL="no">
          <SCHEME>
(delay ^exp^)
          </SCHEME>
        </SNIPPET>
        is syntactic sugar for
        <SNIPPET EVAL="no">
          <SCHEME>
(lambda () ^exp^)
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Force</SCHEMEINLINE> simply calls the procedure
        (of no arguments) produced by <SCHEMEINLINE>delay</SCHEMEINLINE>,
	so we can implement <SCHEMEINLINE>force</SCHEMEINLINE> as
        a procedure:
        <SNIPPET>
          <INDEX><DECLARATION>force</DECLARATION></INDEX> 
          <SCHEME>
(define (force delayed-object)
  (delayed-object))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        This implementation suffices for <SCHEMEINLINE>delay</SCHEMEINLINE> and
	<SCHEMEINLINE>force</SCHEMEINLINE> to work as advertised, but there is
	an important optimization that we can include.  In many applications, we
	end up forcing the same delayed object many times.  This can lead to
	serious inefficiency in recursive programs involving streams.  (See
        exercise<SPACE/><REF NAME="ex:fib-stream-efficiency"/>.)  The solution
	is to build delayed objects so that the first time they are forced, they
	store the value that is computed.  Subsequent forcings will simply
	return the stored value without repeating the computation.  In other
	words, we implement <SCHEMEINLINE>delay</SCHEMEINLINE> as a
	special-purpose
        <INDEX>delay<SUBINDEX>memoized</SUBINDEX></INDEX>
        <INDEX>memoization<SUBINDEX><ORDER>delay</ORDER>by <SCHEMEINLINE>delay</SCHEMEINLINE></SUBINDEX></INDEX>
	memoized procedure similar to the one described in
	exercise<SPACE/><REF NAME="ex:memoization"/>. One way to accomplish this
	is to use the following procedure, which takes as argument a procedure
        (of no arguments) and returns a memoized version of the procedure. The
	first time the memoized procedure is run, it saves the computed result.
	On subsequent evaluations, it simply returns the result.
        <SNIPPET>
          <INDEX><DECLARATION>memo-proc</DECLARATION></INDEX> 
          <SCHEME>
(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
            (set! already-run? true)
            result)
          result))))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Delay</SCHEMEINLINE> is then defined so that
	<SCHEMEINLINE>(delay ^exp^)</SCHEMEINLINE> is equivalent to
        <SNIPPET EVAL="no">
          <SCHEME>
(memo-proc (lambda () ^exp^))
          </SCHEME>
        </SNIPPET>
        and <SCHEMEINLINE>force</SCHEMEINLINE> is as defined
	previously.<FOOTNOTE>There are many possible implementations of streams
	other than the one described in this section.  Delayed evaluation, which
	is the key to making streams practical, was inherent in 
        <INDEX>Algol<SUBINDEX>call-by-name argument passing</SUBINDEX></INDEX>
        <INDEX>call-by-name argument passing</INDEX>
        Algol 60<APOS/>s <EM>call-by-name</EM> parameter-passing method.  The
	use of this mechanism to implement streams was first described by 
        <INDEX>Landin, Peter</INDEX>
        Landin (1965). Delayed evaluation for streams was introduced into Lisp by
        <INDEX>Friedman, Daniel P.</INDEX>
        <INDEX>Wise, David S.</INDEX>
        Friedman and Wise (1976). In their implementation,
	<SCHEMEINLINE>cons</SCHEMEINLINE>
	always delays evaluating its
	arguments, so that lists automatically behave as streams.  The
	memoizing optimization is also known as 
        <INDEX>call-by-need argument passing</INDEX>
        <INDEX>thunk<SUBINDEX>call-by-name</SUBINDEX></INDEX>
        <INDEX>thunk<SUBINDEX>call-by-need</SUBINDEX></INDEX>
        <INDEX>Algol<SUBINDEX>thunks</SUBINDEX></INDEX>
        <EM>call-by-need</EM>.  The Algol community would refer to our original
	delayed objects as <EM>call-by-name thunks</EM> and to the optimized
	versions as <EM>call-by-need thunks</EM>.</FOOTNOTE>
      </TEXT>

      <EXERCISE>
	<LABEL NAME="ex:general-stream-map"/>
	Complete the following definition, which
	generalizes <SCHEMEINLINE>stream-map</SCHEMEINLINE> to allow procedures
	that take multiple arguments, analogous to
	<SCHEMEINLINE>map</SCHEMEINLINE> in
	section<SPACE/><REF NAME="sec:sequence-operations"/>,
	footnote<SPACE/><REF NAME="foot:generalmap"/>.
	<SNIPPET EVAL="no">
          <INDEX><USE>stream-map</USE><SUBINDEX>with multiple arguments</SUBINDEX></INDEX>
          <SCHEME>
(define (stream-map proc . argstreams)
  (if (^??^ (car argstreams))
      the-empty-stream
      (^??^
       (apply proc (map ^??^ argstreams))
       (apply stream-map
              (cons proc (map ^??^ argstreams))))))
          </SCHEME>
	</SNIPPET>
      </EXERCISE>
      
      <EXERCISE>
	<LABEL NAME="ex:delayed1_scheme"/>
	In order to take a closer look at
	<INDEX>delayed evaluation<SUBINDEX>printing and</SUBINDEX></INDEX>
	delayed evaluation, we will use the
	following procedure, which simply returns its argument after printing it:
	<SNIPPET>
          <SCHEME>
(define (show x)
  (display-line x)
  x)
          </SCHEME>
	</SNIPPET>
	What does the interpreter print in response to evaluating each
	expression in the following sequence?<FOOTNOTE>Exercises such
	as<SPACE/><REF NAME="ex:delayed1_scheme"/>
	and<SPACE/><REF NAME="ex:delayed2_scheme"/>
	are valuable for testing our understanding of how
	<SCHEMEINLINE>delay</SCHEMEINLINE> works. On the other hand, intermixing
	delayed evaluation with printing<EMDASH/>and, even worse, with
	assignment<EMDASH/>is extremely confusing, and instructors of courses
	on computer languages have traditionally tormented their students with
	examination questions such as the ones in this section.	Needless to say,
	writing programs that depend on such subtleties is
	<INDEX>programming<SUBINDEX>odious style</SUBINDEX></INDEX>
	odious programming style.  Part of the power of stream processing is
	that it lets us ignore the order in which events actually happen in
	our programs.  Unfortunately, this is precisely what we cannot afford
	to do in the presence of assignment, which forces us to be concerned
	with time and change.</FOOTNOTE>
	<SNIPPET>
          <SCHEME>
(define x (stream-map show (stream-enumerate-interval 0 10)))

(stream-ref x 5)

(stream-ref x 7)
          </SCHEME>
	</SNIPPET>
      </EXERCISE>

      <EXERCISE>
        Consider the sequence of expressions
        <SNIPPET>
          <SCHEME>
(define sum 0)

(define (accum x)
  (set! sum (+ x sum))
  sum)

(define seq (stream-map accum (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))

(stream-ref y 7)

(display-stream z)
          </SCHEME>
        </SNIPPET>
        What is the value of <SCHEMEINLINE>sum</SCHEMEINLINE> after each of the
	above expressions is evaluated?
        <INDEX>delayed evaluation<SUBINDEX>assignment and</SUBINDEX></INDEX>
	What is the printed response to
	evaluating the <SCHEMEINLINE>stream-ref</SCHEMEINLINE> and
	<SCHEMEINLINE>display-stream</SCHEMEINLINE> expressions?  Would these
	responses differ if we had implemented
	<SCHEMEINLINE>(delay<SPACE/>^exp^)</SCHEMEINLINE> simply as
        <SCHEMEINLINE>(lambda () ^exp^)</SCHEMEINLINE> without using the
	optimization provided by
        <SCHEMEINLINE>memo\?proc</SCHEMEINLINE><LATEXINLINE>$\,$</LATEXINLINE>?
	Explain.
        <LABEL NAME="ex:delayed2_scheme"/>
      </EXERCISE>
    </SCHEME>

    <JAVASCRIPT>
      <TEXT>
	In their most basic form, streams are similar to lists. The
	<INDEX>empty stream</INDEX>
	<INDEX>stream(s)<SUBINDEX>empty</SUBINDEX></INDEX>
	empty stream
	is <JAVASCRIPTINLINE>null</JAVASCRIPTINLINE>, a non-empty stream is a
	pair, and the <JAVASCRIPTINLINE>head</JAVASCRIPTINLINE> of the pair is a
	data item. However, the <JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE> of a
	pair that represents a non-empty stream is not a stream, but a
	<EM>function of no arguments that returns a stream</EM>. The stream
	returned by the function, we call <EM>the tail of the stream</EM>.
	<INDEX>delayed expression<SUBINDEX>implementation using lambda expression</SUBINDEX></INDEX>
	If we
	have a data item <JAVASCRIPTINLINE>x</JAVASCRIPTINLINE> and a stream
	<JAVASCRIPTINLINE>s</JAVASCRIPTINLINE>, we can construct a stream whose
	head is <JAVASCRIPTINLINE>x</JAVASCRIPTINLINE> and whose tail is
	<JAVASCRIPTINLINE>s</JAVASCRIPTINLINE> by evaluating
	<JAVASCRIPTINLINE>pair(x, () => s)</JAVASCRIPTINLINE>.
      </TEXT>

      <TEXT>
	In order to access the first data item of a non-empty stream, we just use
	<JAVASCRIPTINLINE>head</JAVASCRIPTINLINE> as with lists. In order
	to access the tail of a stream
	<JAVASCRIPTINLINE>s</JAVASCRIPTINLINE>, we need to <EM>apply</EM> 
	<JAVASCRIPTINLINE>tail(s)</JAVASCRIPTINLINE>, i.e. evaluate
	<JAVASCRIPTINLINE>tail(s)()</JAVASCRIPTINLINE>. For convenience, we
	therefore define
        <SNIPPET EVAL="yes" CHAP="2">
          <INDEX><DECLARATION>stream_tail</DECLARATION></INDEX> 
          <NAME>stream_tail</NAME>
	  <EXAMPLE>stream_tail_example</EXAMPLE>
	  <EXPECTED>5</EXPECTED>
          <JAVASCRIPT>
function stream_tail(stream) {
    return tail(stream)();
}
	  </JAVASCRIPT>
	</SNIPPET>
        <SNIPPET EVAL="yes" HIDE="yes">
          <NAME>stream_tail_example</NAME>
          <JAVASCRIPT>
stream_tail(pair(4, () => pair(5, () => null)));	    
	  </JAVASCRIPT>
          <JAVASCRIPT_TEST>
head(stream_tail(pair(4, () => pair(5, () => null))));
	  </JAVASCRIPT_TEST>
	</SNIPPET>
	The tail of a stream is <QUOTE>wrapped</QUOTE> in a function. It is a
        <INDEX>delayed expression</INDEX>
	<EM>delayed expression</EM>, a
        <INDEX>promise</INDEX>
	<QUOTE>promise</QUOTE> to evaluate an
	expression at some future time.
	Correspondingly, <JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE>
	<INDEX>forcing<SUBINDEX>tail of stream</SUBINDEX></INDEX>
	<EM>forces</EM>
	the tail to fulfill its promise.  It selects the
	<JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE> of the pair and evaluates the
	delayed expression found there to obtain the next pair of the stream.
        <INDEX>stream(s)<SUBINDEX>implemented as delayed lists<CLOSE/></SUBINDEX></INDEX>
      </TEXT>

      <TEXT>
        We can make and use streams, in just the same way as we can make
        and use lists, to represent aggregate data arranged in a sequence.  In
        particular, we can build stream analogs of the list operations from
        chapter<SPACE/>2, such as  <JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE>,
	<SCHEMEINLINE>map</SCHEMEINLINE>, and
	<JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE>:<FOOTNOTE>This should
	bother you. The fact that we are defining such similar functions
        for streams and lists indicates that we are missing some underlying
	abstraction.  Unfortunately, in order to exploit this abstraction, we
	will need to exert finer control over the process of evaluation than we
	can at present.  We will discuss this point further at the end of
	section<SPACE/><REF NAME="sec:streams-and-delayed-evaluation"/>.
        In section<SPACE/><REF NAME="sec:lazy-evaluation"/>, we<APOS/>ll
	develop a framework that unifies lists and streams.</FOOTNOTE>
        <SNIPPET EVAL="yes">
	  <INDEX><DECLARATION>stream_ref</DECLARATION></INDEX> 
	  <INDEX><DECLARATION>stream_map</DECLARATION></INDEX> 
	  <INDEX><DECLARATION>stream_for_each</DECLARATION></INDEX> 
          <REQUIRES>stream_tail</REQUIRES>
          <NAME>stream_functions</NAME>
          <EXAMPLE>stream_functions_example</EXAMPLE>
	  <JAVASCRIPT>
function stream_ref(s, n) {
    return n === 0
           ? head(s)
           : stream_ref(stream_tail(s), n - 1);
}
function stream_map(f, s) {
    return is_null(s)
           ? null
           : pair(f(head(s)),
                  () => stream_map(f, stream_tail(s)));
}
function stream_for_each(fun, s) {
    if (is_null(s)) {
        return true;
    } else {
        fun(head(s));
        return stream_for_each(fun, stream_tail(s));
    }
}
	  </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <REQUIRES>stream_tail</REQUIRES>
          <NAME>stream_functions_example</NAME>
	  <JAVASCRIPT>
const my_stream = pair(4, () => pair(5, () => null));
display(stream_ref(my_stream, 1));
const my_stream_2 = stream_map(x => x + 1, my_stream);
stream_for_each(display, my_stream_2);
	  </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
const my_stream = pair(4, () => pair(5, () => null));
const my_stream_2 = stream_map(x => x + 1, my_stream);
let acc = 0;
stream_for_each(x => {acc = acc + x;}, my_stream_2);
acc;
	  </JAVASCRIPT_TEST>
	</SNIPPET>
	The function
        <JAVASCRIPTINLINE>stream_for_each</JAVASCRIPTINLINE> is useful for
	viewing streams:
        <SNIPPET EVAL="yes">
	  <INDEX><DECLARATION>display_stream</DECLARATION></INDEX> 
          <NAME>display_stream</NAME>
          <EXAMPLE>display_stream_example</EXAMPLE>
	  <JAVASCRIPT>
function display_stream(s) {
    return stream_for_each(display, s);
}
	  </JAVASCRIPT>
	  <JAVASCRIPT_RUN>
const max_display = 9;
function display_stream(s) {
    function display_stream_iter(st, n) {
        if (is_null(st)) {
        } else if (n === 0) {
            display('', "...");
        } else {
            display(head(st));
            display_stream_iter(stream_tail(st), n - 1);
        }
    }
    display_stream_iter(s, max_display);
}
	  </JAVASCRIPT_RUN>
        </SNIPPET>
        <SNIPPET EVAL="yes" HIDE="yes">
          <REQUIRES>stream_tail</REQUIRES>
	  <REQUIRES>display_stream</REQUIRES>
          <NAME>display_stream_example</NAME>
	  <JAVASCRIPT>
const my_stream = pair(4, () => pair(5, () => null));
display_stream(my_stream);
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>

      <TEXT>
	The function that represents the tail of a stream is evaluated when it
	is accessed, using <JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE>.
	This design choice is reminiscent of our discussion of rational numbers
	in section<SPACE/><REF NAME="sec:abstraction-barriers"/>, where we saw
	that we can choose to implement rational numbers so that the reduction
	of numerator and denominator to lowest terms is performed either at
        construction time or at selection time.  The two rational-number
        implementations produce the same data abstraction, but the choice has
        an effect on efficiency.  There is a similar relationship between
        streams and ordinary lists.  As a data abstraction, streams are the
        same as lists.  The difference is the time at which the elements are
        evaluated.  With ordinary lists, both the
	<JAVASCRIPTINLINE>head</JAVASCRIPTINLINE> and the
	<JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>
        are evaluated at construction time.  With streams, the
	<JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE> is evaluated at selection time.
      </TEXT>

      <SUBHEADING> 
        <NAME>Streams in action</NAME>
      </SUBHEADING>

      <TEXT>
        To see how this data structure behaves, let us analyze the
        <QUOTE>outrageous</QUOTE> prime computation we saw above, reformulated
	in terms of streams:

        <SNIPPET EVAL="yes">
	  <NAME>no_more_outrageous</NAME>
          <REQUIRES>prime_definition</REQUIRES>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <EXPECTED>10009</EXPECTED>
	  <JAVASCRIPT>
head(stream_tail(stream_filter(
                    is_prime,
                    stream_enumerate_interval(10000, 
                                              1000000))));
	  </JAVASCRIPT>
        </SNIPPET>
        We will see that it does indeed work efficiently.
      </TEXT>

      <TEXT>
        We begin by calling
	<JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE> with
        the arguments 10,000 and 1,000,000.  The function
	<JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE>
        is the stream analog of
	<JAVASCRIPTINLINE>enumerate_interval</JAVASCRIPTINLINE>
        (section<SPACE/><REF NAME="sec:sequences-conventional-interfaces"/>):
        <SNIPPET HIDE="yes">
	  <NAME>stream_enumerate_interval_example</NAME>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <JAVASCRIPT>
stream_enumerate_interval(10000, 1000000);
	  </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
stream_ref(stream_enumerate_interval(10000, 1000000), 100);
	  </JAVASCRIPT_TEST>
        </SNIPPET>
        <SNIPPET EVAL="yes">
	  <INDEX><DECLARATION>stream_enumerate_interval</DECLARATION></INDEX>
          <REQUIRES>prime_definition</REQUIRES>
          <NAME>stream_enumerate_interval</NAME>
	  <EXAMPLE>stream_enumerate_interval_example</EXAMPLE>
	  <EXPECTED>10100</EXPECTED>
	  <JAVASCRIPT>
function stream_enumerate_interval(low, high) {
    return low &gt; high
           ? null
           : pair(low,
                  () => stream_enumerate_interval(low + 1, 
                                                  high)); 
}
	  </JAVASCRIPT>
        </SNIPPET>
        and thus the result returned by
	<JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE>,
        formed by the <SCHEMEINLINE>pair</SCHEMEINLINE>,
	is<FOOTNOTE>The numbers shown here do not really appear in the delayed
	expression.  What actually appears is the original expression, in an
	environment in which the variables are bound to the appropriate numbers.
	For example, <JAVASCRIPTINLINE>low + 1</JAVASCRIPTINLINE> with
        <SCHEMEINLINE>low</SCHEMEINLINE> bound to 10,000 actually appears
	where <SCHEMEINLINE>10001</SCHEMEINLINE> is shown.</FOOTNOTE>
        <SNIPPET EVAL="yes">
	  <NAME>stream_enumerate_interval_example_2</NAME>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <EXPECTED>10100</EXPECTED>
	  <JAVASCRIPT>
pair(10000, () => stream_enumerate_interval(10001, 1000000));
	  </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
stream_ref(pair(10000, () => stream_enumerate_interval(10001, 1000000)), 100);
	  </JAVASCRIPT_TEST>
        </SNIPPET>
        That is, <JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE>
        returns a stream represented as a pair whose
	<JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>
        is 10,000 and whose <JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>
	is a promise to enumerate more of the
        interval if so requested.  This stream is now filtered for primes,
        using the stream analog of the <SCHEMEINLINE>filter</SCHEMEINLINE>
	function
        (section<SPACE/><REF NAME="sec:sequences-conventional-interfaces"/>):
        <SNIPPET EVAL="yes" CHAP="2">
	  <INDEX><DECLARATION>stream_filter</DECLARATION></INDEX> 
          <REQUIRES>stream_tail</REQUIRES>
          <NAME>stream_filter</NAME>
          <EXAMPLE>stream_filter_example</EXAMPLE>
	  <EXPECTED>6</EXPECTED>
	  <JAVASCRIPT>
function stream_filter(pred, stream) {
    return is_null(stream)
           ? null
           : pred(head(stream))
           ? pair(head(stream),
                  () => stream_filter(pred, 
                                      stream_tail(stream)))
           : stream_filter(pred, stream_tail(stream));
}
	  </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET EVAL="yes" CHAP="2" HIDE="yes">
          <NAME>stream_filter_example</NAME>
          <REQUIRES>display_stream</REQUIRES>
	  <JAVASCRIPT>
const my_stream = pair(5, () => pair(6, () => pair(7, () => null)));
const my_filtered_stream =
    stream_filter(x => x % 2 === 0, my_stream);
display_stream(my_filtered_stream);
	  </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
const my_stream = pair(5, () => pair(6, () => pair(7, () => null)));
const my_filtered_stream =
    stream_filter(x => x % 2 === 0, my_stream);
head(my_filtered_stream);
	  </JAVASCRIPT_TEST>
	</SNIPPET>
        The function <JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE> tests the
	<SCHEMEINLINE>head</SCHEMEINLINE> of the stream (which is 10,000). Since
	this is not prime, <JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE>
	examines the tail of its input stream.  The call to
	<JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE> forces evaluation of the
	delayed <JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE>,
	which now returns
        <SNIPPET EVAL="yes">
	  <NAME>enumerate_interval_example_3</NAME>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <EXPECTED>10101</EXPECTED>
	  <JAVASCRIPT>
pair(10001, () => stream_enumerate_interval(10002, 1000000));
          </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
stream_ref(pair(10001, () => stream_enumerate_interval(10002, 1000000)), 100);
          </JAVASCRIPT_TEST>
	</SNIPPET>
	The function <JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE> now
	looks at the <JAVASCRIPTINLINE>head</JAVASCRIPTINLINE> of this stream,
        10,001, sees that this is not prime either, forces another 
	<JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE>, and so on, until 
	<JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE> yields
	the prime 10,007, whereupon
	<JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE>, according to its
        definition, returns
        <SNIPPET EVAL="no">
	  <JAVASCRIPT>
pair(head(stream), 
     stream_filter(pred, stream_tail(stream)));
          </JAVASCRIPT>
	</SNIPPET>
        which in this case is
        <SNIPPET EVAL="yes">
	  <NAME>which_in_this_case</NAME>
          <REQUIRES>prime_definition</REQUIRES>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <EXPECTED>10949</EXPECTED>
	  <JAVASCRIPT>
pair(10007,
     () => stream_filter(
               is_prime,
               pair(10008,
                    () => stream_enumerate_interval(10009, 
                                                    1000000))
              )
    );
	  </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
stream_ref(pair(10007,
     () => stream_filter(
               is_prime,
               pair(10008,
                    () => stream_enumerate_interval(10009, 
                                                    1000000))
              )
    ), 100);
	  </JAVASCRIPT_TEST>
        </SNIPPET>
        This result is now passed to
	<JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE> in our original
	expression.  This forces the delayed
	<JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE>, 
	which in turn keeps forcing the delayed
	<JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE> until it
	finds the next prime, which is 10,009.  Finally, the result passed to
	<SCHEMEINLINE>head</SCHEMEINLINE> in our original expression is
        <SNIPPET EVAL="yes">
	  <NAME>now_passed_to</NAME>
          <REQUIRES>prime_definition</REQUIRES>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <EXPECTED>10957</EXPECTED>
	  <JAVASCRIPT>
pair(10009,
     () => stream_filter(
               is_prime,
               pair(10010,
                    () => stream_enumerate_interval(10011, 
                                                    1000000))
              )
    );
	  </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
stream_ref(pair(10009,
     () => stream_filter(
               is_prime,
               pair(10010,
                    () => stream_enumerate_interval(10011, 
                                                    1000000))
              )
    ), 100);
	  </JAVASCRIPT_TEST>
        </SNIPPET>
	The function <SCHEMEINLINE>head</SCHEMEINLINE> returns 10,009, and the
	computation is complete.  Only as many integers were tested for
	primality as were necessary to find the second prime, and the interval
	was enumerated only as far as was necessary to feed the prime filter.
      </TEXT>

      <TEXT>
        In general, we can think of delayed evaluation as 
        <INDEX>programming<SUBINDEX>demand-driven</SUBINDEX></INDEX>
        <QUOTE>demand-driven</QUOTE> programming, whereby each stage in the
	stream process is activated only enough to satisfy the next stage.  What
	we have done is to
        <INDEX>order of events<SUBINDEX>decoupling apparent from actual</SUBINDEX></INDEX>
        decouple the actual order of events in the computation from the apparent
	structure of our functions. We write functions as if the streams existed
	<QUOTE>all at once</QUOTE> when, in reality, the computation is
	performed incrementally, as in traditional programming styles.
      </TEXT>


      <SUBHEADING> 
        <NAME>An optimization</NAME>
      </SUBHEADING>

      <TEXT>
	When we construct stream pairs, we delay the evaluation of their tail
	expressions by wrapping these expressions in a function. We force their
	evaluation when needed, by applying the function.
      </TEXT>

      <TEXT>
        This implementation suffices for streams to work as advertised, but
	there is an important optimization that we shall consider where needed.
	In many	applications, we end up forcing the same delayed object many
	times. This can lead to serious inefficiency in recursive programs
	involving streams.  (See
	exercise<SPACE/><REF NAME="ex:fib-stream-efficiency"/>.)
	The solution is to build delayed objects so that the first time they are
	forced, they store the value that is computed.  Subsequent forcings will
	simply return the stored value without repeating the computation.  In
	other words, we implement the construction of stream pairs as a
        <INDEX>delayed expression<SUBINDEX>memoized</SUBINDEX></INDEX>
        <INDEX>memoization<SUBINDEX><ORDER>stream tail</ORDER>in stream tail</SUBINDEX></INDEX>
	memoized function similar to the one described in
	exercise<SPACE/><REF NAME="ex:memoization"/>. One way to accomplish this
	is to use the following function, which takes as argument a function
        (of no arguments) and returns a memoized version of the function.
	The first time the memoized function is run, it saves the computed
	result.	On subsequent evaluations, it simply returns
	the result.<FOOTNOTE>There are many possible implementations of streams
	other than the one described in this section.  Delayed evaluation, which
	is the key to making streams practical, was inherent in 
        <INDEX>Algol<SUBINDEX>call-by-name argument passing</SUBINDEX></INDEX>
        Algol 60<APOS/>s
        <INDEX>call-by-name argument passing</INDEX>
	<EM>call-by-name</EM>
        parameter-passing method.  The use of this mechanism to implement
        streams was first described by 
        <INDEX>Landin, Peter</INDEX>
        Landin (1965).  Delayed evaluation for
        streams was introduced into Lisp by 
        <INDEX>Friedman, Daniel P.</INDEX>
        <INDEX>Wise, David S.</INDEX>
        Friedman and Wise (1976). In their
        implementation,
	<SCHEMEINLINE>cons</SCHEMEINLINE> (the Lisp
	equivalent of our
	<JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE> function)
	always delays evaluating its arguments, so
        that lists automatically behave as streams.  The memoizing
        optimization is also known as 
        <INDEX>call-by-need argument passing</INDEX>
        <EM>call-by-need</EM>.  The Algol community would refer to our original
	delayed objects as
        <INDEX>thunk<SUBINDEX>call-by-name</SUBINDEX></INDEX>
        <INDEX>thunk<SUBINDEX>call-by-need</SUBINDEX></INDEX>
        <INDEX>Algol<SUBINDEX>thunks</SUBINDEX></INDEX>
	<EM>call-by-name thunks</EM> and to the optimized
	versions as <EM>call-by-need thunks</EM>.</FOOTNOTE>
        <SNIPPET>
          <INDEX><DECLARATION>memo</DECLARATION></INDEX> 
	  <NAME>memo</NAME>
	  <EXAMPLE>memo_example</EXAMPLE>
	  <EXPECTED>1</EXPECTED>
          <JAVASCRIPT>
function memo(fun) {	    
    let already_run = false;
    let result = undefined;
    return () => {
               if (!already_run) {
                   result = fun();
                   already_run = true;
                   return result;
               } else {
                   return result;
               }
           };
}
	  </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
	  <NAME>memo_example</NAME>
          <JAVASCRIPT>
function square_4() {
    const result = 4 * 4;	    
    display("multiplication carried out");
    return result;
}
const memo_square_4 = memo(square_4);
display(memo_square_4()); // shows "multipl.."
display(memo_square_4()); // does not show "multipl.."
	  </JAVASCRIPT>
          <JAVASCRIPT_TEST>
let calls = 0;
function square_4() {
    const result = 4 * 4;	    
    calls = calls + 1;
    return result;
}
const memo_square_4 = memo(square_4);
memo_square_4(); 
memo_square_4();
calls;
	  </JAVASCRIPT_TEST>
	</SNIPPET>
      </TEXT>

      <TEXT>
	We can make use of <JAVASCRIPTINLINE>memo</JAVASCRIPTINLINE> whenever
	we construct a stream pair. For example, instead of 
        <SNIPPET EVAL="yes">
          <INDEX><DECLARATION>stream_map</DECLARATION></INDEX> 
	  <EXAMPLE>stream_map_example</EXAMPLE>
	  <EXPECTED>3</EXPECTED>
	  <JAVASCRIPT>
function stream_map(f, s) {
    return is_null(s)
           ? null
           : pair(f(head(s)),
                  () => stream_map(f, stream_tail(s)));
}
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET EVAL="yes" HIDE="yes">
          <REQUIRES>stream_tail</REQUIRES>
	  <NAME>stream_map_example</NAME>
	  <JAVASCRIPT>
const my_stream = pair(4, () => pair(5, () => null));

const my_stream_2 =
    stream_map(display, my_stream);

stream_ref(my_stream_2, 1);
stream_ref(my_stream_2, 1);
// the number 5 is shown twice
// because the same delayed
// object is forced twice
	  </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
const my_stream = pair(4, () => pair(5, () => null));
let calls = 0;
const my_stream_2 =
    stream_map(x => {calls = calls + 1;}, my_stream);

stream_ref(my_stream_2, 1);
stream_ref(my_stream_2, 1);
calls;
	  </JAVASCRIPT_TEST>
	</SNIPPET>
	we can define an optimized function
	<JAVASCRIPTINLINE>stream_map</JAVASCRIPTINLINE>	as
	follows:
	<SNIPPET EVAL="yes">
          <INDEX><DECLARATION>stream_map_optimized</DECLARATION></INDEX> 
	  <NAME>stream_map_optimized</NAME>
	  <REQUIRES>memo</REQUIRES>
	  <EXAMPLE>stream_map_optimized_example</EXAMPLE>
	  <EXPECTED>2</EXPECTED>	  
	  <JAVASCRIPT>
function stream_map_optimized(f, s) {
    return is_null(s)
           ? null
           : pair(f(head(s)),
                  memo( () => stream_map_optimized(
                                 f, stream_tail(s)) ));
}
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET EVAL="yes" HIDE="yes">
	  <NAME>stream_map_optimized_example</NAME>
	  <JAVASCRIPT>
const my_stream = pair(4, () => pair(5, () => null));

const my_stream_2 =
    stream_map(display, my_stream);

stream_ref(my_stream_2, 1);
stream_ref(my_stream_2, 1);
// the number 5 is shown twice
// because the same delayed
// object is forced twice

const my_stream_3 =
    stream_map_optimized(display, my_stream);

stream_ref(my_stream_3, 1);
stream_ref(my_stream_3, 1);
// the number 5 is shown only once
// because the result of forcing
// the delayed object is memoized
	  </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
const my_stream = pair(4, () => pair(5, () => null));

const my_stream_2 =
    stream_map(x => x, my_stream);

stream_ref(my_stream_2, 1);
stream_ref(my_stream_2, 1);
// the number 5 is shown twice
// because the same delayed
// object is forced twice

let calls = 0;
const my_stream_3 =
    stream_map_optimized(x => {calls = calls + 1;}, my_stream);

stream_ref(my_stream_3, 1);
stream_ref(my_stream_3, 1);
calls;
	  </JAVASCRIPT_TEST>
	</SNIPPET>
      </TEXT>
      
      <EXERCISE>
	<LABEL NAME="ex:combine-streams"/>
	Declare a function <JAVASCRIPTINLINE>stream_map_2</JAVASCRIPTINLINE>
	that takes a binary function and two streams as arguments and returns
	a stream whose elements are the results of applying the function
	pairwise to the corresponding elements of the argument streams.
	<SNIPPET EVAL="no">
          <INDEX><USE>stream_map_2</USE><FRAGILE/></INDEX> 
	  <JAVASCRIPT>
function stream_map_2(f, s1, s2) {
    ...
}
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET EVAL="no" HIDE="yes">
	  <NAME>stream_combine</NAME>
	  <REQUIRES>memo</REQUIRES>
	  <JAVASCRIPT>
function stream_map_2(f, s1, s2) {
    return is_null(s1) &amp;&amp; is_null(s2)
           ? null
           : is_null(s1) || is_null(s2)
           ? error(null, "unexpected argument -- stream_map_2")
           : pair(f(head(s1),head(s2)), 
                  memo(() => stream_map_2(f, stream_tail(s1),
                                          stream_tail(s2))));
}	  	
	  </JAVASCRIPT>
	</SNIPPET>
	Similar to <JAVASCRIPTINLINE>stream_map_optimized</JAVASCRIPTINLINE>,
	declare a function
	<JAVASCRIPTINLINE>stream_map_2_optimized</JAVASCRIPTINLINE> by
	modifying your
	<JAVASCRIPTINLINE>stream_map_2</JAVASCRIPTINLINE>
	such that the result stream employs memoization.
      </EXERCISE>

      <EXERCISE>
	<LABEL NAME="ex:delayed1"/>
	Note that our primitive function
	<JAVASCRIPTINLINE>display</JAVASCRIPTINLINE> returns its argument
	after displaying it.
	What does the interpreter print in response to evaluating each
	statement in the following sequence?<FOOTNOTE>Exercises such
	as<SPACE/><REF NAME="ex:delayed1"/> and<SPACE/><REF NAME="ex:delayed2"/>
	are valuable for testing our understanding of how delayed evaluation
	works. On the other hand, intermixing delayed evaluation with
	<INDEX>delayed evaluation<SUBINDEX>printing and</SUBINDEX></INDEX>
	printing<EMDASH/>and, even worse, with assignment<EMDASH/>is extremely
	confusing, and instructors of courses on computer languages have
	traditionally tormented their students with examination questions such
	as the ones in this section. Needless to say, writing programs that
	depend on such subtleties is
	<INDEX>programming<SUBINDEX>odious style</SUBINDEX></INDEX>
	odious programming style.  Part of the power of stream processing is
	that it lets us ignore the order in which events actually happen in
	our programs.  Unfortunately, this is precisely what we cannot afford
	to do in the presence of assignment, which forces us to be concerned
	with time and change.</FOOTNOTE>
	<SNIPPET EVAL="yes">
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <JAVASCRIPT>
let x = stream_map(display, stream_enumerate_interval(0, 10));

stream_ref(x, 5);

stream_ref(x, 7);
	  </JAVASCRIPT>
	</SNIPPET>
	What does the interpreter print if 
	<JAVASCRIPTINLINE>stream_map_optimized</JAVASCRIPTINLINE>
	is used instead of <JAVASCRIPTINLINE>stream_map</JAVASCRIPTINLINE>?
	<SNIPPET EVAL="yes">
	  <NAME>stream_map_optimized_example_2</NAME>
          <REQUIRES>stream_map_optimized</REQUIRES>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <JAVASCRIPT>
let x = stream_map_optimized(
            display, stream_enumerate_interval(0, 10));
stream_ref(x, 5);
stream_ref(x, 7);
	  </JAVASCRIPT>
	</SNIPPET>
      </EXERCISE>

      <EXERCISE>
        Consider the sequence of statements
	<SNIPPET EVAL="yes">
	  <NAME>assignment_and_streams</NAME>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
          <REQUIRES>even_definition</REQUIRES>
          <REQUIRES>display_stream</REQUIRES>
	  <EXPECTED>305</EXPECTED>
	  <JAVASCRIPT>
let sum = 0;

function accum(x) {
    sum = x + sum;
    return sum;
}

const seq = stream_map(accum, stream_enumerate_interval(1, 20));

const y = stream_filter(is_even, seq);

const z = stream_filter(x => x % 5 === 0, seq);

stream_ref(y, 7);

display_stream(z);
	  </JAVASCRIPT>
	  <JAVASCRIPT_TEST>
let sum = 0;

function accum(x) {
    sum = x + sum;
    return sum;
}

const seq = stream_map(accum, stream_enumerate_interval(1, 20));

const y = stream_filter(is_even, seq);

const z = stream_filter(x => x % 5 === 0, seq);

stream_ref(y, 7);

stream_ref(z, 3);
	  </JAVASCRIPT_TEST>
        </SNIPPET>
        What is the value of <SCHEMEINLINE>sum</SCHEMEINLINE> after each of the
	above statements is evaluated?
        <INDEX>delayed evaluation<SUBINDEX>assignment and</SUBINDEX></INDEX>
	What is the printed response to	evaluating the 
	<JAVASCRIPTINLINE>stream_ref</JAVASCRIPTINLINE> and 
	<JAVASCRIPTINLINE>display_stream</JAVASCRIPTINLINE> expressions?
	Would these responses differ if we had applied the function
	<JAVASCRIPTINLINE>memo</JAVASCRIPTINLINE>
	on every tail of every constructed stream pair, as suggested in the
	optimization above? Explain.
        <LABEL NAME="ex:delayed2"/>
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>
</SUBSECTION>
