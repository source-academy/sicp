<SUBSECTION> 
  

  <LABEL NAME="sec:circuit-simulator"></LABEL>
   <INDEX>数字电路仿真<OPEN></OPEN></INDEX> 

   <TEXT>
    设计复杂的数字系统，例如计算机，是一项重要的工程活动。 数字系统是通过互联简单元件构成的。 尽管这些单个元件的行为很简单，但由它们构成的网络可能表现出非常复杂的行为。 对拟议电路设计的计算机仿真是数字系统工程师使用的重要工具。 在本节中，我们设计一个用于执行数字逻辑仿真的系统。 该系统代表了一类被称为 
    <INDEX>事件驱动仿真</INDEX>
    <INDEX>仿真<SUBINDEX>事件驱动</SUBINDEX></INDEX>
    <EM>事件驱动仿真</EM> 的程序，其中动作 (<QUOTE>事件</QUOTE>) 会触发后续在稍后发生的事件，而这些事件又触发更多事件，依此类推。
  </TEXT> 

   <TEXT>
    我们的电路计算模型将由对应于构成电路的基本组件的对象组成。 存在 
    <INDEX>wire, in digital circuit</INDEX>
    <EM>wires</EM>，它们传输 
    <INDEX>signal, digital</INDEX>
    <INDEX>digital signal</INDEX>
    <EM>digital signals</EM>。 一个<SPACE></SPACE>数字信号在任何时刻只能取两个可能的值，0 和 1。 还有各种类型的数字 
    <INDEX>function box, in digital circuit</INDEX>
    <EM>function boxes</EM>，它们将传递输入信号的导线连接到其他输出导线上。 这些功能块根据其输入信号计算产生输出信号。 输出信号经过 
    <INDEX><ORDER>delay</ORDER>delay, in digital circuit</INDEX>
    延迟一段时间，该时间取决于功能块的类型。 例如，一个 
    <INDEX>inverter</INDEX>
    <EM>inverter</EM> 是一个原始功能块，用于反转其输入。 如果反相器的输入信号变为 0，则在一个 <EM>inverter-delay</EM> 之后，反相器会将其输出信号变为 1。 如果反相器的输入信号变为 1，则在一个 <EM>inverter-delay</EM> 之后，反相器会将其输出信号变为 0。 我们在图中符号化地绘制了反相器，如图<SPACE></SPACE><REF NAME="fig:logic-gates"></REF>所示。 一个 
    <INDEX>and-gate</INDEX>
    <EM>and-gate</EM>，也如图<SPACE></SPACE><REF NAME="fig:logic-gates"></REF>所示，是一个具有两个输入和一个输出的原始功能块。 它将其输出信号驱动到一个值，该值为输入信号的 
    <INDEX>logical and (digital logic)</INDEX>
    <EM>logical and</EM>。 也就是说，如果它的两个输入信号均变为<SPACE></SPACE>1，则在一个 <EM>and-gate-delay</EM> 时间之后，与门会将其输出信号设为 1；否则，输出为 0。 一个 
    <INDEX>or-gate</INDEX>
    <EM>or-gate</EM> 是一个类似的两输入原始功能块，其输出信号驱动到一个值，该值为输入信号的 
    <INDEX>logical or (digital logic)</INDEX>
    <EM>logical or</EM>。 也就是说，如果至少有一个输入信号为 1，则输出将变为 1；否则，输出将变为<SPACE></SPACE>0。
  </TEXT> 

     <FIGURE>
      <FIGURE SRC="img_original/ch3-Z-G-24.svg"></FIGURE>
      <CAPTION>数字逻辑模拟器中的原始功能块。</CAPTION>
      <LABEL NAME="fig:logic-gates"></LABEL>
    </FIGURE> 

   <TEXT>
    我们可以将原始功能块连接在一起，以构造更复杂的功能。为了实现这一点，我们将一些功能块的输出连接到其他功能块的输入端。例如，图<SPACE></SPACE><REF NAME="fig:half-adder"></REF>中所示的<INDEX>半加器</INDEX>
    <INDEX>加法器<SUBINDEX>半</SUBINDEX></INDEX>
    <EM>半加器</EM>电路由一个或门、两个与门和一个反相器构成。它接受两个输入信号，<LATEXINLINE>$A$</LATEXINLINE>和<LATEXINLINE>$B$</LATEXINLINE>，并产生两个输出信号，<LATEXINLINE>$S$</LATEXINLINE>和<LATEXINLINE>$C$</LATEXINLINE>。当且仅当<LATEXINLINE>$A$</LATEXINLINE>和<LATEXINLINE>$B$</LATEXINLINE>中恰有一个为1时，<LATEXINLINE>$S$</LATEXINLINE>将变为1，而当<LATEXINLINE>$A$</LATEXINLINE>和<LATEXINLINE>$B$</LATEXINLINE>均为1时，<LATEXINLINE>$C$</LATEXINLINE>将变为1。从图中可以看出，由于涉及延迟，输出可能在不同时间产生。数字电路设计中的许多难点正源于这一事实。
    <FIGURE>
      <FIGURE SPLIT_SCALE="0.5" WEB_SCALE="0.8" SRC="img_original/ch3-Z-G-25.svg"></FIGURE>
      <CAPTION>半加器电路。
      </CAPTION>
      <LABEL NAME="fig:half-adder"></LABEL>
    </FIGURE>
  </TEXT> 

   <TEXT>
    我们现在将构建一个程序，用于建模我们希望研究的数字逻辑电路。该程序将构造模拟导线的计算对象，这些导线将<QUOTE>保存</QUOTE>信号。功能块将由
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    模拟，以确保信号之间关系的正确性。
  </TEXT> 

   <TEXT>
    我们模拟中的一个基本元素将是一个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>make_wire</USE></INDEX> 
    ，用于构造导线。例如，我们可以如下构造六根导线：
    <SNIPPET>
      <NAME>make_wire_usage</NAME>
      <REQUIRES>make_wire</REQUIRES>
      <SCHEME>
(define a (make-wire))
(define b (make-wire))
(define c (make-wire))
(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
      </SCHEME>
      <JAVASCRIPT>
const a = make_wire();
const b = make_wire();
const c = make_wire();
const d = make_wire();
const e = make_wire();
const s = make_wire();
      </JAVASCRIPT>
    </SNIPPET>
    我们通过调用一个构造该类盒子的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    将一个函数盒附加到一组导线上。该构造函数的参数为要连接到盒子上的导线。例如，既然我们可以构造与门、或门和反相器，就可以按照图<SPACE></SPACE><REF NAME="fig:half-adder"></REF>所示连接出半加器：
    <SNIPPET>
      <NAME>or_gate_example</NAME>
      <REQUIRES>or_gate</REQUIRES>
      <REQUIRES>make_wire_usage</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(or-gate a b d)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
or_gate(a, b, d);   
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>and_gate_example</NAME>
      <REQUIRES>and_gate</REQUIRES>
      <REQUIRES>make_wire_usage</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(and-gate a b c)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
and_gate(a, b, c);  
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>inverter_example</NAME>
      <REQUIRES>inverter</REQUIRES>
      <REQUIRES>make_wire_usage</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(inverter c e)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
inverter(c, e);     
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>and_gate_example_2</NAME>
      <REQUIRES>and_gate</REQUIRES>
      <REQUIRES>make_wire_usage</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(and-gate d e s)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
and_gate(d, e, s);  
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT> 

   <TEXT>
    更好的是，我们可以通过定义一个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>半加器</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>half_@adder</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    来明确命名这个操作，该操作构造出这个电路，给出要连接到半加器上的四根外部导线：
    <SNIPPET HIDE="yes">
      <NAME>half_adder_example</NAME>
      <REQUIRES>half_adder</REQUIRES>
      <JAVASCRIPT>
const a = make_wire();
const b = make_wire();
const s = make_wire();	
const c = make_wire();
half_adder(a, b, s, c);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX>半加器<SUBINDEX><DECLARATION>half_adder</DECLARATION></SUBINDEX></INDEX>
      <NAME>half_adder</NAME>
      <REQUIRES>make_wire</REQUIRES>
      <REQUIRES>or_gate</REQUIRES>
      <REQUIRES>and_gate</REQUIRES>
      <REQUIRES>inverter</REQUIRES>
      <EXAMPLE>half_adder_example</EXAMPLE>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    &apos;ok))
      </SCHEME>
      <JAVASCRIPT>
function half_adder(a, b, s, c) {
    const d = make_wire();
    const e = make_wire();
    or_gate(a, b, d);
    and_gate(a, b, c);
    inverter(c, e);
    and_gate(d, e, s);
    return &quot;ok&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
    这样定义的优点在于，我们可以将 
    <SPLITINLINE>
    <SCHEME><SCHEMEINLINE>半加器</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>half_adder</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    本身作为构建更复杂电路的积木块使用。例如，图<SPACE></SPACE><REF NAME="fig:full-adder"></REF>展示了一个由两个半加器和一个或门组成的
    <INDEX>全加器</INDEX>
    <INDEX>加器<SUBINDEX>全</SUBINDEX></INDEX>
    <EM>全加器</EM>。<FOOTNOTE>全加器是一种在二进制数相加中使用的基本电路元素。这里 <LATEXINLINE>$A$</LATEXINLINE> 和 <LATEXINLINE>$B$</LATEXINLINE> 表示要相加的两个数字中对应位置上的位，<LATEXINLINE>$C_{\mathit{in}}$</LATEXINLINE> 为来自右侧一位的进位。该电路生成 <LATEXINLINE>$\mathit{SUM}$</LATEXINLINE>，即对应位置上的和位，以及 <LATEXINLINE>$C_{\mathit{out}}$</LATEXINLINE>，即需传播到左侧的进位。</FOOTNOTE> 我们可以按照如下方式构造一个全加器：
    <SNIPPET HIDE="yes">
      <NAME>full_adder_example</NAME>
      <REQUIRES>full_adder</REQUIRES>
      <JAVASCRIPT>
const a     = make_wire();
const b     = make_wire();
const c_in  = make_wire();
const sum   = make_wire();	
const c_out = make_wire();
full_adder(a, b, c_in, sum, c_out);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX>全加器<SUBINDEX><DECLARATION>full_adder</DECLARATION></SUBINDEX></INDEX>
      <NAME>full_adder</NAME>
      <REQUIRES>make_wire</REQUIRES>
      <REQUIRES>half_adder</REQUIRES>
      <REQUIRES>or_gate</REQUIRES>
      <EXAMPLE>full_adder_example</EXAMPLE>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    &apos;ok))
      </SCHEME>
      <JAVASCRIPT>
function full_adder(a, b, c_in, sum, c_out) {
    const s = make_wire();
    const c1 = make_wire();
    const c2 = make_wire();
    half_adder(b, c_in, s, c1);
    half_adder(a, s, sum, c2);
    or_gate(c1, c2, c_out);
    return &quot;ok&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
    定义了
    <SPLITINLINE>
    <SCHEME><SCHEMEINLINE>全加器</SCHEMEINLINE></SCHEME>
    <JAVASCRIPT><JAVASCRIPTINLINE>full_adder</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    作为一个
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    后，我们就可以利用它作为构建更复杂电路的积木块。（例如，参见练习<SPACE></SPACE><REF NAME="ex:ripple-carry"></REF>。）
  <WEB_ONLY>
    &lt;!--  图形因适应 SICP JS 分页稍后移动  --&gt;
    &lt;!--  图形代码在本文件的 PDF_ONLY 部分中重复  --&gt;
    <FIGURE>
      <FIGURE SPLIT_SCALE="0.5" WEB_SCALE="0.8" SRC="img_original/ch3-Z-G-26.svg"></FIGURE>
      <CAPTION>一个全加器电路。
      </CAPTION>
      <LABEL NAME="fig:full-adder"></LABEL>
    </FIGURE>
  </WEB_ONLY>
  </TEXT> 

   <TEXT>
    从本质上讲，我们的模拟器为我们提供了构建电路语言的工具。如果我们采用在 <REF NAME="sec:elements-of-programming"></REF> 一节中研究
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    时所持的一般语言视角，我们可以认为原始函数盒构成了该语言的基本元素，将盒子连线在一起提供了一种组合方式，以及将接线模式指定为
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    则构成了一种抽象手段。
  </TEXT> 

   <SUBHEADING> <NAME>原始函数盒</NAME> </SUBHEADING> 


   <TEXT>
    原始函数盒
    <INDEX>数字电路仿真<SUBINDEX>原始函数盒<OPEN></OPEN></SUBINDEX></INDEX>
    实现了当一根导线上的信号发生变化时对其他导线信号产生影响的作用。为了构建函数盒，我们在导线上使用以下操作：
    <UL>
      <LI>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(get-signal wire)</SCHEMEINLINE>:</SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>get_signal(</JAVASCRIPTINLINE><META>wire</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	<INDEX><USE>get_signal</USE></INDEX> 
	<BR></BR>
	返回导线上信号的当前值。
      </LI>
      <LI>
        <SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(set-signal! wire new-value)</SCHEMEINLINE>:</SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>set_signal(</JAVASCRIPTINLINE><META>wire</META><JAVASCRIPTINLINE>,</JAVASCRIPTINLINE> <META>new-value</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>:
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>set_signal</USE></INDEX> 
	<BR></BR>
	将导线上信号的值更改为新值。
      </LI>
      <LI>
        <SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>(add-action! wire procedure-of-no-arguments)</SCHEMEINLINE>:
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>add_action(</JAVASCRIPTINLINE><META>wire</META><JAVASCRIPTINLINE>,</JAVASCRIPTINLINE> <META>function-of-no-arguments</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>:
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>add_action</USE></INDEX> 
	<BR></BR>
	声明当导线上信号发生变化时，应执行指定的
	<SPLITINLINE>
	  <SCHEME>过程</SCHEME>
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	。这样的
	<SPLITINLINE>
	  <SCHEME>过程</SCHEME>
	  <JAVASCRIPT>函数</JAVASCRIPT>
	</SPLITINLINE>
	是传递导线上信号变化至其他导线的载体。
      </LI>
    </UL>
    此外，我们还将使用一个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>after_delay</USE></INDEX> 
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>after-delay</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>after_delay</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    ，它接受一个时间延迟和一个待执行的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，并在给定延迟后执行该过程/函数。
  </TEXT> 

   <TEXT>
    利用这些
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    我们可以定义原始的数字逻辑函数。要通过反相器将输入连接到输出，我们使用
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>add-action!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>add_action</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    将输入导线与一个将在输入导线上信号改变时执行的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    关联在一起。该
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    计算输入信号的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>logical-not</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>logical_not</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    ，然后，在经历一个
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>inverter-delay</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>inverter_delay</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    之后，将输出信号设置为这个新值:
    <SNIPPET>
      <INDEX>inverter<SUBINDEX><DECLARATION>inverter</DECLARATION></SUBINDEX></INDEX>
      <INDEX><DECLARATION>logical_not</DECLARATION></INDEX> 
      <NAME>inverter</NAME>
      <REQUIRES>get_signal</REQUIRES>
      <REQUIRES>after_delay</REQUIRES>
      <EXAMPLE>inverter_example</EXAMPLE>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input)
  &apos;ok)
                
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error &quot;Invalid signal&quot; s))))
      </SCHEME>
      <JAVASCRIPT>
function inverter(input, output) {
    function invert_input() {
        const new_value = logical_not(get_signal(input));
        after_delay(inverter_delay, 
                    () =&gt; set_signal(output, new_value));
    }
    add_action(input, invert_input);
    return &quot;ok&quot;;
}
function logical_not(s) {
    return s === 0
           ? 1
           : s === 1
           ? 0
           : error(s, &quot;invalid signal&quot;);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT> 

  <SNIPPET HIDE="yes">
    <NAME>logical_and</NAME>
    <JAVASCRIPT>
function logical_and(s1, s2) {
    return s1 === 1 &amp;&amp; s2 === 1
           ? 1
           : s1 === 0 || s1 === 1
           ? s2 === 0 || s2 === 1
             ? 0
             : error(s2, &quot;invalid signal&quot;)
           : error(s1, &quot;invalid signal&quot;);
}
    </JAVASCRIPT>
  </SNIPPET>
   <PDF_ONLY>
    &lt;!-- 将图形从前面移至此处以适应 SICP JS 分页 --&gt;
    &lt;!-- 图形代码是该文件中较早 WEB_ONLY 部分代码的复制 --&gt;
    <FIGURE>
      <FIGURE SPLIT_SCALE="0.5" WEB_SCALE="0.8" SRC="img_original/ch3-Z-G-26.svg"></FIGURE>
      <CAPTION>全加器电路。
      </CAPTION>
      <LABEL NAME="fig:full-adder"></LABEL>
    </FIGURE>
  </PDF_ONLY> 

   <TEXT>
    一个与门稍微复杂一些。只要与门的任一输入发生变化，就必须执行
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    的动作。它计算输入导线上信号值的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>逻辑与</SCHEMEINLINE>
      （使用一个类似于
      <SCHEMEINLINE>逻辑非</SCHEMEINLINE> 的过程）
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>logical_and</JAVASCRIPTINLINE>
	（使用一个类似于
	<JAVASCRIPTINLINE>logical_not</JAVASCRIPTINLINE> 的函数）
      </JAVASCRIPT>
    </SPLITINLINE>
    并安排在经过一个
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>与门延迟</SCHEMEINLINE>。</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>and_gate_delay</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLITINLINE>
    之后，让输出导线更新为新的信号值。
    <SNIPPET POSTPADDING="no">
      <INDEX>and-gate<SUBINDEX><DECLARATION>and_gate</DECLARATION></SUBINDEX></INDEX>
      <NAME>and_gate</NAME>
      <REQUIRES>get_signal</REQUIRES>
      <REQUIRES>after_delay</REQUIRES>
      <REQUIRES>logical_and</REQUIRES>
      <EXAMPLE>and_gate_example</EXAMPLE>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
          (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  &apos;ok)
      </SCHEME>
      <JAVASCRIPT>
function and_gate(a1, a2, output) {
    function and_action_function() {
        const new_value = logical_and(get_signal(a1),
                                      get_signal(a2));
        after_delay(and_gate_delay, 
                    () =&gt; set_signal(output, new_value));
    }
    add_action(a1, and_action_function);
    add_action(a2, and_action_function);
    return &quot;ok&quot;;
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT> 

   <EXERCISE>
    定义一个
    <INDEX>或门<SUBINDEX><ORDER>或门</ORDER><SPLITINLINE><SCHEME><SCHEMEINLINE>or-gate</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>or_gate</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    作为一个基本函数盒。你的
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>or-gate</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>or_gate</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    构造器应该类似于
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>and-gate</SCHEMEINLINE>。</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>and_gate</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLITINLINE>
    <LABEL NAME="ex:3_28"></LABEL>
    <SOLUTION>
      <SNIPPET>
	<NAME>logical_or</NAME>
	<JAVASCRIPT>
// contributed by GitHub user clean99

function logical_or(s1, s2) {
    return s1 === 0 &amp;&amp; s2 === 0
           ? 0
           : s1 === 0 || s1 === 1
           ? s2 === 0 || s2 === 1
             ? 1
             : error(s2, &quot;invalid signal&quot;)
           : error(s1, &quot;invalid signal&quot;);
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET>
	<NAME>or_gate</NAME>
	<REQUIRES>get_signal</REQUIRES>
	<REQUIRES>after_delay</REQUIRES>
	<REQUIRES>logical_or</REQUIRES>
	<JAVASCRIPT>
// contributed by GitHub user clean99

function or_gate(a1, a2, output) {
    function or_action_function() {
        const new_value = logical_or(get_signal(a1),
                                     get_signal(a2));
        after_delay(or_gate_delay, 
                    () =&gt; set_signal(output, new_value));
    }
    add_action(a1, or_action_function);
    add_action(a2, or_action_function);
    return &quot;ok&quot;;
}
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE> 
  
   <EXERCISE>
    构造一个
    <INDEX>或门<SUBINDEX><ORDER>或门</ORDER><SPLITINLINE><SCHEME><SCHEMEINLINE>或门</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>or_gate</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    的另一种方法是将其作为一个由与门和反相器构成的复合数字逻辑设备来构造。定义一个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>或门</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>or_gate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    来实现这一目的。该或门的延迟时间以
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>与门延迟</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>and_gate_delay</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>反相器延迟</SCHEMEINLINE>?</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>inverter_delay</JAVASCRIPTINLINE>?
      </JAVASCRIPT>
    </SPLITINLINE>
    进行表示。
    <SOLUTION>
      （由 GitHub 用户 <LINK ADDRESS="https://github.com/taimoon">taimoon</LINK> 贡献）
      <BREAK></BREAK>
      思路：~(~a &amp; ~b) = nand(~a, ~b) = ~~a | ~~b = a | b
      <SNIPPET EVAL="no">
	<JAVASCRIPT>
function nand_gate(a1, a2, out){
    const tmp = make_wire();
    and_gate(a1, a2, tmp);
    inverter(tmp, out);
}

function or_gate(a1, a2, out){
    const not_a1 = make_wire();
    const not_a2 = make_wire();
    inverter(a1, not_a1);
    inverter(a2, not_a2);
    nand_gate(not_a1, not_a2, out);
}
	</JAVASCRIPT>
      </SNIPPET>
      与非门的延迟时间为
      <JAVASCRIPTINLINE>nand_gate_delay = and_gate_delay + inverter_delay</JAVASCRIPTINLINE> 而上述或门的延迟时间为
      <JAVASCRIPTINLINE>or_gate_delay = nand_gate_delay + inverter_delay = and_gate_delay + 2 * inverter_delay</JAVASCRIPTINLINE>。
    </SOLUTION>
    <LABEL NAME="ex:3_29"></LABEL>
  </EXERCISE> 
  
   <EXERCISE>
    图<SPACE></SPACE><REF NAME="fig:ripple-carry"></REF>展示了一个
    <INDEX>串行进位加法器</INDEX>
    <INDEX>加法器<SUBINDEX>串行进位加法器</SUBINDEX></INDEX>
    <EM>串行进位加法器</EM>，由串联<LATEXINLINE>$n$</LATEXINLINE>个全加器构成。
    这是用于相加两个<LATEXINLINE>$n$</LATEXINLINE>位二进制数的最简单形式的并行加法器。
    输入<LATEXINLINE>$A_{1}$</LATEXINLINE>、
    <LATEXINLINE>$A_{2}$</LATEXINLINE>、
    <LATEXINLINE>$A_{3}$</LATEXINLINE>、<ELLIPSIS></ELLIPSIS>、
    <LATEXINLINE>$A_{n}$</LATEXINLINE>及
    <LATEXINLINE>$B_{1}$</LATEXINLINE>、
    <LATEXINLINE>$B_{2}$</LATEXINLINE>、
    <LATEXINLINE>$B_{3}$</LATEXINLINE>、<ELLIPSIS></ELLIPSIS>、
    <LATEXINLINE>$B_{n}$</LATEXINLINE>
    是待相加的两个二进制数（每个<LATEXINLINE>$A_{k}$</LATEXINLINE>和
    <LATEXINLINE>$B_{k}$</LATEXINLINE>均为0或1)。
    该电路生成
    <LATEXINLINE>$S_{1}$</LATEXINLINE>、
    <LATEXINLINE>$S_{2}$</LATEXINLINE>、
    <LATEXINLINE>$S_{3}$</LATEXINLINE>、<ELLIPSIS></ELLIPSIS>、
    <LATEXINLINE>$S_{n}$</LATEXINLINE>，即<LATEXINLINE>$n$</LATEXINLINE>位的和，以及
    <LATEXINLINE>$C$</LATEXINLINE>，表示加法的进位。
    编写一个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>串行进位加法器</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ripple_carry_adder</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    来生成该电路。
    该
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    应接受三个列表作为参数，每个列表包含<LATEXINLINE>$n$</LATEXINLINE>根导线，分别表示
    <LATEXINLINE>$A_{k}$</LATEXINLINE>、<LATEXINLINE>$B_{k}$</LATEXINLINE>和
    <LATEXINLINE>$S_{k}$</LATEXINLINE><EMDASH></EMDASH>同时还接受另一根导线<LATEXINLINE>$C$</LATEXINLINE>。
    串行进位加法器的主要缺点是需要等待进位信号传播。获得一个<LATEXINLINE>$n$</LATEXINLINE>位串行进位加法器完整输出所需的延迟是多少？请以与门、或门和反相器的延迟来表达该延迟。
    <LABEL NAME="ex:ripple-carry"></LABEL>
  </EXERCISE> 

   <FIGURE>
    <FIGURE SPLIT_SCALE="0.5" WEB_SCALE="0.8" SRC="img_original/ch3-Z-G-27.svg"></FIGURE>
    <CAPTION>
      用于<LATEXINLINE>$n$</LATEXINLINE>-位数字的串行进位加法器。
    </CAPTION>
    <LABEL NAME="fig:ripple-carry"></LABEL>
  </FIGURE> 

   <INDEX>数字电路仿真<SUBINDEX>原语功能盒<CLOSE></CLOSE></SUBINDEX></INDEX> 

   <SUBHEADING> 
    <NAME>表示导线</NAME>
  </SUBHEADING> 
  <TEXT> 
    一条导线
    <INDEX>数字电路仿真<SUBINDEX>表示导线<OPEN></OPEN></SUBINDEX></INDEX>
    在我们的仿真中将是一个具有两个局部状态变量的计算对象：
    <SPLITINLINE>
      <SCHEME>一个<SPACE></SPACE><SCHEMEINLINE>信号值</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>一个<SPACE></SPACE><JAVASCRIPTINLINE>信号值</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    （初始时取值为 0）以及一组
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>动作过程</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>动作函数</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    ，在信号值改变时运行。我们实现导线时，
    采用
    <INDEX>消息传递<SUBINDEX>在数字电路仿真中</SUBINDEX></INDEX>
    消息传递风格，作为一组局部
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    再加上一个  
<SCHEMEINLINE>dispatch</SCHEMEINLINE>
     
    <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    用于选择合适的局部操作，就像我们在<SPACE></SPACE><REF NAME="sec:local-state-variables"></REF>节中对简单的银行账户对象所做的一样:
<SNIPPET>
      <INDEX><DECLARATION>make_wire</DECLARATION></INDEX> 
      <NAME>make_wire</NAME>
      <REQUIRES>call_each</REQUIRES>
      <EXAMPLE>make_wire_usage</EXAMPLE>
      <SCHEME>
(define (make-wire)
  (let ((signal-value 0) (action-procedures &apos;()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
            (call-each action-procedures))
            &apos;done))
                
(define (accept-action-procedure! proc)
  (set! action-procedures (cons proc action-procedures))
  (proc))
               
(define (dispatch m)
  (cond ((eq? m &apos;get-signal) signal-value)
        ((eq? m &apos;set-signal!) set-my-signal!)
        ((eq? m &apos;add-action!) accept-action-procedure!)
        (else (error &quot;Unknown operation -- WIRE&quot; m))))
  dispatch))
      </SCHEME>
      <JAVASCRIPT>
function make_wire() {
    let signal_value = 0;
    let action_functions = null;
    function set_my_signal(new_value) {
        if (signal_value !== new_value) {
            signal_value = new_value;
            return call_each(action_functions);
        } else {
            return &quot;done&quot;;
        }
    }
    function accept_action_function(fun) {
        action_functions = pair(fun, action_functions);
        fun();
    }
    function dispatch(m) {
        return m === &quot;get_signal&quot;
               ? signal_value
               : m === &quot;set_signal&quot;
               ? set_my_signal
               : m === &quot;add_action&quot;
               ? accept_action_function
               : error(m, &quot;unknown operation -- wire&quot;);
    }
    return dispatch;
}
      </JAVASCRIPT>
    </SNIPPET> 
    局部的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>set-my-signal</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>set_my_signal</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    测试新的信号值是否改变了线路上的信号。
    如果是这样，则依次运行每个操作
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    使用下面这个
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>call-each</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>call_each</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    它会依次调用列表中每个无参数的
    <SPLITINLINE>
      <SCHEME>过程:</SCHEME>
      <JAVASCRIPT>函数:</JAVASCRIPT>
    </SPLITINLINE>
<SNIPPET>
      <INDEX><DECLARATION>call_each</DECLARATION></INDEX> 
      <NAME>call_each</NAME>
      <SCHEME>
(define (call-each procedures)
  (if (null? procedures)
      &apos;done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))
      </SCHEME>
      <JAVASCRIPT>
function call_each(functions) {
    if (is_null(functions)) {
        return &quot;done&quot;;
    } else {
        head(functions)();
        return call_each(tail(functions));
    }
}
      </JAVASCRIPT>
    </SNIPPET> 
    局部的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>accept-action-procedure</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>accept_action_function</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    将给定的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    添加到要运行的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    列表中，然后运行新的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    一次。(参见练习<SPACE></SPACE><REF NAME="ex:accept-action"></REF>。)
</TEXT>

  
  <TEXT>
    使用局部的 <SCHEMEINLINE>dispatch</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    按照指定方式设置后，我们可以提供以下
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    以访问线路上的局部操作：<FOOTNOTE>这些
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    仅仅是语法糖，它们通过
    <SPLITINLINE>
      <SCHEME>
        <INDEX>语法糖<SUBINDEX>过程与数据的</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
        <INDEX>语法糖<SUBINDEX>函数与数据的</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>语法接口</INDEX>
    允许我们使用普通的
    <SPLITINLINE>
      <SCHEME>过程式</SCHEME>
      <JAVASCRIPT>函数式</JAVASCRIPT>
    </SPLITINLINE>
    语法来访问对象的局部
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。 令人惊讶的是，我们可以如此简单地互换
    <SPLITINLINE>
      <SCHEME><QUOTE>过程</QUOTE></SCHEME>
      <JAVASCRIPT><QUOTE>函数</QUOTE></JAVASCRIPT>
    </SPLITINLINE>
    和
    <QUOTE>数据</QUOTE>的角色。例如，如果我们写下
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(wire &apos;get-signal)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>wire(&quot;get_signal&quot;)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    我们将 <SCHEMEINLINE>wire</SCHEMEINLINE> 视为一个被传入消息
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-signal</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>&quot;get_signal&quot;</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    调用的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。 或者，写作
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(get-signal wire)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_signal(wire)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    则使我们更倾向于将 <SCHEMEINLINE>wire</SCHEMEINLINE> 看作一个作为
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-signal</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_signal</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    的输入数据对象。 实际情况是，在一种可以将
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    作为对象处理的语言中，
    <QUOTE><SPLITINLINE><SCHEME>过程</SCHEME><JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE></QUOTE>
    与 <QUOTE>数据</QUOTE> 之间没有本质区别，我们可以选择合适的语法糖以允许我们以任意风格编程。
    <LABEL NAME="foot:object-syntax"></LABEL></FOOTNOTE>
    <SNIPPET>
      <INDEX><DECLARATION>get_signal</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_signal</DECLARATION></INDEX> 
      <INDEX><DECLARATION>add_action</DECLARATION></INDEX> 
      <NAME>get_signal</NAME>
      <SCHEME>
(define (get-signal wire)
  (wire &apos;get-signal))
                
(define (set-signal! wire new-value)
  ((wire &apos;set-signal!) new-value))
                

(define (add-action! wire action-procedure)
  ((wire &apos;add-action!) action-procedure))
      </SCHEME>
      <JAVASCRIPT>
function get_signal(wire) {
    return wire(&quot;get_signal&quot;);
}
function set_signal(wire, new_value) {
    return wire(&quot;set_signal&quot;)(new_value);
}
function add_action(wire, action_function) {
    return wire(&quot;add_action&quot;)(action_function);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>


  
  <TEXT>
    线路具有时变信号，并且可能会被逐步附加到设备上，这些都是可变对象的典型特征。我们将它们建模为
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    ，它们具有通过赋值修改的局部状态变量。当创建一个新的线路时，将分配一组新的状态变量（由
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>let</SCHEMEINLINE> expression in</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>let</JAVASCRIPTINLINE> statements in
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-wire</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_wire</JAVASCRIPTINLINE>)</JAVASCRIPT>
    </SPLITINLINE>
    负责，并且一个新的 <SCHEMEINLINE>dispatch</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    被构造并返回，同时捕获了带有新状态变量的环境。
  </TEXT>


  
  <TEXT>
    这些线路被连接到它们的各种设备共享。因此，与某个设备的交互而引起的更改会影响所有连接到该线路的其他设备。该线路通过调用在建立连接时提供给它的行动
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    来向其邻居传递这一更改。
  </TEXT>


  
  <INDEX>数字电路仿真
    <SUBINDEX>表示导线<CLOSE></CLOSE></SUBINDEX>
  </INDEX>

  
  
  <SUBHEADING>
    <NAME>议程</NAME>
  </SUBHEADING>


  <INDEX>digital-circuit simulation<SUBINDEX>agenda<OPEN></OPEN></SUBINDEX></INDEX><!-- Error occurred while translating this section -->

   <TEXT>
    完成模拟器所需的唯一内容是
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>after-delay</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>after_delay</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    这里的理念在于维护一个称为<EM>agenda</EM>的数据结构，其中包含了待执行事项的安排。
    以下为agenda所定义的操作：
    <UL>
      <LI>
        <SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(make-agenda)</SCHEMEINLINE>:</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>make_agenda()</JAVASCRIPTINLINE>:</JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>make_agenda</USE></INDEX> 
	<BR></BR>
	返回一个新的空agenda。
      </LI>
      <LI>
        <SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(empty-agenda? agenda)</SCHEMEINLINE>:</SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>is_empty_agenda(</JAVASCRIPTINLINE><META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>is_empty_agenda</USE></INDEX> 
	<BR></BR>
	当指定的agenda为空时，结果为真。
      </LI>
      <LI>
        <SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(first-agenda-item agenda)</SCHEMEINLINE>:</SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>first_agenda_item(</JAVASCRIPTINLINE><META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>first_agenda_item</USE></INDEX> 
	<BR></BR>
	返回agenda中的第一个项目。
      </LI>
      <LI>
        <SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>(remove-first-agenda-item! agenda)</SCHEMEINLINE>:
	  </SCHEME>
	  <JAVASCRIPT>
            <JAVASCRIPTINLINE>remove_first_agenda_item(</JAVASCRIPTINLINE><META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>remove_first_agenda_item</USE></INDEX> 
	<BR></BR>
        通过移除第一个项目来修改agenda。
      </LI>
      <LI>
        <SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>(add-to-agenda! time action agenda)</SCHEMEINLINE>:
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>add_to_agenda(</JAVASCRIPTINLINE><META>time</META><JAVASCRIPTINLINE>,</JAVASCRIPTINLINE> <META>action</META><JAVASCRIPTINLINE>,</JAVASCRIPTINLINE> <META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>add_to_agenda</USE></INDEX> 
	<BR></BR>
        通过将给定的
        <SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
        （在指定时间执行）添加到agenda中，从而对agenda进行修改。
      </LI>
      <LI>
        <SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(current-time agenda)</SCHEMEINLINE>:</SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>current_time(</JAVASCRIPTINLINE><META>agenda</META><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
        <INDEX><USE>current_time</USE></INDEX> 
	<BR></BR>
        返回当前仿真时间。
      </LI>
    </UL>
  </TEXT> 

   <TEXT>
    我们使用的特定 agenda 用以下方式表示：
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-agenda</SCHEMEINLINE>。</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_agenda</JAVASCRIPTINLINE>。</JAVASCRIPT>
    </SPLITINLINE>
    该
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>after-delay</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>after_delay</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    将新元素添加到
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-agenda</SCHEMEINLINE>：</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_agenda</JAVASCRIPTINLINE>：</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <INDEX><DECLARATION>after_delay</DECLARATION></INDEX> 
      <NAME>after_delay</NAME>
      <REQUIRES>add_to_agenda</REQUIRES>
      <REQUIRES>make_agenda</REQUIRES>
      <REQUIRES>the_agenda</REQUIRES>
      <SCHEME>
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
      </SCHEME>
      <JAVASCRIPT>
function after_delay(delay, action) {
    add_to_agenda(delay + current_time(the_agenda),
                  action,
                  the_agenda);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT> 

   <TEXT>
    <SPLIT>
      <SCHEME>
	模拟由过程
	<SCHEMEINLINE>propagate</SCHEMEINLINE> 驱动，该过程操作
	<SCHEMEINLINE>the-agenda</SCHEMEINLINE>，
	依次执行议程上每个过程。
      </SCHEME>
      <JAVASCRIPT>
	模拟由函数
	<SCHEMEINLINE>propagate</SCHEMEINLINE> 驱动，该函数依次执行
	<JAVASCRIPTINLINE>the_agenda</JAVASCRIPTINLINE> 上的每个函数。
      </JAVASCRIPT>
    </SPLIT>
    通常情况下，随着模拟运行，新项目会被添加到议程中，只要议程中还有项目，
    <SCHEMEINLINE>propagate</SCHEMEINLINE> 就会继续模拟：
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>propagate</DECLARATION></INDEX> 
      <NAME>propagate</NAME>
      <REQUIRES>remove_first_agenda_item</REQUIRES>
      <REQUIRES>first_agenda_item</REQUIRES>
      <REQUIRES>the_agenda</REQUIRES>
      <SCHEME>
(define (propagate)
  (if (empty-agenda? the-agenda)
      &apos;done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
      </SCHEME>
      <JAVASCRIPT>
function propagate() {
    if (is_empty_agenda(the_agenda)) {
        return &quot;done&quot;;
    } else {
        const first_item = first_agenda_item(the_agenda);
        first_item();
        remove_first_agenda_item(the_agenda);
        return propagate();
    }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT> 

   <INDEX>数字电路仿真<SUBINDEX>议程<CLOSE></CLOSE></SUBINDEX></INDEX> 
  
  <LONG_PAGE LINES="1"></LONG_PAGE>
  

  <OPEN></OPEN>
  

  
  <TEXT>
    以下内容
    <SPLITINLINE>
      <SCHEME>过程,</SCHEME>
      <JAVASCRIPT>函数,</JAVASCRIPT>
    </SPLITINLINE>
    ，它在一条导线上放置一个<QUOTE>探针</QUOTE>，展示了仿真器的运行。探针告知导线，每当其信号发生变化时，应打印出新的信号值，同时显示当前时间以及一个用于标识
    <SPLITINLINE>
      <SCHEME>导线:</SCHEME>
      <JAVASCRIPT>
	导线. 
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <INDEX><DECLARATION>探针</DECLARATION><SUBINDEX>在数字电路仿真器中</SUBINDEX></INDEX>
      <NAME>探针</NAME>
      <REQUIRES>议程</REQUIRES>
      <REQUIRES>get_signal</REQUIRES>
      <SCHEME>
(define (probe name wire)
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name)
                 (display &quot; &quot;)
                 (display (current-time the-agenda))
                 (display &quot;  New-value = &quot;)
                 (display (get-signal wire))))
      </SCHEME>
      <JAVASCRIPT>
function probe(name, wire) {
    add_action(wire, 
               () =&gt; display(name + &quot; &quot; +
                             stringify(current_time(the_agenda)) + 
                             &quot;, new value = &quot; + 
                             stringify(get_signal(wire))));
}
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
function probe(name, wire) {
    add_action(wire, 
               () =&gt; name + &quot; &quot; +
                     stringify(current_time(the_agenda)) + 
                     &quot;, new value = &quot; + 
                     stringify(get_signal(wire)));
}
      </JAVASCRIPT_TEST>
    </SNIPPET>
  </TEXT>


  
  <TEXT>
    我们首先初始化议程，并为原始函数盒指定延时：
    <SNIPPET>
      <NAME>the_agenda</NAME>
      <REQUIRES>make_agenda</REQUIRES>
      <SCHEME>
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
      </SCHEME>
      <JAVASCRIPT>
const the_agenda = make_agenda();
const inverter_delay = 2;
const and_gate_delay = 3;
const or_gate_delay = 5;
      </JAVASCRIPT>
    </SNIPPET>
    现在我们定义四根导线，并在其中两根上放置探针：
    <SNIPPET>
      <NAME>probing_two_wires</NAME>
      <REQUIRES>make_wire</REQUIRES>
      <REQUIRES>probe</REQUIRES>
      <SCHEME>
(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))
    
(probe &apos;sum sum)
      </SCHEME>
      <SCHEMEOUTPUT>
    sum 0  New-value = 0
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
const input_1 = make_wire();
const input_2 = make_wire();
const sum = make_wire();
const carry = make_wire();

probe(&quot;sum&quot;, sum);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;sum 0, new value = 0&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>probe_carry</NAME>
      <REQUIRES>probing_two_wires</REQUIRES>
      <SCHEME>
(probe &apos;carry carry)
      </SCHEME>
      <SCHEMEOUTPUT>
carry 0  New-value = 0
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
probe(&quot;carry&quot;, carry);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;carry 0, new value = 0&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    接下来我们将导线连接到半加器电路中（如 图<SPACE></SPACE><REF NAME="fig:half-adder"></REF>所示），将
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>input-1</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>input_1</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    的信号设为 1，并运行仿真：
    <SNIPPET>
      <NAME>half_adder_example_2</NAME>
      <REQUIRES>half_adder</REQUIRES>
      <REQUIRES>probe_carry</REQUIRES>
      <EXPECTED>&apos;ok&apos;</EXPECTED>
      <SCHEME>
(half-adder input-1 input-2 sum carry)
      </SCHEME>
      <SCHEMEOUTPUT>
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
half_adder(input_1, input_2, sum, carry);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;ok&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>set_signal_example</NAME>
      <REQUIRES>half_adder_example_2</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(set-signal! input-1 1)
      </SCHEME>
      <SCHEMEOUTPUT>
done
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_signal(input_1, 1);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;done&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>propagate_example_1</NAME>
      <REQUIRES>set_signal_example</REQUIRES>
      <REQUIRES>propagate</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(propagate)
      </SCHEME>
      <SCHEMEOUTPUT>
sum 8  New-value = 1
done
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
propagate();
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;sum 8, new value = 1&quot;
&quot;done&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SCHEMEINLINE>sum</SCHEMEINLINE> 信号在时间 8 时变为 1。
    此时距仿真开始已过去八个时间单位。
    在此时，我们可以将
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>input-2</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>input_2</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    的信号设为 1，并允许信号传播：
    <SNIPPET>
      <NAME>set_signal_example_2</NAME>
      <REQUIRES>propagate_example_1</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(set-signal! input-2 1)
      </SCHEME>
      <SCHEMEOUTPUT>
                done
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
set_signal(input_2, 1);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;done&quot;	
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>propagate_example_2</NAME>
      <REQUIRES>set_signal_example_2</REQUIRES>
      <EXPECTED>&apos;done&apos;</EXPECTED>
      <SCHEME>
(propagate)
      </SCHEME>
      <SCHEMEOUTPUT>
carry 11  New value = 1
sum 16  New value = 0
done
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
propagate();
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;carry 11, new value = 1&quot;
&quot;sum 16, new value = 0&quot;
&quot;done&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <LONG_PAGE LINES="2"></LONG_PAGE> <SCHEMEINLINE>carry</SCHEMEINLINE> 信号在时间 11 时变为 1，而
    <SCHEMEINLINE>sum</SCHEMEINLINE> 信号在时间 16 时变为 0。
  </TEXT>


  
  <INDEX>数字电路仿真<SUBINDEX>示例仿真<CLOSE></CLOSE></SUBINDEX></INDEX>

  
  <INDEX>半加器<SUBINDEX>仿真&lt;/CLOSE&gt;</SUBINDEX></INDEX>


  
  <EXERCISE>
    <LABEL NAME="ex:accept-action"></LABEL>
    内部的
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>accept-action-procedure!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>accept_action_function</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    在
    <INDEX><USE>make_wire</USE></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-wire</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_wire</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    中规定，当一个新的动作
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    被添加到连线时，该
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    会立即运行。请解释为什么这种初始化是必要的。特别是，跟踪上文段落中的半加器示例，并说明如果我们将
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>accept-action-procedure!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>accept_action_function</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    定义为
    <SNIPPET EVAL="no" POSTPADDING="no">
      <SCHEME>
(define (accept-action-procedure! proc)
  (set! action-procedures (cons proc action-procedures)))
      </SCHEME>
      <JAVASCRIPT>
function accept_action_function(fun) {
   action_functions = pair(fun, action_functions);
}
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>

      
  
  <SUBHEADING> 
    <NAME>实现议程</NAME>
  </SUBHEADING>


  
  <INDEX>数字电路仿真<SUBINDEX>实现议程<OPEN></OPEN></SUBINDEX></INDEX>


  
  <TEXT>
    最后，我们详细介绍了议程数据结构，它保存了预定将来执行的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。
  </TEXT>


  
  <TEXT>
    议程由 
    <INDEX>议程中的时间段</INDEX>
    <EM>时间段</EM>组成。 每个时间段是一对，由一个数字（表示时间）和一个 
    <INDEX>队列<SUBINDEX><ORDER>仿真</ORDER>在仿真议程中</SUBINDEX></INDEX>
    队列构成（参见练习<SPACE></SPACE><REF NAME="ex:agenda-list"></REF>），该队列保存了在该时间段内预定执行的
    <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    。
    <SNIPPET>
      <INDEX><DECLARATION>make_time_segment</DECLARATION></INDEX> 
      <INDEX><DECLARATION>segment_time</DECLARATION></INDEX> 
      <INDEX><DECLARATION>segment_queue</DECLARATION></INDEX> 
      <NAME>make_time_segment</NAME>
      <SCHEME>
(define (make-time-segment time queue)
  (cons time queue))
                
(define (segment-time s) (car s))
                
(define (segment-queue s) (cdr s))
      </SCHEME>
      <JAVASCRIPT>
function make_time_segment(time, queue) {
   return pair(time, queue);
}
function segment_time(s) { return head(s); }
<SHORT_SPACE></SHORT_SPACE>
function segment_queue(s) { return tail(s); }
      </JAVASCRIPT>
    </SNIPPET>
    我们将使用在<SPACE></SPACE><REF NAME="sec:queues"></REF>部分中描述的队列操作来操作时间段队列。
  </TEXT>


  
  <TEXT>
    议程本身是一个一维的
    <INDEX>表<SUBINDEX>在仿真议程中使用</SUBINDEX></INDEX>
    时间段表。它不同于在<SPACE></SPACE><REF NAME="sec:tables"></REF>部分中描述的表，因为这些时间段将按照递增的时间排序。此外，我们在议程的首部存储了
    <INDEX>仿真议程中的当前时间</INDEX>
    <EM>当前时间</EM>（即，上次处理动作的时间）。新构造的议程没有时间段，且当前时间为0：<FOOTNOTE>议程是一个
    <INDEX>有头列表</INDEX>
    <INDEX>列表(s)<SUBINDEX>有头</SUBINDEX></INDEX>
    的有头列表，类似于在<SPACE></SPACE><REF NAME="sec:tables"></REF>部分中的表，但由于列表以时间作为头部，我们不需要额外的虚拟头（例如使用表时所用的
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>*table*</SCHEMEINLINE> 符号
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>&quot;*table*&quot;</JAVASCRIPTINLINE> 字符串
      </JAVASCRIPT>
    </SPLITINLINE>
    ）。</FOOTNOTE>
    <SNIPPET>
      <INDEX><DECLARATION>make_agenda</DECLARATION></INDEX> 
      <INDEX><DECLARATION>current_time</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_current_time</DECLARATION></INDEX> 
      <INDEX><DECLARATION>segments</DECLARATION></INDEX> 
      <INDEX><DECLARATION>set_segments</DECLARATION></INDEX> 
      <INDEX><DECLARATION>first_segment</DECLARATION></INDEX> 
      <INDEX><DECLARATION>rest_segments</DECLARATION></INDEX> 
      <NAME>make_agenda</NAME>
      <SCHEME>
(define (make-agenda) (list 0))
                
(define (current-time agenda) (car agenda))
                
(define (set-current-time! agenda time)
  (set-car! agenda time))
                
(define (segments agenda) (cdr agenda))
                
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
                
(define (first-segment agenda) (car (segments agenda)))
                
(define (rest-segments agenda) (cdr (segments agenda)))
      </SCHEME>
      <JAVASCRIPT>
function make_agenda() { return list(0); }
<SHORT_SPACE></SHORT_SPACE>
function current_time(agenda) { return head(agenda); }
<SHORT_SPACE></SHORT_SPACE>
function set_current_time(agenda, time) {
   set_head(agenda, time);
}
function segments(agenda) { return tail(agenda); }
<SHORT_SPACE></SHORT_SPACE>
function set_segments(agenda, segs) {
   set_tail(agenda, segs);
}
function first_segment(agenda) { return head(segments(agenda)); }
<SHORT_SPACE></SHORT_SPACE>
function rest_segments(agenda) { return tail(segments(agenda)); }
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>


  
  <TEXT>
    如果议程没有时间段，则议程为空：
    <SNIPPET>
      <INDEX><DECLARATION>is_empty_agenda</DECLARATION></INDEX> 
      <NAME>is_empty_agenda</NAME>
      <REQUIRES>make_agenda</REQUIRES>
      <SCHEME>
(define (empty-agenda? agenda)
  (null? (segments agenda)))
      </SCHEME>
      <JAVASCRIPT>
function is_empty_agenda(agenda) {
   return is_null(segments(agenda));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>


  <TEXT>
    To add an action to an agenda, we first check if the agenda is empty.
    If so, we create a time segment for the action and install this in
    the agenda.  Otherwise, we scan the agenda, examining the time of each
    segment.  If we find a segment for our appointed time, we add the
    action to the associated queue.  If we reach a time later than the one
    to which we are appointed, we insert a new time segment into the
    agenda just before it.  If we reach the end of the agenda, we must
    create a new time segment at the end.
    <SNIPPET>
      <INDEX><DECLARATION>add_to_agenda</DECLARATION></INDEX> 
      <NAME>add_to_agenda</NAME>
      <REQUIRES>make_time_segment</REQUIRES>
      <REQUIRES>make_queue</REQUIRES>
      <REQUIRES>insert_queue</REQUIRES>
      <REQUIRES>make_time_segment</REQUIRES>
      <REQUIRES>make_agenda</REQUIRES>
      <SCHEME>
(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (&lt; time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
     (if (= (segment-time (car segments)) time)
         (insert-queue! (segment-queue (car segments))
                        action)
         (let ((rest (cdr segments)))
           (if (belongs-before? rest)
               (set-cdr!
                segments
                (cons (make-new-time-segment time action)
                      (cdr segments)))
               (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
      </SCHEME>
      <JAVASCRIPT>
function add_to_agenda(time, action, agenda) {
   function belongs_before(segs) {
      return is_null(segs) || time &lt; segment_time(head(segs));
   }
   function make_new_time_segment(time, action) {
      const q = make_queue();
      insert_queue(q, action);
      return make_time_segment(time, q);
   }
   function add_to_segments(segs) {
      if (segment_time(head(segs)) === time) {
          insert_queue(segment_queue(head(segs)), action);
      } else {
          const rest = tail(segs);
          if (belongs_before(rest)) {
              set_tail(segs, pair(make_new_time_segment(time, action),
                                  tail(segs)));
          } else {
              add_to_segments(rest);
          }
      }
   }
   const segs = segments(agenda);
   if (belongs_before(segs)) {
       set_segments(agenda,
                    pair(make_new_time_segment(time, action), segs));
   } else {
       add_to_segments(segs);
   }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that removes the first item from the agenda deletes the
    item at the front of the queue in the first time segment.  If this
    deletion makes the time segment empty, we remove it from the list of
    segments:<FOOTNOTE>Observe that the
    <LABEL NAME="foot:one-armed"></LABEL>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE>
	expression in this
	procedure
	has no alternative expression.
      </SCHEME>
      <JAVASCRIPT>
	conditional statement in this
	function has an
	<INDEX>block<SUBINDEX>empty</SUBINDEX></INDEX>
	empty block as its alternative statement.
      </JAVASCRIPT>
    </SPLITINLINE>
    Such a
    <INDEX>conditional statement<SUBINDEX>one-armed (without alternative)</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>one-armed <SCHEMEINLINE>if</SCHEMEINLINE> expression</QUOTE>
      </SCHEME>
      <JAVASCRIPT>
	<QUOTE>one-armed conditional statement</QUOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is used to decide whether to do something, rather than to select between two
    <SPLITINLINE>
      <SCHEME>
	expressions.
	An <SCHEMEINLINE>if</SCHEMEINLINE> expression returns an
	unspecified value if the predicate is false and there is no
	<LATEXINLINE>alternative</LATEXINLINE>.
      </SCHEME>
      <JAVASCRIPT>statements.</JAVASCRIPT>
    </SPLITINLINE>
  </FOOTNOTE>
    <SNIPPET>
      <INDEX><DECLARATION>remove_first_agenda_item</DECLARATION></INDEX> 
      <NAME>remove_first_agenda_item</NAME>
      <REQUIRES>make_agenda</REQUIRES>
      <REQUIRES>is_empty_queue</REQUIRES>
      <REQUIRES>delete_queue</REQUIRES>
      <REQUIRES>make_time_segment</REQUIRES>
      <SCHEME>
(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
      </SCHEME>
      <JAVASCRIPT>
function remove_first_agenda_item(agenda) {
   const q = segment_queue(first_segment(agenda));
   delete_queue(q);
   if (is_empty_queue(q)) {
       set_segments(agenda, rest_segments(agenda));
   } else {}
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT><!-- Error occurred while translating this section -->

  <TEXT>
    The first agenda item is found at the head of the queue in the first
    time segment.  Whenever we extract an item, we also update the current
    time:<FOOTNOTE>In this way, the current time will always be the time
    of the action most recently processed.  Storing this time at the head
    of the agenda ensures that it will still be available even if the
    associated time segment has been deleted.</FOOTNOTE>
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>first_agenda_item</DECLARATION></INDEX> 
      <NAME>first_agenda_item</NAME>
      <REQUIRES>is_empty_agenda</REQUIRES>
      <REQUIRES>make_time_segment</REQUIRES>
      <REQUIRES>front_queue</REQUIRES>
      <SCHEME>
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error &quot;Agenda is empty -- FIRST-AGENDA-ITEM&quot;)
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
      </SCHEME>
      <JAVASCRIPT>
function first_agenda_item(agenda) {
    if (is_empty_agenda(agenda)) {
        error(&quot;agenda is empty -- first_agenda_item&quot;);
    } else {
        const first_seg = first_segment(agenda);
        set_current_time(agenda, segment_time(first_seg));
        return front_queue(segment_queue(first_seg));
    }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT><!-- Error occurred while translating this section -->

  <EXERCISE>
    The
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    to be run during each time segment of the agenda are kept in a queue.
    Thus, the
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for each segment are called in the order in which they were added to the
    agenda (first in, first out).  Explain why this order must be used.  In
    particular, trace the behavior of an and-gate whose inputs change from
    0,1 to 1,0 in the same segment and say how the behavior would differ if
    we stored a segment<APOS></APOS>s
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in an ordinary list, adding and removing
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    only at the front (last in, first out).
    <LABEL NAME="ex:agenda-list"></LABEL>
  </EXERCISE><!-- Error occurred while translating this section -->

  <INDEX>digital-circuit simulation<CLOSE></CLOSE></INDEX><!-- Error occurred while translating this section -->
  <INDEX>digital-circuit simulation<SUBINDEX>agenda implementation<CLOSE></CLOSE></SUBINDEX></INDEX><!-- Error occurred while translating this section -->

</SUBSECTION>
