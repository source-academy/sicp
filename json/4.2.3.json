[{"id":"/sicpjs/4.2.3","tag":"TITLE","body":"4.2.3  \n    Streams as Lazy Lists"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"3.5.1","href":"/sicpjs/3.5.1"},{"body":", we showed how to\n    implement streams as delayed lists.\n    \n\tWe used a\n\t\n\tlambda expression\n      \n    to construct a\n    \"","tag":"#text"},{"body":"promise","tag":"#text"},{"body":"\" to compute the\n    tail\n    of a stream, without actually fulfilling that promise until later.\n    \n\tWe were forced to create streams as a new kind of data object similar\n\tbut not identical to lists, and this required us to reimplement many\n\tordinary list operations (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"map"},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":", and so on) for use with streams.\t\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    With lazy evaluation, streams and lists can be identical, so there is\n    no need for \n    separate list and stream operations. All we need to do is to arrange matters\n    so that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    is non-strict.  One way to accomplish this is to extend the lazy evaluator\n    to allow for non-strict primitives, and to implement\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    as one of these.  An easier way is to recall\n    (section ","tag":"#text"},{"tag":"REF","body":"2.1.3","href":"/sicpjs/2.1.3"},{"body":") that there is no fundamental need\n    to implement\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    as a primitive at all.  Instead, we can represent\n    \n    pairs as\n    functions:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/4.2.3#footnote-1"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"function pair(x, y) {\t\n    return m => m(x, y);\n}\nfunction head(z) {    \n    return z((p, q) => p);\n}\nfunction tail(z) {\n    return z((p, q) => q);\n}"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    In terms of these basic operations, the standard definitions of the list\n    operations will work with infinite lists (streams) as well as finite ones,\n    and the stream operations can be implemented as list operations. Here are\n    some examples:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"function list_ref(items, n) {\t\n    return n === 0\n           ? head(items)\n           : list_ref(tail(items), n - 1);\n}\nfunction map(fun, items) {\t   \n    return is_null(items)\n           ? null\n           : pair(fun(head(items)),\n                  map(fun, tail(items)));\n}\nfunction scale_list(items, factor) {\n    return map(x => x * factor, items);\n}\nfunction add_lists(list1, list2) {\n    return is_null(list1)\n           ? list2\n           : is_null(list2)    \n           ? list1\n           : pair(head(list1) + head(list2),\n                  add_lists(tail(list1), tail(list2)));\n}\nconst ones = pair(1, ones);\nconst integers = pair(1, add_lists(ones, integers));"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"list_ref(integers, 17);","output":"L-evaluate value:\n18"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Note that these lazy lists are even lazier than the streams of\n    chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":":  The\n    head\n    of the list, as well as the\n    tail,\n    is delayed.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/4.2.3#footnote-2"},{"body":"\n    In fact, even accessing the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    or\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    of a lazy pair need not force the value of a list element.  The value will be\n    forced only when it is really needed—e.g., for use as the argument\n    of a primitive, or to be printed as an answer.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Lazy pairs also help with the problem that arose with streams in\n    section ","tag":"#text"},{"tag":"REF","body":"3.5.4","href":"/sicpjs/3.5.4"},{"body":", where we\n    found that formulating stream models of systems with loops may require us to\n    sprinkle our programs with\n    \n\tadditional lambda expressions for\n\t\n\tdelays, beyond the ones required to\n\tconstruct a stream pair.\n      \n    With lazy evaluation, all arguments to\n    functions\n    are delayed uniformly.  For instance, we can implement\n    functions\n    to integrate lists and solve differential equations as we originally\n    intended in section ","tag":"#text"},{"tag":"REF","body":"3.5.4","href":"/sicpjs/3.5.4"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"function integral(integrand, initial_value, dt) {\t\n    const int = pair(initial_value,\n                     add_lists(scale_list(integrand, dt), \n                               int));\n    return int;\n}\nfunction solve(f, y0, dt) {\n    const y = integral(dy, y0, dt);\n    const dy = map(f, y);\n    return y;\n}"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"list_ref(solve(x => x, 1, 0.001), 1000);","output":"L-evaluate value:\n2.716924"}]},{"tag":"EXERCISE","title":"Exercise 4.30","id":"#ex-4.30","child":[{"body":"\n    Give some examples that illustrate the difference between the streams\n    of chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":" and the \"","tag":"#text"},{"body":"lazier","tag":"#text"},{"body":"\" lazy lists described in\n    this section. How can you take advantage of this extra laziness?\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.31","id":"#ex-4.31","child":[{"body":"\n    Ben Bitdiddle tests the lazy list implementation given above by\n    evaluating the expression\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"head(list(\"a\", \"b\", \"c\"));"},{"body":"\n    To his surprise, this produces an error.  After some thought, he realizes\n    that the \"","tag":"#text"},{"body":"lists","tag":"#text"},{"body":"\" obtained\n    \n\tfrom the primitive ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list"},{"body":" function\n      \n    are different from the lists manipulated by the new definitions of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":".\n    Modify \n    \n\tthe evaluator such that applications of the primitive\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list"},{"body":"\n\tfunction\n      \n    typed at the driver loop will produce true lazy lists.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.32","id":"#ex-4.32","child":[{"body":"\n    Modify the driver loop for the evaluator so that lazy pairs and lists will\n    print in some reasonable way.  (What are you going to do about infinite\n    lists?)  You may also need to modify the representation of lazy pairs so\n    that the evaluator can identify them in order to print them.\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/4.2.3#footnote-link-1","child":[{"body":"This\n    is the \n    functional\n    representation described in exercise ","tag":"#text"},{"tag":"REF","body":"2.4","href":"/sicpjs/2.1.3#ex-2.4"},{"body":".\n    Essentially any \n    functional\n    representation (e.g., a message-passing implementation) would do as well.\n    Notice that we can install these definitions in the lazy evaluator simply by\n    typing them at the driver loop.  If we had originally included\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    as primitives in the global environment, they will be redefined.  (Also see\n    exercises ","tag":"#text"},{"tag":"REF","body":"4.31","href":"/sicpjs/4.2.3#ex-4.31"},{"body":"\n    and ","tag":"#text"},{"tag":"REF","body":"4.32","href":"/sicpjs/4.2.3#ex-4.32"},{"body":".)","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/4.2.3#footnote-link-2","child":[{"body":"This permits us to create delayed versions of more\n    general kinds of\n    list structures, not just sequences.\n    Hughes 1990\n    discusses some\n    applications of\n    \"","tag":"#text"},{"body":"lazy trees.","tag":"#text"},{"body":"\"","tag":"#text"}]}]