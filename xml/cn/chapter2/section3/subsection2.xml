<SUBSECTION>
   <NAME>
示例: 符号微分
</NAME> 

  <LABEL NAME="sec:symbolic-differentiation"></LABEL>
   <INDEX>微分<SUBINDEX>符号</SUBINDEX><OPEN></OPEN></INDEX> 
   <INDEX>符号微分<OPEN></OPEN></INDEX> 
   <INDEX>代数表达式<SUBINDEX>求导</SUBINDEX><OPEN></OPEN></INDEX> 

   <TEXT>
作为符号操作的一个示例，以及进一步说明数据抽象，考虑一个设计 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 的情况，它执行代数表达式的符号微分。我们希望 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 以代数表达式和变量作为参数，并返回表达式关于该变量的导数。例如，如果 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 的参数是 $ax^2 + bx +c$ 和$x$，则 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 应返回 $2ax+b$。符号微分在 <SPLITINLINE>  Lisp.  <JAVASCRIPT> 编程语言 Lisp.<FOOTNOTE>本书的原始版本使用编程语言 Scheme，Lisp 的一种方言。</FOOTNOTE> </JAVASCRIPT> </SPLITINLINE> 中具有特殊的历史意义。它是开发符号操作计算机语言的推动示例之一。此外，它标志着研究线的开始，这种研究导致了用于符号数学工作的强大系统的发展，这些系统 <SPLITINLINE>  目前正被越来越多的应用数学家和物理学家使用。  <JAVASCRIPT> 今天被应用数学家和物理学家常规使用。 </JAVASCRIPT> </SPLITINLINE> </TEXT> 
   <TEXT>
在开发符号微分程序时，我们将遵循与开发<REF NAME="sec:rationals"></REF>部分的有理数系统时相同的数据抽象策略。也就是说，我们将首先定义一个微分算法，该算法作用于诸如<QUOTE>和，</QUOTE><QUOTE>积，</QUOTE>和<QUOTE>变量</QUOTE>等抽象对象，而不必担心这些对象应如何表示。只有在此之后，我们才会解决表示问题。
</TEXT> 

   <SUBHEADING>
    <NAME>抽象数据的微分程序</NAME>
  </SUBHEADING> 

   <TEXT>
<SPLITINLINE>

为了

<JAVASCRIPT>
为了
</JAVASCRIPT>
</SPLITINLINE>
简单起见，我们将考虑一个非常简单的符号微分程序，该程序处理仅使用两个参数的加法和乘法运算构建的表达式。任何此类表达式的微分都可以通过应用以下求导<INDEX>规则<SUBINDEX>规则</SUBINDEX></INDEX>化简规则来进行：

\[
\begin{array}{rll}
\dfrac{dc}{dx} &amp; = &amp; 0\quad \text{当 $c$ 为常数或与 $x$ 不同的变量时} \\[12pt]
\dfrac{dx}{dx} &amp; = &amp; 1 \\[12pt]
\dfrac{d(u+v)}{dx} &amp; = &amp; \dfrac{du}{dx}+\dfrac{dv}{dx} \\[12pt]
\dfrac{d(uv)}{dx} &amp; = &amp; u\left( \dfrac{dv}{dx}\right)+v\left( \dfrac{du}{dx}\right)
\end{array}
\]

</TEXT> 
   <TEXT>
注意，后两个规则本质上是递归的。也就是说，为了获得和的导数，我们首先找到项的导数并将它们相加。每一项可能又是一个需要分解的表达式。逐渐分解为越来越小的部分，最终将产生一些要么是常数，要么是变量的部分，其导数将是$0$或$1$。
</TEXT> 
  <TEXT> 
为了在 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 中体现这些规则，我们像设计有理数实现时那样进行一些<INDEX>wishful thinking</INDEX>一厢情愿的想法。如果我们有一种表示代数表达式的方法，我们应该能够判断一个表达式是和、积、常量还是变量。我们应该能够提取表达式的各个部分。例如，对于和，我们希望能够提取加数（第一项）和被加数（第二项）。我们还应该能够从各个部分构造表达式。让我们假设我们已经有 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 来实现以下选择器、构造器和谓词： 
<TABLE>
       <TR>
<TD>
<SPLITINLINE>
(variable? e)
<JAVASCRIPT><JAVASCRIPTINLINE>is_variable(e)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
e是一个变量吗？
</TD>
</TR>
<TR>
<TD>
<SPLITINLINE>
(same-variable? v1 v2)
<JAVASCRIPT>
<JAVASCRIPTINLINE>is_same_variable(v1, v2)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
v1和v2是相同的变量吗？
</TD>
</TR>
<TR DOUBLESPACE="yes">
<TD>
<SPLITINLINE>
(sum? e)
<JAVASCRIPT><JAVASCRIPTINLINE>is_sum(e)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
e是一个和吗？
</TD>
</TR>
<TR>
<TD>
<SPLITINLINE>
(addend e)
<JAVASCRIPT><JAVASCRIPTINLINE>addend(e)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
和的加数e。
</TD>
</TR>
<TR>
<TD>
<SPLITINLINE>
(augend e)
<JAVASCRIPT><JAVASCRIPTINLINE>augend(e)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
和的被加数e。
</TD>
</TR>
 <TR>
<TD>
<SPLITINLINE>
(make-sum a1 a2)
<JAVASCRIPT><JAVASCRIPTINLINE>make_sum(a1, a2)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
构造a1和a2的和。
</TD>
</TR>
<TR DOUBLESPACE="yes">
<TD>
<SPLITINLINE>
(product? e)
<JAVASCRIPT><JAVASCRIPTINLINE>is_product(e)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
e是一个积吗？
</TD>
</TR>
<TR>
<TD>
<SPLITINLINE>
(multiplier e)
<JAVASCRIPT><JAVASCRIPTINLINE>multiplier(e)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
乘积e的乘数。
</TD>
</TR>
<TR>
<TD>
<SPLITINLINE>
(multiplicand e)
<JAVASCRIPT><JAVASCRIPTINLINE>multiplicand(e)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
乘积e的被乘数。
</TD>
</TR>
<TR>
<TD>
<SPLITINLINE>
(make-product m1 m2)
<JAVASCRIPT>
<JAVASCRIPTINLINE>make_product(m1, m2)</JAVASCRIPTINLINE>
</JAVASCRIPT>
</SPLITINLINE>
</TD>
<TD>
构造m1和m2的乘积。
</TD>
</TR>
</TABLE> 
使用这些，以及原语谓词
 
使用这些，以及原语函数<INDEX><USE>is_number</USE>：</INDEX>
<INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>is_number</USE> (\textit{ns})</SUBINDEX></INDEX>
<SPLITINLINE>
number?,
<JAVASCRIPT><JAVASCRIPTINLINE>is_number</JAVASCRIPTINLINE>,</JAVASCRIPT>
</SPLITINLINE>
它识别数字，我们可以将微分规则表达为以下<SPLITINLINE>过程：<JAVASCRIPT>函数：</JAVASCRIPT></SPLITINLINE>
<SNIPPET>
      <INDEX><DECLARATION>deriv</DECLARATION> (symbolic)</INDEX>
      <NAME>deriv</NAME>
      <REQUIRES>is_variable</REQUIRES>
      <REQUIRES>is_same_variable</REQUIRES>
      <REQUIRES>is_sum</REQUIRES>
      <REQUIRES>make_sum</REQUIRES>
      <REQUIRES>addend</REQUIRES>
      <REQUIRES>augend</REQUIRES>
      <REQUIRES>is_product</REQUIRES>
      <REQUIRES>multiplier</REQUIRES>
      <REQUIRES>multiplicand</REQUIRES>
      <EXAMPLE>xyx3</EXAMPLE>
      <EXPECTED>[ &apos;*&apos;, [ &apos;x&apos;, [ &apos;y&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
          (if (same-variable? exp var) 1 0))
        ((sum? exp)
          (make-sum (deriv (addend exp) var)
                    (deriv (augend exp) var)))
        ((product? exp)
          (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
        (else
          (error &quot;unknown expression type -- DERIV&quot; exp))))
      </SCHEME>
      <JAVASCRIPT>
function deriv(exp, variable) {
    return is_number(exp)
           ? 0
           : is_variable(exp)
           ? is_same_variable(exp, variable) ? 1 : 0
           : is_sum(exp)
           ? make_sum(deriv(addend(exp), variable),
                      deriv(augend(exp), variable))
           : is_product(exp)
           ? make_sum(make_product(multiplier(exp),
                                   deriv(multiplicand(exp),
                                         variable)),
                      make_product(deriv(multiplier(exp),
                                         variable),
                                   multiplicand(exp)))
           : error(exp, &quot;unknown expression type -- deriv&quot;);
}
      </JAVASCRIPT>
    </SNIPPET> 
这个
<SCHEMEINLINE>deriv</SCHEMEINLINE>
     
<SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 融合了完整的微分算法。由于它是用抽象数据表示的，所以无论我们选择如何表示代数表达式，只要我们设计出合适的选择器和构造器，它就能够起作用。这是我们接下来必须解决的问题。
</TEXT>

   <SUBHEADING>
<NAME>代数表达式的表示</NAME>
</SUBHEADING> 

   <INDEX>代数表达式<SUBINDEX>表示<OPEN></OPEN></SUBINDEX></INDEX> 
  <TEXT> 
我们可以想象许多使用列表结构来表示代数表达式的方法。例如，我们可以使用反映通常代数符号的符号列表来表示
<LATEXINLINE>$ax+b$</LATEXINLINE> 
将其表示为 <SPLITINLINE> 
列表(a * x + b). 
<JAVASCRIPT> 
<JAVASCRIPTINLINE>list(&quot;a&quot;, &quot;*&quot;, &quot;x&quot;, &quot;+&quot;, &quot;b&quot;)</JAVASCRIPTINLINE>. 
</JAVASCRIPT> 
</SPLITINLINE> 
<SPLITINLINE> 
 不过，一个特别简单的选择是使用与 Lisp 用于组合的相同的带括号的前缀表示法；亦即，将 $ax+b$ 表示为 (+ (* a x) b)。然后我们将 
 
<JAVASCRIPT> 
然而，如果我们在表示中反映表达式的数学结构将更方便；亦即，将 $ax+b$ 表示为 <JAVASCRIPTINLINE>list(&quot;+&quot;, list(&quot;*&quot;, &quot;a&quot;, &quot;x&quot;), &quot;b&quot;)</JAVASCRIPTINLINE>。在操作数前放置一个二元运算符被称为 <INDEX>前缀表示法</INDEX> <EM>前缀表示法</EM>，与 section <REF NAME="sec:expressions"></REF> 中介绍的中缀表示法形成对比。使用前缀表示法，我们的 
</JAVASCRIPT> 
</SPLITINLINE> 
数据表示法如下： 
<UL>
       <LI>
变量是 <SPLITINLINE> 符号。 <JAVASCRIPT>只是字符串。</JAVASCRIPT> </SPLITINLINE> 它们由原语谓词 <INDEX><USE>is_string</USE> (primitive function)</INDEX> <INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>is_string</USE> (\textit{ns})</SUBINDEX></INDEX> <SPLITINLINE> symbol?: <JAVASCRIPT><JAVASCRIPTINLINE>is_string</JAVASCRIPTINLINE>: </JAVASCRIPT> </SPLITINLINE>

<NAME>is_variable_example</NAME>
 (variable? &apos;xyz) 
<JAVASCRIPT> is_variable(&quot;xyz&quot;); </JAVASCRIPT>


<INDEX><DECLARATION>is_variable</DECLARATION><SUBINDEX>for algebraic expressions</SUBINDEX></INDEX> 
<NAME>is_variable</NAME>
<EXAMPLE>is_variable_example</EXAMPLE>
<EXPECTED>true</EXPECTED>
 (define (variable? x) (symbol? x)) 
<JAVASCRIPT> function is_variable(x) { return is_string(x); } </JAVASCRIPT>

</LI>
 <LI>
两个变量是相同的如果 <SPLITINLINE> 表示它们的符号是 eq?:  <JAVASCRIPT>表示它们的字符串相等: </JAVASCRIPT> </SPLITINLINE>

<NAME>is_same_variable_example</NAME>
 (same-variable? &apos;xyz &apos;xyz) 
<JAVASCRIPT> is_same_variable(&quot;xyz&quot;, &quot;xyz&quot;); </JAVASCRIPT>


<INDEX><DECLARATION>is_same_variable</DECLARATION></INDEX> 
<NAME>is_same_variable</NAME>
<EXPECTED>true</EXPECTED>
<REQUIRES>is_variable</REQUIRES>
<EXAMPLE>is_same_variable_example</EXAMPLE>

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

<JAVASCRIPT>
function is_same_variable(v1, v2) {
    return is_variable(v1) &amp;&amp; is_variable(v2) &amp;&amp; v1 === v2;
}
</JAVASCRIPT>

</LI>
 <LI>
和与积被构造为列表：

<NAME>make_sum_example</NAME>
<REQUIRES>make_sum</REQUIRES>
 (make-sum (make-product &apos;x 3) (make-product &apos;y &apos;z)) 
<JAVASCRIPT> make_sum(make_product(&quot;x&quot;, 3), make_product(&quot;y&quot;, &quot;z&quot;)); </JAVASCRIPT>
<JAVASCRIPT_TEST> head(tail(make_sum(make_product(&quot;x&quot;, 3), make_product(&quot;y&quot;, &quot;z;)))); </JAVASCRIPT_TEST>


<INDEX><DECLARATION>make_sum</DECLARATION></INDEX> 
<INDEX><DECLARATION>make_product</DECLARATION></INDEX> 
<NAME>make_sum</NAME>
<EXAMPLE>make_sum_example</EXAMPLE>
<EXPECTED>[ &apos;*&apos;, [ &apos;x&apos;, [ 3, null ] ] ]</EXPECTED>
 (define (make-sum a1 a2) (list &apos;+ a1 a2)) (define (make-product m1 m2) (list &apos;* m1 m2)) 
<JAVASCRIPT> function make_sum(a1, a2) { return list(&quot;+&quot;, a1, a2); }
<SHORT_SPACE></SHORT_SPACE>
function make_product(m1, m2) { return list(&quot;*&quot;, m1, m2); } </JAVASCRIPT>

</LI>
 <LI>
和是一个列表，其第一个元素是 <SPLITINLINE> 符号+: <JAVASCRIPT>字符串<JAVASCRIPTINLINE>&quot;+&quot;</JAVASCRIPTINLINE>:</JAVASCRIPT> </SPLITINLINE>

<NAME>is_sum_example</NAME>
<REQUIRES>make_sum</REQUIRES>
 (sum? (make-sum &apos;x 3)) 
<JAVASCRIPT> is_sum(make_sum(&quot;x&quot;, 3)); </JAVASCRIPT>


<INDEX><DECLARATION>is_sum</DECLARATION></INDEX> 
<NAME>is_sum</NAME>
<EXAMPLE>is_sum_example</EXAMPLE>
<EXPECTED>true</EXPECTED>
 (define (sum? x) (and (pair? x) (eq? (car x) &apos;+))) 
<JAVASCRIPT> function is_sum(x) { return is_pair(x) &amp;&amp; head(x) === &quot;+&quot;; } </JAVASCRIPT>

</LI>
<LI>
和的加数是和列表的第二项：

<NAME>addend_example</NAME>
<REQUIRES>make_sum</REQUIRES>
 (addend (make-sum &apos;x 3)) 
<JAVASCRIPT> addend(make_sum(&quot;x&quot;, 3)); </JAVASCRIPT>


<INDEX><DECLARATION>addend</DECLARATION></INDEX> 
<NAME>addend</NAME>
<EXAMPLE>addend_example</EXAMPLE>
<EXPECTED>&apos;x&apos;</EXPECTED>
 (define (addend s) (cadr s)) 
<JAVASCRIPT> function addend(s) { return head(tail(s)); } </JAVASCRIPT>

</LI>
 <LI>
和的被加数是和列表的第三项：

<NAME>augend_example</NAME>
<REQUIRES>make_sum</REQUIRES>
 (augend (make-sum &apos;x 3)) 
<JAVASCRIPT> augend(make_sum(&quot;x&quot;, 3)); </JAVASCRIPT>


<INDEX><DECLARATION>augend</DECLARATION></INDEX> 
<NAME>augend</NAME>
<EXAMPLE>augend_example</EXAMPLE>
<EXPECTED>3</EXPECTED>
 (define (augend s) (caddr s)) 
<JAVASCRIPT> function augend(s) { return head(tail(tail(s))); } </JAVASCRIPT>

</LI>
<LI>
积是一个列表，其第一个元素是 <SPLITINLINE> 符号*: <JAVASCRIPT>字符串<JAVASCRIPTINLINE>&quot;*&quot;</JAVASCRIPTINLINE>:</JAVASCRIPT> </SPLITINLINE>

<NAME>is_product_example</NAME>
<REQUIRES>make_sum</REQUIRES>
 (is-product (make-product &apos;x 3)) 
<JAVASCRIPT> is_product(make_product(&quot;x&quot;, 3)); </JAVASCRIPT>


<INDEX><DECLARATION>is_product</DECLARATION></INDEX> 
<NAME>is_product</NAME>
<EXPECTED>true</EXPECTED>
<EXAMPLE>is_product_example</EXAMPLE>
 (define (product? x) (and (pair? x) (eq? (car x) &apos;*))) 
<JAVASCRIPT> function is_product(x) { return is_pair(x) &amp;&amp; head(x) === &quot;*&quot;; } </JAVASCRIPT>

</LI>
 <LI>
积的乘数是积列表的第二项：

<NAME>multiplier_example</NAME>
<REQUIRES>make_sum</REQUIRES>
 (multiplier (make-product &apos;x 3)) 
<JAVASCRIPT> multiplier(make_product(&quot;x&quot;, 3)); </JAVASCRIPT>


<INDEX><DECLARATION>multiplier</DECLARATION><SUBINDEX>selector</SUBINDEX></INDEX>
<NAME>multiplier</NAME>
<EXAMPLE>multiplier_example</EXAMPLE>
<EXPECTED>&apos;x&apos;</EXPECTED>
 (define (multiplier p) (cadr p)) 
<JAVASCRIPT> function multiplier(s) { return head(tail(s)); } </JAVASCRIPT>

</LI>
<LI>
积的被乘数是积列表的第三项：

<NAME>multiplicand_example</NAME>
<REQUIRES>make_sum</REQUIRES>
 (multiplicand (make-product &apos;x 3)) 
<JAVASCRIPT> multiplicand(make_product(&quot;x&quot;, 3)); </JAVASCRIPT>


<INDEX><DECLARATION>multiplicand</DECLARATION></INDEX> 
<NAME>multiplicand</NAME>
<EXAMPLE>multiplicand_example</EXAMPLE>
<EXPECTED>3</EXPECTED>
 (define (multiplicand p) (caddr p)) 
<JAVASCRIPT> function multiplicand(s) { return head(tail(tail(s))); } </JAVASCRIPT>

</LI>
</UL> 
因此，我们只需将这些与由体现的算法结合起来
<SCHEMEINLINE>deriv</SCHEMEINLINE> 为了拥有一个工作的符号微分程序。让我们看看它的一些行为示例： <SNIPPET>
      <NAME>deriv_example_8</NAME>
      <REQUIRES>deriv</REQUIRES>
      <EXPECTED>[ &apos;+&apos;, [ 1, [ 0, null ] ] ]</EXPECTED>
      <SCHEME>
(deriv &apos;(+ x 3) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
(+ 1 0)
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(list(&quot;+&quot;, &quot;x&quot;, 3), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
list(&quot;+&quot;, 1, 0)
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>deriv_example_2</NAME>
      <REQUIRES>deriv</REQUIRES>
      <EXPECTED>[ &apos;*&apos;, [ &apos;x&apos;, [ 0, null ] ] ]</EXPECTED>
      <SCHEME>
(deriv &apos;(* x y) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
(+ (* x 0) (* 1 y))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(tail(deriv(list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), &quot;x&quot;)));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(&quot;+&quot;, list(&quot;*&quot;, &quot;x&quot;, 0), list(&quot;*&quot;, 1, &quot;y&quot;))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>xyx3</NAME>
      <REQUIRES>deriv</REQUIRES>
      <EXPECTED>[ &apos;*&apos;, [ &apos;x&apos;, [ &apos;y&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
(deriv &apos;(* (* x y) (+ x 3)) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
(+ (* (* x y) (+ 1 0))
   (* (+ (* x 0) (* 1 y))
      (+  x 3)))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(tail(head(tail(deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;)))));
      </JAVASCRIPT_TEST>
    <JAVASCRIPT_OUTPUT>
list(&quot;+&quot;, list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, 1, 0)),
          list(&quot;*&quot;, list(&quot;+&quot;, list(&quot;*&quot;, &quot;x&quot;, 0), list(&quot;*&quot;, 1, &quot;y&quot;)),
                    list(&quot;+&quot;, &quot;x&quot;, 3)))
    </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
程序生成的答案是正确的；但是，它们是未经化简的。的确
<LATEX>
      \[
      \begin{array}{lll}
      \dfrac{d(xy)}{dx} &amp; = &amp; x\cdot 0+1\cdot y
      \end{array}
      \]
    </LATEX> 
但是我们希望程序能够知道
<LATEXINLINE>$x\cdot 0 = 0$</LATEXINLINE>,
    <LATEXINLINE>$1\cdot y = y$</LATEXINLINE> 
以便使程序知道
<LATEXINLINE>$0+y = y$</LATEXINLINE> 
第二个例子的答案应该只是 
<SCHEMEINLINE>y</SCHEMEINLINE>  正如第三个例子所示，当表达式变得复杂时，这成为一个严重的问题。 </TEXT>
  <TEXT> 
我们的问题很像我们在有理数实现中遇到的问题：<INDEX>代数表达式<SUBINDEX>化简<OPEN></OPEN></SUBINDEX></INDEX> <INDEX>代数表达式的化简</INDEX> 我们还没有将答案化简至最简形式。为了实现有理数的化简，我们只需要更改实现中的构造器和选择器。在这里，我们也可以采用类似的策略。我们不会改变
<SCHEMEINLINE>deriv</SCHEMEINLINE> 
完全不需要。相反，我们将改变 <SPLITINLINE> make-sum <JAVASCRIPT><JAVASCRIPTINLINE>make_sum</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 这样如果两个加数都是数字， <SPLITINLINE> make-sum <JAVASCRIPT><JAVASCRIPTINLINE>make_sum</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 将它们相加并返回它们的和。此外，如果其中一个加数是 0，那么 <SPLITINLINE> make-sum <JAVASCRIPT><JAVASCRIPTINLINE>make_sum</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 将返回另一个加数。
<SNIPPET HIDE="yes">
      <NAME>make_sum_example_2</NAME>
      <SCHEME>
(make-sum 2 3)
      </SCHEME>
      <JAVASCRIPT>
make_sum(2, 3);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>make_sum</DECLARATION></INDEX> 
      <NAME>make_sum_2</NAME>
      <EXAMPLE>make_sum_example_2</EXAMPLE>
      <REQUIRES>number_equal</REQUIRES>
      <EXPECTED>5</EXPECTED>
      <SCHEME>
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list &apos;+ a1 a2))))
      </SCHEME>
      <JAVASCRIPT>
function make_sum(a1, a2) {
    return number_equal(a1, 0)
           ? a2
           : number_equal(a2, 0)
           ? a1
           : is_number(a1) &amp;&amp; is_number(a2)
           ? a1 + a2
           : list(&quot;+&quot;, a1, a2);
}
      </JAVASCRIPT>
    </SNIPPET> 这使用了 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> <SPLITINLINE> =number?, <JAVASCRIPT><JAVASCRIPTINLINE>number_equal</JAVASCRIPTINLINE>, </JAVASCRIPT></SPLITINLINE> 它检查表达式是否等于给定数字： <SNIPPET HIDE="yes">
      <NAME>number_equal_example</NAME>
      <SCHEME>
(number_equal 3 3))
      </SCHEME>
      <JAVASCRIPT>
number_equal(3, 3);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>number_equal</DECLARATION></INDEX> 
      <NAME>number_equal</NAME>
      <EXAMPLE>number_equal_example</EXAMPLE>
      <EXPECTED>true</EXPECTED>
      <SCHEME>
(define (=number? exp num)
  (and (number? exp) (= exp num)))
      </SCHEME>
      <JAVASCRIPT>
function number_equal(exp, num) {
    return is_number(exp) &amp;&amp; exp === num;
}
      </JAVASCRIPT>
    </SNIPPET> 
同样，我们将更改 <SPLITINLINE> make-product <JAVASCRIPT><JAVASCRIPTINLINE>make_product</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 来内置规则，即 0 乘以任何数都是 0，而 1 乘以任何数都是其自身： 
<SNIPPET HIDE="yes">
      <NAME>make_product_example_2</NAME>
      <SCHEME>
(make-product 2 3))
      </SCHEME>
      <JAVASCRIPT>
make_product(2, 3);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>make_product</DECLARATION></INDEX> 
      <NAME>make_product_2</NAME>
      <EXAMPLE>make_product_example_2</EXAMPLE>
      <EXPECTED>6</EXPECTED>
      <REQUIRES>number_equal</REQUIRES>
      <SCHEME>
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list &apos;* m1 m2))))
      </SCHEME>
      <JAVASCRIPT>
function make_product(m1, m2) {
    return number_equal(m1, 0) || number_equal(m2, 0)
           ? 0
           : number_equal(m1, 1)
           ? m2
           : number_equal(m2, 1)
           ? m1
           : is_number(m1) &amp;&amp; is_number(m2)
           ? m1 * m2
           : list(&quot;*&quot;, m1, m2);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>deriv_2</NAME>
      <REQUIRES>is_variable</REQUIRES>
      <REQUIRES>is_same_variable</REQUIRES>
      <REQUIRES>is_sum</REQUIRES>
      <REQUIRES>make_sum_2</REQUIRES>
      <REQUIRES>make_product_2</REQUIRES>
      <REQUIRES>addend</REQUIRES>
      <REQUIRES>augend</REQUIRES>
      <REQUIRES>is_product</REQUIRES>
      <REQUIRES>multiplier</REQUIRES>
      <REQUIRES>multiplicand</REQUIRES>
      <SCHEME>
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
          (if (same-variable? exp var) 1 0))
        ((sum? exp)
          (make-sum (deriv (addend exp) var)
                    (deriv (augend exp) var)))
        ((product? exp)
          (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
        (else
          (error &quot;unknown expression type -- DERIV&quot; exp))))
      </SCHEME>
      <JAVASCRIPT>
function deriv(exp, variable) {
    return is_number(exp)
           ? 0
           : is_variable(exp)
             ? (is_same_variable(exp, variable)) ? 1 : 0
             : is_sum(exp)
               ? make_sum(deriv(addend(exp), variable),
                          deriv(augend(exp), variable))
               : is_product(exp)
                 ? make_sum(make_product(multiplier(exp),
                                deriv(multiplicand(exp),
                                      variable)),
                            make_product(deriv(multiplier(exp),
                                            variable),
                                         multiplicand(exp)))
                 : error(exp, &quot;unknown expression type -- deriv&quot;);
}
      </JAVASCRIPT>
    </SNIPPET> 
以下是此版本在我们的三个示例上的工作方式：
<SNIPPET>
      <NAME>here_is_how</NAME>
      <REQUIRES>deriv_2</REQUIRES>
      <EXPECTED>1</EXPECTED>
      <SCHEME>
(deriv &apos;(+ x 3) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
1
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(list(&quot;+&quot;, &quot;x&quot;, 3), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
1
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>why_y</NAME>
      <REQUIRES>deriv_2</REQUIRES>
      <EXPECTED>&apos;y&apos;</EXPECTED>
      <SCHEME>
(deriv &apos;(* x y) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
y
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
&quot;y&quot;
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>deriv_list_times</NAME>
      <REQUIRES>deriv_2</REQUIRES>
      <EXPECTED>[ &apos;*&apos;, [ &apos;x&apos;, [ &apos;y&apos;, null ] ] ]</EXPECTED>
      <SCHEME>
          (deriv &apos;(* (* x y) (+ x 3)) &apos;x)
      </SCHEME>
      <SCHEMEOUTPUT>
          (+ (* x y) (* y (+ x 3)))
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(tail(deriv(list(&quot;*&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;)));
      </JAVASCRIPT_TEST>
      <JAVASCRIPT_OUTPUT>
list(&quot;+&quot;, list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;), list(&quot;*&quot;, &quot;y&quot;, list(&quot;+&quot;, &quot;x&quot;, 3)))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
尽管这已经有了很大的改进，但第三个例子表明，要让程序将表达式简化成我们可以认为是<QUOTE>最简</QUOTE>的形式，还有很长的路要走。代数化简的问题很复杂，因为，除了其他原因外，最简形式可能因目的不同而不同。<INDEX>代数表达式<SUBINDEX>化简<CLOSE></CLOSE></SUBINDEX></INDEX>
</TEXT>

  <EXERCISE> 
展示如何扩展基本微分器以处理更多种类的表达式。<INDEX>微分<SUBINDEX>规则</SUBINDEX></INDEX> 例如，实现微分规则
<LATEX>
      \[
      \begin{array}{lll}
      \dfrac {d(u^{n})}{dx} &amp; = &amp; nu^{n-1}\left( \dfrac{du}{dx}\right)
      \end{array}
      \]
    </LATEX> 
通过向
<SCHEMEINLINE>deriv</SCHEMEINLINE> 
在程序中添加一个新子句并定义合适的 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> <SPLITINLINE> exponentiation?, <JAVASCRIPT><JAVASCRIPTINLINE>is_exp</JAVASCRIPTINLINE>, </JAVASCRIPT></SPLITINLINE> 
<SCHEMEINLINE>base</SCHEMEINLINE>, <SCHEMEINLINE>exponent</SCHEMEINLINE> 
并且定义合适的 <SPLITINLINE> make-exponentiation. <JAVASCRIPT><JAVASCRIPTINLINE>make_exp</JAVASCRIPTINLINE>.</JAVASCRIPT> </SPLITINLINE> （您可以使用 <SPLITINLINE> 符号** <JAVASCRIPT>字符串<JAVASCRIPTINLINE>&quot;**&quot;</JAVASCRIPTINLINE> </JAVASCRIPT> </SPLITINLINE> 来表示幂运算。）内置这样的规则：任何数的 0 次幂为 1，任何数的 1 次幂为其自身。
<LABEL NAME="ex:deriv-exponentiation"></LABEL>
    <SOLUTION>
      <SNIPPET>
	<NAME>deriv_expo</NAME>
        <REQUIRES>is_variable</REQUIRES>
        <REQUIRES>is_same_variable</REQUIRES>
        <REQUIRES>is_sum</REQUIRES>
        <REQUIRES>make_sum</REQUIRES>
        <REQUIRES>addend</REQUIRES>
        <REQUIRES>augend</REQUIRES>
        <REQUIRES>is_product</REQUIRES>
        <REQUIRES>multiplier</REQUIRES>
        <REQUIRES>multiplicand</REQUIRES>
        <REQUIRES>number_equal</REQUIRES>
	<EXAMPLE>example_deriv_expo</EXAMPLE>
	<EXPECTED>4</EXPECTED>
	<JAVASCRIPT>
function base(e) {
    return head(tail(e));
}
function exponent(e) {
    return head(tail(tail(e)));
}
function make_exp(base, exp) {
    return number_equal(exp, 0)
           ? 1
           : number_equal(exp, 1)
             ? base
             : list(&quot;**&quot;, base, exp);
}
function is_exp(x) {
    return is_pair(x) &amp;&amp; head(x) === &quot;**&quot;;
}
function deriv(exp, variable) {
    return is_number(exp)
           ? 0
           : is_variable(exp)
             ? (is_same_variable(exp, variable) ? 1 : 0)
             : is_sum(exp)
               ? make_sum(deriv(addend(exp), variable),
                          deriv(augend(exp), variable))
               : is_product(exp)
                 ? make_sum(make_product(multiplier(exp),
                                deriv(multiplicand(exp),
                                      variable)),
                            make_product(deriv(multiplier(exp),
                                               variable),
                                multiplicand(exp)))
                 : is_exp(exp)
                   ? make_product(make_product(exponent(exp),
                                      make_exp(
                                          base(exp),
                                          exponent(exp) - 1)),
			          deriv(base(exp), variable))
                   : error(exp, &quot;unknown expression type -- deriv&quot;);
}
	</JAVASCRIPT>
	<SCHEME>
	</SCHEME>
      </SNIPPET>
    </SOLUTION>
    <SNIPPET HIDE="yes">
      <NAME>example_deriv_expo</NAME>
      <JAVASCRIPT>
deriv(list(&quot;**&quot;, &quot;x&quot;, 4), &quot;x&quot;);
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
head(tail(head(tail(deriv(list(&quot;**&quot;, &quot;x&quot;, 4), &quot;x&quot;)))));
      </JAVASCRIPT_TEST>
      <SCHEME>
      </SCHEME>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE> 
扩展微分程序以处理任意数量的（两个或更多）项的和与积。然后，上面的最后一个例子可以表示为
<SNIPPET HIDE="yes">
      <NAME>deriv_3</NAME>
      <REQUIRES>is_variable</REQUIRES>
      <REQUIRES>is_same_variable</REQUIRES>
      <REQUIRES>is_sum</REQUIRES>
      <REQUIRES>make_sum_2</REQUIRES>
      <REQUIRES>make_product_2</REQUIRES>
      <REQUIRES>addend</REQUIRES>
      <REQUIRES>is_product</REQUIRES>
      <REQUIRES>multiplier</REQUIRES>
      <SCHEME>
;; change the representation of terms
;; by defining make_sum, make_product, is_sum, is_product, etc

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
          (if (same-variable? exp var) 1 0))
        ((sum? exp)
          (make-sum (deriv (addend exp) var)
                    (deriv (augend exp) var)))
        ((product? exp)
          (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
        (else
          (error &quot;unknown expression type -- DERIV&quot; exp))))
      </SCHEME>
      <JAVASCRIPT>
// change the representation of terms
// by defining augend and multiplicand

function deriv(exp, variable) {
    return is_number(exp)
           ? 0
           : is_variable(exp)
             ? (is_same_variable(exp, variable) ? 1 : 0)
             : is_sum(exp)
               ? make_sum(deriv(addend(exp), variable),
                          deriv(augend(exp), variable))
               : is_product(exp)
                 ? make_sum(make_product(multiplier(exp),
                                deriv(multiplicand(exp),
                                      variable)),
                            make_product(
                                deriv(multiplier(exp),
                                      variable),
                                multiplicand(exp)))
                 : error(exp, &quot;unknown expression type -- deriv&quot;);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>deriv_3_example</NAME>
      <REQUIRES>deriv_3</REQUIRES>
      <SCHEME>
(deriv &apos;(* x y (+ x 3)) &apos;x)
      </SCHEME>
      <JAVASCRIPT>
deriv(list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;, list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;);
      </JAVASCRIPT>
    </SNIPPET> 
尝试仅通过更改和与积的表示来实现这一点，而不改变
<SCHEMEINLINE>deriv</SCHEMEINLINE>
     
尝试仅通过更改和与积的表示来实现这一点，而不改变 <SPLITINLINE> 过程 <JAVASCRIPT>函数</JAVASCRIPT> </SPLITINLINE> 完全不需要。例如，
<SCHEMEINLINE>addend</SCHEMEINLINE> 
一个和的第一个项会是首项
<SCHEMEINLINE>augend</SCHEMEINLINE> 
的和是其余各项的和。
<SOLUTION>

<NAME>deriv_3_solution_example</NAME>
<JAVASCRIPT>
deriv(list(&quot;*&quot;, &quot;x&quot;, &quot;y&quot;, list(&quot;+&quot;, &quot;x&quot;, 3)), &quot;x&quot;);
</JAVASCRIPT>



<NAME>deriv_3_solution</NAME>
<REQUIRES>deriv_3</REQUIRES>
<EXAMPLE>deriv_3_solution_example</EXAMPLE>

(deriv &apos;(* x y (+ x 3)) &apos;x)

<JAVASCRIPT>
function augend(s) {
    return accumulate(make_sum, 0, tail(tail(s)));
}
function multiplicand(s) {
    return accumulate(make_product, 1, tail(tail(s)));
}
</JAVASCRIPT>

</SOLUTION>
<!--   NOT WORKING!!!
    <SOLUTION>
      <SNIPPET>
	<NAME>try_to_do_this</NAME>
	<EXAMPLE>deriv_4_example</EXAMPLE>
	<EXPECTED>[ '*', [ 'x', [ 0, null ] ] ]</EXPECTED>
	<JAVASCRIPT>
function augend(s) {
    return length(tail(tail(s))) &gt; 1
           ? make_sum(head(tail(tail(s))),
                      tail(tail(tail(s))))
           : head(tail(tail(s)));
}
function multiplicand(s) {
    return length(tail(tail(s))) &gt; 1
           ? make_product(head(tail(tail(s))),
                      tail(tail(tail(s))))
           : head(tail(tail(s)));
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
        <NAME>deriv_4</NAME>
        <REQUIRES>is_variable</REQUIRES>
        <REQUIRES>is_same_variable</REQUIRES>
        <REQUIRES>is_sum</REQUIRES>
        <REQUIRES>make_sum</REQUIRES>
        <REQUIRES>addend</REQUIRES>
        <REQUIRES>is_product</REQUIRES>
        <REQUIRES>multiplier</REQUIRES>
        <SCHEME>
;; change the representation of terms
;; by defining make_sum, make_product, is_sum, is_product, etc

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
          (if (same-variable? exp var) 1 0))
        ((sum? exp)
          (make-sum (deriv (addend exp) var)
                    (deriv (augend exp) var)))
        ((product? exp)
          (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
        (else
          (error "unknown expression type   --><!--   --><!-- -- DERIV" exp))))
        </SCHEME>
        <JAVASCRIPT>
// change the representation of terms
// by defining augend and multiplicand

function deriv(exp, variable) {
    return is_number(exp)
           ? 0
           : is_variable(exp)
             ? (is_same_variable(exp, variable) ? 1 : 0)
             : is_sum(exp)
               ? make_sum(deriv(addend(exp), variable),
                          deriv(augend(exp), variable))
               : is_product(exp)
                 ? make_sum(make_product(multiplier(exp),
                                deriv(multiplicand(exp),
                                      variable)),
                            make_product(deriv(multiplier(exp),
                                               variable),
                                         multiplicand(exp)))
                 : error(exp, "unknown expression type   --><!--   --><!-- -- deriv");
}
	</JAVASCRIPT>
      </SNIPPET>
      <SNIPPET HIDE="yes">
	<NAME>deriv_4_example</NAME>
        <REQUIRES>deriv_4</REQUIRES>
        <SCHEME>
(deriv '(* x y (+ x 3)) 'x)
        </SCHEME>
        <JAVASCRIPT>
deriv(list("*", "x", "y", list("+", "x", 3)), "x");
        </JAVASCRIPT>
        <JAVASCRIPT_TEST>
head(tail(deriv(list("*", "x", "y", list("+", "x", 3)), "x")));
        </JAVASCRIPT_TEST>
      </SNIPPET>
    </SOLUTION>
      -->
    <LABEL NAME="ex:2_57"></LABEL>
  </EXERCISE>

  <EXERCISE> 
假设我们想要修改微分程序，使其适用于普通数学符号，其中 <SPLITINLINE> + <JAVASCRIPT><JAVASCRIPTINLINE>&quot;+&quot;</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 和 <SPLITINLINE> * <JAVASCRIPT><JAVASCRIPTINLINE>&quot;*&quot;</JAVASCRIPTINLINE></JAVASCRIPT> </SPLITINLINE> 是<INDEX>中缀表示法<SUBINDEX>前缀表示法 vs.</SUBINDEX></INDEX>的中缀运算符，而不是前缀运算符。由于微分程序是以抽象数据的形式定义的，我们可以通过仅更改定义微分器需作用的代数表达式的表示方式的谓词、选择器和构造器，来使其适应不同的表达式表示方式。
 <OL>
<LI>
展示如何实现这种方法以便区分以中缀形式表示的代数表达式，
<SPLITINLINE>
例如(x + (3 * (x + (y + 2))))这样的。
<JAVASCRIPT>如下例所示：

<JAVASCRIPT>
list(&quot;x&quot;, &quot;+&quot;, list(3, &quot;*&quot;, list(&quot;x&quot;, &quot;+&quot;, list(&quot;y&quot;, &quot;+&quot;, 2))))
</JAVASCRIPT>

</JAVASCRIPT>
</SPLITINLINE>
为简化任务，假设
<SPLITINLINE>
+
<JAVASCRIPT><JAVASCRIPTINLINE>&quot;+&quot;</JAVASCRIPTINLINE></JAVASCRIPT>
</SPLITINLINE>
和
<SPLITINLINE>
*
<JAVASCRIPT><JAVASCRIPTINLINE>&quot;*&quot;</JAVASCRIPTINLINE></JAVASCRIPT>
</SPLITINLINE>
总是接受两个参数，并且表达式完全用括号括起来。
</LI>
<LI>
如果我们允许使用<INDEX>标准代数符号<SUBINDEX>例如</SUBINDEX></INDEX>，问题就会变得相当复杂，
<SPLITINLINE>
如(x + 3 * (x + y + 2))这样，它省略了不必要的括号，并假设乘法在加法之前执行。
<JAVASCRIPT>更接近普通中缀表示法的表示，它省略了不必要的括号，并假设乘法优先于加法，如本例：

<JAVASCRIPT>
list(&quot;x&quot;, &quot;+&quot;, 3, &quot;*&quot;, list(&quot;x&quot;, &quot;+&quot;, &quot;y&quot;, &quot;+&quot;, 2))
</JAVASCRIPT>

</JAVASCRIPT>
</SPLITINLINE>
您能否为这种符号设计合适的谓词、选择器和构造器，使我们的导数程序仍然正常工作？
</LI>
</OL>
<SOLUTION>
      <OL>
	<LI>
	  <SNIPPET>
            <REQUIRES>is_variable</REQUIRES>
            <REQUIRES>is_same_variable</REQUIRES>
            <REQUIRES>number_equal</REQUIRES>
	    <EXAMPLE>example_2.61_1</EXAMPLE>
	    <EXPECTED>4</EXPECTED>
	    <JAVASCRIPT>
function make_sum(a1, a2) {
    return number_equal(a1, 0)
           ? a2
           : number_equal(a2, 0)
             ?  a1
             : is_number(a1) &amp;&amp; is_number(a2)
               ? a1 + a2
               : list(a1, &quot;+&quot;, a2);
}
function is_sum(x) {
    return is_pair(x) &amp;&amp; head(tail(x)) === &quot;+&quot;;
}
function addend(s) {
    return head(s);
}
function augend(s) {
    return head(tail(tail(s)));
}
function make_product(m1, m2) {
    return number_equal(m1, 0) || number_equal(m2, 0)
           ?  0
           : number_equal(m1, 1)
             ? m2
             : number_equal(m2, 1)
               ?  m1
               : is_number(m1) &amp;&amp; is_number(m2)
                 ? m1 * m2
                 : list(m1, &quot;*&quot;, m2);
}
function is_product(x) {
    return is_pair(x) &amp;&amp; head(tail(x)) === &quot;*&quot;;
}
function multiplier(s) {
    return head(s);
}
function multiplicand(s) {
    return head(tail(tail(s)));
}
function deriv(exp, variable) {
    return is_number(exp)
        ? 0
        : is_variable(exp)
          ? (is_same_variable(exp, variable) ? 1 : 0)
          : is_sum(exp)
            ? make_sum(deriv(addend(exp), variable),
                       deriv(augend(exp), variable))
            : is_product(exp)
              ? make_sum(make_product(multiplier(exp),
                             deriv(multiplicand(exp),
                                   variable)),
                         make_product(deriv(multiplier(
                                                    exp),
                                            variable),
                                      multiplicand(exp)))
              : error(exp, &quot;unknown expression type -- deriv&quot;);
}
	    </JAVASCRIPT>
	    <SCHEME>
	    </SCHEME>
	  </SNIPPET>
	  <SNIPPET HIDE="yes">
	    <NAME>example_2.61_1</NAME>
	    <JAVASCRIPT>
deriv(list(&quot;x&quot;, &quot;*&quot;, 4), &quot;x&quot;);
	    </JAVASCRIPT>
	    <SCHEME>
	    </SCHEME>
	  </SNIPPET>
	</LI>
	<LI>
	  <SNIPPET>
            <REQUIRES>is_variable</REQUIRES>
            <REQUIRES>is_same_variable</REQUIRES>
            <REQUIRES>number_equal</REQUIRES>
	    <EXAMPLE>example_2.61_2</EXAMPLE>
	    <JAVASCRIPT>
function items_before_first(op, s) {
    return is_string(head(s)) &amp;&amp; head(s) === op
           ? null
           : pair(head(s),
                  items_before_first(op, tail(s)));
}
function items_after_first(op, s) {
    return is_string(head(s)) &amp;&amp; head(s) === op
           ? tail(s)
           : items_after_first(op, tail(s));
}
function simplify_unary_list(s) {
    return is_pair(s) &amp;&amp; is_null(tail(s))
           ? head(s)
           : s;
}
function contains_plus(s) {
    return is_null(s)
           ? false
           : is_string(head(s)) &amp;&amp; head(s) === &quot;+&quot;
             ? true
             : contains_plus(tail(s));
}
function make_sum(a1, a2) {
    return number_equal(a1, 0)
           ? a2
           : number_equal(a2, 0)
             ?  a1
             : is_number(a1) &amp;&amp; is_number(a2)
               ? a1 + a2
               : list(a1, &quot;+&quot;, a2);
}
// a sequence of terms and operators is a sum
// if and only if at least one + operator occurs
function is_sum(x) {
    return is_pair(x) &amp;&amp; contains_plus(x);
}
function addend(s) {
    return simplify_unary_list(items_before_first(&quot;+&quot;, s));
}
function augend(s) {
    return simplify_unary_list(items_after_first(&quot;+&quot;, s));
}
function make_product(m1, m2) {
    return number_equal(m1, 0) || number_equal(m2, 0)
           ?  0
           : number_equal(m1, 1)
             ? m2
             : number_equal(m2, 1)
               ?  m1
               : is_number(m1) &amp;&amp; is_number(m2)
                 ? m1 * m2
                 : list(m1, &quot;*&quot;, m2);
}
// a sequence of terms and operators is a product
// if and only if no + operator occurs
function is_product(x) {
    return is_pair(x) &amp;&amp; ! contains_plus(x);
}
function multiplier(s) {
    return simplify_unary_list(items_before_first(&quot;*&quot;, s));
}
function multiplicand(s) {
    return simplify_unary_list(items_after_first(&quot;*&quot;, s));
}
function deriv(exp, variable) {
    return is_number(exp)
        ? 0
        : is_variable(exp)
          ? (is_same_variable(exp, variable) ? 1 : 0)
          : is_sum(exp)
            ? make_sum(deriv(addend(exp), variable),
                       deriv(augend(exp), variable))
            : is_product(exp)
              ? make_sum(make_product(multiplier(exp),
                             deriv(multiplicand(exp),
                                   variable)),
                         make_product(deriv(multiplier(exp),
                                            variable),
                             multiplicand(exp)))
              : error(exp, &quot;unknown expression type -- deriv&quot;);
}
	    </JAVASCRIPT>
	    <SCHEME>
	    </SCHEME>
	  </SNIPPET>

	  <SNIPPET HIDE="yes">
	    <NAME>example_2.61_2</NAME>
	    <JAVASCRIPT>
deriv(list(&quot;x&quot;, &quot;*&quot;, 4), &quot;x&quot;);
	    </JAVASCRIPT>
	    <SCHEME>
	    </SCHEME>
	  </SNIPPET>
	</LI>
      </OL>
    </SOLUTION>
    <LABEL NAME="ex:2_58"></LABEL>
  </EXERCISE>
   <INDEX>代数表达式<SUBINDEX>表示<CLOSE></CLOSE></SUBINDEX></INDEX> 
   <INDEX>微分<SUBINDEX>符号<CLOSE></CLOSE></SUBINDEX></INDEX> 
   <INDEX>符号微分<CLOSE></CLOSE></INDEX> 
   <INDEX>代数表达式<SUBINDEX>求导<CLOSE></CLOSE></SUBINDEX></INDEX> 
</SUBSECTION> --&gt;
