[{"id":"/sicpjs/foreword84","tag":"TITLE","body":"Foreword to Structure and Interpretation of Computer Programs, 1984"},{"tag":"TEXT","id":"#p1","child":[{"body":"\nEducators, generals, dieticians, psychologists, and parents program.\nArmies, students, and some societies are programmed.  An assault on\nlarge problems employs a succession of programs, most of which spring\ninto existence en route.  These programs are rife with issues that\nappear to be particular to the problem at hand.  To appreciate\nprogramming as an intellectual activity in its own right you must turn\nto computer programming; you must read and write computer\nprograms—many of them.  It doesn't matter much what the programs are\nabout or what applications they serve.  What does matter is how well\nthey perform and how smoothly they fit with other programs in the\ncreation of still greater programs.  The programmer must seek both\nperfection of part and adequacy of collection.  In this book the use\nof \"","tag":"#text"},{"body":"program","tag":"#text"},{"body":"\" is focused on the creation, execution, and study of\nprograms written in a dialect of Lisp for execution on a digital\ncomputer.  Using Lisp we restrict or limit not what we may program,\nbut only the notation for our program descriptions.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\nOur traffic with the subject matter of this book involves us with\nthree foci of phenomena: the human mind, collections of computer\nprograms, and the computer.  Every computer program is a model,\nhatched in the mind, of a real or mental process.  These processes,\narising from human experience and thought, are huge in number,\nintricate in detail, and at any time only partially understood.  They\nare modeled to our permanent satisfaction rarely by our computer\nprograms.  Thus even though our programs are carefully handcrafted\ndiscrete collections of symbols, mosaics of interlocking functions,\nthey continually evolve: we change them as our perception of the model\ndeepens, enlarges, generalizes until the model ultimately attains a\nmetastable place within still another model with which we struggle.\nThe source of the exhilaration associated with computer programming is\nthe continual unfolding within the mind and on the computer of\nmechanisms expressed as programs and the explosion of perception they\ngenerate.  If art interprets our dreams, the computer executes them in\nthe guise of programs!\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\nFor all its power, the computer is a harsh taskmaster.  Its programs\nmust be correct, and what we wish to say must be said accurately in\nevery detail.  As in every other symbolic activity, we become\nconvinced of program truth through argument.  Lisp itself can be\nassigned a semantics (another model, by the way), and if a program's\nfunction can be specified, say, in the predicate calculus, the proof\nmethods of logic can be used to make an acceptable correctness\nargument.  Unfortunately, as programs get large and complicated, as\nthey almost always do, the adequacy, consistency, and correctness of\nthe specifications themselves become open to doubt, so that complete\nformal arguments of correctness seldom accompany large programs.\nSince large programs grow from small ones, it is crucial that we\ndevelop an arsenal of standard program structures of whose correctness\nwe have become sure—we call them idioms—and learn to combine them\ninto larger structures using organizational techniques of proven\nvalue.  These techniques are treated at length in this book, and\nunderstanding them is essential to participation in the Promethean\nenterprise called programming.  More than anything else, the\nuncovering and mastery of powerful organizational techniques\naccelerates our ability to create large, significant programs.\nConversely, since writing large programs is very taxing, we are\nstimulated to invent new methods of reducing the mass of function and\ndetail to be fitted into large programs.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\nUnlike programs, computers must obey the laws of physics.  If they\nwish to perform rapidly—a few nanoseconds per state change—they\nmust transmit electrons only small distances (at most\n","tag":"#text"},{"body":"$1\\frac{1}{2}$","tag":"LATEX"},{"body":"\nfeet).  The heat generated by the huge number of devices so\nconcentrated in space has to be removed.  An exquisite engineering art\nhas been developed balancing between multiplicity of function and\ndensity of devices.  In any event, hardware always operates at a level\nmore primitive than that at which we care to program.  The processes\nthat transform our Lisp programs to \"","tag":"#text"},{"body":"machine","tag":"#text"},{"body":"\" programs are\nthemselves abstract models which we program.  Their study and creation\ngive a great deal of insight into the organizational programs\nassociated with programming arbitrary models.  Of course the computer\nitself can be so modeled.  Think of it: the behavior of the smallest\nphysical switching element is modeled by quantum mechanics described\nby differential equations whose detailed behavior is captured by\nnumerical approximations represented in computer programs executing on\ncomputers composed of …!\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\nIt is not merely a matter of tactical convenience to separately\nidentify the three foci.  Even though, as they say, it's all in the\nhead, this logical separation induces an acceleration of symbolic\ntraffic between these foci whose richness, vitality, and potential is\nexceeded in human experience only by the evolution of life itself.  At\nbest, relationships between the foci are metastable.  The computers\nare never large enough or fast enough.  Each breakthrough in hardware\ntechnology leads to more massive programming enterprises, new\norganizational principles, and an enrichment of abstract models.\nEvery reader should ask himself periodically \"","tag":"#text"},{"body":"Toward what end, toward\nwhat end?","tag":"#text"},{"body":"\"—but do not ask it too often lest you pass up the fun of\nprogramming for the constipation of bittersweet philosophy.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\nAmong the programs we write, some (but never enough) perform a precise\nmathematical function such as sorting or finding the maximum of a\nsequence of numbers, determining primality, or finding the square\nroot.  We call such programs algorithms, and a great deal is known of\ntheir optimal behavior, particularly with respect to the two important\nparameters of execution time and data storage requirements.  A\nprogrammer should acquire good algorithms and idioms.  Even though\nsome programs resist precise specifications, it is the responsibility\nof the programmer to estimate, and always to attempt to improve, their\nperformance.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\nLisp is a survivor, having been in use for about a quarter of a\ncentury.  Among the active programming languages only Fortran has had\na longer life.  Both languages have supported the programming needs of\nimportant areas of application, Fortran for scientific and engineering\ncomputation and Lisp for artificial intelligence.  These two areas\ncontinue to be important, and their programmers are so devoted to\nthese two languages that Lisp and Fortran may well continue in active\nuse for at least another quarter-century.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\nLisp changes.  The Scheme dialect used in this text has evolved from\nthe original Lisp and differs from the latter in several important\nways, including static scoping for variable binding and permitting\nfunctions to yield functions as values.  In its semantic structure\nScheme is as closely akin to Algol 60 as to early Lisps.  Algol 60,\nnever to be an active language again, lives on in the genes of Scheme\nand Pascal.  It would be difficult to find two languages that are the\ncommunicating coin of two more different cultures than those gathered\naround these two languages.  Pascal is for building\npyramids—imposing, breathtaking, static structures built by armies\npushing heavy blocks into place.  Lisp is for building\norganisms—imposing, breathtaking, dynamic structures built by squads\nfitting fluctuating myriads of simpler organisms into place.  The\norganizing principles used are the same in both cases, except for one\nextraordinarily important difference: The discretionary exportable\nfunctionality entrusted to the individual Lisp programmer is more than\nan order of magnitude greater than that to be found within Pascal\nenterprises.  Lisp programs inflate libraries with functions whose\nutility transcends the application that produced them.  The list,\nLisp's native data structure, is largely responsible for such growth\nof utility.  The simple structure and natural applicability of lists\nare reflected in functions that are amazingly nonidiosyncratic.  In\nPascal the plethora of declarable data structures induces a\nspecialization within functions that inhibits and penalizes casual\ncooperation.  It is better to have 100 functions operate on one data\nstructure than to have 10 functions operate on 10 data structures.  As\na result the pyramid must stand unchanged for a millennium; the\norganism must evolve or perish.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\nTo illustrate this difference, compare the treatment of material and\nexercises within this book with that in any first-course text using\nPascal.  Do not labor under the illusion that this is a text\ndigestible at MIT only, peculiar to the breed found there.  It is\nprecisely what a serious book on programming Lisp must be, no matter\nwho the student is or where it is used.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\nNote that this is a text about programming, unlike most Lisp books,\nwhich are used as a preparation for work in artificial intelligence.\nAfter all, the critical programming concerns of software engineering\nand artificial intelligence tend to coalesce as the systems under\ninvestigation become larger.  This explains why there is such growing\ninterest in Lisp outside of artificial intelligence.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\nAs one would expect from its goals, artificial intelligence research\ngenerates many significant programming problems.  In other\nprogramming cultures this spate of problems spawns new languages.\nIndeed, in any very large programming task a useful organizing\nprinciple is to control and isolate traffic within the task modules\nvia the invention of language.  These languages tend to become less\nprimitive as one approaches the boundaries of the system where we\nhumans interact most often.  As a result, such systems contain complex\nlanguage-processing functions replicated many times.  Lisp has such a\nsimple syntax and semantics that parsing can be treated as an\nelementary task.  Thus parsing technology plays almost no role in Lisp\nprograms, and the construction of language processors is rarely an\nimpediment to the rate of growth and change of large Lisp systems.\nFinally, it is this very simplicity of syntax and semantics that is\nresponsible for the burden and freedom borne by all Lisp programmers.\nNo Lisp program of any size beyond a few lines can be written without\nbeing saturated with discretionary functions.  Invent and fit; have\nfits and reinvent!  We toast the Lisp programmer who pens his thoughts\nwithin nests of parentheses.\n    ","tag":"#text"}]},{"tag":"EPIGRAPH","child":[{}],"author":" Alan J. Perlis, ","title":"New Haven, Connecticut"}]