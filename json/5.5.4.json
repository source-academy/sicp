[{"id":"/sicpjs/5.5.4","tag":"TITLE","body":"5.5.4  \n    Combining Instruction Sequences"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    This section describes the details on how instruction sequences are\n    represented and combined.  Recall from\n    section ","tag":"#text"},{"tag":"REF","body":"5.5.1","href":"/sicpjs/5.5.1"},{"body":" that an instruction\n    sequence is represented as a list of the registers needed, the registers\n    modified, and the actual instructions.  We will also consider a label\n    (string)\n    to be a degenerate case of an instruction sequence, which\n    doesn't need or modify any registers.\n    So to determine the registers needed\n    and modified by instruction sequences we use the selectors\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"function registers_needed(s) {\n    return is_string(s) ? null : head(s);\n}\nfunction registers_modified(s) {\n    return is_string(s) ? null : head(tail(s));\n}\nfunction instructions(s) {\n    return is_string(s) ? list(s) : head(tail(tail(s)));\n}"},{"body":"\n    and to determine whether a given\n    sequence needs or modifies a given register we use the predicates\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"function needs_register(seq, reg) {\n    return ! is_null(member(reg, registers_needed(seq)));\n}\nfunction modifies_register(seq, reg) {\n    return ! is_null(member(reg, registers_modified(seq)));\n}"},{"body":"\n    In terms of these predicates and selectors, we can implement the\n    various instruction sequence combiners used throughout the compiler.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    The basic combiner is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_instruction_sequences"},{"body":".\n      \n    This takes as\n    arguments\n    two\n    instruction sequences that are to be\n    executed sequentially and returns an instruction sequence whose statements\n    are the statements of\n    the two\n    sequences appended together.\n    The subtle point is to determine the registers that are needed and modified by the resulting sequence.\n    It modifies those registers that\n    are modified by either sequence;\n    it needs those registers that must be initialized before the\n    first sequence can be run (the registers needed by the first sequence), together with those registers needed by\n    the second sequence that are not initialized (modified) by the first sequence.","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_instruction_sequences"},{"body":"\n    is given two instruction sequences ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq2"},{"body":" and returns the instruction sequence whose\n    \n        instructions\n      \n    are the\n    \n        instructions\n      \n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" followed\n    by the\n    \n        instructions\n      \n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq2"},{"body":", whose modified\n    registers are those registers that are modified by either\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" or ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq2"},{"body":", and\n    whose needed registers are the registers needed by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" together with those registers needed by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq2"},{"body":" that are not modified by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":".  (In terms of set operations, the new set\n    of needed registers is the union of the set of registers needed by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" with the set difference of the registers\n    needed by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq2"},{"body":" and the registers modified by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":".)  Thus,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_instruction_sequences"},{"body":"\n    is implemented as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"function append_instruction_sequences(seq1, seq2) {\n    return make_instruction_sequence(\n               list_union(registers_needed(seq1),\n                          list_difference(registers_needed(seq2),\n                                          registers_modified(seq1))),\n               list_union(registers_modified(seq1),\n                          registers_modified(seq2)),\n               append(instructions(seq1), instructions(seq2)));\n}"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    This\n    function\n    uses some simple operations for manipulating sets\n    represented as lists, similar to the (unordered) set representation\n    described in section ","tag":"#text"},{"tag":"REF","body":"2.3.3","href":"/sicpjs/2.3.3"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"function list_union(s1, s2) {\n    return is_null(s1)\n           ? s2\n           : is_null(member(head(s1), s2))\n           ? pair(head(s1), list_union(tail(s1), s2))\n           : list_union(tail(s1), s2);\n}\nfunction list_difference(s1, s2) {\n    return is_null(s1)\n           ? null\n           : is_null(member(head(s1), s2))\n           ? pair(head(s1), list_difference(tail(s1), s2))\n           : list_difference(tail(s1), s2);\n}"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n        The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":",\n      \n    the second major instruction\n    sequence combiner, takes a list of registers\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"regs"},{"body":" and two instruction sequences\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq2"},{"body":" that\n    are to be executed sequentially.  It returns an instruction sequence whose\n    \n        instructions\n      \n    are the\n    \n        instructions\n      \n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" followed\n    by the\n    \n        instructions\n      \n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq2"},{"body":", with appropriate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":"\n    instructions around ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" to protect the\n    registers in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"regs"},{"body":" that are modified by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" but needed by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq2"},{"body":".  To accomplish this,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"preserving"},{"body":" first creates a sequence that has\n    the required ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save"},{"body":"s followed by the\n    \n        instructions\n      \n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" followed by the required\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore"},{"body":"s.  This sequence needs the registers\n    being saved and restored in addition to the registers needed by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":", and modifies the registers modified by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq1"},{"body":" except for the ones being saved and\n    restored.  This augmented sequence and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"seq2"},{"body":"\n    are then appended in the usual way.  The following\n    function\n    implements this strategy recursively, walking down the list of registers to\n    be preserved:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false,"body":"function preserving(regs, seq1, seq2) {\n    if (is_null(regs)) {\n        return append_instruction_sequences(seq1, seq2);\n    } else {\n        const first_reg = head(regs);\n        return needs_register(seq2, first_reg) &&\n               modifies_register(seq1, first_reg)\n               ? preserving(tail(regs),\n                     make_instruction_sequence(\n                         list_union(list(first_reg),\n                                    registers_needed(seq1)),\n                         list_difference(registers_modified(seq1),\n                                         list(first_reg)),\n                         append(list(save(first_reg)),\n                                append(instructions(seq1),\n                                       list(restore(first_reg))))),\n                     seq2)\n               : preserving(tail(regs), seq1, seq2);\n    }\n}"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Another sequence combiner,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tack_on_instruction_sequence"},{"body":",\n      \n    is used by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_lambda_expression"},{"body":"\n    to append a\n    function\n    body to another sequence.  Because the\n    function\n    body is not \"","tag":"#text"},{"body":"in line","tag":"#text"},{"body":"\" to be executed as part of the combined\n    sequence, its register use has no impact on the register use of the sequence\n    in which it is embedded. We thus ignore the\n    function\n    body's sets of needed and modified\n    registers when we tack it onto the other sequence.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"function tack_on_instruction_sequence(seq, body_seq) {\n    return make_instruction_sequence(\n               registers_needed(seq),\n               registers_modified(seq),\n               append(instructions(seq), instructions(body_seq)));\n}"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"The functions\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_conditional"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compile_function_call"},{"body":"\n    use a special combiner called\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"parallel_instruction_sequences"},{"body":"\n    to append the two alternative branches that follow a test.  The two branches\n    will never be executed sequentially; for any particular evaluation of the\n    test, one branch or the other will be entered.  Because of this, the\n    registers needed by the second branch are still needed by the combined\n    sequence, even if these are modified by the first branch.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"function parallel_instruction_sequences(seq1, seq2) {\n    return make_instruction_sequence(\n               list_union(registers_needed(seq1),\n                          registers_needed(seq2)),\n               list_union(registers_modified(seq1),\n                          registers_modified(seq2)),\n               append(instructions(seq1), instructions(seq2)));\n}"}]}]