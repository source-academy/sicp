<SUBSECTION>
  <LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    Compound <SPLITINLINE><SCHEME>Procedures</SCHEME>
    <PYTHON>Functions</PYTHON></SPLITINLINE>
  </NAME>

  <TEXT>
    We have identified in 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <PYTHON>JavaScript</PYTHON>
    </SPLITINLINE>
    some of the elements that must appear in any powerful programming language:
    <UL>
      <LI>
        Numbers and arithmetic operations are primitive data and 
        <SPLITINLINE>
	  <SCHEME>procedures.</SCHEME>
	  <PYTHON>functions.</PYTHON>
	</SPLITINLINE>
      </LI>
      <LI>
        Nesting of combinations provides a means of combining operations.
      </LI>
      <LI>
        Constant declarations that associate names with values provide a
        limited means of abstraction.
      </LI>
    </UL>
    Now we will learn about
    <SPLITINLINE>
      <SCHEME>
	<INDEX>procedure<SUBINDEX>definition of</SUBINDEX></INDEX>
      </SCHEME>
      <PYTHON>
	<INDEX><FUNCTION/><SUBINDEX>declaration of</SUBINDEX><OPEN/></INDEX>
      </PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <EM>procedure definitions</EM>,
      </SCHEME>
      <PYTHON>
	<EM>function declarations</EM>, 
      </PYTHON>
    </SPLITINLINE>
    a much more powerful abstraction technique by which a compound
    operation can be given a name and then referred to as a unit.
  </TEXT>
  <TEXT>
    We begin by examining how to express the idea of
    <QUOTE>squaring.</QUOTE>
    We might say,
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>To square something, multiply it by itself.</QUOTE>
      </SCHEME>
      <PYTHON>
	<QUOTE>To square something, take it times itself.</QUOTE>
      </PYTHON>
    </SPLITINLINE>
    <COMMENT>
      The Scheme and JavaScript phrases differ a bit here, in order to better
      match infix notation in JavaScript.
    </COMMENT>
    This is expressed in our language as 
    <SNIPPET>
      <INDEX><DECLARATION>square</DECLARATION></INDEX>
      <INDEX><USE>function</USE> (keyword)</INDEX>
      <INDEX>keywords<SUBINDEX><ORDER>function</ORDER><USE>function</USE></SUBINDEX></INDEX>
      <NAME>square_definition</NAME>
      <EXAMPLE>square_example</EXAMPLE>
      <SCHEME>
(define (square x) (* x x))
      </SCHEME>
      <PYTHON>
function square(x) {
    return x * x;
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>square_example</NAME>
      <SCHEME>
	(square 14)
      </SCHEME>
      <PYTHON>
square(14);
      </PYTHON>
    </SNIPPET>
  </TEXT>
  <LONG_PAGE lines="1"/>
  <TEXT>
    We can understand this in the following way:
    <WEB_ONLY>
      <SNIPPET EVAL="no">
	<SCHEME>
(define (square x)          (*          x      x))
;;  ^      ^    ^            ^          ^      ^
;;  To   square something,   multiply   it  by itself.
	</SCHEME>
	<PYTHON>
function square(    x   ) { return x    *     x; }
//  ^       ^       ^         ^    ^    ^     ^
// To    square something,  take   it times itself.
	</PYTHON>
      </SNIPPET>
    </WEB_ONLY>

    <PDF_ONLY>
    <LATEX>
      \begin{flushleft}\normalcodesize
      \begin{tabular}{@{}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c}
      \tt\textbf{function} &amp; \tt square(        &amp; \tt x                  &amp;  \tt ) \verb+{+ &amp; \tt\textbf{return} &amp; \tt x          &amp;  \tt *            &amp;   \tt x &amp; \tt; \verb+}+  \\
      $\Big\uparrow$       &amp; $\Big\uparrow$     &amp; $\Big\uparrow$         &amp;                 &amp;                    &amp; $\Big\uparrow$ &amp; $\Big\uparrow$    &amp; $\Big\uparrow$ \\[4pt]
      \normalsize To       &amp; \normalsize square &amp; \normalsize something, &amp;                 &amp; \normalsize take   &amp;\normalsize it  &amp; \normalsize times &amp; \normalsize itself. \\
      \end{tabular}
      \end{flushleft}
      </LATEX>
    </PDF_ONLY>
    We have here a
    <SPLITINLINE>
      <SCHEME>
	<INDEX>compound procedure</INDEX>
	<INDEX>procedure<SUBINDEX>compound</SUBINDEX></INDEX>
	<EM>compound procedure</EM>,
      </SCHEME>
      <PYTHON>
	<INDEX>compound function</INDEX>
	<INDEX><FUNCTION/><SUBINDEX>compound</SUBINDEX></INDEX>
	<EM>compound function</EM>,
      </PYTHON>
    </SPLITINLINE>
    which has been given the name <SCHEMEINLINE>square</SCHEMEINLINE>. The
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <PYTHON>function</PYTHON>
    </SPLITINLINE>
    represents the operation of multiplying something by itself. The thing to
    be multiplied is given a local name, <SCHEMEINLINE>x</SCHEMEINLINE>, 
    which plays the same role that a pronoun plays in natural language.
    <SPLITINLINE>
      <SCHEME>
	<INDEX>naming<SUBINDEX>of procedures</SUBINDEX></INDEX>
	<INDEX>procedure<SUBINDEX>naming (with <TT>define</TT>)</SUBINDEX></INDEX>
	<INDEX>procedure<SUBINDEX>creating with <TT>define</TT></SUBINDEX></INDEX>
      </SCHEME>
      <PYTHON>
	<INDEX>naming<SUBINDEX>of functions</SUBINDEX></INDEX>
	<INDEX><FUNCTION/><SUBINDEX>naming (with function declaration)</SUBINDEX></INDEX>
	<INDEX><FUNCTION/><SUBINDEX>creating with function declaration</SUBINDEX></INDEX>
      </PYTHON>
    </SPLITINLINE>
    Evaluating the
    <SPLITINLINE>
      <SCHEME>
	definition
      </SCHEME>
      <PYTHON>
	declaration
      </PYTHON>
    </SPLITINLINE>
    creates this compound
    <SPLITINLINE>
      <SCHEME>
	procedure
      </SCHEME>
      <PYTHON>
	function
      </PYTHON>
    </SPLITINLINE>
    and associates it with the name
    <INDEX>syntactic forms<SUBINDEX>function declaration</SUBINDEX></INDEX>
    <INDEX><FUNCTION/></INDEX>
    <INDEX>function declaration</INDEX>
    <INDEX>declaration<SUBINDEX><ORDER>function</ORDER>of function (<PYTHONINLINE>function</PYTHONINLINE>)</SUBINDEX></INDEX>
    <SCHEMEINLINE>square</SCHEMEINLINE>.<FOOTNOTE>Observe that there are two
    different operations being combined here: we are creating the
    <SPLITINLINE>
      <SCHEME>
	procedure,
      </SCHEME>
      <PYTHON>
	function,
      </PYTHON>
    </SPLITINLINE>
    and we are giving
    it the name <SCHEMEINLINE>square</SCHEMEINLINE>. It is possible, indeed
    important, to be able to separate these two notions<EMDASH/>to create
    <SPLITINLINE>
      <SCHEME>
	procedures
      </SCHEME>
      <PYTHON>
	functions
      </PYTHON>
    </SPLITINLINE>
    without naming them, and to give names to
    <SPLITINLINE>
      <SCHEME>
	procedures
      </SCHEME>
      <PYTHON>
	functions
      </PYTHON>
    </SPLITINLINE>
    that have already been created. We will see how to do this in
    section<SPACE/><REF NAME="sec:lambda"/>.</FOOTNOTE>
  </TEXT>
  <TEXT>
    <SPLITINLINE>
      <SCHEME>
        The general form of a procedure definition
      </SCHEME>
      <PYTHON>
        The simplest form of a function declaration
      </PYTHON>
    </SPLITINLINE>
    is
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(define ($\langle \textit{name} \rangle$ $\langle\textit{formal parameters}\rangle$) $\langle \textit{body} \rangle$)
      </SCHEME>
      <PYTHON>
function <META>name</META>(<META>parameters</META>) { return <META>expression</META>; }
      </PYTHON>
    </SNIPPET>
    The
    <SPLITINLINE>
      <SCHEME>
	<INDEX>name<SUBINDEX><ORDER>procedure</ORDER>of a procedure</SUBINDEX></INDEX>
	<INDEX>procedure<SUBINDEX>name of</SUBINDEX></INDEX>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE>
      </SCHEME>
      <PYTHON>
	<INDEX>name<SUBINDEX><ORDER>function</ORDER>of a function</SUBINDEX></INDEX>
	<INDEX><FUNCTION/><SUBINDEX>name of</SUBINDEX></INDEX>
	<META>name</META>
      </PYTHON>
    </SPLITINLINE>
    is a symbol to be associated with the
    <SPLITINLINE>
      <SCHEME>
	procedure
      </SCHEME>
      <PYTHON>
	function
      </PYTHON>
    </SPLITINLINE>
    definition in the environment.<FOOTNOTE>Throughout this book, we will
    <INDEX>notation in this book<SUBINDEX>italic symbols in expression syntax</SUBINDEX></INDEX>
    <INDEX>syntax<SUBINDEX><ORDER>expressions</ORDER>of expressions, describing</SUBINDEX></INDEX>
    describe the general syntax of expressions by using italic
    symbols<SPLITINLINE><SCHEME> delimited by angle
    brackets</SCHEME></SPLITINLINE><EMDASH/>e.g.,
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE><EMDASH/>to
      </SCHEME>
      <PYTHON>
	<META>name</META><EMDASH/>to
      </PYTHON>
    </SPLITINLINE>
    denote the <QUOTE>slots</QUOTE> in the expression to be filled in 
    when such an expression is actually used.</FOOTNOTE>
    The
    <SPLITINLINE>
      <SCHEME>
	<INDEX>procedure<SUBINDEX>formal parameters of</SUBINDEX></INDEX>
	<INDEX>formal parameters</INDEX>
      </SCHEME>
      <PYTHON>
	<INDEX><FUNCTION/><SUBINDEX>parameters of</SUBINDEX></INDEX>
	<INDEX>parameters</INDEX>
      </PYTHON>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{formal parameters}\rangle$</LATEXINLINE>
      </SCHEME>
      <PYTHON>
        <META>parameters</META>
      </PYTHON>
    </SPLITINLINE>
    are the names used within the body of the
    <SPLITINLINE>
      <SCHEME>
	procedure
      </SCHEME>
      <PYTHON>
	function
      </PYTHON>
    </SPLITINLINE>
    to refer to the
    corresponding arguments of the
    <SPLITINLINE>
      <SCHEME>
	procedure.
      </SCHEME>
      <PYTHON>
	function.
      </PYTHON>
    </SPLITINLINE>
    <SPLIT>
      <SCHEME>
	The
        <INDEX>procedure<SUBINDEX>body of</SUBINDEX></INDEX>
        <INDEX>body of a procedure</INDEX>
	<LATEXINLINE>$\langle \textit{body} \rangle$</LATEXINLINE>
        is an expression
	that will yield the value of
        the procedure
	application when the formal parameters are replaced by
        the actual arguments to which the
	procedure
	is applied.<FOOTNOTE>More
        <INDEX>sequence of expressions<SUBINDEX><ORDER>procedures</ORDER>in procedure body</SUBINDEX></INDEX>
        generally, the body of the procedure can be a sequence of expressions.
        In this case, the interpreter evaluates each expression in the
        sequence in turn and returns the value of the final expression as the
        value of the procedure application.</FOOTNOTE>
	The <LATEXINLINE>$\langle \textit{name} \rangle$</LATEXINLINE>
	and the
	<LATEXINLINE>$\langle \textit{formal parameters} \rangle$</LATEXINLINE> 
	are grouped within
	<INDEX>parentheses<SUBINDEX><ORDER>procedure</ORDER>in procedure definition</SUBINDEX></INDEX>
	<INDEX>procedure<SUBINDEX>definition of</SUBINDEX></INDEX>
	parentheses, just as they would be in an actual call to the procedure
	being defined.
      </SCHEME>
      <PYTHON>
	The <META>parameters</META>
	are grouped within
	<INDEX>parentheses<SUBINDEX><ORDER>function</ORDER>in function declaration</SUBINDEX></INDEX>
	<INDEX>parentheses<SUBINDEX><ORDER>function</ORDER>in function declaration</SUBINDEX></INDEX>
	parentheses and separated by commas, as they will be in an application
	of the function	being declared.
	<INDEX>return statement</INDEX>
	<INDEX>return value</INDEX>
	<INDEX><USE>return</USE> (keyword)</INDEX>
	<INDEX>syntactic forms<SUBINDEX>return statement</SUBINDEX></INDEX>
	<INDEX>keywords<SUBINDEX><ORDER>return</ORDER><USE>return</USE></SUBINDEX></INDEX>
	In the simplest form, the 
        <INDEX><FUNCTION/><SUBINDEX>body of</SUBINDEX></INDEX>
        <INDEX>body of a function</INDEX>
	<EM>body</EM> of a function declaration is a single
	<EM>return statement</EM>,<FOOTNOTE>More
        <INDEX>sequence of statements<SUBINDEX><ORDER>functions</ORDER>in function body</SUBINDEX></INDEX>
        generally, the body of the function can be a sequence of statements.
	In this case, the interpreter evaluates each statement in the sequence
	in turn until a return statement determines the value of the
	function application.</FOOTNOTE>
	which consists of the keyword
	<PYTHONINLINE>return</PYTHONINLINE>
	followed by the <EM>return expression</EM>
	that will yield the value of the function application, when the
	<SPLITINLINE>
	  <SCHEME>formal</SCHEME>
	</SPLITINLINE>
	parameters are replaced by the actual arguments to which the function
	is applied. Like constant declarations and expression statements,
	return statements
	<INDEX>semicolon (<PYTHONINLINE>;</PYTHONINLINE>)<SUBINDEX>ending statement</SUBINDEX></INDEX>
	<INDEX><FUNCTION/><SUBINDEX>declaration of</SUBINDEX><CLOSE/></INDEX>
	end with a semicolon.
      </PYTHON>
    </SPLIT>
  </TEXT>
  <TEXT>
    <SPLIT>
      <SCHEME>
        Having defined <SCHEMEINLINE>square</SCHEMEINLINE>, 
        we can now use it:
      </SCHEME>
      <PYTHON>
	Having declared <PYTHONINLINE>square</PYTHONINLINE>,
	we can now use it in a
	<EM>function application</EM> expression, which we turn into a statement
	using a semicolon:
      </PYTHON>
    </SPLIT>
    <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square 21)
      </SCHEME>
      <SCHEMEOUTPUT>
441		
      </SCHEMEOUTPUT>
      <PYTHON>
square(21);
      </PYTHON>
      <PYTHON_OUTPUT>
441
      </PYTHON_OUTPUT>
    </SNIPPET>

    <SPLIT>
      <SCHEME>
      </SCHEME>
      <PYTHON>
	<COMMENT>
	  Since operator combinations are syntactically distinct from function
	  applications, the JavaScript version needs to explicitly spell out
	  the evaluation rules for function application here. This prepares
	  the ground for the substitution model in the next sub-section.
	</COMMENT>
	Function applications are<EMDASH/>after operator
	combinations<EMDASH/>the second kind of combination of
	expressions into larger expressions that we encounter.
	The general form of a function application is
        <SNIPPET EVAL="no" LATEX="yes">
          <PYTHON>
<META>function-expression</META>(<META>argument-expressions</META>)
          </PYTHON>
        </SNIPPET>
	where the
	<INDEX>function expression</INDEX>
	<META>function-expression</META>
	of the application specifies
	the function to be applied to the comma-separated
        <INDEX>argument(s)</INDEX>
	<META>argument-expressions</META>.
	To evaluate a function application, the interpreter follows
	<INDEX>evaluation<SUBINDEX>of function application</SUBINDEX></INDEX>
	<INDEX>function application<SUBINDEX>evaluation of</SUBINDEX></INDEX>
	a procedure
	quite similar to the procedure for operator combinations described in
	section<SPACE/><REF NAME="sec:evaluating-combinations"/>.
	<UL>
	  <LI>To evaluate a function application, do the following:
	  <OL>
            <LI>
	      Evaluate the subexpressions of the application, namely
	      the function expression and the argument expressions.
	    </LI>
            <LI>
	      Apply the function that is the value of the function expression
              to the values of the argument expressions.
	    </LI>
	  </OL>
	  </LI>
	</UL>
      </PYTHON>
    </SPLIT>
    <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square (+ 2 5))
      </SCHEME>
      <SCHEMEOUTPUT>
49
      </SCHEMEOUTPUT>
      <PYTHON>
square(2 + 5);
      </PYTHON>
      <PYTHON_OUTPUT>
49		  
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SPLIT>
      <PYTHON>
	Here, the argument expression is itself a compound expression,
	the operator combination <PYTHONINLINE>2 + 5</PYTHONINLINE>.
      </PYTHON>
    </SPLIT>
    <SNIPPET>
      <NAME>square_square</NAME>
      <EXPECTED>81</EXPECTED>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square (square 3))
      </SCHEME>
      <SCHEMEOUTPUT>
81
      </SCHEMEOUTPUT>
      <PYTHON>
square(square(3));
      </PYTHON>
      <PYTHON_OUTPUT>
81
      </PYTHON_OUTPUT>
    </SNIPPET>
    <SPLIT>
    <PYTHON>
      Of course function application expressions can also serve as argument expressions.
    </PYTHON>
    </SPLIT>
  </TEXT>
  
  <TEXT>
    We can also use <SCHEMEINLINE>square</SCHEMEINLINE>
    as a building block in defining other
    <SPLITINLINE>
      <SCHEME>
        procedures.
      </SCHEME>
      <PYTHON>
	functions.
      </PYTHON>
    </SPLITINLINE>
    For example, <LATEXINLINE>$x^2 +y^2$</LATEXINLINE> can be expressed as
    <SNIPPET EVAL="no">
      <SCHEME>
(+ (square x) (square y))
      </SCHEME>
      <PYTHON>
square(x) + square(y)
      </PYTHON>
    </SNIPPET>
    We can easily
    <SPLITINLINE>
      <SCHEME>define</SCHEME>
      <PYTHON>declare</PYTHON>
    </SPLITINLINE>
    a
    <SPLITINLINE>
      <SCHEME>
	procedure
        <SCHEMEINLINE>sum-of-squares</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	function
	<PYTHONINLINE>sum_of_squares</PYTHONINLINE><FOOTNOTE>The
	way multi-part names such as
	<PYTHONINLINE>sum_of_squares</PYTHONINLINE> are written affects
	the readability of programs, and programming communities differ
	on this.
	<INDEX>camel case</INDEX>
	According to the common JavaScript convention, called <EM>camel case</EM>,
	the name would be
	<PYTHONINLINE>sumOfSquares</PYTHONINLINE>. The convention
	<INDEX>naming conventions<SUBINDEX>snake case</SUBINDEX></INDEX>
	<INDEX>snake case</INDEX>
	used in this book is called <EM>snake case</EM>, and was chosen
	for its closer resemblance
	to the convention used in the Scheme version of this book, where
	hyphens play the role of our underscores.</FOOTNOTE>
      </PYTHON>
    </SPLITINLINE>
    that, given any two numbers as arguments, produces the
    sum of their squares:
    <SNIPPET>
      <INDEX><DECLARATION>sum_of_squares</DECLARATION></INDEX>
      <NAME>sum_of_squares</NAME>
      <EXPECTED>25</EXPECTED>
      <EXAMPLE>sum_of_squares_example</EXAMPLE>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
      </SCHEME>
      <PYTHON>
function sum_of_squares(x, y) {
    return square(x) + square(y);
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>sum_of_squares_example</NAME>
      <EXPECTED>25</EXPECTED>
      <REQUIRES>sum_of_squares</REQUIRES>
      <SCHEME>
(sum-of-squares 3 4)
      </SCHEME>
      <SCHEMEOUTPUT>
25
      </SCHEMEOUTPUT>
      <PYTHON>
sum_of_squares(3, 4);
      </PYTHON>
      <PYTHON_OUTPUT>
25
      </PYTHON_OUTPUT>
    </SNIPPET>
    Now we can use
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>sum-of-squares</SCHEMEINLINE>
      </SCHEME>
      <PYTHON>
	<PYTHONINLINE>sum_of_squares</PYTHONINLINE>
      </PYTHON>
    </SPLITINLINE>
    as a building block in constructing further
    <SPLITINLINE>
      <SCHEME>
	procedures:
      </SCHEME>
      <PYTHON>
	functions:
      </PYTHON>
    </SPLITINLINE>
    <SNIPPET>
      <NAME>f</NAME>
      <EXAMPLE>f_example</EXAMPLE>
      <EXPECTED>136</EXPECTED>
      <REQUIRES>sum_of_squares</REQUIRES>
      <SCHEME>
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
      </SCHEME>
      <PYTHON>
function f(a) {
    return sum_of_squares(a + 1, a * 2);
}
      </PYTHON>
    </SNIPPET>
    <SNIPPET>
      <NAME>f_example</NAME>
      <REQUIRES>f</REQUIRES>
      <SCHEME>
(f 5)
      </SCHEME>
      <SCHEMEOUTPUT>
136
      </SCHEMEOUTPUT>
      <PYTHON>
f(5);    
      </PYTHON>
      <PYTHON_OUTPUT>
136		  
      </PYTHON_OUTPUT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    <SPLIT>
      <SCHEME>
        Compound
        <INDEX>compound procedure<SUBINDEX>used like primitive procedure</SUBINDEX></INDEX>
	procedures are used in exactly the same way as primitive
        procedures. Indeed, one could not tell by looking at the definition
        of <SCHEMEINLINE>sum-of-squares</SCHEMEINLINE> given above whether 
        <SCHEMEINLINE>square</SCHEMEINLINE> was built into
        the interpreter, like <SCHEMEINLINE>+</SCHEMEINLINE> and 
        <SCHEMEINLINE>*</SCHEMEINLINE>, 
        or defined as a compound procedure.
      </SCHEME>
      <PYTHON>
	In addition to compound functions, any JavaScript environment provides
	<INDEX><FUNCTION/><SUBINDEX>primitive</SUBINDEX></INDEX>
	<INDEX>primitive function</INDEX>
	primitive functions that are built into the interpreter or loaded
	from libraries.
	<INDEX>JavaScript environment used in this book</INDEX>
	Besides the primitive functions provided by the operators,
	the JavaScript environment used in this book includes
	additional primitive functions
	such as the function
	<INDEX><USE>math_log</USE> (primitive function)</INDEX>
	<INDEX><PRIMITIVE/><SUBINDEX><USE>math_log</USE><ECMA>Math.log</ECMA></SUBINDEX></INDEX>
	<PYTHONINLINE>math_log</PYTHONINLINE>,
	which computes the natural logarithm of its argument.<FOOTNOTE>Our
	JavaScript environment includes all functions and constants of
	ECMAScript's 
	<LINK address="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-math-object">Math object</LINK>,
	under the names <PYTHONINLINE>math_</PYTHONINLINE><LATEXINLINE>$\ldots$</LATEXINLINE>.
	<INDEX>ECMAScript<SUBINDEX><ORDER>Math</ORDER><PYTHONINLINE>Math</PYTHONINLINE> object</SUBINDEX></INDEX>
	For example, ECMAScript's <PYTHONINLINE>Math.log</PYTHONINLINE>
        is available as <PYTHONINLINE>math_log</PYTHONINLINE>.
	The MIT Press
	web page for this book includes the JavaScript package
	<INDEX><USE>sicp</USE> JavaScript package</INDEX>
	<INDEX>JavaScript package <PYTHONINLINE>sicp</PYTHONINLINE></INDEX>
	<PYTHONINLINE>sicp</PYTHONINLINE> that provides these and all other
	JavaScript functions that are considered primitive in the book.
      </FOOTNOTE>
	These additional primitive functions are used in exactly the same way as
	<INDEX>compound function<SUBINDEX>used like primitive function</SUBINDEX></INDEX>
	compound functions; evaluating the application
	<PYTHONINLINE>math_log(1)</PYTHONINLINE> results in the	number 0.
	Indeed, one could not tell by looking at the definition of
	<PYTHONINLINE>sum_of_squares</PYTHONINLINE> given above whether
	<PYTHONINLINE>square</PYTHONINLINE> was built into the
	interpreter, loaded from a library, or defined as a compound function.
      </PYTHON>
    </SPLIT>
  </TEXT>
</SUBSECTION>
