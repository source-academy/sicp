<SUBSECTION>
   <LABEL NAME="sec:compound-procedures"></LABEL><LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    复合 <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
  </NAME><LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    复合 <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
  </NAME>

  <TEXT>
    我们在 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    中识别了一些任何强大编程语言中必须出现的元素：
    <UL>
      <LI>
        数字和算术运算是原始数据和
        <SPLITINLINE>
	  <SCHEME>过程。</SCHEME>
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
        组合的嵌套提供了组合运算的方法。
      </LI>
      <LI>
        将名称与值关联的常量声明提供了一种有限的抽象方式。
      </LI>
    </UL>
    现在我们将学习
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>定义</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><OPEN></OPEN></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <EM>过程定义</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<EM>函数声明</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    一种更强大的抽象技术，通过这种技术，一个复合操作可以被赋予一个名称，然后作为一个单元来引用。
  </TEXT>  <LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    复合 <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
  </NAME>

  <TEXT>
    我们在 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    中识别了一些任何强大编程语言中必须出现的元素：
    <UL>
      <LI>
        数字和算术运算是原始数据和
        <SPLITINLINE>
	  <SCHEME>过程。</SCHEME>
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
        组合的嵌套提供了组合运算的方法。
      </LI>
      <LI>
        将名称与值关联的常量声明提供了一种有限的抽象方式。
      </LI>
    </UL>
    现在我们将学习
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>定义</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><OPEN></OPEN></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <EM>过程定义</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<EM>函数声明</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    一种更强大的抽象技术，通过这种技术，一个复合操作可以被赋予一个名称，然后作为一个单元来引用。
  </TEXT>
  <TEXT>
    我们首先研究如何表达
    <QUOTE>平方</QUOTE>
    的概念。我们可能会说：
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </SCHEME>
      <JAVASCRIPT>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <COMMENT>
      在这里，Scheme和JavaScript的表达略有不同，以更好地匹配JavaScript中的中缀表示法。
    </COMMENT>
    这在我们的语言中表示为
    <SNIPPET>
      <INDEX><DECLARATION>square</DECLARATION></INDEX>
      <INDEX><USE>function</USE> (关键字)</INDEX>
      <INDEX>关键字<SUBINDEX><ORDER>function</ORDER><USE>function</USE></SUBINDEX></INDEX>
      <NAME>square_definition</NAME>
      <EXAMPLE>square_example</EXAMPLE>
      <SCHEME>
(define (square x) (* x x))
      </SCHEME>
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>square_example</NAME>
      <SCHEME>
	(square 14)
      </SCHEME>
      <JAVASCRIPT>
square(14);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>  <LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    复合 <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
  </NAME>

  <TEXT>
    我们在 
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    中识别了一些任何强大编程语言中必须出现的元素：
    <UL>
      <LI>
        数字和算术运算是原始数据和
        <SPLITINLINE>
	  <SCHEME>过程。</SCHEME>
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
        组合的嵌套提供了组合运算的方法。
      </LI>
      <LI>
        将名称与值关联的常量声明提供了一种有限的抽象方式。
      </LI>
    </UL>
    现在我们将学习
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>定义</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><OPEN></OPEN></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <EM>过程定义</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<EM>函数声明</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    一种更强大的抽象技术，通过这种技术，一个复合操作可以被赋予一个名称，然后作为一个单元来引用。
  </TEXT>
  <TEXT>
    我们首先研究如何表达
    <QUOTE>平方</QUOTE>
    的概念。我们可能会说：
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </SCHEME>
      <JAVASCRIPT>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <COMMENT>
      在这里，Scheme和JavaScript的表达略有不同，以更好地匹配JavaScript中的中缀表示法。
    </COMMENT>
    这在我们的语言中表示为
    <SNIPPET>
      <INDEX><DECLARATION>square</DECLARATION></INDEX>
      <INDEX><USE>function</USE> (关键字)</INDEX>
      <INDEX>关键字<SUBINDEX><ORDER>function</ORDER><USE>function</USE></SUBINDEX></INDEX>
      <NAME>square_definition</NAME>
      <EXAMPLE>square_example</EXAMPLE>
      <SCHEME>
(define (square x) (* x x))
      </SCHEME>
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>square_example</NAME>
      <SCHEME>
	(square 14)
      </SCHEME>
      <JAVASCRIPT>
square(14);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <LONG_PAGE lines="1"></LONG_PAGE> <LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    Compound  <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
   </NAME>

  <TEXT>
    We have identified in 
     <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    一些必须出现在任何强大编程语言中的元素：
    <UL>
      <LI>
        数字和算术运算是原始数据和 
        <SPLITINLINE>
	  <SCHEME>过程。</SCHEME>
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
        组合的嵌套提供了组合运算的方法。
      </LI>
      <LI>
        将名称与值关联的常量声明提供了一种有限的抽象方式。
      </LI>
    </UL>
    现在我们将学习
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>定义</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><OPEN></OPEN></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <EM>过程定义</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<EM>函数声明</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    一种更强大的抽象技术，通过这种技术，一个复合操作可以被赋予一个名称，然后作为一个单元来引用。
   </TEXT>
  <TEXT>
    We begin by examining how to express the idea of
     <QUOTE>平方。</QUOTE>
    我们可能会说，
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </SCHEME>
      <JAVASCRIPT>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <COMMENT>
      在这里，为了更好地匹配JavaScript中的中缀表示法，Scheme和JavaScript的表达略有不同。
    </COMMENT>
    这在我们的语言中表示为 
     <SNIPPET>
      <INDEX><DECLARATION>square</DECLARATION></INDEX>
      <INDEX><USE>function</USE> (keyword)</INDEX>
      <INDEX>keywords<SUBINDEX><ORDER>function</ORDER><USE>function</USE></SUBINDEX></INDEX>
      <NAME>square_definition</NAME>
      <EXAMPLE>square_example</EXAMPLE>
      <SCHEME>
(define (square x) (* x x))
      </SCHEME>
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>square_example</NAME>
      <SCHEME>
	(square 14)
      </SCHEME>
      <JAVASCRIPT>
square(14);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <LONG_PAGE lines="1"></LONG_PAGE>
  <TEXT>
    We can understand this in the following way:
     <WEB_ONLY>
      <SNIPPET EVAL="no">
	<SCHEME>
(define (square x)          (*          x      x))
;;  ^      ^    ^            ^          ^      ^
;;  要   平方   某个东西，   将其      乘以  自身。
	</SCHEME>
	<JAVASCRIPT>
function square(    x   ) { return x    *     x; }
//  ^       ^       ^         ^    ^    ^     ^
// 要    平方    某个东西，  将其      乘以  自身。
	</JAVASCRIPT>
      </SNIPPET>
    </WEB_ONLY>

    <PDF_ONLY>
    <LATEX>
      \begin{flushleft}\normalcodesize
      \begin{tabular}{@{}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c}
      \tt\textbf{function} &amp; \tt square(        &amp; \tt x                  &amp;  \tt ) \verb+{+ &amp; \tt\textbf{return} &amp; \tt x          &amp;  \tt *            &amp;   \tt x &amp; \tt; \verb+}+  \\
      $\Big\uparrow$       &amp; $\Big\uparrow$     &amp; $\Big\uparrow$         &amp;                 &amp;                    &amp; $\Big\uparrow$ &amp; $\Big\uparrow$    &amp; $\Big\uparrow$ \\[4pt]
      \normalsize 要       &amp; \normalsize 平方   &amp; \normalsize 某个东西， &amp;                 &amp; \normalsize 将其   &amp;\normalsize    乘以 &amp; \normalsize 自身. \\
      \end{tabular}
      \end{flushleft}
      </LATEX>
    </PDF_ONLY>
    我们这里有一个
    <SPLITINLINE>
      <SCHEME>
	<INDEX>复合过程</INDEX>
	<INDEX>过程<SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合过程</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>复合函数</INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合函数</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    它被赋予了一个名称  <SCHEMEINLINE>square</SCHEMEINLINE>. The
     <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    代表了将某个东西乘以自身的运算。要被乘的东西被赋予一个本地名称，  <SCHEMEINLINE>x</SCHEMEINLINE>, 
    which plays the same role that a pronoun plays in natural language.
     <SPLITINLINE>
      <SCHEME>
	<INDEX>过程命名<SUBINDEX>使用 <TT>define</TT> 进行命名</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>用 <TT>define</TT> 创建</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>命名</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>函数命名<SUBINDEX>of functions</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明命名</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明创建</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    评估
    <SPLITINLINE>
      <SCHEME>
	定义
      </SCHEME>
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    创建这个复合
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    并将其与名称关联
    <INDEX>语法形式<SUBINDEX>函数声明</SUBINDEX></INDEX>
    <INDEX><FUNCTION></FUNCTION></INDEX>
    <INDEX>函数声明</INDEX>
    <INDEX>声明<SUBINDEX><ORDER>函数</ORDER>函数的 (function)</SUBINDEX></INDEX>
     <SCHEMEINLINE>square</SCHEMEINLINE>. <FOOTNOTE>注意，这里结合了两种不同的操作：我们正在创建
    <SPLITINLINE>
      <SCHEME>
	过程，
      </SCHEME>
      <JAVASCRIPT>
	函数，
      </JAVASCRIPT>
    </SPLITINLINE>
    并且我们正在给它命名为<SCHEMEINLINE>square</SCHEMEINLINE>。能够分离这两种概念是可能的，确实是重要的<EMDASH></EMDASH>创建
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    而不命名它们，以及给已创建的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    命名。在<SPACE></SPACE><REF NAME="sec:lambda"></REF>节中我们将看到如何做到这一点。</FOOTNOTE>
   </TEXT><LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    Compound  <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
   </NAME>

  <TEXT>
    We have identified in 
     <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    一些必须出现在任何强大编程语言中的元素：
    <UL>
      <LI>
        数字和算术运算是原始数据和 
        <SPLITINLINE>
	  <SCHEME>过程。</SCHEME>
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
        组合的嵌套提供了组合运算的方法。
      </LI>
      <LI>
        将名称与值关联的常量声明提供了一种有限的抽象方式。
      </LI>
    </UL>
    现在我们将学习
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>定义</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><OPEN></OPEN></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <EM>过程定义</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<EM>函数声明</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    一种更强大的抽象技术，通过这种技术，一个复合操作可以被赋予一个名称，然后作为一个单元来引用。
   </TEXT>
  <TEXT>
    We begin by examining how to express the idea of
     <QUOTE>平方。</QUOTE>
    我们可能会说，
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </SCHEME>
      <JAVASCRIPT>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <COMMENT>
      在这里，Scheme和JavaScript的表达略有不同，以更好地匹配JavaScript中的中缀表示法。
    </COMMENT>
    这在我们的语言中表示为 
     <SNIPPET>
      <INDEX><DECLARATION>square</DECLARATION></INDEX>
      <INDEX><USE>function</USE> (keyword)</INDEX>
      <INDEX>keywords<SUBINDEX><ORDER>function</ORDER><USE>function</USE></SUBINDEX></INDEX>
      <NAME>square_definition</NAME>
      <EXAMPLE>square_example</EXAMPLE>
      <SCHEME>
(define (square x) (* x x))
      </SCHEME>
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>square_example</NAME>
      <SCHEME>
	(square 14)
      </SCHEME>
      <JAVASCRIPT>
square(14);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <LONG_PAGE lines="1"></LONG_PAGE>
  <TEXT>
    We can understand this in the following way:
     <WEB_ONLY>
      <SNIPPET EVAL="no">
	<SCHEME>
(define (square x)          (*          x      x))
;;  ^      ^    ^            ^          ^      ^
;;  要   平方   某个东西，   将其      乘以  自身。
	</SCHEME>
	<JAVASCRIPT>
function square(    x   ) { return x    *     x; }
//  ^       ^       ^         ^    ^    ^     ^
// 要    平方    某个东西，  将其      乘以  自身。
	</JAVASCRIPT>
      </SNIPPET>
    </WEB_ONLY>

    <PDF_ONLY>
    <LATEX>
      \begin{flushleft}\normalcodesize
      \begin{tabular}{@{}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c}
      \tt\textbf{function} &amp; \tt square(        &amp; \tt x                  &amp;  \tt ) \verb+{+ &amp; \tt\textbf{return} &amp; \tt x          &amp;  \tt *            &amp;   \tt x &amp; \tt; \verb+}+  \\
      $\Big\uparrow$       &amp; $\Big\uparrow$     &amp; $\Big\uparrow$         &amp;                 &amp;                    &amp; $\Big\uparrow$ &amp; $\Big\uparrow$    &amp; $\Big\uparrow$ \\[4pt]
      \normalsize 要       &amp; \normalsize 平方   &amp; \normalsize 某个东西， &amp;                 &amp; \normalsize 将其   &amp;\normalsize    乘以 &amp; \normalsize 自身. \\
      \end{tabular}
      \end{flushleft}
      </LATEX>
    </PDF_ONLY>
    我们这里有一个
    <SPLITINLINE>
      <SCHEME>
	<INDEX>复合过程</INDEX>
	<INDEX>过程<SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合过程</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>复合函数</INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合函数</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    它被赋予了一个名称  <SCHEMEINLINE>square</SCHEMEINLINE>. The
     <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    代表了将某个东西乘以自身的运算。要被乘的东西被赋予一个本地名称，  <SCHEMEINLINE>x</SCHEMEINLINE>, 
    which plays the same role that a pronoun plays in natural language.
     <SPLITINLINE>
      <SCHEME>
	<INDEX>过程命名<SUBINDEX>使用 <TT>define</TT> 进行命名</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>用 <TT>define</TT> 创建</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>命名</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>函数命名<SUBINDEX>of functions</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明命名</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明创建</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    评估
    <SPLITINLINE>
      <SCHEME>
	定义
      </SCHEME>
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    创建这个复合
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    并将其与名称关联
    <INDEX>语法形式<SUBINDEX>函数声明</SUBINDEX></INDEX>
    <INDEX><FUNCTION></FUNCTION></INDEX>
    <INDEX>函数声明</INDEX>
    <INDEX>声明<SUBINDEX><ORDER>函数</ORDER>函数的 (function)</SUBINDEX></INDEX>
     <SCHEMEINLINE>square</SCHEMEINLINE>. <FOOTNOTE>注意，这里结合了两种不同的操作：我们正在创建
    <SPLITINLINE>
      <SCHEME>
	过程，
      </SCHEME>
      <JAVASCRIPT>
	函数，
      </JAVASCRIPT>
    </SPLITINLINE>
    并且我们正在给它命名为<SCHEMEINLINE>square</SCHEMEINLINE>。能够分离这两种概念是可能的，确实是重要的<EMDASH></EMDASH>创建
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    而不命名它们，以及给已创建的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    命名。在<SPACE></SPACE><REF NAME="sec:lambda"></REF>节中我们将看到如何做到这一点。</FOOTNOTE>
   </TEXT>
  <TEXT> 
    <SPLITINLINE>
      <SCHEME>
        过程定义的一般形式
      </SCHEME>
      <JAVASCRIPT>
        函数声明的最简单形式
      </JAVASCRIPT>
    </SPLITINLINE>
    是
     <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(define ($\langle \textit{name} \rangle$ $\langle\textit{formal parameters}\rangle$) $\langle \textit{body} \rangle$)
      </SCHEME>
      <JAVASCRIPT>
function <META>name</META>(<META>parameters</META>) { return <META>expression</META>; }
      </JAVASCRIPT>
    </SNIPPET>
    The
     
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程名称<SUBINDEX><ORDER>过程</ORDER>名称</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>的名称</SUBINDEX></INDEX>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>函数名称<SUBINDEX><ORDER>函数</ORDER>名称</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>的名称</SUBINDEX></INDEX>
	<META>名称</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    是与环境中的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    定义关联的符号。<FOOTNOTE>在整本书中，我们将
    <INDEX>本书中的符号<SUBINDEX>表达式语法中的斜体符号</SUBINDEX></INDEX>
    <INDEX>语法<SUBINDEX><ORDER>表达式</ORDER>的描述</SUBINDEX></INDEX>
    通过使用斜体符号来描述表达式的一般语法<SPLITINLINE><SCHEME> 以尖括号
    包围</SCHEME></SPLITINLINE><EMDASH></EMDASH>例如，
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE><EMDASH></EMDASH>表示
      </SCHEME>
      <JAVASCRIPT>
	<META>名称</META><EMDASH></EMDASH>表示
      </JAVASCRIPT>
    </SPLITINLINE>
    表达式中需要被填入的<QUOTE>槽</QUOTE>，在实际使用这样的表达式时。</FOOTNOTE>
    The
    <SPLITINLINE>
      <SCHEME>
	<INDEX>形式参数<SUBINDEX>过程的</SUBINDEX></INDEX>
	<INDEX>形式参数</INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>的参数</SUBINDEX></INDEX>
	<INDEX>参数</INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{形式参数}\rangle$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <META>参数</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    是在
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    的主体中用于引用所对应论据的名称。
    <SPLITINLINE>
      <SCHEME>
	过程。
      </SCHEME>
      <JAVASCRIPT>
	函数。
      </JAVASCRIPT>
    </SPLITINLINE>
     <SPLIT> 
      <SCHEME>
	过程的
        <INDEX>主体<SUBINDEX>过程的</SUBINDEX></INDEX>
        <INDEX>过程主体</INDEX>
	<LATEXINLINE>$\langle \textit{body} \rangle$</LATEXINLINE>
        是一个表达式
	当形式参数被实际参数替换，即过程被应用到的实际参数时，该表达式将产生过程应用的值。<FOOTNOTE>更
        <INDEX>表达式序列<SUBINDEX><ORDER>过程</ORDER>在过程主体中</SUBINDEX></INDEX>
        一般来说，过程的主体可以是一个表达式序列。在这种情况下，解释器依次评估序列中的每个表达式，并将最后一个表达式的值作为过程应用的值返回。</FOOTNOTE>
	<LATEXINLINE>$\langle \textit{name} \rangle$</LATEXINLINE>
	和
	<LATEXINLINE>$\langle \textit{formal parameters} \rangle$</LATEXINLINE> 
	被括在一起
	<INDEX>括号<SUBINDEX><ORDER>过程</ORDER>在过程定义中</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>定义的</SUBINDEX></INDEX>
	括号内，就像在过程的实际调用中一样。
      </SCHEME>
        <JAVASCRIPT>
	<META>参数</META>
	被括在一起
	<INDEX>括号<SUBINDEX><ORDER>函数</ORDER>在函数声明中</SUBINDEX></INDEX>
	<INDEX>括号<SUBINDEX><ORDER>函数</ORDER>在函数声明中</SUBINDEX></INDEX>
	括号内并用逗号分隔，就像在函数声明的应用中一样。
	<INDEX>返回语句</INDEX>
	<INDEX>返回值</INDEX>
	<INDEX><USE>return</USE> (关键字)</INDEX>
	<INDEX>语法结构<SUBINDEX>返回语句</SUBINDEX></INDEX>
	<INDEX>关键字<SUBINDEX><ORDER>return</ORDER><USE>return</USE></SUBINDEX></INDEX>
	在最简单的形式中，
        <INDEX><FUNCTION></FUNCTION><SUBINDEX>的主体</SUBINDEX></INDEX>
        <INDEX>函数的主体</INDEX>
	<EM>主体</EM>是一个单一的函数声明
	<EM>返回语句</EM>，<FOOTNOTE>更
        <INDEX>语句序列<SUBINDEX><ORDER>函数</ORDER>在函数主体中</SUBINDEX></INDEX>
        一般来说，函数的主体可以是一系列语句。在这种情况下，解释器依次评估序列中的每个语句，直到返回语句确定函数应用的值。</FOOTNOTE>
	它由关键字
	<JAVASCRIPTINLINE>return</JAVASCRIPTINLINE>
	后跟<EM>返回表达式</EM>组成
	当形式参数被实际参数替换，即函数被应用到的实际参数时，该表达式将产生函数应用的值。就像常量声明和表达式语句一样，
	返回语句
	<INDEX>分号 (<JAVASCRIPTINLINE>;</JAVASCRIPTINLINE>)<SUBINDEX>结束语句</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><CLOSE></CLOSE></INDEX>
	以分号结束。
      </JAVASCRIPT>
     </SPLIT>
  </TEXT><LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    Compound  <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
   </NAME>

  <TEXT>
    We have identified in 
     <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    一些必须出现在任何强大编程语言中的元素：
    <UL>
      <LI>
        数字和算术运算是原始数据和 
        <SPLITINLINE>
	  <SCHEME>过程。</SCHEME>
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
        组合的嵌套提供了组合运算的方法。
      </LI>
      <LI>
        将名称与值关联的常量声明提供了一种有限的抽象方式。
      </LI>
    </UL>
    现在我们将学习
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>定义</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><OPEN></OPEN></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <EM>过程定义</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<EM>函数声明</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    一种更强大的抽象技术，通过这种技术，一个复合操作可以被赋予一个名称，然后作为一个单元来引用。
   </TEXT>
  <TEXT>
    We begin by examining how to express the idea of
     <QUOTE>平方。</QUOTE>
    我们可能会说，
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </SCHEME>
      <JAVASCRIPT>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <COMMENT>
      在这里，Scheme和JavaScript的表达略有不同，以更好地匹配JavaScript中的中缀表示法。
    </COMMENT>
    这在我们的语言中表示为 
     <SNIPPET>
      <INDEX><DECLARATION>square</DECLARATION></INDEX>
      <INDEX><USE>function</USE> (keyword)</INDEX>
      <INDEX>keywords<SUBINDEX><ORDER>function</ORDER><USE>function</USE></SUBINDEX></INDEX>
      <NAME>square_definition</NAME>
      <EXAMPLE>square_example</EXAMPLE>
      <SCHEME>
(define (square x) (* x x))
      </SCHEME>
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>square_example</NAME>
      <SCHEME>
	(square 14)
      </SCHEME>
      <JAVASCRIPT>
square(14);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <LONG_PAGE lines="1"></LONG_PAGE>
  <TEXT>
    We can understand this in the following way:
     <WEB_ONLY>
      <SNIPPET EVAL="no">
	<SCHEME>
(define (square x)          (*          x      x))
;;  ^      ^    ^            ^          ^      ^
;;  要    平方  某个东西，   将其       乘以  自身。
	</SCHEME>
	<JAVASCRIPT>
function square(    x   ) { return x    *     x; }
//  ^       ^       ^         ^    ^    ^     ^
// 要    平方    某个东西，  将其       乘以    自身。
	</JAVASCRIPT>
      </SNIPPET>
    </WEB_ONLY>

    <PDF_ONLY>
    <LATEX>
      \begin{flushleft}\normalcodesize
      \begin{tabular}{@{}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c}
      \tt\textbf{function} &amp; \tt square(        &amp; \tt x                  &amp;  \tt ) \verb+{+ &amp; \tt\textbf{return} &amp; \tt x          &amp;  \tt *            &amp;   \tt x &amp; \tt; \verb+}+  \\
      $\Big\uparrow$       &amp; $\Big\uparrow$     &amp; $\Big\uparrow$         &amp;                 &amp;                    &amp; $\Big\uparrow$ &amp; $\Big\uparrow$    &amp; $\Big\uparrow$ \\[4pt]
      \normalsize 要       &amp; \normalsize 平方   &amp; \normalsize 某个东西, &amp;                 &amp; \normalsize 将其   &amp;\normalsize 乘以 &amp; \normalsize 自身. \\
      \end{tabular}
      \end{flushleft}
      </LATEX>
    </PDF_ONLY>
    我们这里有一个
    <SPLITINLINE>
      <SCHEME>
	<INDEX>复合过程</INDEX>
	<INDEX>过程<SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合过程</EM>,
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>复合函数</INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合函数</EM>,
      </JAVASCRIPT>
    </SPLITINLINE>
    它被赋予了一个名称  <SCHEMEINLINE>square</SCHEMEINLINE>. The
     <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    代表了将某个东西乘以自身的运算。要被乘的东西被赋予一个本地名称，  <SCHEMEINLINE>x</SCHEMEINLINE>, 
    which plays the same role that a pronoun plays in natural language.
     <SPLITINLINE>
      <SCHEME>
	<INDEX>过程命名<SUBINDEX>的命名</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>使用<TT>define</TT>命名</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>使用<TT>define</TT>创建</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>函数命名<SUBINDEX>的命名</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明命名</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明创建</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    评估
    <SPLITINLINE>
      <SCHEME>
	定义
      </SCHEME>
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    创建这个复合
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    并将其与名称关联
    <INDEX>语法形式<SUBINDEX>函数声明</SUBINDEX></INDEX>
    <INDEX><FUNCTION></FUNCTION></INDEX>
    <INDEX>函数声明</INDEX>
    <INDEX>声明<SUBINDEX><ORDER>函数</ORDER>函数的声明 (<JAVASCRIPTINLINE>function</JAVASCRIPTINLINE>)</SUBINDEX></INDEX>
     <SCHEMEINLINE>square</SCHEMEINLINE>. <FOOTNOTE>注意，这里结合了两种不同的操作：我们正在创建
    <SPLITINLINE>
      <SCHEME>
	过程，
      </SCHEME>
      <JAVASCRIPT>
	函数，
      </JAVASCRIPT>
    </SPLITINLINE>
    并且我们正在给它命名为<SCHEMEINLINE>square</SCHEMEINLINE>。能够分离这两种概念是可能的，确实是重要的<EMDASH></EMDASH>创建
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    而不命名它们，以及给已创建的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    命名。在<SPACE></SPACE><REF NAME="sec:lambda"></REF>节中我们将看到如何做到这一点。</FOOTNOTE>
   </TEXT>
  <TEXT> 
    <SPLITINLINE>
      <SCHEME>
        过程定义的一般形式
      </SCHEME>
      <JAVASCRIPT>
        函数声明的最简单形式
      </JAVASCRIPT>
    </SPLITINLINE>
    是
     <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(define ($\langle \textit{name} \rangle$ $\langle\textit{formal parameters}\rangle$) $\langle \textit{body} \rangle$)
      </SCHEME>
      <JAVASCRIPT>
function <META>name</META>(<META>parameters</META>) { return <META>expression</META>; }
      </JAVASCRIPT>
    </SNIPPET>
    The
     
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程名称<SUBINDEX><ORDER>过程</ORDER>的名称</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>的名称</SUBINDEX></INDEX>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>函数名称<SUBINDEX><ORDER>函数</ORDER>的名称</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>的名称</SUBINDEX></INDEX>
	<META>名称</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    是要与环境中的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    定义相关联的符号。<FOOTNOTE>在整本书中，我们将
    <INDEX>本书中的符号<SUBINDEX>表达式语法中的斜体符号</SUBINDEX></INDEX>
    <INDEX>语法<SUBINDEX><ORDER>表达式</ORDER>的语法描述</SUBINDEX></INDEX>
    通过使用斜体符号来描述表达式的一般语法<SPLITINLINE><SCHEME> 用尖括号
    分隔</SCHEME></SPLITINLINE><EMDASH></EMDASH>例如，
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE><EMDASH></EMDASH>表示
      </SCHEME>
      <JAVASCRIPT>
	<META>名称</META><EMDASH></EMDASH>表示
      </JAVASCRIPT>
    </SPLITINLINE>
    表达式中需要被填入的<QUOTE>槽</QUOTE>，在实际使用这样的表达式时。</FOOTNOTE>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>形式参数</SUBINDEX></INDEX>
	<INDEX>形式参数</INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>的参数</SUBINDEX></INDEX>
	<INDEX>参数</INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{formal parameters}\rangle$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <META>参数</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    是过程的主体中用来引用
    对应的实参的名称。
    <SPLITINLINE>
      <SCHEME>
	过程。
      </SCHEME>
      <JAVASCRIPT>
	函数。
      </JAVASCRIPT>
    </SPLITINLINE>
     <SPLIT> 
      <SCHEME>
	过程的
        <INDEX>主体<SUBINDEX>的过程</SUBINDEX></INDEX>
        <INDEX>过程主体</INDEX>
	<LATEXINLINE>$\langle \textit{body} \rangle$</LATEXINLINE>
        是一种表达式
	当形式参数被
        过程
	应用的实际参数替换时，将产生
        的值。<FOOTNOTE>更
        <INDEX>表达式序列<SUBINDEX><ORDER>过程</ORDER>在过程主体中</SUBINDEX></INDEX>
        通常，过程的主体可以是一个表达式序列。
        在这种情况下，解释器依次评估序列中的每个表达式，并将最终表达式的值作为过程应用的值返回。</FOOTNOTE>
	<LATEXINLINE>$\langle \textit{name} \rangle$</LATEXINLINE>
	和
	<LATEXINLINE>$\langle \textit{formal parameters} \rangle$</LATEXINLINE> 
	在
	<INDEX>括号<SUBINDEX><ORDER>过程</ORDER>在过程定义中</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>定义的</SUBINDEX></INDEX>
	括号内分组，就像在实际调用要定义的过程时一样。
      </SCHEME>
        <JAVASCRIPT>
	<META>参数</META>
	在
	<INDEX>括号<SUBINDEX><ORDER>函数</ORDER>在函数声明中</SUBINDEX></INDEX>
	<INDEX>括号<SUBINDEX><ORDER>函数</ORDER>在函数声明中</SUBINDEX></INDEX>
	括号内分组并用逗号分隔，就像在函数声明的应用中一样。
	<INDEX>返回语句</INDEX>
	<INDEX>返回值</INDEX>
	<INDEX><USE>return</USE> (关键字)</INDEX>
	<INDEX>语法形式<SUBINDEX>返回语句</SUBINDEX></INDEX>
	<INDEX>关键字<SUBINDEX><ORDER>return</ORDER><USE>return</USE></SUBINDEX></INDEX>
	在最简单的形式中，
        <INDEX><FUNCTION></FUNCTION><SUBINDEX>主体的</SUBINDEX></INDEX>
        <INDEX>函数主体</INDEX>
	<EM>主体</EM> 是一个单一的函数声明
	<EM>返回语句</EM>，<FOOTNOTE>更
        <INDEX>语句序列<SUBINDEX><ORDER>函数</ORDER>在函数主体中</SUBINDEX></INDEX>
        一般来说，函数的主体可以是一系列语句。
	在这种情况下，解释器依次评估序列中的每个语句，直到返回语句确定函数应用的值。</FOOTNOTE>
	它由关键字
	<JAVASCRIPTINLINE>return</JAVASCRIPTINLINE>
	后跟<EM>返回表达式</EM>组成
	当
	<SPLITINLINE>
	  <SCHEME>形式</SCHEME>
	</SPLITINLINE>
	参数被实际参数替换，即函数被应用到的实际参数时，该表达式将产生函数应用的值。就像常量声明和表达式语句，
	返回语句
	<INDEX>分号 (<JAVASCRIPTINLINE>;</JAVASCRIPTINLINE>)<SUBINDEX>结束语句</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><CLOSE></CLOSE></INDEX>
	以分号结束。
      </JAVASCRIPT>
     </SPLIT>
  </TEXT>
  <TEXT> 
    <SPLIT>
      <SCHEME>
        定义了<SCHEMEINLINE>square</SCHEMEINLINE>之后，
        我们现在可以使用它：
      </SCHEME>
      <JAVASCRIPT>
	声明了<JAVASCRIPTINLINE>square</JAVASCRIPTINLINE>之后，
	我们现在可以在
	<EM>函数应用</EM>表达式中使用它，并通过使用分号将其转化为一个语句：
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square 21)
      </SCHEME>
      <SCHEMEOUTPUT>
441		
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(21);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
441
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 

    <SPLIT>
      <SCHEME>
      </SCHEME>
      <JAVASCRIPT>
	<COMMENT>
	  由于运算符组合在句法上与函数应用不同，JavaScript版本需要在这里明确说明函数应用的评估规则。这为下一小节的替换模型奠定了基础。
	</COMMENT>
	函数应用是<EMDASH></EMDASH>继运算符
	组合之后的<EMDASH></EMDASH>我们遇到的第二种将
	表达式组合成更大表达式的方法。
	函数应用的一般形式是
        <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
<META>函数表达式</META>(<META>参数表达式</META>)
          </JAVASCRIPT>
        </SNIPPET>
	其中应用的
	<INDEX>函数表达式</INDEX>
	<META>函数表达式</META>
	指定了要应用于以逗号分隔的
        <INDEX>参数</INDEX>
	<META>参数表达式</META>的函数。
	为了评估函数应用，解释器遵循
	<INDEX>评估<SUBINDEX>函数应用</SUBINDEX></INDEX>
	<INDEX>函数应用<SUBINDEX>的评估</SUBINDEX></INDEX>
	一个过程，与
	在<SPACE></SPACE><REF NAME="sec:evaluating-combinations"></REF>节中描述的运算符组合过程非常相似。
	<UL>
	  <LI>评估函数应用时，进行以下操作：
	  <OL>
            <LI>
	      评估应用的子表达式，即
	      函数表达式和参数表达式。
	    </LI>
            <LI>
	      将函数表达式的值所代表的函数
              应用到参数表达式的值上。
	    </LI>
	  </OL>
	  </LI>
	</UL>
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square (+ 2 5))
      </SCHEME>
      <SCHEMEOUTPUT>
49
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(2 + 5);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
49		  
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    <SPLIT>
      <JAVASCRIPT>
	这里，参数表达式本身是一个复合表达式，
	运算符组合 <JAVASCRIPTINLINE>2 + 5</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET>
      <NAME>square_square</NAME>
      <EXPECTED>81</EXPECTED>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square (square 3))
      </SCHEME>
      <SCHEMEOUTPUT>
81
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(square(3));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
81
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    <SPLIT>
    <JAVASCRIPT>
      当然，函数应用表达式也可以作为参数表达式。
    </JAVASCRIPT>
    </SPLIT>
   </TEXT><LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    Compound  <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
   </NAME>

  <TEXT>
    We have identified in 
     <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    一些必须出现在任何强大编程语言中的元素：
    <UL>
      <LI>
        数字和算术运算是原始数据和 
        <SPLITINLINE>
	  <SCHEME>过程。</SCHEME>
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
        组合的嵌套提供了组合运算的方法。
      </LI>
      <LI>
        将名称与值关联的常量声明提供了一种有限的抽象方式。
      </LI>
    </UL>
    现在我们将学习
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>定义</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><OPEN></OPEN></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <EM>过程定义</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<EM>函数声明</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    一种更强大的抽象技术，通过这种技术，一个复合操作可以被赋予一个名称，然后作为一个单元来引用。
   </TEXT>
  <TEXT>
    We begin by examining how to express the idea of
     <QUOTE>平方。</QUOTE>
    我们可能会说，
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </SCHEME>
      <JAVASCRIPT>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <COMMENT>
      在这里，Scheme和JavaScript的表达略有不同，以更好地匹配JavaScript中的中缀表示法。
    </COMMENT>
    这在我们的语言中表示为 
     <SNIPPET>
      <INDEX><DECLARATION>square</DECLARATION></INDEX>
      <INDEX><USE>function</USE> (keyword)</INDEX>
      <INDEX>keywords<SUBINDEX><ORDER>function</ORDER><USE>function</USE></SUBINDEX></INDEX>
      <NAME>square_definition</NAME>
      <EXAMPLE>square_example</EXAMPLE>
      <SCHEME>
(define (square x) (* x x))
      </SCHEME>
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>square_example</NAME>
      <SCHEME>
	(square 14)
      </SCHEME>
      <JAVASCRIPT>
square(14);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <LONG_PAGE lines="1"></LONG_PAGE>
  <TEXT>
    We can understand this in the following way:
     <WEB_ONLY>
      <SNIPPET EVAL="no">
	<SCHEME>
(define (square x)          (*          x      x))
;;  ^      ^    ^            ^          ^      ^
;;  要   平方   某个东西，   将其      乘以  自身。
	</SCHEME>
	<JAVASCRIPT>
function square(    x   ) { return x    *     x; }
//  ^       ^       ^         ^    ^    ^     ^
// 要    平方    某个东西，  将其      乘以  自身。
	</JAVASCRIPT>
      </SNIPPET>
    </WEB_ONLY>

    <PDF_ONLY>
    <LATEX>
      \begin{flushleft}\normalcodesize
      \begin{tabular}{@{}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c}
      \tt\textbf{function} &amp; \tt square(        &amp; \tt x                  &amp;  \tt ) \verb+{+ &amp; \tt\textbf{return} &amp; \tt x          &amp;  \tt *            &amp;   \tt x &amp; \tt; \verb+}+  \\
      $\Big\uparrow$       &amp; $\Big\uparrow$     &amp; $\Big\uparrow$         &amp;                 &amp;                    &amp; $\Big\uparrow$ &amp; $\Big\uparrow$    &amp; $\Big\uparrow$ \\[4pt]
      \normalsize 要       &amp; \normalsize 平方   &amp; \normalsize 某个东西， &amp;                 &amp; \normalsize 将其   &amp;\normalsize    乘以 &amp; \normalsize 自身. \\
      \end{tabular}
      \end{flushleft}
      </LATEX>
    </PDF_ONLY>
    我们这里有一个
    <SPLITINLINE>
      <SCHEME>
	<INDEX>复合过程</INDEX>
	<INDEX>过程<SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合过程</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>复合函数</INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合函数</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    它被赋予了一个名称  <SCHEMEINLINE>square</SCHEMEINLINE>. The
     <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    代表了将某个东西乘以自身的运算。要被乘的东西被赋予一个本地名称，  <SCHEMEINLINE>x</SCHEMEINLINE>, 
    which plays the same role that a pronoun plays in natural language.
     <SPLITINLINE>
      <SCHEME>
	<INDEX>过程命名<SUBINDEX>的命名</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>使用<TT>define</TT>命名</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>使用<TT>define</TT>创建</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>函数命名<SUBINDEX>的命名</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明命名</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明创建</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    评估
    <SPLITINLINE>
      <SCHEME>
	定义
      </SCHEME>
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    创建这个复合
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    并将其与名称关联
    <INDEX>语法形式<SUBINDEX>函数声明</SUBINDEX></INDEX>
    <INDEX><FUNCTION></FUNCTION></INDEX>
    <INDEX>函数声明</INDEX>
    <INDEX>声明<SUBINDEX><ORDER>函数</ORDER>函数的 (function)</SUBINDEX></INDEX>
     <SCHEMEINLINE>square</SCHEMEINLINE>. <FOOTNOTE>注意，这里结合了两种不同的操作：我们正在创建
    <SPLITINLINE>
      <SCHEME>
	过程，
      </SCHEME>
      <JAVASCRIPT>
	函数，
      </JAVASCRIPT>
    </SPLITINLINE>
    并且我们正在给它命名为<SCHEMEINLINE>square</SCHEMEINLINE>。能够分离这两种概念是可能的，确实是重要的<EMDASH></EMDASH>创建
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    而不命名它们，以及给已创建的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    命名。在<SPACE></SPACE><REF NAME="sec:lambda"></REF>节中我们将看到如何做到这一点。</FOOTNOTE>
   </TEXT>
  <TEXT> 
    <SPLITINLINE>
      <SCHEME>
        过程定义的一般形式
      </SCHEME>
      <JAVASCRIPT>
        函数声明的最简单形式
      </JAVASCRIPT>
    </SPLITINLINE>
    是
     <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(define ($\langle \textit{name} \rangle$ $\langle\textit{formal parameters}\rangle$) $\langle \textit{body} \rangle$)
      </SCHEME>
      <JAVASCRIPT>
function <META>name</META>(<META>parameters</META>) { return <META>expression</META>; }
      </JAVASCRIPT>
    </SNIPPET>
    The
     <SPLITINLINE>
      <SCHEME>
	<INDEX>过程名称<SUBINDEX><ORDER>过程</ORDER>名称</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>的名称</SUBINDEX></INDEX>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>函数名称<SUBINDEX><ORDER>函数</ORDER>名称</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>的名称</SUBINDEX></INDEX>
	<META>名称</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    是要与环境中的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    定义相关联的符号。<FOOTNOTE>在整个书中，我们将
    <INDEX>本书中的符号<SUBINDEX>表达式语法中的斜体符号</SUBINDEX></INDEX>
    <INDEX>语法<SUBINDEX><ORDER>表达式</ORDER>描述表达式的语法</SUBINDEX></INDEX>
    通过使用斜体符号来描述表达式的一般语法<SPLITINLINE><SCHEME> 以尖括号
    分隔</SCHEME></SPLITINLINE><EMDASH></EMDASH>例如，
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE><EMDASH></EMDASH>表示
      </SCHEME>
      <JAVASCRIPT>
	<META>名称</META><EMDASH></EMDASH>表示
      </JAVASCRIPT>
    </SPLITINLINE>
    实际使用表达式时需要填入的<QUOTE>槽</QUOTE>。</FOOTNOTE>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>形式参数</SUBINDEX></INDEX>
	<INDEX>形式参数</INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>参数</SUBINDEX></INDEX>
	<INDEX>参数</INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{formal parameters}\rangle$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <META>参数</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    是在
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    的主体中用于引用
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    对应参数的名称。
    <SPLITINLINE>
      <SCHEME>
	过程。
      </SCHEME>
      <JAVASCRIPT>
	函数。
      </JAVASCRIPT>
    </SPLITINLINE>
     <SPLIT> 
      <SCHEME>
	The
        <INDEX>过程<SUBINDEX>的主体</SUBINDEX></INDEX>
        <INDEX>过程的主体</INDEX>
	<LATEXINLINE>$\langle \textit{body} \rangle$</LATEXINLINE>
        是一个表达式
	当形式参数被
        实际参数替换，过程
	被应用时，将产生过程应用的值。<FOOTNOTE>更
        <INDEX>表达式序列<SUBINDEX><ORDER>过程</ORDER>在过程主体中</SUBINDEX></INDEX>
        通常，过程的主体可以是一系列表达式。
        在这种情况下，解释器依次评估序列中的每个表达式，并将最终表达式的值作为过程应用的值返回。</FOOTNOTE>
	<LATEXINLINE>$\langle \textit{name} \rangle$</LATEXINLINE>
	和
	<LATEXINLINE>$\langle \textit{formal parameters} \rangle$</LATEXINLINE> 
	在
	<INDEX>括号<SUBINDEX><ORDER>过程</ORDER>在过程定义中</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>的定义</SUBINDEX></INDEX>
	括号内分组，就像在实际调用要定义的过程时一样。
      </SCHEME>
        <JAVASCRIPT>
	<META>参数</META>
	在
	<INDEX>括号<SUBINDEX><ORDER>函数</ORDER>在函数声明中</SUBINDEX></INDEX>
	<INDEX>括号<SUBINDEX><ORDER>函数</ORDER>在函数声明中</SUBINDEX></INDEX>
	括号内分组并用逗号分隔，就像在函数声明的应用中一样。
	<INDEX>返回语句</INDEX>
	<INDEX>返回值</INDEX>
	<INDEX><USE>return</USE> (关键字)</INDEX>
	<INDEX>语法形式<SUBINDEX>返回语句</SUBINDEX></INDEX>
	<INDEX>关键字<SUBINDEX><ORDER>return</ORDER><USE>return</USE></SUBINDEX></INDEX>
	在最简单的形式中，
        <INDEX><FUNCTION></FUNCTION><SUBINDEX>主体的</SUBINDEX></INDEX>
        <INDEX>函数的主体</INDEX>
	<EM>主体</EM> 是一个单一的函数声明
	<EM>返回语句</EM>，<FOOTNOTE>更
        <INDEX>语句序列<SUBINDEX><ORDER>函数</ORDER>在函数主体中</SUBINDEX></INDEX>
        一般来说，函数的主体可以是一系列语句。
	在这种情况下，解释器依次评估序列中的每个语句，直到返回语句确定函数应用的值。</FOOTNOTE>
	它由关键字
	<JAVASCRIPTINLINE>return</JAVASCRIPTINLINE>
	后跟<EM>返回表达式</EM>组成
	当
	<SPLITINLINE>
	  <SCHEME>形式</SCHEME>
	</SPLITINLINE>
	参数被实际参数替换，即函数被应用到的实际参数时，该表达式将产生函数应用的值。就像常量声明和表达式语句，
	返回语句
	<INDEX>分号 (<JAVASCRIPTINLINE>;</JAVASCRIPTINLINE>)<SUBINDEX>结束语句</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><CLOSE></CLOSE></INDEX>
	以分号结束。
      </JAVASCRIPT>
     </SPLIT>
  </TEXT>
  <TEXT> 
    <SPLIT>
      <SCHEME>
        定义了<SCHEMEINLINE>square</SCHEMEINLINE>之后，
        我们现在可以使用它：
      </SCHEME>
      <JAVASCRIPT>
	声明了<JAVASCRIPTINLINE>square</JAVASCRIPTINLINE>之后，
	我们现在可以在
	<EM>函数应用</EM>表达式中使用它，并通过使用分号将其转化为一个语句：
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square 21)
      </SCHEME>
      <SCHEMEOUTPUT>
441		
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(21);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
441
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 

    <SPLIT>
      <SCHEME>
      </SCHEME>
      <JAVASCRIPT>
	<COMMENT>
	  由于运算符组合在句法上与函数应用不同，JavaScript版本需要在这里明确说明函数应用的评估规则。这为下一小节的替换模型奠定了基础。
	</COMMENT>
	函数应用是<EMDASH></EMDASH>继运算符组合之后的<EMDASH></EMDASH>我们遇到的第二种将表达式组合成更大表达式的方法。
	函数应用的一般形式是
        <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
<META>函数表达式</META>(<META>参数表达式</META>)
          </JAVASCRIPT>
        </SNIPPET>
	其中应用的
	<INDEX>函数表达式</INDEX>
	<META>函数表达式</META>
	指定应用于以逗号分隔的
        <INDEX>参数</INDEX>
	<META>参数表达式</META>的函数。
	为了评估函数应用，解释器遵循
	<INDEX>评估<SUBINDEX>函数应用的</SUBINDEX></INDEX>
	<INDEX>函数应用<SUBINDEX>的评估</SUBINDEX></INDEX>
	一个过程，
	与<SPACE></SPACE><REF NAME="sec:evaluating-combinations"></REF>节中描述的运算符组合的过程非常相似。
	<UL>
	  <LI>评估函数应用时，执行以下操作：
	  <OL>
            <LI>
	      评估应用的子表达式，即函数表达式和参数表达式。
	    </LI>
            <LI>
	      将函数表达式之值代表的函数应用于参数表达式之值。
	    </LI>
	  </OL>
	  </LI>
	</UL>
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square (+ 2 5))
      </SCHEME>
      <SCHEMEOUTPUT>
49
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(2 + 5);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
49		  
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    <SPLIT>
      <JAVASCRIPT>
	这里，参数表达式本身是一个复合表达式，
	运算符组合 <JAVASCRIPTINLINE>2 + 5</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET>
      <NAME>square_square</NAME>
      <EXPECTED>81</EXPECTED>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square (square 3))
      </SCHEME>
      <SCHEMEOUTPUT>
81
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(square(3));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
81
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    <SPLIT>
    <JAVASCRIPT>
      当然，函数应用表达式也可以作为参数表达式。
    </JAVASCRIPT>
    </SPLIT>
   </TEXT>
  
  <TEXT>
    We can also use <SCHEMEINLINE>square</SCHEMEINLINE>
    as a building block in defining other
     <SPLITINLINE>
      <SCHEME>
        过程。
      </SCHEME>
      <JAVASCRIPT>
	函数。
      </JAVASCRIPT>
    </SPLITINLINE>
    例如，  <LATEXINLINE>$x^2 +y^2$</LATEXINLINE> can be expressed as
    <SNIPPET EVAL="no">
      <SCHEME>
(+ (square x) (square y))
      </SCHEME>
      <JAVASCRIPT>
square(x) + square(y)
      </JAVASCRIPT>
    </SNIPPET>
    We can easily
     <SPLITINLINE>
      <SCHEME>定义</SCHEME>
      <JAVASCRIPT>声明</JAVASCRIPT>
    </SPLITINLINE>
    一个
    <SPLITINLINE>
      <SCHEME>
	过程
        <SCHEMEINLINE>sum-of-squares</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	函数
	<JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE><FOOTNOTE>多部分名称的书写方式，例如
	<JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>，影响程序的可读性，不同的编程社区对此有不同的看法。
	<INDEX>骆驼拼写</INDEX>
	根据常见的JavaScript惯例，称为<EM>骆驼拼写</EM>，
	名称将是
	<JAVASCRIPTINLINE>sumOfSquares</JAVASCRIPTINLINE>。本书中使用的惯例称为<EM>蛇形拼写</EM>，
	<INDEX>命名惯例<SUBINDEX>蛇形拼写</SUBINDEX></INDEX>
	<INDEX>蛇形拼写</INDEX>
	在本书的Scheme版本中使用的惯例更为相似，其中连字符承担了我们下划线的角色。</FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    给定任意两个数字作为参数，产生它们平方和：
     <SNIPPET>
      <INDEX><DECLARATION>sum_of_squares</DECLARATION></INDEX>
      <NAME>sum_of_squares</NAME>
      <EXPECTED>25</EXPECTED>
      <EXAMPLE>sum_of_squares_example</EXAMPLE>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
      </SCHEME>
      <JAVASCRIPT>
function sum_of_squares(x, y) {
    return square(x) + square(y);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>sum_of_squares_example</NAME>
      <EXPECTED>25</EXPECTED>
      <REQUIRES>sum_of_squares</REQUIRES>
      <SCHEME>
(sum-of-squares 3 4)
      </SCHEME>
      <SCHEMEOUTPUT>
25
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
sum_of_squares(3, 4);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
25
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    Now we can use
     <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>sum-of-squares</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    作为构建进一步
    <SPLITINLINE>
      <SCHEME>
	过程的构件：
      </SCHEME>
      <JAVASCRIPT>
	函数的构件：
      </JAVASCRIPT>
    </SPLITINLINE>
     <SNIPPET>
      <NAME>f</NAME>
      <EXAMPLE>f_example</EXAMPLE>
      <EXPECTED>136</EXPECTED>
      <REQUIRES>sum_of_squares</REQUIRES>
      <SCHEME>
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
      </SCHEME>
      <JAVASCRIPT>
function f(a) {
    return sum_of_squares(a + 1, a * 2);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>f_example</NAME>
      <REQUIRES>f</REQUIRES>
      <SCHEME>
(f 5)
      </SCHEME>
      <SCHEMEOUTPUT>
136
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
f(5);    
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
136		  
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT><LABEL NAME="sec:compound-procedures"></LABEL>
  <NAME>
    Compound  <SPLITINLINE><SCHEME>过程</SCHEME>
    <JAVASCRIPT>函数</JAVASCRIPT></SPLITINLINE>
   </NAME>

  <TEXT>
    We have identified in 
     <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    一些必须出现在任何强大编程语言中的元素：
    <UL>
      <LI>
        数字和算术运算是原始数据和 
        <SPLITINLINE>
	  <SCHEME>过程。</SCHEME>
	  <JAVASCRIPT>函数。</JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
        组合的嵌套提供了组合运算的方法。
      </LI>
      <LI>
        将名称与值关联的常量声明提供了一种有限的抽象方式。
      </LI>
    </UL>
    现在我们将学习
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>定义</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><OPEN></OPEN></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
        <EM>过程定义</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<EM>函数声明</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    一种更强大的抽象技术，通过这种技术，一个复合操作可以被赋予一个名称，然后作为一个单元来引用。
   </TEXT>
  <TEXT>
    We begin by examining how to express the idea of
     <QUOTE>平方。</QUOTE>
    我们可能会说，
    <SPLITINLINE>
      <SCHEME>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </SCHEME>
      <JAVASCRIPT>
	<QUOTE>要平方某个东西，将其乘以自身。</QUOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <COMMENT>
      在这里，Scheme和JavaScript的表达略有不同，以更好地匹配JavaScript中的中缀表示法。
    </COMMENT>
    这在我们的语言中表示为 
     <SNIPPET>
      <INDEX><DECLARATION>square</DECLARATION></INDEX>
      <INDEX><USE>function</USE> (keyword)</INDEX>
      <INDEX>keywords<SUBINDEX><ORDER>function</ORDER><USE>function</USE></SUBINDEX></INDEX>
      <NAME>square_definition</NAME>
      <EXAMPLE>square_example</EXAMPLE>
      <SCHEME>
(define (square x) (* x x))
      </SCHEME>
      <JAVASCRIPT>
function square(x) {
    return x * x;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>square_example</NAME>
      <SCHEME>
	(square 14)
      </SCHEME>
      <JAVASCRIPT>
square(14);
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <LONG_PAGE lines="1"></LONG_PAGE>
  <TEXT>
    We can understand this in the following way:
     <WEB_ONLY>
      <SNIPPET EVAL="no">
	<SCHEME>
(define (square x)          (*          x      x))
;;  ^      ^    ^            ^          ^      ^
;;  要   平方   某个东西，   将其      乘以  自身。
	</SCHEME>
	<JAVASCRIPT>
function square(    x   ) { return x    *     x; }
//  ^       ^       ^         ^    ^    ^     ^
// 要    平方    某个东西，  将其      乘以  自身。
	</JAVASCRIPT>
      </SNIPPET>
    </WEB_ONLY>

    <PDF_ONLY>
    <LATEX>
      \begin{flushleft}\normalcodesize
      \begin{tabular}{@{}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c@{~}c}
      \tt\textbf{function} &amp; \tt square(        &amp; \tt x                  &amp;  \tt ) \verb+{+ &amp; \tt\textbf{return} &amp; \tt x          &amp;  \tt *            &amp;   \tt x &amp; \tt; \verb+}+  \\
      $\Big\uparrow$       &amp; $\Big\uparrow$     &amp; $\Big\uparrow$         &amp;                 &amp;                    &amp; $\Big\uparrow$ &amp; $\Big\uparrow$    &amp; $\Big\uparrow$ \\[4pt]
      \normalsize 要       &amp; \normalsize 平方   &amp; \normalsize 某个东西， &amp;                 &amp; \normalsize 将其   &amp;\normalsize    乘以 &amp; \normalsize 自身. \\
      \end{tabular}
      \end{flushleft}
      </LATEX>
    </PDF_ONLY>
    我们这里有一个
    <SPLITINLINE>
      <SCHEME>
	<INDEX>复合过程</INDEX>
	<INDEX>过程<SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合过程</EM>，
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>复合函数</INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>复合</SUBINDEX></INDEX>
	<EM>复合函数</EM>，
      </JAVASCRIPT>
    </SPLITINLINE>
    它被赋予了一个名称  <SCHEMEINLINE>square</SCHEMEINLINE>. The
     <SPLITINLINE>
      <SCHEME>过程</SCHEME>
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    代表了将某个东西乘以自身的运算。要被乘的东西被赋予一个本地名称，  <SCHEMEINLINE>x</SCHEMEINLINE>, 
    which plays the same role that a pronoun plays in natural language.
     <SPLITINLINE>
      <SCHEME>
	<INDEX>过程命名<SUBINDEX>的命名</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>使用<TT>define</TT>命名</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>使用<TT>define</TT>创建</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>函数命名<SUBINDEX>的命名</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明命名</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>使用函数声明创建</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    评估
    <SPLITINLINE>
      <SCHEME>
	定义
      </SCHEME>
      <JAVASCRIPT>
	声明
      </JAVASCRIPT>
    </SPLITINLINE>
    创建这个复合
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    并将其与名称关联
    <INDEX>语法形式<SUBINDEX>函数声明</SUBINDEX></INDEX>
    <INDEX><FUNCTION></FUNCTION></INDEX>
    <INDEX>函数声明</INDEX>
    <INDEX>声明<SUBINDEX><ORDER>函数</ORDER>的函数 (<JAVASCRIPTINLINE>function</JAVASCRIPTINLINE>)</SUBINDEX></INDEX>
     <SCHEMEINLINE>square</SCHEMEINLINE>. <FOOTNOTE>注意，这里结合了两种不同的操作：我们正在创建
    <SPLITINLINE>
      <SCHEME>
	过程，
      </SCHEME>
      <JAVASCRIPT>
	函数，
      </JAVASCRIPT>
    </SPLITINLINE>
    并且我们正在给它命名为<SCHEMEINLINE>square</SCHEMEINLINE>。能够分离这两种概念是可能的，确实是重要的<EMDASH></EMDASH>创建
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    而不命名它们，以及给已创建的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    命名。在<SPACE></SPACE><REF NAME="sec:lambda"></REF>节中我们将看到如何做到这一点。</FOOTNOTE>
   </TEXT>
  <TEXT> 
    <SPLITINLINE>
      <SCHEME>
        过程定义的一般形式
      </SCHEME>
      <JAVASCRIPT>
        函数声明的最简单形式
      </JAVASCRIPT>
    </SPLITINLINE>
    是
     <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(define ($\langle \textit{name} \rangle$ $\langle\textit{formal parameters}\rangle$) $\langle \textit{body} \rangle$)
      </SCHEME>
      <JAVASCRIPT>
function <META>name</META>(<META>parameters</META>) { return <META>expression</META>; }
      </JAVASCRIPT>
    </SNIPPET>
    The
     <SPLITINLINE>
      <SCHEME>
	<INDEX>过程名称<SUBINDEX><ORDER>过程</ORDER>名称</SUBINDEX></INDEX>
	<INDEX>过程<SUBINDEX>名称</SUBINDEX></INDEX>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>函数名称<SUBINDEX><ORDER>函数</ORDER>名称</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>名称</SUBINDEX></INDEX>
	<META>名称</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    是一个与环境中的
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    定义关联的符号。<FOOTNOTE>在整本书中，我们将
    <INDEX>本书中的符号<SUBINDEX>表达式语法中的斜体符号</SUBINDEX></INDEX>
    <INDEX>语法<SUBINDEX><ORDER>表达式</ORDER>表达式的描述</SUBINDEX></INDEX>
    使用斜体符号来描述表达式的一般语法<SPLITINLINE><SCHEME> 用尖括号
    分隔</SCHEME></SPLITINLINE><EMDASH></EMDASH>例如，
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{name}\rangle$</LATEXINLINE><EMDASH></EMDASH>表示
      </SCHEME>
      <JAVASCRIPT>
	<META>名称</META><EMDASH></EMDASH>表示
      </JAVASCRIPT>
    </SPLITINLINE>
    表达式中需要填入的<QUOTE>槽</QUOTE>，实际使用表达式时。</FOOTNOTE>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>过程<SUBINDEX>形式参数</SUBINDEX></INDEX>
	<INDEX>形式参数</INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>参数</SUBINDEX></INDEX>
	<INDEX>参数</INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<LATEXINLINE>$\langle \textit{formal parameters}\rangle$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <META>参数</META>
      </JAVASCRIPT>
    </SPLITINLINE>
    是在过程的主体中用于引用
    <SPLITINLINE>
      <SCHEME>
	过程
      </SCHEME>
      <JAVASCRIPT>
	函数
      </JAVASCRIPT>
    </SPLITINLINE>
    对应参数的名称。
    <SPLITINLINE>
      <SCHEME>
	过程。
      </SCHEME>
      <JAVASCRIPT>
	函数。
      </JAVASCRIPT>
    </SPLITINLINE>
     <SPLIT><!-- Error occured while translating this section-->
<!-- Error: TypeError: Cannot read properties of undefined (reading 'content')--> <JAVASCRIPT>
	<META>参数</META>
	在
	<INDEX>括号<SUBINDEX><ORDER>函数</ORDER>在函数声明中</SUBINDEX></INDEX>
	<INDEX>括号<SUBINDEX><ORDER>函数</ORDER>在函数声明中</SUBINDEX></INDEX>
	括号内分组并用逗号分隔，就像在函数声明的应用中一样。
	<INDEX>返回语句</INDEX>
	<INDEX>返回值</INDEX>
	<INDEX><USE>return</USE> (关键字)</INDEX>
	<INDEX>语法结构<SUBINDEX>返回语句</SUBINDEX></INDEX>
	<INDEX>关键字<SUBINDEX><ORDER>return</ORDER><USE>return</USE></SUBINDEX></INDEX>
	在最简单的形式中，
        <INDEX><FUNCTION></FUNCTION><SUBINDEX>主体的</SUBINDEX></INDEX>
        <INDEX>函数主体</INDEX>
	<EM>主体</EM> 是一个单一的函数声明
	<EM>返回语句</EM>，<FOOTNOTE>更
        <INDEX>语句序列<SUBINDEX><ORDER>函数</ORDER>在函数主体中</SUBINDEX></INDEX>
        通常来说，函数的主体可以是一系列语句。
	在这种情况下，解释器依次评估序列中的每个语句，直到返回语句确定函数应用的值。</FOOTNOTE>
	它由关键字
	<JAVASCRIPTINLINE>return</JAVASCRIPTINLINE>
	后跟<EM>返回表达式</EM>组成
	当
	<SPLITINLINE>
	  <SCHEME>形式</SCHEME>
	</SPLITINLINE>
	参数被实际参数替换，即函数被应用到的实际参数时，该表达式将产生函数应用的值。就像常量声明和表达式语句，
	返回语句
	<INDEX>分号 (<JAVASCRIPTINLINE>;</JAVASCRIPTINLINE>)<SUBINDEX>结束语句</SUBINDEX></INDEX>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>声明</SUBINDEX><CLOSE></CLOSE></INDEX>
	以分号结束。
      </JAVASCRIPT>
     </SPLIT>
  </TEXT>
  <TEXT> 
    <SPLIT>
      <SCHEME>
        定义了<SCHEMEINLINE>square</SCHEMEINLINE>之后，
        我们现在可以使用它：
      </SCHEME>
      <JAVASCRIPT>
	声明了<JAVASCRIPTINLINE>square</JAVASCRIPTINLINE>之后，
	我们现在可以在
	<EM>函数应用</EM>表达式中使用它，并通过使用分号将其转化为一个语句：
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square 21)
      </SCHEME>
      <SCHEMEOUTPUT>
441		
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(21);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
441
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 

    <SPLIT>
      <SCHEME>
      </SCHEME>
      <JAVASCRIPT>
	<COMMENT>
	  由于运算符组合在句法上与函数应用不同，JavaScript版本需要在这里明确说明函数应用的评估规则。这为下一小节的替换模型奠定了基础。
	</COMMENT>
	函数应用是<EMDASH></EMDASH>继运算符组合之后的<EMDASH></EMDASH>我们遇到的第二种将表达式组合成更大表达式的方法。
	函数应用的一般形式是
        <SNIPPET EVAL="no" LATEX="yes">
          <JAVASCRIPT>
<META>函数表达式</META>(<META>参数表达式</META>)
          </JAVASCRIPT>
        </SNIPPET>
	其中应用的
	<INDEX>函数表达式</INDEX>
	<META>函数表达式</META>
	指定应用于以逗号分隔的
        <INDEX>参数</INDEX>
	<META>参数表达式</META>的函数。
	为了评估函数应用，解释器遵循
	<INDEX>评估<SUBINDEX>函数应用的</SUBINDEX></INDEX>
	<INDEX>函数应用<SUBINDEX>的评估</SUBINDEX></INDEX>
	一个过程，与<SPACE></SPACE><REF NAME="sec:evaluating-combinations"></REF>节中描述的运算符组合的过程非常相似。
	<UL>
	  <LI>评估函数应用时，执行以下操作：
	  <OL>
            <LI>
	      评估应用的子表达式，即函数表达式和参数表达式。
	    </LI>
            <LI>
	      将函数表达式之值代表的函数应用于参数表达式之值。
	    </LI>
	  </OL>
	  </LI>
	</UL>
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square (+ 2 5))
      </SCHEME>
      <SCHEMEOUTPUT>
49
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(2 + 5);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
49		  
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    <SPLIT>
      <JAVASCRIPT>
	这里，参数表达式本身是一个复合表达式，
	运算符组合 <JAVASCRIPTINLINE>2 + 5</JAVASCRIPTINLINE>。
      </JAVASCRIPT>
    </SPLIT>
     <SNIPPET>
      <NAME>square_square</NAME>
      <EXPECTED>81</EXPECTED>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(square (square 3))
      </SCHEME>
      <SCHEMEOUTPUT>
81
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(square(3));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
81
      </JAVASCRIPT_OUTPUT>
    </SNIPPET> 
    <SPLIT>
    <JAVASCRIPT>
      当然，函数应用表达式也可以作为参数表达式。
    </JAVASCRIPT>
    </SPLIT>
   </TEXT>
  
  <TEXT>
    We can also use <SCHEMEINLINE>square</SCHEMEINLINE>
    as a building block in defining other
     <SPLITINLINE>
      <SCHEME>
        过程。
      </SCHEME>
      <JAVASCRIPT>
	函数。
      </JAVASCRIPT>
    </SPLITINLINE>
    例如，  <LATEXINLINE>$x^2 +y^2$</LATEXINLINE> can be expressed as
    <SNIPPET EVAL="no">
      <SCHEME>
(+ (square x) (square y))
      </SCHEME>
      <JAVASCRIPT>
square(x) + square(y)
      </JAVASCRIPT>
    </SNIPPET>
    We can easily
     <SPLITINLINE>
      <SCHEME>定义</SCHEME>
      <JAVASCRIPT>声明</JAVASCRIPT>
    </SPLITINLINE>
    一个
    <SPLITINLINE>
      <SCHEME>
	过程
        <SCHEMEINLINE>sum-of-squares</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	函数
	<JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE><FOOTNOTE>多部分名称的书写方式，例如
	<JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>，影响程序的可读性，不同的编程社区对此有不同的看法。
	<INDEX>驼峰式拼写</INDEX>
	根据常见的JavaScript惯例，称为<EM>驼峰式拼写</EM>，
	名称将是
	<JAVASCRIPTINLINE>sumOfSquares</JAVASCRIPTINLINE>。本书中使用的惯例称为<EM>蛇形拼写</EM>，
	<INDEX>命名惯例<SUBINDEX>蛇形拼写</SUBINDEX></INDEX>
	<INDEX>蛇形拼写</INDEX>
	在本书的Scheme版本中使用的惯例更为相似，其中连字符承担了我们下划线的角色。</FOOTNOTE>
      </JAVASCRIPT>
    </SPLITINLINE>
    给定任意两个数字作为参数，产生它们平方和：
     <SNIPPET>
      <INDEX><DECLARATION>sum_of_squares</DECLARATION></INDEX>
      <NAME>sum_of_squares</NAME>
      <EXPECTED>25</EXPECTED>
      <EXAMPLE>sum_of_squares_example</EXAMPLE>
      <REQUIRES>square_definition</REQUIRES>
      <SCHEME>
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
      </SCHEME>
      <JAVASCRIPT>
function sum_of_squares(x, y) {
    return square(x) + square(y);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>sum_of_squares_example</NAME>
      <EXPECTED>25</EXPECTED>
      <REQUIRES>sum_of_squares</REQUIRES>
      <SCHEME>
(sum-of-squares 3 4)
      </SCHEME>
      <SCHEMEOUTPUT>
25
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
sum_of_squares(3, 4);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
25
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    Now we can use
     <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>sum-of-squares</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    作为构建进一步
    <SPLITINLINE>
      <SCHEME>
	过程的构件：
      </SCHEME>
      <JAVASCRIPT>
	函数的构件：
      </JAVASCRIPT>
    </SPLITINLINE>
     <SNIPPET>
      <NAME>f</NAME>
      <EXAMPLE>f_example</EXAMPLE>
      <EXPECTED>136</EXPECTED>
      <REQUIRES>sum_of_squares</REQUIRES>
      <SCHEME>
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
      </SCHEME>
      <JAVASCRIPT>
function f(a) {
    return sum_of_squares(a + 1, a * 2);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>f_example</NAME>
      <REQUIRES>f</REQUIRES>
      <SCHEME>
(f 5)
      </SCHEME>
      <SCHEMEOUTPUT>
136
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
f(5);    
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
136		  
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>
  <TEXT> 
    <SPLIT>
      <SCHEME>
        复合
        <INDEX>复合过程<SUBINDEX>像原始过程一样使用</SUBINDEX></INDEX>
	过程的使用方式与原始过程完全相同。事实上，仅通过查看上面给出的<SCHEMEINLINE>sum-of-squares</SCHEMEINLINE>定义，我们无法判断<SCHEMEINLINE>square</SCHEMEINLINE>是内置于解释器中的，像<SCHEMEINLINE>+</SCHEMEINLINE>和<SCHEMEINLINE>*</SCHEMEINLINE>一样，还是定义为复合过程。
      </SCHEME>
      <JAVASCRIPT>
	除了复合函数之外，任何JavaScript环境还提供
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>原始</SUBINDEX></INDEX>
	<INDEX>原始函数</INDEX>
	内置在解释器中或从库中加载的原始函数。
	<INDEX>本书中使用的JavaScript环境</INDEX>
	除了运算符提供的原始函数外，
	本书使用的JavaScript环境包括额外的原始函数，例如函数
	<INDEX><USE>math_log</USE> (原始函数)</INDEX>
	<INDEX><PRIMITIVE></PRIMITIVE><SUBINDEX><USE>math_log</USE><ECMA>Math.log</ECMA></SUBINDEX></INDEX>
	<JAVASCRIPTINLINE>math_log</JAVASCRIPTINLINE>，
	它计算参数的自然对数。<FOOTNOTE>我们的
	JavaScript环境包括ECMAScript的所有函数和常量
	<LINK address="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-math-object">Math对象</LINK>，
	以<JAVASCRIPTINLINE>math_</JAVASCRIPTINLINE><LATEXINLINE>$\ldots$</LATEXINLINE>命名。
	<INDEX>ECMAScript<SUBINDEX><ORDER>Math</ORDER><JAVASCRIPTINLINE>Math</JAVASCRIPTINLINE>对象</SUBINDEX></INDEX>
	例如，ECMAScript的<JAVASCRIPTINLINE>Math.log</JAVASCRIPTINLINE>
    可以作为<JAVASCRIPTINLINE>math_log</JAVASCRIPTINLINE>使用。
	MIT出版社
	为本书提供的网页包括JavaScript包
	<INDEX><USE>sicp</USE> JavaScript包</INDEX>
	<INDEX>JavaScript包 <JAVASCRIPTINLINE>sicp</JAVASCRIPTINLINE></INDEX>
	<JAVASCRIPTINLINE>sicp</JAVASCRIPTINLINE>，提供这些及书中认为是原始的所有其他JavaScript函数。
     </FOOTNOTE>
	这些附加的原始函数的使用方式与
	<INDEX>复合函数<SUBINDEX>像原始函数一样使用</SUBINDEX></INDEX>
	复合函数完全相同；评估应用
	<JAVASCRIPTINLINE>math_log(1)</JAVASCRIPTINLINE> 的结果为数字0。
	事实上，仅通过查看上面给出的
	<JAVASCRIPTINLINE>sum_of_squares</JAVASCRIPTINLINE>定义，我们无法判断
	<JAVASCRIPTINLINE>square</JAVASCRIPTINLINE> 是内置于解释器中的，还是从库中加载，或定义为复合函数。
      </JAVASCRIPT>
    </SPLIT>
   </TEXT></SUBSECTION>