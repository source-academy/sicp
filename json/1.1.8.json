[{"id":"/sicpjs/1.1.8","tag":"TITLE","body":"1.1.8  \n    \n      \n      \n        Functions\n      \n    \n    as Black-Box Abstractions"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n\tThe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":"\n    is our first example of a process defined by a set of mutually \n    defined functions.\n    Notice that the \n    declaration of\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":"\n    is\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"recursive","tag":"#text"}]},{"body":"; that is, the\n    \n        function\n      \n    is defined in terms of itself.  The idea of being able to define a\n    \n        function\n      \n    in terms of itself may be disturbing; it may seem unclear how such a\n    \"","tag":"#text"},{"body":"circular","tag":"#text"},{"body":"\" definition could make sense at all, much less\n    specify a well-defined process to be carried out by a computer.  This will\n    be addressed more carefully in\n    section ","tag":"#text"},{"tag":"REF","body":"1.2","href":"/sicpjs/1.2"},{"body":".  But first\n    let's consider some other important points illustrated by the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":" example.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Observe that the problem of computing square roots breaks up naturally\n    into a number of subproblems:\n    \n    how to tell whether a guess is good\n    enough, how to improve a guess, and so on.  Each of these tasks is\n    accomplished by a separate\n    function.\n    The entire ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":" program can be viewed as a\n    cluster of\n    \n        functions\n\t(shown in figure ","tag":"#text"},{"tag":"REF","body":"1.2","href":"/sicpjs/1.1.8#fig-1.2"},{"body":")\n      \n    that mirrors the decomposition of the problem into subproblems.\n  ","tag":"#text"}]},{"tag":"FIGURE","scale":"60%","src":"img_javascript/ch1-Z-G-6.svg","id":"#fig-1.2","captionHref":"/sicpjs/1.1.8#fig-1.2","captionName":"Figure 1.2 ","captionBody":[{"body":"Functional decomposition of the\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":" program.\n        ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    The importance of this\n    \n    decomposition strategy is not simply that one\n    is dividing the program into parts.  After all, we could take any\n    large program and divide it into parts—the first ten lines, the next\n    ten lines, the next ten lines, and so on.  Rather, it is crucial that\n    each\n    \n        function\n      \n    accomplishes an identifiable task that can be used as a module in defining\n    other\n    functions.\n    For example, when we define the\t      \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":" function\n      \n    in terms of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":", we are able to\n    regard the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":"\n        function\n      \n    as a\n    \"","tag":"#text"},{"body":"black box.","tag":"#text"},{"body":"\"  We are not at that moment concerned with\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"how","tag":"#text"}]},{"body":" the\n    \n        function\n      \n    computes its result, only with the fact ","tag":"#text"},{"tag":"EM","child":[{"body":"that","tag":"#text"}]},{"body":" it computes the\n    square.  The details of how the square is computed can be suppressed,\n    to be considered at a later time.  Indeed, as far as the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":" function\n      \n    is concerned, ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" is not quite a\n    \n        function\n      \n    but rather an abstraction of a\n    function,\n    a so-called\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"functional abstraction","tag":"#text"}]},{"body":".\n      \n    At this level of abstraction, any\n    \n        function\n      \n    that computes the square is equally good.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    Thus, considering only the values they return, the following two\n    \n        functions\n      \n    squaring a number should be indistinguishable. Each takes a numerical\n    argument and produces the square of that number as the value.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/1.1.8#footnote-1"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToBwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9cjFh04oALL0VA","body":"function square(x) {\n    return x * x;\n} "},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToBwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrQC2zMgAsA+u24AHTgBMqBAEYAbLrIWK9VAOY9eVgNzYAvvmLlqtLboOXBw0eMm1uoADUoNy2DtiMLBycKAAsvNZAA","body":"function square(x) {\n    return math_exp(double(math_log(x)));\n}\nfunction double(x) {\n    return x + x;\n} "}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    So a\n    \n        function\n      \n    should be able to suppress detail.  The users of the\n    \n        function\n      \n    may not have written the\n    \n        function\n      \n    themselves, but may have obtained it from another programmer as a\n    black box. A user should not need to know how the\n    \n        function\n      \n    is implemented in order to use it.\n    ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Local names","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    One detail of a\n    function's\n    implementation that should not matter to the user of the\n    \n        function\n      \n    is the implementer's choice of names for the\n    function's parameters.\n    Thus, the following\n    \n        functions\n      \n    should not be distinguishable:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToBwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9cjFh04oALL0VA","body":"function square(x) {\n    return x * x;\n} "},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToBwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoBPASlADe2UCNAcyBVrW6gAVKG4BubAF9cjFh04oALL0VA","body":"function square(y) {\n    return y * y;\n} "},{"body":"\n    This principle—that the meaning of a\n    \n        function\n      \n    should be independent of the parameter names used by its\n    author—seems on the surface to be self-evident, but its\n    consequences are profound.  The simplest consequence is that the\n    parameter names of a\n    \n        function\n      \n    must be local to the body of the\n    \n        function.\n      \n    For example, we used ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":"\n\tin the declaration of\t      \n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    in our square-root\n    \n        function:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":9,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToBwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq0KJgB9AHMqKgATIOEiKgIQgAsWEIJhJiYAGjUHPgERMQl6ZhYrGzsUtKYuHU5QAB5FNAUFFH0jbEDQ8KiYuMSWdAAWFCyAJg5dIA","body":"function is_good_enough(guess, x) {\n    return abs(square(guess) - x) < 0.001;\n} "},{"body":"\n    The intention of the author of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    is to determine if the square of the first argument is within a given\n    tolerance of the second argument.  We see that the author of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    used the name ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"guess"},{"body":" to refer to the\n    first argument and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" to refer to the\n    second argument.  The argument of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":"\n    is ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"guess"},{"body":".  If the author of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" used ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":"\n    (as above) to refer to that argument, we see that the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    must be a different ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" than the one\n    in  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":". Running the\n    \n        function\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" must not affect the value\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" that is used by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":",\n      \n    because that value of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" may be needed by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    after ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" is done computing.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    If the parameters were not local to the bodies of their respective\n    functions,\n    then the parameter ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" could be confused with the parameter\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":",\n      \n    and the behavior of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    would depend upon which version of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":"\n    we used.  Thus, ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" would not be the\n    black box we desired.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    A     \n    \n\tparameter of a function\n      \n    has a very special role in the\n    \n        function declaration,\n      \n    in that it doesn't matter what name the\n    \n    parameter has.  Such a name is called\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"bound","tag":"#text"}]},{"body":", and we say that the function declaration\n      ","tag":"#text"},{"tag":"EM","child":[{"body":"binds","tag":"#text"}]},{"body":" its\n    \n\tparameters.\n      \n    The meaning of a\n    \n        function declaration is unchanged if a bound name\n      \n    is consistently renamed throughout the\n    declaration.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/1.1.8#footnote-2"},{"body":"\n    If a\n    name\n    is not bound, we say that it is\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"free","tag":"#text"}]},{"body":".  The set of\n    statements\n    for which a binding\n    declares\n    a name is called the\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"scope","tag":"#text"}]},{"body":" of that name. In a\n    \n        function declaration, the bound names\n      \n    declared as the\n    \n        parameters of the function\n      \n    have the body of the\n    \n        function\n      \n    as their scope.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    In the\n    \n\tdeclaration of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    above,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"guess"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" are\n    bound\n    \n\tnames\n      \n    but\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"abs"},{"body":"\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" are free.\n    The meaning of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    should be independent of the names we choose for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"guess"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" so long as they are distinct and\n    different from\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"abs"},{"body":"\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":".  (If we renamed\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"guess"},{"body":" to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"abs"},{"body":" we would have introduced a bug by\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"capturing","tag":"#text"}]},{"body":" the\n    \n\tname\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"abs"},{"body":".\n    It would have changed from free to bound.)  The meaning of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    is not independent of the \n    \n\tchoice of its free names,\n      \n    however. It surely depends upon the fact\n    \n\t(external to this declaration)\n      \n\tthat the name ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"abs"},{"body":" refers to a function\n      \n    for computing the absolute value of a number.\n    \n\tThe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    will compute a different function if we substitute\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"math_cos"},{"body":"\n\t(the primitive cosine function)\n      \n    for ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"abs"},{"body":" in its\n    \n\tdeclaration.\n      ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Internal\n    declarations\n    and block structure","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    We have one kind of name isolation available to us so far:\n    \n\tThe parameters of a function\n      \n    are local to the body of the\n    function.\n    The square-root program illustrates another way in which we would like to\n    control the use of names.\n    \n    The existing program consists of separate\n    \n        functions:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":13,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToBwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq06ADdhQToAc2F2ABpQAE8HPgERMQlQdlAAajiuMAAmfSN8XzNaK0Eyex5E-mTXC0tygH0KMhCWFBjOAqLTf3qmlrawgmEmJk6Ep1rUiiZGsKoqABNG4SIqAjCACxZh0fG1DmqnJ1U9seOT-k0ysmbWwRYKAFsAB0EqYN2RsYmJ7pMfnMs3mixWaw222++wmVSmLlSjFYVhsdnOTC4Ok4oAAPIo0AoFCgAcU+i93p9IujYY4kgiAsFQhFob81KAwOiON1sLcWABWLlAA","body":"function sqrt(x) {\n    return sqrt_iter(1, x);\n}\nfunction sqrt_iter(guess, x) {\n    return is_good_enough(guess, x)\n           ? guess\n           : sqrt_iter(improve(guess, x), x);\n}\nfunction is_good_enough(guess, x) {\n    return abs(square(guess) - x) < 0.001;\n}\nfunction improve(guess, x) {\n    return average(guess, x / guess);\n} "}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    The problem with this program is that the only\n    \n        function\n      \n    that is important to users of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":" is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":".  The other\n    \n        functions\n      \n\t(","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":",\n      \n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"improve"},{"body":") only clutter up their minds.\n    They may not \n    \n\tdeclare any other function\n      \n    called\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    as part of another program to work together\n    with the square-root program, because ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":"\n    needs it.  The problem is especially severe in the construction of large\n    systems by many separate programmers.  For example, in the construction\n    of a large library of numerical\n    functions,\n    many numerical functions are computed as successive approximations and\n    thus might have\n    \n        functions\n      \n    named\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":"\n    and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"improve"},{"body":" as auxiliary\n    functions.\n    We would like to localize the\n    subfunctions,\n    hiding them inside ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":" so that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":" could coexist with other\n    successive approximations, each having its own private\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":" function.\n      \n    To make this possible, we allow a\n    \n        function\n      \n    to have\n    \n    internal declarations that are local to that\n    function.\n    For example, in the square-root problem we can write\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":13,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToBwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq06ADdhQToAc2F2ABpQAE8HPgERMQlQdlAAajiuMAAmfSN8XzNaK0Eyex5E-hM-cwomAH0wqioAE0bhIioCMIALFjCCYSYmGM4qpydk13pmFisbOyGRpi4dCYAeRTQFBRR9JyMnWpLQCgBbAAdBKmDB4dHxhKmkl1SgkPDIlae1UDAvzWhwExwEp38Fks5UaFDIIQeq2ek1ezhStAazVaHS6PX6iL+E2qqKmqiBxJJAk0ZTIsPhghYlxudx+jzGag4zxB-DB-BmqRpdIRKC53mwNJYAFYOLogA","body":"function sqrt(x) {\n    function is_good_enough(guess, x) {\n        return abs(square(guess) - x) < 0.001;\n    }\n    function improve(guess, x) {\n        return average(guess, x / guess);\n    }\n    function sqrt_iter(guess, x) {\n        return is_good_enough(guess, x) \n               ? guess\n               : sqrt_iter(improve(guess, x), x);\n    }\n    return sqrt_iter(1, x);\n} "}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n\tAny matching pair of braces designates a ","tag":"#text"},{"tag":"EM","child":[{"body":"block","tag":"#text"}]},{"body":", and\n\tdeclarations inside the block are local to the block.\n\t\n    Such nesting of\n    declarations,\n    called ","tag":"#text"},{"tag":"EM","child":[{"body":"block structure","tag":"#text"}]},{"body":", is basically the right solution to the\n    simplest name-packaging problem.  But there is a better idea lurking here.\n    In addition to internalizing the \n    declarations of the auxiliary functions,\n    we can simplify them.  Since ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" is bound in the\n    declaration\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":", the\n    \n        functions\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_good_enough"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"improve"},{"body":", and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt_iter"},{"body":",\n      which are declared internally to","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":", are in the scope of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":". Thus, it is not necessary to pass\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" explicitly to each of these\n    functions.\n    Instead, we allow ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" to be a free\n    name\n    in the internal\n    declarations,\n    as shown below. Then ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" gets its value from\n    the argument with which the enclosing\n    \n        function\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sqrt"},{"body":" is called.  This discipline is called\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"lexical scoping","tag":"#text"}]},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/1.1.8#footnote-3"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":13,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHToBwChsDMBXAOwGMAXASwHsjQBDAIwGcAKADwEpQBvbUf0ACcApmQKDabUAD4AvKAAMoAPygpALlABaNQG5sAX1yFSlGqCYBHAnRHsuvAUNHjJoAFR7Dx4uWq06ADdhQToAc2F2ABpQAE8HPgERMQlQdlAAajiuMAAmfSN8XzNaK0Eyex5E-hM-cwomAH0wqioAE0bhIioCMIALFjCCYSYmBKcnZNd6ZhYrGzshkbHtNS4AHkU0BQUUfScjJ1qS0AoAWwAHQSpgweHR8Yn+KdSgkPDIpdGYqTAvsf2AkOAmO-gslnKjQoZBCd2WjyeL1oDWarQ6XR6-ThD2qTyeqn+uLxTk0ZTIUJhghY5yuN0+9zGHEB-GBzxcqTJFNhKCZ3mwZJYAFYmUA","body":"function sqrt(x) {\n    function is_good_enough(guess) {\n        return abs(square(guess) - x) < 0.001;\n    }\n    function improve(guess) {\n        return average(guess, x / guess);\n    }\n    function sqrt_iter(guess) {\n        return is_good_enough(guess)\n               ? guess\n               : sqrt_iter(improve(guess));\n    }\n    return sqrt_iter(1);\n} "}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    We will use block structure extensively to help us break up large programs\n    into tractable pieces.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/1.1.8#footnote-4"},{"body":"\n    The idea of block structure originated with the programming language\n    \n    Algol 60. It appears in most advanced programming languages and is an\n    important tool for helping to organize the construction of large programs. \n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/1.1.8#footnote-link-1","child":[{"body":"It\n    is not even clear which of these\n    \n        functions\n      \n    is a more efficient implementation.  This depends upon the hardware\n    available.  There are machines for which the \"","tag":"#text"},{"body":"obvious","tag":"#text"},{"body":"\"\n    implementation is the less efficient one.  Consider a machine that has\n    extensive tables of logarithms and antilogarithms stored in a very\n    efficient manner.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/1.1.8#footnote-link-2","child":[{"body":"The\n    concept of consistent renaming is actually subtle and difficult to\n    define formally.  Famous logicians have made embarrassing errors\n    here.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/1.1.8#footnote-link-3","child":[{"body":"Lexical scoping dictates that free\n    \n\tnames in a function\n      \n    are taken to refer to bindings made by enclosing\n    \n        function declarations;\n      \n    that is, they are looked up in\n    \n    the environment in which the\n    \n        function was declared.\n      \n    We will see how this works in detail in chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":" when we\n    study environments and the detailed behavior of the interpreter.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/1.1.8#footnote-link-4","child":[{"body":"Embedded \n    \n        declarations must come first in a function\n      \n    body.\n    \n    The management is not responsible for the consequences of running programs\n    that intertwine\n    declaration\n    and use; see also\n    footnotes ","tag":"#text"},{"tag":"REF","body":2,"href":"/sicpjs/1.3.2#footnote-2"},{"body":"\n    and ","tag":"#text"},{"tag":"REF","body":4,"href":"/sicpjs/1.3.2#footnote-4"},{"body":"\n    in section ","tag":"#text"},{"tag":"REF","body":"1.3.2","href":"/sicpjs/1.3.2"},{"body":".\n    ","tag":"#text"}]}]