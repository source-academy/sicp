<SUBSECTION>
  <NAME>
    Maintaining the Illusion of Infinite Memory
  </NAME>

  <LABEL NAME="sec:gc"/>
  
  <INDEX>garbage collection<OPEN/></INDEX>

  <TEXT>
    The representation method outlined in
    section<SPACE/><REF NAME="sec:memory-as-vectors"/> solves the problem of
    implementing list structure, provided that we have an infinite amount of
    memory. With a real computer we will eventually run out of free space in
    which to construct new pairs.<FOOTNOTE>This may not be true eventually,
    because memories may get large enough so that it would be impossible
    to run out of free memory in the lifetime of the computer.  For
    example, there are about
    <SPLITINLINE>
      <SCHEME>
        <LATEXINLINE>$3\times 10^{13}$ microseconds</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <LATEXINLINE>$3\times 10^{16}$ nanoseconds</LATEXINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    in a year, so if we were to
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    once per
    <SPLITINLINE>
      <SCHEME>
        <LATEXINLINE>microsecond</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <LATEXINLINE>nanosecond</LATEXINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    we would need about
    <SPLITINLINE>
      <SCHEME>
        <LATEXINLINE>$10^{15}$</LATEXINLINE>
      </SCHEME>
      <JAVASCRIPT>
        <LATEXINLINE>$10^{18}$</LATEXINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    cells of memory to build a machine
    that could operate for 30 years without running out of memory.  That much
    memory seems absurdly large by today<APOS/>s standards, but it is not
    physically impossible.  On the other hand, processors are getting faster and 
    <SPLITINLINE>
      <SCHEME>
        a future computer may have 
      </SCHEME>
      <JAVASCRIPT>
        modern computers have increasingly
      </JAVASCRIPT>
    </SPLITINLINE>
    large numbers of processors operating in
    parallel on a single memory, so it may be possible to use up memory much
    faster than we have postulated.</FOOTNOTE> However, most of the pairs
    generated in a typical computation are used only to hold intermediate
    results.  After these
    results are accessed, the pairs are no longer needed<EMDASH/>they are <EM>
    garbage</EM>.  For instance, the computation
    <SNIPPET EVAL="no">
      <SCHEME>
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
      </SCHEME>
      <JAVASCRIPT>
accumulate((x, y) => x + y, 0, filter(is_odd, enumerate_interval(0, n)))
      </JAVASCRIPT>
    </SNIPPET>
    constructs two lists: the enumeration and the result of filtering
    the enumeration.  When the accumulation is complete, these lists are
    no longer needed, and the allocated memory can be reclaimed.  If we
    can arrange to collect all the garbage periodically, and if this turns
    out to recycle memory at about the same rate at which we construct new
    pairs, we will have preserved the illusion that there is an infinite
    amount of memory.
  </TEXT>

  <TEXT>
    In order to recycle pairs, we must have a way to determine which
    allocated pairs are not needed (in the sense that their contents can
    no longer influence the future of the computation).  The method we
    shall examine for accomplishing this is known as <EM>garbage
    collection</EM>.  Garbage collection is based on the observation that, at
    any moment in a
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    interpretation, the only objects that can
    affect the future of the computation are those that can be reached by
    some succession of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operations starting from the pointers that are currently in the machine
    registers.<FOOTNOTE>We assume here that the stack is represented as a list
    as described in section<SPACE/><REF NAME="sec:memory-as-vectors"/>, so that
    items on the stack are accessible via the pointer in the stack
    register.</FOOTNOTE>  Any memory cell that is not so accessible may be
    recycled.
  </TEXT>

  <TEXT>
    There are many ways to perform garbage collection.  The method we
    shall examine here is called 
    <INDEX>stop-and-copy garbage collector<OPEN/></INDEX>
    <INDEX>garbage collector<SUBINDEX>stop-and-copy<OPEN/></SUBINDEX></INDEX>
    <EM>stop-and-copy</EM>.  The basic idea is to divide memory into two
    halves: <QUOTE>working memory</QUOTE> and <QUOTE>free memory.</QUOTE>  When
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    constructs pairs, it allocates these in working memory.  When working memory
    is full, we perform garbage collection by locating all the useful pairs in
    working memory and copying these into consecutive locations in free memory.
    (The useful pairs are located by tracing all the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE
    > and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointers, starting with the machine registers.)  Since we do not copy the
    garbage, there will presumably be additional free memory that we can
    use to allocate new pairs.  In addition, nothing in the working memory
    is needed, since all the useful pairs in it have been copied.  Thus,
    if we interchange the roles of working memory and free memory, we can
    continue processing; new pairs will be allocated in the new working
    memory (which was the old free memory).  When this is full, we can
    copy the useful pairs into the new free memory (which was the old
    working memory).<FOOTNOTE>This idea was invented and first implemented
    by
    <INDEX>Minsky, Marvin Lee</INDEX>
    Minsky, as part of the implementation of 
    <INDEX>Lisp<SUBINDEX><ORDER>DEC</ORDER>on DEC PDP-1</SUBINDEX></INDEX>
    Lisp for the PDP-1 at the
    <INDEX>MIT<SUBINDEX>Research Laboratory of Electronics</SUBINDEX></INDEX>
    MIT Research Laboratory of Electronics.  It was further developed by
    <INDEX>Fenichel, Robert</INDEX>
    <INDEX>Yochelson, Jerome C.</INDEX>
    Fenichel and Yochelson (1969) for use in the Lisp implementation for the
    <INDEX>Multics time-sharing system</INDEX>
    Multics time-sharing system.  Later, 
    <INDEX>Baker, Henry G., Jr.</INDEX>
    Baker (1978) developed a <QUOTE>real-time</QUOTE> version of the method,
    which does not require the computation to stop during garbage collection.
    Baker<APOS/>s idea was extended by 
    <INDEX>Hewitt, Carl Eddie</INDEX>
    Hewitt,
    <INDEX>Lieberman, Henry</INDEX>
    Lieberman, and
    <INDEX>Moon, David A.</INDEX>
    Moon (see Lieberman and Hewitt 1983) to take
    advantage of the fact that some structure is more volatile
    and other structure is more permanent.  
    <P/>
    An alternative commonly used garbage-collection technique is the 
    <INDEX>mark-sweep garbage collector</INDEX>
    <INDEX>garbage collector<SUBINDEX>mark-sweep</SUBINDEX></INDEX>
    <EM>mark-sweep</EM> method. This consists of tracing all the structure
    accessible from the machine registers and marking each pair we reach.
    We then scan all of memory, and any location that is unmarked is
    <QUOTE>swept up</QUOTE> as garbage and made available for reuse.  A full
    discussion of the mark-sweep method can be found in 
    <INDEX>Allen, John</INDEX>
    <CITATION>Allen 1978</CITATION>.
    <P/>
    The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in
    use for large-memory systems because it examines only the useful part
    of memory.  This is in contrast to mark-sweep, in which the sweep
    phase must check all of memory.  A second advantage of stop-and-copy
    is that it is a 
    <INDEX>compacting garbage collector</INDEX>
    <INDEX>garbage collector<SUBINDEX>compacting</SUBINDEX></INDEX>
    <EM>compacting</EM> garbage collector.  That is, at the
    end of the garbage-collection phase the useful data will have been
    moved to consecutive memory locations, with all garbage pairs
    compressed out.  This can be an extremely important performance
    consideration in machines with virtual memory, in which accesses to
    widely separated memory addresses may require extra paging
    operations.</FOOTNOTE>
  </TEXT>

  <SUBHEADING> 
    <NAME>Implementation of a stop-and-copy garbage collector</NAME>
  </SUBHEADING>

  <TEXT>
    We now use our register-machine language to describe the stop-and-copy
    algorithm in more detail.  We will assume that there is a register
    called 
    <INDEX><USE>root</USE> register</INDEX>
    <SCHEMEINLINE>root</SCHEMEINLINE> that contains a pointer to a structure
    that eventually points at all accessible data.  This can be arranged by
    storing the contents of all the machine registers in a preallocated list
    pointed at by <SCHEMEINLINE>root</SCHEMEINLINE> just before starting
    garbage collection.<FOOTNOTE>This list of registers does not include
    the registers used by the storage-allocation
    system<EMDASH/><SCHEMEINLINE>root</SCHEMEINLINE>,
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cars</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_heads</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cdrs</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_tails</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and the other registers that will be introduced in this section.</FOOTNOTE>
    We also assume that, in addition to the current working memory, there is
    free memory available into which we can copy the useful data.  The current
    working memory consists of vectors whose base addresses are in 
    registers called
    <INDEX><USE>the_heads</USE><SUBINDEX>register</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cars</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_heads</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <INDEX><USE>the_tails</USE><SUBINDEX>register</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cdrs</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_tails</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and the free memory is in registers called 
    <INDEX><USE>new_heads</USE> register</INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-cars</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>new_heads</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <INDEX><USE>new_tails</USE> register</INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-cdrs</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>new_tails</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    Garbage collection is triggered when we exhaust the free cells in the
    current working memory, that is, when a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operation attempts to increment the <SCHEMEINLINE>free</SCHEMEINLINE>
    pointer beyond the end of the memory vector.  When the garbage-collection
    process is complete, the <SCHEMEINLINE>root</SCHEMEINLINE> pointer will
    point into the new memory, all objects accessible from the
    <SCHEMEINLINE>root</SCHEMEINLINE> will have been moved to the new memory,
    and the <SCHEMEINLINE>free</SCHEMEINLINE> pointer will indicate the next
    place in the new memory where a new pair can be allocated.  In addition,
    the roles of working memory and new memory will have been
    interchanged<EMDASH/>new pairs will be constructed in the new memory,
    beginning at the place indicated by <SCHEMEINLINE>free</SCHEMEINLINE>, and
    the (previous) working memory will be available as the new memory for the
    next garbage collection.
    <SPLITINLINE>
      <SCHEME>Figure<SPACE/><REF NAME="fig:memory-reconfig_scheme"/></SCHEME>
      <JAVASCRIPT>Figure<SPACE/><REF NAME="fig:memory-reconfig"/></JAVASCRIPT>
    </SPLITINLINE>
    shows the arrangement of memory just before and just after garbage
    collection.
    <SPLIT>
      <SCHEME>
	<FIGURE src="img_original/Fig5.15c.std.svg">
          <CAPTION>
	    Reconfiguration of memory by the garbage-collection process.
	  </CAPTION>
          <LABEL NAME="fig:memory-reconfig_scheme"/>
	</FIGURE>
      </SCHEME>
      <JAVASCRIPT>
	<FIGURE>
	  <FIGURE scale_factor="3" src="img_javascript/Fig5.15c.std.svg"/>
          <CAPTION>
	    Reconfiguration of memory by the garbage-collection process.
	  </CAPTION>
          <LABEL NAME="fig:memory-reconfig"/>
	</FIGURE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    The state of the garbage-collection process is controlled by
    maintaining two pointers:
    <INDEX><USE>free</USE> register</INDEX>
    <SCHEMEINLINE>free</SCHEMEINLINE> and
    <INDEX><USE>scan</USE> register</INDEX>
    <SCHEMEINLINE>scan</SCHEMEINLINE>.  These are initialized to point to the
    beginning of the new memory.  The algorithm begins by relocating the pair
    pointed at by <SCHEMEINLINE>root</SCHEMEINLINE> to the beginning of the new
    memory.  The pair is copied, the <SCHEMEINLINE>root</SCHEMEINLINE> pointer
    is adjusted to point to the new location, and the
    <SCHEMEINLINE>free</SCHEMEINLINE> pointer is incremented.  In addition, the
    old location of the pair is marked to show that its contents have been
    moved.  This marking is done as follows: In the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position, we place a special tag that signals that this is an already-moved
    object.  (Such an object is traditionally called a 
    <INDEX>broken heart</INDEX>
    <EM>broken heart</EM>.)<FOOTNOTE>The term 
    <EM>broken heart</EM> was coined by
    <INDEX>Cressey, David</INDEX>
    David Cressey, who wrote a garbage collector
    for 
    <INDEX>MDL</INDEX>
    <INDEX>Lisp<SUBINDEX>MDL, dialect of</SUBINDEX></INDEX>
    MDL, a dialect of Lisp developed at MIT during the early 1970s.</FOOTNOTE>
    In the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position we place a 
    <INDEX>forwarding address</INDEX>
    <EM>forwarding address</EM> that points at the location to which the object
    has been moved.
  </TEXT>

  <TEXT>
    After relocating the root, the garbage collector enters its basic
    cycle.  At each step in the algorithm, the
    <SCHEMEINLINE>scan</SCHEMEINLINE> pointer
    (initially pointing at the relocated root) points at a pair that has
    been moved to the new memory but whose
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointers still refer to objects in the old memory.  These objects are each
    relocated, and the <SCHEMEINLINE>scan</SCHEMEINLINE> pointer is incremented.
    To relocate an object (for example, the object indicated by the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer of the pair we are scanning) we check to see if the object has
    already been moved (as indicated by the presence of a broken-heart tag
    in the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position of the object).  If the object has not
    already been moved, we copy it to the place indicated by
    <SCHEMEINLINE>free</SCHEMEINLINE>,
    update <SCHEMEINLINE>free</SCHEMEINLINE>, set up a broken heart at the
    object<APOS/>s old location, and update the pointer to the object (in this
    example, the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer of the pair we are scanning) to point
    to the new location.  If the object has already been moved, its
    forwarding address (found in the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position of the broken heart) is substituted for the pointer in the pair
    being scanned. Eventually, all accessible objects will have been moved and
    scanned, at which point the <SCHEMEINLINE>scan</SCHEMEINLINE> pointer will
    overtake the <SCHEMEINLINE>free</SCHEMEINLINE> pointer and the process will
    terminate.
  </TEXT>
  
  <TEXT>
    We can specify the stop-and-copy algorithm as a sequence of instructions for
    a register machine.  The basic step of relocating an object is accomplished
    by a subroutine called
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>relocate-old-result-in-new</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>relocate_old_result_in_new</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    This subroutine gets its argument, a pointer to the object to be relocated,
    from a register named 
    <INDEX><USE>old</USE> register</INDEX>
    <SCHEMEINLINE>old</SCHEMEINLINE>.  It relocates the designated object
    (incrementing <SCHEMEINLINE>free</SCHEMEINLINE> in the process),
    puts a pointer to the relocated object into a register called 
    <INDEX><USE>new</USE> register</INDEX>
    <SCHEMEINLINE>new</SCHEMEINLINE>, and returns by branching to the entry
    point stored in the register
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>relocate-continue</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>relocate_continue</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    To begin garbage collection, we invoke this subroutine to relocate the
    <SCHEMEINLINE>root</SCHEMEINLINE> pointer, after initializing
    <SCHEMEINLINE>free</SCHEMEINLINE> and <SCHEMEINLINE>scan</SCHEMEINLINE>.
    When the relocation of <SCHEMEINLINE>root</SCHEMEINLINE> has been
    accomplished, we install the new pointer as the new
    <SCHEMEINLINE>root</SCHEMEINLINE> and enter the main loop of the garbage
    collector.
    <SNIPPET EVAL="no">
      <NAME>begin_garbage_collection</NAME>
      <SCHEME>
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
      </SCHEME>
      <JAVASCRIPT>
"begin_garbage_collection",
  assign("free", constant(0)),
  assign("scan", constant(0)),
  assign("old", reg("root")),
  assign("relocate_continue", label("reassign_root")),
  go_to(label("relocate_old_result_in_new")),
"reassign_root",
  assign("root", reg("new")),
  go_to(label("gc_loop")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    In the main loop of the garbage collector we must determine whether
    there are any more objects to be scanned.  We do this by testing
    whether the <SCHEMEINLINE>scan</SCHEMEINLINE> pointer is coincident with
    the <SCHEMEINLINE>free</SCHEMEINLINE> pointer.  If the pointers are equal,
    then all accessible objects have been relocated, and we branch to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>gc-flip</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>gc_flip</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    which cleans things up so that we can continue the interrupted computation.
    If there are still pairs to be scanned, we call the relocate subroutine to
    relocate the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the next pair (by placing the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer in <SCHEMEINLINE>old</SCHEMEINLINE>).  The
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>relocate-continue</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>relocate_continue</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    register is set up so that the subroutine will return to update the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer.
    <SNIPPET EVAL="no">
      <NAME>gc_loop</NAME>
      <SCHEME>
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
      </SCHEME>
      <JAVASCRIPT>
"gc_loop",
  test(list(op("==="), reg("scan"), reg("free"))),
  branch(label("gc_flip")),
  assign("old", list(op("vector_ref"), reg("new_heads"), reg("scan"))),
  assign("relocate_continue", label("update_head")),
  go_to(label("relocate_old_result_in_new")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  
  <TEXT>
    At
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>update-car</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>update_head</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    we modify the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer of the pair being scanned, then proceed to relocate the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the pair.  We return to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>update-cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>update_tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    when that relocation has been accomplished. After relocating and updating
    the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    we are finished scanning that pair, so we continue with the main loop.
    <SNIPPET EVAL="no">
      <NAME>update_head</NAME>
      <SCHEME>
update-car
  (perform
  (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform
  (op vector-set!) (reg new-cdrs) (reg scan) (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
      </SCHEME>
      <JAVASCRIPT>
"update_head",
  perform(list(op("vector_set"), 
               reg("new_heads"), reg("scan"), reg("new"))),
  assign("old", list(op("vector_ref"), 
                     reg("new_tails"), reg("scan"))),
  assign("relocate_continue", label("update_tail")),
  go_to(label("relocate_old_result_in_new")),

"update_tail",
  perform(list(op("vector_set"), 
               reg("new_tails"), reg("scan"), reg("new"))),
  assign("scan", list(op("+"), reg("scan"), constant(1))),
  go_to(label("gc_loop")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The subroutine
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>relocate-old-result-in-new</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>relocate_old_result_in_new</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    relocates objects as follows: If the object to be relocated (pointed at by
    <SCHEMEINLINE>old</SCHEMEINLINE>) is not a pair, then we return the same
    pointer to the object unchanged (in <SCHEMEINLINE>new</SCHEMEINLINE>).
    (For example, we may be scanning a pair whose
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is the number 4.  If we represent the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    by <SCHEMEINLINE>n4</SCHEMEINLINE>, as described in
    section<SPACE/><REF NAME="sec:impl-list-ops"/>, then we want the
    <QUOTE>relocated</QUOTE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    pointer to still be <SCHEMEINLINE>n4</SCHEMEINLINE>.)  Otherwise, we
    must perform the relocation.  If the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position of the pair to be relocated contains a broken-heart tag, then the
    pair has in fact already been moved, so we retrieve the forwarding address
    (from the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    position of the broken heart) and return this in
    <SCHEMEINLINE>new</SCHEMEINLINE>. If the pointer in
    <SCHEMEINLINE>old</SCHEMEINLINE> points at a yet-unmoved pair, then we move
    the pair to the first free cell in new memory (pointed at by
    <SCHEMEINLINE>free</SCHEMEINLINE>) and set up the broken heart by storing a
    broken-heart tag and forwarding address at the old location.
    <SPLITINLINE>
      <SCHEME>Relocate-old-result-in-new</SCHEME>
      <JAVASCRIPT>The subroutine
      <JAVASCRIPTINLINE>relocate_old_result_in_new</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    uses a register 
    <SPLITINLINE>
      <SCHEME>
	<INDEX><USE>oldcr</USE> register</INDEX>
	<SCHEMEINLINE>oldcr</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX><USE>oldht</USE> register</INDEX>
	<JAVASCRIPTINLINE>oldht</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to hold the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    or the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    of the object pointed at by <SCHEMEINLINE>old</SCHEMEINLINE>.<FOOTNOTE>The
    garbage collector uses the low-level predicate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pointer-to-pair?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pointer_to_pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    instead of the list-structure
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pair?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    operation because in a real system there might be various things
    that are treated as pairs for garbage-collection purposes.
    For example,
    <SPLITINLINE>
      <SCHEME>
    in a Scheme system that conforms to the IEEE standard
      </SCHEME>
    </SPLITINLINE>
    a
    <SPLITINLINE>
      <SCHEME>
	procedure
      </SCHEME>
      <JAVASCRIPT>
	      function
      </JAVASCRIPT>
    </SPLITINLINE>
    object may be implemented as a special kind of
    <QUOTE>pair</QUOTE> that doesn<APOS/>t satisfy the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pair?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    predicate.
    For simulation purposes,
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pointer-to-pair?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pointer_to_pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    can be implemented as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>pair?</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_pair</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
  </FOOTNOTE>

    <SNIPPET EVAL="no">
      <NAME>relocate_old_result_in_new</NAME>
      <SCHEME>
relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) <EM>; new location for pair</EM>
  <EM>;; Update free pointer.</EM>
  (assign free (op +) (reg free) (const 1))
  <EM>;; Copy the car and cdr to new memory.</EM>
  (perform (op vector-set!)
  (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
  (reg new-cdrs) (reg new) (reg oldcr))
  <EM>;; Construct the broken heart.</EM>
  (perform (op vector-set!)
  (reg the-cars) (reg old) (const broken-heart))
  (perform
  (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
      </SCHEME>
      <JAVASCRIPT>
"relocate_old_result_in_new",
  test(list(op("is_pointer_to_pair"), reg("old"))),
  branch(label("pair")),
  assign("new", reg("old")),
  go_to(reg("relocate_continue")),
"pair",
  assign("oldht", list(op("vector_ref"), 
                       reg("the_heads"), reg("old"))),
  test(list(op("is_broken_heart"), reg("oldht"))),
  branch(label("already_moved")),
  assign("new", reg("free")),     // new location for pair
  // Update "free" pointer.
  assign("free", list((op("+"), reg("free"), constant(1))),
  // Copy the head and tail to new memory
  perform(list(op("vector_set"), reg("new_heads"), reg("new"), reg("oldht"))),
  assign("oldht", list(op("vector_ref"), 
                       reg("the_tails"), reg("old"))),
  perform(list(op("vector_set"), reg("new_tails"), reg("new"), reg("oldht"))),
  // Construct the broken heart
  perform(list(op("vector_set"),
               reg("the_heads"), reg("old"), 
               constant("broken_heart"))),
  perform(list(op("vector_set"),  reg("the_tails"), reg("old"), reg("new"))),
  go_to(reg("relocate_continue")),
"already_moved",
  assign("new", list(op("vector_ref"), 
                     reg("the_tails"), reg("old"))),
  go_to(reg("relocate_continue")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    At the very end of the garbage collection process, we interchange the
    role of old and new memories by interchanging pointers: interchanging
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cars</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_heads</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    with
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-cars</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>new_heads</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>the-cdrs</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>the_tails</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    with
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>new-cdrs</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>new_tails</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    We will then be ready to perform another garbage
    collection the next time memory runs out.
    <SNIPPET>
      <NAME>testing_5_3_2</NAME>
      <REQUIRES>tagged_list</REQUIRES>
      <REQUIRES>make_go_to</REQUIRES>
      <REQUIRES>pop</REQUIRES>
      <REQUIRES>assoc</REQUIRES>
      <REQUIRES>go_to_go_to_dest</REQUIRES>
      <REQUIRES>make_register</REQUIRES>
      <SCHEME>
      gc-flip
      (assign temp (reg the-cdrs))
      (assign the-cdrs (reg new-cdrs))
      (assign new-cdrs (reg temp))
      (assign temp (reg the-cars))
      (assign the-cars (reg new-cars))
      (assign new-cars (reg temp))
      </SCHEME>
      <JAVASCRIPT_RUN>
// TYPED POINTERS

const NUMBER_TYPE = "number";
const BOOL_TYPE = "bool";
const STRING_TYPE = "string";
const PTR_TYPE = "ptr";
const PROG_TYPE = "prog";
const NULL_TYPE = "null";
const UNDEFINED_TYPE = "undefined";
const NO_VALUE_YET_TYPE = "*unassigned*";
const BROKEN_HEART_TYPE = "broken_heart";

function make_ptr_ptr(idx) {
    return pair(PTR_TYPE, idx);
}

function make_null_ptr() {
    return pair(NULL_TYPE, null);
}

function make_no_value_yet_ptr() {
    return pair(NO_VALUE_YET_TYPE, null);
}

function make_prog_ptr(idx) {
    return pair(PROG_TYPE, idx);
}

function make_broken_heart_ptr(idx) {
    return pair(BROKEN_HEART_TYPE, idx);
}

function get_elem_type(elem) {
    return is_number(elem) ? NUMBER_TYPE :
        is_boolean(elem) ? BOOL_TYPE :
        is_string(elem) ? STRING_TYPE :
        is_null(elem) ? NULL_TYPE :
        is_undefined(elem) ? UNDEFINED_TYPE :
        error(elem, "invalid typed elem");
}

function wrap_ptr(elem) {
    return pair(get_elem_type(elem), elem);
}

function unwrap_ptr(ptr) {
    return tail(ptr);
}

function is_ptr(ptr) {
    return is_pair(ptr) &amp;&amp;
        !is_pair(head(ptr)) &amp;&amp;
        !is_pair(tail(ptr)) &amp;&amp;
        (head(ptr) === NUMBER_TYPE ||
        head(ptr) === BOOL_TYPE ||
        head(ptr) === STRING_TYPE ||
        head(ptr) === PTR_TYPE ||
        head(ptr) === NULL_TYPE ||
        head(ptr) === UNDEFINED_TYPE ||
        head(ptr) === PROG_TYPE ||
        head(ptr) === NO_VALUE_YET_TYPE ||
        head(ptr) === BROKEN_HEART_TYPE);
}

function is_number_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === NUMBER_TYPE;
}

function is_bool_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === BOOL_TYPE;
}

function is_string_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === STRING_TYPE;
}

function is_ptr_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === PTR_TYPE;
}

function is_null_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === NULL_TYPE;
}

function is_undefined_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === UNDEFINED_TYPE;
}

function is_prog_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === PROG_TYPE;
}

function is_no_value_yet_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === NO_VALUE_YET_TYPE;
}

function is_broken_heart_ptr(ptr) {
    return is_ptr(ptr) &amp;&amp; head(ptr) === BROKEN_HEART_TYPE;
}

// Primitive functions and constants

const primitive_function_names_arities = list(
       pair("display", 1),
       pair("error", 1),
       pair("+", 2),
       pair("-", 2),
       pair("*", 2),
       pair("/", 2),
       pair("%", 2),
       pair("===", 2),
       pair("!==", 2),
       pair("&lt;", 2),
       pair("&lt;=", 2),
       pair("&gt;", 2),
       pair("&gt;=", 2),
       pair("!", 1),
       pair("||", 2),
       pair("&amp;&amp;", 2)
);

const primitive_constants = list(
       list("undefined", undefined),
       list("math_PI"  , math_PI)
      );
       
function make_primitive_function(impl) {
    return list("primitive", impl);
}

function setup_environment() {
    const primitive_function_names =
        map(head, primitive_function_names_arities);
    const primitive_function_values =
        map(name => pair(make_primitive_function(name), false),
            primitive_function_names);
    const primitive_constant_names =
        map(head, primitive_constants);
    const primitive_constant_values =
        map(f => pair(head(tail(f)), false),
            primitive_constants);
    return pair(pair(
               append(primitive_function_names, 
                      primitive_constant_names),
               append(primitive_function_values, 
                      primitive_constant_values)),
               null);
}

function flatten_list_to_vectors(the_heads, the_tails, lst,
                                 make_ptr_fn, starting_index) {
    let free = starting_index;
    function helper(lst) {
        if (!is_pair(lst)) {
            return wrap_ptr(lst);
        } else {
            const index = free;
            free = free + 1;
            const elem = head(lst);
            the_heads[index] = helper(elem);
            the_tails[index] = helper(tail(lst));
            return make_ptr_fn(index);
        }
    }
    helper(lst);
    return free;
}

// MACHINE
function get_contents(register) {
    return register("get");
}

function set_contents(register, value) {
    return register("set")(value);
}

function make_stack() {
    let stack = null;

    function push(x) { 
        stack = pair(x, stack); 
        return "done";
    }

    function pop() {
        if (is_null(stack)) {
            error("empty stack -- pop");

        } else {
            const top = head(stack);
            stack = tail(stack);
            return top;
        }
    }

    function initialize() {
        stack = null;
        return "done";
    }

    function dispatch(message) {
        return message === "push"
               ? push
               : message === "pop"
               ? pop()
               : message === "initialize"
               ? initialize()
               : message === "stack"
               ? stack
               : error(message, "unknown request -- stack");
    }

    return dispatch;
}

function make_new_machine() {
    const SIZE = make_register("SIZE");
    const pc = make_register("pc");
    const flag = make_register("flag");
    const stack = make_stack();
    const stack_reassign_proc = make_register("stack_reassign_proc");
    const free = make_register("free");
    const root = make_register("root");
    const root_populate_proc = make_register("root_populate_proc");
    const root_restore_proc = make_register("root_restore_proc");
    const gc_registers = list(
        list("free", free),
        list("scan", make_register("scan")),
        list("old", make_register("old")),
        list("new", make_register("new")),
        list("relocate_continue", make_register("relocate_continue")),
        list("temp", make_register("temp")),
        list("oldht", make_register("oldht"))
    );
    const exp = make_register("exp");
    const env = make_register("env");
    const evaluator_registers = list(
        list("exp", exp),
        list("env", env),
        list("val", make_register("val")),
        list("continue", make_register("continue")),
        list("fun", make_register("fun")),
        list("argl", make_register("argl")),
        list("unev", make_register("unev")),
        list("fun", make_register("fun"))
    );
    const aux_registers = list(
        list("res", make_register("val")),
        list("err", make_register("err")),
        list("a", make_register("a")),
        list("b", make_register("b")),
        list("c", make_register("c")),
        list("d", make_register("d")),
        list("e", make_register("e")),
        list("f", make_register("f"))
    );
    const the_heads = make_register("the_heads");
    const the_tails = make_register("the_tails");
    set_contents(the_heads, make_vector());
    set_contents(the_tails, make_vector());
    const new_heads = make_register("new_heads");
    const new_tails = make_register("new_tails");
    set_contents(new_heads, make_vector());
    set_contents(new_tails, make_vector());
    const prog_heads = make_register("prog_heads");
    const prog_tails = make_register("prog_tails");
    let the_instruction_sequence = null;
    let the_ops = list(list("initialize_stack",
                            () => stack("initialize")));
    the_ops = append(the_ops, vector_ops);
    let register_table =
          list(list("SIZE", SIZE),
               list("pc", pc),
               list("flag", flag),
               list("root", root),
               list("root_populate_proc", root_populate_proc),
               list("root_restore_proc", root_restore_proc),
               list("stack_reassign_proc", stack_reassign_proc),
               list("the_heads", the_heads),
               list("the_tails", the_tails),
               list("new_heads", new_heads),
               list("new_tails", new_tails),
               list("prog_heads", prog_heads),
               list("prog_tails", prog_tails));
    register_table = append(register_table, gc_registers);
    register_table = append(register_table, evaluator_registers);
    register_table = append(register_table, aux_registers);

    function start() {
        const root_registers = 
                append(aux_registers, evaluator_registers);
        set_contents(pc, the_instruction_sequence);
        set_contents(free,
                     make_ptr_ptr(flatten_list_to_vectors(
                                    the_heads("get"),
                                    the_tails("get"),
                                    setup_environment(), 
                                    make_ptr_ptr,
                                    length(root_registers))));
        set_contents(env, make_ptr_ptr(length(root_registers)));
        function root_populate_proc_fn() {
            const root_ptr = free("get");
            root("set")(root_ptr);
            let register_list = root_registers;
            while (!is_null(register_list)) {
                const content = head(tail(head(register_list)))("get");
                const index = unwrap_ptr(free("get"));
                the_heads("get")[index] = 
                  content === "*unassigned*"
                  ? make_null_ptr() : content;
                free("set")(make_ptr_ptr(index + 1));
                the_tails("get")[index] = free("get");
                register_list = tail(register_list);
            }
            the_tails("get")[unwrap_ptr(free("get")) - 1] =
              make_null_ptr();
        }
        function root_restore_proc_fn() {
            let root_ptr = root("get");
            let register_list = root_registers;
            while (!is_null(register_list)) {
                const index = unwrap_ptr(root_ptr);
                const value = the_heads("get")[index];
                head(tail(head(register_list)))("set")(value);
                root_ptr = the_tails("get")[index];
                register_list = tail(register_list);
            }
        }
        function stack_reassign_proc_fn() {
            let local_stack = stack("stack");
            while (!is_null(local_stack)) {
                const value = head(local_stack);
                if (is_ptr_ptr(value)) {
                    const index = unwrap_ptr(value);
                    const new_ptr = the_tails("get")[index];
                    set_head(local_stack, new_ptr);
                } else {}
                local_stack = tail(local_stack);
            }
        }
        set_contents(root_populate_proc, root_populate_proc_fn);
        set_contents(root_restore_proc, root_restore_proc_fn);
        set_contents(stack_reassign_proc, stack_reassign_proc_fn);
        return execute();  
    } 
    function allocate_register(name) {
        if (is_undefined(assoc(name, register_table))) {
        register_table = pair(list(name, make_register(name)),
                              register_table);
        } else {
            error(name, "multiply defined register");
        }
        return "register allocated";
    }
    function lookup_register(name) {
        const val = assoc(name, register_table);
        return is_undefined(val)
               ? error(name, "unknown register")
               : head(tail(val));
    }
    function execute() {
        const insts = get_contents(pc);
        if (is_null(insts)) {
            return "done";
        } else {
            const proc = instruction_execution_fun(head(insts));
            proc(); 
            return execute();
        }
    }
    function dispatch(message) {
        return message === "start"
               ? start
               : message === "install_instruction_sequence"
               ? seq => { the_instruction_sequence = seq; }
               : message === "allocate_register"
               ? allocate_register
               : message === "get_register"
               ? lookup_register
               : message === "install_operations"
               ? ops => { the_ops = append(the_ops, ops); }
               : message === "stack"
               ? stack
               : message === "operations"
               ? the_ops
               : error(message, "unknown request -- machine");
    }
    return dispatch;
}

function make_machine(register_names, ops, controller) {
    const machine = make_new_machine();

    map(reg_name => machine("allocate_register")(reg_name), register_names);
    machine("install_operations")(ops);
    machine("install_instruction_sequence")(assemble(controller, machine));

    return machine;
}

function start(machine) {
    return machine("start")();
}

function get_register_contents(machine, register_name) {
    return get_contents(get_register(machine, register_name));
}

function set_register_contents(machine, register_name, value) {
    set_contents(get_register(machine, register_name), value);
    return "done";
}

function get_register(machine, reg_name) {
    return machine("get_register")(reg_name);
}


// ASSEMBLER

function assemble(controller, machine) {
    function receive(insts, labels) {
        update_insts(insts, labels, machine);
        return insts;
    }
    
    return extract_labels(controller, receive);
}

function extract_labels(text, receive) {
    function helper(insts, labels) { 
        const next_inst = head(text);

        return is_string(next_inst)
               ? receive(insts, pair(make_label_entry(next_inst, insts), labels))
               : receive(pair(make_instruction(next_inst), insts), labels);
    }

    return is_undefined(text) || is_null(text)
           ? receive(null, null)
           : extract_labels(tail(text), helper);
}

function update_insts(insts, labels, machine) {
    const pc = get_register(machine, "pc");
    const flag = get_register(machine, "flag");
    const stack = machine("stack");
    const ops = machine("operations");

    const set_iep = set_instruction_execution_fun;
    const make_ep = make_execution_function;
    return map(i => set_iep(i,
                            make_ep(instruction_text(i),
                                    labels,
                                    machine,
                                    pc,
                                    flag,
                                    stack,
                                    ops)),
               insts);
}

function make_instruction(text) {
    return pair(text, null);
}

function instruction_text(inst) {
    return head(inst);
}

function instruction_execution_fun(inst) {
    return tail(inst);
}

function set_instruction_execution_fun(inst, proc) {
    set_tail(inst, proc); 
}

function make_label_entry(label_name, insts) {
    return pair(label_name, insts);
}

function lookup_label(labels, label_name) {
    const val = assoc(label_name, labels);

    return is_undefined(val)
           ? error(label_name, "undefined label -- assemble")
           : tail(val);
}

function make_execution_function(inst, labels, machine, pc, flag, stack, ops) {
    const x = head(inst);

    return x === "assign"
           ? make_assign_ef(inst, machine, labels, ops, pc)
           : x === "test"
           ? make_test_ef(inst, machine, labels, ops, flag, pc)
           : x === "branch"
           ? make_branch_ef(inst, machine, labels, flag, pc)
           : x === "go_to"
           ? make_go_to_ef(inst, machine, labels, pc)
           : x === "save"
           ? make_save_ef(inst, machine, stack, pc)
           : x === "restore"
           ? make_restore_ef(inst, machine, stack, pc)
           : x === "perform"
           ? make_perform_ef(inst, machine, labels, ops, pc)
           : x === "dump_memory" // Added to allow printing the memory vectors
           ? () => {
               display(stringify(get_register_contents(machine, "the_heads")));
               display(stringify(get_register_contents(machine, "the_tails")));
               advance_pc(pc);
           }
           : error(inst, "unknown instruction type -- assemble");
}

function make_assign_ef(inst, machine, labels, operations, pc) {
    const target = get_register(machine, assign_reg_name(inst));
    const value_exp = assign_value_exp(inst);
    const value_fun = is_operation_exp(value_exp)
          ? make_operation_exp_ef(value_exp, machine, labels, operations)
          : make_primitive_exp_ef(value_exp, machine, labels);

    function perform_assign() {
        set_contents(target, value_fun());
        advance_pc(pc); 
    }

    return perform_assign;
}

function assign_reg_name(assign_instruction) {
    return head(tail(assign_instruction));
}

function assign_value_exp(assign_instruction) { 
    return head(tail(tail(assign_instruction)));
}

function assign(reg_name, value_exp) {
    return list("assign", reg_name, value_exp);
}

function dump_memory() {
    return list("dump_memory", "the_heads", "the_tails");
}

function advance_pc(pc) {
    set_contents(pc, tail(get_contents(pc))); 
    
}

function make_test_ef(inst, machine, labels, operations, flag, pc) {
    const condition = test_condition(inst);

    if (is_operation_exp(condition)) {
    const condition_fun = make_operation_exp_ef(condition, machine,
                                             labels, operations);

        function perform_test() {
            set_contents(flag, unwrap_ptr(condition_fun()));
            advance_pc(pc); 
        }

        return perform_test; 
    } else {
        error(inst, "bad test instruction -- assemble");
    }
}

function test_condition(test_instruction) {
    return head(tail(test_instruction));
}

function test(condition) {
    return list("test", condition);
}

function make_branch_ef(inst, machine, labels, flag, pc) {
    const dest = branch_dest(inst);
    
    if (is_label_exp(dest)) {
        const insts = lookup_label(labels, label_exp_label(dest));

        function perform_branch() {
            if (get_contents(flag)) {
                set_contents(pc, insts);

            } else {
                advance_pc(pc);
            }
        }

        return perform_branch;

    } else {
        error(inst, "bad branch instruction -- assemble");
    }
}

function branch_dest(branch_instruction) {
    return head(tail(branch_instruction));
}

function branch(dest) {
    return list("branch", dest);
}

function make_goto(inst, machine, labels, pc) {
    const dest = goto_dest(inst);

    if (is_label_exp(dest)) {
        const insts = lookup_label(labels, label_exp_label(dest));
        return () => set_contents(pc, insts);

    } else if (is_register_exp(dest)) {
        const reg = get_register(machine, register_exp_reg(dest));
        return () => set_contents(pc, get_contents(reg));

    } else {
        error(inst, "bad go_to instruction -- assemble");
    }
}

function goto_dest(goto_instruction) {
    return head(tail(goto_instruction));
}
/*
function go_to(dest) {
    return list("go_to", dest);
}
*/
function make_save_ef(inst, machine, stack, pc) {
    const reg = get_register(machine, stack_inst_reg_name(inst));

    function perform_save() {
        push(stack, get_contents(reg));
        advance_pc(pc);
    }

    return perform_save;
}

function make_restore_ef(inst, machine, stack, pc) {
    const reg = get_register(machine, stack_inst_reg_name(inst));

    function perform_restore() {
        set_contents(reg, pop(stack));
        advance_pc(pc); 
    }

    return perform_restore;
}

function stack_inst_reg_name(stack_instruction) {
    return head(tail(stack_instruction));
}

function save(register_name) {
    return list("save", register_name);
}

function restore(register_name) {
    return list("restore", register_name);
}

function make_perform_ef(inst, machine, labels, operations, pc) {
    const action = perform_action(inst);

    if (is_operation_exp(action)) {
        const action_fun = make_operation_exp_ef(action, machine, 
                                              labels, operations);
        return () => { action_fun(); advance_pc(pc); };

    } else {
        error(inst, "bad perform instruction -- assemble");
    }
}

function perform_action(inst) {
    return head(tail(inst)); 
}

function perform(op) {
    return list("perform", op);
}


function make_primitive_exp_ef(exp, machine, labels) {
    if (is_constant_exp(exp)) {
        const c = constant_exp_value(exp);
        return () => c;
        
    } else if (is_label_exp(exp)) {
        const insts = lookup_label(labels, label_exp_label(exp));
        return () => insts;

    } else if (is_register_exp(exp)) {
        const r = get_register(machine, register_exp_reg(exp));
        return () => get_contents(r); 

    } else {
        error(exp, "unknown expression type -- assemble");
    }
}

/* TODO: probably remove these -- suddenly available through new import chains
function is_register_exp(exp) {
    return is_tagged_list(exp, "reg");
}

function register_exp_reg(exp) {
    return head(tail(exp));
}

function reg(name) {
    return list("reg", name);
}

function is_constant_exp(exp) {
    return is_tagged_list(exp, "constant");
}

function constant_exp_value(exp) {
    return head(tail(exp));
}

function constant(value) {
    return list("constant", wrap_ptr(value));
}

function is_label_exp(exp) {
    return is_tagged_list(exp, "label");
}

function label_exp_label(exp) {
    return head(tail(exp));
}

function label(string) {
    return list("label", string);
}
*/

function make_operation_exp_ef(exp, machine, labels, operations) {
    const op = lookup_prim(op_exp_op(exp), operations);
    const aprocs = map(e => make_primitive_exp_ef(e, machine, labels),
                       operation_exp_operands(exp));

    function perform_operation_exp() {
        return op(map(p => p(), aprocs));
    }
    
    return perform_operation_exp;
}

/* TODO: probably remove these -- suddenly available through new import chains
function is_operation_exp(exp) {
    return is_tagged_list(head(exp), "op");
}

function operation_exp_operands(operation_exp) {
    return tail(operation_exp);
}

function op(name) {
    return list("op", name);
}
*/

function op_exp_op(operation_exp) {
    return head(tail(head(operation_exp)));
}

function lookup_prim(symbol, operations) {
    const val = assoc(symbol, operations);

    return is_undefined(val)
           ? error(symbol, "unknown operation -- assemble")
           : head(tail(val));
}

// PAIR OPERATIONS

// head in "a", tail in "b"
const pair_controller = list(
  "pair",
    save("continue"),
    assign("continue", label("pair_after_gc")),
    test(list(op("==="), reg("free"), reg("SIZE"))),
    branch(label("begin_garbage_collection")),
  "pair_after_gc",
    restore("continue"),
    perform(list(op("vector_set"), reg("the_heads"), reg("free"), reg("a"))),
    perform(list(op("vector_set"), reg("the_tails"), reg("free"), reg("b"))),
    assign("res", reg("free")),
    assign("free", list(op("inc_ptr"), reg("free"))),
    go_to(reg("continue"))
);


function underlying_javascript_closure(fn) {
    return args => apply_in_underlying_javascript(fn, args);
}

function unwrap_args(fn) {
    return args => fn(map(unwrap_ptr, args));
}

function wrap_return_value(fn) {
    return args => wrap_ptr(fn(args));
}

function primitive_function(fn) {
    return wrap_return_value(unwrap_args(underlying_javascript_closure(fn)));
}

// 5.3 MEMORY MANAGEMENT

function vector_ref(vector, idx) {
    return vector[unwrap_ptr(idx)];
}

function vector_set(vector, idx, val) {
    vector[unwrap_ptr(idx)] = val;
}

function make_vector() {
    return [];
}

function inc_ptr(ptr) {
    return make_ptr_ptr(unwrap_ptr(ptr) + 1);
}

const vector_ops = list(
    list("vector_ref", underlying_javascript_closure(vector_ref)),
    list("vector_set", underlying_javascript_closure(vector_set)),
    list("inc_ptr", underlying_javascript_closure(inc_ptr))
);

// MACHINE SETUP
const ptr_ops =
  list(
    list("make_ptr_ptr",
         unwrap_args(underlying_javascript_closure(make_ptr_ptr))),
    list("make_null_ptr",
         underlying_javascript_closure(make_null_ptr)),
    list("make_no_value_yet_ptr",
         underlying_javascript_closure(make_no_value_yet_ptr)),
    list("make_prog_ptr", underlying_javascript_closure(make_prog_ptr)),
    list("make_broken_heart_ptr",
         underlying_javascript_closure(make_broken_heart_ptr)),
    list("is_number_ptr",
         wrap_return_value(underlying_javascript_closure(is_number_ptr))),
    list("is_bool_ptr",
         wrap_return_value(underlying_javascript_closure(is_bool_ptr))),
    list("is_string_ptr",
         wrap_return_value(underlying_javascript_closure(is_string_ptr))),
    list("is_ptr_ptr",
         wrap_return_value(underlying_javascript_closure(is_ptr_ptr))),
    list("is_null_ptr",
         wrap_return_value(underlying_javascript_closure(is_null_ptr))),
    list("is_undefined_ptr",
         wrap_return_value(underlying_javascript_closure(is_undefined_ptr))),
    list("is_prog_ptr",
         wrap_return_value(underlying_javascript_closure(is_prog_ptr))),
    list("is_no_value_yet_ptr",
         wrap_return_value(underlying_javascript_closure(is_no_value_yet_ptr))),
    list("is_broken_heart_ptr",
         wrap_return_value(underlying_javascript_closure(is_broken_heart_ptr)))
);

const primitive_ops = list(
    list("display", primitive_function(display)),
    list("error", primitive_function(error)),
    list("+", primitive_function((x, y) => x + y)),
    list("-", primitive_function((x, y) => x - y)),
    list("*", primitive_function((x, y) => x * y)),
    list("/", primitive_function((x, y) => x / y)),
    list("%", primitive_function((x, y) => x % y)),
    list("===", primitive_function((x, y) => x === y)),
    list("!==", primitive_function((x, y) => x !== y)),
    list("&lt;", primitive_function((x, y) => x &lt; y)),
    list("&lt;=", primitive_function((x, y) => x &lt;= y)),
    list("&gt;", primitive_function((x, y) => x &gt; y)),
    list("&gt;=", primitive_function((x, y) => x &gt;= y)),
    list("!", primitive_function(x => !x)),
    list("||", primitive_function((x, y) => x || y)),
    list("&amp;&amp;", primitive_function((x, y) => x &amp;&amp; y))
);

const gc_ops = list(
    list("call_proc", underlying_javascript_closure(proc => proc()))
);

const gc_controller = list(
  "begin_garbage_collection",
    perform(list(op("call_proc"), reg("root_populate_proc"))),
    assign("free", list(op("make_ptr_ptr"), constant(0))),
    assign("scan", list(op("make_ptr_ptr"), constant(0))),
    assign("old", reg("root")),
    assign("relocate_continue", label("reassign_root")),
    go_to(label("relocate_old_result_in_new")),
  "reassign_root",
    assign("root", reg("new")),
    go_to(label("gc_loop")),
  "gc_loop",
    test(list(op("==="), reg("scan"), reg("free"))),
    branch(label("gc_flip")),
    assign("old", list(op("vector_ref"), reg("new_heads"), reg("scan"))),
    assign("relocate_continue", label("update_head")),
    go_to(label("relocate_old_result_in_new")),
  "update_head",
    perform(list(op("vector_set"), reg("new_heads"), reg("scan"), reg("new"))),
    assign("old", list(op("vector_ref"), reg("new_tails"), reg("scan"))),
    assign("relocate_continue", label("update_tail")),
    go_to(label("relocate_old_result_in_new")),
  "update_tail",
    perform(list(op("vector_set"), reg("new_tails"), reg("scan"), reg("new"))),
    assign("scan", list(op("inc_ptr"), reg("scan"))),
    go_to(label("gc_loop")),
  "relocate_old_result_in_new",
    test(list(op("is_ptr_ptr"), reg("old"))),
    branch(label("gc_pair")),
    assign("new", reg("old")),
    go_to(reg("relocate_continue")),
  "gc_pair",
    assign("oldht", list(op("vector_ref"), reg("the_heads"), reg("old"))),
    test(list(op("is_broken_heart_ptr"), reg("oldht"))),
    branch(label("already_moved")),
    assign("new", reg("free")),
    // new location for pair
    // Update "free" pointer.
    assign("free", list(op("inc_ptr"), reg("free"))),
    // Copy the head and tail to new memory
    perform(list(op("vector_set"),
                 reg("new_heads"), reg("new"), reg("oldht"))),
    assign("oldht", list(op("vector_ref"), reg("the_tails"), reg("old"))),
    perform(list(op("vector_set"),
                 reg("new_tails"), reg("new"), reg("oldht"))),
    // Construct the broken heart
    assign("oldht", list(op("make_broken_heart_ptr"))),
    perform(list(op("vector_set"),
                 reg("the_heads"), reg("old"), reg("oldht"))),
    perform(list(op("vector_set"),
                 reg("the_tails"), reg("old"), reg("new"))),
    go_to(reg("relocate_continue")),
  "already_moved",
    assign("new", list(op("vector_ref"), reg("the_tails"), reg("old"))),
    go_to(reg("relocate_continue")),
  "gc_flip",
    perform(list(op("call_proc"), reg("stack_reassign_proc"))),
    assign("temp", reg("the_tails")),
    assign("the_tails", reg("new_tails")),
    assign("new_tails", reg("temp")),
    assign("temp", reg("the_heads")),
    assign("the_heads", reg("new_heads")),
    assign("new_heads", reg("temp")),
    perform(list(op("call_proc"), reg("root_restore_proc"))),
    go_to(reg("continue"))
);

const error_controller = list(
    "error",
    perform(list(op("error"), reg("res"), reg("err"))),
    go_to(label("end_evaluation"))
);

const begin_controller =  list(
  "fig_5_14",
  "pair4",
    assign("a", constant(4)),
    assign("b", list(op("make_null_ptr"))),
    assign("continue", label("garbage1")),
    go_to(label("pair")),
    /// The following creates a garbage
    /// pair (9999, 9999) which will
    /// not affect live object count at
    /// the end of the program. You can
    /// verify by adding more garbage
    /// or remove this line. Or
    /// uncomment the use of
    /// dump_memory() below, before and
    /// after GC.
  "garbage1",
    assign("a", constant(9999)),
    assign("b", constant(9999)),
    assign("continue", label("pair2")),
    go_to(label("pair")),
  "pair2",
    assign("a", constant(3)),
    assign("b", reg("res")),
    assign("continue", label("garbage2")),
    go_to(label("pair")), 
    /// The following creates a garbage
    /// pair (9999, 9999) which will
    /// not affect live object count at
    /// the end of the program. You can
    /// verify by adding more garbage
    /// or remove this line. Or
    /// uncomment the use of
    /// dump_memory() below, before and
    /// after GC.
  "garbage2",
    assign("a", constant(9999)),
    assign("b", constant(9999)),
    assign("continue", label("pair7")),
    go_to(label("pair")),
  "pair7",
    assign("temp", reg("res")),
    assign("a", constant(2)),
    assign("b", list(op("make_null_ptr"))),
    assign("continue", label("pair5")),
    go_to(label("pair")),
  "pair5",
    assign("a", constant(1)),
    assign("b", reg("res")),
    assign("continue", label("pair1")),
    go_to(label("pair")),
  "pair1",
    assign("a", reg("res")),
    assign("b", reg("temp")),
    assign("continue", label("done")),
    go_to(label("pair")),
  "done",
    // dump_memory(), // uncomment to get a dump of heads and tails vectors
    assign("continue", label("after_gc")),
    go_to(label("begin_garbage_collection")),
  "after_gc",
    // dump_memory(), // uncomment to get a dump of heads and tails vectors
    go_to(label("end_evaluation")));

const end_controller = list(
    "end_evaluation"
);

const ops = accumulate(append, null, list(
    vector_ops,
    ptr_ops,
    gc_ops,
    primitive_ops
));

const controller = accumulate(append, null, list(
    begin_controller,
    pair_controller,
    gc_controller,
    error_controller,
    end_controller
));

function make_evaluator_machine(size) {
    const evaluator_machine = make_machine(null, ops, controller);
    set_register_contents(evaluator_machine, "SIZE", wrap_ptr(size));
    return evaluator_machine;
}

const evaluator_machine = make_evaluator_machine(10000);

set_register_contents(evaluator_machine, "a", wrap_ptr(206));
set_register_contents(evaluator_machine, "b", wrap_ptr(40));

start(evaluator_machine);
get_register_contents(evaluator_machine, "free");
// [ 'ptr', 108 ] The number of live objects in the program at termination
      </JAVASCRIPT_RUN>      
      <EXPECTED>[ 'ptr', 108 ]</EXPECTED>
      <JAVASCRIPT>
"gc_flip",
    assign("temp", reg("the_tails")),
    assign("the_tails", reg("new_tails")),
    assign("new_tails", reg("temp")),
    assign("temp", reg("the_heads")),
    assign("the_heads", reg("new_heads")),
    assign("new_heads", reg("temp"))
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <INDEX>list-structured memory<CLOSE/></INDEX>
  <INDEX>memory<SUBINDEX>list-structured<CLOSE/></SUBINDEX></INDEX>
  <INDEX>garbage collection<CLOSE/></INDEX>
  <INDEX>stop-and-copy garbage collector<CLOSE/></INDEX>
  <INDEX>garbage collector<SUBINDEX>stop-and-copy<CLOSE/></SUBINDEX></INDEX>
  
</SUBSECTION>
