[{"id":"/sicpjs/5.3.1","tag":"TITLE","body":"5.3.1  \n    Memory as Vectors"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    A conventional computer memory can be thought of as an array of\n    cubbyholes, each of which can contain a piece of information.  Each\n    cubbyhole has a unique name, called its \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"address","tag":"#text"}]},{"body":" or \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"location","tag":"#text"}]},{"body":".  Typical memory systems provide two primitive operations:\n    one that fetches the data stored in a specified location and one that\n    assigns new data to a specified location.  Memory addresses can be\n    incremented to support sequential access to some set of the\n    cubbyholes.  More generally, many important data operations require\n    that memory addresses be treated as data, which can be stored in\n    memory locations and manipulated in machine registers.  The\n    representation of list structure is one application of such \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"address arithmetic","tag":"#text"}]},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    To model computer memory, we use a new kind of data structure called a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"vector","tag":"#text"}]},{"body":".  Abstractly, a vector is a compound data object whose\n    individual elements can be accessed by means of an integer index in an\n    amount of time that is independent of the index.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.3.1#footnote-1"},{"body":" In order to describe memory operations, we use two\n    functions\n    for manipulating vectors:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.3.1#footnote-2"},{"tag":"UL","child":[{"tag":"LI","child":[{"tag":"JAVASCRIPTINLINE","body":"vector_ref("},{"tag":"META","body":"vector"},{"tag":"JAVASCRIPTINLINE","body":", "},{"tag":"META","body":"n"},{"tag":"JAVASCRIPTINLINE","body":")"},{"body":"\n\treturns the ","tag":"#text"},{"tag":"META","body":"n"},{"body":"th element of the vector.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"tag":"JAVASCRIPTINLINE","body":"vector_set("},{"tag":"META","body":"vector"},{"tag":"JAVASCRIPTINLINE","body":", "},{"tag":"META","body":"n"},{"tag":"JAVASCRIPTINLINE","body":", "},{"tag":"META","body":"value"},{"tag":"JAVASCRIPTINLINE","body":")"},{"body":"\n\tsets the ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"th element of the vector to the\n\tdesignated value.\n      ","tag":"#text"}]}]},{"body":"\n\n    For example, if ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"v"},{"body":" is a vector, then\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"vector_ref(v, 5)"},{"body":"\n    gets the fifth entry in the vector ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"v"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"vector_set(v, 5, 7)"},{"body":"\n    changes the value of the fifth entry of the vector\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"v"},{"body":"\n    to 7.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/5.3.1#footnote-3"},{"body":" For computer memory, this access can be implemented\n    through the use of address arithmetic to combine a ","tag":"#text"},{"tag":"EM","child":[{"body":"base address","tag":"#text"}]},{"body":"\n    that specifies the beginning location of a vector in memory with an\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"index","tag":"#text"}]},{"body":" that specifies the offset of a particular element of the\n    vector.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Representing\n    \n    data","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    We can use vectors to implement the basic pair structures required for a\n    list-structured memory.  Let us imagine that computer memory is divided into\n    two vectors: \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_heads"},{"body":"\n    and \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_tails"},{"body":".\n    We will represent list structure as follows: A pointer to a pair is an index\n    into the two vectors.  The \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    of the pair is the entry in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_heads"},{"body":"\n    with the designated index, and the \n    tail\n    of the pair is the entry in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_tails"},{"body":"\n    with the designated index.  We also need a representation for objects other\n    than pairs (such as numbers and\n    strings)\n    and a way to distinguish one kind of data from another. There are many\n    methods of accomplishing this, but they all reduce to using \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"typed pointers","tag":"#text"}]},{"body":", that is, to extending the notion of\n    \"","tag":"#text"},{"body":"pointer","tag":"#text"},{"body":"\" to include information on data type.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/5.3.1#footnote-4"},{"body":" The data type enables the system to\n    distinguish a pointer to a pair (which consists of the \"","tag":"#text"},{"body":"pair","tag":"#text"},{"body":"\"\n    data type and an index into the memory vectors) from pointers to other\n    kinds of data (which consist of some other data type and whatever is\n    being used to represent data of that type).  Two data objects are\n    \n    considered to be the same\n    (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"==="},{"body":")\n    if their pointers are identical.\n    \n\tFigure ","tag":"#text"},{"tag":"REF","body":"5.14","href":"/sicpjs/5.3.1#fig-5.14"},{"body":"\n    illustrates the use of this method to represent \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(list(1, 2), 3, 4)"},{"body":",\n      \n    whose box-and-pointer diagram is also shown.  We use letter prefixes to\n    denote the data-type information.  Thus, a pointer to the pair with\n    index 5 is denoted ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"p5"},{"body":", the empty list\n    is denoted by the pointer ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"e0"},{"body":", and a pointer to\n    the number 4 is denoted ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n4"},{"body":".  In the\n    box-and-pointer diagram, we have indicated at the lower left of each pair\n    the vector index that specifies where the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    of the pair are stored.  The blank locations in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_heads"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_tails"},{"body":"\n    may contain parts of other list structures (not of interest here).\n    ","tag":"#text"},{"tag":"FIGURE","scale":"90%","src":"img_javascript/Fig5.14b.std.svg","id":"#fig-5.14","captionHref":"/sicpjs/5.3.1#fig-5.14","captionName":"Figure 5.14 ","captionBody":[{"body":"Box-and-pointer and memory-vector representations \n          of the list\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(list(1, 2), 3, 4)"},{"body":".","tag":"#text"}]}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    A pointer to a number, such as ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n4"},{"body":",\n    might consist of a type indicating numeric data together with the\n    actual representation of the number 4.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/5.3.1#footnote-5"},{"body":"\n    To deal with numbers that are too large to be represented in the fixed\n    amount of space allocated for a single pointer, we could use a distinct \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"bignum","tag":"#text"}]},{"body":" data type, for which the pointer designates a list in which\n    the parts of the number are stored.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-6","body":"6","href":"/sicpjs/5.3.1#footnote-6"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n\tA string\n\t\n\tmight be represented as a typed pointer that designates a\n\tsequence of the characters that form the string's printed\n\trepresentation. The parser constructs such a sequence\n\twhen it encounters a string literal, and the\n\tstring-concatenation operator ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"+"},{"body":" and\n\tstring-producing\n\tprimitive functions such as\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"stringify"},{"body":" \n\tconstruct such a sequence.\n\tSince we want two instances of a string to\n\tbe recognized as the \"","tag":"#text"},{"body":"same","tag":"#text"},{"body":"\" string by\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"==="},{"body":" and we want\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"==="},{"body":"\n\tto\n\tbe a simple test for equality of pointers, we must ensure that if the\n\tsystem sees the same string twice, it will use the same pointer (to\n\tthe same sequence of characters) to represent both occurrences. To\n\taccomplish this, the system maintains a table, called the\n\t","tag":"#text"},{"tag":"EM","child":[{"body":"string pool","tag":"#text"}]},{"body":", \n\tof all the strings it has ever encountered. When the system\n\tis about to construct a string, it checks the string pool to see if it has ever\n\tbefore seen the same string. If it has not, it\n\tconstructs a new string (a typed pointer to a new\n\tcharacter sequence) and enters this pointer in the string pool. If the\n\tsystem has seen the string before, it returns the string pointer\n\tstored in the string pool. This process of replacing strings by unique\n\tpointers is called\n\t","tag":"#text"},{"tag":"EM","child":[{"body":"string interning","tag":"#text"}]},{"body":".\n      ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Implementing the primitive list operations","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Given the above representation scheme, we can replace each\n    \"","tag":"#text"},{"body":"primitive","tag":"#text"},{"body":"\" list operation of a register machine with one or\n    more primitive vector operations.  We will use two registers,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_heads"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_tails"},{"body":",\n    to identify the memory vectors, and will\n    assume that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"vector_ref"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"vector_set"},{"body":"\n    are available as primitive operations.  We also assume that numeric\n    operations on pointers (such as incrementing a pointer, using a pair pointer\n    to index a vector, or adding two numbers) use only the index portion of\n    the typed pointer.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    For example, we can make a register machine support the instructions\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nassign($reg$$_1$, list(op(\"head\"), reg($reg$$_2$)))\n\nassign($reg$$_1$, list(op(\"tail\"), reg($reg$$_2$)))\n      "},{"body":"\n    if we implement these, respectively, as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nassign($reg$$_1$, list(op(\"vector_ref\"), reg(\"the_heads\"), reg($reg$$_2$)))\n\nassign($reg$$_1$, list(op(\"vector_ref\"), reg(\"the_tails\"), reg($reg$$_2$)))\n      "},{"body":"\n\n    The instructions\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nperform(list(op(\"set_head\"), reg($reg$$_1$), reg($reg$$_2$)))\n\nperform(list(op(\"set_tail\"), reg($reg$$_1$), reg($reg$$_2$)))\n      "},{"body":"\n    are implemented as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nperform(list(op(\"vector_set\"), reg(\"the_heads\"), reg($reg$$_1$), reg($reg$$_2$)))\n\nperform(list(op(\"vector_set\"), reg(\"the_tails\"), reg($reg$$_1$), reg($reg$$_2$)))\n      "}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n\tThe operation\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    is performed by allocating an unused index and storing the arguments to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_heads"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_tails"},{"body":"\n    at that indexed vector position.  We presume that there is a special\n    register,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":", that always holds a pair pointer\n    containing the next available index, and that we can increment the index\n    part of that pointer to find the next free location.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-7","body":"7","href":"/sicpjs/5.3.1#footnote-7"},{"body":"\n    For example, the instruction\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nassign($reg$$_1$, list(op(\"pair\"), reg($reg$$_2$), reg($reg$$_3$)))\n      "},{"body":"\n    is implemented as the following sequence of vector\n    operations:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-8","body":"8","href":"/sicpjs/5.3.1#footnote-8"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nperform(list(op(\"vector_set\"),\n             reg(\"the_heads\"), reg(\"free\"), reg($reg$$_2$))),\nperform(list(op(\"vector_set\"),\n             reg(\"the_tails\"), reg(\"free\"), reg($reg$$_3$))),\nassign($reg$$_1$, reg(\"free\")),\nassign(\"free\", list(op(\"+\"), reg(\"free\"), constant(1)))\n      "}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"==="},{"body":"\n    operation\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nlist(op(\"===\"), reg($reg$$_1$), reg($reg$$_2$))\n      "},{"body":"\n    simply tests the equality of all fields in the registers, and\n    predicates such as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_pair"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_null"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_string"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_number"},{"body":"\n    need only check the type field.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"Implementing stacks","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    Although our register machines use stacks, we need do nothing special\n    here, since stacks can be modeled in terms of lists.  The stack can be\n    \n    a list of the saved values, pointed to by a special register\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"the_stack"},{"body":".\n    Thus,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"save("},{"tag":"META","body":"reg"},{"tag":"JAVASCRIPTINLINE","body":")"},{"body":"\n    can be implemented as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nassign(\"the_stack\", list(op(\"pair\"), reg($reg$), reg(\"the_stack\")))\n      "},{"body":"\n    Similarly,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"restore("},{"tag":"META","body":"reg"},{"tag":"JAVASCRIPTINLINE","body":")"},{"body":"\n    can be implemented as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nassign($reg$, list(op(\"head\"), reg(\"the_stack\")))\nassign(\"the_stack\", list(op(\"tail\"), reg(\"the_stack\")))\n      "},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"perform(list(op(\"initialize_stack\")))"},{"body":"\n    can be implemented as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nassign(\"the_stack\", constant(null))\n      "},{"body":"\n\n    These operations can be further expanded in terms of the vector\n    operations given above.  In conventional computer architectures,\n    however, it is usually advantageous to allocate the stack as a\n    separate vector.  Then pushing and popping the stack can be\n    accomplished by incrementing or decrementing an index into that\n    vector.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.19","id":"#ex-5.19","child":[{"body":"\n    Draw the box-and-pointer representation and the memory-vector representation\n    \n\t(as in figure ","tag":"#text"},{"tag":"REF","body":"5.14","href":"/sicpjs/5.3.1#fig-5.14"},{"body":")\n      \n    of the list structure produced by\n\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"const x = pair(1, 2);\nconst y = list(x, x);"},{"body":"\n    with the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":" pointer initially\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"p1"},{"body":".  What is the final value of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":"$\\,$","tag":"LATEX"},{"body":"?  What\n    pointers represent the values of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":"?\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.20","id":"#ex-5.20","child":[{"body":"\n    Implement register machines for the following\n    functions.\n    Assume that the list-structure memory operations are available as\n    machine primitives.\n    ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\tRecursive\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"count_leaves"},{"body":":\n\t  ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQGY0EYBQuAzAVwDsBjAFwEsB7E0Mm0igfQBsBTAQwDcOBnABQUAThw4BKUAG9coeaDEUiI+lX4sSRNm2FjJchUYUB+UAAZDxowC5QAQlDqWABy5URe8RKvX5ZvD9bBiYSVk5eAUEAC24AEy9JKQBqXyCQ5nZuPiEKd11RbwkAblwAX3xGTIicwTcPQTZ1CkFsABpQACYJDqb+FowOgBYJUeKgA","body":"function count_leaves(tree) {\n    return is_null(tree)\n           ? 0\n           : ! is_pair(tree)\n           ? 1\n           : count_leaves(head(tree)) +\n             count_leaves(tail(tree));\n} "}]},{"tag":"LI","child":[{"body":"\n\tRecursive\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"count_leaves"},{"body":"\n\twith explicit counter:\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQGY0EYBQuAzAVwDsBjAFwEsB7E0Mm0igfQBsBTAQwDcOBnABQUAThw4BKUAG9coeaGLlqdBkxKsqFDiOFiOAGlAkpshedBiKREfSr8WJImzZ7xEuRa8KA-Mc-eXgBcoACEoPYsAA5cVLqi7qABgeZ+9ADUoHgpwWrMLFo6wrGuCZIGyTlVCoz5hboAFtwAJm7lxhISANzJAL7JVjb0tRoF2vH6RgAM3bj9uCOsnLwCgjFxgmz2FILYRgBMEkZb-DsYRgAsnd1AA","body":"function count_leaves(tree) {\n    function count_iter(tree, n) {\n        return is_null(tree)\n               ? n\n               : ! is_pair(tree) \n               ? n + 1\n               : count_iter(tail(tree),\n                            count_iter(head(tree), n));\n    }\n    return count_iter(tree, 0);\n} "}]}]}]},{"tag":"EXERCISE","title":"Exercise 5.21","id":"#ex-5.21","child":[{"body":"\n    Exercise ","tag":"#text"},{"tag":"REF","body":"3.12","href":"/sicpjs/3.3.1#ex-3.12"},{"body":" of\n    section ","tag":"#text"},{"tag":"REF","body":"3.3.1","href":"/sicpjs/3.3.1"},{"body":"\n    presented an\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":"function\n    that appends two lists to form a new list and an\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append_mutator"},{"body":"      \n\tfunction\n      \n    that splices two lists together.  Design a register machine to\n    \n    implement\n    each of these\n    functions.\n    Assume that the list-structure memory operations are\n    available as primitive operations.\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.3.1#footnote-link-1","child":[{"body":"We could represent\n    memory as lists of items. However, the access time would then not be\n    independent of the index, since accessing the\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"th element of a list requires\n    ","tag":"#text"},{"body":"$n-1$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    operations.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.3.1#footnote-link-2","child":[{"body":"\n    As mentioned in section ","tag":"#text"},{"tag":"REF","body":"4.1.4","href":"/sicpjs/4.1.4"},{"body":"\n      (footnote 2),\n    \n    JavaScript supports vectors as data\n    structures and calls them \"","tag":"#text"},{"body":"arrays.","tag":"#text"},{"body":"\" We use the term ","tag":"#text"},{"tag":"EM","child":[{"body":"vector","tag":"#text"}]},{"body":" in\n    this book, as it is the more common terminology.\n    The vector functions above are easily implemented using\n    JavaScript's primitive array support.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/5.3.1#footnote-link-3","child":[{"body":"For completeness, we should specify a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_vector"},{"body":"\n    operation that constructs vectors.  However, in the present application we\n    will use vectors only to model fixed divisions of the computer\n    memory.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/5.3.1#footnote-link-4","child":[{"body":"This is\n    precisely the same \n    \"","tag":"#text"},{"body":"tagged data","tag":"#text"},{"body":"\" idea we introduced in chapter ","tag":"#text"},{"tag":"REF","body":"2","href":"/sicpjs/2"},{"body":" for\n    dealing with generic operations.  Here, however, the data types are\n    included at the primitive machine level rather than constructed\n    through the use of lists.\n    ","tag":"#text"},{"tag":"TEXT","id":"#p11","child":[{"body":"\n      Type information may be encoded in\n      a variety of ways, depending on the details of the machine on which the\n      JavaScript\n      system is to be implemented.  The execution efficiency of\n      JavaScript\n      programs will be strongly dependent on how cleverly this choice is made, but\n      it is difficult to formulate general design rules for good choices.  The\n      most straightforward way to implement typed pointers is to allocate a fixed\n      set of bits in each pointer to be a\n      ","tag":"#text"},{"tag":"EM","child":[{"body":"type field","tag":"#text"}]},{"body":" that encodes the data type.  Important questions to be\n      addressed in designing such a representation include the following:\n      How many type bits are required?  How large must the vector indices\n      be?  How efficiently can the primitive machine instructions be used to\n      manipulate the type fields of pointers?  Machines that include special\n      hardware for the efficient handling of type fields are said to have\n      ","tag":"#text"},{"tag":"EM","child":[{"body":"tagged architectures","tag":"#text"}]},{"body":".\n    ","tag":"#text"}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/5.3.1#footnote-link-5","child":[{"body":"This decision on the\n    representation of numbers determines whether\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"==="},{"body":",\n    which tests equality of pointers, can be used to test for equality of\n    numbers.  If the pointer contains the number itself, then equal numbers will\n    have the same pointer.  But if the pointer contains the index of a location\n    where the number is stored, equal numbers will be guaranteed to have\n    equal pointers only if we are careful never to store the same number\n    in more than one location.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-6","count":6,"href":"/sicpjs/5.3.1#footnote-link-6","child":[{"body":"This is just like writing a\n    number as a sequence of digits, except that each \"","tag":"#text"},{"body":"digit","tag":"#text"},{"body":"\" is a\n    number between 0 and the largest number that can be stored in a single\n    pointer.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-7","count":7,"href":"/sicpjs/5.3.1#footnote-link-7","child":[{"body":"There are\n    other ways of finding free storage.  For example, we could link together\n    all the unused pairs into a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"free list","tag":"#text"}]},{"body":".  Our free locations are consecutive (and hence can be\n    accessed by incrementing a pointer) because we are using a compacting\n    garbage collector, as we will see in\n    section ","tag":"#text"},{"tag":"REF","body":"5.3.2","href":"/sicpjs/5.3.2"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-8","count":8,"href":"/sicpjs/5.3.1#footnote-link-8","child":[{"body":"This is essentially the implementation of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    in terms of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set_head"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set_tail"},{"body":",\n    as described in section ","tag":"#text"},{"tag":"REF","body":"3.3.1","href":"/sicpjs/3.3.1"},{"body":".\n    The operation\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"get_new_pair"},{"body":"\n    used in that implementation is realized here by the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"free"},{"body":" pointer.","tag":"#text"}]}]