[{"id":"/sicpjs/1.3","tag":"TITLE","body":"1.3  \n        Formulating Abstractions with Higher-Order \n        \n\t  \n\t  Functions"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n        We have seen that\n        functions\n        are, in effect, abstractions that describe compound operations on\n\tnumbers independent of the particular numbers. For example, when we\n\tdeclare","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=1&prgrm=PTAEGUEkGEAVQFLlARgHQGYBQWBmBXAOwGMAXASwHtDRj8AjAUwAoAPASlAG8tQ-QATo1L4BNVqABUoCdNYBuLAF8cdJswzt5QA","body":"function cube(x) {\n    return x * x * x;\n} "},{"body":"\n        we are not talking about the cube of a particular number, but rather\n        about a method for obtaining the cube of any number.  Of course we could\n\tget along without ever \n        declaring this function,\n\tby always writing expressions such as\n        ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"3 * 3 * 3\nx * x * x\ny * y * y"},{"body":"\n        and never mentioning ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"cube"},{"body":" explicitly. This\n\twould place us at a serious disadvantage, forcing us to work always at\n\tthe level of the particular operations that happen to be primitives in\n\tthe language (multiplication, in this case) rather than in terms of\n\thigher-level operations.  Our programs would be able to compute cubes,\n\tbut our language would lack the ability to express the concept of cubing.\n\tOne of the things we should demand from a powerful programming language\n\tis the ability to build abstractions by assigning names to common\n        patterns and then to work in terms of the abstractions directly.\n        Functions\n        provide this ability.  This is why all but the most primitive\n\tprogramming languages include mechanisms for \n        declaring functions.","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n        Yet even in numerical processing we will be severely limited in our\n        ability to create abstractions if we are restricted to\n        functions\n        whose parameters must be numbers.  Often the same programming pattern\n        will be used with a number of different\n        functions.\n\tTo express such patterns as concepts, we will need to construct\n        functions\n        that can accept\n        functions\n        as arguments or return\n        functions\n        as values.\n        Functions\n        that manipulate\n        functions\n        are called \n        ","tag":"#text"},{"tag":"EM","child":[{"body":"higher-order functions.","tag":"#text"}]},{"body":"\n\tThis section shows how higher-order\n        functions\n        can serve as powerful abstraction mechanisms, vastly increasing the\n\texpressive power of our language.\n      ","tag":"#text"}]}]