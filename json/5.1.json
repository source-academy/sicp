[{"id":"/sicpjs/5.1","tag":"TITLE","body":"5.1  Designing Register Machines"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    To design a register machine, we must design its ","tag":"#text"},{"tag":"EM","child":[{"body":"data paths","tag":"#text"}]},{"body":"\n    (registers and operations) and the ","tag":"#text"},{"tag":"EM","child":[{"body":"controller","tag":"#text"}]},{"body":" that sequences\n    these operations.  To illustrate the design of a simple register\n    machine, let us examine Euclid's Algorithm, which is used to compute\n    \n    the greatest common divisor (GCD) of two integers.  As we saw in\n    section ","tag":"#text"},{"tag":"REF","body":"1.2.5","href":"/sicpjs/1.2.5"},{"body":",\n    \n    Euclid's Algorithm can be\n    carried out by an iterative process, as specified by the following\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQEYBQWBmBXAOwGMAXASwHtDQBzYgEwAoBDAGlACMBKUAbyyghoAE4BTUvhE1OoALwLQABlAB+UC1AAuOoyacOmgKRduAbiwBfHPWYAmJRwx3zQA","body":"function gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n} "}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    A machine to carry out this algorithm must keep track of two numbers,\n    ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":", so let us\n    assume that these numbers are stored in two registers with those names. The\n    basic operations required are testing whether the contents of register\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" is zero and computing the remainder of the\n    contents of register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" divided by the contents\n    of register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":".\n\n    The remainder operation is a complex process, but assume for the moment that\n    we have a primitive device that computes remainders. On each cycle of the\n    GCD algorithm, the contents of register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" must\n    be replaced by the contents of register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":", and\n    the contents of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" must be replaced by the\n    remainder of the old contents of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" divided by\n    the old contents of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":". It would be convenient\n    if these replacements could be done simultaneously, but in our model of\n    register machines we will assume that only one register can be assigned a\n    new value at each step. To accomplish the replacements, our machine will use\n    a third \"","tag":"#text"},{"body":"temporary","tag":"#text"},{"body":"\" register, which we call\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"t"},{"body":". (First the remainder will be placed in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"t"},{"body":", then the contents of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" will be placed in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":", and finally the remainder stored in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"t"},{"body":" will be placed in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":".)\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    We can illustrate the registers and operations required for this\n    machine by using the\n    \n    data-path diagram shown in\n    figure ","tag":"#text"},{"tag":"REF","body":"5.1","href":"/sicpjs/5.1#fig-5.1"},{"body":".  In this\n    diagram, the registers (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":", and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"t"},{"body":") are\n    represented by rectangles.  Each way to assign a value to a register is\n    indicated by an arrow with a button—drawn as ","tag":"#text"},{"body":"$\\otimes$","tag":"LATEX"},{"body":"— behind the \n    head, pointing from the source of data to the register.  \n    When pushed, the button allows\n    the value at the source to \"","tag":"#text"},{"body":"flow","tag":"#text"},{"body":"\" into the designated register.\n    The label next to each button is the name we will use to refer to the\n    button.  The names are arbitrary, and can be chosen to have mnemonic value\n    (for example, ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a<-b"},{"body":" denotes pushing the\n    button that assigns the contents of register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":"\n    to register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":").  The source of data for a\n    register can be another register (as in the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a<-b"},{"body":" assignment), an operation result (as in\n    the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"t<-r"},{"body":" assignment), or a constant\n    (a built-in value that cannot be changed, represented in a data-path\n    diagram by a triangle containing the constant).\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    An operation that computes a value from constants and the contents\n    of registers is represented in a data-path diagram by a trapezoid\n    containing a name for the operation.  For example, the box marked\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"rem"},{"body":" in\n    figure ","tag":"#text"},{"tag":"REF","body":"5.1","href":"/sicpjs/5.1#fig-5.1"},{"body":" represents an operation that\n    computes the remainder of the contents of the registers\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" to which\n    it is attached.  Arrows (without buttons) point from the input registers and\n    constants to the box, and arrows connect the operation's output value\n    to registers. A test is represented by a circle containing a name for the\n    test.  For  example, our GCD machine has an operation that tests whether the\n    contents of register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":" is zero.  A\n    \n    test also has arrows from its input\n    registers and constants, but it has no output\n    arrows; its value is used by the controller rather than by the data\n    paths.  Overall, the data-path diagram shows the registers and\n    operations that are required for the machine and how they must be\n    connected.  If we view the arrows as wires and the\n    ","tag":"#text"},{"body":"$\\otimes$","tag":"LATEX"},{"body":" buttons as switches, the data-path diagram\n    is very like the wiring diagram for a machine that could be constructed\n    from electrical components.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"60%","src":"img_original/Fig5.1a.std.svg","id":"#fig-5.1","captionHref":"/sicpjs/5.1#fig-5.1","captionName":"Figure 5.1 ","captionBody":[{"body":"Data paths for a GCD machine. ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    In order for the data paths to actually compute GCDs, the buttons must\n    be pushed in the correct sequence.  We will describe this sequence in\n    terms of a\n    \n    controller diagram, as illustrated in\n    figure ","tag":"#text"},{"tag":"REF","body":"5.2","href":"/sicpjs/5.1#fig-5.2"},{"body":".  The elements of the\n    controller diagram indicate how the data-path components should be operated.\n    The rectangular boxes in the controller diagram identify data-path buttons\n    to be pushed, and the arrows describe the sequencing from one step to the\n    next.  The diamond in the diagram represents a decision.  One of the two\n    sequencing arrows will be followed, depending on the value of the data-path\n    test identified in the diamond.  We can interpret the controller in terms\n    of a physical analogy: Think of the diagram as a maze in which a marble is\n    rolling.  When the marble rolls into a box, it pushes the data-path button\n    that is named by the box.  When the marble rolls into a decision node (such\n    as the test for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":"$\\, =0$","tag":"LATEX"},{"body":"), it leaves\n    the node on the path determined by the result of the indicated test.\n    Taken together, the data paths and the controller completely describe\n    a machine for computing GCDs.  We start the controller (the rolling\n    marble) at the place marked ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"start"},{"body":", after\n    placing numbers in registers ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"b"},{"body":".  When the controller reaches\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"done"},{"body":", we will find the value of the GCD in\n    register ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":".\n    ","tag":"#text"},{"tag":"FIGURE","scale":"40%","src":"img_original/Fig5.2.std.svg","id":"#fig-5.2","captionHref":"/sicpjs/5.1#fig-5.2","captionName":"Figure 5.2 ","captionBody":[{"body":"Controller for a GCD machine.","tag":"#text"}]}]},{"tag":"EXERCISE","title":"Exercise 5.1","id":"#ex-5.1","child":[{"body":"\n    Design a register machine to compute\n    \n    factorials using the iterative\n    algorithm specified by the following\n    function.\n    Draw data-path and\n    controller diagrams for this machine.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":0,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQEYBQWBmBXAOwGMAXASwHtDRcBDMygJ3LoBsAKQgSlAG8soIbSJkqNcqQCmTDgAcmlACb4yAGlDFKRaU14Dhh0Eyml8TGlp0zQAPlA1BR58ID8oBctWknL5wC5QSRkOK0JdUAAqD0UVdV8-RKEwiIBqUAxuAG5fAF9fEzMLIN0ODA1MnPy8BlJmVk4UbKA","body":"function factorial(n) {\n    function iter(product, counter) {\n        return counter > n \n               ? product\n               : iter(counter * product,\n                      counter + 1);\n   }\n   return iter(1, 1);\n} "}],"solution":[{"body":"\n      (Solution by GitHub user escolmebartlebooth)\n      In ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial(n)"},{"body":", the function\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"iter(product, counter)"},{"body":" is seeded by the\n      arguments ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"(1, 1)"},{"body":" and runs until\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"counter > n"},{"body":", at which point the product is\n      returned. Unlike , the register\n      machine has no need of a temporary register assuming that the correct order of\n      register assignment is followed.\n\n      For the data path, we see three registers:\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"product"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"counter"},{"body":", and\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":". There are two operations:\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"multiply"},{"body":" and\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"plus"},{"body":" with two assignments.\n      There is one test: ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"greater than"},{"body":".\n\n      ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ex5-1-solution-1.png","id":"#fig-"},{"body":"\n\n      For the controller, we start by filling the three registers with the desired\n      factorial ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"n"},{"body":" and the value\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"1"},{"body":" (seeding\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"product"},{"body":" and\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"counter"},{"body":"). The function\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"iter"},{"body":" runs and tests whether\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"counter > n"},{"body":". If\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"counter <= n"},{"body":", then\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"product"},{"body":" is updated to\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"product * counter"},{"body":", followed by counter being\n      updated to\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"counter + 1"},{"body":" and the process is repeated until\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"counter > n"},{"body":". Once counter is > n, the product\n      is\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial(n)"},{"body":" and can be returned.\n\n      ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ex5-1-solution-2.png","id":"#fig-"}]}]