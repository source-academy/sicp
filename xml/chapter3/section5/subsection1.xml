<SUBSECTION>
  <NAME>
    Streams Are Delayed Lists
  </NAME>

  <LABEL NAME="sec:delayed-lists"/>
  <INDEX>stream(s)<SUBINDEX>implemented as delayed lists|(</SUBINDEX></INDEX>
  <TEXT>
    As we saw in section<SPACE/><REF NAME="sec:sequences-conventional-interfaces"/>,
    sequences can serve as standard interfaces for combining program
    modules.  We formulated powerful abstractions for manipulating
    sequences, such as <SCHEMEINLINE>map</SCHEMEINLINE>, <SCHEMEINLINE>filter</SCHEMEINLINE>, and <SCHEMEINLINE>accumulate</SCHEMEINLINE>, that
    capture a wide variety of operations in a manner that is both succinct
    and elegant.
  </TEXT>

  <TEXT>
    Unfortunately, if we represent sequences as lists, this elegance is
    bought at the price of severe inefficiency with respect to both the
    time and space required by our computations.
    When we represent manipulations on sequences as transformations
    of lists, our programs must construct and copy data structures (which
    may be huge) at every step of a process.
  </TEXT>

  <TEXT>
    To see why this is true, let us compare two programs for computing the
    sum of all the prime numbers in an interval.  The first program is
    written in standard iterative style:<FOOTNOTE>Assume that we have a
    predicate
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>prime?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>is_prime</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    (e.g., as in section<SPACE/><REF NAME="sec:primality"/>) that
    tests for primality.</FOOTNOTE>
    <!--  \indcode*{sum-primes} -->
    <SNIPPET EVAL="yes">
      <REQUIRES>prime_definition</REQUIRES>
      <NAME>sum_primes1</NAME>
      <EXAMPLE>sum_primes1_example</EXAMPLE>
      <SCHEME>
        <!--  \indcode*{sum-primes} -->
        (define (sum-primes a b)
        (define (iter count accum)
        (cond ((&gt; count b) accum)
        ((prime? count) (iter (+ count 1) (+ count accum)))
        (else (iter (+ count 1) accum))))
        (iter a 0))
      </SCHEME>
      <JAVASCRIPT>
function sum_primes(a, b) {
    function iter(count, accum) {
        if (count &gt; b) {
            return accum;
        } else {
            if (is_prime(count)) {
                return iter(count + 1, count + accum);
            } else {
                return iter(count + 1, accum);
            }
        }
    }
    return iter(a, 0);
}
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET EVAL="yes" HIDE="yes">
      <NAME>sum_primes1_example</NAME>
      <JAVASCRIPT>
sum_primes(7, 182);    
      </JAVASCRIPT>
    </SNIPPET>

</TEXT>

  <TEXT>
    The second program performs the same computation using the sequence
    operations of section<SPACE/><REF NAME="sec:sequences-conventional-interfaces"/>:

    <SNIPPET EVAL="yes">
      <REQUIRES>prime_definition</REQUIRES>
      <REQUIRES>enumerate_interval</REQUIRES>
      <NAME>sum_primes2</NAME>
      <EXAMPLE>sum_primes1_example</EXAMPLE>
      <SCHEME>
        <!--  \indcode*{sum-primes} -->
        (define (sum-primes a b)
        (accumulate +
        0
        (filter prime? (enumerate-interval a b))))
      </SCHEME>
      <JAVASCRIPT>
function sum_primes(a, b) {
    return accumulate((x, y) => x + y,
                      0,
                      filter(is_prime, 
                             enumerate_interval(a, b)));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    In carrying out the computation, the first program needs to store only
    the sum being accumulated.  In contrast, the filter in the second
    program cannot do any testing until 
    <SPLITINLINE><SCHEME><SCHEMEINLINE>enumerate-interval</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>enumerate_interval</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
    has
    constructed a complete list of the numbers in the interval.  The
    filter generates another list, which in turn is passed to 
    <SCHEMEINLINE>accumulate</SCHEMEINLINE> before being collapsed to form a sum.  Such large
    intermediate storage is not needed by the first program, which we can
    think of as enumerating the interval incrementally, adding each prime
    to the sum as it is generated.
  </TEXT>

  <TEXT>
    The inefficiency in using lists becomes painfully apparent if we use
    the sequence paradigm to compute the second prime in the interval from
    10,000 to 1,000,000 by evaluating the expression

    <SNIPPET EVAL="yes">
      <REQUIRES>prime_definition</REQUIRES>
      <REQUIRES>enumerate_interval</REQUIRES>
      <SCHEME>
        (car (cdr (filter prime?
        (enumerate-interval 10000 1000000))))
      </SCHEME>
      <JAVASCRIPT>
head(tail(filter(is_prime,
                 enumerate_interval(10000, 1000000))));
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>This expression does find the second prime,
      </SCHEME>
      <JAVASCRIPT>This expression does find the second prime when
      given enough time and space,</JAVASCRIPT>
    </SPLITINLINE>
    but the computational overhead is outrageous.
    We construct a list of almost a million
    integers, filter this list by testing each element for primality, and
    then ignore almost all of the result.  In a more traditional
    programming style, we would interleave the enumeration and the
    filtering, and stop when we reached the second prime.
  </TEXT>

  <TEXT>
    Streams are a clever idea that allows one to use sequence
    manipulations without incurring the costs of manipulating sequences as
    lists.  With streams we can achieve the best of both worlds: We can
    formulate programs elegantly as sequence manipulations, while attaining the
    efficiency of incremental computation.  The basic idea is to arrange
    to construct a stream only partially, and to pass the partial
    construction to the program that consumes the stream.  If the consumer
    attempts to access a part of the stream that has not yet been
    constructed, the stream will automatically construct just enough more
    of itself to produce the required part, thus preserving the illusion
    that the entire stream exists.  In other words, although we will write
    programs as if we were processing complete sequences, we design our
    stream implementation to automatically and transparently interleave
    the construction of the stream with its use.
  </TEXT>

  <SPLIT>

    <SCHEME>

      <TEXT>
        On the surface, streams are just lists with different names for the
	procedures that manipulate them.  There is a constructor,
        <!-- \indsf{cons-stream}-->
        <SCHEMEINLINE>cons-stream</SCHEMEINLINE>, and two selectors, 
        <!--  \indcode{stream-car} -->
        <SCHEMEINLINE>stream-car</SCHEMEINLINE> and 
        <!--  \indcode{stream-cdr} -->
        <SCHEMEINLINE>stream-cdr</SCHEMEINLINE>, which satisfy the constraints
        \begin{eqnarray*}
        \mbox{(stream-car (cons-stream x y))} &amp;=&amp; \mbox{x} \\
        \mbox{(stream-cdr (cons-stream x y))} &amp;=&amp; \mbox{y}
        \end{eqnarray*}
        There is a distinguishable object, 
        <INDEX>empty stream</INDEX><INDEX>stream(s)<SUBINDEX>empty</SUBINDEX></INDEX>
        <!--  \indcode{the-empty-stream} -->
        <SCHEMEINLINE>the-empty-stream</SCHEMEINLINE>, which
        cannot be the result of any <SCHEMEINLINE>cons-stream</SCHEMEINLINE> operation,
	and which can be identified with the predicate 
        <!--  \indcode{stream-null?} -->
        <SCHEMEINLINE>stream-null?</SCHEMEINLINE>.<FOOTNOTE>In the MIT implementation, 
        <!--  \indcode{the-empty-stream}[in MIT Scheme] -->
        <!--  \indcode{stream-null?}[in MIT Scheme] -->
        <INDEX>MIT Scheme<SUBINDEX>empty@the empty stream</SUBINDEX></INDEX>
        <SCHEMEINLINE>the-empty-stream</SCHEMEINLINE> is the
        same as the empty list <SCHEMEINLINE>'()</SCHEMEINLINE>, and
	<SCHEMEINLINE>stream-null?</SCHEMEINLINE> is the same
        as <SCHEMEINLINE>null?</SCHEMEINLINE>.</FOOTNOTE>
      </TEXT>

      <TEXT>
        Thus we can make and use streams, in just the same way as we can make
        and use lists, to represent aggregate data arranged in a sequence.  In
        particular, we can build stream analogs of the list operations from
        chapter<SPACE/>2, such as <SCHEMEINLINE>list-ref</SCHEMEINLINE>,
	<SCHEMEINLINE>map</SCHEMEINLINE>, and
	<SCHEMEINLINE>for-each</SCHEMEINLINE>:<FOOTNOTE>This should bother you.
	The fact that we are defining such similar procedures
        for streams and lists indicates that we are missing some
        underlying abstraction.  Unfortunately, in order to exploit this
        abstraction, we will need to exert finer control over the process of
        evaluation than we can at present.  We will discuss this point further
        at the end of section<SPACE/><REF NAME="sec:streams-and-delayed-evaluation"/>.
        In section<SPACE/><REF NAME="sec:lazy-evaluation"/>, we<APOS/>ll develop
	a framework that unifies lists and streams.</FOOTNOTE>
        <SNIPPET EVAL="no" EXTERNAL_LIBRARY="STREAMS"> 

          <SCHEME>
            <!--  \indcode*{stream-ref} -->
            (define (stream-ref s n)
            (if (= n 0)
            (stream-car s)
            (stream-ref (stream-cdr s) (- n 1))))

            <!--  \indcode*{stream-map} -->
            (define (stream-map proc s)
            (if (stream-null? s)
            the-empty-stream
            (cons-stream (proc (stream-car s))
            (stream-map proc (stream-cdr s)))))

            <!--  \indcode*{stream-for-each} -->
            (define (stream-for-each proc s)
            (if (stream-null? s)
            'done
            (begin (proc (stream-car s))
            (stream-for-each proc (stream-cdr s)))))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Stream-for-each</SCHEMEINLINE> is useful for viewing streams:
        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            <!--  \indcode*{display-stream} -->
            (define (display-stream s)
            (stream-for-each display-line s))

            <!--  \indcode*{display-line} -->
            (define (display-line x)
            (newline)
            (display x))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        To make the stream implementation automatically and transparently
        interleave the construction of a stream with its use, we will arrange
        for the <SCHEMEINLINE>cdr</SCHEMEINLINE> of a stream to be evaluated when it is accessed by
        the <SCHEMEINLINE>stream-cdr</SCHEMEINLINE> procedure
        rather than when the stream is
        constructed by <SCHEMEINLINE>cons-stream</SCHEMEINLINE>.  This implementation choice is
        reminiscent of our discussion of rational numbers in
        section<SPACE/><REF NAME="sec:abstraction-barriers"/>, where we saw that we can
        choose to implement rational numbers so that the reduction of
        numerator and denominator to lowest terms is performed either at
        construction time or at selection time.  The two rational-number
        implementations produce the same data abstraction, but the choice has
        an effect on efficiency.  There is a similar relationship between
        streams and ordinary lists.  As a data abstraction, streams are the
        same as lists.  The difference is the time at which the elements are
        evaluated.  With ordinary lists, both the
	<SCHEMEINLINE>car</SCHEMEINLINE> and the <SCHEMEINLINE>cdr</SCHEMEINLINE>
        are evaluated at construction time.  With streams, the <SCHEMEINLINE>cdr</SCHEMEINLINE>
	is evaluated at selection time.
      </TEXT>

      <TEXT>
        <!-- \indsf*{delay} -->
        <!-- \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[delay@<SCHEMEINLINE>delay</SCHEMEINLINE> (<EM>ns</EM>)]-->
        Our implementation of streams will be based on a special form called
        <SCHEMEINLINE>delay</SCHEMEINLINE>.  Evaluating <SCHEMEINLINE>(delay ^exp^)</SCHEMEINLINE>
	does not evaluate the expression <LATEXINLINE>exp</LATEXINLINE>, but rather returns a
	so-called
        <INDEX>delayed object</INDEX>
        <EM>delayed object</EM>, which we can think of as a <QUOTE>promise</QUOTE> to evaluate
        <LATEXINLINE>exp</LATEXINLINE> at some future time.
	As a companion to <SCHEMEINLINE>delay</SCHEMEINLINE>, there is a procedure
        called 
        <!--  \indcode{force} -->
        <SCHEMEINLINE>force</SCHEMEINLINE> that takes a delayed object as
        argument and performs the evaluation<EMDASH/>in effect, forcing the
        <SCHEMEINLINE>delay</SCHEMEINLINE> to fulfill its promise.  We will see below how
	<SCHEMEINLINE>delay</SCHEMEINLINE>
        and <SCHEMEINLINE>force</SCHEMEINLINE> can be implemented, but first let us use these to
        construct streams.
      </TEXT>

      <TEXT>
        <!-- \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme
             standard)}[cons-stream@<SCHEMEINLINE>cons-stream</SCHEMEINLINE> (<EM>ns</EM>)]
             \indsf*{cons-stream}
        -->
        <SCHEMEINLINE>Cons-stream</SCHEMEINLINE> is a special form defined so that

        <SNIPPET EVAL="no" EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (cons-stream ^a^ ^b^)
          </SCHEME>
        </SNIPPET>

        is equivalent to

        <SNIPPET EVAL="no" EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (cons ^a^ (delay ^b^))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        What this means is that we will construct streams using pairs.  However,
        rather than placing the value of the rest of the stream
        into the <SCHEMEINLINE>cdr</SCHEMEINLINE> of the
        pair we will put there a promise to compute the rest if it is ever
        requested.  <SCHEMEINLINE>Stream-car</SCHEMEINLINE> and
	<SCHEMEINLINE>stream-cdr</SCHEMEINLINE> can now be defined as procedures:

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            <!--  \indcode*{stream-car} -->
            (define (stream-car stream) (car stream))

            <!--  \indcode*{stream-cdr} -->
            (define (stream-cdr stream) (force (cdr stream)))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Stream-car</SCHEMEINLINE> selects the
	<SCHEMEINLINE>car</SCHEMEINLINE> of the pair; <SCHEMEINLINE>stream-cdr</SCHEMEINLINE>
        selects the <SCHEMEINLINE>cdr</SCHEMEINLINE> of the pair and evaluates the delayed
	expression found there to obtain the rest of the
	stream.<FOOTNOTE>Although <SCHEMEINLINE>stream-car</SCHEMEINLINE> and
        <!-- \indsf{cons-stream}[why a special form]-->
        <!-- \indsf{delay}[why a special form]-->
        <SCHEMEINLINE>stream-cdr</SCHEMEINLINE> can be defined as procedures,
	<SCHEMEINLINE>cons-stream</SCHEMEINLINE> must
        be a special form.  If <SCHEMEINLINE>cons-stream</SCHEMEINLINE> were a procedure,
	then,
        according to our model of evaluation, evaluating
	<SCHEMEINLINE>(cons-stream ^a^ ^b^)</SCHEMEINLINE>
	would automatically cause <LATEXINLINE>b</LATEXINLINE> to be evaluated, which is
        precisely what we do not want to happen.  For the same reason,
	<SCHEMEINLINE>delay</SCHEMEINLINE> must be a special form, though
	<SCHEMEINLINE>force</SCHEMEINLINE> can be an ordinary
	procedure.</FOOTNOTE>
        <INDEX>stream(s)<SUBINDEX>implemented as delayed lists|)</SUBINDEX></INDEX>
      </TEXT>

      <SUBHEADING> 
        <NAME>The stream implementation in action</NAME>
      </SUBHEADING>

      <TEXT>
        To see how this implementation behaves, let us analyze the
        <QUOTE>outrageous</QUOTE> prime computation we saw above, reformulated in terms
        of streams:

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (stream-car
            (stream-cdr
            (stream-filter prime?
            (stream-enumerate-interval 10000 1000000))))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        We will see that it does indeed work efficiently.
      </TEXT>

      <TEXT>
        We begin by calling <SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE> with
        the arguments 10,000 and 1,000,000.  <SCHEMEINLINE>Stream-enumerate-interval</SCHEMEINLINE>
        is the stream analog of <SCHEMEINLINE>enumerate-interval</SCHEMEINLINE>
        (section<SPACE/><REF NAME="sec:sequence-operations"/>):

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            <!--  \indcode*{stream-enumerate-interval} -->
            (define (stream-enumerate-interval low high)
            (if (&gt; low high)
            the-empty-stream
            (cons-stream
            low
            (stream-enumerate-interval (+ low 1) high))))
          </SCHEME>
        </SNIPPET>

        and thus the result returned by <SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE>,
        formed by the <SCHEMEINLINE>cons-stream</SCHEMEINLINE>, is<FOOTNOTE>The numbers shown here do
        not really appear in the delayed expression.  What actually appears is
        the original expression, in an environment in which the variables are
        bound to the appropriate numbers.  For example,
	<SCHEMEINLINE>(+ low 1)</SCHEMEINLINE> with
        <SCHEMEINLINE>low</SCHEMEINLINE> bound to 10,000 actually appears where
	<SCHEMEINLINE>10001</SCHEMEINLINE> is
        shown.</FOOTNOTE>

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (cons 10000
            (delay (stream-enumerate-interval 10001 1000000)))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        That is, <SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE>
        returns a stream represented as a pair whose
	<SCHEMEINLINE>car</SCHEMEINLINE>
        is 10,000 and whose
	<SCHEMEINLINE>cdr</SCHEMEINLINE> is a promise to enumerate more of the
        interval if so requested.  This stream is now filtered for primes,
        using the stream analog of the <SCHEMEINLINE>filter</SCHEMEINLINE> procedure
        (section<SPACE/><REF NAME="sec:sequence-operations"/>):

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            <!--  \indcode*{stream-filter} -->
            (define (stream-filter pred stream)
            (cond ((stream-null? stream) the-empty-stream)
            ((pred (stream-car stream))
            (cons-stream (stream-car stream)
            (stream-filter pred
            (stream-cdr stream))))
            (else (stream-filter pred (stream-cdr stream)))))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Stream-filter</SCHEMEINLINE> tests the <SCHEMEINLINE>stream-car</SCHEMEINLINE> of the stream (the <SCHEMEINLINE>car</SCHEMEINLINE> of the pair, which is 10,000).
	Since this is not prime,
        <SCHEMEINLINE>stream-filter</SCHEMEINLINE> examines the
	<SCHEMEINLINE>stream-cdr</SCHEMEINLINE> of its input
        stream.  The call to <SCHEMEINLINE>stream-cdr</SCHEMEINLINE> forces evaluation of the
	delayed <SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE>, which now returns

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (cons 10001
            (delay (stream-enumerate-interval 10002 1000000)))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Stream-filter</SCHEMEINLINE> now looks at the
	<SCHEMEINLINE>stream-car</SCHEMEINLINE> of this stream,
        10,001, sees that this is not prime either, forces another
	<SCHEMEINLINE>stream-cdr</SCHEMEINLINE>, and so on, until
	<SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE> yields
        the prime 10,007, whereupon <SCHEMEINLINE>stream-filter</SCHEMEINLINE>,
	according to its definition, returns

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (cons-stream (stream-car stream)
            (stream-filter pred (stream-cdr stream)))
          </SCHEME>
        </SNIPPET>

        which in this case is

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (cons 10007
            (delay
            (stream-filter
            prime?
            (cons 10008
            (delay
            (stream-enumerate-interval 10009
            1000000))))))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        This result is now passed to <SCHEMEINLINE>stream-cdr</SCHEMEINLINE> in our
        original expression.  This forces the delayed <SCHEMEINLINE>stream-filter</SCHEMEINLINE>,
	which in turn keeps forcing the delayed
	<SCHEMEINLINE>stream-enumerate-interval</SCHEMEINLINE> until it finds the next prime,
	which is 10,009.  Finally, the result passed to <SCHEMEINLINE>stream-car</SCHEMEINLINE>
	in our original expression is

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (cons 10009
            (delay
            (stream-filter
            prime?
            (cons 10010
            (delay
            (stream-enumerate-interval 10011
            1000000))))))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Stream-car</SCHEMEINLINE> returns 10,009, and the computation is complete.
	Only as many integers were tested for primality as were necessary to find the
        second prime, and the interval was enumerated only as far as was
        necessary to feed the prime filter.
      </TEXT>

      <TEXT>
        In general, we can think of delayed evaluation as 
        <INDEX>programming<SUBINDEX>demand-driven</SUBINDEX></INDEX>
        <QUOTE>demand-driven</QUOTE>
        programming, whereby each stage in the stream process is activated
        only enough to satisfy the next stage.  What we have done is to
        <INDEX>order of events<SUBINDEX>decoupling apparent from actual</SUBINDEX></INDEX>
        decouple the actual order of events in the computation from the
        apparent structure of our procedures.
	We write procedures as if the
        streams existed <QUOTE>all at once</QUOTE> when, in reality, the computation is
        performed incrementally, as in traditional programming styles.
      </TEXT>

      <SUBHEADING> 
        <NAME>Implementing <SCHEMEINLINE>delay</SCHEMEINLINE> and
	<SCHEMEINLINE>force</SCHEMEINLINE></NAME>
      </SUBHEADING>

      <TEXT>
        <!-- \indsf{delay}[implementation using <SCHEMEINLINE>lambda</SCHEMEINLINE>]-->
        Although <SCHEMEINLINE>delay</SCHEMEINLINE> and <SCHEMEINLINE>force</SCHEMEINLINE>
	may seem like mysterious
        operations, their implementation is really quite straightforward.
        <SCHEMEINLINE>Delay</SCHEMEINLINE> must package an expression so that it can be evaluated
        later on demand, and we can accomplish this simply by treating the
        expression as the body of a procedure.
	<SCHEMEINLINE>Delay</SCHEMEINLINE> can be a special
        form such that

        <SNIPPET EVAL="no" EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (delay ^exp^)
          </SCHEME>
        </SNIPPET>

        is syntactic sugar for

        <SNIPPET EVAL="no" EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (lambda () ^exp^)
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Force</SCHEMEINLINE> simply calls the procedure
        (of no arguments) produced by <SCHEMEINLINE>delay</SCHEMEINLINE>,
	so we can implement <SCHEMEINLINE>force</SCHEMEINLINE> as
        a procedure:

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            <!--  \indcode*{force} -->
            (define (force delayed-object)
            (delayed-object))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <!-- \indsf{delay}[memoized]-->
        <INDEX>memoization<SUBINDEX>delay@by <SCHEMEINLINE>delay</SCHEMEINLINE></SUBINDEX></INDEX>
        This implementation suffices for <SCHEMEINLINE>delay</SCHEMEINLINE> and
	<SCHEMEINLINE>force</SCHEMEINLINE> to work
        as advertised, but there is an important optimization that we can
        include.  In many applications, we end up forcing the same delayed object
        many times.  This can lead to serious inefficiency in recursive
        programs involving streams.  (See
        exercise<SPACE/><REF NAME="ex:fib-stream-efficiency"/>.)  The solution is to build
        delayed objects so that the first time they are forced, they store the
        value that is computed.  Subsequent forcings will simply return the
        stored value without repeating the computation.  In other words, we
        implement <SCHEMEINLINE>delay</SCHEMEINLINE> as a special-purpose memoized procedure
        similar to the one described in exercise<SPACE/><REF NAME="ex:memoization"/>.
	One way to accomplish this is to use the following procedure,
	which takes as argument a procedure
        (of no arguments) and returns a memoized version of the procedure.
	The first time the memoized procedure
        is run, it saves the computed result.  On subsequent evaluations, it simply
        returns the result.

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            <!--  \indcode*{memo-proc} -->
            (define (memo-proc proc)
            (let ((already-run? false) (result false))
            (lambda ()
            (if (not already-run?)
            (begin (set! result (proc))
            (set! already-run? true)
            result)
            result))))
          </SCHEME>
        </SNIPPET>
      </TEXT>

      <TEXT>
        <SCHEMEINLINE>Delay</SCHEMEINLINE> is then defined so that
	<SCHEMEINLINE>(delay ^exp^)</SCHEMEINLINE> is equivalent to

        <SNIPPET EVAL="no" EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (memo-proc (lambda () ^exp^))
          </SCHEME>
        </SNIPPET>

        and <SCHEMEINLINE>force</SCHEMEINLINE> is as defined previously.<FOOTNOTE>There are many
        possible implementations of streams other than the one described in
        this section.  Delayed evaluation, which is the key to making streams
        practical, was inherent in 
        <INDEX>Algol<SUBINDEX>call-by-name argument passing</SUBINDEX></INDEX>
        <INDEX>call-by-name argument passing</INDEX>
        Algol 60<APOS/>s <EM>call-by-name</EM>
        parameter-passing method.  The use of this mechanism to implement
        streams was first described by 
        <INDEX>Landin, Peter</INDEX>
        Landin (1965).  Delayed evaluation for
        streams was introduced into Lisp by 
        <INDEX>Friedman, Daniel P.</INDEX>
        <INDEX>Wise, David S.</INDEX>
        Friedman and Wise (1976). In their
        implementation, <SCHEMEINLINE>cons</SCHEMEINLINE>
	always delays evaluating its arguments, so
        that lists automatically behave as streams.  The memoizing
        optimization is also known as 
        <INDEX>call-by-need argument passing</INDEX>
        <INDEX>thunk<SUBINDEX>call-by-name</SUBINDEX></INDEX>
        <INDEX>thunk<SUBINDEX>call-by-need</SUBINDEX></INDEX>
        <INDEX>Algol<SUBINDEX>thunks</SUBINDEX></INDEX>
        <EM>call-by-need</EM>.  The Algol community
        would refer to our original delayed objects as <EM>call-by-name
        thunks</EM> and to the optimized versions as <EM>call-by-need thunks</EM>.</FOOTNOTE>
      </TEXT>

      <EXERCISE>
	<LABEL NAME="ex:general-stream-map"/>
	Complete the following definition, which
	generalizes <SCHEMEINLINE>stream-map</SCHEMEINLINE> to allow procedures
	that take multiple arguments, analogous to <SCHEMEINLINE>map</SCHEMEINLINE> in
	section<SPACE/><REF NAME="sec:sequence-operations"/>,
	footnote<SPACE/><REF NAME="foot:generalmap"/>.

	<SNIPPET EVAL="no" EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            <!--  \indcode{stream-map}[with multiple arguments] -->
            (define (stream-map proc . argstreams)
            (if (^??^ (car argstreams))
            the-empty-stream
            (^??^
            (apply proc (map ^??^ argstreams))
            (apply stream-map
            (cons proc (map ^??^ argstreams))))))
          </SCHEME>
	</SNIPPET>
      </EXERCISE>
      
      <EXERCISE>
	<LABEL NAME="ex:delayed1"/>
	<INDEX>delayed evaluation<SUBINDEX>printing and</SUBINDEX></INDEX>
	In order to take a closer look at delayed evaluation, we will use the
	following procedure, which simply returns its argument after printing it:

	<SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (define (show x)
            (display-line x)
            x)
          </SCHEME>
	</SNIPPET>

	What does the interpreter print in response to evaluating each
	expression in the following sequence?<FOOTNOTE>Exercises such as<SPACE/><REF NAME="ex:delayed1"/> and<SPACE/><REF NAME="ex:delayed2"/>
	are valuable for testing our understanding of how <SCHEMEINLINE>delay</SCHEMEINLINE> works.
	On the other hand, intermixing delayed evaluation with printing<EMDASH/>and,
	even worse, with assignment<EMDASH/>is extremely confusing, and instructors
	of courses on computer languages have traditionally tormented their
	students with examination questions such as the ones in this section.
	Needless to say, writing programs that depend on such subtleties is
	<INDEX>programming<SUBINDEX>odious style</SUBINDEX></INDEX>
	odious programming style.  Part of the power of stream processing is
	that it lets us ignore the order in which events actually happen in
	our programs.  Unfortunately, this is precisely what we cannot afford
	to do in the presence of assignment, which forces us to be concerned
	with time and change.</FOOTNOTE>

	<SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (define x (stream-map show (stream-enumerate-interval 0 10)))

            (stream-ref x 5)

            (stream-ref x 7)
          </SCHEME>
	</SNIPPET>
      </EXERCISE>

      <EXERCISE>
        <INDEX>delayed evaluation<SUBINDEX>assignment and</SUBINDEX></INDEX>
        Consider the sequence of expressions

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
          <SCHEME>
            (define sum 0)

            (define (accum x)
            (set! sum (+ x sum))
            sum)

            (define seq (stream-map accum (stream-enumerate-interval 1 20)))
            (define y (stream-filter even? seq))
            (define z (stream-filter (lambda (x) (= (remainder x 5) 0))
            seq))

            (stream-ref y 7)

            (display-stream z)
          </SCHEME>
        </SNIPPET>

        What is the value of <SCHEMEINLINE>sum</SCHEMEINLINE> after each of the above
	expressions is evaluated?  What is the printed response to evaluating the
	<SCHEMEINLINE>stream-ref</SCHEMEINLINE> and <SCHEMEINLINE>display-stream</SCHEMEINLINE>
	expressions?  Would these responses differ if we had implemented
	<SCHEMEINLINE>(delay<SPACE/>^exp^)</SCHEMEINLINE> simply as
        <SCHEMEINLINE>(lambda () ^exp^)</SCHEMEINLINE> without using the optimization provided by
        <SCHEMEINLINE>memo\?proc</SCHEMEINLINE><LATEXINLINE>$\,$</LATEXINLINE>?  Explain.
        <LABEL NAME="ex:delayed2"/>
      </EXERCISE>

    </SCHEME>

    <JAVASCRIPT>

      <TEXT>
	In their most basic form, streams are similar to lists. The empty stream is
	<JAVASCRIPTINLINE>null</JAVASCRIPTINLINE>,
	a non-empty stream is a pair, and the <JAVASCRIPTINLINE>head</JAVASCRIPTINLINE> 
	of the pair is a data item. However, the <JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE> of
	a pair that represents a 
	non-empty stream is not a stream, but a <EM>nullary function that returns a stream</EM>.
	The stream returned by the function, we call <EM>the tail of the stream</EM>.
	If we have a data item <JAVASCRIPTINLINE>x</JAVASCRIPTINLINE>
	and a stream <JAVASCRIPTINLINE>s</JAVASCRIPTINLINE>, we can construct a stream
	whose head is <JAVASCRIPTINLINE>x</JAVASCRIPTINLINE> and whose tail is
	<JAVASCRIPTINLINE>s</JAVASCRIPTINLINE> by evaluating
	<JAVASCRIPTINLINE>pair(x, () => s)</JAVASCRIPTINLINE>.
      </TEXT>

      <TEXT>
	In order to access the data item of a non-empty stream, we just use
	<JAVASCRIPTINLINE>head</JAVASCRIPTINLINE> as with lists. In order
	to access the tail of a stream
	<JAVASCRIPTINLINE>s</JAVASCRIPTINLINE>, we need to <EM>apply</EM> 
	<JAVASCRIPTINLINE>tail(s)</JAVASCRIPTINLINE>, i.e. evaluate
	<JAVASCRIPTINLINE>(tail(s))()</JAVASCRIPTINLINE>. For convenience, we therefore define
        <SNIPPET EVAL="yes"  CHAP="2">
          <NAME>stream_tail</NAME>
	  <EXAMPLE>stream_tail_example</EXAMPLE>
          <JAVASCRIPT>
function stream_tail(stream) {
    return tail(stream)();
}
	  </JAVASCRIPT>
	</SNIPPET>

        <SNIPPET EVAL="yes" HIDE="yes">
          <NAME>stream_tail_example</NAME>
          <JAVASCRIPT>
stream_tail(pair(4, () => pair(5, () => null)));	    
	  </JAVASCRIPT>
	</SNIPPET>
	
      </TEXT>

      <TEXT>
        We can make and use streams, in just the same way as we can make
        and use lists, to represent aggregate data arranged in a sequence.  In
        particular, we can build stream analogs of the list operations from
        chapter<SPACE/>2, such as  <JAVASCRIPTINLINE>list_ref</JAVASCRIPTINLINE>,
	<SCHEMEINLINE>map</SCHEMEINLINE>, and
	<JAVASCRIPTINLINE>for_each</JAVASCRIPTINLINE>:<FOOTNOTE>This should bother you.
	The fact that we are defining such similar functions
        for streams and lists indicates that we are missing some
        underlying abstraction.  Unfortunately, in order to exploit this
        abstraction, we will need to exert finer control over the process of
        evaluation than we can at present.  We will discuss this point further
        at the end of section<SPACE/><REF NAME="sec:streams-and-delayed-evaluation"/>.
        In section<SPACE/><REF NAME="sec:lazy-evaluation"/>, we<APOS/>ll develop
	a framework that unifies lists and streams.</FOOTNOTE>
        <SNIPPET EVAL="yes" CHAP="2">
          <REQUIRES>stream_tail</REQUIRES>
          <NAME>stream_functions</NAME>
          <EXAMPLE>stream_functions_example</EXAMPLE>
	  <JAVASCRIPT>
function stream_ref(s, n) {
    return n === 0
           ? head(s)
           : stream_ref(stream_tail(s), n - 1);
}
function stream_map(f, s) {
    return is_null(s)
           ? null
           : pair(f(head(s)),
                  () => stream_map(f, stream_tail(s)));
}
function stream_for_each(fun, s) {
    if (is_null(s)) {
        return true;
    } else {
        fun(head(s));
        return stream_for_each(fun, stream_tail(s));
    }
}
	  </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET EVAL="yes" CHAP="2" HIDE="yes">
          <REQUIRES>stream_tail</REQUIRES>
          <NAME>stream_functions_example</NAME>
	  <JAVASCRIPT>
const my_stream = pair(4, () => pair(5, () => null));
display(stream_ref(my_stream, 1));
const my_stream_2 = stream_map(x => x + 1, my_stream);
stream_for_each(display, my_stream_2);
	  </JAVASCRIPT>
	</SNIPPET>
	
      </TEXT>

      <TEXT>
	The function
        <JAVASCRIPTINLINE>stream_for_each</JAVASCRIPTINLINE> is useful for viewing streams:
        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
          <NAME>display_stream</NAME>
	  <REQUIRES>stream_functions</REQUIRES>
          <EXAMPLE>display_stream_example</EXAMPLE>
          <SCHEME>
            <!--  \indcode*{display-stream} -->
            (define (display-stream s)
            (stream-for-each display-line s))

            <!--  \indcode*{display-line} -->
            (define (display-line x)
            (newline)
            (display x))
          </SCHEME>
	  <JAVASCRIPT>
function display_stream(s) {
    return stream_for_each(display, s);
}
	  </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET EVAL="yes" HIDE="yes">
          <REQUIRES>stream_tail</REQUIRES>
          <NAME>display_stream_example</NAME>
	  <JAVASCRIPT>
const my_stream = pair(4, () => pair(5, () => null));
display_stream(my_stream);
	  </JAVASCRIPT>
	</SNIPPET>
	
      </TEXT>

      <TEXT>
	The function that represents the tail of a stream is evaluated when it is accessed,
	using <JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE>.
	This design choice is
        reminiscent of our discussion of rational numbers in
        section<SPACE/><REF NAME="sec:abstraction-barriers"/>, where we saw that we can
        choose to implement rational numbers so that the reduction of
        numerator and denominator to lowest terms is performed either at
        construction time or at selection time.  The two rational-number
        implementations produce the same data abstraction, but the choice has
        an effect on efficiency.  There is a similar relationship between
        streams and ordinary lists.  As a data abstraction, streams are the
        same as lists.  The difference is the time at which the elements are
        evaluated.  With ordinary lists, both the <JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>
	<JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>
        are evaluated at construction time.  With streams, the
	<JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE> is
        evaluated at selection time.
      </TEXT>

      <TEXT>
	The tail of a stream is <QUOTE>wrapped</QUOTE> in a function.
	It is a <EM>delayed expression</EM>, a <QUOTE>promise</QUOTE> 
	to evaluate an expression 
        <LATEXINLINE>exp</LATEXINLINE> at some future time. Correspondingly, 
	<JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE> forces the tail to fulfill its promise.  
	It selects the <JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE> of the pair and
	evaluates the delayed expression found there to obtain the rest of the stream.
        <INDEX>stream(s)<SUBINDEX>implemented as delayed lists|)</SUBINDEX></INDEX>
      </TEXT>

      <SUBHEADING> 
        <NAME>Streams in action</NAME>
      </SUBHEADING>

      <TEXT>
        To see how this data structure behaves, let us analyze the
        <QUOTE>outrageous</QUOTE> prime computation we saw above, reformulated in terms
        of streams:

        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
	  <NAME>stream_enumerate_interval_example</NAME>
          <REQUIRES>prime_definition</REQUIRES>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <JAVASCRIPT>
head(stream_tail(stream_filter(
                    is_prime,
                    stream_enumerate_interval(10000, 
                                              1000000))));
	  </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        We will see that it does indeed work efficiently.
      </TEXT>

      <TEXT>
        We begin by calling <JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE> with
        the arguments 10,000 and 1,000,000.  The function
	<JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE>
        is the stream analog of <JAVASCRIPTINLINE>enumerate_interval</JAVASCRIPTINLINE>
        (section<SPACE/><REF NAME="sec:sequences-conventional-interfaces"/>):

        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
          <REQUIRES>prime_definition</REQUIRES>
          <NAME>stream_enumerate_interval</NAME>
	  <EXAMPLE>stream_enumerate_interval_example</EXAMPLE>
	  <JAVASCRIPT>
function stream_enumerate_interval(low, high) {
    return low &gt; high
           ? null
           : pair(low,
                  () => stream_enumerate_interval(low + 1, 
                                                  high)); 
}
	  </JAVASCRIPT>
        </SNIPPET>

        and thus the result returned by
	<JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE>,
        formed by the <SCHEMEINLINE>pair</SCHEMEINLINE>, is<FOOTNOTE>The numbers shown
	here do not really appear in the delayed expression.  What actually appears is
        the original expression, in an environment in which the variables are
        bound to the appropriate numbers.  For example,
	<JAVASCRIPTINLINE>low + 1</JAVASCRIPTINLINE> with
        <SCHEMEINLINE>low</SCHEMEINLINE> bound to 10,000 actually appears where
	<SCHEMEINLINE>10001</SCHEMEINLINE> is shown.</FOOTNOTE>

        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <JAVASCRIPT>
pair(10000, () => stream_enumerate_interval(10001, 1000000));
	  </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        That is, <JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE>
        returns a stream represented as a pair whose
	<JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>
        is 10,000 and whose <JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>
	is a promise to enumerate more of the
        interval if so requested.  This stream is now filtered for primes,
        using the stream analog of the <SCHEMEINLINE>filter</SCHEMEINLINE> function
        (section<SPACE/><REF NAME="sec:sequences-conventional-interfaces"/>):

        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS" CHAP="2">
          <REQUIRES>stream_tail</REQUIRES>
          <NAME>stream_filter</NAME>
          <EXAMPLE>stream_filter_example</EXAMPLE>
	  <JAVASCRIPT>
function stream_filter(pred, s) {
    return is_null(s)
           ? null
           : pred(head(s))
             ? pair(head(s),
                    () => stream_filter(pred, 
                                        stream_tail(s)))
             : stream_filter(pred,
                             stream_tail(s));
}
	  </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS" CHAP="2" HIDE="yes">
          <NAME>stream_filter_example</NAME>
          <REQUIRES>display_stream</REQUIRES>
	  <JAVASCRIPT>
const my_stream = pair(5, () => pair(6, () => pair(7, () => null)));
const my_filtered_stream =
    stream_filter(x => x % 2 === 0, my_stream);
display_stream(my_filtered_stream);
	  </JAVASCRIPT>
	</SNIPPET>
	
      </TEXT>

      <TEXT>
        The function <JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE> tests the
	<SCHEMEINLINE>head</SCHEMEINLINE> of the stream (which is 10,000).  Since this is
	not prime, <JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE> examines the tail
	of its input
        stream.  The call to <JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE> forces evaluation of the delayed
        <JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE>, which now returns

        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <JAVASCRIPT>
pair(10001, () => stream_enumerate_interval(10002, 1000000));
          </JAVASCRIPT>
	</SNIPPET>
      </TEXT>

      <TEXT>
	The function
        <JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE> 
	now looks at the <JAVASCRIPTINLINE>head</JAVASCRIPTINLINE>
	of this stream,
        10,001, sees that this is not prime either, forces another 
	<JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE>, and so on, until 
	<JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE> yields
        the prime 10,007, whereupon <JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE>, according to its
        definition, returns

        <SNIPPET EXTERNAL_LIBRARY="STREAMS" EVAL="no">
	  <JAVASCRIPT>
pair(head(stream), stream_filter(pred, stream_tail(stream)));
          </JAVASCRIPT>
	</SNIPPET>

        which in this case is

        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
          <REQUIRES>prime_definition</REQUIRES>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <JAVASCRIPT>
pair(10007,
     () => stream_filter(is_prime,
               pair(10008,
                    () => stream_enumerate_interval(10009, 
                                                    1000000))
	      )
    );
	  </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        This result is now passed to <JAVASCRIPTINLINE>stream_tail</JAVASCRIPTINLINE> in our
        original expression.  This forces the delayed
	<JAVASCRIPTINLINE>stream_filter</JAVASCRIPTINLINE>, 
	which in turn keeps forcing the delayed
	<JAVASCRIPTINLINE>stream_enumerate_interval</JAVASCRIPTINLINE> 
	until it finds the next prime, which is
        10,009.  Finally, the result passed to <SCHEMEINLINE>head</SCHEMEINLINE> in our
        original expression is

        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
          <REQUIRES>prime_definition</REQUIRES>
          <REQUIRES>stream_enumerate_interval</REQUIRES>
	  <JAVASCRIPT>
pair(10009,
     () => stream_filter(is_prime,
               pair(10010,
                    () => stream_enumerate_interval(10011, 
                                                    1000000))
              )
    );
	  </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
	The function
        <SCHEMEINLINE>head</SCHEMEINLINE> returns 10,009,
	and the computation is complete.  Only as
        many integers were tested for primality as were necessary to find the
        second prime, and the interval was enumerated only as far as was
        necessary to feed the prime filter.
      </TEXT>

      <TEXT>
        In general, we can think of delayed evaluation as 
        <INDEX>programming<SUBINDEX>demand-driven</SUBINDEX></INDEX>
        <QUOTE>demand-driven</QUOTE>
        programming, whereby each stage in the stream process is activated
        only enough to satisfy the next stage.  What we have done is to
        <INDEX>order of events<SUBINDEX>decoupling apparent from actual</SUBINDEX></INDEX>
        decouple the actual order of events in the computation from the
        apparent structure of our functions. We write functions
        as if the streams existed <QUOTE>all at once</QUOTE> when, in reality,
	the computation is performed incrementally, as in traditional programming styles.
      </TEXT>


      <SUBHEADING> 
        <NAME>An optimization</NAME>
      </SUBHEADING>

      <TEXT>
        <!-- \indsf{delay}[implementation using <SCHEMEINLINE>lambda</SCHEMEINLINE>]-->
	When we construct stream pairs, we delay the evaluation of their tail expressions
	by wrapping these expressions in a function. We force their evaluation when needed,
	by applying the function.
      </TEXT>

      <TEXT>
        <!-- \indsf{delay}[memoized]-->
        <INDEX>memoization<SUBINDEX>delay@by <SCHEMEINLINE>delay</SCHEMEINLINE></SUBINDEX></INDEX>
        This implementation suffices for streams to work
        as advertised, but there is an important optimization that we can
        include.  In many applications, we end up forcing the same delayed object
        many times.  This can lead to serious inefficiency in recursive
        programs involving streams.  (See
        exercise<SPACE/><REF NAME="ex:fib-stream-efficiency"/>.)  The solution is to build
        delayed objects so that the first time they are forced, they store the
        value that is computed.  Subsequent forcings will simply return the
        stored value without repeating the computation.  In other words, we
        implement the construction of stream pairs as a memoized function
        similar to the one described in exercise<SPACE/><REF NAME="ex:memoization"/>.
	One way to accomplish this is to use the following function,
	which takes as argument a function
        (of no arguments) and returns a memoized version of the function.
	The first time the memoized function is run, it saves the computed result.
	On subsequent evaluations, it simply returns the result.

        <SNIPPET EXTERNAL_LIBRARY="STREAMS">
	  <NAME>memo</NAME>
	  <EXAMPLE>memo_example</EXAMPLE>
          <JAVASCRIPT>
function memo(fun) {	    
    let already_run = false;
    let result = undefined;
    return () => {
                     if (!already_run) {
                         result = fun();
                         already_run = true;
                         return result;
                     } else {
                         return result;
                     }
	         };
}
	  </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET EXTERNAL_LIBRARY="STREAMS" HIDE="yes">
	  <NAME>memo_example</NAME>
          <JAVASCRIPT>
function square_4() {
    const result = 4 * 4;	    
    display("multiplication carried out");
    return result;
}
const memo_square_4 = memo(square_4);
display(memo_square_4()); // shows "multipl.."
display(memo_square_4()); // does not show "multipl.."
	  </JAVASCRIPT>
	</SNIPPET>
	
      </TEXT>

      <TEXT>
	We can make use of <JAVASCRIPTINLINE>memo</JAVASCRIPTINLINE> whenever
	we construct a stream pair. For example, instead of 
        <SNIPPET EVAL="yes" CHAP="2">
	  <EXAMPLE>stream_map_example</EXAMPLE>
	  <JAVASCRIPT>
function stream_map(f, s) {
    return is_null(s)
           ? null
           : pair(f(head(s)),
                  () => stream_map(f, stream_tail(s)));
}
          </JAVASCRIPT>
	</SNIPPET>
	<SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS" HIDE="yes">
          <REQUIRES>stream_tail</REQUIRES>
	  <NAME>stream_map_example</NAME>
	  <JAVASCRIPT>
function stream_ref(s, n) {
    return n === 0
           ? head(s)
           : stream_ref(stream_tail(s), n - 1);
}

const my_stream = pair(4, () => pair(5, () => null));

const my_stream_2 =
    stream_map(x => { display(x); return x; }, 
               my_stream);

stream_ref(my_stream_2, 1);
stream_ref(my_stream_2, 1);
// the number 5 is shown twice
// because the same delayed
// object is forced twice
true;
	  </JAVASCRIPT>
	</SNIPPET>
	we can define an optimized function <JAVASCRIPTINLINE>stream_map</JAVASCRIPTINLINE>
	as follows:<FOOTNOTE>There are many
          possible implementations of streams other than the one described in
          this section.  Delayed evaluation, which is the key to making streams
          practical, was inherent in 
          <INDEX>Algol<SUBINDEX>call-by-name argument passing</SUBINDEX></INDEX>
          <INDEX>call-by-name argument passing</INDEX>
          Algol 60<APOS/>s <EM>call-by-name</EM>
          parameter-passing method.  The use of this mechanism to implement
          streams was first described by 
          <INDEX>Landin, Peter</INDEX>
          Landin (1965).  Delayed evaluation for
          streams was introduced into Lisp by 
          <INDEX>Friedman, Daniel P.</INDEX>
          <INDEX>Wise, David S.</INDEX>
          Friedman and Wise (1976). In their
          implementation, <SCHEMEINLINE>cons</SCHEMEINLINE>
	  always delays evaluating its arguments, so
          that lists automatically behave as streams.  The memoizing
          optimization is also known as 
          <INDEX>call-by-need argument passing</INDEX>
          <INDEX>thunk<SUBINDEX>call-by-name</SUBINDEX></INDEX>
          <INDEX>thunk<SUBINDEX>call-by-need</SUBINDEX></INDEX>
          <INDEX>Algol<SUBINDEX>thunks</SUBINDEX></INDEX>
          <EM>call-by-need</EM>.  The Algol community
          would refer to our original delayed objects as <EM>call-by-name
          thunks</EM> and to the optimized versions as <EM>call-by-need thunks</EM>.
	</FOOTNOTE>

	<SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
	  <NAME>stream_map_optimized</NAME>
	  <REQUIRES>memo</REQUIRES>
	  <EXAMPLE>stream_map_optimized_example</EXAMPLE>
	  <JAVASCRIPT>
function stream_map_optimized(f, s) {
    return is_null(s)
           ? null
           : pair(f(head(s)),
                  memo( () => stream_map_optimized(
                                 f, stream_tail(s)) ));
}
          </JAVASCRIPT>
	</SNIPPET>

	<SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS" HIDE="yes">
	  <NAME>stream_map_optimized_example</NAME>
	  <JAVASCRIPT>
const my_stream = pair(4, () => pair(5, () => null));

const my_stream_2 =
    stream_map(x => { display(x); return x; }, 
               my_stream);

stream_ref(my_stream_2, 1);
stream_ref(my_stream_2, 1);
// the number 5 is shown twice
// because the same delayed
// object is forced twice

const my_stream_3 =
    stream_map_optimized(x => { display(x); return x; }, 
               my_stream);

stream_ref(my_stream_3, 1);
stream_ref(my_stream_3, 1);
// the number 5 is shown only once
// because the result of forcing
// the delayed object is memoized
true;
	  </JAVASCRIPT>
	</SNIPPET>

      </TEXT>
      
      <EXERCISE>
	<LABEL NAME="ex:combine-streams"/>
	Define a function <JAVASCRIPTINLINE>stream_combine</JAVASCRIPTINLINE>
	that takes a binary function and two streams as arguments and returns
	a stream whose elements are the results of applying the function
	pairwise to the corresponding elements of the argument streams.

	<SNIPPET EVAL="no" EXTERNAL_LIBRARY="STREAMS">
	  <JAVASCRIPT>
function stream_combine(f, s1, s2) {
    ...
}
          </JAVASCRIPT>
	</SNIPPET>

	<SNIPPET EVAL="no" HIDE="yes">
	  <NAME>stream_combine</NAME>
	  <JAVASCRIPT>
function stream_combine(f, s1, s2) {
    return is_null(s1) &amp;&amp; is_null(s2)
        ? null
        : is_null(s1) || is_null(s2)
        ? error(null, "unexpected null in stream_combine")
        : pair(f(head(s1),head(s2)), 
               () => stream_combine(f, stream_tail(s1),
                                       stream_tail(s2)));
}	  	
	  </JAVASCRIPT>
	</SNIPPET>
	</EXERCISE>

      <EXERCISE>
	<LABEL NAME="ex:delayed1"/>
	<INDEX>delayed evaluation<SUBINDEX>printing and</SUBINDEX></INDEX>
	In order to take a closer look at delayed evaluation, we will use the
	following function, which simply returns its argument after printing it:

      <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
        <NAME>show</NAME>
	<JAVASCRIPT>
function show(x) {
    display(x);
    return x;
}
	</JAVASCRIPT>
      </SNIPPET>

      What does the interpreter print in response to evaluating each
      expression in the following sequence?<FOOTNOTE>Exercises
      such as<SPACE/><REF NAME="ex:delayed1"/> and<SPACE/><REF NAME="ex:delayed2"/>
      are valuable for testing our understanding of how delayed evaluation works.
      On the other hand, intermixing delayed evaluation with printing<EMDASH/>and,
      even worse, with assignment<EMDASH/>is extremely confusing, and instructors
      of courses on computer languages have traditionally tormented their
      students with examination questions such as the ones in this section.
      Needless to say, writing programs that depend on such subtleties is
      <INDEX>programming<SUBINDEX>odious style</SUBINDEX></INDEX>
      odious programming style.  Part of the power of stream processing is
      that it lets us ignore the order in which events actually happen in
      our programs.  Unfortunately, this is precisely what we cannot afford
      to do in the presence of assignment, which forces us to be concerned
      with time and change.</FOOTNOTE>

      <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
        <REQUIRES>stream_enumerate_interval</REQUIRES>
        <REQUIRES>show</REQUIRES>
	<JAVASCRIPT>
let x = stream_map(show, stream_enumerate_interval(0, 10));
stream_ref(x, 5);
stream_ref(x, 7);
	</JAVASCRIPT>
      </SNIPPET>

      <SPLIT>
	<JAVASCRIPT>
	  What does the evaluator print if 
	  <JAVASCRIPTINLINE>stream_map_optimized</JAVASCRIPTINLINE>
	  is used instead of <JAVASCRIPTINLINE>stream_map</JAVASCRIPTINLINE>?
      <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS">
        <REQUIRES>stream_map_optimized</REQUIRES>
        <REQUIRES>stream_enumerate_interval</REQUIRES>
        <REQUIRES>show</REQUIRES>
	<JAVASCRIPT>
let x = stream_map_optimized(
            show, 
            stream_enumerate_interval(0, 10));
stream_ref(x, 5);
stream_ref(x, 7);
	</JAVASCRIPT>
      </SNIPPET>
	</JAVASCRIPT>
      </SPLIT>
      
      </EXERCISE>

      <EXERCISE>
        <INDEX>delayed evaluation<SUBINDEX>assignment and</SUBINDEX></INDEX>
        Consider the sequence of expressions

        <SNIPPET EVAL="yes" EXTERNAL_LIBRARY="STREAMS"> 
          <REQUIRES>stream_enumerate_interval</REQUIRES>
          <REQUIRES>even_definition</REQUIRES>
          <REQUIRES>display_stream</REQUIRES>
	  <JAVASCRIPT>
let sum = 0;

function accum(x) {
    sum = x + sum;
    return sum;
}

const seq = stream_map(
                accum, 
                stream_enumerate_interval(1, 20));
const y = stream_filter(is_even, seq);

const z = stream_filter(x => x % 5 === 0, seq);

stream_ref(y, 7);

display_stream(z);
	  </JAVASCRIPT>
        </SNIPPET>

        What is the value of <SCHEMEINLINE>sum</SCHEMEINLINE> after each of
	the above expressions is evaluated?  What is the printed response
	to evaluating the 
	<JAVASCRIPTINLINE>stream_ref</JAVASCRIPTINLINE> and 
	<JAVASCRIPTINLINE>display_stream</JAVASCRIPTINLINE>
	expressions? Would these responses differ if we had applied the
	function <JAVASCRIPTINLINE>memo</JAVASCRIPTINLINE>
	on every tail of every constructed stream pair, as suggested
	in the optimization above? Explain.
        <LABEL NAME="ex:delayed2"/>
      </EXERCISE>

    </JAVASCRIPT>

  </SPLIT>

</SUBSECTION>
