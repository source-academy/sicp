[{"id":"/sicpjs/2.3.3","tag":"TITLE","body":"2.3.3  \n    Example: Representing Sets"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In the previous examples we built representations for two kinds of\n    compound data objects: rational numbers and algebraic expressions.  In\n    one of these examples we had the choice of simplifying (reducing) the\n    expressions at either construction time or selection time, but other\n    than that the choice of a representation for these structures in terms\n    of lists was straightforward. When we turn to the representation of\n    sets, the choice of a representation is not so obvious.  Indeed, there\n    are a number of possible representations, and they differ\n    significantly from one another in several ways.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    Informally, a set is simply a collection of distinct objects.  To give\n    a more precise definition we can employ the method of data\n    abstraction.  That is, we define \"","tag":"#text"},{"body":"set","tag":"#text"},{"body":"\" by specifying the\n    \n    operations that are to be used on sets.  These are\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"intersection_set"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":",\n      \n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":".\n\tThe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":"\n    is a predicate that determines whether a given element is a member of a set.\n    The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":"\n    takes an object and a set as arguments and returns a set that contains the\n    elements of the original set and also the adjoined element.\n    The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":"\n    computes the union of two sets, which is the set containing each element\n    that appears in either argument.\n    The function\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"intersection_set"},{"body":"\n    computes the intersection of two sets, which is the set containing only\n    elements that appear in both arguments.  From the viewpoint of data\n    abstraction, we are free to design any representation that implements these\n    operations in a way consistent with the interpretations given\n    above.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/2.3.3#footnote-1"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Sets as unordered lists","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    One way to represent a set is as a list of its elements in which no\n    element appears more than once.  The empty set is represented by the\n    empty list.  In this representation,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":"\n    is similar to the\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"member"},{"body":"\n      of section ","tag":"#text"},{"tag":"REF","body":"2.3.1","href":"/sicpjs/2.3.1"},{"body":".\t\n      \n    It uses\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"equal"},{"body":"\n    instead of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"==="},{"body":"\n    so that the set elements need not be\n    just numbers or strings:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":7,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBDAEwCsqKiB9AZwFMyAKAB4AaUDzIBKUAG9soOaABOvAgtoVO7bgBtuAW25Ey7Kni69BIseNnzb8gPyjeNu7YBcoAA50KCi04kAbmwAX1xCUkoaUHVNHX1DY1MxfytpF0VlVRiNIgItLT40jNdQRzw6LR4S1w9uAEcCSv8AC25GIt5xa1LbRzIFAm4auw9Y7T0DIxMzfmFQMh9Cq3FgsOxx+Kmk2b4ARgBWIQzGFjZdvYAGEVPWDhTDm+Y73ZRr0DyC7u7AoA","body":"function is_element_of_set(x, set) {\n    return is_null(set) \n           ? false\n           : equal(x, head(set))\n           ? true\n           : is_element_of_set(x, tail(set));\n} "},{"body":"\n    Using this, we can write\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":".\n      \n    If the object to be adjoined is already in the set, we just return the set.\n    Otherwise, we use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    to add the object to the list that represents the set:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":9,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQKBnAfQFMAbZgW2aLMar0b1mZABQAPADSghZAJSgA3tlArQAJ2EE1tBoyIFWrETPnLV51QH5QeAIashZi+YBcoZgEcC98VIAWzLYAJsbCsrJOzirWZGoEzJFRbrpsnNy8-ILCvqBkthRGJrIA3NgAvriEpJQ0oMEAVlQURFmiktJhipEaZFo6TKlcPHwCMjkmic7WMpMWbgAO+WrjYaUV2A1NLWMAjAAMUpvNrSI7AKyHQY3HYygHoPqG4SVAA","body":"function adjoin_set(x, set) {\n    return is_element_of_set(x, set)\n           ? set\n           : pair(x, set);\n} "},{"body":"\n    For\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"intersection_set"},{"body":"\n    we can use a recursive strategy.  If we know how to form the intersection\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set2"},{"body":" and the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set1"},{"body":", we only need to decide whether to\n    include the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set1"},{"body":" in this.  But this depends on whether\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head(set1)"},{"body":"\n    is also in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set2"},{"body":".  Here is the resulting\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":15,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQKBnAfQFMAbZgW2aLMar0b1mZABQAPADSghZAJSgA3tlArQAJ2EE1tBoyIFWrETPnLV51QH5QeAIashZi+YBcoZgEcC98VIAWzLYAJsbCsrJOzirWZGoEzJFRbrpsnNy8-ILCvqBkthRGJrIA3NgAvriEpJQ0oMEAVlQURFmiktJhipEaZFo6TKlcPHwCMjkmic7WMpMWbgAO+WrjYaUV+MTk1Do8zGpCWzStoWQAjFIyKPJK5j19dEz6hien8gA+bw96BoXCV7PmaxPVgA1TJAbsIYZUbZALBF6yC5-CJRQGgRYUZZwkIyV5SZpkPYHGotMZ5AoIpFkK4o1EqZK7fbMQ6k7Lk35nREdaklcq4AlE5kk45OBpNVmiU4ABikYuaxxQMrqQUa8rGGCVwPCiNFKvFx2lsr1auypwArEbVRKRIqpFrtcUgA","body":"function intersection_set(set1, set2) {\n    return is_null(set1) || is_null(set2)\n           ? null\n           : is_element_of_set(head(set1), set2)\n           ? pair(head(set1), intersection_set(tail(set1), set2))\n           : intersection_set(tail(set1), set2);\n} "}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    In designing a representation, one of the issues we should be concerned\n    with is efficiency.  Consider the number of steps required by our set\n    operations.  Since they all use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":",\n      \n    the speed of this operation has a major impact on the efficiency of the set\n    implementation as a whole.  Now, in order to check whether an object is a\n    member of a set,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":"\n    may have to scan the entire set. (In the worst case, the object turns out\n    not to be in the set.)  Hence, if the set has\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" elements,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":"\n    might take up to ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" steps.  Thus, the number of\n    steps required grows as ","tag":"#text"},{"body":"$\\Theta(n)$","tag":"LATEX"},{"body":". The number\n    of steps required by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":",\n      \n    which uses\n    this operation, also grows as ","tag":"#text"},{"body":"$\\Theta(n)$","tag":"LATEX"},{"body":".  For\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"intersection_set"},{"body":",\n      \n    which does an\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":"\n    check for each element of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set1"},{"body":", the number of\n    steps required grows as the product of the sizes of the sets involved, or\n    ","tag":"#text"},{"body":"$\\Theta(n^{2})$","tag":"LATEX"},{"body":" for two sets of size\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".  The same will be true of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":".","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.59","id":"#ex-2.59","child":[{"body":"\n    Implement the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":"\n    operation for the unordered-list representation of sets.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":15,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQKBnAfQFMAbZgW2aLMar0b1mZABQAPADSghZAJSgA3tlArQAJ2EE1tBoyIFWrETPnLV51QH5QeAIashZi+YBcoZgEcC98VIAWzLYAJsbCsrJOzirWZGoEzJFRbrpsnNy8-ILCvqBkthRGJrIA3NgAvriEpJQ0oMEAVlQURFmiktJhipEaZFo6TKlcPHwCMjkmic7WMpMWbgAO+WrjYaUV+MTk1LTE262hZACMUjIo8krmPX10TPqGB4cRUebTwiizrnVBjc37AcEPWRSD7PZ67Gj7PIFQEnN7hNa4cEtMZOBpNZHZQ4ABikaN+YxQOK+PwxogwRLurHCQNR33R+2xuLp+MxAFYmST9oSpJTqSUgA","body":"function union_set(set1, set2) {\n    return is_null(set1)\n           ? set2\n           : adjoin_set(head(set1), \n                        union_set(tail(set1), set2));\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.60","id":"#ex-2.60","child":[{"body":"\n    We specified that a set would be represented as a list with no duplicates.\n    Now suppose we allow duplicates.  For instance, the set\n    ","tag":"#text"},{"body":"$\\{1,2,3\\}$","tag":"LATEX"},{"body":" could be represented as the list\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(2, 3, 2, 1, 3,"},{"tag":"JAVASCRIPTINLINE","body":"2, 2)"},{"body":".\n    \n    Design\n    functions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":",\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"intersection_set"},{"body":"\n    that operate on this representation.  How does the efficiency of each\n    compare with the corresponding\n    function\n    for the non-duplicate representation?  Are there applications for which\n    you would use this representation in preference to the non-duplicate one?\n    ","tag":"#text"}],"solution":[{"body":"\n      The functions ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":" and\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"intersection_set"},{"body":" remain unchanged.\n      Here is the new implementation of\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":" and\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":".\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":17,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQKBnAfQFMAbZgW2aLMar0b1mZABQAPADSghZAJSgA3tlArQAJ2EE1tBoyIFWrETPnLV51QH5QeAIashZi+YBcoZgEcC98VIAWzLYAJsbCsrJOzirWZGoEzJFRbrpsnNy8-ILCvqBkthRGJrIA3NgAvriEpJQ0dDzMakLk1ERZojIAjFIyKPJK5hpkWjpM+oahZB3yAD7TdKMGhcK9ic7WY6yrFslMqVw8fAIyIgHBE1PdyxFR5tYADvlqJ4EhnbJSFPWNzM00bSJ5Arnd7SK7XG4qZJfJo1VrHQFLSYgnolcqVYi-WjBABWVE+-0koLkikig2GoAeFCehJMpQqVUxoGILX+nUuZF6JIGmm0oFsdzu3Fewi6RN6dNwzL+xycOLxcOyHQADFI5fjjigVXygrj1dkMFqNuF3rKdfL-srVWa9aIOgBWK26hWiTVSI3G4pAA","body":"function adjoin_set(x, set) {\n    return pair(x, set);\n}\nfunction union_set(set1, set2) {\n    return append(set1, set2);\n} "},{"body":"\n      In the version with no duplicates, the required number of steps for\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":" and \n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":" has an order of growth of\n      ","tag":"#text"},{"body":"$O(n)$","tag":"LATEX"},{"body":", where ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"\n      is the number of element occurrences in the given representation, and\n      the required number of steps for\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"intersection_set"},{"body":" and \n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":" has an order of growth of\n      ","tag":"#text"},{"body":"$O(n m)$","tag":"LATEX"},{"body":", where ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"\n      is the number of element occurrences in the representation of the first\n      set and ","tag":"#text"},{"body":"$m$","tag":"LATEX"},{"body":" is the number of element\n      occurrences in the representation of the second set. In the version that\n      allows duplicates, the number of steps for\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":" shrinks to\n      ","tag":"#text"},{"body":"$O(n)$","tag":"LATEX"},{"body":", and the number of steps for\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":" shrinks to\n      ","tag":"#text"},{"body":"$O(n)$","tag":"LATEX"},{"body":". However, note that the number of\n      element occurrences may be much larger in the second version, because\n      many duplicates may accumulate. For applications where duplicate elements\n      are rare, the version that allows duplicates is preferrable.\n\n    ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Sets as ordered lists","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    One way to speed up our set operations is to change the representation\n    so that the set elements are listed in increasing order.  To do this,\n    we need some way to compare two objects so that we can say which is\n    bigger.  For example, we could compare\n    \n\tstrings\n      \n    lexicographically, or\n    we could agree on some method for assigning a unique number to an\n    object and then compare the elements by comparing the corresponding\n    numbers.  To keep our discussion simple, we will consider only the\n    case where the set elements are numbers, so that we can compare\n    elements using ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":">"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"<"},{"body":". We will represent a set of\n    numbers by listing its elements in increasing order.  Whereas our\n    first representation above allowed us to represent the set\n    ","tag":"#text"},{"body":"$\\{1,3,6,10\\}$","tag":"LATEX"},{"body":" by listing the elements in any\n    order, our new representation allows only the list\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(1, 3, 6, 10)"},{"body":".\n      ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    One advantage of ordering shows up in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":":\n      \n    In checking for the presence of an item, we no longer have to scan the\n    entire set.  If we reach a set element that is larger than the item we\n    are looking for, then we know that the item is not in the set:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction is_element_of_set(x, set) {\n    return is_null(set) \n           ? false\n           : x === head(set)\n           ? true\n           : x < head(set)\n           ? false\n           : // $\\texttt{x > head(set)}$\n             is_element_of_set(x, tail(set));\n}\n      "},{"body":"\n    How many steps does this save?  In the worst case, the item we are\n    looking for may be the largest one in the set, so the number of steps\n    is the same as for the unordered representation.  On the other hand,\n    if we search for items of many different sizes we can expect that\n    sometimes we will be able to stop searching at a point near the\n    beginning of the list and that other times we will still need to\n    examine most of the list.  On the average we should expect to have to\n    examine about half of the items in the set.  Thus, the average\n    number of steps required will be about ","tag":"#text"},{"body":"$n/2$","tag":"LATEX"},{"body":".\n    This is still ","tag":"#text"},{"body":"$\\Theta(n)$","tag":"LATEX"},{"body":" growth, but\n    it does save us, on the average, a factor of 2 in number of steps over the\n    previous implementation.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    We obtain a more impressive speedup with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"intersection_set"},{"body":".\n      \n    In the unordered representation this operation required\n    ","tag":"#text"},{"body":"$\\Theta(n^2)$","tag":"LATEX"},{"body":" steps, because we performed a\n    complete scan of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set2"},{"body":" for each element of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set1"},{"body":".  But with the ordered representation,\n    we can use a more clever method.  Begin by comparing the initial elements,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x1"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x2"},{"body":", of the two sets.  If\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x1"},{"body":" equals\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x2"},{"body":", then that gives an element of the\n    intersection, and the rest of the intersection is the intersection of the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"s\n    of the two sets.  Suppose, however, that ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x1"},{"body":"\n    is less than ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x2"},{"body":". Since\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x2"},{"body":" is the smallest element in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set2"},{"body":", we can immediately conclude that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x1"},{"body":" cannot appear anywhere in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set2"},{"body":" and hence is not in the intersection.\n    Hence, the intersection is equal to the intersection of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set2"},{"body":" with the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set1"},{"body":".  Similarly, if\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x2"},{"body":" is less than\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x1"},{"body":", then the intersection is given by the\n    intersection of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set1"},{"body":" with the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set2"},{"body":".  Here is the\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction intersection_set(set1, set2) {\n    if (is_null(set1) || is_null(set2)) {\n        return null;\n    } else {\n        const x1 = head(set1);\n        const x2 = head(set2);\n        return x1 === x2\n               ? pair(x1, intersection_set(tail(set1), tail(set2)))\n               : x1 < x2 \n               ? intersection_set(tail(set1), set2)\n               : // $\\texttt{x2 < x1}$\n\t         intersection_set(set1, tail(set2));\n    }\n}\n      "},{"body":"\n    To estimate the number of steps required by this process, observe that at\n    each step we reduce the intersection problem to computing intersections of\n    smaller sets—removing the first element from\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set1"},{"body":" or ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set2"},{"body":"\n    or both.  Thus, the number of steps required is at most the sum of the sizes\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set1"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set2"},{"body":",\n    rather than the product of the sizes as with the unordered representation.\n    This is ","tag":"#text"},{"body":"$\\Theta(n)$","tag":"LATEX"},{"body":" growth rather than\n    ","tag":"#text"},{"body":"$\\Theta(n^2)$","tag":"LATEX"},{"body":"—a considerable speedup,\n    even for sets of moderate size.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.61","id":"#ex-2.61","child":[{"body":"\n    Give an implementation of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":"\n    using the ordered representation.  By analogy with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":"\n    show how to take advantage of the ordering to produce a\n    function\n    that requires on the average about half as many steps as with the unordered\n    representation.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBDAEwCsqKiB9AZwFMyAKAB4AaUDzIBKUAG9soOaABOvAgtoVO7IgQA22vmPGz5x+QH5Q29fwGGTdgFygBoALxvQAC26N9vSUbszUV4AwNBHZwAeT28GXwlQwPMABzoKBUERA0SHUFT0vi8fAxEcsONGFjYuXkzQMjS9A3FxAG5sAF9cStYOMT4ARgAGER7q-oGAVlHmXpr+FBHQLV0WtqA","body":"function adjoin_set(x, set) {\n    return is_null(set)\n           ? list(x)\n           : x === head(set) \n           ? set\n           : x < head(set)\n           ? pair(x, set)\n           : pair(head(set), \n                  adjoin_set(x, tail(set)));\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.62","id":"#ex-2.62","child":[{"body":"\n    Give a ","tag":"#text"},{"body":"$\\Theta(n)$","tag":"LATEX"},{"body":" implementation of\n     ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":"\n    for sets represented as ordered lists.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":12,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBDAEwCsqKiB9AZwFMyAKAB4AaUDzIBKUAG9soOaABOvAgtoVO7IgQA22vmPGz5x+QH5Q29fwGGTdgFygBoALxvQAC26N9vSUbszUV4AwNBHZwAeT28GXwlQwPMABzoKBUERA0SHUFT0vi8fAxEcsONGFjYuXkzQMjS9A3FxAG5sAF9cQlJKGlBiag4xeIBGLN4USRljCjxQPnVNHSbeUZbpMsVlVWCyFHbjDtBubR5QOYWlrV14qemtpTIVWjFRw-lj0-OZkxIaThkJyjVwxYprNo5f5EQFOFCgopxMRTD7GJ4vYGudwCFBbEwpNIZATjAZEIY1fgNCirMjrIR48qMuxUmn3WxM8KY6I40AMoL5IkkwY0Cl8FljcQTfYtPlyRwCwQoETC4a1N4icXIlqQo6dXAq0UBSqsVX8UYABhExuqIxQlvozBNoow9pu2m19Pk1tNfAtVsdNtqowArP6qj67SI3dq2kA","body":"function union_set(set1, set2) {\n    if (is_null(set1)) {\n        return set2;\n    } else if (is_null(set2)) {\n        return set1;\n    } else {\n      const x1 = head(set1);\n      const x2 = head(set2);\n      return x1 === x2\n             ? pair(x1, union_set(tail(set1),\n                                  tail(set2)))\n             : x1 < x2 \n             ? pair(x1, union_set(tail(set1), set2))\n             : pair(x2, union_set(set1, tail(set2)));\n    }\n} "},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":12,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBDAEwCsqKiB9AZwFMyAKAB4AaUDzIBKUAG9soOaABOvAgtoVO7IgQA22vmPGz5x+QH5Q29fwGGTdgFygBoALxvQAC26N9vSUbszUV4AwNBHZwAeT28GXwlQwPMABzoKBUERA0SHUFT0vi8fAxEcsONGFjYuXkzQMjS9A3FxAG5sAF9cYmoOMT4AytY+2oBGAAYRIer+lEn6ZmGa-gx5rV0W8SFBxZmx+emR-lGAVindo745kXXtTbagA","body":"union_set(\n   adjoin_set(10, adjoin_set(20, adjoin_set(30, null))),\n   adjoin_set(10, adjoin_set(15, adjoin_set(20, null)))); "}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"Sets as binary trees","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    We can do better than the ordered-list representation by arranging the set\n    elements in the form of a tree.  Each node of the tree holds one element of\n    the set, called the \"","tag":"#text"},{"body":"entry","tag":"#text"},{"body":"\" at that node, and a link to each\n    of two other (possibly empty) nodes.  The \"","tag":"#text"},{"body":"left","tag":"#text"},{"body":"\" link points to\n    elements smaller than the one at the node, and the \"","tag":"#text"},{"body":"right","tag":"#text"},{"body":"\"\n    link to elements greater than the one at the node.\n    Figure ","tag":"#text"},{"tag":"REF","body":"2.16","href":"/sicpjs/2.3.3#fig-2.16"},{"body":" shows some trees that represent\n    the set ","tag":"#text"},{"body":"$\\{1,3,5,7,9,11\\}$","tag":"LATEX"},{"body":".  The same set may be\n    represented by a tree in a number of different ways.  The only thing we\n    require for a valid representation is that all elements in the left subtree\n    be smaller than the node entry and that all elements in the right subtree be\n    larger.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"40%","src":"img_original/ch2-Z-G-51.svg","id":"#fig-2.16","captionHref":"/sicpjs/2.3.3#fig-2.16","captionName":"Figure 2.16 ","captionBody":[{"body":"Various binary trees that represent the set\n      ","tag":"#text"},{"body":"$\\{ 1,3,5,7,9,11 \\}$","tag":"LATEX"},{"body":".","tag":"#text"}]}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    The advantage of the tree representation is this: Suppose we want to check\n    whether a number ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" is contained in a set.  We\n    begin by comparing ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" with the entry in the\n    top node.  If ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" is less than this, we know\n    that we need only search the left subtree; if ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":"\n    is greater, we need only search the right subtree.  Now, if the tree is\n    \"","tag":"#text"},{"body":"balanced,","tag":"#text"},{"body":"\" each of these subtrees will be about half the size\n    of the original.  Thus, in one step we have reduced the problem of\n    searching a tree of size ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" to searching a tree\n    of size ","tag":"#text"},{"body":"$n/2$","tag":"LATEX"},{"body":".  Since the size of the tree is\n    halved at each step, we should expect that the number of steps needed to\n    search a tree of size ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" grows as\n    ","tag":"#text"},{"body":"$\\Theta(\\log n)$","tag":"LATEX"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/2.3.3#footnote-2"},{"body":" For\n    large sets, this will be a significant speedup over the previous\n    representations.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    We can represent trees by using\n    \n    lists.  Each node will be a list of\n    three items: the entry at the node, the left subtree, and the right\n    subtree.  A left or a right subtree of the empty list will indicate\n    that there is no subtree connected there.  We can describe this\n    representation by the following\n    functions:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/2.3.3#footnote-3"},{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBTIsgJwE8AKZuugSlAG9QTOmQJNaACzoBDACYchPANygAvrkKlKNUABs6eMgH0ARkymlx8rrwFCRY0JNkcpFHVZ7dla-MXLVaJgoAc3EjU3MSS04efkFhUQlpOTJXd1S3D25s73U-LVoAWykAazpDGLYGZhYAGl19Mnqg0LIbUGxQLvj7Wh0KAGcyKsZWer0DZpCwr2wfatY2ToaDEzMLJe7BafD1qM2t0GKyioU2AEYABlrlw7vuogIdHRv7t6PS8sqMa9v3-62xy+ZxQ11Aj2e9QhOm4rwB8K60OyyMUQA","body":"function entry(tree) { return head(tree); }\n\nfunction left_branch(tree) { return head(tail(tree)); }\n\nfunction right_branch(tree) { return head(tail(tail(tree))); }\n\nfunction make_tree(entry, left, right) { \n    return list(entry, left, right);\n} "}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    Now we can write \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":"\n    using the strategy described above:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction is_element_of_set(x, set) {\n    return is_null(set) \n           ? false\n           : x === entry(set) \n           ? true\n           : x < entry(set)\n           ? is_element_of_set(x, left_branch(set))\n           : // $\\texttt{x > entry(set)}$\n             is_element_of_set(x, right_branch(set));\n}\n      "}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    Adjoining an item to a set is implemented similarly and also requires\n    ","tag":"#text"},{"body":"$\\Theta(\\log n)$","tag":"LATEX"},{"body":" steps.  To adjoin an item\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":", we compare\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" with the node entry to determine whether\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" should be added to the right or to the left\n    branch, and having adjoined\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" to the appropriate branch we piece this\n    newly constructed branch together with the original entry and the other\n    branch.  If ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" is equal to the entry, we just\n    return the node.  If we are asked to adjoin\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" to an empty tree, we generate a tree that\n    has ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" as the entry and empty right and left\n    branches.  Here is the\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction adjoin_set(x, set) {\n    return is_null(set)\n           ? make_tree(x, null, null)\n           : x === entry(set)\n           ? set\n           : x < entry(set)\n           ? make_tree(entry(set),\n                       adjoin_set(x, left_branch(set)),\n                       right_branch(set))\n           : // $\\texttt{x > entry(set)}$\n             make_tree(entry(set),\n                       left_branch(set),\n                       adjoin_set(x, right_branch(set)));\n}\n      "}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    The above claim that searching the tree can be performed in a logarithmic\n    number of steps rests on the assumption that the tree is\n    \"","tag":"#text"},{"body":"balanced,","tag":"#text"},{"body":"\" i.e., that the\n    left and the right subtree of every tree have approximately the same\n    number of elements, so that each subtree contains about half the\n    elements of its parent.  But how can we be certain that the trees we\n    construct will be balanced?  Even if we start with a balanced tree,\n    adding elements with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":"\n    may produce an unbalanced result.  Since the position of a newly adjoined\n    element depends on how the element compares with the items already in the\n    set, we can expect that if we add elements \"","tag":"#text"},{"body":"randomly","tag":"#text"},{"body":"\" the tree\n    will tend to be balanced on the average.  But this is not a guarantee.  For\n    example, if we start with an empty set and adjoin the numbers 1 through 7\n    in sequence we end up with the highly unbalanced tree shown in\n    figure ","tag":"#text"},{"tag":"REF","body":"2.17","href":"/sicpjs/2.3.3#fig-2.17"},{"body":".  In this tree all the left\n    subtrees are empty, so it has no advantage over a simple ordered list.  One\n    way to solve this problem is to define an operation that transforms an\n    arbitrary tree into a balanced tree with the same elements.  Then we can perform this transformation after every few\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_set"},{"body":"\n    operations to keep our set in balance.  There are also other ways to solve\n    this problem, most of which involve designing new data structures for which\n    searching and insertion both can be done in\n    ","tag":"#text"},{"body":"$\\Theta(\\log n)$","tag":"LATEX"},{"body":"\n    steps.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/2.3.3#footnote-4"},{"tag":"FIGURE","scale":"40%","src":"img_original/ch2-Z-G-52.svg","id":"#fig-2.17","captionHref":"/sicpjs/2.3.3#fig-2.17","captionName":"Figure 2.17 ","captionBody":[{"body":"\n\tUnbalanced tree produced by adjoining 1 through 7 in sequence.\n      ","tag":"#text"}]}]},{"tag":"EXERCISE","title":"Exercise 2.63","id":"#ex-2.63","child":[{"body":"\n    Each of the following two\n    functions\n    converts a\n    \n    binary tree to a list.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":true,"prependLength":11,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBTIsgJwE8AKZuugSlAG9QTOmQJNaACzoBDACYchPANygAvrkKlKNUABs6eMgH0ARkymlx8rrwFCRY0JNkcpFHVZ7dla-MXLVaJgoAc3EjU3MSS04efkFhUQlpOTJXd1S3D25s73U-LVoAWykAazpDGLYGZhYAGl19Mnqg0LIbUGxQLvj7Wh0KAGcyKsZWer0DZpCwr2wfDX9tGIqqQ36hwwBGLP5O7rtE0EHDIgIddIVuPe6broB+UFPz69vugC5QKQAHL4YUhRWa0GRm2E3CZgsWW4tRerzh3S+riYIxqWRh8Ix8OWZFW6xBbBaYRMEKiUJycyAA","body":"function tree_to_list_1(tree) {\n    return is_null(tree)\n           ? null\n           : append(tree_to_list_1(left_branch(tree)),\n                    pair(entry(tree),\n                         tree_to_list_1(right_branch(tree))));\n} "},{"tag":"SNIPPET","latex":false,"id":11,"eval":true,"prependLength":11,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBTIsgJwE8AKZuugSlAG9QTOmQJNaACzoBDACYchPANygAvrkKlKNUABs6eMgH0ARkymlx8rrwFCRY0JNkcpFHVZ7dla-MXLVaJgoAc3EjU3MSS04efkFhUQlpOTJXd1S3D25s73U-LVoAWykAazpDGLYGZhYAGl19Mnqg0LIbUGxQLvj7Wh0KAGcyKsZWer0DZpCwr2wfDX9tGIqqQ36hwxQs-k7uhYLQEioABxYVtcHhmOa6AYIdI3W2ne7XnsTQQcMie-SFbl2byBXQA-PE7g8LkNAcC3gAuQ4nM5kVZPNgTcJmCxZWow2H4-HHVxMEY1HF4gmU-FHU7nNEtMImLFRclUtns-FCCGPS7ZWavNSvOwfGnI1GXDz1H46HSzFRAA","body":"function tree_to_list_2(tree) {\n    function copy_to_list(tree, result_list) {\n        return is_null(tree)\n               ? result_list\n               : copy_to_list(left_branch(tree),\n                              pair(entry(tree),\n                                   copy_to_list(right_branch(tree),\n                                                result_list)));\n    }\n    return copy_to_list(tree, null);\n} "},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n        Do the two\n        functions\n        produce the same result for every tree? If not, how do the results\n\tdiffer?  What lists do the two\n\tfunctions\n        produce for the trees in figure ","tag":"#text"},{"tag":"REF","body":"2.16","href":"/sicpjs/2.3.3#fig-2.16"},{"body":"?\n        ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        Do the two\n        functions\n        have the same order of growth in the number of steps required to\n\tconvert a balanced tree with ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" elements\n\tto a list? If not, which one grows more slowly?\n      ","tag":"#text"}]}]}],"solution":[{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\t  The two procedures produce the same results. For the trees in\n\t  figure ","tag":"#text"},{"tag":"REF","body":"2.16","href":"/sicpjs/2.3.3#fig-2.16"},{"body":", the result will always\n\t  be ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(1, 3, 5, 7, 9, 11)"},{"body":".\n\t","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t  A balanced tree with ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" elements has a\n\t  height of ","tag":"#text"},{"body":"$O(\\log{n})$","tag":"LATEX"},{"body":" and\n\t  ","tag":"#text"},{"body":"$O(n)$","tag":"LATEX"},{"body":" nodes. To convert the tree into a\n\t  list using function\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tree_to_list_1"},{"body":", we call \n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tree_to_list_1"},{"body":"$O(n)$","tag":"LATEX"},{"body":" times. We call\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" at each node of the tree,  but at\n\t  each level, we apply ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":"\n\t  with a combined ","tag":"#text"},{"body":"$O(n)$","tag":"LATEX"},{"body":" elements in the\n\t  first arguments. Thus, the run time of\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tree_to_list_1"},{"body":" has an order of\n\t  growth of ","tag":"#text"},{"body":"$O(n\\log{n})$","tag":"LATEX"},{"body":". Instead of\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":", the function\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tree_to_list_2"},{"body":" gets away with\n\t  calling ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":" at each node, and\n\t  thus ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tree_to_list_2"},{"body":" has an order\n\t  of growth of ","tag":"#text"},{"body":"$O(n)$","tag":"LATEX"},{"body":".\n\t","tag":"#text"}]}]}]},{"tag":"EXERCISE","title":"Exercise 2.64","id":"#ex-2.64","child":[{"body":"\n    The following\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list_to_tree"},{"body":"\n    converts an ordered list to a balanced binary tree.  The helper\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"partial_tree"},{"body":"\n    takes as arguments an integer ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" and list of\n    at least ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" elements and constructs a balanced\n    tree containing the first ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" elements of the\n    list.  The result returned by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"partial_tree"},{"body":"\n    is a pair (formed with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":")\n    whose\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n    is the constructed tree and whose\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"tail"},{"body":"\n    is the list of elements not included in the tree.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":true,"prependLength":11,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBTIsgJwE8AKZuugSlAG9QTOmQJNaACzoBDACYchPANygAvrkKlKNUABs6eMgH0ARkymlx8rrwFCRY0JNkcpFHVZ7dla-MXLVaJgoAc3EjU3MSS04efkFhUQlpOTJXd1S3D25s73U-LVoAWykAazpDGLYGZhYAGl19Mnqg0LIbUGxQLvj7Wh0KAGcyKsZWer0DZpCwr2wfDX9tfqGKqgqFKr1C6oGbTu67RMdktgAHKSZKKR11rk26bcYB8YZgsks6LZ3s2bUFgtA50uFGutzomzIz1ARD23VAFDwoDYtAAvGjQAAGWFwg4JBznChMZEEHQ6eqfSGzOEqeg6AZ0fj7HGgEg0IYNAyGAYUABeDJRoGK70MeB0VCoRORoAAtKAAIy8MAoKnMllssgcoxCAYkjUCoFXG6VClQiZGbl8lXM1lEdlmsGgAVOOT27W6q04m3sog0Qz2k2O0AZdyuug6nRtRRMz3qwTTc28-nQmVI+0WhkAanlHrhXo170GhmqrEDzuRvv9Ed2UdVattGpaYUMbojgYNIKNG2D5aIfsaRar3CmrS5iZz3TzcZHMVLJ0bWrD7prqsnQmKFCIG+CA8hge78+bi4j466h3xriJxTKYI44kLxbqmrBw6bMSH0drtbXrk3RG3Jo9NQfGWIwyDWSoQLYOUMXqFAYNADAsS8IA","body":"function list_to_tree(elements) {\n    return head(partial_tree(elements, length(elements)));\n}\nfunction partial_tree(elts, n) {\n    if (n === 0) {\n        return pair(null, elts);\n    } else {\n        const left_size = math_floor((n - 1) / 2);\n        const left_result = partial_tree(elts, left_size);\n        const left_tree = head(left_result);\n        const non_left_elts = tail(left_result);\n        const right_size = n - (left_size + 1);\n        const this_entry = head(non_left_elts);\n        const right_result = partial_tree(tail(non_left_elts), right_size);\n        const right_tree = head(right_result);\n        const remaining_elts = tail(right_result);\n        return pair(make_tree(this_entry, left_tree, right_tree),\n                    remaining_elts);\n    }\n} "},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n        Write a short paragraph explaining as clearly as you can how\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"partial_tree"},{"body":"\n\tworks.  Draw the tree produced by\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list_to_tree"},{"body":"\n\tfor the list\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(1, 3, 5, 7, 9, 11)"},{"body":".\n\t  ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        What is the order of growth in the number of steps required by\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list_to_tree"},{"body":"\n\tto convert a list of ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" elements?\n      ","tag":"#text"}]}]}],"solution":[{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\t  The function\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"partial_tree(elts, n)"},{"body":"\n\t  returns a pair whose head is a balanced tree for the first\n\t  ","tag":"#text"},{"body":"$\\lfloor (n - 1) / 2 \\rfloor$","tag":"LATEX"},{"body":"\n\t  elements of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"elts"},{"body":", and whose\n\t  tail is the list containing the remaining elements of\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"elts"},{"body":". It works by calling itself\n\t  recursively, to construct the left subtree and right subtree, and\n\t  then makes the tree, and the required return pair. Thus, the overall\n\t  function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list_to_tree"},{"body":" just needs\n\t  to call ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"partial_tree"},{"body":" with the\n\t  given list and its length, and return the head of the result.\n\t  \n\t  The tree for\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(1, 3, 5, 7, 9, 11)"},{"body":"\n\t  is the tree on the right in\n\t  figure ","tag":"#text"},{"tag":"REF","body":"2.16","href":"/sicpjs/2.3.3#fig-2.16"},{"body":".\n\t","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\t  The order of growth for the run time of function\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list_to_tree"},{"body":" is\n\t  ","tag":"#text"},{"body":"$O(n)$","tag":"LATEX"},{"body":" because for every node of\n\t  the result tree, only a constant amount of work is needed.\n\t","tag":"#text"}]}]}]},{"tag":"EXERCISE","title":"Exercise 2.65","id":"#ex-2.65","child":[{"body":"\n    Use the results of exercises ","tag":"#text"},{"tag":"REF","body":"2.63","href":"/sicpjs/2.3.3#ex-2.63"},{"body":"\n    and ","tag":"#text"},{"tag":"REF","body":"2.64","href":"/sicpjs/2.3.3#ex-2.64"},{"body":" to give\n    ","tag":"#text"},{"body":"$\\Theta(n)$","tag":"LATEX"},{"body":" implementations of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"intersection_set"},{"body":"\n    for sets implemented as (balanced) binary trees.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/2.3.3#footnote-5"}],"solution":[{"tag":"SNIPPET","latex":false,"id":13,"eval":true,"prependLength":61,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjRjqiB9AZwFMyAKNsgRgBpQ3FAEpQAb2ygpoCnlAcKzRkQIAbVV3Y9hoidP2gATuwKHaQgNyTpAX1CtVbGXIVKV6zWRG7rBoybNBLSt9OwcnPQMSGmYyUAAPHlAAXlAAC1YAQwATT20QqJi4+JQU9KzcoWEC-WMyU1pElOTUkt8-fQB+UAAHTIpDDkSBehoWdg4yfo1ubT52jsWlvymKGfZvYQXFgC4EpIAeBNLtju6+gaH+OiIGcc5V9d5hASqt5ek9i8GSkdux7h5ASPTybGqgGzYSH4YjkBj2IhkQwAT0mxlYun89UCGRyaNYGIsENwhFIlBooFUrDwZEYACNDJlSGl8RjxFiGuU8SCkQSdEToaS4RTDBQAOZpWkMpkkFm8tliDk4iqTaaqtasnTVYkwsnwgC2mQA1qxGPKOKxESiBFSaQJRRKyJj2nVOapFJxLUjkTbqWR7eLJdUoSTYeTaO7YmaqGb0RaqfqvcwfLUArRcbk+oZKJlVLGCfHWInEcxfUQxWQWQ4i0mtVZIULw71MtmKLn86x42RS6AiCnpLJ5LQWqkAAz9vyuwLfDjuVQCBzd4OheyOVjiU6gaJEWKUv0sCgAL3XqUNlcYeFUVCog1noAAtKBtKAwCJwfpt7vbbTjMw1HFUizHM83NRce2-A9j2XDpPziCD5TKDMOAg39-2gvxYN7MYILAsoQRQ1g-1UJ132kTCHUlSCT17B95Ag5gj3XABqJ90MKHc4krRRGC9FFEJVIhsP3MC2I-IojEDH9CP-MogLbEC4xBQSmBw4jkwDR0qNEsjxIo2kENSJC9MYVDiO0qRyKLfpbnLHi1LwtVjNMkjNynWgZ0NE0O0mNJuN4n09xpDsNMo+UXk3D5-ENCgbLFOyl3BSFBTDeF5WjRhI1pFBNQ3fRG3haIemRdLMtZe1pOIjKPQnAw3JkNw1A0MKIr8bpnKq2IWoMPZCuKsgY1KiDpWZTV5ki8aDBnfzRq6ibll6kqPQ4YzhtlGa5o2zb2syut2khVNsVoBb+o6h50QEOdg2SvUKVGJhuEYTIlHNWZXg2GrMMypJUjSk7MsYbLZjYz6PVKH70UWqNAfe8E6v+k7zTu+5kI9a5Mu8etcF+gaPQBjgkYep7vNmxZ4Zjc1SuuDABAAVgEAB2HQxs2qQye80qUAEAAWAQADYBAADh0UBRGqIA","body":"function union_set_as_tree(set1, set2) {\n    const list1 = tree_to_list_2(set1);\n    const list2 = tree_to_list_2(set2);\n    return list_to_tree(union_set(list1, list2));\n} "},{"tag":"SNIPPET","latex":false,"id":14,"eval":true,"prependLength":59,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQKiyBTAJwGdHzqiB9dsgCj4BGADSg+KAJSgA3tlAK6eUPwqtuRAgBstgxmSHSAPkbrrNOvWSnS5i+6Gb6CzWha0BueYoC+oRlrsst4OoCQ0rGSgAB5CoAC8oAAWjACGACZWhl6hCuFEkTEoCclpmRKSOblOZC60sQnxidEoIbkOAPygAA6pFMz8sWL0TGwclDS8+vxkfbrCkmKzFPP6NpJt7YoAXDFxADxFoJtboF0jLOyck3wzc1mL4msbpw67IKAAJAA6TNFkAJkLVAh1iPk+2AAkFsLmNrjxbsIlvcKpU2j5sBj8MR4f4GMwAJ4zJyMWyOZyuUoZYmMUkeUBYwikCa0LSMPBkbgAI2YqVISRppNk5NqlJS1OWujIJMklQZuCZuOYFAA5klOTy+SQBdLaWSanUqZlJXcVoLZXLGTiWaAALapADWjG4usY-EY+IJYjZHLEyrVZDJbQNlK0agEHulXtAPrIftV6rRVuZXBj4ZdVBdJPdbNtkdYtmDFNo4syvWYlFSWiztJzjDzDFY3o9KrIAoC9fzFq8GMVNvLlerrpzZCboCIhfsFGU-FoTUSAAZJ9Viz0+gN3GIAqO0fY-AEgnZcvlCrHeBQAF6MEr2tvcPBaKhUAaz0AAWlAhlAYCkVVCJ6iM8nFYbQokSAcKCrGs3W3Mcz1YS86ROPIIkA9lOVdEpS34IDGBArRAz-BwAPHSYz1gkoTVw-DCOQsJUMcBNOQQq8SloD8cPQ89WIAak-XdjwYts1G4SNCSwspZzIrjYIE-8GP9dVuGA0CSggqDhxNIhpI5USCILeMA24pD2hIxSMJJCTqXM5S8NAuTiIU+s+iIegVT00dKPuGyVIIhz7BDWhen6fh7SdaCZiSESxOjM9XUMpTXUWOjXnJe16DcjyCyIjFk1xV0M24MNIm4FBzWCew+1TcJugJQrioEeLyRoorw2XUJArMDRtClGUUtCLpfM5Br+reejavq8NON0zV+XNERRtS3JgoGGL5sWpbThquqyEzBr+Bs2btXWzbTrOxQhtayJu3RItRVobbJsiQUxHcJMFWtVNYSuFkpk5VJ1GHJEnmsdr6IKQDwyEeICt2q7OTKhYiJIhqUBhkknoRqxfzuw0GsK4dvvGLg-pwqHvXDGwe1wWG9vTMqifhP7uABiKNtCfG4eHfbRFADAxAAVjEAAOWUFvOhROczbmppQMR+dAAA2EXZVAaRKiAA","body":"function intersection_set_as_tree(set1, set2) {\n    const list1=tree_to_list_2(set1);\n    const list2=tree_to_list_2(set2);\n    return list_to_tree(intersection_set(list1, list2));\n} "}]},{"tag":"SUBHEADING","id":"#h4","child":[{"body":"Sets and information retrieval","tag":"#text"}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n    We have examined options for using lists to represent sets and have\n    seen how the choice of representation for a data object can have a\n    large impact on the performance of the programs that use the data.\n    Another reason for concentrating on sets is that the techniques\n    discussed here appear again and again in applications involving\n    information retrieval.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p15","child":[{"body":"\n    Consider a data base containing a large number of individual records,\n    \n    such as the personnel files for a company or the transactions in an\n    accounting system.  A typical data-management system spends a large\n    amount of time accessing or modifying the data in the records and\n    therefore requires an efficient method for accessing records.  This is\n    done by identifying a part of each record to serve as an identifying\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"key","tag":"#text"}]},{"body":".  A key can be anything that uniquely identifies the\n    record.  For a personnel file, it might be an employee's ID number.\n    For an accounting system, it might be a transaction number.  Whatever\n    the key is, when we define the record as a data structure we should\n    include a\n     ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"key"},{"body":" selector\n    function\n    that retrieves the key associated with a given record.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p16","child":[{"body":"\n    Now we represent the data base as a set of records. To locate the record\n    with a given key we use a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":", which takes as arguments a key and a\n    data base and which returns the record that has that key, or false if there\n    is no such record.\n    The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":"\n    is implemented in almost the same way as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set"},{"body":".\n      \n    For example, if the set of records is implemented as an unordered list, we\n    could use\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":15,"eval":true,"prependLength":11,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBbAQwGsBTAfQCcWSqOATABSsAngBpQfBmQYBKUAG8AkKFDYVKrmQIdaABwYUOQlmIlTZAbmwBffMXLVaIgVx78589aq+bttABYsDIKuvHwyVraEpJQ0ZtIu3GEeauq+OqDSFAA2iW7hkbjRDnHZVFRMBLoCAOYUAG4sRGwi4gDOLGRsVHicSfxtKT6dfqAUbWxEBNm5HV09ffmDqV6rAPygeAzZHSur6gBcoCwAjgTbtQ1NLSbizoHBAnPdvaEDMh97+6AbD4LPCzefGW3y8RzKFSql0azVamQMs06L0WYUGERsuAhlWqGHE2XGZAEjFYKP4AhQ4gARAA1JoENqUmTiL6glTE9hAgQAVipCCqFDILA4jNELNZ7NJggALFSALIMDgMpli0ESzm40CUgCiCrI-hFKu+av6ggAbFTwFI-IyPhYgA","body":"function lookup(given_key, set_of_records) {\n    return is_null(set_of_records)\n           ? false\n           : equal(given_key, key(head(set_of_records)))\n           ? head(set_of_records)\n           : lookup(given_key, tail(set_of_records));\n} "}]},{"tag":"TEXT","id":"#p17","child":[{"body":"\n    Of course, there are better ways to represent large sets than as unordered\n    lists.  Information-retrieval systems in which records have to be\n    \"","tag":"#text"},{"body":"randomly accessed","tag":"#text"},{"body":"\" are typically implemented by a tree-based\n    method, such as the binary-tree representation discussed previously.\n    In designing such a system the methodology of data abstraction\n    can be a great help.  The designer can create an initial implementation\n    using a simple, straightforward representation such as unordered lists.\n    This will be unsuitable for the eventual system, but it can be useful in\n    providing a \"","tag":"#text"},{"body":"quick and dirty","tag":"#text"},{"body":"\" data base with which to test the\n    rest of the system.  Later on, the data representation can be modified to\n    be more sophisticated.  If the data base is accessed in terms of abstract\n    selectors and constructors, this change in representation will not require\n    any changes to the rest of the system.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.66","id":"#ex-2.66","child":[{"body":"\n    Implement the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"lookup"},{"body":"function\n    for the case where the set of records is structured as a binary tree,\n    ordered by the numerical values of the keys.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":16,"eval":true,"prependLength":21,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHQGZMChsDMBXAOwGMAXASwHsjQBTIsgJwE8AKZuugSlAG9QTOmQJNaACzoBDACYchPANygAvrkKlKNUABs6eMgH0ARkymlx8rrwFCRY0JNkcpFHVZ7dla-MXLVaJgoAc3EjU3MSS04efkFhUQlpOTJXd1S3D25s73U-LVoAWykAazpDGLYGZhYAGl19Mnqg0LIbUGxQLvj7Wh0KAGcyKsZWer0DZpCwr2wfDX9tYrLDIRIqJjkyutAZKVSbAEguzu67RNAAB1cmNm36vYPFOd9NANBttjWNmXbu0665wcTjk302szUCwKu32Ui+dHW4P4AJ6Fwy7jBv2e83y7x0VCoJQIlzYwQoADcGIZ7qAYoYqHhVgifgMbCiKHhQGxBoYiAQdOkFPTGZjWWzuhLUQ4+QLnhKVPQdAM6MjJd11kQhrTxDzqqxQABeeijdh0hlMxEyVlytWgDVasg6gbUugsQ0fV0cJ2GPUsWa2qW0MmUogut0GiPannbDoB20Afijzt9KLjXQAXKBg1SYwAeJNh1NpxP4wnE0kUnOu+pFtMBibhMwWDzCi0s7K1gOZ0tEknZ0M0zt1yUtMImJtRFvm0U5FFqHz2sigQosQx4KTkwyXHTmYQDQ0o5blSpHtubNgAFnqACIALJSJgDa-cWqHIeS08n0rlTFsFA3gA1BgCCfF9Y2HOsZR0Wp3wg5dvwqBQ2FPX8MBvABRB9HWfGC4LwyUoPqKDslwiDPyQlDmXPAA2G9wH2RIcNgsiEK-FZfwAVhvBBiQoMg6CYJj8OE0BCNE-kdBfZjh2I2ZsB7cs0OXVd103bddzIa0gA","body":"function lookup(given_key, tree_of_records) {\n    if (is_null(tree_of_records)) {\n        return null;\n    } else {\n        const this_entry = entry(tree_of_records);\n        const this_key = key(this_entry);\n        return given_key === this_key \n               ? this_entry\n               : given_key < this_key\n               ? lookup(given_key, \n                        left_branch(tree_of_records))\n               : lookup(given_key, \n                        right_branch(tree_of_records));\n    }\n} "}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/2.3.3#footnote-link-1","child":[{"body":"If we want to be more formal, we can specify\n    \"","tag":"#text"},{"body":"consistent with the interpretations given above","tag":"#text"},{"body":"\" to mean\n    that the operations satisfy a collection of rules such as these:\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tFor any set ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"S"},{"body":" and any object\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":",\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set(x, adjoin_set(x, S))"},{"body":"\n\tis true (informally: \"","tag":"#text"},{"body":"Adjoining an object to a set produces a\n\tset that contains the object","tag":"#text"},{"body":"\").\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        For any sets ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"S"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"T"},{"body":" and any object\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":",\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set(x, union_set(S, T))"},{"body":"\n        is equal to\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set(x, S) || is_element_of_set(x, T) \t    "},{"body":"\n        (informally: \"","tag":"#text"},{"body":"The elements of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"union_set(S, T)"},{"body":"\n\tare the elements that are in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"S"},{"body":" or in\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"T"},{"body":"\").\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        For any object ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":",\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_element_of_set(x, null)"},{"body":"\n        is false (informally:\n\t\"","tag":"#text"},{"body":"No object is an element of the empty set","tag":"#text"},{"body":"\").\n      ","tag":"#text"}]}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/2.3.3#footnote-link-2","child":[{"body":"Halving the size of\n    the problem at each step is the distinguishing characteristic of\n    \n    logarithmic growth, as we saw with the fast-exponentiation algorithm of\n    section ","tag":"#text"},{"tag":"REF","body":"1.2.4","href":"/sicpjs/1.2.4"},{"body":" and the half-interval\n    search method of\n    section ","tag":"#text"},{"tag":"REF","body":"1.3.3","href":"/sicpjs/1.3.3"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/2.3.3#footnote-link-3","child":[{"body":"We\n    are representing sets in terms of trees, and trees in terms of\n    lists—in effect, a data abstraction built upon a data abstraction.\n    We can regard the\n    functions","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"entry"},{"body":",\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"left_branch"},{"body":",","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"right_branch"},{"body":",\n      \n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_tree"},{"body":"\n    as a way of isolating the abstraction of a \"","tag":"#text"},{"body":"binary tree","tag":"#text"},{"body":"\" from\n    the particular way we might wish to represent such a tree in terms of list\n    structure.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/2.3.3#footnote-link-4","child":[{"body":"Examples of such structures include\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"B-trees","tag":"#text"}]},{"body":" and ","tag":"#text"},{"tag":"EM","child":[{"body":"red-black trees","tag":"#text"}]},{"body":".  There is a large literature\n    on data structures devoted to this problem.  See \n    Cormen, Leiserson, Rivest, and Stein 2022.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/2.3.3#footnote-link-5","child":[{"body":"\n    Exercises ","tag":"#text"},{"tag":"REF","body":"2.63","href":"/sicpjs/2.3.3#ex-2.63"},{"body":"–","tag":"#text"},{"tag":"REF","body":"2.65","href":"/sicpjs/2.3.3#ex-2.65"},{"body":"\n    are due to\n    \n    Paul Hilfinger.","tag":"#text"}]}]