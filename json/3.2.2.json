[{"id":"/sicpjs/3.2.2","tag":"TITLE","body":"3.2.2  \n    Applying Simple\n    \n      \n      Functions"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    When we introduced the substitution model in\n    section ","tag":"#text"},{"tag":"REF","body":"1.1.5","href":"/sicpjs/1.1.5"},{"body":" we showed how the\n    application\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f(5)"},{"body":"\n    evaluates to 136, given the following\n    function declarations:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQCZMChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF98xctVp0CAWwD6VPPsYsOdHgBpQAT35DRY9hKn0mbLn1ABqN2a52ymqEpJQ0oHiczPbCouKS2nqGxqYeFsw+oACM1hnyGLxBuJEArIVAA","body":"function square(x) {\n    return x * x;\n}\nfunction sum_of_squares(x, y) {\n    return square(x) + square(y);\n}\nfunction f(a) {\n    return sum_of_squares(a + 1, a * 2);\n} "},{"body":"\n    We can analyze the same example using the environment model.\n    Figure ","tag":"#text"},{"tag":"REF","body":"3.4","href":"/sicpjs/3.2.2#fig-3.4"},{"body":" shows the three\n    function\n    objects created by evaluating the definitions of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":", ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":", and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_of_squares"},{"body":"\n    in the\n    program\n    environment.  Each\n    function\n    object consists of some code, together with a pointer to the\n    program\n    environment.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ch3-Z-G-5.svg","id":"#fig-3.4","captionHref":"/sicpjs/3.2.2#fig-3.4","captionName":"Figure 3.4 ","captionBody":[{"body":"Function objects in the program frame.","tag":"#text"}]}]},{"tag":"TEXT","id":"#p2","child":[{"tag":"FIGURE","scale":"70%","src":"img_javascript/ch3-Z-G-6.svg","id":"#fig-3.5","captionHref":"/sicpjs/3.2.2#fig-3.5","captionName":"Figure 3.5 ","captionBody":[{"body":"\n\t    Environments created by evaluating\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f(5)"},{"body":" using the functions in\n\t    figure ","tag":"#text"},{"tag":"REF","body":"3.4","href":"/sicpjs/3.2.2#fig-3.4"},{"body":".\n\t  ","tag":"#text"}]},{"body":"\n\n    In\n    figure ","tag":"#text"},{"tag":"REF","body":"3.5","href":"/sicpjs/3.2.2#fig-3.5"},{"body":"\n    we see the environment structure created by evaluating the expression\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f(5)"},{"body":".\n    The call to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":" creates a new environment, E1,\n    beginning with a frame in which ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a"},{"body":", the\n     parameter of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":", is bound to the argument 5.  In E1, we\n    evaluate the body of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":false,"body":"return sum_of_squares(a + 1, a * 2);"},{"body":"To evaluate\n    \n\tthe return statement, we first evaluate the\n\tsubexpressions of the return expression.\n      \n    The first subexpression,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_of_squares"},{"body":",\n      \n    has a value that is a\n    function\n    object.  (Notice how this value is found: We first look in the first frame\n    of E1, which contains no binding for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_of_squares"},{"body":".\n      \n    Then we proceed to the enclosing environment, i.e., the\n    program\n    environment, and find the binding shown in\n    \n\tfigure ","tag":"#text"},{"tag":"REF","body":"3.4","href":"/sicpjs/3.2.2#fig-3.4"},{"body":".)\n      \n    The other two subexpressions are evaluated by applying the primitive\n    operations ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"+"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"*"},{"body":"\n    to evaluate the two combinations\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a + 1"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"a * 2"},{"body":"\n    to obtain 6 and 10, respectively.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    Now we apply the\n    function\n    object\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_of_squares"},{"body":"\n    to the arguments 6 and 10.  This results in a new environment, E2, in which\n    the  parameters\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":" are bound\n    to the arguments. Within E2 we evaluate \n    \n\tthe statement\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"return square(x) + square(y);"},{"body":"\n    This leads us to evaluate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square(x)"},{"body":",\n    where ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" is found in the\n    program\n    frame and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" is 6.  Once again, we set up a\n    new environment, E3, in which ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" is bound to 6,\n    and within this we evaluate the body of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":",\n    which is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return x * x;"},{"body":".\n    Also as part of applying\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_of_squares"},{"body":",\n      \n    we must evaluate the subexpression\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square(y)"},{"body":",\n    where ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"y"},{"body":" is 10.  This second call to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" creates another environment, E4, in\n    which ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":", the\n     parameter of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":", is bound to 10.  And within E4 we must\n    evaluate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"return x * x;"},{"body":".","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    The important point to observe is that each call to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" creates a new environment containing a\n    binding for ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":".  We can see here how the\n    different frames serve to keep separate the different local variables all\n    named ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":".  Notice that each frame created by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" points to the\n    program\n    environment, since this is the environment indicated by the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":"function\n    object.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    After the subexpressions are evaluated, the results are returned.  The\n    values generated by the two calls to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":" are\n    added by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_of_squares"},{"body":",\n      \n    and this result is returned by ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":".\n    Since our focus here is on the environment structures, we will not\n    dwell on how these returned values are passed from call to call;\n    however, this is also an important aspect of the evaluation process,\n    and we will return to it in detail in chapter ","tag":"#text"},{"tag":"REF","body":"5","href":"/sicpjs/5"},{"body":".\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.9","id":"#ex-3.9","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"1.2.1","href":"/sicpjs/1.2.1"},{"body":"\n    we used the substitution model to analyze two\n    functions\n    for computing\n    \n    factorials, a recursive version\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQCZMChsDMBXAOwGMAXASwHsjQ8BDcqgJwvoBsAKIgSlAG9soYaGYBTMgWa1aAXnmgAjEJGqRAfiUq1qgFyhaAKjqMyLNl1oBaJTwDc2AL64GTVh04BWe0A","body":"function factorial(n) {\n    return n === 1\n           ? 1\n           : n * factorial(n - 1);\n} "},{"body":"\n    and an iterative version\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":0,"program":"chap=3&prgrm=PTAEGUEkGEAVQFLlAZgHQCZMChsDMBXAOwGMAXASwHsjQ8BDcqgJwvoBsAKIgSlAG9soYaGYBTMgWa0G5APoUyY5pwCMAGlAbQvANzYAvvmLlqMxmQVKVAB2ZUAJgXKaSVYtc0BbegA85bh58giKiElK0gUTWoAB8oD7+UWRCoWmgAPygdo7OKelpAFx0FlbKnMnKoABU2fZOLqCpBS3plcygANRams2t-Ql+Ae7RPPpG+BYsbFwArGNAA","body":"function factorial(n) {\n    return fact_iter(1, 1, n);\n}\nfunction fact_iter(product, counter, max_count) {\n    return counter > max_count\n           ? product\n           : fact_iter(counter * product, \n                       counter + 1, \n                       max_count);\n} "},{"body":"\n    Show the environment structures created by evaluating\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial(6)"},{"body":"\n    using each version of the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":"function.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/3.2.2#footnote-1"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/3.2.2#footnote-link-1","child":[{"body":"\n    The environment model will not clarify our claim in\n    section ","tag":"#text"},{"tag":"REF","body":"1.2.1","href":"/sicpjs/1.2.1"},{"body":" that the\n    interpreter can execute a\n    function\n    such as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fact_iter"},{"body":"\n    in a constant amount of space using tail recursion.  We will discuss\n    \n    tail recursion when we\n    deal with the control structure of the interpreter in\n    section ","tag":"#text"},{"tag":"REF","body":"5.4","href":"/sicpjs/5.4"},{"body":".","tag":"#text"}]}]