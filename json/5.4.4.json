[{"id":"/sicpjs/5.4.4","tag":"TITLE","body":"5.4.4  \n    Running the Evaluator"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    With the implementation of the explicit-control evaluator we come to\n    the end of a development, begun in chapter ","tag":"#text"},{"tag":"REF","body":"1","href":"/sicpjs/1"},{"body":", in which we have\n    explored successively more precise\n    \n    models of the evaluation process.\n    We started with the relatively informal substitution model, then\n    extended this in chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":" to the environment model, which enabled us\n    to deal with state and change.  In the metacircular evaluator of\n    chapter ","tag":"#text"},{"tag":"REF","body":"4","href":"/sicpjs/4"},{"body":", we used\n    JavaScript\n    itself as a language for making more\n    explicit the environment structure constructed during evaluation of an\n    component.\n    Now, with register machines, we have taken a close look\n    at the evaluator's mechanisms for storage management,\n    argument passing, and control.  At\n    each new level of description, we have had to raise issues and resolve\n    ambiguities that were not apparent at the previous, less precise\n    treatment of evaluation.  To understand the behavior of the\n    explicit-control evaluator, we can simulate it and monitor its\n    performance.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    We will install a\n    \n    driver loop in our evaluator machine.  This plays\n    the role of the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"driver_loop"},{"body":"function\n    of section ","tag":"#text"},{"tag":"REF","body":"4.1.4","href":"/sicpjs/4.1.4"},{"body":". The evaluator\n    will repeatedly print a prompt, read \n    a program,\n    evaluate\n    the program\n    by going to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"eval_dispatch"},{"body":",\n      \n    and print the result.\n    \n        If nothing is entered at the prompt, we jump to the label\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluator_done"},{"body":", which is\n        the last entry point in the controller. \n      \n    The following instructions form the beginning of the\n    explicit-control evaluator's controller sequence:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/5.4.4#footnote-1"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n\"read_evaluate_print_loop\",\n  perform(list(op(\"initialize_stack\"))),\n  assign(\"comp\", list(op(\"user_read\"),\n                      constant(\"EC-evaluate input:\"))),\n  assign(\"comp\", list(op(\"parse\"), reg(\"comp\"))),\n  test(list(op(\"is_null\"), reg(\"comp\"))),\n  branch(label(\"evaluator_done\")),\n  assign(\"env\", list(op(\"get_current_environment\"))),\n  assign(\"val\", list(op(\"scan_out_declarations\"), reg(\"comp\"))),\n  save(\"comp\"),    // so we can use it to temporarily hold $\\texttt{*unassigned*}$ values\n  assign(\"comp\", list(op(\"list_of_unassigned\"), reg(\"val\"))),\n  assign(\"env\", list(op(\"extend_environment\"), \n                     reg(\"val\"), reg(\"comp\"), reg(\"env\"))),\n  perform(list(op(\"set_current_environment\"), reg(\"env\"))),\n  restore(\"comp\"), // the program \n  assign(\"continue\", label(\"print_result\")),\n  go_to(label(\"eval_dispatch\")),\n\"print_result\",\n  perform(list(op(\"user_print\"),\n               constant(\"EC-evaluate value:\"), reg(\"val\"))),\n  go_to(label(\"read_evaluate_print_loop\")), \n  "},{"body":"\n        We store the current environment, initially the global environment,\n        in the variable ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"current_environment"},{"body":"\n        and update it each time around the loop to remember past declarations.\n        The operations\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"get_current_environment"},{"body":" and\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"set_current_environment"},{"body":" \n\tsimply get and set this variable.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":false,"body":"let current_environment = the_global_environment;\n\nfunction get_current_environment() {\n    return current_environment;\n}\n\nfunction set_current_environment(env) {\n    current_environment = env;\n}"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    When we encounter an\n    \n    error in a\n    function\n    (such as the \n    \"","tag":"#text"},{"body":"unknown function type","tag":"#text"},{"body":"\" error\n    indicated at\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply_dispatch"},{"body":"),\n      \n    we print an error message and return to the driver loop.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/5.4.4#footnote-2"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n\"unknown_component_type\",\n  assign(\"val\", constant(\"unknown syntax\")),\n  go_to(label(\"signal_error\")),\n      \n\"unknown_function_type\",\n  restore(\"continue\"), // clean up stack (from $\\texttt{apply\\_dispatch}$)\n  assign(\"val\", constant(\"unknown function type\")),\n  go_to(label(\"signal_error\")),\n      \n\"signal_error\",\n  perform(list(op(\"user_print\"),\n               constant(\"EC-evaluator error:\"), reg(\"val\"))),\n  go_to(label(\"read_evaluate_print_loop\")),\n      "}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    For the purposes of the simulation, we initialize the stack each time\n    through the driver loop, since it might not be empty after an error\n    \n\t(such as an undeclared name)\n      \n    interrupts an evaluation.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/5.4.4#footnote-3"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    If we combine all the code fragments presented in sections\n    ","tag":"#text"},{"tag":"REF","body":"5.4.1","href":"/sicpjs/5.4.1"},{"body":"–","tag":"#text"},{"tag":"REF","body":"5.4.4","href":"/sicpjs/5.4.4"},{"body":",\n    we can create an\n    \n    evaluator machine model that we can run using the\n    register-machine simulator of section ","tag":"#text"},{"tag":"REF","body":"5.2","href":"/sicpjs/5.2"},{"body":".\n\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nconst eceval = make_machine(list(\"comp\", \"env\", \"val\", \"fun\",\n                                 \"argl\", \"continue\", \"unev\"),\n                            eceval_operations,\n                            list(\"read_evaluate_print_loop\",\n                                 $\\langle{}$entire machine controller as given above$\\rangle$\n                                 \"evaluator_done\"));\n      "},{"body":"\n\n    We must define \n    JavaScript functions\n    to simulate the operations used as primitives by the evaluator.  These are\n    the same\n    functions\n    we used for the metacircular evaluator in\n    section ","tag":"#text"},{"tag":"REF","body":"4.1","href":"/sicpjs/4.1"},{"body":", together with the few additional\n    ones defined in footnotes throughout section ","tag":"#text"},{"tag":"REF","body":"5.4","href":"/sicpjs/5.4"},{"body":".\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nconst eceval_operations = list(list(\"is_literal\", is_literal),\n                               $\\langle\\mathit{complete}\\;\\,\\mathit{list}\\;\\,\\mathit{of}\\;\\mathit{operations}\\:\\,\\mathit{for}\\;\\,\\mathit{eceval}\\;\\,\\mathit{machine}\\rangle$);\n      "}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    Finally, we can initialize the global environment and run the evaluator:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":1361,"program":"chap=4&prgrm=PTAEGUEkGEAVQFLlAVgHQBZMChslAGYCuAdgMYAuAlgPYkDOhATjQLYQzxKhYCMavXMXLU6oAKYA3AIYAbItIriAFGTYAHOuJIUANBJKSAlKADe2UJdBNxFIkxKgq9APqyqSpnNUatOoxZWQVYA-KDunnIuMvIqaqyaJNoUAcFpAFxOriTSrHG+Sf6BaaHhNDQA1kTqLvQAnqwARjSy0XJEKvVNLS40BC45eT4Jfin62sbFJaCZzi7S6uruZIq0JMOJyanTlmELS3XKUu2KKsKUay7iAB7qNvT0axujRuOGr1M7ae70FL39MQ69GU0iYAHMrrd7o86MD4pt-G9jNsdrNXDR1OIvBQaEwXPFGlQcqJ1vCXp80mFjvJTsoMVjFLj8WxCcTLjj5otlqs6M9CmMKV80hMUdM0cySAATDxrbxk-mikpUmIS6UkuUFZJIxUZLJuXKNSXSSF3cQPJ7yraCoJhVjSCriFznEnKWQGo0udSg3K2LG1BrNWRwzWI61C6Zupoe5qSw6WxEGSZC8X0cQARw65HyIwVYd2EhVqYz2jInXTmdLtQopzyOmDOa22rzMz1jVkNDIFT5VqFyqibY7XfjekTOuC4psdgcVZryW7RV7Baik-sJBnSlrFHnI5FzfFzsukvEZDd2ItIZSzb7NKUygPdBcR5PLg5agY1Z0j+Psm3r1He71J9Tx5UkLzHG0l1aIDvRdYcm2TPVpHNMESE3X8r0g+ZkNQuc4P-BCsRYJht30AAiUgKhIGgAHdHHqHRpGuUAAFpmMghQlFIowAG5sAAXyEUgLjEfZZEOYR9FBMF6BMcwgioAhQGUOY7ioVgZUkR173WYQjFk60VwcUBRLqT0mDUjStKEl0JOM8EZN4oI+IkINxCcRTlNcMlSElJ1rKeXT9OmN9fmsM0iFkChQAAXnY2ltJcGNxNID5wzSkobiUKUrkMKgWBwnRlGbdKhQSr0vDyTxgV03RipKnYpPoWr6paqwEomPK6DQwKeIM2xVz1Qy10BFR7giy8SrCIa2liCUsq3MbIvAkpMh88QCCJcRJUcqxnPEVyzGtQjcTvUgyIoqjaMIfyxAoOpMRYtiTK4nbLAEgTsG08JnD+PoZqBI5bia0dDqCIbQDtdQQXBGKAD44tvKTtXGIHeo+r7qVVGU6A1BsdG1UGrHBuYKCYIgKAAC0OakOPyKVsZyVpTWlFZb2HP8RWW-MadpN81VlVoQvLXCwPgr5Mh5tm6H5nHWjkTw2U039tV49GbscTGiwrToKFYChgZFQnLAUpS5nEBI7tqYWs2UX49ZkoKSnBtaNqSbapj2g6Tc8-VfnXc25zt-W9KN4Jwcls48r935Z0KoOZJVj2XNTUOghCqKNqYaPdb+EaYtAYqI7vKO-hjjdA5zhPR1e4JvbmaaRuLrPS5z-7xBDuShXBzPs71tua6c5O3M7r5w8La3S2Ue4W9j-Xbcrjn3gH3aPf4wSRDWUB6BWNcaHJr8TxgtZ6wRFJQ+J1wtZLbNT650A9jIMgiFYCLaX2bRJWa1rghICLZC-7+VhIa2x3r0fe0EzywgAYA4IV8sz+03CfF4ekAJzAgSBdCi4fhbnQSSf03QfzszvpkX+shZCq3XsJDWKoBydhIiDEeoB06gCSvnWhFREo0FjL+GuzD2wrCDPnbe0hd7gO-EfWEygkq9TTrCKKpAkKPBQltRgsVsH-BcAo7CW1XQdjkA5KYY8Ti3iSijLKvkOr5TQvw-R0CYGAK0Uot2wM6r2K+JzChX11F-UcVQZRkpbYBhaDJc+-UjLAK6IGOGoBSIACpfH+NiaRfQkTglo0oSSTC00y4B0KnhQ2jDwZ2gdC4Bu7QVBF2mjcU05peTszsW49x7x0mfXVphRRfiCpbnye8UOzC86xSLh0lCm424mmhOePGApGlWBFDXYZa5UmtEbgs0ZSzlagBGonMGYTHAjQoa0jeYhMa4MmafAmjCFn4MDG3Iq0xTkPnWfUgu0wi4POGuU8ZZoYSgSmYvYwDTLBzMMbs0ALtNruw+vgbSjACAsHYFAOAiBkB8DQAAJgyZvEm0gwRgi2m4H69DKaOmrGCR2lgL6emkHlX8oAABkdLQAU3ENIAJ7MYrRVisSl8OKDlfTmBEBkhCwKhKnI4bFuL8XYPoaRQVXhZAvTXl4jwQrbnstMEEEFYqmUsoCdWKgwq-ktK+sUx0crvAjXJWFbV0rZUqvlckzZ5TjVtLmIMG+LxRUDQlXi3y0q8KkXdYqtWRzHCmoGD6QJBCrXg1tUGlJQTZAutDVvRNGj3W0sKaC5lrLlD6sNbfZNVDELYTQuqrV3rXCkt9QS34MrVnJGDYc4tDbPxPJFVm7VOa9XUp-N2vNvbfx6XSV9VtudPnVImXUjtFajL9vzQOg1Q6i2ZLQeIyBvzb5eqMj6qVhKA3pxEX8d5XFQAAB8z3Nl3X6-dF4yIyHMtINsjoT0mAvVeqtOKa3+rvTEhKr6+VtPedclombZ10TTX9DN87B1EJHUB9dIExmTu+Wcz1naBowaXQuuDgGU3hsPZ+d5yh3X6BGl82pJAY2gttYR49iGSSOtI062aKHKMrqxa4SMhpjRsZ+WBnZ2rr21u6b+2V7peNQlQ3QJtXiJNUoqr6PESykEKm3WGhYUablQZ9PoLDBbkHwZTdx6MXC4wzsE5h3Vi6fw4bAnpPDxbw0mckzU-j5UfRVX0NI9T3063iajK5qdJBHUecqliYG0jHOrtcP+hjaG1OmAAJCasszuz9kqb11oDXFw+G7ZNtNy8BPBGby1pccOomwBB6G8CM8WorEi1xhaU6prYvnKvrXoWiurmSGsbs4dwsrRMaM-VKZ1vCABmHrm8isvhoBKGORHvwCeG9qgjcij0H2K08Vx11Q1bcaxGoY9TdvOfk3xnb38+tIea1VZWu2gjXbwUlZd0XONjbFQgkWfyjaUurXu7LYnsnVnLjoArKaqlScoyt61Vnc12aNW9sQcw+YM1xlujD6WeWZZEzK1H6pWgXZk2+y9QphM-qmWRfHAsvtg+m2IansszJbSoKzD1iXiixtG1Vmr9PHCM8Zgt62omfsjy537HneFuueLaQLqI8ssSK3Z21sXI2Jfjd-VNpH4rL4Tx1nrclf2v0A63EHMicDSzg+LRbx0OTEHzwN2YKwnPs3WYXUHBzSrCsl1p6bhev3Xe5vjnzsK2dZ7AmDwH7V7uF4y5TWbC2pkbcO+DlHytAw-4p4MQJflXGkIz1B37+2hvQVuszzH4vHHkeuHYTD2HWP-tZZF+cmJ7CreZPYQN8zovwM6vh7B+zcenP2kdLXu3Kve+2rbykkHuSUja71PSbETICREgweqlLzvyt6gUUwUyS-GR4lX2yadP331k5r2vvfvRMTL6PyyNfsEwJD5i5onI1+D84nv00R-CWVeb8sF73J1vUpxiV3331v0P2ZB-xPxCxDzmFZFBAgIZC-2gMQKf1FwAJeVW3T0b1xwDUQI-0gNQOPxAnb03k-yZHbR723w62qzwlqxfxmx9wPylDr3Fz+El1-Wly9xTVTD5hvwZDYKGwpTV04I11AK1zXmbUyXDVElZwwXaihx+UknBGfmSAox+RCUxwq0JVInkNZjWGSQeyULczWFULBHUM-CJwYCr0cEoO-3QPZHmwMPXwsysGYQcPzgcJAwMwVBrkpXAMELvzQN-1P1vgwjkK5AUJdHDQzQcNShmSCGlR7l+kgOEPs2IQhhH05CWBiKeDiMjQSMBTcRSJYPSLZVFge2-n4OlmCJEUqKNTsMQmiMMPCPQxdyEwy2-RAJb30NaLIJD1MOCxh3Bn0yHSYJEnBE0OPlGMDx7WwwHyaIOWhXVlhXhQ4CRW4FRQm0xWrxfDJkpkOGuGoy6M4RaBZXWBOOwJ2DCGuAAmOmImuDImaAuJEQkFuGPCUE-jClLCoE0klHIP2IIH0WONknr0cAAEI9RSZyYqZlATjuJQAQ1h8SltJlBbsItvMzMLlJ89DvJsptJQtvRwss5sTYxE4c9XUvJfAfI-JQ07xTjcDjcm87wqdaTCT1YgTHAyoSSWtGSncOCxtqsCB9BGDkS9ieT1Yu8BSNUhSedRTQBpcJSZCZtpTLEuo5wCBwT5TOtFStcVSTUciylYgfAdAJ9aC9CTSOhHU3x5p4DXBrSVBLVfNgC60tkYknTuSISxk7S5wXSdC+8FifxLVmiSx2xHgSAIQNSukjhek5TQUF05lDTvdm4nRFM4zjBBT5jMyeIVTmFuVzZ1BLYYzNx85SFyFJTsi0SMyVMyNyltCITQAvQaU6yWMgQ8yUTetFNfDqpFMdScy4UfROyqyhy8g24+zhzszo9B0xz24kSuzN5MoP4cpJBOpYy2yYhIskJHQClJ9tAwRKYtM0kOU1EDyjyty74wgWziJw05zjygx6ygw-xGgdzVysjZBzyKYHyQkAAecIL85QS8jCR45QUiHEGgbIkgOoOySwxBLeaoPIraTIUiUAAAahuPql+HMijIUkOBUxMAwsdVQowuqMsGwqJDBDwqAv0RQQIiYCIjAogsIHEGolgqsP1gQuiOQpiXQswpKgotwoIHwsTRCSIrIj4rIq3lJkouosvOaPbEqGqF8NuSWVxMezaQmDcHKChj3OmC+mEXWE3NotTidlL2yEzwIqkqpEMG0oxDjJPBoEjOjNyisTnE5iksyCWVPKDJ-LvmmDCH7WAu-i8p3hsz8v0AXXkuXjemtG9gmB8sLMT1XPXM3CtVeQYpOjUrAJIGaB8lACDRkRKE9hTkYWCjkWYB9HzlSPTMjWBXDHBkMrvB7JU2auHP0DnInLaryE92mAEicl7y0sUt0qXmkNHWwhUsbmypiHUrak0tsuGtzNMssAMrCuMufOWrDnMozzIT8ussTDspGscucpSrcsKg8pCtTQIR8v7Ssu-jCFTD+CCtsRY38pWi3jCvd1Er-CitoqKrSGcjio8gSs5S5WZSuGStLItKFFAuyvIlyr3ilAKqqtYmMlLUbX+uCBKuHmKmYTnOqp93vPqq7lBSas6tarnL-E6pGknJ6sxoGoZpwKMiGp0tzJWLABhWYDYE2K4BRQEBwFVP2NUnUmoE0npKoVOio1dO6JN0lrImFssibUFscAVtFsdDUiWDn0UJSmnLh2DMloc3zIqtVv+KslDVUT8y3EFFtW7UdSsG7TSkSOCFtXzTtssHzUdsBVtRvLdubOpSYE9utr0OwV9uwUDpKFtTLzIUdSjtkC+CduSL0OlHoCWGkDqEdWTtTpgp2ATqsFtUeLdsePDFzssFtTtEpnmEaHoGSXLopkrsYGmBLstrArQt9qsARP0DqBMGinhiYgwuzqbttWYjbssA7tAC7uiSYjYgHq9r0OYnALdqYiCB7qsDYiXsHr0KSX0DSDHonpXqYliXHssA3v82ABHqUmePHu7t7tADABnqDv8wAFJz7d7r7QAmJH6j7QAT6txSJQa27X7J6fKu7Z7-NITOUAHL696b7wHYoQGH7f7fyX6oG36mJ-zLB4GI69DfzooR7AH97QAcGMGf6wLYZkHO7UHQB4ZiHQHf7YZcHt6gh8Gb76GaGEGwLITz737ggV7LBoTLATjBRepmETaxaEoVMYophgFu19BRGzaqEDERHzIRbTbxa8EaBGgAArL41RKRzTYQaJb25RxWvTN3WclKPSEouRtR4+XqbAJRiyNWhbD8TitRQlW1cFN2R1TxraJupI21SAEgV2DwdO7ewJ4Ju6PxmZMuxQOu2ASAN22ulweJqJxpGJiugAUV9qSYydSdKL0IADlpACnz6imCm3rv5hHjbjGnG6NezJGghgEyBol+0yA-xrG6NFHqnHHVG6maaGmgFNNmmV7xi2n2manemNs6w7HR0uRTJrH0TbIpJsEmSjITIXAiQ38jwmAxJKKXBNHpAZBt5zJiy7l0prGNbPzNxtaqMLCVmF9HrlKobCpVmNZrhzFTrNTCp342CFnpS6ypLWoOmpnS5vqSj7EfmAk-n9sNHtHKAXEkihRgX3xNsaa8nv4krizTJnn59pCCzwawR2xXzCdXKvmopYpHmagcXlAZm2kORBKwQ6QtGvjXm9QCTfJ0TYWWWMJSJfz2XmJtIyHUFXBoWJauXKAryYlfy5GBX1YhWEIVJ-amW4WJovgwhSIABtEi0AelmSqM5QftcVlIQimJMiaojC3VnCxlhdI1kOIigAXVIgAgZeottYXyIFTDxFUkKjuA0Bbitf0FtdDkzrdEOFIlYgjcjajejZjeHvBasF9YtirCtb4tIgAB0Qs+LLXKLlWWXU2M2lbPyoon4GKNCcX85uVCWNGogcXeJlbQA8U-gS2bBrDSXYzWXm2y223NwHnbB8R7AW2-hqW9KPCB2u21yzryXEwF9G2xsqLfgsRlA7QyAKZNp9AbAIR3VWXl3V2kgwLZ2N2fosQuIp5xBN3hyF87pMRlJ3wyYqEByu1rMiRsKiB72FyqzFKqgahhaHzA3iDbG+kKqYh85FEOxf3QBP9bGAjtqfGAkYhJXYbE1zoSBKIaJ7D-2xBUbFFzZn0uIAJxj4OFLygv39RGh9pXQn19pgY3QyPWgt3AP3wWMQOHgwOaP9ojtxB9A2PnzoOzjYOaKk0QLMriJuOOPkOjxXYtpwhKO46sOHgcPPy8OEJfqk0F9w1rHqkrhqtql9Ad213pPaPtCpg64aSUXrDbhAZ1AO5rRmFhmmEQWTRblql6ambHAaXokyAa5sb3JTY89aOTRLPrPyrGPn3XGyglKahuOKPDOuOZPHOovnOXPRDtV3OV7Qv6AvOh4fOfZD2F28RqlAv0qPCKqA7YoD2z2j3bzpAV39PcvPBHON3CuYqmzUv4ZZ2-S6wp48yk4qOcaMrGKdOcrUOrobCdX7o3I5PUwmhFPMb3oqzw1IOHxNPOtBu9OkhYuYuIOMPbCGPQoMR85P3lKf3Fu1xNP7LnO-2UCoOphmFpBhALbgE3IV71OJmxblvtPdPqvd3OODOqP0WvgTvHPWDJRgREveOBpWvjI5mNm1w1odm6g9mDmjmyATmraYEMRPuoZFIV7qs-w7vSAHYF8FlT3536vmN6A94mBSxWXbUFlHU6u-RyfKfqfJjHArkN2OOQQJrQu72SRWXxirkefX2+eQ8rlyMCvBfb3he1hwTe9xiF1JeX373PdFyxA5CJrOtQvPuav1vfvHyturuoFmy2nduopqxwRbB85yvSfF21ufv2ez3OfQverivGPxfbhmOnFkMLPnfeEgPPkDHoo4r0RtuAv3erPrRbQcjAf3uBOOgTRtfvuNuqPLuN0ZJrRMgXuem3vbgtO4-dzbhE-9PuODFt9IeyqvhHq5pkhgRzfG2nz4-hAaWkvphWUZB4F1AyAMS2mkTmw+IifJR2-KxO-u+rUq+Ou55O-IrB12u6B5pgRO-h1e-VeNMSklA-ZNf3wi-deS-U+QJgYCA3QwRZGTfGFbPpYGYK2zQm2L+XRffjOPI5gY+LOBcguShz-6Y8FA-qzHRn+qXqtAW6UAXNvx+6AC0ou-A3mnxb7gxy+UlcfnPxr53gj++gAXPSWb7NchQbfERMPy76L9e+JUfvj1wOgV8gUwnG9r8BeKsodW1-JwFL2LSTcFO4gRVANRX7UDAcn-GXrrSMgu1r+tpW-jL3fb1t1+N-DgbyGEEw8lefPXzPL2v4SDYSyvZfvNxyKNAvA5AOupvwoHZEdeP3CAYfxxQn8rUzCI8KFFigqDsBddYwVuHv7yRH+fndjgV0sFv80gzCdLgd2I7KUouEA0Tppyi6ODoBoKWAd-G9iz9zSnXPQWSiK4tR4BoQyfmQH0DpcW+QobziQPqhYCO+uAnvlJX6rpRCBg8XrptVApa9W8VAswWoNoGSDN4DA6bkwNm5jU2kpQldtF32gPsBoU+VQSu0dTccRy9bBoRYOv5SJ2hddIXve2kFmMl0vQuQbzxl7ddWBjXejgmRtRWkz2TGC9imXjyOkKueXALs5y4E65scPROtIN1IgbsXoaw4tAz3y659GuOwhYXrXCpg8zhmSOjPnxaHcD8SILR1JakEG55nGm2ArjcKAIy1WSRwujErS+h1NNOjcG4U2XGIPDWBUXeYU2VtTccVhPVb4dSVI72CLO0Io3DjmlRHCUR3QuTP5x8EydAuuw3ykmVuCG1WB9lRERwTAoYhUR85R4e9j-7kjAyirGlDsIZQwkWSuOftBdxiRMjmif-G-HSCpbUiKR4xQ1pKKs40iqyYo4HsCAxAmhXhjgG1nKKJFtJw0YIebByA0Ejg7eyffXov1N6gBLBVvfUfNksHkDcWNg3zpiMJwWc-Bm1Fwe+AtqHdIuZIrwXF1JG0dlAfg5rjALfrRD5+3feIR6Nm5ZcTOc7SrgF1dEpDmEG7K3n2wuFLsvutXTYfV006NcgxfUFLqGL7YT8F+cQhtsWIQGdcN2LvN6FlxSGFCt+xQyUA22tHlD5BmSKobh1qGsC9Rc2JoUmgpG2pexOIToTJ21EpphxNo-oZOMmHS86AsvbfOMRnHDCReig+tpoChgxxOwrLLcV2FIgbjvS6gD1t+V3EN924vmXcWBSPH0AKYJ7L4XUPww5F6AhzXctViKHGjpK1XCoAYPNEpiyuaY7Mbb0zG69dxcgudk73fA1iWub9FISUGvEnjqwnYfQCEPDHVjEhaQNITgNH4YC3orPH-mNl+C4hXxdokATPi-E-iz+JXM9qmPEI28qu2gsiZ2DAkc8M0zvTGiGOiSwS0gYYxARu1kb2VdxUEzAYP2wGOgR+eA-igDQeYviSe6o5uqRGfGaR6eZ7ccecOv5ETZJg4pYYRJsDKSyU6IvgohI4ShdwJGaUCSuM4GBlxi5kugauIfGokxJWIAgLiFYB593xwEnQTJ2BgndgYZoyiYx2q6ZJYot+ZyUwFcmBSng1gqwLGPZERT5xkQ+zgFKoT0l84C3UPrHzikkBSJYAxFhAJ8n+DCxnEySWlEyloDuu38TCWJIyHlSchmXfIfWLIFFDSIr5ZsSFJcltiphmHJ6PJ2qHMCV4rAtqWFJBAjDbhbw-zINNYCOpMpqkzJBNPmAS05pFk+caMP7xLpFptk6YWpxyI3Bjw5MS4OiSKEQCPxOUr4FP0IDIDPxSErbkZ23xXsVAzvHyvoWwhOtFw6vL3oaNIl69vJ6gXyW0wAh3S7R3dTlDEmEEvS1W+E8QR9K0FJ8vpf7A-hdMX7-TxugMx6b0LBm3F8JEwqGR+N0EIy-pynZGQ9NBoxJJx6MgKvhJnHYyPJJo36VkQBlEzgZCkl8WTKVD4TFJxE9yQxMunfjjedMwmZBMenTwiJLMykPhKFk2A3JjYj8aeN5lIzr2DM2KPuOPEuA7QTAB0HiF1ZfiRZwQKPiUngkqzQQ6subDOCYmdZpZRkgwXLPukCziZxwqQFiBnhMSOQqs9WdrIgjhobAmkJgI7I4TOzDZfoM2dTO5mWyCZ8sm2YzImluzSg6nJyS5MlmaCcZXkuGSHPFgSBGpjY+GsN3FQbTbo43R6GjSm5ditpJSULnaLmgsAyEfoJaVLUDI3ky5dpCuZ+TxDVz9AFZeAu+HLktAm5s4iWg9KslPtIJeEkyTtKfhf9SAKMwMgunv5Uk+CfbYedcF2ljz1gRQ3SKHCr5TzGxukd1uoCNBKA5BwIdLjTJAGGDjadna3pVwzFcz9xZAPqZYDxpH8aJcYvLpfJhmkRwht8xKaFF3GpSPJYFXcR-M8I-Sf52gxkdt2rrsTQUoUq4F9ztHRIq+88xeftPHknTpgWvFBSUHDQjy9pD4dEugq+AmSG5XcquTnOXmQT42-jJOdDP05T88FOwcIYxJ5kYgHY5CnYAkOLlmo-ROgPfP2LE5tibprnP2jSlE7MY2F9kzJJlC8CUAnRwYLhUQqYDrtjw4gU2qy1jpmlSYciyVjYD+JKwKyrcv+FkQkWBTpFZzEqHZlkWVymA-3JhofK+kwSpKzCJIO8yuBXNkg+cVpnP0blYh0JOwSlAyxIyZRnFc+CpuGCmiKLTadopqLQumB1yzsJIrhYcEcVDsXF+MKJYi2NhRiWFaS2xcEoQhaKlFSsGJTkVLmJLAlaVTJWkoSHlL7EJfbxQDWaLYdqhaizxfIqoVJBWWhiqRSXyaVyKqlQoCJTTLsVZKwUO804PvP6WwzWl85VJcTA9E4T6ofEZouGkvFWoi23M8sn-BrirL8asUCsjXC+j6yXZi7BKdssEXEQZZlNYMaClIiSgtApELzlMH2WqjDlxEBKd-Nij9oLl1oE5Quk+XTBwY1y25fco0opp4JCJBcSUDeWnKx6gk-AWZW1QAqkgdy1eMCuLQbj3OKQ2MRWXnhfinBOwUCqRCLJ3Q1lqNA8S32SG40KqOIdQG4uswwriokKmPDirmVNkqVzXbIbFRRWroSAMoOQFQAABeKgV5UZPWVkJLl8Km5YiqBVzUU0mdRQI0LyAPAcU54lIUUm+RKrHp8EqOaLPgm7ZM+aqvFBqqZG7Zry9lYJXqsVUGrbZBy-2UwC1U6zmyys55TS11UQx9VT3COU8ptV2qIIG4g2WrKOUuqFVz4y1YzKJA8r3AAq71aUDDXUBeVAq51SVAlhkCg1Sq5DlnLCjFhQoqNf+bUO3yyqKAK7dhZ6EdU2rjZoEwOVzJll+Te8gQoFiWv9VnKjJtSkoJVM9DVTmVWNPCR7PtneyTZvs+bM8rz7mzyJvM3zLWpai+qnVdKiqSJPSHYTipXwQgQNPrVGzNZdCOSd7RXV+g11FQU4TPLUleyfZxsp1RuqWGHq+1x6r1TNM3iTqbV2K7cReKMlXjPVDaw8VusbU4rH1X4q8e+rBE6jjSgE4iPMKmCrKSx+cOJAkjdhJI9lQGZwF6ALXfkU1eKBKaqotXurFZjbKNfmBLGBq3Vj0x6lhvvjtknu8MDVGBtij7IJSiatOYxSQ0-dM5l0RwDYEzVRRUa3auiR-PZVNl81hasRZvC9HKAHQdQafs+hPmMctFuIZsbFFA5d8hN0-RYqJogV8cpQ60CFKezUBMBJQkrWDv9MHQSbNNovFjrJvEDCbfikm-hcl3TxYr9NIPbTSpsk6SgHiGYbwHJt8r9obNDsSVu5uPDmasiMmwTSZvk0-gPNKvKsihN4mAbWW6Y0iJhpDw8SqxgGs8VFsA1-zbAd451EWqSDUQDZICsTaFE74-ySk0WzvgAoqrhDCtjoaLe-MxrMJIVSyp9ZjVWXcpq5VsYsFmBFWVlkilvblEwoO7uM9CMaqgHGttxGTHUkPS8aREG3DauIUE1ZRcJ5TPo+tdab2jfIMFcc9C78jqkfygmjoyEeiPeemOA2oLbBWzVTW7C54U8u+zGebdWEU0JSdkdEhbZ+Xzh1zpUzGdjRfK3ZWLAEN2p9J+TJV1jC4ZA5jKRBfiRQqABwC0Wdqk4XCP5jNNIP8ouHGQ9tbOQElKpWptIvRT8zwCRinJJj-ecdaTUZtx15AFFj227f9rFXp5+O8HY1TRpOgg6LoaHMKBxrNWUjB0hHdHXtmLRYLbwCU90b8AtrhbOueAoGo6KxUJD7tAihFUwLZWA7wwCC0eUgvWD9pJdNLZleHAXmjzBVbK5FdKuLQ8bENbq45W0hjjez0V9KisTENLGRVwaLWm3LUs12Lydd1oLjdvjo34bzeFAQjQ9S90Jr0o5q4NehpiShc5ArQe3Xrh91bx0wRU5rSQta3awhE6Yd9tRo922yw9+2yrYBqj0Z62c2OrELhrQ2PTz5eXKPVjouGF6g9j00PWQnqIkhq6dO3rSvQ1Q9agF0mxYB-DzTg0mFcMkcqnrw22z-5dO3cZXvVW2yfJUe1vfQBdWgU6NaaxjRmqBCsa2IdvTjb3kN1Fq7eJPeMe6m+nAxCFFivLVFDt4VaBgrFHLd93V0PKmQLKRofNvdTRJTsv8-QijtGWw6jA2+rYVu30B1R79PoUvoMxAWTaUWteifR-qYWY0t9wBmOLXoj1tbLcd8C7YwO6UWLj5SmgaHbweZ+67e27Z-Wbu90h4S99XEsS-KzGPajtAi4XXPCINASuZf+umnhKr7zaSDH4+gz9wDJTB4t1BgCXRNIO682Df4e8dvhl1IrWBHrP0DYFzSJtiyybSiqy2kNbgFDshqMmGWSrLNCUck3ZayJEiShNGNATZlJGhjH9YKKzXzJCyMPYJ1tdaKSKFvrYCp888wNQqMhsJGGZiy0zkRZV2oK9piNhWw8wkUUqgfJ+cEDYSgpD4BGoFIWnj4eULHxUKwQCwm4dsINJbUwxaTJm1AAdV1SMR+cckYG2eGFUqSoIPEPyMl0bauqOI2kFMaspSjeR32H8CkgcVEjMdPPH7AaPOHsjtzSI3oVdrTAgtHwMI8ACkhdH-MhK0yOod+AVH4jEgNQ+CBWa5H-MrKPQwYfBCTGSgkkXQ-obXA2HaoAx+zgkCUgO7hjv9GquPjBxTGTjs+MpUcbArTxfc1dKY7cdOPBx5jv9ew2HkLwVHijdR33DUf8wJ4sWCe6+J8b1CjHATWYX47-Rtx3HUKKSPXHcf6NpB8A1IbnfXq5rsBKo0gZiGQDyhPxTwCMXENccm1cZ7UcgOI18fNRJoXjYFCk23FWOWB1tkQZZM6ipNEmOOdJtY3qG-2Emlk6aH0HSYTQEJeTPVFk3MDHTsmvjY6CE2BTHS+FgTMppZFKaelOJRk4fYLIRtaiSR0an4VU2kcVNXIeTI0GEwXM6STVmThJtdHljIKVHAI8WHI4SeAxLIyTUOy03ggVMsngMOpyjOqZaj6APTE6Do3qYmoGnykRp-U2mktQim88gWJo+SfOwBmWTLmBTJ5j9AqZvT9UWLtGcxLKYwWhJxM0lHZP0npO0Z6RJGY+yrhfcRp+uLsh+MsnIcZhGTFYAUWfZfDpZuXAUaGWNm2W-A2WIqbbPM4WYpwJ1klmHMpYUB3ZwXMzBiLtwWTfZoWG1u92FHCzs52EMLl7Pjn5ckURXKsCUmLmMjiUmWILgVwOBtz05807rngNMCdgXxh3aWbbzhgvj7CRU53nzNfBvM-CDhCWe5OgI949GF07Ed3MpJvzYiP87CEVPeJ+gkGraE6fAtv4FkvjUs64UYzWnRTAxPnqWdFaMYALeoDCzLxZPrMcLMmLC-hde7yM0LZ56ApoDpJEkvj7LGxnae+AbbpSWZ+45kf2zMXFT7Ubto2lYvJScWHF6Ui+etMJRPzDFkY+8xXI4snTy5bKHxZZN3kuSHJ+S6GgRPO1g67gmoMGdiBGmsdmljoCpcTr+Z2uY7VthOzJZpmSoyE4scZaHZcXQwolyE1ZdLYmXUqjaLC+P2sufMuk+lqwPgAACqDAXEN8XItPYjChZuYCFfouqX-MEVtcIJZ4t4JgMIlqK8celLAZmLTpmK0mdJIJxCTmVoNIWbyvtVcrqV78MbLqZARHUs2V8A5yAiKmHTiaJ0-VejSlmfCpBRjF8dasP5YCipzqzASQwchELRhPfiQS6v9WXCqF3C4SfKiphiSWcU87sbxRJBzIzTZlLIFvzT77LYFEmIcSpjNGDicJTBsla2uxZQSnw6JJCW2sHWgKljcixWT2ttydjm18iJ6zGyspvGL1yQ1ppZPiGvWOFb3foB+tmQiQ0yI69crg2hsM64NtOmBZ+idCfoooOxv4dLAqgD9TcmKElhCN1oKQds1lFcEBCjLvWfwYasYTSATTXQhKeysAfDX8qRtWs4dA0mJ6kR4QcNutJTcBufWuIY5szr-QybQBmIEcWgUeIoDpAZtJdYQeTdZtQxWTd1v8I1yZsaBRbDSXof2LAqSwmQEqmoSXUZvM2rDW4Sm9NZqFk6wKzN+mxSEZsTAWbetqW0Zacs2XTLXSRW2bewhgUYgltiUX-KAu-ntssITmyzuNsK3Tb3EmSfLYSC+38AG4TQF4HMhiRpKREnVpBXhBO2nE-t0O7rfdt2o-YPiHINokBKy2z2Lt0k4HeCDm3DAbtym9JYsS2WCDP+mZHLddt53GWId9QL7blsW2i7QQMm9KkpvuXbbnlzcC3fzsErS77d4bDpJUBN3ObSdzpP7Z0BEgbSJoq8X9YInjQZtDSScSrYJUqhDdq93AGkH3FL3Fo-1ikJ3YptS3AbhNye9-GeGkReb-N-G0oGI0i2G7BdhVCPcsDr2ouONixPfbElL3ibljAuNjZORwa5Vt4hpOLa7tS2BUJJ1+0bYntv2WEgwje1IAJSMmd7aQCB6feOtsnn78Dm62kGVuf2UHhVEun5YCveytoFITB5Lewe9WnCxOOBybfwfBBCHZIze3XpXyjXGMzDoINQ6tvYOYrA9xu0w5LqsOAx7DwRzw6sB8P07T-Ygpw76vcPGHAdqR5YDEfkd2HdDsInAVIdgAAAKpIaihFtgA+LNyM+LyBUP+hkD7B6+mUeh2EH6jn8Ow9fRi2rHWD1k2KdwciOlbSDoh5ICwjKmMarj5be46rOfYnjQjlO83Yce+O2HKDoaOg+CAyPKbKOdc7A79t4PRHsT8Ryg7bOJPeHbjmh6ycTM2FInmTnx+YOQf+OXM+T6R4U-4esmbcZT7xxSEceq3-HUJ-A7U-dr1PZHNed8805UdZPKnfjxKAM9UdsCtw1jjxxNYYcZOWnBD7Jxo5QeDXicJdD+2w6Z20QKLowF8ONx3tAP-HCThpJ7IdkXq-ZDamlic-Uk2AZ71AX+IbansoQonZdqW3WbVNeOhna960VU6iDb2brhz1B0KhJvF3nbpEV22ncps0nDTnz+xxM-Xty27Sc9zWw0kBfxonn6wcF6SchdS2eTOmPIIM7hda2wXEL5ulC-UummtLuD+u3A7bvwufniLufsi+6eST2HNThm2C9IBSBXn1J+TFmd7KEvonEz7WwrZxe8vizZmQV47YwkkvsXZLqW0paoSX3Gkctrl5ICle4O6X6zhl4PaRcPODne9lB1o9gIguggIr1O-K9AUoEFH9DtcANdmdwFelo8XV184pCAvVnIWBpOzLufMuS63roe+q+JfJ34a3LsV-oWiP1mGAGriZ-67VfKuzXYLnW5a7flZHI30boN9Pfluz39XC99h6JEfBUAOWqbj59q77F+O-nIDhDSy-ddcgC3Rb-bKU+udj2wKcbv8OHeZSwUNrW1ZtwG-jdWBGbyzHlwSpmOEtYbCDxm8ID0kv3V7t9MAMShROXAbCljkJ0U9jp9uGqg91txM7af9EDgBblOqA5Zf+vJ3JdGt0sEcNwUy2HRw6qa6sD+vB3Gb55xPbDe21cHW74J1M9CctH6jThq92m++0ZP33FTtQVU9yKtA3QrRlYzG+Dtt2vXwd1txy+Dd6v57evdp2B-mlPwwdoyqSCy42c5Ot7lbjoRM7PdyxH4z8V+HvJw9Nuv849hDxSHFnj3YP9Hm5+PYfeIfM3g7sN4sc2MXv13MCOu4XbgcPvhXnLpIOq7Deu033Yn6V8EDw-LP-H+bto3++Cw3viPhrhT7W4g8-uwQt7ywCK+zcofRninsj65K0+8f6XZbuJwR4PdVu1PwQPN7W+q6YfvjVH5jz27Y8YvpTsxod9x+WM6eAPzrxuzS4yfCeS6DHsCie++eWfxH6zf56e73uxfCPYD5d5+9XcisSLdFx1w9jlsnvt3Szpx9Y2egTPknUDmkiMCotckAPOX0gDJ6CA7vaLRX0tziA3tbO1wCUO6Qa-s+Fe5mun400+9JfTPiL2fUi0YT-AoLqvjrhdS1DluhfqPGkrN-c5tJNeaAJPH1-q4Bd72GvPX9j0+7jdhveSimKqGU9y+PvMXFt-b+qSrvHeav47sF+d+TcV2+7GNGuyq83fSfcHbHjJ1q52+Yuk30z4S5K9wcneGk1qhtWWoa0-e1vhnth9NFg64efn5bqCEl869BA7Zn2OH5D6xcKoubi2LcLBwmenPe1oEi5+rKudueaPUPx52kARcuuDPKL3e-Z5QfT5PPz75N8+cB92OhXp36d2G8MpgIvbjWcBZz8dsUh-XJt-QOHaLK4hQQBqGCmPfjt7H1ALPv7+45guQXc7cD+uyJ+Df3fpnj3yS2N9ruD3gv43l1-Y5e9uJW7w9gnyx5efLffnSPmz0R-6PsPOnXu3r4zb2-Ju3f4edN+A96cpPXAoJpp1J+5cxORnVniGgCZD9+vg7yHx59gFd+R7MfKvopxcdnhlOgPKXiWw07eMF458mf973l4j-4ewTlYMzxE+g9KwQ3gbuD9X6Y8yukPTLnN6h6T8Xm5ovr+34j-3fwbnfqLtv9rA785vyf83hv924p81++Pnv6T2G8eOXGa+hfsPxZ+a+jOY-zURPyg6hMV-5-YOOb7c4W++uovK-qzxW6d+3iAXA-6+FH7uge-ZX2Pz+S42UD4-7fjLunzO4Z+o-cnaT3r2L4DsS+wA7Mh8SRuhALiDScngKL4wew9nX7j28flP6JuzftD6l+fZk+CFu9Po36Zuqfg059mk5mzh++FIHJ5OOwDmf4zuSJj-Y6sHbjgGnAbrup5YwBOAfCoBvXuF4H+63nv6MeUASP77+4vtn7TO4VqdbUuhdsX4geozn2ZHmSuNW40By5gwDC4t-k34Wu0zpIFwI1dvM6uu1Pgj4n+jvr37n+8Xoz7+OIgZubHmatDIEYBorsm56BCsCeZ4BqgdF7yep-poHiBOgQE6dI-dpj5e+g3lqagsBCJYGwI8Hu97-+W8C+JOoj6ItqhSYAQXroBT7pgHp2Mpp6Y-IXgUED+uY-vEFx+CAVT6guTfm-65uKzu4EuAvAPD7WBhAdZ52BADqQHGIbkGOjEa1AQ4EymuQawGU+fHkwGJBo9hP50epNrHJDSbgV7y6WqQdN5veYfpr6CeX3tb4v+tPot5oBwQIC6COKfiYH-eJVs+DVW3NlthxBW+A4EnoLgTP7JuTVoGB8eP2mb5c+0AS26+Bs7v4GaQgQUNrBBoAW6DgB4Qb97TB7jn6asYHRtsHfwjLkS77BvbrH7V+sAdz7MBiAfJ4HY-WHTzL+K3t35xefgQLbvIFQWkCAuwGHTy1BPwd0FNBo-uwEI6tvpP4l0J9kU5hmgpjC5OuohI3YIeGTsF5W+gbtr6ZupLs8LP+R-it6v+owfYFBA+ABkzCcTKA0TuAUZNjateOzvyB7OmIEYH9ecrtfb+W6aqNwdeQIRvZOINbMJx0hVgAxpocmXtyFMCcIV8H-+YACeCXEwymsrNU3NIl5n+OoIzbkhILGBSChC+l9AihXfmw7ihhOJKF2eqPhaFXAkoSD5tBrADn7p259n9ZPBQoNfa32atgHSPET9sL4IOBATca6oeNqUFA2n4P-baBn-vfbq2typ8CI2FVAEZyAAzJYDhoW+rRgmBvbvehyuKbp65gC4boSzEUsAchx9B1RImGtAPkk65lhncofp1sBZLIK+sYIBVA5B4Gm4hpsQgtfy8A6KlkpthQQCGxp0ygAADkAAIKgAvAAOF5kiLD2Gu8oUIfZX8vwGijq6gCFOGWaRkH2H4UerFRTCUp7PQDjQJrAOGgAE2OOFIkoAMuEWiUNocADhkAFvAUwe8LIDNiVEFFBkczZH9ZScAAOxHhaQG2HOQHZulBthJodfwLh4JGkqnha4YOEAAQkqQfhk4b3gDh0AAOHHhQyiBHnhg4VeE3it4feE0Aj4W5CE2UnBgBQRQQF+E-hv4e2G-AE2F2HARUwKBEDhAABL7Q7YGiaTOh4ROFpQhEURHhgf4XSzX8GAORHQReashE0RdEZBRwo3NMIJ4RzEcECsRbEV8BthVESgCgA+4RhQusW4cIKdhS-NBFURAAGzyRfFEpGHAwgmRFqR+AOAA3hEUK1J-WYKPZoQoJ4dgBURAABzaRikRuHUUokc3ziRrYYn61hlKvWEsAjYbkAuAaKC2HSR9bKyjbMIIN5hARQoKeHgwjSKeFmuPlAAAMS4RSBhAjQEkSxRLYCFGLs0gCxCjh3mHxTikn4RYAYAaKAhEUR34T+EyRyEWmykQr4XxRyRsUNVE6RTkVuGZRxEK+H6AKAIbRthSKtgD4GRwMjZyAvUDQb341uv1HUgWYa-bcQQAA","body":"const the_global_environment = setup_environment();\nstart(eceval); "},{"tag":"SNIPPET","latex":false,"id":3,"eval":false,"body":"function append(x, y) {\n    return is_null(x)\t\n           ? y\n           : pair(head(x), append(tail(x), y));\n}","output":"EC-evaluate value:\nundefined"},{"tag":"SNIPPET","latex":false,"id":4,"eval":false,"body":"append(list(\"a\", \"b\", \"c\"), list(\"d\", \"e\", \"f\"));","output":"EC-evaluate value:\n[\"a\", [\"b\", [\"c\", [\"d\", [\"e\", [\"f\", null]]]]]]"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    Of course, evaluating\n    programs\n    in this way will take much longer\n    than if we had directly typed them into\n    JavaScript,\n    because of the\n    multiple levels of simulation involved.  Our\n    programs\n    are evaluated\n    by the explicit-control-evaluator machine, which is being simulated by\n    a\n    JavaScript\n    program, which is itself being evaluated by the\n    JavaScript\n    interpreter.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Monitoring the performance of the evaluator","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    Simulation can be a powerful tool to guide the implementation of\n    evaluators.\n    \n    Simulations make it easy not only to explore variations\n    of the register-machine design but also to monitor the performance of\n    the simulated evaluator.  For example, one important factor in\n    performance is how efficiently the evaluator uses the stack.  We can\n    observe the number of stack operations required to evaluate various\n    programs\n    by defining the evaluator register machine with the\n    version of the simulator that collects statistics on stack use\n    (section ","tag":"#text"},{"tag":"REF","body":"5.2.4","href":"/sicpjs/5.2.4"},{"body":"), and adding an instruction at the\n    evaluator's\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"print_result"},{"body":"\n    entry point to print the statistics:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\n\"print_result\",\n  perform(list(op(\"print_stack_statistics\"))), // added instruction\n  // rest is same as before\n  perform(list(op(\"user_print\"),\n               constant(\"EC-evaluate value:\"), reg(\"val\"))),\n  go_to(label(\"read_evaluate_print_loop\")),\n      "},{"body":"\n    Interactions with the evaluator now look like this:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":false},{"tag":"SNIPPET","latex":false,"id":6,"eval":false,"body":"function factorial (n) {\n    return n === 1\n           ? 1\n           : factorial(n - 1) * n;\n}","output":"total pushes = 4 \nmaximum depth = 3\nEC-evaluate value:\nundefined"},{"tag":"SNIPPET","latex":false,"id":7,"eval":false,"body":"factorial(5);","output":"total pushes = 151 \nmaximum depth = 28\nEC-evaluate value:\n120"},{"body":"\n\n    Note that the driver loop of the evaluator reinitializes the stack\n    at the start of\n    each interaction, so that the statistics printed will refer only to\n    stack operations used to evaluate the previous\n    program.","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.27","id":"#ex-5.27","child":[{"body":"\n    Use the monitored stack to explore the\n    \n    tail-recursive property of the\n    evaluator (section ","tag":"#text"},{"tag":"REF","body":"5.4.2","href":"/sicpjs/5.4.2"},{"body":").  Start the\n    evaluator and define the\n    \n    iterative ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":"function\n    from section ","tag":"#text"},{"tag":"REF","body":"1.2.1","href":"/sicpjs/1.2.1"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":false,"body":"function factorial(n) {\n    function iter(product, counter) {\n        return counter > n\n               ? product\n               : iter(counter * product,\n                      counter + 1);\n    }\n    return iter(1, 1);\n}"},{"body":"\n    Run the\n    function\n    with some small values of ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".  Record the\n    maximum stack depth and the number of pushes required to compute\n    ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":" for each of these values.\n    ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\tYou will find that the maximum depth required to evaluate\n\t","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":" is independent of\n\t","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".  What is that depth?\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tDetermine from your data a formula in terms of\n\t","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" for the total number of push operations\n\tused in evaluating ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":" for any\n\t","tag":"#text"},{"body":"$n \\geq 1$","tag":"LATEX"},{"body":". Note that the number of\n\toperations used is a linear function of ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"\n\tand is thus determined by two constants.\n      ","tag":"#text"}]}]}]},{"tag":"EXERCISE","title":"Exercise 5.28","id":"#ex-5.28","child":[{"body":"\n    For comparison with exercise ","tag":"#text"},{"tag":"REF","body":"5.27","href":"/sicpjs/5.4.4#ex-5.27"},{"body":", explore\n    the behavior of the following\n    function\n    for computing\n    \n    factorials recursively:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":9,"eval":false,"body":"function factorial(n) {\n    return n === 1 \n           ? 1\n           : factorial(n - 1) * n;\n}"},{"body":"\n    By running this\n    function\n    with the monitored stack, determine, as a function of\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":", the maximum depth of the stack and the total\n    number of pushes used in evaluating ","tag":"#text"},{"body":"$n!$","tag":"LATEX"},{"body":" for\n    ","tag":"#text"},{"body":"$n \\geq 1$","tag":"LATEX"},{"body":".  (Again, these functions will be\n    linear.)  Summarize your experiments by filling in the following table with\n    the appropriate expressions in terms of ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":":\n    ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_original/527table.svg","id":"#fig-"},{"body":"\n    The maximum depth is a measure of the amount of space used by the\n    evaluator in carrying out the computation, and the number of pushes\n    correlates well with the time required.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.89","id":"#ex-2.89","child":[{"body":"\n    Modify the definition of the evaluator by changing\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"ev_return"},{"body":"\n      as described in section ","tag":"#text"},{"tag":"REF","body":"5.4.2","href":"/sicpjs/5.4.2"},{"body":"\n    so that the evaluator is no longer\n    \n    tail-recursive.  Rerun your experiments from\n    exercises ","tag":"#text"},{"tag":"REF","body":"5.27","href":"/sicpjs/5.4.4#ex-5.27"},{"body":"\n    and ","tag":"#text"},{"tag":"REF","body":"5.28","href":"/sicpjs/5.4.4#ex-5.28"},{"body":" to demonstrate that both versions of\n    the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":"function\n    now require space that grows linearly with their input.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 5.29","id":"#ex-5.29","child":[{"body":"\n    Monitor the stack operations in the tree-recursive\n    \n    Fibonacci computation:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":false,"body":"function fib(n) {\n    return n < 2 ? n : fib(n - 1) + fib(n - 2);\n}"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\tGive a formula in terms of ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" for the\n\tmaximum depth of the stack required to compute\n\t","tag":"#text"},{"body":"${\\textrm{Fib}}(n)$","tag":"LATEX"},{"body":" for\n\t","tag":"#text"},{"body":"$n \\geq 2$","tag":"LATEX"},{"body":".  Hint: In\n\tsection ","tag":"#text"},{"tag":"REF","body":"1.2.2","href":"/sicpjs/1.2.2"},{"body":" we argued that the space\n\tused by this process grows linearly with ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tGive a formula for the total number of pushes used to compute\n\t","tag":"#text"},{"body":"${\\textrm{Fib}}(n)$","tag":"LATEX"},{"body":" for\n\t","tag":"#text"},{"body":"$n \\geq 2$","tag":"LATEX"},{"body":".  You should find that the number\n\tof pushes (which correlates well with the time used) grows exponentially\n\twith ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".  Hint: Let\n\t","tag":"#text"},{"body":"$S(n)$","tag":"LATEX"},{"body":" be the number of pushes used in\n\tcomputing ","tag":"#text"},{"body":"${\\textrm{Fib}}(n)$","tag":"LATEX"},{"body":".  You should be\n\table to argue that there is a formula that expresses\n\t","tag":"#text"},{"body":"$S(n)$","tag":"LATEX"},{"body":" in terms of\n\t","tag":"#text"},{"body":"$S(n-1)$","tag":"LATEX"},{"body":", ","tag":"#text"},{"body":"$S(n-2)$","tag":"LATEX"},{"body":",\n\tand some fixed \"","tag":"#text"},{"body":"overhead","tag":"#text"},{"body":"\" constant\n\t","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" that is independent of\n\t","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":".  Give the formula, and say what\n\t","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" is.  Then show that\n\t","tag":"#text"},{"body":"$S(n)$","tag":"LATEX"},{"body":" can be expressed as\n\t","tag":"#text"},{"body":"$a {\\textrm{Fib}}(n+1) + b$","tag":"LATEX"},{"body":" and give the\n\tvalues of ","tag":"#text"},{"body":"$a$","tag":"LATEX"},{"body":" and\n\t","tag":"#text"},{"body":"$b$","tag":"LATEX"},{"body":".\n      ","tag":"#text"}]}]}]},{"tag":"EXERCISE","title":"Exercise 5.30","id":"#ex-5.30","child":[{"body":"\n    Our evaluator currently catches and signals only two kinds of\n    \n    errors—unknown\n    \n        component\n      \n    types and unknown\n    function\n    types.  Other errors will take us out of the evaluator\n    \n\tread-evaluate-print\n      \n    loop.\n    When we run the evaluator using the register-machine simulator, these\n    errors are caught by the underlying\n    JavaScript\n    system.  This is analogous\n    to the computer crashing when a user program makes an error.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/5.4.4#footnote-4"},{"body":"\n    It is a large project to\n    make a real error system work, but it is well worth the effort to understand\n    what is involved here.\n    ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"\n\tErrors that occur in the evaluation process, such as an attempt to\n\taccess an unbound\n\tname,\n\tcould be caught by changing the lookup\n\toperation to make it return a distinguished condition code, which cannot\n\tbe a possible value of any user\n\tname.\n\tThe evaluator can test\n\tfor this condition code and then do what is necessary to go to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"signal_error"},{"body":".\n\t  \n\tFind all of the places in the evaluator where such a\n\tchange is necessary and fix them.  This is lots of work.\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tMuch worse is the problem of handling errors that are signaled by\n\tapplying primitive\n\tfunctions\n\tsuch as an attempt to divide by zero or an attempt to extract the\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n\t    of a string.\n\t  \n\tIn a professionally written high-quality system, each\n\tprimitive application is checked for safety as part of the primitive.\n\tFor example, every call to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head"},{"body":"\n\tcould first check that the argument is a pair.  If the argument is not\n\ta pair, the application would return a distinguished condition code to\n\tthe evaluator, which would then report the failure.  We could arrange\n\tfor this in our register-machine simulator by making each primitive\n\tfunction\n\tcheck for applicability and returning an appropriate distinguished\n\tcondition code on failure. Then the\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"primitive_apply"},{"body":"\n\tcode in the evaluator can check for the condition code and go to\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"signal_error"},{"body":"\n\tif necessary.  Build this structure and make it work.\n\tThis is a major project.\n      ","tag":"#text"}]}]}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/5.4.4#footnote-link-1","child":[{"body":"We assume\n    here that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"user_read"},{"body":",\n\t      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"parse"},{"body":",\n      \n    and the various printing\n    operations are available as primitive machine operations, which is useful\n    for our simulation, but completely unrealistic in practice.  These are\n    actually extremely complex operations.  In practice,\n    reading and printing\n    would be\n    implemented using low-level input-output operations such as transferring\n    single characters to and from a device.\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/5.4.4#footnote-link-2","child":[{"body":"There are\n    other errors that we would like the interpreter to handle, but these are not\n    so simple.  See exercise ","tag":"#text"},{"tag":"REF","body":"5.30","href":"/sicpjs/5.4.4#ex-5.30"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/5.4.4#footnote-link-3","child":[{"body":"We\n    could perform the stack initialization only after errors, but doing it in\n    the driver loop will be convenient for monitoring the evaluator's\n    performance, as described below.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/5.4.4#footnote-link-4","child":[{"body":"\n        This manifests itself as, for example, a \"","tag":"#text"},{"body":"kernel panic","tag":"#text"},{"body":"\" or a \"","tag":"#text"},{"body":"blue\n        screen of death","tag":"#text"},{"body":"\" or even a reboot. Automatic rebooting is an approach\n        typically used on phones and tablets. Most modern operating systems do a\n        decent job of preventing user programs from causing an entire machine to\n        crash.\n      ","tag":"#text"}]}]