<SECTION>
   <NAME>
    <SPLITINLINE>
      程序
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    及其生成的过程
  </NAME> 

   <SECTIONCONTENT></SECTIONCONTENT> 

  <LABEL NAME="sec:procedures-and-processes"></LABEL> 

   <TEXT>
    我们现在已经考虑了编程的元素：我们使用了
    原始算术操作，组合了这些操作，并且
    通过
    <SPLITINLINE>
      将其定义为复合程序。
      <JAVASCRIPT>将其声明为复合函数。</JAVASCRIPT>
    </SPLITINLINE>
    但这还不足以让我们说我们知道如何编程。我们的情况类似于一个已经
    学会了国际象棋棋子如何移动规则的人，但对典型开局、战术或策略一无所知。像初学者的棋手一样，
    我们尚不知道该领域的常见使用模式。
    我们缺乏对哪些移动是值得做的知识
    <SPLITINLINE>
      （哪些程序值得定义）
      <JAVASCRIPT>（哪些函数值得声明）</JAVASCRIPT>
    </SPLITINLINE>
    我们缺乏预测移动后果的经验
    <SPLITINLINE>
      （执行一个程序）。
      <JAVASCRIPT>（执行一个函数）。</JAVASCRIPT>
    </SPLITINLINE>
  </TEXT> 

   <TEXT>
    视觉化所考虑的行动后果的能力对于成为一名专家程序员至关重要，正如在任何合成的创造性活动中一样。例如，成为一名专家摄影师，必须学会如何观察一个场景，并知道每个可能的曝光选择下，图像中每个区域在打印时将显得多么黑暗，以及
    <SPLITINLINE>
      显影。
      <JAVASCRIPT>处理选项。</JAVASCRIPT>
    </SPLITINLINE>
    <COMMENT>
      术语<QUOTE>显影</QUOTE>可能对数字时代的主流受众并不熟悉。
    </COMMENT>
    只有这样，人才能向后推理，规划构图、照明、曝光和
    <SPLITINLINE>
      显影
      <JAVASCRIPT>处理</JAVASCRIPT>
    </SPLITINLINE>
    以获得所需的效果。因此编程也是如此，我们在规划一个过程的行动方案，并通过程序控制该过程。要成为专家，我们必须学会可视化各种类型生成的
    <SPLITINLINE>
      程序。
      <JAVASCRIPT>函数。</JAVASCRIPT>
    </SPLITINLINE>
    只有在我们培养出这样的技能之后，才能可靠地构造出表现出所需行为的程序。
  </TEXT> 

   <TEXT>
    一个
    <SPLITINLINE>
      程序
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE> 
    是一个
    <INDEX><FUNCTION></FUNCTION><SUBINDEX><ORDER>模式</ORDER>作为过程的局部演化模式</SUBINDEX></INDEX>
    用于计算过程的<EM>局部演化</EM>的模式。它指定了过程的每个阶段如何建立在上一个阶段之上。我们希望能够对局部
    <INDEX>过程的局部演化</INDEX>
    <INDEX>过程<SUBINDEX>局部演化</SUBINDEX></INDEX>
    已由
    <SPLITINLINE>
      程序
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    指定的过程的整体或<EM>全局</EM>行为做出陈述。一般来说，这很难做到，但我们至少可以尝试描述一些典型的过程演化模式。
  </TEXT> 

   <TEXT>
    在本节中，我们将检查一些由简单
    <SPLITINLINE>
      程序
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE>
    生成的常见<QUOTE>形状</QUOTE>。我们还将研究这些过程消耗时间和空间这两种重要计算资源的速率。我们将考虑的
    <SPLITINLINE>
      程序
      <JAVASCRIPT>函数</JAVASCRIPT>
    </SPLITINLINE> 
    非常简单。它们的作用类似于摄影中的测试模式：作为过于简化的原型模式，而不是实际的例子。
  </TEXT> 

  <!--  Subsection 1 : Linear Recursion and Iteration  -->
  &amp;subsection1.2.1;

  <!--  Subsection 2 : Tree Recursion  -->
  &amp;subsection1.2.2;

  <!--  Subsection 3 : Orders of Growth  -->
  &amp;subsection1.2.3;

  <!--  Subsection 4 : Exponentiation  -->
  &amp;subsection1.2.4;

  <!--  Subsection 5 : Greatest Comman Divisors  -->
  &amp;subsection1.2.5;

  <!--  Subsection 6 : Example: Testing for Primality  -->
  &amp;subsection1.2.6;

</SECTION>
