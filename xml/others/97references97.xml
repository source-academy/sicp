<REFERENCES>
  <!--  taken from http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-36.html#%_chap_Temp_849 -->
  <NAME>References</NAME>

  <REFERENCE>
    Abelson, Harold, Andrew Berlin, Jacob Katzenelson,
    William McAllister,
    Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992.  The
    Supercomputer Toolkit: A general framework for special-purpose
    computing.  <EM>International Journal of High-Speed Electronics</EM>
    3(3):337<ENDASH/>361.</REFERENCE>

  <REFERENCE>
    Allen, John.  1978.  <EM>Anatomy of Lisp.</EM> New York: McGraw-Hill.
  </REFERENCE>

  <REFERENCE>Appel, Andrew W.  1987.  Garbage collection can be faster than stack
    allocation.  <EM>Information Processing Letters</EM> 25(4):275<ENDASH/>279.</REFERENCE>

  <REFERENCE>Backus, John.  1978.  Can programming be liberated from the von
    Neumann style?  <EM>Communications of the ACM</EM> 21(8):613<ENDASH/>641.</REFERENCE>

  <REFERENCE>Baker, Henry G., Jr.  1978.  List processing in real time on a serial
    computer.  <EM>Communications of the ACM</EM> 21(4):280<ENDASH/>293.</REFERENCE>

  <REFERENCE>Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and
    Daniel Weise.  1982.  The Scheme-81 architecture<EMDASH/>System and chip.
    In <EM>Proceedings of the MIT Conference on Advanced Research in
      VLSI,</EM> edited by Paul Penfield, Jr. Dedham, MA: Artech House.</REFERENCE>

  <REFERENCE>Borning, Alan.  1977.  ThingLab<EMDASH/>An object-oriented system for
    building simulations using constraints. In <EM>Proceedings of the 5th
      International Joint Conference on Artificial Intelligence.</EM></REFERENCE>

  <REFERENCE>Borodin, Alan, and Ian Munro.  1975.  <EM>The Computational
      Complexity of Algebraic and Numeric Problems.</EM> New York: American
    Elsevier.</REFERENCE>

  <REFERENCE>Chaitin, Gregory J.  1975.  Randomness and mathematical proof.  <EM>Scientific American</EM> 232(5):47<ENDASH/>52.</REFERENCE>

  <REFERENCE>Church, Alonzo.  1941.  <EM>The Calculi of Lambda-Conversion.</EM>
    Princeton, N.J.: Princeton University Press.</REFERENCE>

  <REFERENCE>Clark, Keith L.  1978.  Negation as failure.  In <EM>Logic and Data
      Bases.</EM> New York: Plenum Press, pp. 293<ENDASH/>322.</REFERENCE>

  <REFERENCE>Clinger, William.  1982.  Nondeterministic call by need is neither
    lazy nor by name. In <EM>Proceedings of the ACM Symposium on Lisp and
      Functional Programming,</EM> pp. 226<ENDASH/>234.</REFERENCE>

  <REFERENCE>Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un syst<EGRAVE_LOWER/>me
    de communication homme-machine en fran<CCEDIL_LOWER/>ais.  Technical report,
    Groupe d<APOS/>Intelligence Artificielle, Universit<EACUTE_LOWER/> d'Aix-Marseille II,
    Luminy.</REFERENCE>

  <REFERENCE>Cormen, Thomas, Charles Leiserson, Ronald Rivest, and Clifford Stein.  2022. <EM>Introduction to Algorithms.</EM> 4th edition. Cambridge, MA: MIT Press.</REFERENCE>

  <REFERENCE>Crockford, Douglas.  2008.  <EM>JavaScript: The Good Parts.</EM>
    Sebastopol, CA: O'Reilly Media.</REFERENCE>

  <REFERENCE>Darlington, John, Peter Henderson, and David Turner.  1982.  <EM>Functional Programming and Its Applications.</EM> New York: Cambridge
    University Press.</REFERENCE>

  <REFERENCE>Dijkstra, Edsger W. 1968a.  The structure of the <QUOTE>THE</QUOTE>
    multiprogramming system.  <EM>Communications of the ACM</EM>
    11(5):341<ENDASH/>346.</REFERENCE>

  <REFERENCE>Dijkstra, Edsger W. 1968b.  Cooperating sequential processes.  In <EM>Programming Languages</EM>, edited by F. Genuys. New York: Academic Press, pp.
    43<ENDASH/>112.</REFERENCE>

  <REFERENCE>Dinesman, Howard P.  1968.  <EM>Superior Mathematical Puzzles</EM>.  New
    York: Simon and Schuster.</REFERENCE>

  <REFERENCE>de Kleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.
    AMORD: Explicit control of reasoning.  In <EM>Proceedings of the ACM
      Symposium on Artificial Intelligence and Programming Languages,</EM> pp.
    116<ENDASH/>125.</REFERENCE>

  <REFERENCE>Doyle, Jon. 1979. A truth maintenance system. <EM>Artificial
      Intelligence</EM> 12:231<ENDASH/>272.</REFERENCE>

  <REFERENCE>ECMA.  1997. ECMAScript: A general purpose,
cross-platform programming
language, edited by Guy L. Steele Jr.  <EM>Ecma International.</EM></REFERENCE>

  <REFERENCE>ECMA.  2015. ECMAScript: A general purpose, cross-platform programming
language. 6th edition, edited by Allen Wirfs-Brock.  <EM>Ecma International.</EM></REFERENCE>

  <REFERENCE>ECMA.  2020. ECMAScript: A general purpose, cross-platform programming
language. 11th edition, edited by Jordan Harband.  <EM>Ecma International.</EM></REFERENCE>

  <REFERENCE>Feeley, Marc.  1986.  Deux approches <AGRAVE_LOWER/> l'implantation du
    language Scheme.  Masters thesis, Universit<EACUTE_LOWER/> de Montr<EACUTE_LOWER/>al.</REFERENCE>

  <REFERENCE>Feeley, Marc and Guy Lapalme.  1987.  Using closures for code
    generation.  <EM>Journal of Computer Languages</EM> 12(1):47<ENDASH/>66.</REFERENCE>

  <REFERENCE>Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National
    Fifth Generation Project: Introduction, survey, and evaluation.  In <EM>Future Generation Computer Systems,</EM> vol. 9, pp. 105<ENDASH/>117.</REFERENCE>
  
  <REFERENCE>Feller, William.  1957.  <EM>An Introduction to Probability Theory
      and Its Applications,</EM> volume 1. New York: John Wiley <AMP/> Sons.</REFERENCE>

  <REFERENCE>Fenichel, R., and J. Yochelson.  1969.  A Lisp garbage collector for
    virtual memory computer systems.  <EM>Communications of the ACM</EM>

    12(11):611<ENDASH/>612.</REFERENCE>

  <REFERENCE>Floyd, Robert. 1967. Nondeterministic algorithms. <EM>JACM,</EM> 14(4):636<ENDASH/>644.</REFERENCE>

  <REFERENCE>Forbus, Kenneth D., and Johan de Kleer.  1993. <EM>Building Problem
      Solvers.</EM> Cambridge, MA: MIT Press.</REFERENCE>

  <REFERENCE>Friedman, Daniel P., and David S. Wise.  1976.  CONS should not
    evaluate its arguments. In <EM>Automata, Languages, and Programming:
      Third International Colloquium,</EM> edited by S. Michaelson and R.
    Milner, pp. 257<ENDASH/>284.</REFERENCE>

  <REFERENCE>Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.
    <EM>Essentials of Programming Languages.</EM>  Cambridge, MA: MIT
    Press/McGraw-Hill.</REFERENCE>

  <REFERENCE>Gabriel, Richard P. 1988.  The Why of <EM>Y</EM>.  <EM>Lisp Pointers</EM>
    2(2):15<ENDASH/>25.</REFERENCE>

  <REFERENCE>Goldberg, Adele, and David Robson.  1983.  <EM>Smalltalk-80: The
      Language and Its Implementation.</EM> Reading, MA: Addison-Wesley.</REFERENCE>

  <REFERENCE>Gordon, Michael, Robin Milner, and Christopher Wadsworth.  1979.  <EM>Edinburgh LCF.</EM> Lecture Notes in Computer Science, volume 78. New
    York: Springer-Verlag.</REFERENCE>

  <REFERENCE>Gray, Jim, and Andreas Reuter. 1993. <EM>Transaction Processing:
      Concepts and Models.</EM> San Mateo, CA: Morgan-Kaufman.</REFERENCE>

  <REFERENCE>Green, Cordell.  1969.  Application of theorem proving to problem
    solving.  In <EM>Proceedings of the International Joint Conference on
      Artificial Intelligence,</EM> pp. 219<ENDASH/>240.</REFERENCE>

  <REFERENCE>Green, Cordell, and Bertram Raphael.  1968.  The use of
    theorem-proving techniques in question-answering systems.  In <EM>Proceedings of the ACM National Conference,</EM> pp. 169<ENDASH/>181.</REFERENCE>

  <REFERENCE>Guttag, John V.  1977.  Abstract data types and the development of
    data structures.  <EM>Communications of the ACM</EM> 20(6):397<ENDASH/>404.</REFERENCE>

  <REFERENCE>Hamming, Richard W.  1980.  <EM>Coding and Information Theory.</EM>

    Englewood Cliffs, N.J.: Prentice-Hall.</REFERENCE>

  <REFERENCE>Hanson, Christopher P.  1990.  Efficient stack allocation for
    tail-recursive languages.  In <EM>Proceedings of ACM Conference on
      Lisp and Functional Programming,</EM> pp. 106<ENDASH/>118.</REFERENCE>

  <REFERENCE>Hanson, Christopher P.  1991.  A syntactic closures macro facility.
    <EM>Lisp Pointers,</EM> 4(3).</REFERENCE>

  <REFERENCE>Hardy, Godfrey H.  1921.  Srinivasa Ramanujan.  <EM>Proceedings of
      the London Mathematical Society</EM> XIX(2).</REFERENCE>

  <REFERENCE>Hardy, Godfrey H., and E. M. Wright.  1960.  <EM>An Introduction to
      the Theory of Numbers.</EM>  4th edition.  New York: Oxford University
    Press.</REFERENCE>

  <REFERENCE>Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. <EM>IBM Systems Journal</EM> 7(2):74<ENDASH/>84.</REFERENCE>

  <REFERENCE>Henderson, Peter. 1980.  <EM>Functional Programming: Application and
      Implementation.</EM> Englewood Cliffs, N.J.: Prentice-Hall.</REFERENCE>

  <REFERENCE>Henderson. Peter. 1982. Functional Geometry. In <EM>Conference Record
      of the 1982 ACM Symposium on Lisp and Functional Programming,</EM>
    pp. 179<ENDASH/>187.</REFERENCE>

  <REFERENCE>Hewitt, Carl E.  1969.  PLANNER: A language for proving theorems in
    robots.  In <EM>Proceedings of the International Joint Conference on
      Artificial Intelligence,</EM> pp. 295<ENDASH/>301.</REFERENCE>

  <REFERENCE>Hewitt, Carl E.  1977.  Viewing control structures as patterns of
    passing messages.  <EM>Journal of Artificial Intelligence</EM>
    8(3):323<ENDASH/>364.</REFERENCE>

  <REFERENCE>Hoare, C. A. R. 1972.  Proof of correctness of data representations.
    <EM>Acta Informatica</EM> 1(1).</REFERENCE>

  <REFERENCE>Hodges, Andrew. 1983.  <EM>Alan Turing: The Enigma.</EM> New York: Simon
    and Schuster.</REFERENCE>

  <REFERENCE>Hofstadter, Douglas R.  1979.  <EM>G<OUML_LOWER/>del, Escher, Bach: An Eternal
      Golden Braid.</EM> New York: Basic Books.</REFERENCE>

  <REFERENCE>Hughes, R. J. M.  1990.  Why functional programming matters.  In <EM>Research Topics in Functional Programming</EM>, edited by David Turner.
    Reading, MA: Addison-Wesley, pp. 17<ENDASH/>42.</REFERENCE>

  <REFERENCE>IEEE Std 1178-1990.  1990.  <EM>IEEE Standard for the Scheme
      Programming Language.</EM></REFERENCE>

  <REFERENCE>Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig;
    assisted by M. Lind, Herbert Kanner, and Robert Floyd.  1960.  THUNKS:
    A way of compiling procedure statements, with some comments on
    procedure declarations.  Unpublished manuscript.  (Also, private
    communication from Wallace Feurzeig.)</REFERENCE>

    <REFERENCE>Jaffar, Joxan, and Peter J. Stuckey. 1986. Semantics of infinite tree
    logic programming. <EM>Theoretical Computer Science</EM> 46:141<ENDASH/>158.</REFERENCE>
    
  <REFERENCE>Kaldewaij, Anne. 1990.  <EM>Programming: The Derivation of
      Algorithms.</EM> New York: Prentice-Hall.</REFERENCE>

  <REFERENCE>Knuth, Donald E.  1997a.  <EM>Fundamental Algorithms.</EM> Volume 1 of
    <EM>The Art of Computer Programming.</EM>  3rd edition. Reading, MA:
    Addison-Wesley.</REFERENCE>

  <REFERENCE>Knuth, Donald E.  1997b.  <EM>Seminumerical Algorithms.</EM> Volume 2 of
    <EM>The Art of Computer Programming.</EM>  3rd edition. Reading, MA:
    Addison-Wesley.</REFERENCE>

  <REFERENCE>Konopasek, Milos, and Sundaresan Jayaraman.  1984.  <EM>The TK!Solver
      Book: A Guide to Problem-Solving in Science, Engineering, Business,
      and Education.</EM> Berkeley, CA: Osborne/McGraw-Hill.</REFERENCE>

  <REFERENCE>Kowalski, Robert.  1973.  Predicate logic as a programming language.
    Technical report 70, Department of Computational Logic, School of
    Artificial Intelligence, University of Edinburgh.</REFERENCE>

  <REFERENCE>Kowalski, Robert.  1979.  <EM>Logic for Problem Solving.</EM> New York:
    North-Holland.</REFERENCE>

  <REFERENCE>Lamport, Leslie. 1978.  Time, clocks, and the ordering of events in a
    distributed system.  <EM>Communications of the ACM</EM> 21(7):558<ENDASH/>565.</REFERENCE>

  <REFERENCE>Lampson, Butler, J. J. Horning, R.  London, J. G. Mitchell, and G. K.
    Popek.  1981.  Report on the programming language Euclid.  Technical
    report, Computer Systems Research Group, University of Toronto.</REFERENCE>

  <REFERENCE>Landin, Peter.  1965.  A correspondence between Algol 60 and Church's
    lambda notation: Part I.  <EM>Communications of the ACM</EM>
    8(2):89<ENDASH/>101.</REFERENCE>

  <REFERENCE>Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage
    collector based on the lifetimes of objects. <EM>Communications of
      the ACM</EM> 26(6):419<ENDASH/>429.</REFERENCE>

  <REFERENCE>Liskov, Barbara H., and Stephen N. Zilles.  1975.  Specification
    techniques for data abstractions.  <EM>IEEE Transactions on Software
      Engineering</EM> 1(1):7<ENDASH/>19.</REFERENCE>

  <REFERENCE>McAllester, David Allen.  1978.  A three-valued truth-maintenance
    system.  Memo 473, MIT Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>McAllester, David Allen.  1980.  An outlook on truth maintenance.
    Memo 551, MIT Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>McCarthy, John.  1967.  A basis for a mathematical theory of
    computation.  In <EM>Computer Programing and Formal Systems</EM>, edited
    by P. Braffort and D. Hirschberg.  North-Holland.</REFERENCE>

  <REFERENCE>McDermott, Drew, and Gerald Jay Sussman.  1972. Conniver reference
    manual.  Memo 259, MIT Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>Miller, Gary L.  1976.  Riemann's Hypothesis and tests for primality.
    <EM>Journal of Computer and System Sciences</EM> 13(3):300<ENDASH/>317.</REFERENCE>

  <REFERENCE>Miller, James S., and Guillermo J. Rozas. 1994.  Garbage collection is
    fast, but a stack is faster.  Memo 1462, MIT Artificial Intelligence
    Laboratory.</REFERENCE>

  <REFERENCE>Moon, David.  1978.  MacLisp reference manual, Version 0.  Technical
    report, MIT Laboratory for Computer Science.</REFERENCE>

  <REFERENCE>Morris, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience
    with an applicative string processing language.  In <EM>Proceedings
      of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of
      Programming Languages.</EM></REFERENCE>

  <REFERENCE>Phillips, Hubert.  1934. <EM>The Sphinx Problem Book</EM>.  London: Faber
    and Faber.</REFERENCE>

  <REFERENCE>Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.
    <EM>Journal of Number Theory</EM> 12:128<ENDASH/>138.</REFERENCE>

  <REFERENCE>Raymond, Eric.  1996. <EM>The New Hacker's Dictionary.</EM> 3rd edition.
    Cambridge, MA: MIT Press.</REFERENCE>

  <REFERENCE>Raynal, Michel. 1986. <EM>Algorithms for Mutual Exclusion.</EM>
    Cambridge, MA: MIT Press.</REFERENCE>

  <REFERENCE>Rees, Jonathan A., and Norman I. Adams IV. 1982.  T: A dialect of Lisp
    or, lambda: The ultimate software tool.  In <EM>Conference Record of
      the 1982 ACM Symposium on Lisp and Functional Programming,</EM> pp.
    114<ENDASH/>122.</REFERENCE>

  <REFERENCE>Rivest, Ronald, Adi Shamir, and Leonard Adleman.  1977.  A method for
    obtaining digital signatures and public-key cryptosystems. Technical
    memo LCS/TM82, MIT Laboratory for Computer Science.</REFERENCE>

  <REFERENCE>Robinson, J. A. 1965.  A machine-oriented logic based on the
    resolution principle.  <EM>Journal of the ACM</EM> 12(1):23.</REFERENCE>

  <REFERENCE>Robinson, J. A. 1983.  Logic programming<EMDASH/>Past, present, and future.
    <EM>New Generation Computing</EM> 1:107<ENDASH/>124.</REFERENCE>

    <WEB_ONLY>
      <REFERENCE>Sagade, Y. 2015. <LINK address="http://www.ysagade.nl/2015/04/12/sicp-change-growth/">SICP exercise 1.14</LINK>
      </REFERENCE>
    </WEB_ONLY>
    
  <REFERENCE>Spafford, Eugene H.  1989.  The Internet Worm: Crisis and aftermath.
    <EM>Communications of the ACM</EM> 32(6):678<ENDASH/>688.</REFERENCE>

  <REFERENCE>Steele, Guy Lewis, Jr.  1977.  Debunking the <QUOTE>expensive procedure
      call</QUOTE> myth.  In <EM>Proceedings of the National Conference of the
      ACM,</EM> pp. 153<ENDASH/>162.</REFERENCE>

  <REFERENCE>Steele, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An
    interpreter for the extended lambda calculus.  Memo 349, MIT
    Artificial Intelligence Laboratory.</REFERENCE>

  <REFERENCE>Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.
    Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  <EM>The Hacker's Dictionary.</EM> New York: Harper 
<AMP/> Row.</REFERENCE>

  <REFERENCE>Stoy, Joseph E.  1977.  <EM>Denotational Semantics.</EM> Cambridge, MA:
    MIT Press.</REFERENCE>

  <REFERENCE>Sussman, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic
    techniques in computer-aided circuit analysis.  <EM>IEEE Transactions
      on Circuits and Systems</EM> CAS-22(11):857<ENDASH/>865.</REFERENCE>

  <REFERENCE>Sussman, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints<EMDASH/>A
    language for expressing almost-hierarchical descriptions.  <EM>AI
      Journal</EM> 14:1<ENDASH/>39.</REFERENCE>

  <REFERENCE>Sussman, Gerald Jay, and Jack Wisdom.  1992. Chaotic evolution of the
    solar system.  <EM>Science</EM> 257:256<ENDASH/>262.</REFERENCE>

  <REFERENCE>Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.
    Microplanner reference manual.  Memo 203A, MIT Artificial Intelligence
    Laboratory.</REFERENCE>

  <REFERENCE>Sutherland, Ivan E.  1963.  SKETCHPAD: A man-machine graphical
    communication system.  Technical report 296, MIT Lincoln Laboratory.</REFERENCE>

  <REFERENCE>Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978.
    Data type specification: Parameterization and the power of
    specification techniques. In <EM>Conference Record of the Tenth Annual ACM
      Symposium on Theory of Computing</EM>, pp. 119<ENDASH/>132.</REFERENCE>

  <REFERENCE>Turner, David.  1981.  The future of applicative languages.  In <EM>Proceedings of the 3rd European Conference on Informatics,</EM> Lecture
    Notes in Computer Science, volume 123. New York: Springer-Verlag, pp.
    334<ENDASH/>348.</REFERENCE>

  <REFERENCE>Wand, Mitchell.  1980.  Continuation-based program transformation
    strategies.  <EM>Journal of the ACM</EM> 27(1):164<ENDASH/>180.</REFERENCE>

  <REFERENCE>Waters, Richard C.  1979.  A method for analyzing loop programs.  <EM>IEEE Transactions on Software Engineering</EM> 5(3):237<ENDASH/>247.</REFERENCE>

  <REFERENCE>Winston, Patrick. 1992. <EM>Artificial Intelligence</EM>.  3rd edition.
    Reading, MA: Addison-Wesley.</REFERENCE>

  <REFERENCE>Zabih, Ramin, David McAllester, and David Chapman.  1987.
    Non-deterministic Lisp with dependency-directed backtracking.
    <EM>AAAI-87</EM>, pp. 59<ENDASH/>64.</REFERENCE>

  <REFERENCE>Zippel, Richard.  1979.  Probabilistic algorithms for sparse
    polynomials.  Ph.D. dissertation, Department of Electrical Engineering
    and Computer Science, MIT.</REFERENCE>

  <REFERENCE>Zippel, Richard.  1993.  <EM>Effective Polynomial Computation.</EM>
    Boston, MA: Kluwer Academic Publishers.</REFERENCE>

</REFERENCES>
