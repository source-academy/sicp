[{"id":"/sicpjs/4.2.1","tag":"TITLE","body":"4.2.1  \n    Normal Order and Applicative Order"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"1.1","href":"/sicpjs/1.1"},{"body":", where we began\n    our discussion of models of evaluation, we noted that\n    JavaScript\n    is an ","tag":"#text"},{"tag":"EM","child":[{"body":"applicative-order","tag":"#text"}]},{"body":" language, namely, that all the arguments to\n    JavaScriptfunctions\n    are evaluated when the\n    function\n    is applied.  In contrast, ","tag":"#text"},{"tag":"EM","child":[{"body":"normal-order","tag":"#text"}]},{"body":" languages delay evaluation of\n    function\n    arguments until the actual argument values are needed. Delaying evaluation of\n    function\n    arguments until the last possible moment (e.g., until they are required by a\n    primitive operation) is called \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"lazy evaluation","tag":"#text"}]},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/4.2.1#footnote-1"},{"body":" Consider the\n    function","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=2&variant=lazy&prgrm=PTAEGUEkGEAVQFLlAFgHQCY0EYBQuQIB7AVwCcBjAU1AEEKBDAEyoFsBPUIgByoDsAzqAAuACwCWQ7mSIBzMg1YEw4vqAA2DAF6dWRFmlDRRRIgJoAicKUo0A5Rgsiiy56ApFW3BmRoB3cTFQAWEycQphUD0WXAAzEj4I8SI1UPYAfVYqAAoGABpQACMASlAAb1xQKtBfYXI1BlAAXhbQAAZQAH5QbFAALiKAbgBIXABffDTMnLaC0SpmbL4SdXVi4sGgA","body":"function try_me(a, b) {\n    return a === 0 ? 1 : b;\t\n} "},{"body":"\n    Evaluating\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"try_me(0, head(null));"},{"body":"\n\tsignals\n      \n    an error in\n    JavaScript.\n    With lazy evaluation, there would be no error.  Evaluating the\n    statement\n    would return 1, because the argument\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"head(null)"},{"body":"\n    would never be evaluated.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    An example that exploits lazy evaluation is the\n    declaration\n    of a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":3,"program":"chap=2&variant=lazy&prgrm=PTAEGUEkGEAVQFLlAFgHQCY0EYBQuBjAewDsBnAF1AA8zQBeUEgVwBtWBufECI5gJwIBTUAEECAQwAmQgLYBPUEQAOQ8qAoALAJZ1l-IgHN+E2bh7aSoVhIBei2URlpQ0TUSJkRAInB9BIgDlGN4aROZgFESgxLLKEvwiAO7aWqCU-NoEVI4yuABmzCTZ2qSgRaxCZGQAFMQkUqmlJAA05WTMEqwA+gBuXcxCbULUwsoUzV19A0IAlKAA3qDLK7groIkUAlb1jRNlAPygI2P7JFP9rIOgAFztnT2Xg1wAvvgVVbW63SzsNbSzNqaITSf5kQGgRpkZQ2eQ1bxCfgGfh3WjpdxsKRMIhUABGIl+rG8s1mHCAA","body":"function unless(condition, usual_value, exceptional_value) {      \n    return condition ? exceptional_value : usual_value;\n} "},{"body":"\n    that can be used in\n    statements\n    such as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":10,"program":"chap=2&variant=lazy&prgrm=PTAEGUEkGEAVQFLlAFgHQCY0EYBQuQIB7AVwCcBjAU1AEEKBDAEyoFsBPUIgByoDsAzqAAuACwCWQ7mSIBzMg1YEw4vqAA2DAF6dWRFmlDRRRIgJoAicKUo0A5Rgsiiy56ApFW3BmRoB3cTFQAWEycQphUD0WXAAzEj4I8SI1BPUqAQEACg8+JkDkvgAaUBIBEgZ1AH0AN0qSKhKqAA9qbmFCytr6qgBKUABvUGGR3BHQX2FyNVz8jpTQAH5QFrb5vi669QbQAC5S8s2egG5cAF98XJDQZqEAXlA+EnV1U9w0jOzJKqeXrNveiVRFRmP8BIDQPkBNxNOwshYqGQZGR9rdgiZnkxHkRIgAjGi-dQWXq9Y5AA","body":"unless(is_null(xs), head(xs), display(\"error: xs should not be null\")); "},{"body":"\n    This won't work in an applicative-order language because both the\n    usual value and the exceptional value will be evaluated before\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":" is called (compare\n    exercise ","tag":"#text"},{"tag":"REF","body":"1.6","href":"/sicpjs/1.1.7#ex-1.6"},{"body":"). An advantage of lazy evaluation is\n    that some\n    functions,\n    such as ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":", can do useful computation\n    even if evaluation of some of their arguments would produce errors or\n    would not terminate.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    If the body of a\n    function\n    is entered before an argument has been evaluated we say that the\n    function\n    is \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"non-strict","tag":"#text"}]},{"body":" in that argument.  If the argument is evaluated before\n    the body of the\n    function\n    is entered we say that the\n    function\n    is \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"strict","tag":"#text"}]},{"body":" in that\n    argument.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/4.2.1#footnote-2"},{"body":"\n    In a purely applicative-order language, all\n    functions\n    are strict in each argument.  In a purely normal-order language, all compound\n    functions\n    are non-strict in each argument, and primitive\n    functions\n    may be either strict or non-strict.  There are also languages (see\n    exercise ","tag":"#text"},{"tag":"REF","body":"4.29","href":"/sicpjs/4.2.2#ex-4.29"},{"body":") that give\n    programmers detailed control over the strictness of the\n    functions\n    they define.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    A striking example of a\n    function\n    that can usefully be made non-strict is\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":"\n    (or, in general, almost any constructor for data structures).\n    One can do useful computation, combining elements to form\n    data structures and operating on the resulting data structures,\n    even if the values of the elements are not known.  It makes perfect\n    sense, for instance, to compute the length of a list without knowing\n    the values of the individual elements in the list.  We will exploit\n    this idea in section ","tag":"#text"},{"tag":"REF","body":"4.2.3","href":"/sicpjs/4.2.3"},{"body":" to implement the\n    streams of chapter ","tag":"#text"},{"tag":"REF","body":"3","href":"/sicpjs/3"},{"body":" as lists formed of non-strict\n    pairs.","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.23","id":"#ex-4.23","child":[{"body":"\n\tSuppose that (in ordinary applicative-order JavaScript) we define\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":" as shown above and then define\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial"},{"body":" in terms\n    of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":" as\n\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":8,"program":"chap=2&variant=lazy&prgrm=PTAEGUEkGEAVQFLlAFgHQCY0EYBQuQIB7AVwCcBjAU1AEEKBDAEyoFsBPUIgByoDsAzqAAuACwCWQ7mSIBzMg1YEw4vqAA2DAF6dWRFmlDRRRIgJoAicKUo0A5Rgsiiy56ApFW3BmRoB3cTFQAWEycQphUD0WXAAzEj4I8SI1BPUqAQEACg8+JkDkvgAaUBIBEgZ1AH0AN0qSKhKqAA9qbmFCytr6qgBKUABvUGGR3BHQX2FyNVz8jpTQAH5QFrb5vi669QbQAC5S8s2egG5cAF98QmtyajpGFg4uXkERCSkZeUVXVQ1tXX0qIZjKZzKArDZbg4nMIXIQYe5PN5fKAAkEQmEIlEAfh4ol1qBYgwIkQwpUsnx+gMxiNJtNSnx0plyaAALxs0DYIrU8Y83mgNQAKgJRJhpPUzIAtBzely+XKRtheqcLnERSTxGSAKxKoA","body":"function factorial(n) {\n    return unless(n === 1,\n                  n * factorial(n - 1),\n                  1);\n} "},{"body":"\n    What happens if we attempt to evaluate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"factorial(5)"},{"body":"?\n      \n    Will our\n    functions\n    work in a normal-order language?\n    ","tag":"#text"}],"solution":[{"body":"\n      (provided by GitHub user joeng03)\nWhen evaluated in default (‘strict’) mode, the code undergoes applicative order reduction and runs into an infinite loop because it needs to evaluate the arguments of the unless function, but the factorial function does not have a terminating condition.\nWhen evaluated in lazy mode, the code undergoes normal order reduction. It produces the correct output because the unless function is applied before its arguments are evaluated.      \n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 4.24","id":"#ex-4.24","child":[{"body":"\n    Ben Bitdiddle and Alyssa P. Hacker\n    \n    disagree over the importance of lazy\n    evaluation for implementing things such as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":". Ben points out that it's possible\n    to implement ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":" in applicative order as a\n    syntactic\n    form. Alyssa counters that, if one did that,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":" would be merely syntax, not a\n    function\n    that could be used in conjunction with higher-order\n    functions.\n    Fill in the details on both sides of the argument.\n    \n\tShow how to implement ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":" as a derived\n\tcomponent (like operator combination),\n\tby catching in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"evaluate"},{"body":"\n\tapplications whose function expression is the name\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":".\n\tGive an example of a situation where it might be useful to have\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unless"},{"body":" available as a function,\n\trather than as a syntactic form.\n      ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/4.2.1#footnote-link-1","child":[{"body":"The difference between the\n    \"","tag":"#text"},{"body":"lazy","tag":"#text"},{"body":"\" terminology and the \"","tag":"#text"},{"body":"normal-order","tag":"#text"},{"body":"\"\n    terminology is somewhat fuzzy.  Generally, \"","tag":"#text"},{"body":"lazy","tag":"#text"},{"body":"\" refers to the\n    mechanisms of particular evaluators, while \"","tag":"#text"},{"body":"normal-order","tag":"#text"},{"body":"\"\n    refers to the semantics of languages, independent of any particular\n    evaluation strategy.  But this is not a hard-and-fast distinction, and the\n    two terminologies are often used interchangeably.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/4.2.1#footnote-link-2","child":[{"body":"The \"","tag":"#text"},{"body":"strict","tag":"#text"},{"body":"\" versus \"","tag":"#text"},{"body":"non-strict","tag":"#text"},{"body":"\"\n    terminology means essentially the same as\n    \"","tag":"#text"},{"body":"applicative-order","tag":"#text"},{"body":"\" versus \"","tag":"#text"},{"body":"normal-order,","tag":"#text"},{"body":"\" except\n    that it refers to individual\n    functions\n    and arguments rather than to the language as a whole.  At a conference on\n    programming languages you might hear someone say, \"","tag":"#text"},{"body":"The normal-order\n    language \n    \n    Hassle has certain strict primitives.  Other\n    functions\n    take their arguments by lazy evaluation.","tag":"#text"},{"body":"\"","tag":"#text"}]}]