<SUBSECTION>
  <NAME>
    Interfacing Compiled Code to the Evaluator
  </NAME>

  <LABEL NAME="sec:interfacing-compiled-code"/>

  <INDEX>compiler for JavaScript<SUBINDEX>interfacing to evaluator<OPEN/></SUBINDEX></INDEX>
  <INDEX>compiler for JavaScript<SUBINDEX>running compiled code<OPEN/></SUBINDEX></INDEX>
  <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>modified for compiled code<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    We have not yet explained how to load compiled code into the evaluator
    machine or how to run it.  We will assume that the explicit-control-evaluator
    machine has been defined as in
    section<SPACE/><REF NAME="sec:running-evaluator"/>, with the additional
    operations specified in footnote<SPACE/><REF NAME="foot:compiler-ops"/> (section<SPACE/><REF NAME="sec:compiling-components"/>).
    We will implement a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><USE>compile_and_go</USE></INDEX> 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-and-go</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_and_go</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    that compiles a
    <SPLITINLINE>
      <SCHEME>Scheme expression,</SCHEME>
      <JAVASCRIPT>JavaScript program,</JAVASCRIPT>
    </SPLITINLINE>
    loads the resulting object code into the evaluator machine,
    and causes the machine to run the code in the
    evaluator global environment, print the result, and
    enter the evaluator<APOS/>s driver loop.  We will also modify the evaluator
    so that interpreted
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	components
      </JAVASCRIPT>
    </SPLITINLINE>
    can call compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    as well as interpreted ones.  We can then put a compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    into the machine and use the
    evaluator to call it:
    <SNIPPET>
      <NAME>compile_and_go_example</NAME>
      <REQUIRES>compile_and_go</REQUIRES>
      <SCHEME>
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
      </SCHEME>
      <SCHEMEOUTPUT>
;;; EC-Eval value:
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
compile_and_go(parse(`
function factorial(n) {
    return n === 1
           ? 1
           : factorial(n - 1) * n;
}
                     `));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
EC-evaluate value:
undefined
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <SCHEMEPROMPT>
;;; EC-Eval input:
      </SCHEMEPROMPT>
      <SCHEME>
(factorial 5)
      </SCHEME>
      <SCHEMEOUTPUT>
;;; EC-Eval value:
120
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
EC-evaluate input:
      </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
factorial(5);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
EC-evaluate value:
120
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    To allow the evaluator to handle compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    (for example,
    to evaluate the call to <SCHEMEINLINE>factorial</SCHEMEINLINE> above),
    we need to change the code at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    (section<SPACE/><REF NAME="sec:procedure-application"/>) so that it
    recognizes compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    (as distinct from compound or primitive
    <SPLITINLINE>
      <SCHEME>procedures)</SCHEME>
      <JAVASCRIPT>functions)</JAVASCRIPT>
    </SPLITINLINE>
    and transfers control directly to the entry point of the
    compiled code:<FOOTNOTE>Of course, compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    as well as interpreted
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    are compound (nonprimitive).  For compatibility with the terminology used
    in the explicit-control evaluator, in this section we will use
    <QUOTE>compound</QUOTE> to mean interpreted (as opposed to
    compiled).</FOOTNOTE>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>apply_dispatch</DECLARATION><SUBINDEX>modified for compiled code</SUBINDEX></INDEX>
      <INDEX><DECLARATION>compiled_apply</DECLARATION></INDEX> 
      <SCHEME>
apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (test (op compiled-procedure?) (reg proc))  
  (branch (label compiled-apply))
  (goto (label unknown-procedure-type))

compiled-apply
  (restore continue)
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  </SCHEME>
  <JAVASCRIPT>
"apply_dispatch",
  test(list(op("is_primitive_function"), reg("fun"))),
  branch(label("primitive_apply")),
  test(list(op("is_compound_function"), reg("fun"))),
  branch(label("compound_apply")),
  test(list(op("is_compiled_function"), reg("fun"))),
  branch(label("compiled_apply")),
  go_to(label("unknown_function_type")),
"compiled_apply",
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
        Note the restore of <SCHEMEINLINE>continue</SCHEMEINLINE> at
        <SPLITINLINE>
          <SCHEME>
          <SCHEMEINLINE>compiled-apply</SCHEMEINLINE>.</SCHEME>
          <JAVASCRIPT>
	          <JAVASCRIPTINLINE>compiled_apply</JAVASCRIPTINLINE>.
          </JAVASCRIPT>
        </SPLITINLINE>
        Recall that the evaluator was arranged so that at
        <SPLITINLINE>
          <SCHEME><SCHEMEINLINE>apply-dispatch</SCHEMEINLINE>,</SCHEME>
          <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>,
          </JAVASCRIPT>
        </SPLITINLINE>
        the continuation would be at the top of the stack.  The compiled code entry
        point, on the other hand, expects the continuation to be in
        <SCHEMEINLINE>continue</SCHEMEINLINE>, so
        <SCHEMEINLINE>continue</SCHEMEINLINE> must be
        restored before the compiled code is executed.
      </SCHEME>
      <JAVASCRIPT>
        At
	<JAVASCRIPTINLINE>compiled_apply</JAVASCRIPTINLINE>, as at
	<JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE>, we push a marker to the stack
        so that a subsequent return statement
        can revert the stack to this state.
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    To enable us to run some compiled code when we start the evaluator
    machine, we add a <SCHEMEINLINE>branch</SCHEMEINLINE> instruction at
    the beginning of the evaluator machine, which causes the machine to
    go to a new entry point if the <SCHEMEINLINE>flag</SCHEMEINLINE> register 
    is set.<FOOTNOTE>Now that the evaluator machine starts
    with a <SCHEMEINLINE>branch</SCHEMEINLINE>, we must always initialize the
    <SCHEMEINLINE>flag</SCHEMEINLINE> register before starting the evaluator
    machine.  To start the machine at its ordinary
    <SPLITINLINE>
      <SCHEME>
	read-eval-print
      </SCHEME>
      <JAVASCRIPT>
	read-evaluate-print
      </JAVASCRIPT>
    </SPLITINLINE>
    loop, we
    could use
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>start_eceval</DECLARATION></INDEX> 
      <NAME>start_eceval</NAME>
      <REQUIRES>compile_and_go</REQUIRES>
      <EXAMPLE>compile_and_go_example</EXAMPLE>
      <SCHEME>
(define (start-eceval)
  (set! the-global-environment (setup-environment))
  (set-register-contents! eceval 'flag false)
  (start eceval))
      </SCHEME>
      <JAVASCRIPT>
function start_eceval() {
    set_register_contents(eceval, "flag", false);
    return start(eceval);
}
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
      </JAVASCRIPT_RUN>
    </SNIPPET></FOOTNOTE>
    <SNIPPET LATEX="yes">
      <SCHEME>
  (branch (label external-entry))      ; branches if $\texttt{flag}$ is set
read-eval-print-loop
  (perform (op initialize-stack))
  $\ldots$
      </SCHEME>
      <JAVASCRIPT>
$\texttt{ }\texttt{ }$branch(label("external_entry")), // branches if flag is set    
"read_evaluate_print_loop",
  perform(list(op("initialize_stack"))),
  $\ldots$
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>External-entry</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The code at <JAVASCRIPTINLINE>external_entry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    assumes that the machine is started with <SCHEMEINLINE>val</SCHEMEINLINE>
    containing the location of an instruction sequence that puts a result into
    <SCHEMEINLINE>val</SCHEMEINLINE> and ends with
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Starting at this entry point jumps to the location designated
    by <SCHEMEINLINE>val</SCHEMEINLINE>, but first assigns
    <SCHEMEINLINE>continue</SCHEMEINLINE> so that execution will return to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>print-result</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>print_result</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which prints the value in <SCHEMEINLINE>val</SCHEMEINLINE> and then goes to
    the beginning of the evaluator<APOS/>s
    <SPLITINLINE>
      <SCHEME>
	read-eval-print
      </SCHEME>
      <JAVASCRIPT>
	read-evaluate-print
      </JAVASCRIPT>
    </SPLITINLINE>
    loop.<FOOTNOTE>Since
    a compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is an object that the system may try to print, we also modify the system
    print operation
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>user-print</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>user_print</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    (from section<SPACE/><REF NAME="sec:running-eval"/>) so that it will not
    attempt to print the components of a compiled
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <JAVASCRIPT>function:</JAVASCRIPT>
      </SPLITINLINE>
      <SNIPPET EVAL="no">
	<INDEX><DECLARATION>user_print</DECLARATION><SUBINDEX>modified for compiled code</SUBINDEX></INDEX>
	<NAME>user_print_2</NAME>
	<SCHEME>
        (define (user-print object)
        (cond ((compound-procedure? object)
              (display (list 'compound-procedure
              (procedure-parameters object)
              (procedure-body object)
              '&lt;procedure-env&gt;)))
              ((compiled-procedure? object)
              (display '&lt;compiled-procedure&gt;))
              (else (display object))))
      </SCHEME>
      <JAVASCRIPT>
function user_print(string, object) {
    function prepare(object) {
        return is_compound_function(object)
               ? "&lt; compound function &gt;"
               : is_primitive_function(object)
               ? "&lt; primitive function &gt;"
               : is_compiled_function(object)
               ? "&lt; compiled function &gt;"
               : is_pair(object)
               ? pair(prepare(head(object)),
                      prepare(tail(object)))
               : object;
    }
    display(string + " " + stringify(prepare(object)));
}
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
function user_print(prompt_string, object) {
   function to_string(object) {
       return is_compound_function(object)
              ? "&lt;compound-function&gt;"
              : is_compiled_function(object)
              ? "&lt;compiled-function&gt;"
              : is_primitive_function(object)
              ? "&lt;primitive-function&gt;"
              : is_pair(object)
              ? "[" + to_string(head(object)) + ", "
                    + to_string(tail(object)) + "]"
              : stringify(object);
    }
    display(prompt_string + "\n" + to_string(object) + "\n----------------------------");
}
      </JAVASCRIPT_RUN>
    </SNIPPET></FOOTNOTE>
    <SNIPPET EVAL="no">
      <INDEX><DECLARATION>external_entry</DECLARATION></INDEX> 
      <SCHEME>
external-entry
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (reg val))
      </SCHEME>
      <JAVASCRIPT>
"external_entry",
  perform(list(op("initialize_stack"))),
  assign("env", list(op("get_global_environment"))),
  assign("continue", label("print_result")),
  go_to(reg("val")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>modified for compiled code<CLOSE/></SUBINDEX></INDEX>
  
  <TEXT>
    Now we can use the following
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to compile a
    <SPLITINLINE>
      <SCHEME>procedure definition,</SCHEME>
      <JAVASCRIPT>function declaration,</JAVASCRIPT>
    </SPLITINLINE>
    execute the compiled code, and run the
    <SPLITINLINE>
      <SCHEME>
	read-eval-print
      </SCHEME>
      <JAVASCRIPT>
	read-evaluate-print
      </JAVASCRIPT>
    </SPLITINLINE>
    loop so
    we can try the
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    <SPLIT>
      <JAVASCRIPT>
	For the interpreted program to refer to the names that
	are declared at top level in the compiled program, we
        <INDEX>scanning out declarations<SUBINDEX>in compiler</SUBINDEX></INDEX>	
	scan out the top-level names and 
	extend the global environment by binding these names to
	<JAVASCRIPTINLINE>"*unassigned*"</JAVASCRIPTINLINE>,
	knowing that the compiled code will assign them 
	the correct values.
      </JAVASCRIPT>
    </SPLIT>
    Because we want the compiled code to
    <SPLITINLINE>
      <SCHEME>return</SCHEME>
      <JAVASCRIPT>proceed</JAVASCRIPT>
    </SPLITINLINE>
    to the location in
    <SCHEMEINLINE>continue</SCHEMEINLINE> with its result in
    <SCHEMEINLINE>val</SCHEMEINLINE>, we compile the
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
      <JAVASCRIPT>program</JAVASCRIPT>
    </SPLITINLINE>
    with a target of <SCHEMEINLINE>val</SCHEMEINLINE> and a
    linkage of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	      <JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>.
        This is the only place other than return expressions to use this linkage.
      </JAVASCRIPT>
    </SPLITINLINE>
    In order to transform the
    object code produced by the compiler into executable instructions
    for the evaluator register machine, we use the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>assemble</SCHEMEINLINE> from the
    register-machine simulator
    (section<SPACE/><REF NAME="sec:assembler"/>).  We then initialize
    the <SCHEMEINLINE>val</SCHEMEINLINE> register to point to the list
    of instructions, set the
    <SCHEMEINLINE>flag</SCHEMEINLINE> so that the evaluator will go to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>external-entry</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>external_entry</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    and start the evaluator.
    <SNIPPET HIDE="yes">
      <NAME>display_instructions</NAME>
      <JAVASCRIPT>
function stringify_list(xs) {
    return is_null(member(head(xs),
                   list("assign", "perform", "op", "label", "branch",
                        "go_to", "save", "restore", "reg", "constant")))
           ? "list(" + comma_separated(xs) + ")"
           : head(xs) + "(" + comma_separated(tail(xs)) + ")";
}
function comma_separated(elements) {
    return accumulate((s, acc) => stringify_instruction(s) +
                                  (acc === "" ? "" : ", " + acc),
                      "", elements);
}
function stringify_instruction(x) {
    return is_string(x) || is_number(x) || is_undefined(x) || is_null(x)
           ? stringify(x)
           : stringify_list(x);
}
function display_instructions(instructions) {
    return for_each(i => {display(stringify_instruction(i) + ","); },
                    instructions);
}
      </JAVASCRIPT>
    </SNIPPET>
    <!-- FIXME: remove no_args, first_arg etc -->
    <SNIPPET HIDE="yes">
      <NAME>eceval_2</NAME>
      <REQUIRES>prompt_for_input</REQUIRES>
      <REQUIRES>the_global</REQUIRES>
      <JAVASCRIPT>

const eceval_operations = 
    list(
      // args
      list("arg_expressions"      , arg_expressions),
      list("function_expression"  , function_expression),
      list("is_null"
                                  , is_null),
      list("head"        , head),
      list("is_last_argument_expression"
                                  , a => is_null(tail(a))),
      list("tail"        , tail),

      //arg
      list("empty_arglist"        , () => null),
      list("adjoin_arg"           , (val, argl) => append(argl,
                                                      list(val))),

      // comp (sequence)
      list("first_statement"     , first_statement),
      list("rest_statements"     , rest_statements),
      list("is_last_statement"   , is_last_statement),
      list("sequence_statements" , sequence_statements),

      // eval functions from meta-circular evaluator
      list("is_literal"  , is_literal),
      list("literal_value"       , literal_value),
      list("is_name"             , is_name),
      list("symbol_of_name"      , symbol_of_name),
      list("is_assignment"       , is_assignment),
      list("assignment_symbol"   , assignment_symbol),
      list("assignment_value_expression"
                                 , assignment_value_expression),
      list("assign_symbol_value" , assign_symbol_value),
      list("is_declaration"      , is_declaration),
      list("declaration_symbol"  , declaration_symbol),
      list("declaration_value_expression"
                                 , declaration_value_expression),
      list("assign_symbol_value" , assign_symbol_value),
      list("is_lambda_expression", is_lambda_expression),
      list("lambda_parameter_symbols"
                                 , lambda_parameter_symbols),
      list("lambda_body"         , lambda_body),
      list("is_return_statement" , is_return_statement),
      list("return_expression"   , return_expression),
      list("is_conditional"
                                 , is_conditional),
      list("conditional_predicate"
				 , conditional_predicate),
      list("conditional_consequent"
                                 , conditional_consequent),
      list("conditional_alternative"
                                 , conditional_alternative),
      list("is_sequence"         , is_sequence),
      list("is_block"            , is_block),
      list("block_body"          , block_body),
      list("scan_out_declarations"
                                 , scan_out_declarations),
      list("list_of_unassigned"  , list_of_unassigned),
      list("is_application"      , is_application),
      list("is_primitive_function"
                                 , is_primitive_function),
      list("apply_primitive_function"
                                 , apply_primitive_function),
      list("is_compound_function", is_compound_function),
      list("function_parameters" , function_parameters),
      list("function_environment", function_environment),
      list("function_body"       , function_body),
      list("extend_environment"  , extend_environment),
      list("make_function"       , make_function),

      list("get_global_environment"
                                 , get_global_environment),
      list("set_global_environment"
                                 , set_global_environment),

      // Unsorted
      list("is_function_declaration"  , is_function_declaration),
      list("function_declaration_body"  , function_declaration_body),
      list("function_declaration_parameters"  , function_declaration_parameters),
      list("function_declaration_name"  , function_declaration_name),
      list("function_decl_to_constant_decl", function_decl_to_constant_decl),
      list("declaration_symbol"  , declaration_symbol),
      list("is_operator_combination", is_operator_combination),
      list("operator_combination_to_application", operator_combination_to_application),

      // generic helpers
      list("is_truthy", is_truthy),
      list("is_falsy"                , x => ! is_truthy(x)), 
      list("is_null", is_null),
      list("is_pair"                 , is_pair),
      list("is_number"               , is_number),
      list("append"                  , append),
      list("pair"                    , pair),

      list(
        "lookup_symbol_value"        , lookup_symbol_value),
      list("get_global_environment" , get_global_environment),
      list("set_global_environment" , set_global_environment),

      list("user_read"               , prompt),
      list("user_print"              , user_print),
      list("parse"                   , parse),
      list("display"                 , display),
      list("make_compiled_function"  , make_compiled_function),
      list("is_compiled_function"    , is_compiled_function),
      list("compiled_function_env"   , compiled_function_env),
      list("compiled_function_entry" , compiled_function_entry),
      list("list"                    , list)
      
    );

const eceval_controller =
list(
      branch(label("external_entry")), // branches if flag is set    

      "read_evaluate_print_loop",
      perform(list(op("initialize_stack"))),
      assign("comp", list(op("user_read"), constant("EC-evaluate input:"))),
      test(list(op("is_null"), reg("comp"))),
      branch(label("evaluator_done")),
      assign("comp", list(op("parse"), reg("comp"))),
      assign("env", list(op("get_global_environment"))),

      assign("val", list(op("scan_out_declarations"), reg("comp"))),
      save("comp"), // temporarily store to comp
      assign("comp", list(op("list_of_unassigned"), reg("val"))),
      assign("env", list(op("extend_environment"), 
                         reg("val"), reg("comp"), reg("env"))),
      perform(list(op("set_global_environment"), reg("env"))),
      restore("comp"),
      assign("continue", label("print_result")),
      go_to(label("eval_dispatch")),

      "external_entry",
      perform(list(op("initialize_stack"))),
      assign("env", list(op("get_global_environment"))),
      assign("continue", label("print_result")),
      go_to(reg("val")),

      "print_result",
      perform(list(op("user_print"),
                   constant("EC-evaluate value:"), reg("val"))),
      go_to(label("read_evaluate_print_loop")), 

      "eval_dispatch",
      test(list(op("is_literal"), reg("comp"))),
      branch(label("ev_literal")),
      test(list(op("is_name"), reg("comp"))),
      branch(label("ev_name")),
      test(list(op("is_operator_combination"), reg("comp"))),
      branch(label("ev_operator_combination")),
      test(list(op("is_function_declaration"), reg("comp"))),
      branch(label("ev_function_declaration")),
      test(list(op("is_operator_combination"), reg("comp"))),
      branch(label("ev_operator_combination")),
      test(list(op("is_declaration"), reg("comp"))),
      branch(label("ev_declaration")),
      test(list(op("is_assignment"), reg("comp"))),
      branch(label("ev_assignment")),
      test(list(op("is_return_statement"), reg("comp"))),
      branch(label("ev_return")),
      test(list(op("is_conditional"), reg("comp"))),
      branch(label("ev_conditional")),
      test(list(op("is_lambda_expression"), reg("comp"))),
      branch(label("ev_lambda")),
      test(list(op("is_sequence"), reg("comp"))),
      branch(label("ev_sequence_start")),
      test(list(op("is_block"), reg("comp"))),
      branch(label("ev_block")),
      test(list(op("is_application"), reg("comp"))),
      branch(label("ev_application")),
      go_to(label("unknown_component_type")),

      "ev_return",
      revert_stack_to_marker(),
      restore("continue"),
      assign("comp", list(op("return_expression"), reg("comp"))),
      go_to(label("eval_dispatch")),

      "ev_literal",
      assign("val", list(op("literal_value"), reg("comp"))),
      go_to(reg("continue")),
      
      "ev_name",
      assign("comp", list(op("symbol_of_name"), reg("comp"))),
      assign("val", list(op("lookup_symbol_value"), reg("comp"), reg("env"))),
      go_to(reg("continue")),
      
      "ev_lambda",
      assign("unev", list(op("lambda_parameter_symbols"), reg("comp"))),
      assign("comp", list(op("lambda_body"), reg("comp"))),
      assign("val", list(op("make_function"),
                         reg("unev"), reg("comp"), reg("env"))),
      go_to(reg("continue")),

      "ev_operator_combination",
      assign("comp", list(op("operator_combination_to_application"),
                          reg("comp"), reg("env"))),
      
      "ev_application",
      save("continue"),
      save("env"),
      assign("unev", list(op("arg_expressions"), reg("comp"))),
      save("unev"),
      assign("comp", list(op("function_expression"), reg("comp"))),
      assign("continue", label("ev_appl_did_function_expression")),
      go_to(label("eval_dispatch")),
      
      "ev_appl_did_function_expression",
      restore("unev"), // the args
      restore("env"),
      assign("argl", list(op("empty_arglist"))),
      assign("fun", reg("val")), // the function_expression
      test(list(op("is_null"),
                reg("unev"))),
      branch(label("apply_dispatch")),
      save("fun"),
      
      "ev_appl_argument_expression_loop",
      save("argl"),
      assign("comp", list(op("head"), reg("unev"))),
      test(list(op("is_last_argument_expression"),
                reg("unev"))),
      branch(label("ev_appl_last_arg")),
      save("env"),
      save("unev"),
      assign("continue", label("ev_appl_accumulate_arg")),
      go_to(label("eval_dispatch")),
      
      "ev_appl_accumulate_arg",
      restore("unev"),
      restore("env"),
      restore("argl"),
      assign("argl", list(op("adjoin_arg"),
                          reg("val"), reg("argl"))),
      assign("unev", list(op("tail"), reg("unev"))),
      go_to(label("ev_appl_argument_expression_loop")),
      
      "ev_appl_last_arg",
      assign("continue", label("ev_appl_accum_last_arg")),
      go_to(label("eval_dispatch")),
      
      "ev_appl_accum_last_arg",
      restore("argl"),
      assign("argl", list(op("adjoin_arg"),
                          reg("val"), reg("argl"))),
      restore("fun"),
      go_to(label("apply_dispatch")),

"compiled_apply",
  push_marker_to_stack(),
  assign("val", list(op("compiled_function_entry"), reg("fun"))),
  go_to(reg("val")),
      
      "apply_dispatch",
  test(list(op("is_compiled_function"), reg("fun"))),
  branch(label("compiled_apply")),
      test(list(op("is_primitive_function"),
                reg("fun"))),
      branch(label("primitive_apply")),
      test(list(op("is_compound_function"),
                reg("fun"))),
      branch(label("compound_apply")),
      go_to(label("unknown_function_type")),

      "primitive_apply",
      assign("val", list(op("apply_primitive_function"), 
                         reg("fun"), 
                         reg("argl"))),
      restore("continue"),
      go_to(reg("continue")),

      "compound_apply",
      assign("unev", list(op("function_parameters"), reg("fun"))),
      assign("env", list(op("function_environment"), reg("fun"))),
      assign("env", list(op("extend_environment"), 
                         reg("unev"), reg("argl"), reg("env"))),
      assign("comp", list(op("function_body"), reg("fun"))),
      push_marker_to_stack(),
      assign("continue", label("return_undefined")),
      go_to(label("eval_dispatch")),

      "return_undefined",
      assign("val", constant(undefined)),
      revert_stack_to_marker(),
      restore("continue"),
      go_to(reg("continue")),

      "ev_block",
      assign("comp", list(op("block_body"), reg("comp"))),
      assign("val", list(op("scan_out_declarations"), reg("comp"))),

      save("comp"), // temporarily store to comp
      assign("comp", list(op("list_of_unassigned"), reg("val"))),
      assign("env", list(op("extend_environment"), 
                         reg("val"), 
                         reg("comp"), 
                         reg("env"))),
      restore("comp"),
      go_to(label("eval_dispatch")),

"ev_sequence_start",
      assign("unev", list(op("sequence_statements"), reg("comp"))),
      save("continue"),

"ev_sequence",
      assign("comp", list(op("first_statement"), reg("unev"))),
      test(list(op("is_last_statement"), reg("unev"))),
      branch(label("ev_sequence_last_statement")),
      save("unev"),
      save("env"),
      assign("continue", label("ev_sequence_continue")),
      go_to(label("eval_dispatch")),
      
"ev_sequence_continue",
      restore("env"),
      restore("unev"),
      assign("unev", list(op("rest_statements"), reg("unev"))),
      go_to(label("ev_sequence")),
 
"ev_sequence_last_statement",
      restore("continue"),
      go_to(label("eval_dispatch")),

      "ev_conditional",
      save("comp"), // save expression for later
      save("env"),
      save("continue"),
      assign("continue", label("ev_conditional_decide")),
      assign("comp", list(op("conditional_predicate"), reg("comp"))),
      go_to(label("eval_dispatch")), // evaluate the predicate
      
      "ev_conditional_decide",
      restore("continue"),
      restore("env"),
      restore("comp"),
      test(list(op("is_falsy"), reg("val"))),
      branch(label("ev_conditional_alternative")),
      
      "ev_conditional_consequent",
      assign("comp", list(op("conditional_consequent"), reg("comp"))),
      go_to(label("eval_dispatch")),
      
      "ev_conditional_alternative",
      assign("comp", list(op("conditional_alternative"), reg("comp"))),
      go_to(label("eval_dispatch")),
      
      "ev_assignment",
      assign("unev", list(op("assignment_symbol"), reg("comp"))),
      save("unev"), // save variable for later
      assign("comp", list(op("assignment_value_expression"), reg("comp"))),
      save("env"),
      save("continue"),
      assign("continue", label("ev_assignment_1")),
      go_to(label("eval_dispatch")), // evaluate assignment value
      
      "ev_assignment_1",
      restore("continue"),
      restore("env"),
      restore("unev"),
      perform(list(op("assign_symbol_value"),
                   reg("unev"), reg("val"), reg("env"))),
      go_to(reg("continue")),
      
      "ev_function_declaration",
      assign("comp", list(op("function_decl_to_constant_decl"), reg("comp"))),
      
      "ev_declaration",
      assign("unev", list(op("declaration_symbol"),
                          reg("comp"))),
      save("unev"), // save variable for later
      assign("comp", list(op("declaration_value_expression"),
                          reg("comp"))),
      save("env"),
      save("continue"),
      assign("continue", label("ev_declaration_assign")),
      go_to(label("eval_dispatch")), // evaluate declaration value
      
      "ev_declaration_assign",
      restore("continue"),
      restore("env"),
      restore("unev"),
      perform(list(op("assign_symbol_value"),
                   reg("unev"), reg("val"), reg("env"))),
      assign("val", constant(undefined)),
      go_to(reg("continue")),
      
      // Error handling
      "unknown_component_type",
      assign("val", constant("Unknown expression type")),
      go_to(label("signal_error")),
      
      "unknown_function_type",
      restore("continue"), /// clean up stack (from apply_dispatch)
      assign("val", constant("Unknown function type")),
      go_to(label("signal_error")),
      
      "signal_error",
      perform(list(op("user_print"),
                   constant("EC-evaluator error:"), reg("comp"))),
      go_to(label("read_evaluate_print_loop")),
      
      "evaluator_done"
     );

const eceval =
    make_machine(list("comp", "env", "val", "fun",
                      "argl", "continue", "unev"),
                 eceval_operations,
                 eceval_controller);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>compile_and_go</DECLARATION></INDEX>
      <NAME>compile_and_go</NAME>
      <EXAMPLE>compile_and_go_example</EXAMPLE>
      <REQUIRES>headline_4_1_1</REQUIRES>
      <REQUIRES>scan_out_declarations</REQUIRES>
      <REQUIRES>list_of_unassigned</REQUIRES>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_3</REQUIRES>
      <REQUIRES>functions_4_1_4</REQUIRES>
      <REQUIRES>make_machine</REQUIRES>
      <REQUIRES>start</REQUIRES>
      <REQUIRES>compile</REQUIRES>
      <REQUIRES>make_instruction_sequence</REQUIRES>
      <REQUIRES>empty_instruction_sequence</REQUIRES>
      <REQUIRES>compile_linkage</REQUIRES>
      <REQUIRES>end_with_linkage</REQUIRES>
      <REQUIRES>compile_literal</REQUIRES>
      <REQUIRES>compile_assignment</REQUIRES>
      <REQUIRES>make_label</REQUIRES>
      <REQUIRES>compile_conditional</REQUIRES>
      <REQUIRES>compile_sequence</REQUIRES>
      <REQUIRES>make_compiled_function</REQUIRES>
      <REQUIRES>compile_lambda</REQUIRES>
      <REQUIRES>compile_lambda_body</REQUIRES>
      <REQUIRES>compile_return</REQUIRES>
      <REQUIRES>compile_block</REQUIRES>
      <REQUIRES>compile_application</REQUIRES>
      <REQUIRES>construct_arglist</REQUIRES>
      <REQUIRES>compile_function_call</REQUIRES>
      <REQUIRES>all_regs</REQUIRES>
      <REQUIRES>compile_fun_appl</REQUIRES>
      <REQUIRES>registers_needed</REQUIRES>
      <REQUIRES>needs_register</REQUIRES>
      <REQUIRES>append_instruction_sequences</REQUIRES>
      <REQUIRES>list_union</REQUIRES>
      <REQUIRES>preserving</REQUIRES>
      <REQUIRES>tack_on_instruction_sequence</REQUIRES>
      <REQUIRES>parallel_instruction_sequences</REQUIRES>
      <REQUIRES>user_print_2</REQUIRES>
      <REQUIRES>eceval_2</REQUIRES>
      <REQUIRES>display_instructions</REQUIRES>
      <SCHEME>
(define (compile-and-go expression)
  (let ((instructions
        (assemble (statements
                   (compile expression 'val 'return))
                  eceval)))
    (set! the-global-environment (setup-environment))
    (set-register-contents! eceval 'val instructions)
    (set-register-contents! eceval 'flag true)
    (start eceval)))
      </SCHEME>
      <!-- // display_instructions(
           //      instructions(compile(stmt, "val", "return")));
	   -->
      <JAVASCRIPT>
function compile_and_go(stmt) {
    const toplevel_names = scan_out_declarations(stmt);
    const unassigneds = list_of_unassigned(toplevel_names);
    set_global_environment(extend_environment(
                               toplevel_names,
                               unassigneds, 
                               the_global_environment));
    const instr_sequence = compile(stmt, "val", "return");
    const instrs = assemble(instructions(instr_sequence), eceval);
    set_register_contents(eceval, "val", instrs);
    set_register_contents(eceval, "flag", true);
    return start(eceval);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    If we have set up
    <INDEX>compiler for JavaScript<SUBINDEX>monitoring performance (stack use) of compiled code</SUBINDEX></INDEX>
    stack monitoring, as at the end of
    section<SPACE/><REF NAME="sec:running-evaluator"/>, we can examine the
    stack usage of compiled code:
    <SNIPPET EVAL="no">
      <NAME>compile_and_go_example_2</NAME>
      <REQUIRES>compile_and_go</REQUIRES>
      <SCHEME>
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
      </SCHEME>
      <SCHEMEOUTPUT>
(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
compile_and_go(parse(`
function factorial(n) {
    return n === 1
           ? 1
           : factorial(n - 1) * n;
}
                     `));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
total pushes = 0 
maximum depth = 0
EC-evaluate value:
undefined
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <SCHEMEPROMPT>
;;; EC-Eval input:
      </SCHEMEPROMPT>
      <SCHEME>
(factorial 5)
      </SCHEME>
      <SCHEMEOUTPUT>
(total-pushes = 31 maximum-depth = 14)
;;; EC-Eval value:
120
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
EC-evaluate input:
     </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
factorial(5);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
total pushes = 36 
maximum depth = 14
EC-evaluate value:
120
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    Compare
    <INDEX>compiler for JavaScript<SUBINDEX>explicit-control evaluator vs.</SUBINDEX></INDEX>
    this example with the evaluation of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(factorial 5)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>factorial(5)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    using the interpreted version of the same
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    shown at the end of section<SPACE/><REF NAME="sec:running-evaluator"/>.
    <SPLITINLINE>
      <SCHEME>
        The interpreted version required 144 pushes and a maximum stack depth of 28.
      </SCHEME>
      <JAVASCRIPT>
        The interpreted version required 151 pushes and a maximum stack depth of 28.
      </JAVASCRIPT>
    </SPLITINLINE>
    This illustrates the optimization that results from our compilation strategy.
  </TEXT>

  <SUBHEADING>
    <NAME>Interpretation and compilation</NAME>
  </SUBHEADING>

  <INDEX>interpreter<SUBINDEX>compiler vs.</SUBINDEX></INDEX>
  <INDEX>compiler<SUBINDEX>interpreter vs.</SUBINDEX></INDEX>

  <TEXT>
    With the programs in this section, we can now experiment with the
    alternative execution strategies of interpretation and
    compilation.<FOOTNOTE>We can do even better by extending the compiler
    to allow compiled code to call interpreted
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    See exercise<SPACE/><REF NAME="ex:compiled-call-interpreted"/>.</FOOTNOTE>
    An interpreter raises the machine to the level of the user program; a
    compiler lowers the user program to the level of the machine language.
    We can regard the 
    <SPLITINLINE>
      <SCHEME>
        Scheme
      </SCHEME>
      <JAVASCRIPT>
        JavaScript
      </JAVASCRIPT>
    </SPLITINLINE>
    language (or any programming language) as a
    coherent family of abstractions erected on the machine language.
    Interpreters are good for interactive program development and
    debugging because the steps of program execution are organized in
    terms of these abstractions, and are therefore more intelligible
    to the programmer.
    Compiled code can execute faster, because the steps of program execution
    are organized in terms of the machine language, and the compiler is free
    to make optimizations that cut across the higher-level
    abstractions.<FOOTNOTE>Independent of the strategy of execution, we
    incur significant overhead if we insist that
    <INDEX>error handling<SUBINDEX>in compiled code</SUBINDEX></INDEX>
    errors encountered in
    execution of a user program be detected and signaled, rather than being
    allowed to kill the system or produce wrong answers.  For example, an
    out-of-bounds array reference can be detected by checking the validity
    of the reference before performing it.  The overhead of checking,
    however, can be many times the cost of the array reference itself, and
    a programmer should weigh speed against safety in determining whether
    such a check is desirable.  A good compiler should be able to produce
    code with such checks, should avoid redundant checks, and should allow
    programmers to control the extent and type of error checking in the
    compiled code.
    <P/>
      Compilers for popular languages, such as
      <INDEX>C<SUBINDEX>error handling</SUBINDEX></INDEX>
      C and C++,
      put hardly any error-checking operations into
      running code, so as to make things run as fast as possible.  As a
      result, it falls to programmers to explicitly provide error checking.
      Unfortunately, people often neglect to do this, even in
      critical applications where speed is not a constraint.  Their programs
      lead fast and dangerous lives.  For example, the notorious 
      <INDEX>Internet <QUOTE>Worm</QUOTE></INDEX>
      <QUOTE>Worm</QUOTE>
      that paralyzed the Internet in 1988 exploited the 
      <INDEX>UNIX</INDEX>
      UNIX<LATEXINLINE>$^{\textrm{TM}}$</LATEXINLINE>
      operating system<APOS/>s failure to check whether the input buffer has
      overflowed in the finger daemon. (See
      <INDEX>Spafford, Eugene H.</INDEX>
      <CITATION>Spafford 1989</CITATION>.)
  </FOOTNOTE>
  </TEXT>

  <TEXT>
    The alternatives of interpretation and compilation also lead to
    different strategies for
    <INDEX>porting a language</INDEX>
    porting languages to new computers. Suppose
    that we wish to implement
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    for a new machine.  One strategy is
    to begin with the explicit-control evaluator of
    section<SPACE/><REF NAME="sec:eceval"/>
    and translate its instructions to instructions for the
    new machine.  A different strategy is to begin with the compiler and
    change the code generators so that they generate code for the new
    machine.  The second strategy allows us to run any
    <SPLITINLINE><SCHEME>Lisp</SCHEME>
    <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    program on the new machine by first compiling it with the compiler running
    on our
    original <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> system, and linking it with a compiled version of the runtime
    library.<FOOTNOTE>Of course, with either the interpretation or the
    compilation strategy we must also implement for the new machine storage
    allocation, input and output, and all the various operations that we took
    as <QUOTE>primitive</QUOTE> in our discussion of
    the evaluator and compiler.  One strategy for minimizing work here is
    to write as many of these operations as possible in
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    and then compile them for the new machine.  Ultimately, everything reduces
    to a small kernel (such as garbage collection and the mechanism for
    applying actual machine primitives) that is hand-coded for the new
    machine.</FOOTNOTE>  Better yet, we can compile the compiler itself, and run
    this on the new machine to compile other
    <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> programs.<FOOTNOTE>
    This strategy leads to amusing tests of correctness of
    the compiler, such as checking
    whether the compilation of a program on the new machine, using the
    compiled compiler, is identical with the
    compilation of the program on the original
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    system.  Tracking down the source of differences is fun but often
    frustrating, because the results are extremely sensitive to minuscule
    details.</FOOTNOTE>  Or we can compile one of the interpreters of
    section<SPACE/><REF NAME="sec:mc-eval"/> to produce an interpreter that
    runs on the new machine.
  </TEXT>

  <EXERCISE>
    <LABEL NAME="ex:measure-factorial-ratio"/>
    By
    <INDEX>compiler for JavaScript<SUBINDEX>monitoring performance (stack use) of compiled code</SUBINDEX></INDEX>
    <INDEX><USE>factorial</USE><SUBINDEX>stack usage, compiled</SUBINDEX></INDEX>
    comparing the stack operations used by compiled code to the stack
    operations used by the evaluator for the same computation, we can
    determine the extent to which the compiler optimizes use of the stack,
    both in speed (reducing the total number of stack operations) and in
    space (reducing the maximum stack depth).  Comparing this optimized
    stack use to the performance of a special-purpose machine for the same
    computation gives some indication of the quality of the compiler.
    <OL>
      <LI>
	Exercise<SPACE/><REF NAME="ex:rec-fact"/> asked you to determine, as a
	function of <LATEXINLINE>$n$</LATEXINLINE>, the number of pushes and
	the maximum stack depth needed by the evaluator to compute
	<LATEXINLINE>$n!$</LATEXINLINE> using the recursive factorial
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	given above.  Exercise<SPACE/><REF NAME="ex:measure-fact"/> asked you
	to do the same measurements for the special-purpose factorial machine
	shown in figure<SPACE/><REF NAME="fig:fact-machine"/>. Now perform the
	same analysis using the compiled <SCHEMEINLINE>factorial</SCHEMEINLINE>
	<SPLITINLINE>
	  <SCHEME>procedure.</SCHEME>
	  <JAVASCRIPT>function.</JAVASCRIPT>
	</SPLITINLINE>
	<TEXT>
	  <PDF_ONLY>\quad</PDF_ONLY>
	  Take the ratio of the number of pushes in the compiled version to the
	  number of pushes in the interpreted version, and do the same for the
	  maximum stack depth.  Since the number of operations and the stack
	  depth used to compute <LATEXINLINE>$n!$</LATEXINLINE> are linear in
	  <LATEXINLINE>$n$</LATEXINLINE>, these ratios should
	  approach constants as <LATEXINLINE>$n$</LATEXINLINE> becomes large.
	  What are these constants? Similarly, find the ratios of the stack usage
	  in the special-purpose machine to the usage in the interpreted version.
	</TEXT>
	<TEXT>
	  <PDF_ONLY>\quad</PDF_ONLY>
	Compare the ratios for special-purpose versus interpreted code to the
	ratios for compiled versus interpreted code.  You should find that the
	special-purpose machine does much better than the compiled code, since
	the hand-tailored controller code should be much better than what is
	produced by our rudimentary general-purpose compiler.
	</TEXT>
      </LI>
      <LI>
	Can you suggest improvements to the compiler that would help it
	generate code that would come closer in performance to the
	hand-tailored version?
      </LI>
    </OL>
  </EXERCISE>

  <EXERCISE>
    Carry out an analysis like the one in
    exercise<SPACE/><REF NAME="ex:measure-factorial-ratio"/> to determine the
    effectiveness of compiling the tree-recursive
    <INDEX>compiler for JavaScript<SUBINDEX>monitoring performance (stack use) of compiled code</SUBINDEX></INDEX>
    <INDEX><USE>fib</USE><SUBINDEX>stack usage, compiled</SUBINDEX></INDEX>
    Fibonacci
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <SCHEME>
(define (fib n)
  (if (&lt; n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
      </SCHEME>
      <JAVASCRIPT>
function fib(n) { 
    return n &lt; 2 ? n : fib(n - 1) + fib(n - 2); 
}
      </JAVASCRIPT>
    </SNIPPET>
    compared to the effectiveness of using the special-purpose Fibonacci machine
    of figure<SPACE/><REF NAME="fig:fib-machine"/>.  (For measurement of the
    interpreted performance, see exercise<SPACE/><REF NAME="ex:rec-fib"/>.)
    For Fibonacci, the time resource used is not linear in
    <LATEXINLINE>$n$</LATEXINLINE>; hence the ratios of stack operations will not
    approach a limiting value that is independent of
    <LATEXINLINE>$n$</LATEXINLINE>.
    <LABEL NAME="ex:measure-fib-ratio"/>
  </EXERCISE>

  <EXERCISE>
    This section described how to modify the explicit-control evaluator so
    that interpreted code can call compiled
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
    <JAVASCRIPT>functions.</JAVASCRIPT></SPLITINLINE>
    Show how to modify the compiler so that compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    can call not only primitive
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    and compiled
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <JAVASCRIPT>functions,</JAVASCRIPT>
    </SPLITINLINE>
    but interpreted
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    as well.  This requires modifying
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-procedure-call</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_function_call</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to handle the case of compound (interpreted)
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    Be sure to handle all the same <SCHEMEINLINE>target</SCHEMEINLINE> and
    <SCHEMEINLINE>linkage</SCHEMEINLINE> combinations
    as in
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>compile-proc-appl</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_fun_appl</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    To do the actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application,
    the code needs to jump to the evaluator<APOS/>s
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compound-apply</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    entry point. This label cannot be directly referenced in object code
    (since the assembler requires that all labels referenced by the
    code it is assembling be defined there), so we will add a register
    called <SCHEMEINLINE>compapp</SCHEMEINLINE> to the evaluator machine to
    hold this entry point, and add an instruction to initialize it:
    <SNIPPET LATEX="yes">
      <SCHEME>
  (assign compapp (label compound-apply))
  (branch (label external-entry))      ; branches if $\texttt{flag}$ is set
read-eval-print-loop
  $\ldots$
      </SCHEME>
      <JAVASCRIPT latex="yes"><!-- The $\texttt{ }\texttt{ }$ below is a hack to ensure the leading spaces are not consumed-->
$\texttt{ }\texttt{ }$assign("compapp", label("compound_apply")),
  branch(label("external_entry")),     // branches if flag is set
"read_evaluate_print_loop",
  $\ldots$
      </JAVASCRIPT>
    </SNIPPET>
    To test your code, start by
    <SPLITINLINE>
      <SCHEME>
	defining
      </SCHEME>
      <JAVASCRIPT>
	declaring
      </JAVASCRIPT>
    </SPLITINLINE>
    a
    <SPLITINLINE>
      <SCHEME>
	procedure
      </SCHEME>
      <JAVASCRIPT>
	function
      </JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>f</SCHEMEINLINE> that calls a
    <SPLITINLINE>
      <SCHEME>
	procedure
      </SCHEME>
      <JAVASCRIPT>
	function
      </JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>g</SCHEMEINLINE>.  Use
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>compile-and-go</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compile_@and_@go</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to compile the
    <SPLITINLINE>
      <SCHEME>
	definition
      </SCHEME>
      <JAVASCRIPT>
	declaration
      </JAVASCRIPT>
    </SPLITINLINE>
    of <SCHEMEINLINE>f</SCHEMEINLINE>
    and start the evaluator.  Now, typing at the evaluator,
    <SPLITINLINE>
      <SCHEME>
	define
	<SCHEMEINLINE>g</SCHEMEINLINE> and try to call
	<SCHEMEINLINE>f</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	declare 
	<SCHEMEINLINE>g</SCHEMEINLINE> and try to call
	<SCHEMEINLINE>f</SCHEMEINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    <LABEL NAME="ex:compiled-call-interpreted"/>
  </EXERCISE>

  <EXERCISE>
    The
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-and-go</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_and_go</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    interface implemented in this section is
    awkward, since the compiler can be called only once (when the
    evaluator machine is started).  Augment the compiler-interpreter
    interface by providing a
    <INDEX><USE>compile_and_run</USE></INDEX> 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-and-run</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_and_run</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    primitive that can be called from within the explicit-control evaluator
    as follows:
    <SNIPPET EVAL="no" POSTPADDING="no">
      <SCHEMEPROMPT>
;;; EC-Eval input:
      </SCHEMEPROMPT>
      <SCHEME>
(compile-and-run
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
      </SCHEME>
      <SCHEMEOUTPUT>
;;; EC-Eval value:
ok
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
EC-evaluate input:
     </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
compile_and_run(parse(`
function factorial(n) {
    return n === 1
           ? 1
           : factorial(n - 1) * n;
}
                      `));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
EC-evaluate value:
undefined
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET POSTPADDING="no">
      <SCHEMEPROMPT>
;;; EC-Eval input:
      </SCHEMEPROMPT>
      <SCHEME>
(factorial 5)
      </SCHEME>
      <SCHEMEOUTPUT>
;;; EC-Eval value:
120
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
EC-evaluate input:
     </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
factorial(5)
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
EC-Eval value:
120
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE>
    As an alternative to using the explicit-control evaluator<APOS/>s
    <SPLITINLINE>
      <SCHEME>
	read-eval-print
      </SCHEME>
      <JAVASCRIPT>
	read-evaluate-print
      </JAVASCRIPT>
    </SPLITINLINE>
    loop, design a register machine that performs a
    read-compile-execute-print loop.  That is, the machine should run a
    loop that reads
    <SPLITINLINE>
      <SCHEME>
	an expression,
      </SCHEME>
      <JAVASCRIPT>
	a program,
      </JAVASCRIPT>
    </SPLITINLINE>
    compiles it, assembles and
    executes the resulting code, and prints the result.  This is easy to
    run in our simulated setup, since we can arrange to call the
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>compile</SCHEMEINLINE> and
    <SCHEMEINLINE>assemble</SCHEMEINLINE> as <QUOTE>register-machine
    operations.</QUOTE>
    <LABEL NAME="ex:read-compile-execute"/>
  </EXERCISE>

  <EXERCISE>
    Use the compiler to compile the
    <INDEX>metacircular evaluator for JavaScript<SUBINDEX>compilation of</SUBINDEX></INDEX>
    metacircular evaluator of
    section<SPACE/><REF NAME="sec:mc-eval"/> and run this program using the
    register-machine simulator.
    <SPLIT>
      <SCHEME>
	      (To compile more than one definition at a time,
	      you can package the definitions in a
	      <SCHEMEINLINE>begin</SCHEMEINLINE>.)
      </SCHEME>
      <JAVASCRIPT>
        Because the parser takes a string as input, you will need to
        convert the program into a string. The simplest way to do this is
        to use the back quotes (<JAVASCRIPTINLINE>`</JAVASCRIPTINLINE>),
        as we have done for the example inputs to
	<JAVASCRIPTINLINE>compile_and_go</JAVASCRIPTINLINE> and
        <JAVASCRIPTINLINE>compile_and_run</JAVASCRIPTINLINE>. 
      </JAVASCRIPT>
    </SPLIT>
    The resulting interpreter will run very slowly because of the multiple
    levels of interpretation, but getting all the details to work is an
    instructive exercise.
  </EXERCISE>

  <EXERCISE>
    Develop a rudimentary implementation of
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    in
    <INDEX>C<SUBINDEX>JavaScript interpreter written in</SUBINDEX></INDEX>
    C (or some other low-level language of your choice) by translating the
    explicit-control evaluator of section<SPACE/><REF NAME="sec:eceval"/>
    into C.  In order to run this code you will need to also
    provide appropriate storage-allocation routines and other runtime
    support.
    <LABEL NAME="ex:interp-in-C"/>
  </EXERCISE>

  <EXERCISE>
    As a counterpoint to exercise<SPACE/><REF NAME="ex:interp-in-C"/>, modify
    the compiler so that it compiles 
    <SPLITINLINE>
      <SCHEME>Scheme procedures</SCHEME>
      <JAVASCRIPT>JavaScript functions</JAVASCRIPT>
    </SPLITINLINE>
    into sequences of
    <INDEX>C<SUBINDEX>compiling JavaScript into</SUBINDEX></INDEX>
    <INDEX>C<SUBINDEX>JavaScript interpreter written in</SUBINDEX></INDEX>
    <INDEX>metacircular evaluator for JavaScript<SUBINDEX>compilation of</SUBINDEX></INDEX>
    C instructions.  Compile the metacircular evaluator of
    section<SPACE/><REF NAME="sec:mc-eval"/> to produce a
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>  
    interpreter written in C.
    <LABEL NAME="ex:compiler-in-C"/>
  </EXERCISE>

  <INDEX>compiler for JavaScript<SUBINDEX>interfacing to evaluator<CLOSE/></SUBINDEX></INDEX>
  <INDEX>compiler for JavaScript<SUBINDEX>running compiled code<CLOSE/></SUBINDEX></INDEX>
  <INDEX>compiler for JavaScript<CLOSE/></INDEX>

</SUBSECTION>
