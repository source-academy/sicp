[{"id":"/sicpjs/2.2.3","tag":"TITLE","body":"2.2.3  \n    Sequences as Conventional Interfaces"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    In working with compound data, we've stressed how data abstraction\n    permits us to design programs without becoming enmeshed in the details\n    of data representations, and how abstraction preserves for us the\n    flexibility to experiment with alternative representations.  In this\n    section, we introduce another powerful design principle for working\n    with data structures—the use of ","tag":"#text"},{"tag":"EM","child":[{"body":"conventional interfaces","tag":"#text"}]},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    In section ","tag":"#text"},{"tag":"REF","body":"1.3","href":"/sicpjs/1.3"},{"body":" we saw how\n    program abstractions, implemented as higher-order\n    functions,\n    can capture common patterns in programs that deal with numerical data. Our\n    ability to formulate analogous operations for working with compound data\n    depends crucially on the style in which we manipulate our data structures.\n    Consider, for example, the following\n    function,\n    analogous to the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"count_leaves"},{"body":"function\n    of section ","tag":"#text"},{"tag":"REF","body":"2.2.2","href":"/sicpjs/2.2.2"},{"body":", which takes a tree as argument\n    and computes the sum of the squares of the leaves that are odd:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":9,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9chUpRqgKdAPpUAJoc5F+Q0WPYSpoWgFJUoALyvQARmVr8xctVp0BAC2BsZ6jCwcdJxkHOzmwqLikrS6ekQEADaZMXG8iZaFAPygAAwFhaIAXKAAhDr6AA7MFKy57PEVlaAlaUYmsR38JRFsXIPxoDXl3ZY1gSH94Uxj0QAW7MwDefwA1F2zC6GGy5Hs0WQtORO8vF64R0ujUZyZumSv75woADSgmLw-m86B8ACx-ACstzuQA","body":"function sum_odd_squares(tree) {\n    return is_null(tree)\n           ? 0\n           : ! is_pair(tree)\n           ? is_odd(tree) ? square(tree) : 0\n           : sum_odd_squares(head(tree)) +\n             sum_odd_squares(tail(tree));\n} "},{"body":"\n    On the surface, this\n    function\n    is very different from the following one, which constructs a list of all\n    the even Fibonacci numbers\n    ","tag":"#text"},{"body":"${\\textrm{Fib}}(k)$","tag":"LATEX"},{"body":", where\n    ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" is less than or equal to a given integer\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":13,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQKBnAfQFMA3ZogCiIEpQBvbKGGgATszIFRtWgFJUoALzLQABgDc2AL65CpSjVB4KAI259BIsRKkylK1UKvPQAfjVOXIgFyhayxVAARk8vN2DQr19jM1oAWmC+AGojU25QBJQeTR18YnJqWjYORhj6cwFQvQLDImYADzJOAGsLSJEKPFAW0AA+Pzawq3FJaT8CABsJzTCtUGYJ+mZKoZESGnoyIyVUs1aZ1etR2gYWdi48HnbD4XcABwBDClFOPAAaPwam5tAUoJ4rjcop9Gj0-tlrqAdFZoSIRrYQU1VBDcsUiKVTOUAJzZIA","body":"function even_fibs(n) {\n    function next(k) {\n        if (k > n) {\n            return null;\n        } else {\n            const f = fib(k);\n            return is_even(f)\n                   ? pair(f, next(k + 1))\n                   : next(k + 1);\n        }\n    }\n    return next(0);\n} "}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    Despite the fact that these two\n    functions\n    are structurally very different, a more abstract description of the two\n    computations reveals a great deal of similarity.  The first program\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tenumerates the leaves of a tree;\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tfilters them, selecting the odd ones;\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tsquares each of the selected ones; and\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\taccumulates the results using\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"+"},{"body":",\n\tstarting with 0.\n      ","tag":"#text"}]}]},{"body":"\n    The second program\n    ","tag":"#text"},{"tag":"UL","child":[{"tag":"LI","child":[{"body":"\n\tenumerates the integers from 0 to ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":";\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tcomputes the Fibonacci number for each integer;\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\tfilters them, selecting the even ones; and\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n\taccumulates the results using\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair"},{"body":",\n\tstarting with the empty list.\n      ","tag":"#text"}]}]}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    A signal-processing engineer would find it natural to conceptualize these\n    processes in terms of\n    \n    signals flowing through a cascade of stages, each of\n    which implements part of the program plan, as shown in\n    figure ","tag":"#text"},{"tag":"REF","body":"2.7","href":"/sicpjs/2.2.3#fig-2.7"},{"body":".\n      \n    In\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_odd_squares"},{"body":",\n      \n    we begin with an \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"enumerator","tag":"#text"}]},{"body":", which generates a \"","tag":"#text"},{"body":"signal","tag":"#text"},{"body":"\" consisting of\n    the leaves of a given tree.  This signal is passed through a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"filter","tag":"#text"}]},{"body":", which eliminates all but the odd elements. The resulting\n    signal is in turn passed through a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"map","tag":"#text"}]},{"body":", which is a \"","tag":"#text"},{"body":"transducer","tag":"#text"},{"body":"\" that applies the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"square"},{"body":"function\n    to each element.  The output of the map is then fed to an \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"accumulator","tag":"#text"}]},{"body":", which combines the elements using\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"+"},{"body":",\n    starting from an initial 0. The plan for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"even_fibs"},{"body":"\n    is analogous.\n    ","tag":"#text"},{"tag":"FIGURE","scale":"70%","src":"img_javascript/ch2-Z-G-17.svg","id":"#fig-2.7","captionHref":"/sicpjs/2.2.3#fig-2.7","captionName":"Figure 2.7 ","captionBody":[{"body":"The signal-flow plans for the\n          functions\n          ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_odd_squares"},{"body":" (top) and\n\t  ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"even_fibs"},{"body":" (bottom) reveal the\n          commonality between the two programs.\n          ","tag":"#text"}]}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    Unfortunately, the two\n    function declarations\n    above fail to exhibit this signal-flow structure.  For instance, if we\n    examine the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_odd_squares"},{"body":"function,\n    we find that the enumeration is implemented partly by the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_null"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_pair"},{"body":"\n    tests and partly by the tree-recursive structure of the\n    function.\n    Similarly, the accumulation is found partly in the tests and partly in the\n    addition used in the recursion.  In general, there are no distinct parts of\n    either\n    function\n    that correspond to the elements in the signal-flow description. Our two\n    functions\n    decompose the computations in a different way, spreading the enumeration\n    over the program and mingling it with the map, the filter, and the\n    accumulation.  If we could organize our programs to make the signal-flow\n    structure manifest in the\n    functions\n    we write, this would increase the conceptual clarity of the resulting\n    program.","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Sequence Operations","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    The key to organizing programs so as to more clearly reflect the\n    signal-flow structure is to concentrate on the \"","tag":"#text"},{"body":"signals","tag":"#text"},{"body":"\" that\n    flow from one stage in the process to the next.  If we represent these\n    signals as lists, then we can use list operations to implement the\n    processing at each of the stages.  For instance, we can implement the\n    mapping stages of the signal-flow diagrams using the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"map"},{"body":"function\n    from section ","tag":"#text"},{"tag":"REF","body":"2.2.1","href":"/sicpjs/2.2.1"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":12,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9chUpRqgAtswAOnDQBpQFMux11+Q0WPYSpZugH0iBADYfO5y9eF2gaAA-KDuXgFBogBcoPrMFKxGxJwAFuzMACY+Fla8vKaRUcV6hiagZAnevnn5ymrYpZyMLBymHhR0ZJwAjKYoppimACymAKx1QA","body":"map(square, list(1, 2, 3, 4, 5)); ","output":"list(1, 4, 9, 16, 25)"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    Filtering a sequence to select only those elements that satisfy a given\n    predicate is accomplished by\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8KAbMgUwCcAKAB1eYBMKSAQxYAaUAGdmARwLNSzAJSgA3tlDrQPMgVa0K4gPpECDBu0ky5JRWo12NAflDHTt+3YBcobnwHDm7AAWzIK85tKy8goKbu7qTpyCFBzBoeGWUWKxcXH0TGxcPPxCoqBkSWYWkdbRMTkaXnksHD7F-mLljOnVigoA3NgAvriEpJQ0oPoGVLxhREqqdlo6tLQApKigALw7oACMA8NNBVMzvGIM+mTse2IoYphiACxiAKzRfUA","body":"function filter(predicate, sequence) {\n    return is_null(sequence)\n           ? null\n           : predicate(head(sequence))\n           ? pair(head(sequence), \n                  filter(predicate, tail(sequence)))\n           : filter(predicate, tail(sequence));\n} "},{"body":"\n    For example,\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":14,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8KAbMgUwCcAKAB1eYBMKSAQxYAaUAGdmARwLNSzAJSgA3tlDrQPMgVa0K4gPpECDBu0ky5JRWo12NAflDHTt+3YBcobnwHDm7AAWzIK85tKy8goKbu7qTpyCFBzBoeGWUWKxcXH0TGxcPPxCoqBkSWYWkdbRMTkaXnksHD7F-mLljOnVigoA3NgAvriEpJQ0oPoGVLxhREqqdlo6tLQApKigALw7oACMA8P4jM3sUzO8Ygz6ZOx7YihimGIALGIArNF9QA","body":"filter(is_odd, list(1, 2, 3, 4, 5)); ","output":"list(1, 3, 5)"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n  Accumulations can be implemented by\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBDEkggWwIBs6yBTACioAcANKApEKlOm2EBnLgEcCXUlwCUoAN7ZQ20ACcuZArtoVpAfSLs2PWQqUlVWnc50B+EWIlsnL5wC5QAR4ACy46ABMbeUVlFWEfX0SGJlYObj4hD3EKSWEyOgprWxiHFTKAbmwAXyA","body":"function accumulate(op, initial, sequence) {\n    return is_null(sequence)\n           ? initial\n           : op(head(sequence), \n                accumulate(op, initial, tail(sequence)));\n} "},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":12,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBDEkggWwIBs6yBTACioAcANKApEKlOm2EBnLgEcCXUlwCUoAN7ZQ20ACcuZArtoVpAfSLs2PWQqUlVWnc50B+EWIlsnL5wC5QAR4ACy46ABMbeUVlFWEfX0SGJlYObj4hD3EKSWEyOgprWxiHFTKAbmwAX1xCUkoaUH42AmkeAA9hAE81TWd9Q2NQdtAAalAuyprsZJZ2Tl5m1uEABmE2UzIeAEZhFGFMYQAWYQBWCqA","body":"accumulate(plus, 0, list(1, 2, 3, 4, 5)); ","output":"15"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":12,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBDEkggWwIBs6yBTACioAcANKApEKlOm2EBnLgEcCXUlwCUoAN7ZQ20ACcuZArtoVpAfSLs2PWQqUlVWnc50B+EWIlsnL5wC5QAR4ACy46ABMbeUVlFWEfX0SGJlYObj4hD3EKSWEyOgprWxiHFTKAbmwAX1xCUkoaUEpmLmkeAA9hAE81TWd9Q2NQdtAAKlAuyprsZJZ2Tl5m1uEARmE2UzIeNdRhTGEAFmEAVgqgA","body":"accumulate(times, 1, list(1, 2, 3, 4, 5)); ","output":"120"},{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":8,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBDEkggWwIBs6yBTACioAcANKApEKlOm2EBnLgEcCXUlwCUoAN7ZQ20ACcuZArtoVpAfSLs2PWQqUlVWnc50B+EWIlsnL5wC5QAR4ACy46ABMbeUVlFWEfX0SGJlYObj4hD3EKSWEyOgprWxiHFTKAbmwAX1xklnZOXn4C3WFLNilQNlMyHgBGYRRhTGEAFmEAVgqgA","body":"accumulate(pair, null, list(1, 2, 3, 4, 5)); ","output":"list(1, 2, 3, 4, 5)"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    All that remains to implement signal-flow diagrams is to enumerate the\n    sequence of elements to be processed.  For\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"even_fibs"},{"body":",\n    we need to generate the sequence of integers in a given range, which we\n    can do as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBTIggWzoCcBDMugfQqK9YA3dgBsAFCKoB3ADSgAFhQDm8gJSgA3tlA7QrOmQKtakqaAB8C5fO267ugPyhGIkbft2AXKAAO7CqwS0jLuHmE6DMxsnDx8AsLipqAA1KAAjHKKKqqqANzYAL64kSwcXLz8bAliKHIA7HlAA","body":"function enumerate_interval(low, high) {\n    return low > high\n           ? null\n           : pair(low,\n                  enumerate_interval(low + 1, high));\n} "},{"tag":"SNIPPET","latex":false,"id":11,"eval":true,"prependLength":8,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBTIggWzoCcBDMugfQqK9YA3dgBsAFCKoB3ADSgAFhQDm8gJSgA3tlA7QrOmQKtakqaAB8C5fO267ugPyhGIkbft2AXKAAO7CqwS0jLuHmE6DMxsnDx8AsLipqAA1KAAjHKKKqqqANzYAL64kSwcXLz8bAliKHIA7HlAA","body":"enumerate_interval(2, 7); ","output":"list(2, 3, 4, 5, 6, 7)"},{"body":"\n    To enumerate the leaves of a tree, we can use","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/2.2.3#footnote-1"},{"tag":"SNIPPET","latex":false,"id":12,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBTIggWzoCcBDMugfTNbroAKPgICUoAN7ZQM0PzIFWtCgGdujADYbh-OqOmzDsgPyhNGg0cMAuUAEJQq7gAd2FVjrGWrM0xtVknnrePrbszs4MACaCDMxsnDwiQgAWdOwxyaKiADQhPgVxLBxcvLrCbtpZ2QDc2AC+uEUJpcmC-iqBAIw5oB2BKL39gpi9ACzZvQCstUA","body":"function enumerate_tree(tree) {\n    return is_null(tree)\n           ? null\n           : ! is_pair(tree)\n           ? list(tree)\n           : append(enumerate_tree(head(tree)),\n                    enumerate_tree(tail(tree)));\n} "},{"tag":"SNIPPET","latex":false,"id":13,"eval":true,"prependLength":10,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBTIggWzoCcBDMugfTNbroAKPgICUoAN7ZQM0PzIFWtCgGdujADYbh-OqOmzDsgPyhNGg0cMAuUAEJQq7gAd2FVjrGWrM0xtVknnrePrbszs4MACaCDMxsnDwiQgAWdOwxyaKiADQhPgVxLBxcvLrCbtpZ2QDc2AC+uEUJpcmC-iqBAIw5oB2BKL39gpi9ACzZvQCstUA","body":"enumerate_tree(list(1, list(2, list(3, 4)), 5)); ","output":"list(1, 2, 3, 4, 5)"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    Now we can reformulate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_odd_squares"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"even_fibs"},{"body":"\n    as in the signal-flow diagrams.  For\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_odd_squares"},{"body":",\n    \n    we enumerate the sequence of leaves of the tree, filter this to keep only\n    the odd numbers in the sequence, square each element, and sum the results:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":14,"eval":true,"prependLength":22,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9chUpRqgADgBsCdHgBpQAT35DRY9hKkLQAanPK1+YuWq0KdAPpUAEwDOIkthUXFJWloAUlRQAF4k0ABGV3UPLVp2IgIAW3ZWZjJ2XzIOLnL2djDrSPsfX1y9PU4qmvDrLoB+UGa9Tq7RAC5QAEJQRp1mClY2it5BodBevR8yeerF5etR5h0dHOCc-MLi0vbOAAt2ZmD23l5jJZ3lk4KikrKKtpnWh8e6Xcmi89Hy-iCvkYLA4RgegkG9VozBIJHyBD0504+kMpher2WAAY8QTSaA8vtONC2OwSWT6XgKHoSnNGoEAnT6VzrO8zl9LgDAapcHRweyoUwaUY1nQNjKNihTJgnqB5ZwACymACsj14iiAA","body":"function sum_odd_squares(tree) {\n    return accumulate(plus, \n                      0, \n                      map(square, \n                          filter(is_odd, \n                                 enumerate_tree(tree))));\n} "},{"body":"\n    For\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"even_fibs"},{"body":",\n    we enumerate the integers from 0 to ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":", generate\n    the Fibonacci number for each of these integers, filter the resulting\n    sequence to keep only the even elements, and accumulate the results\n    into a list:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":15,"eval":true,"prependLength":20,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQKBnAfQFMA3ZogCiIEpQBvbKGGgATszIFRtWgFJUoALzLQABgDc2AL65CpSjVB4KAI259BIsRKkylK1UKvPQAfjVOXIgFyhayxVAARk8vN2DQr19jM1oAWmC+AGojU25QBJQeTR18YnJqWg4CAFtmUQBDMmZGCiJq0VYKgBtOZqoAdwAaUAALCgBzXotQ8UlpUHaO0AA+PsHeyJd3IgJm5qXnXwAHCopRNs6uzbCRYrLK6tr68qbWqdAUoJ7+oZ5s7V18gyL2IkYYvRzAJRjYJhUSCRSmsqsxOLt9j0TqdnKt1kiUZjUs0GpwGCw-hiscSRCUKttODEiSSacJzuVYdcGndOKoerx3h9cmwOADTECAJzZIA","body":"function even_fibs(n) {\n    return accumulate(pair, \n                      null, \n                      filter(is_even, \n                             map(fib, \n                                 enumerate_interval(0, n))));\n} "}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    The value of expressing programs as sequence operations is that this\n    helps us make program designs that are modular, that is, designs that\n    are constructed by combining relatively independent pieces.  We can\n    encourage modular design by providing a library of standard components\n    together with a conventional interface for connecting the components\n    in flexible ways.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    Modular construction\n    \n    is a powerful strategy for controlling complexity in\n    engineering design.  In real signal-processing applications, for example,\n    designers regularly build systems by cascading elements selected from\n    standardized families of filters and transducers.  Similarly, sequence\n    operations provide a library of standard program elements that we can mix\n    and match.  For instance, we can reuse pieces from the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"sum_odd_squares"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"even_fibs"},{"body":"functions\n    in a program that constructs a list of the squares of the first\n    ","tag":"#text"},{"body":"$n+1$","tag":"LATEX"},{"body":" Fibonacci numbers:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":16,"eval":true,"prependLength":20,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9chUpRqg8FAEaci-IaLHsJU0LQC8t0AAZhp56AD8Dpy9EAuK6FvWoACMnl5uwaFevroGtAC0wfwA1Dr6hqAJKLzKavjE5NS07EQEALbsrMxk7AD6FETVrABuzAA2nK1UAO4ANKAAFhQA5v3GoeKStJ1doAB8A8P9kS7uJa2ty86+AA7MFKwd3T2bYaLFZRVVtfWNLe3ToClBfYMjvNmq6vlaUxR0ZDUYjVGCwOHRDGNTBNLMwSCQygRWldOLt9n0TqdnGtWujMXjQKVmNtOCC2OxcfjKYTiTEKZT6aBzuVKtU6g0KndOPY+kZ3h9cq0-gCgaSwZwgvZskA","body":"function list_fib_squares(n) {\n    return accumulate(pair, \n                      null, \n                      map(square, \n                          map(fib, \n                              enumerate_interval(0, n))));\n} "},{"tag":"SNIPPET","latex":false,"id":17,"eval":true,"prependLength":28,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9chUpRqg8FAEaci-IaLHsJU0LQC8t0AAZhp56AD8Dpy9EAuK6FvWoACMnl5uwaFevroGtAC0wfwA1Dr6hqAJKLzKavjE5NS07EQEALbsrMxk7AD6FETVrABuzAA2nK1UAO4ANKAAFhQA5v3GoeKStJ1doAB8A8P9kS7uJa2ty86+AA7MFKwd3T2bYaLFZRVVtfWNLe3ToClBfYMjvNmq6vlaUxR0ZDUYjVGCwOHRDGNTBNLMwSCQygRWldOLt9n0TqdnGtWujMXjQKVmNtOCC2OxcfjKYTiTEKZT6aBzuVKtU6g0KndOPY+kZ3h9cq0-gCgaSwZwgvZskA","body":"list_fib_squares(10); ","output":"list(0, 1, 1, 4, 9, 25, 64, 169, 441, 1156, 3025)"},{"body":"\n    We can rearrange the pieces and use them in computing the product of the\n    squares of the odd integers in a sequence:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":18,"eval":true,"prependLength":13,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9chUpRqgKdAPpUAJoc5F+Q0WPYSpoWgFJUoALyvQARmVr8xctVqUALbsdDwANKAAnubCouKS0nJRXuq+WrQADqxGBOQGeHqMLBz6VAVGhnrsADbswURkoXTsTOyk7DGW8bbMJCQEgQTVzGRcQSERsZbTM9Puk7OLs4HMGZxFbOwLSzszeBTVo6ycugbGEc2t7bw3KdhZOXllhUybpeXGVbX1jZzVumROPNUBFMBEACwRACstyAA","body":"function product_of_squares_of_odd_elements(sequence) {\n    return accumulate(times, \n                      1, \n                      map(square, \n                          filter(is_odd, sequence)));\n} "},{"tag":"SNIPPET","latex":false,"id":19,"eval":true,"prependLength":20,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9chUpRqgKdAPpUAJoc5F+Q0WPYSpoWgFJUoALyvQARmVr8xctVqUALbsdDwANKAAnubCouKS0nJRXuq+WrQADqxGBOQGeHqMLBz6VAVGhnrsADbswURkoXTsTOyk7DGW8bbMJCQEgQTVzGRcQSERsZbTM9Puk7OLs4HMGZxFbOwLSzszeBTVo6ycugbGEc2t7bw3KdhZOXllhUybpeXGVbX1jZzVumROPNUBFMBEACwRACstyAA","body":"product_of_squares_of_odd_elements(list(1, 2, 3, 4, 5)); ","output":"225"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    We can also formulate conventional data-processing applications in terms of\n    sequence operations.  Suppose we have a sequence of personnel records and\n    we want to find the salary of the highest-paid programmer. Assume that we\n    have a selector ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"salary"},{"body":" that returns the salary\n    of a record, and a predicate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_programmer"},{"body":"\n    that tests if a record is for a programmer.  Then we can write\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":20,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBnAQwBsGAnATwH0q9OALCgHM+AUzplOABwYUAJlNZVBrBgFtVI1gApWIklVay6ASlABvbKCuhdZAq1oMSJAqoIsyIraoZk+nHwAPABpQS2sIyKjrAAZQ8OjEyJ9JLUYWDnik7Oi8CiZPbQo6BSUVdU1Q3X1DE2NjAG5sAF9cfSJxUFUuaoMjUABeUCZisi0R8S0AIgAZCiICOinQqclFZTUNVmXQTBj9mONghJzsibGpgCUKEj42WR3V9fKtnZQAVgOjk9PE8+mAEL5JiPHxEBiCTRvT4HQ6NfDEcjUWjFUobCraXqGUwWCK2ey0UQMWRaMgyJg6PR9eqDAZDJ5lTZQpqtQikSg0ejMNjsSk1WQ4k74hygIkksn5UnkvnU+os7DpHncXgCYRiCTSORol6abw9Km1RpAA","body":"function salary_of_highest_paid_programmer(records) {\n    return accumulate(math_max, \n                      0, \n                      map(salary, \n                          filter(is_programmer, records)));\n} "},{"body":"\n    These examples give just a hint of the vast range of operations that\n    can be expressed as sequence operations.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/2.2.3#footnote-2"}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n    Sequences, implemented here as lists, serve as a conventional interface\n    that permits us to combine processing modules.  Additionally, when we\n    uniformly represent structures as sequences, we have localized the\n    data-structure dependencies in our programs to a small number of sequence\n    operations.  By changing these, we can experiment with alternative\n    representations of sequences, while leaving the overall design of our\n    programs intact.  We will exploit this capability in\n    section ","tag":"#text"},{"tag":"REF","body":"3.5","href":"/sicpjs/3.5"},{"body":", when we generalize the\n    sequence-processing paradigm to admit infinite sequences.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.33","id":"#ex-2.33","child":[{"body":"\n    Fill in the missing expressions to complete the following definitions of\n    some basic list-manipulation operations as accumulations:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction map(f, sequence) {\n    return accumulate((x, y) => $\\langle{}$??$\\rangle$, \n                      null, sequence);\n}\nfunction append(seq1, seq2) {\n    return accumulate(pair, $\\langle{}$??$\\rangle$, $\\langle{}$??$\\rangle$);\n}\nfunction length(sequence) {\n    return accumulate($\\langle{}$??$\\rangle$, 0, sequence);\n}\n      "}],"solution":[{"tag":"SNIPPET","latex":false,"id":21,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBbAQwAcAKPAGlAGcBTARwI9SPAJSgA3tlDTQAJx5kCs2gxIkCdAgBsGZHixYAPTgE8xAXgB8oJgwqy2RkaedSZ7j55lFtWzm69Aj14BIRJRAG5sAF98YnJqFSYmIQATFhCARk4QlDFJd3lFZVBVdU0dPRZbexz+FDq+TJEo2MJSShpQLSEAczIACwz+QWF8gLkFJRU1DW1dfSMXUCtQE1AAalBsiaCggAZ-PePuEbDImNxGVkZBgH0uPlkyTi0KLjIWbNROTE4AFhELWwIFKyTSLDeHy+nAaoEwzm670+-04AFZOAA2IFRUE9Ij9IZQz7fOF-UCAlpAA","body":"function map(f, sequence) {\n    return accumulate((x, y) => pair(f(x), y),\n                      null, \n                      sequence);\n}\nfunction append(seq1, seq2) {\n    return accumulate(pair, seq2, seq1);\n}\nfunction length(sequence) {\n    return accumulate((x, y) => y + 1,\n                      0, \n                      sequence);\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.34","id":"#ex-2.34","child":[{"body":"\n    Evaluating a\n    polynomial in ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" at a given value\n    of ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" can be formulated as an accumulation.\n    We evaluate the polynomial\n    ","tag":"#text"},{"body":"\n      \\[ a_{n} x^n +a_{n-1}x^{n-1}+\\cdots + a_{1} x+a_{0} \\]\n    ","tag":"LATEX"},{"body":"\n    using a well-known algorithm called \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"Horner's rule","tag":"#text"}]},{"body":", which structures the computation as\n    ","tag":"#text"},{"body":"\n      \\[ \\left(\\cdots (a_{n}  x+a_{n-1})x+\\cdots +a_{1}\\right) x+a_{0} \\]\n    ","tag":"LATEX"},{"body":"\n    In other words, we start with ","tag":"#text"},{"body":"$a_{n}$","tag":"LATEX"},{"body":", multiply\n    by ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":", add ","tag":"#text"},{"body":"$a_{n-1}$","tag":"LATEX"},{"body":",\n    multiply by ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":", and so on, until we reach\n    ","tag":"#text"},{"body":"$a_{0}$","tag":"LATEX"},{"body":".","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/2.2.3#footnote-3"},{"body":"\n    Fill in the following template to produce a\n    function\n    that evaluates a polynomial using Horner's rule. Assume that the\n    coefficients of the polynomial are arranged in a sequence, from\n    ","tag":"#text"},{"body":"$a_{0}$","tag":"LATEX"},{"body":" through\n    ","tag":"#text"},{"body":"$a_{n}$","tag":"LATEX"},{"body":".\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction horner_eval(x, coefficient_sequence) {\n    return accumulate((this_coeff, higher_terms) => $\\langle{}$??$\\rangle$,\n                      0, \n                      coefficient_sequence);\n}\n      "},{"body":"\n    For example, to compute ","tag":"#text"},{"body":"$1+3x+5x^3+x^5$","tag":"LATEX"},{"body":" at\n    ","tag":"#text"},{"body":"$x=2$","tag":"LATEX"},{"body":" you would evaluate\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":22,"eval":true,"prependLength":7,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQALKgJyIFNGB9FgNwEMAbABQAPADSgSVFnjwUSFFkTLsAziwCOBBSRYBKUAG9soY6EYsyBZqB4kSBALYE+PMiwECydCsvYSpeMS8Aczo2dldGe2U9AF4APlARIxMU1LSTAAYxZPTc1L9pWXlFFXVNUl0AbmwAX1wGZjDufgEUMT5vMgEARjFMMSzQAFYBsW6dHUqgA","body":"horner_eval(2, list(1, 3, 0, 5, 0, 1)); "}],"solution":[{"tag":"SNIPPET","latex":false,"id":23,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQALKgJyIFNGB9FgNwEMAbABQAPADSgSVFnjwUSFFkTLsAziwCOBBSRYBKUAG9soY6EYsyBZqB4kSBALYE+PMiwECydCsvYSpeMS8Aczo2dldGe2U9AF4APlAjE2SU1JMhUAAqegoQsIio0ABqUE9vX0lpESS02pSABjEaupa-aVl5RRV1TVJdAG5sAF9cBmYw7n4BFDE+bzIBAEYxTDFG0ABWNbFFnR1+oA","body":"function horner_eval(x, coefficient_sequence) {\n    return accumulate((this_coeff, higher_terms) => \n                      x * higher_terms + this_coeff,\n                      0, \n                      coefficient_sequence);\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.35","id":"#ex-2.35","child":[{"body":"\n    Redefine\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"count_leaves"},{"body":"\n    from section ","tag":"#text"},{"tag":"REF","body":"2.2.2","href":"/sicpjs/2.2.2"},{"body":" as an accumulation:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction count_leaves(t) {\n    return accumulate($\\langle{}$??$\\rangle$, $\\langle{}$??$\\rangle$, map($\\langle{}$??$\\rangle$, $\\langle{}$??$\\rangle$));\n}\n          "}],"solution":[{"tag":"SNIPPET","latex":false,"id":24,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQSriyB9AGwFMBDANzYGcAKMgEpQAb2yhJoAE5syBabQ4kSBALYEWHMm37923PgBpQZKmQ4sRAXgB8oAz16gA1KfOWjEqT99+pAAwm2ACQIX5qHAAO-LwEAEZMZLJsoHagFLxMURwU0rEJSSlCoeH+5X4A-HQMRMyOfAWJyWxsJRUdneUAXKAAjF5hZcJCANzYAL649IysnE78OXn6mWT8A6hCJiyr-JgmACxCx6NAA","body":"function count_leaves(t) {\n    return accumulate((leaves, total) => leaves + total,\n                      0, \n\t\t      map(sub_tree => is_pair(sub_tree)\n\t\t                      ? count_leaves(sub_tree)\n                                      : 1,\n\t\t\t  t));\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.36","id":"#ex-2.36","child":[{"body":"\n    The\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"accumulate_n"},{"body":"\n    is similar to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"accumulate"},{"body":"\n    except that it takes as its third argument a sequence of sequences, which\n    are all assumed to have the same number of elements.  It applies the\n    designated accumulation\n    function\n    to combine all the first elements of the sequences, all the second elements\n    of the sequences, and so on, and returns a sequence of the results.  For\n    instance, if ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"s"},{"body":" is a sequence containing four\n    sequences\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":25,"eval":false,"body":"list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9), list(10, 11, 12))"},{"body":"\n    then the value of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"accumulate_n(plus, 0, s)"},{"body":"\n    should be the sequence\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(22, 26, 30)"},{"body":".\n      \n    Fill in the missing expressions in the following definition of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"accumulate_n"},{"body":":\n      ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction accumulate_n(op, init, seqs) {\n    return is_null(head(seqs))\n           ? null\n           : pair(accumulate(op, init, $\\langle{}$??$\\rangle$), \n                  accumulate_n(op, init, $\\langle{}$??$\\rangle$));\n}\n      "}],"solution":[{"tag":"SNIPPET","latex":false,"id":26,"eval":true,"prependLength":5,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQAHAGwIGcAKADwBpQBPASlABvbKFGgATgFMyBcbXagA1LwDc2AL65CpSjVABDEiQIBbAg31lJAfSKsqdbhSIUy3ZpICOzAcLETpWVoKZltzBlYAC0l9ABNWD28+PhF-NNAAflAicNT0sQAuen0KcVZDYzMLK3tHUGdXbhN9Og5QAF4APlBouI4+dy8fAbz8sYrTc0sbOwcnFzdQZtaFLtAyEoj2AdBE4b41TWwSGmYyXa9rRI7QBhCyVjuz1gBGbhRuTB2nh4AWbgArNwAGw7UZjCE-VgAdm4AA5uABOb73V4ABm4LzeoBeKGSagmVWmtlYjBY3AxF08Vy8ByAA","body":"function accumulate_n(op, init, seqs) {\n    return is_null(head(seqs))\n           ? null\n           : pair(accumulate(op, init, map(x => head(x), seqs)),\n                  accumulate_n(op, init, map(x => tail(x), seqs)));\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.37","id":"#ex-2.37","child":[{"body":"\n    Suppose we represent vectors ","tag":"#text"},{"body":"$v=(v_{i})$","tag":"LATEX"},{"body":" as\n    \n    sequences of numbers, and matrices ","tag":"#text"},{"body":"$m=(m_{ij})$","tag":"LATEX"},{"body":"\n    as sequences of vectors (the rows of the matrix). For example, the matrix\n    ","tag":"#text"},{"body":"\n      \\[ \\left[ \n      \\begin{array}{llll}\n      1 & 2 & 3 & 4\\\\\n      4 & 5 & 6 & 6\\\\\n      6 & 7 & 8 & 9\\\\\n      \\end{array}\n      \\right] \\]\n    ","tag":"LATEX"},{"body":"\n\tis represented as the following sequence:\n\t","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":27,"eval":false,"body":"list(list(1, 2, 3, 4),\n     list(4, 5, 6, 6),\n     list(6, 7, 8, 9))"},{"body":"\n    With this representation, we can use sequence operations to concisely\n    express the basic matrix and vector operations.  These operations\n    (which are described in any book on matrix algebra) are the following:\n    ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"tag":"JAVASCRIPTINLINE","body":"dot_product("},{"body":"$v$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":", \t  "},{"body":"$w$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":")"}]},{"tag":"TD","child":[{"body":"\n\treturns the sum ","tag":"#text"},{"body":"$\\sum_{i}v_{i} w_{i}$","tag":"LATEX"},{"body":";\n\t","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"tag":"JAVASCRIPTINLINE","body":"matrix_times_vector("},{"body":"$m$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":", \t  "},{"body":"$v$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":")"}]},{"tag":"TD","child":[{"body":"\n\treturns the vector ","tag":"#text"},{"body":"$t$","tag":"LATEX"},{"body":", where\n\t","tag":"#text"},{"body":"$t_{i} =\\sum_{j}m_{ij}v_{j}$","tag":"LATEX"},{"body":";\n\t","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"tag":"JAVASCRIPTINLINE","body":"matrix_times_matrix("},{"body":"$m$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":", \t  "},{"body":"$n$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":")"}]},{"tag":"TD","child":[{"body":"\n\treturns the matrix ","tag":"#text"},{"body":"$p$","tag":"LATEX"},{"body":", where\n\t","tag":"#text"},{"body":"$p_{ij}=\\sum_{k} m_{ik}n_{kj}$","tag":"LATEX"},{"body":";\n\t","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"tag":"JAVASCRIPTINLINE","body":"transpose("},{"body":"$m$","tag":"LATEX"},{"tag":"JAVASCRIPTINLINE","body":")"}]},{"tag":"TD","child":[{"body":"\n\treturns the matrix ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":", where\n\t","tag":"#text"},{"body":"$n_{ij}=m_{ji}$","tag":"LATEX"},{"body":".\n\t","tag":"#text"}]}]}]},{"body":"\n    We can define the dot product as","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/2.2.3#footnote-4"},{"tag":"SNIPPET","latex":false,"id":28,"eval":true,"prependLength":16,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQAHAGwIGcAKADwBpQBPASlABvbKFGgATgFMyBcbXagA1LwDc2AL65CpSjVCUAtpLZdeA4WInTZ80ACpVGrcXLVaAQxIkCBgg3dkkgD6RKxUdNwURBRk3MySAI7M5iJiUjJyoBTMIX4MrAAWku4AJqzxSXx8qZa1APygRHk1tWIAXPTuFOKsnt6+-oFhEVnRsaAG7nQcoAC8AHygRaUcfHGJyWstrTugfT5+AcGh4ZFj3JPTCgv6Xfnsa6AVm3xqmvguurQlVGRBdOIqCUCORWAA3bgAdxSlnSNj2XgOg0krEYLG4AAZuPsBkcQqxDMZuABGbgMbJkcFQqqvJzYH5-AFAkGU8nMSmk1CPNmUzDcAAsVRUQA","body":"function dot_product(v, w) {\n    return accumulate(plus, 0, accumulate_n(times, 1, list(v, w)));\n} "},{"body":"\n    Fill in the missing expressions in the following\n    functions\n    for computing the other matrix operations.  (The\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"accumulate_n"},{"body":"\n\tis declared in       \n      \n    exercise ","tag":"#text"},{"tag":"REF","body":"2.36","href":"/sicpjs/2.2.3#ex-2.36"},{"body":".)\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction matrix_times_vector(m, v) {\n    return map($\\langle{}$??$\\rangle$, m);\n}\nfunction transpose(mat) {\n    return accumulate_n($\\langle{}$??$\\rangle$, $\\langle{}$??$\\rangle$, mat);\n}\nfunction matrix_times_matrix(m, n) {\n    const cols = transpose(n);\n    return map($\\langle{}$??$\\rangle$, m);\n}\n      "}],"solution":[{"tag":"SNIPPET","latex":false,"id":29,"eval":true,"prependLength":20,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBDEkggWwIBs6yBTAfSIAoqABwA0oCkQpkxAZy4BHGQEpQAb2yhNoAE5cyBbbQoy+7NvwAWXOgBN+cxUqUatrrQH5QRMy7euAXKBCdBTa-AxMrBzcgqLiktKgzHRC-AAeoAC8AHygVrbpSrIKykW+fhWaESzsnLwCwmISUmLJqRk5oGQh5mlFoA6lSgDc2AC+uISklDRBbAQy6WIAnirqrrr6hqAZANSgy6MT+MTk1LSUzFyLaStr5ZsGtBkAVAdHk6cztDZUZDxCbRUGwEcj8ABuYgA7vcNnonvRGDVolx+EJ5jIxAAGMTVKJ1Pj8S7XMQARjEbGMZAh0KcI3Gn2m5ySnG0FDSPGJJnBXHIVDCzDE4NhWke2za-CBUKyuV+-0BwNB1KlQv6zHpEymZ1mZG0dCIMiEVDk-GSZBFmjFtDxtW4hOCoTE3jYbFanA1JyZszNbI5XJ4PvZ-CIrQtoBINBkZHDVDYMiyXT1BqNJvVozhW1oEo6uQlyxloDlAKBILBtwO-Qjcf6RA92AjBuj4ITlKj-FJONQncwWPpDajSVJLap-Fb1PJqDEmH6Y-4mDEAFYyTORxO105Rv3o8wUMO27OJygpyu2wAWRdiABsJ+pAHYxAAOMQATg3uEDfooV25vLI-NNE7CqMICJvqhrGqizCkvSIEfpyX7XAGrJBlBrQoCMQA","body":"function matrix_times_vector(m, v) {\n    return map(row => dot_product(row, v), m);\n}\nfunction transpose(mat) {\n    return accumulate_n(pair, null, mat);\n}\nfunction matrix_times_matrix(n, m) {\n    const cols = transpose(m);\n    return map(x => map(y => dot_product(x, y), cols), n);\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.38","id":"#ex-2.38","child":[{"body":"\n    The\n     ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"accumulate"},{"body":"function\n    is also known as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fold_right"},{"body":",\n    because it combines the first element of the sequence with the result\n    of combining all the elements to the right.  There is also a\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fold_left"},{"body":",\n    which is similar to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fold_right"},{"body":",\n    except that it combines elements working in the opposite direction:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":30,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8qAbAEwH0GBTPMgCioAcANKApEKlAIYMhAZ3YBHAu1LsAlKADe2UNrrFy1WmPYAnbsfbSCDMkPPSyazTuehzZAscPSWRKwzMWDlouIToA-K4WVmTBoSEAXMJkJrx8AZbWQgAW7OJM6Q4qQrFxpdpk4hT+doUA3CUAviVuHobJpiJiFJIy8orKKvVN+IysHFzcDBT2Qr4MUqBT9twAjEIoQpgqg0A","body":"function fold_left(op, initial, sequence) {\n    function iter(result, rest) {\n        return is_null(rest)\n               ? result\n               : iter(op(result, head(rest)), \n                      tail(rest));\n    }\n    return iter(initial, sequence);\n} "},{"body":"\n    What are the values of\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":31,"eval":true,"prependLength":8,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChslAM4CGAtgKahEGUDGNArifQDZEAuZ2NA9gHYFtQAM27MAJgH0ATgEsA5gAtBAXloMmrDgG5cQ+rxpsZfUGJkA3GWLIAKAB4AaUAE8AlKADe2UD9BSybPRSvKB2oGDOOgC+uqKSsopsNmaW1k4AjE7MMgI2mahOmK6uWkA","body":"fold_right(divide, 1, list(1, 2, 3)); "},{"tag":"SNIPPET","latex":false,"id":32,"eval":true,"prependLength":15,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8qAbAEwH0GBTPMgCioAcANKApEKlAIYMhAZ3YBHAu1LsAlKADe2UNrrFy1WmPYAnbsfbSCDMkPPSyazTuehzZAscPSWRKwzMWDlouIToA-K4WVmTBoSEAXMJkJrx8AZbWQgAW7OJM6Q4qQrFxpdpk4hT+doUA3CUAviVuHobJpiJiFJIy8orKKvVN+HqUNKBMFABuFEzs3AAeQgCejs3s7p6gC6Bgy0O49MxsnDyTM3NCAIxCDBT23DeoQpgqg0A","body":"fold_left(divide, 1, list(1, 2, 3)); "},{"tag":"SNIPPET","latex":false,"id":33,"eval":true,"prependLength":4,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChslAM4CGAtgKahEGUDGNArifQDZEAuZ2NA9gHYFtQAM27MAJgH0ATgEsA5gAtBAXloMmrDgG5cI8dPlKAFMxkCANKF4tml0wKMBGSykuYAlO61A","body":"fold_right(list, null, list(1, 2, 3)); "},{"tag":"SNIPPET","latex":false,"id":34,"eval":true,"prependLength":11,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8qAbAEwH0GBTPMgCioAcANKApEKlAIYMhAZ3YBHAu1LsAlKADe2UNrrFy1WmPYAnbsfbSCDMkPPSyazTuehzZAscPSWRKwzMWDlouIToA-K4WVmTBoSEAXMJkJrx8AZbWQgAW7OJM6Q4qQrFxpdpk4hT+doUA3CUAviVuHobJpiJiFJIy8orKKvVN+IysHFzcDBT2Qr4MUqBT9twAjEIoQpgqg0A","body":"fold_left(list, null, list(1, 2, 3)); "},{"body":"\n    Give a property that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"op"},{"body":"\n    should satisfy to guarantee that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fold_right"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fold_left"},{"body":"\n    will produce the same values for any sequence.\n    ","tag":"#text"}],"solution":[{"tag":"OL","child":[{"tag":"LI","child":[{"tag":"SNIPPET","latex":false,"id":35,"eval":true,"prependLength":10,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChslAM4CGAtgKahEGUDGNArifQDZEAuZ2NA9gHYFtQAM27MAJgH0ATgEsA5gAtBAXloMmrDgG5cQ+rxpsZfUGJkA3GWLIAKAB4AaUAE8AlKADe2UD9BSybPRSvKB2oGDOOgC+uqKSsopsNmaW1k4AjE7MMgI2mahOmK6uOnhg-gQsbABcoOloAKxAA","body":"1.5 "}]},{"tag":"LI","child":[{"tag":"SNIPPET","latex":false,"id":36,"eval":true,"prependLength":17,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8qAbAEwH0GBTPMgCioAcANKApEKlAIYMhAZ3YBHAu1LsAlKADe2UNrrFy1WmPYAnbsfbSCDMkPPSyazTuehzZAscPSWRKwzMWDlouIToA-K4WVmTBoSEAXMJkJrx8AZbWQgAW7OJM6Q4qQrFxpdpk4hT+doUA3CUAviVuHobJpiJiFJIy8orKKvVN+HqUNKBMFABuFEzs3AAeQgCejs3s7p6gC6Bgy0O49MxsnDyTM3NCAIxCDBT23DeoQpgqg7ggkRlkiQAMaFcAGzAkGgsGAoA","body":"0.16666666666666666 "}]},{"tag":"LI","child":[{"tag":"SNIPPET","latex":false,"id":37,"eval":true,"prependLength":6,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChslAM4CGAtgKahEGUDGNArifQDZEAuZ2NA9gHYFtQAM27MAJgH0ATgEsA5gAtBAXloMmrDgG5cI8dPlKAFMxkCANKF4tml0wKMBGSykuYAlO514wUsgRY2AC5QAG1nMNDXSMxLUOtmWysbAF0UywTmNIzUlKA","body":"[1, [[2, [[3, [null, null]], null]], null]] "}]},{"tag":"LI","child":[{"tag":"SNIPPET","latex":false,"id":38,"eval":true,"prependLength":13,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8qAbAEwH0GBTPMgCioAcANKApEKlAIYMhAZ3YBHAu1LsAlKADe2UNrrFy1WmPYAnbsfbSCDMkPPSyazTuehzZAscPSWRKwzMWDlouIToA-K4WVmTBoSEAXMJkJrx8AZbWQgAW7OJM6Q4qQrFxpdpk4hT+doUA3CUAviVuHobJpiJiFJIy8orKKvVN+IysHFzcDBT2Qr4MUqBT9twAjEIoQpgqg7ggkRlkiQDaJ3MLR2ugZwC610JHG1d+t-eYs8-XQA","body":"[[[null, [1, null]], [2, null]], [3, null]] "}]}]},{"body":"\n      We can guarantee that ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fold_right"},{"body":"\n      and ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fold_left"},{"body":" produce\n      the same values for any sequence, if we require that\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"op"},{"body":" is commutative and associative.\n      They also produce the same values, if\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"op"},{"body":" is just associative and the\n      argument ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"initial"},{"body":" is a left and right\n      neutral element with respect to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"op"},{"body":".\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":39,"eval":true,"prependLength":8,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQAHAGwIGcAKADwBpQBPASlABvbKFGgATgFMyBcbXagA1LwDc2AL64QoZgEMAtpNC7mxkiQL6CDXWUnYSNZmVB4qDACYB9cRQDmABYuALxmFlY2dmr47t6+gWSsjCzcAAzcDBTOrACM3CjcmHx8KkA","body":"fold_right(plus, 0, list(1, 2, 3)); "},{"tag":"SNIPPET","latex":false,"id":40,"eval":true,"prependLength":15,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQAHAGwIGcAKADwBpQBPASlABvbKFGgATgFMyBcbXagA1LwDc2AL65CpSjVB4qDACYB9BpLxlWVOtwpEKlAIYNuzSQEcCk0pIHCxfWJyalpHSXFWKWYCBjJuaLJ-EUCxKRk5UApmEyJYhijJZiSU1LLRAH4JItiyUvLUgC4ssgjrOkKYuO4AC0knI06kvm56hvHQMicKAsS+PjVAzUD02TDWyPtHChc3T29fBY0tQ1NzS1ZGFm4ABm4GbKsARm4Ubkx5lSA","body":"fold_left(plus, 0, list(1, 2, 3)); "}]},{"tag":"EXERCISE","title":"Exercise 2.39","id":"#ex-2.39","child":[{"body":"\n    Complete the following definitions of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reverse"},{"body":"\n    (exercise ","tag":"#text"},{"tag":"REF","body":"2.18","href":"/sicpjs/2.2.1#ex-2.18"},{"body":") in terms of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fold_right"},{"body":"\n    and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fold_left"},{"body":"\n    from exercise ","tag":"#text"},{"tag":"REF","body":"2.38","href":"/sicpjs/2.2.3#ex-2.38"},{"body":":\n    ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction reverse(sequence) {\n    return fold_right((x, y) => $\\langle{}$??$\\rangle$, null, sequence);\n}\n      "},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nfunction reverse(sequence) {\n    return fold_left((x, y) => $\\langle{}$??$\\rangle$, null, sequence);\n}\n      "}],"solution":[{"tag":"SNIPPET","latex":false,"id":41,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsCcBTANwLwGcCAKAGwEsyAXSgRgBpQAWdgVnYE52zAGzsU3AJTiA3EA","body":"reverse(list(1, 4, 5, 9, 16, 25)); "},{"tag":"SNIPPET","latex":false,"id":42,"eval":true,"prependLength":4,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChslAM4CGAtgKahEGUDGNArifQDZEAuZ2NA9gHYFtQAM27MAJgH0ATgEsA5gAtBAXloMmrDgG5cQ+rxpsZfUFLIA3MlIJkAFDYCO9MgbIBKUAG9soX6bJs9FK8wqKSsopstrYAHgA0oACeHsoAfJQADhkuYraJCcwyArFubgk+fpVV1X68LMwJjs6ubjoAvrhmltZ2hcUAjAkALAkArAkAnAn9AGwJKKOlWkA","body":"function reverse(sequence) {\n    return fold_right((x, y) => append(y, list(x)), \n                      null, sequence);\n} "},{"tag":"SNIPPET","latex":false,"id":43,"eval":true,"prependLength":11,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8qAbAEwH0GBTPMgCioAcANKApEKlAIYMhAZ3YBHAu1LsAlKADe2UNrrFy1WmPYAnbsfbSCDMkPPSyazTuehzZAscPSWRKwzMWDlouIToA-K4WVmTBoSEAXMJkJrx8AZbWQgAW7OJM6Q4qQrFxpdpk4hT+doUA3CUAviVuHobJpiJiFJIy8orKKvVN+HqUNJEAbiay3LIKSiSqGs3s7p50jKwcXNzcAB5CAJ5qALwAfKB8laaHQntFoL4MUqBz-YuD2MPmU8YzDBR7NwAIxCAAsQgArEIAJxCYEANiEKEhKkGQA","body":"function reverse(sequence) {\n    return fold_left((x, y) => pair(y, x), null, sequence);\n} "}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Nested Mappings","tag":"#text"}]},{"tag":"TEXT","id":"#p15","child":[{"body":"\n    We can extend the sequence paradigm to include many computations that are\n    commonly expressed using nested loops.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/2.2.3#footnote-5"},{"body":"\n    Consider this problem: Given a positive integer\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":", find all ordered pairs of distinct positive\n    integers ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$j$","tag":"LATEX"},{"body":",\n    where ","tag":"#text"},{"body":"$1\\leq j < i\\leq n$","tag":"LATEX"},{"body":", such that\n    ","tag":"#text"},{"body":"$i +j$","tag":"LATEX"},{"body":" is prime.  For example, if\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" is 6, then the pairs are the following:\n    ","tag":"#text"},{"body":"\n      \\[\n      \\begin{array}{c|ccccccc}\n      i     & 2 & 3 & 4 & 4 & 5 & 6 & 6 \\\\\n      j     & 1 & 2 & 1 & 3 & 2 & 1 & 5 \\\\\n      \\hline\n      i+j   & 3 & 5 & 5 & 7 & 7 & 7 & 11\n      \\end{array}\n      \\]\n    ","tag":"LATEX"},{"body":"\n    A natural way to organize this computation is to generate the sequence\n    of all ordered pairs of positive integers less than or equal to\n    ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":", filter to select those pairs whose sum is\n    prime, and then, for each pair ","tag":"#text"},{"body":"$(i, j)$","tag":"LATEX"},{"body":" that\n    passes through the filter, produce the triple\n    ","tag":"#text"},{"body":"$(i, j, i+j)$","tag":"LATEX"},{"body":".\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p16","child":[{"body":"\n    Here is a way to generate the sequence of pairs: For each integer\n    ","tag":"#text"},{"body":"$i\\leq n$","tag":"LATEX"},{"body":", enumerate the integers\n    ","tag":"#text"},{"body":"$j < i$","tag":"LATEX"},{"body":", and for each such\n    ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$j$","tag":"LATEX"},{"body":"\n    generate the pair ","tag":"#text"},{"body":"$(i, j)$","tag":"LATEX"},{"body":".  In terms of\n    sequence operations, we map along the sequence\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"enumerate_interval(1, n)"},{"body":".\n      \n    For each ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":" in this sequence, we map along the\n    sequence\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"enumerate_interval(1, i - 1)"},{"body":".\n      \n    For each ","tag":"#text"},{"body":"$j$","tag":"LATEX"},{"body":" in this latter sequence, we\n    generate the pair\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(i, j)"},{"body":".\n    This gives us a sequence of pairs for each ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":".\n    Combining all the sequences for all the ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":" (by\n    accumulating with ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":") produces the\n    required sequence of pairs:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-6","body":"6","href":"/sicpjs/2.2.3#footnote-6"},{"tag":"SNIPPET","latex":false,"id":44,"eval":true,"prependLength":10,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBTIggWzoCcBDMugfQqK9YA3dgBsAFCKoB3ADSgAFhQDm8gJSgA3tlA7QrOmQKtakqaAB8C5fO267ugPyhGIkbft2AXKAAO7CqwS0jLuHmE6DMxsnDx8AsLipqAA1KAAjHKKKqqqANzYAL64JDQAzmTOoAC8oABs+djsJCTMBCIxYuw+PgwAJnKhYS4iA+G6TF1iFNWWEz5iAFYzoCIU5VNyC6ohY7v2kSwcXLz8bAliGaDTALTpOTt7ugfRx3FnohdyRDl5QA","body":"accumulate(append, \n           null, \n           map(i => map(j => list(i, j),\n                        enumerate_interval(1, i - 1)),\n               enumerate_interval(1, n))); "},{"body":"\n    The combination of mapping and accumulating with\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"append"},{"body":" is so common in this sort of program\n    that we will isolate it as a separate\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":45,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8AbAQzIFtGAHACjwBpQBnAKYBHAJSgA3tlAzQAJ0FkCc2oxIkCLAkzKDOHdoKIATPkW30+bLrwEjRogNzYAvrgbNrnAB6gAvAB8oPQU-GQ+fN6ifCFhnACMfCh8mHwALA6OQA","body":"function flatmap(f, seq) {\n    return accumulate(append, null, map(f, seq));\n} "},{"body":"\n    Now filter this sequence of pairs to find those whose sum is prime. The\n    filter predicate is called for each element of the sequence; its argument\n    is a pair and it must extract the integers from the pair. Thus, the\n    predicate to apply to each element in the sequence is\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":46,"eval":true,"prependLength":23,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBnARwIEMAnAUwAoAPASlADe2UCNAcyBVrW6gAVKG4BubAF9chUpRr0AtswA2+9nTIB9ACYUAbhTpVWnIvyGix7CVNB4KRcxeu29o4ANKi8ymoa5NS03r7+NnYORKFkxmaWifbOwqLikrSMLBycaSYJgaz8AHygRLmujQD8dQ2NogBcoJkU5sal6RVJoU5t7aAtZRkBSWPtXXF+PUkhoFND9qAA1KAAjOGq+MTR2j19dJzMoQBGOa75ntegAKSgzKAAvF+gAAwR6sctLRbKYAA6sCg6LhOQRtB60WhfD66AxGcrLIJOf5HTQxUAg8GQ9imOgEHScUHMChVWH3dwFfF0MEQqGcAAW7GY5gpVJpOw5XNKVP0POpvHF2IJLOJpPJ+lsZE4AA5QgBOCVAA","body":"function is_prime_sum(pair) {\n    return is_prime(head(pair) + head(tail(pair)));\n} "},{"body":"\n    Finally, generate the sequence of results by mapping over the filtered\n    pairs using the following\n    function,\n    which constructs a triple consisting of the two elements of the pair along\n    with their sum:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":47,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBbAQwGsBTAfQAcGKAnNgZwJ0AFF14BKUAG9soOaB4syBHrQA2FfmWEALFgwAmo7j3EAaUHsPCy3NcYnnQs+a7fyrRsadABqS-pGthT23uLhANzYAL64jKycJgJCwhpawgAcFgCckUA","body":"function make_pair_sum(pair) {\n    return list(head(pair), head(tail(pair)), \n                head(pair) + head(tail(pair)));\n} "},{"body":"\n    Combining all these steps yields the complete\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":48,"eval":true,"prependLength":43,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBbAQwGsBTAfQAcGKAnNgZwJ0AFF14BKUAG9soOaB4syBHrQA2FfmWEALFgwAmo7j3EAaUHsPCy3NcYnnQs+a7fyrRsadABqS-pGthT23uLhANzYAL64hKSUNKD8AI4EDIrCAB6SMq6KyqqgWaAAVMVRsfjE5NS0-IxqaixabAYUAG6aVDzCRLkucgUqtHgURAZtnd29RBYo4pXVCXWgYxNTXfw9fRZkLWSbMwP5SiPJaRksNgdH2z4AfKBEg+5yAPzPr28AXKDtXQMLRurQBMws-W+7k++1B03uULcf3WkzB912oFhhzRPT8oAAjIsYstakkwUD+MIGBYAEYneTDIo00AAUlADFAAF5uaAAAxLEmJWiaTg8Ch0a79aSvRm0WjcznJRrNOFbHb9AXxUnC-ii8XsQQiMLS06FHV6iW6QIOHz+Tw2Ow28JEqpaoVrNQMMiMDjCPAWfgsFL0oZnIoMEgkIQET37KkcDgsCYQmNqCw+v0BoORYmC1ZJoQsHhe9jjfY8DoMexqKgAdwsOgoAHMdCGFGH1HXQE9Gy3Ea5PkRU-35H9vMIa-WR285AWJcX9mwy0XK9Wu-58Q3m62XXEau6OGKJQIhJwTJSpXkGR36AxfYxWGfeCe6BZp24xmpy8IRYf9S+3xnICP1jDMKC5J4MwAKwg0ANC0H8LCgpx32AtC3jnIsSyXIhy1XYRN1AcCAFoCXCMxUPQ9xMIXUtcJXKsCIhZ1d2wP9j0NJ8eEpAA2RYgA","body":"function prime_sum_pairs(n) {\n    return map(make_pair_sum, \n               filter(is_prime_sum, \n                      flatmap(i => map(j => list(i, j), \n                                       enumerate_interval(1, i - 1)),\n                              enumerate_interval(1, n))));\n} "}]},{"tag":"TEXT","id":"#p17","child":[{"body":"\n    Nested mappings are also useful for sequences other than those that\n    enumerate intervals.  Suppose we wish to generate all the \n    \n    permutations\n    of a set ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":"; that is, all the ways of ordering\n    the items in the set.  For instance, the permutations of\n    ","tag":"#text"},{"body":"$\\{1, 2, 3\\}$","tag":"LATEX"},{"body":" are\n    ","tag":"#text"},{"body":"$\\{1, 2, 3\\}$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$\\{ 1, 3, 2\\}$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$\\{2, 1, 3\\}$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$\\{ 2, 3, 1\\}$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$\\{ 3, 1, 2\\}$","tag":"LATEX"},{"body":", and\n    ","tag":"#text"},{"body":"$\\{ 3, 2, 1\\}$","tag":"LATEX"},{"body":".  Here is a plan for generating\n    the permutations of ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":": For each item\n    ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" in ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":",\n    recursively generate the sequence of permutations of\n    ","tag":"#text"},{"body":"$S-x$","tag":"LATEX"},{"body":",","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-7","body":"7","href":"/sicpjs/2.2.3#footnote-7"},{"body":" and adjoin\n    ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" to the front of each one.  This yields, for\n    each ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" in ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":", the\n    sequence of permutations of ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":" that begin\n    with ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":".  Combining these sequences for\n    all ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":" gives all the permutations\n    of ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":":","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-8","body":"8","href":"/sicpjs/2.2.3#footnote-8"},{"tag":"SNIPPET","latex":false,"id":49,"eval":true,"prependLength":5,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8AbAQzIFtGAHACjwBpQBnAKYBHAJSgA3tlAzQAJ0FkCc2oxIkCLAkzKDOHdoKIATPkW30+bLrwEjRogNzYAvrkKlKNUIblayzNRE-Jz84lKy8orKtBT8APrm9PSh4pHpsiCggizsZACedmQA-NIZkcWg9HFknEn0aeUyWULCBEYkgqAkNAEURP0A5tm5BUVlTaAAXHQ61pwAHqAAvAB8oPPsK+vsjBRyi3zsojwTk+dNvv6BNCEKLFQAbnoLfGEOpxfnYc5u2FcEAJeYKcar8WoARj4KD4mAcjiAA","body":"function permutations(s) {\n    return is_null(s)             // empty set?\n           ? list(null)           // sequence containing empty set\n           : flatmap(x => map(p => pair(x, p),\n                              permutations(remove(x, s))),\n                     s);\n} "},{"body":"\n    Notice how this strategy reduces the problem of generating permutations of\n    ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":" to the problem of generating the\n    permutations of sets with fewer elements than\n    ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":".  In the terminal case, we work our way down\n    to the empty list, which represents a set of no elements. For this, we\n    generate\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(null)"},{"body":",\n    which is a sequence with one item, namely the set with no elements.  The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"remove"},{"body":"function\n    used in ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"permutations"},{"body":" returns all the items in\n    a given sequence except for a given item.  This can be expressed as a\n    simple filter:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":50,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQAnAUwFsqA3BgCgrOYBpQAzgwCOBBqQYBKUAG9soBfQZkCdWngoAbHnQ4APUAF4AfKACEofUcOHQ3ZpN7zFL166GjxJKQG5sAX1xNcQBzMgALDkYWdg5Mfk0KATIOAEZ+FH540AAWfgBWSSKfIA","body":"function remove(item, sequence) {\n    return filter(x => ! (x === item),\n                  sequence);\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.40","id":"#ex-2.40","child":[{"body":"\n    Write a\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unique_pairs"},{"body":"\n    that, given an integer ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":", generates the\n    sequence of pairs ","tag":"#text"},{"body":"$(i, j)$","tag":"LATEX"},{"body":" with\n    ","tag":"#text"},{"body":"$1\\leq j < i\\leq n$","tag":"LATEX"},{"body":".  Use\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"unique_pairs"},{"body":"\n    to simplify the definition of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"prime_sum_pairs"},{"body":"\n    given above.\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":51,"eval":true,"prependLength":43,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBTIggWzoCcBDMugfQqK9YA3dgBsAFCKoB3ADSgAFhQDm8gJSgA3tlA7QrOmQKtakqaAB8C5fO267ugPyhGIkbft2AXKAAO7CqwS0jLuHmE6DMxsnDx8AsLipqAA1KAAjHKKKqqqANzYAL64hKSUNKBM7ADWPH4B3ADOzGJ1rOpadvqGxqAiFA1kYvJ07AAmLf5tmSPjZP7irTlyoeF2w2MTAeqp67Pzm205+UX4xOTUtA0AjgTs+mIAHu2hXUa0D6AAVKAPx8VnZUulVcdAG3FGFEE-SogSIz06BjeoDwfFG4Mh0NhchQeUKp1KF2RqPRUIaMLERDkXDBENJMPhulePWut3u1LIJMx6ksRBWHicvNWOm8tIoo1BYnZnLJrDkcL59icUtFMoVXiJRDRKvJlNAyoxMpS6VxRRK53KovFDTE7DkACMGTombQ7aAAKSgdigAC8vtAAAY-vjzbR+twfKwKCwKY69IierRfd7QA1gSJQRztbCTf8CeUwxGozwmkwDrHnaAC5Ho7sy0ba3MKAtJjkc8HAciRJxKj4xHg5A06Fdy-HaOwSCRmAQu1wbT4fAxRnLpyI5D2+wOh0c8e3CcQKDdapNrXDNC9R53u+xexQfZZ1wArO+9fqDChyB+qZZCn9hSIsDguF4fg2ASMQMkrUAAFpjS-UA1R-f9oiAuJQNEcC5W3U0AUJQsWEaZhw2PGMzwRbpaHXSoaiI+oS2-X8dBREQBDEKsiwIph6IYsJ90PGjWBPVsgzw4tCNaa0ADY8iAA","body":"function unique_pairs(n) {\n    return flatmap(i => map(j => list(i, j), \n                            enumerate_interval(1, i - 1)), \n                   enumerate_interval(1, n));\n}\nfunction prime_sum_pairs(n) {\n    return map(make_pair_sum, \n               filter(is_prime_sum, \n                      unique_pairs(n)));\n} "}]},{"tag":"EXERCISE","title":"Exercise 2.41","id":"#ex-2.41","child":[{"body":"\n    Write a\n    function\n    to find all ordered triples of distinct positive integers\n    ","tag":"#text"},{"body":"$i$","tag":"LATEX"},{"body":", ","tag":"#text"},{"body":"$j$","tag":"LATEX"},{"body":",\n    and ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" less than or equal to a given\n    integer ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" that sum to a given integer\n    ","tag":"#text"},{"body":"$s$","tag":"LATEX"},{"body":".\n    ","tag":"#text"}],"solution":[{"tag":"SNIPPET","latex":false,"id":52,"eval":true,"prependLength":12,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBTIggWzoCcBDMugfQqK9YA3dgBsAFCKoB3ADSgAFhQDm8gJSgA3tlA7QrOmQKtakqaAB8C5fO267ugPyhGIkbft2AXKAAO7CqwS0jLuHmE6DMxsnDx8AsLipqAA1KAAjHKKKqqqANzYAL64hKSUNKB4IpxM7D5ieHIAznQAjupadvqGxqDsJCTMBFVcYrU+DAAmci4icjV1DaDNbXmFxcTk1LTEFC0EPGSsFD4idI1iRO2hXUa0ldW1YhSgALyW92TzYgBWr5ZfAGs-qARBRGmQnnJvnIAaoQuEEYikbpIiwOFxePw2AkxBlQL8ALTpHLw5Fkjyo6IYuLY0S4uTPIlpEmhcn0RhomKY+J0vGXVZFEqbconAjnAAecgAnldOgZbqBxSlQFL8oKNmVaIdjqdGtwyPJONxGsx9VQxI1prLdDcengKCIBE8uExGsC+gMmEMYmJRZbQAAGBkuxrqF7hpaktmgHZ7A5HE5nC45NW4bWJvUGo0mphm3FB0AANjyQA","body":"function unique_triples(n) {\n    return flatmap(i => flatmap(j => map(k => list(i, j, k),\n                                         enumerate_interval(1, j - 1)),\n                                enumerate_interval(1, i - 1)),\n                   enumerate_interval(1, n));\n}\nfunction plus(x, y) {\n    return x + y;\n}\nfunction triples_that_sum_to(s, n) {\n    return filter(items => accumulate(plus, 0, items) === s,\n                  unique_triples(n));\n} "}]},{"tag":"FIGURE","scale":"60%","src":"img_original/ch2-Z-G-23.svg","id":"#fig-2.8","captionHref":"/sicpjs/2.2.3#fig-2.8","captionName":"Figure 2.8 ","captionBody":[{"body":"A solution to the eight-queens puzzle.\n\t","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 2.42","id":"#ex-2.42","child":[{"body":"\n      The \n      \"","tag":"#text"},{"body":"eight-queens puzzle","tag":"#text"},{"body":"\" asks how to place eight queens on a\n      chessboard so that no queen is in check from any other (i.e., no two\n      queens are in the same row, column, or diagonal).  One possible solution\n      is shown in figure ","tag":"#text"},{"tag":"REF","body":"2.8","href":"/sicpjs/2.2.3#fig-2.8"},{"body":".  One way to solve the\n      puzzle is to work across the board, placing a queen in each column.\n      Once we have placed ","tag":"#text"},{"body":"$k-1$","tag":"LATEX"},{"body":" queens, we must place\n      the ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":"th queen in a position where it does not\n      check any of the queens already on the board.  We can formulate this\n      approach recursively: Assume that we have already generated the sequence\n      of all possible ways to place ","tag":"#text"},{"body":"$k-1$","tag":"LATEX"},{"body":" queens in\n      the first ","tag":"#text"},{"body":"$k-1$","tag":"LATEX"},{"body":" columns of the board.  For\n      each of these ways, generate an extended set of positions by placing a\n      queen in each row of the ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":"th column.  Now\n      filter these, keeping only the positions for which the queen in the\n      ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":"th column is safe with respect to the other\n      queens.  This produces the sequence of all ways to place\n      ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" queens in the first\n      ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" columns.  By continuing this process, we\n      will produce not only one solution, but all solutions to the puzzle.\n      ","tag":"#text"},{"tag":"TEXT","id":"#p18","child":[{"body":"\n      We implement this solution as a\n      function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"queens"},{"body":",\n      which returns a sequence of all solutions to the problem of placing\n      ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" queens on an\n      ","tag":"#text"},{"body":"$n\\times n$","tag":"LATEX"},{"body":" chessboard.\n      The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"queens"},{"body":"\n      has an internal\n      function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"queens_cols"},{"body":"\n      that returns the sequence of all ways to place queens in the first\n      ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":" columns of the board.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":53,"eval":true,"prependLength":12,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQ8AbAQzIFtGAHACjwBpQBnAKYBHAJSgA3tlAzQAJ0FkCc2oxIkCLAkzKDOHdoKIATPkW30+bLrwEjRogNzYAvrkKlKNUEc2C5zIIA+hREunIAboz0nPRUAO58ABYUAOZJ4lKy8orKtHHxoAB8oCnp0tmVoAD8oOb09BVVsgBcoOyMFHKxCTxNzQO+LP6BIWH+UTEFoADUoACMyWkZTq7uxOTUtMIEgkb8nABGVIxyxkH8FABegpn9HpveO3tEQSRU9AcA1ncDCkoqUBfUAAXjBoAADP0BrJavQKPwyJxBCx2GQAJ5BY6nYyiaEw0BtPAUejhTjsKiXLxEfigkoIi6MPB6L58ClUrb8UR9Am82QMZjWTgKRFBKh4ILPfZ0-F8uWyIVEQTxIJyBIy+Wa3mMYwAKyooSC7Io1M4SpVasSQJ5WttduyIrIYolUpp3Nl9r5QxGujG4UmnEWoGxZwu11u7s9fNdbw+31AAFoFg5Vtk3A7coCY+9PkcTqHLjdVm5sK6DgAOJxAA","body":"function queens(board_size) {\n    function queen_cols(k) {\n        return k === 0\n               ? list(empty_board)\n               : filter(positions => is_safe(k, positions),\n                        flatmap(rest_of_queens =>\n                                  map(new_row =>\n                                        adjoin_position(new_row, k,\n                                                        rest_of_queens),\n                                      enumerate_interval(1, board_size)),\n                                queen_cols(k - 1)));\n    }\n    return queen_cols(board_size);\n} "},{"body":"\n    In this\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"rest_of_queens"},{"body":"\n    is a way to place ","tag":"#text"},{"body":"$k-1$","tag":"LATEX"},{"body":" queens in the first\n    ","tag":"#text"},{"body":"$k-1$","tag":"LATEX"},{"body":" columns, and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"new_row"},{"body":"\n    is a proposed row in which to place the queen for the\n    ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":"th column.  Complete the program by\n    implementing the representation for sets of board positions, including the\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"adjoin_position"},{"body":",\n      \n    which adjoins a new row-column position to a set of positions, and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"empty_board"},{"body":",\n      \n    which represents an empty set of positions.  You must also write the\n    function","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"is_safe"},{"body":",\n    which determines for a set of positions whether the queen in the\n    ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":"th column is safe with respect to the others.\n    (Note that we need only check whether the new queen is safe—the\n    other queens are already guaranteed safe with respect to each other.)\n      ","tag":"#text"}]}],"solution":[{"tag":"SNIPPET","latex":false,"id":54,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBDAEwCsqKiB9AByoGcLKaACgBOVAO4AaUCSoAbKcICmPMgEpQAb2ygdoJWQLDanOhWGCTZkeKkzZqhcrUBubAF8gA","body":"function adjoin_position(row, col, rest) {\n    return pair(pair(row, col), rest);\n} "},{"tag":"SNIPPET","latex":false,"id":55,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsGMB7AOwGcAXUAUwFsAHMgTwH0AjAgQwCcATUAXlBEArgBsRAbiA","body":"const empty_board = null; "},{"tag":"SNIPPET","latex":false,"id":56,"eval":true,"prependLength":0,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQKBnAfXoEM8BTACgGsAaUAA5V6FSjXoBKUAG9soeaBLiyoPBQBO9Mo3VUA7qAC8oABbsWAE05nLnISLFFJEgNxyFSpyrWbtSgDZGoGQsFP7W5lb2otROEq7u8ursZATqtCwkJAQAtgT+LGRcdsL89FSMeCzqUoYAfDKJCs0trc2eWqC6BsY2UcIJbUPDisqjgcYhYSWSbiPzzcmp6aDlldWgAGSbTQt7Cj5aOvqgALSqGkcBoACEhoa7+3vdZ+NbO0+fF77HBgDU3yuVECdweXyeLwB122j3BQ0O2heoK6+jmcPkAF9eLCnmR1AR2PwcfspuFoo5nG4MUA","body":"function is_safe(k, positions) {\n    const first_row = head(head(positions));\n    const first_col = tail(head(positions));\n    return accumulate((pos, so_far) => {\n                         const row = head(pos);\n                         const col = tail(pos);\n                         return so_far &&\n                                first_row - first_col !==\n                                row - col &&\n                                first_row + first_col !==\n                                row + col &&\n                                first_row !== row;\n                      },\n                      true, \n                      tail(positions));\n} "},{"body":"\n      Putting it all together:\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":57,"eval":true,"prependLength":52,"program":"chap=2&prgrm=PTAEGUEkGEAVQFLlAJgHToMwChsDMBXAOwGMAXASwHsjQBDAEwCsqKiB9AByoGcLKaACgBOVAO4AaUCSoAbKcICmPMgEpQAb2ygdoJWQLDanOhWGCTZkeKkzZqhcrUBubAF9cMoitCKAtpxkAJ7sAEZUdMIMoAC8oEQEsrKu+MTk1LQUPOw8dHiKggDWUtx8At7qWrrSND54ZirsomKxoAAWioyCHV2l-Bk8qqqu1V51DWTsdq1kprLdnQwWvP21QyO6+oa0dCQkBH6JdGQFyzxSPFTseJHqMQB8mtrVL69vOmNkeuKtPUulw2e72Br0+NVkMzmZ0BINh1S2RlAl2ukVAADI0UC4djqvVhI1mqAALSgPGNaYAQhiMSxOJxhJJ0wxtLpcLJk0JAGpSRMpnJQFSaazWVzwejMcK6eymj9Bd8xBtJTo3BIWayyMICIopGq6bMKPM+uVBoCPKlSOVSbJjn46JxBHgLooAI6VLEInZ7A5HE6CO2cRREBhSBJJKS2+2OpEu9buXCEC0ZXwJPyKYTHRTsNgnYQANzo81kNnaFAA5m03fDFAZEUWWo82mW2rrdAB+eKJWQtnQALlAlnMddVksDBzTGazRBz+cLP25AEYpI3y7GzQn0jRQM6tYGeIJwpEGDkKAAvRSV3Try3bxSBvmyPeFC+vD2gQqxamgAAM3Ze7dkWRkII-iBCEB5RKov7VH29SyDmZyrN4sSPFkOR5AUxT9isxoOFBbLWmQEYiE47BUHg7A3ruyF4UqOhEUQihiDKLQPDRtGvIwLBsFw2EZIIDFMc0UjFGx7G0UojRkRRO4VMOYl0qOqbpick7TgWgiLqA4FHnwZ5DHJ8lvJRHB2I+xKgPOQwwroHhVjWtDGfee7aceemuGaxl7gAHIC2BAA","body":"// click here to see all solutions "}]},{"tag":"EXERCISE","title":"Exercise 2.43","id":"#ex-2.43","child":[{"body":"\n    Louis Reasoner is having a terrible time doing\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.42","href":"/sicpjs/2.2.3#ex-2.42"},{"body":".  His\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"queens"},{"body":"function\n    seems to work, but it runs extremely slowly. (Louis never does manage to\n    wait long enough for it to solve even the\n    ","tag":"#text"},{"body":"$6\\times 6$","tag":"LATEX"},{"body":" case.)  When Louis asks Eva Lu Ator\n    for help, she points out that he has interchanged the order of the nested\n    mappings in the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"flatmap"},{"body":",\n    writing it as\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":58,"eval":false,"body":"flatmap(new_row =>\n          map(rest_of_queens => \n                adjoin_position(new_row, k, rest_of_queens), \n              queen_cols(k - 1)), \n        enumerate_interval(1, board_size));"},{"body":"\n    Explain why this interchange makes the program run slowly.  Estimate\n    how long it will take Louis's program to solve the eight-queens\n    puzzle, assuming that the program in\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.42","href":"/sicpjs/2.2.3#ex-2.42"},{"body":" solves the puzzle in time\n    ","tag":"#text"},{"body":"$T$","tag":"LATEX"},{"body":".\n    ","tag":"#text"}],"solution":[{"body":"\n      Louis's program re-evaluates the application\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"queen_cols(k - 1))"},{"body":" in each iteration\n      of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"flatmap"},{"body":", which happens\n      ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":" times for each\n      ","tag":"#text"},{"body":"$k$","tag":"LATEX"},{"body":". That means overall Louis's program will\n      solve the puzzle in a time of about ","tag":"#text"},{"body":"$n^n T$","tag":"LATEX"},{"body":"\n      if the program in exercise ","tag":"#text"},{"tag":"REF","body":"2.42","href":"/sicpjs/2.2.3#ex-2.42"},{"body":" solves the\n      puzzle in time ","tag":"#text"},{"body":"$T$","tag":"LATEX"},{"body":".\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/2.2.3#footnote-link-1","child":[{"body":"This is, in fact,\n    precisely the \n     ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"fringe"},{"body":"function\n    from exercise ","tag":"#text"},{"tag":"REF","body":"2.28","href":"/sicpjs/2.2.2#ex-2.28"},{"body":".  Here we've renamed it\n    to emphasize that it is part of a family of general sequence-manipulation\n    functions.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/2.2.3#footnote-link-2","child":[{"body":"\n    Richard Waters (1979) developed a program that automatically analyzes\n    traditional \n    \n    Fortran programs, viewing them in terms of maps, filters, and accumulations.\n    He found that fully 90 percent of the code in the Fortran Scientific\n    Subroutine Package fits neatly into this paradigm.  One of the reasons\n    for the success of Lisp as a programming language is that lists provide a\n    standard medium for expressing ordered collections so that they can be\n    manipulated using higher-order operations. Many modern languages, such as\n    Python, have learned this lesson.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/2.2.3#footnote-link-3","child":[{"body":"According to \n    \n    Knuth (1997b), this rule was formulated by\n    \n    W. G. Horner early in the nineteenth century, but the method was actually\n    used by Newton over a hundred years earlier.  Horner's rule evaluates\n    the polynomial using fewer additions and multiplications than does the\n    straightforward method of first computing\n    ","tag":"#text"},{"body":"$a_{n} x^n$","tag":"LATEX"},{"body":", then adding\n    ","tag":"#text"},{"body":"$a_{n-1}x^{n-1}$","tag":"LATEX"},{"body":", and so on.  In fact, it is\n    possible to prove that any algorithm for evaluating arbitrary polynomials\n    must use at least as many additions and multiplications as does\n    Horner's rule, and thus Horner's rule is an \n    \n    optimal algorithm for polynomial evaluation.  This was proved (for the\n    number of additions) by\n    \n    A. M. Ostrowski in a 1954 paper that essentially founded the modern study\n    of optimal algorithms.  The analogous statement for multiplications was\n    proved by \n    \n    V. Y. Pan in 1966.  The book by \n    \n      Borodin and Munro (1975)\n     \n    provides an overview of these and other results about optimal\n    algorithms.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/2.2.3#footnote-link-4","child":[{"body":"This definition uses\n    \n\tthe function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"accumulate_n"},{"body":"\n\tfrom exercise ","tag":"#text"},{"tag":"REF","body":"2.36","href":"/sicpjs/2.2.3#ex-2.36"},{"body":".\n      ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/2.2.3#footnote-link-5","child":[{"body":"This approach to nested\n    mappings was shown to us by \n    \n    David Turner, whose languages \n    \n    KRC and \n    \n    Miranda provide elegant formalisms for dealing with these constructs.  The\n    examples in this section (see also\n    exercise ","tag":"#text"},{"tag":"REF","body":"2.42","href":"/sicpjs/2.2.3#ex-2.42"},{"body":") are adapted from Turner 1981.\n    In section ","tag":"#text"},{"tag":"REF","body":"3.5.3","href":"/sicpjs/3.5.3"},{"body":", we'll see\n    how this approach generalizes to infinite sequences.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-6","count":6,"href":"/sicpjs/2.2.3#footnote-link-6","child":[{"body":"We're representing a pair here\n    as a list of two elements rather than as\n    an ordinary pair.\n    Thus, the \"","tag":"#text"},{"body":"pair","tag":"#text"},{"body":"\"","tag":"#text"},{"body":"$(i, j)$","tag":"LATEX"},{"body":" is\n    represented as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"list(i, j)"},{"body":",\n    not\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"pair(i, j)"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-7","count":7,"href":"/sicpjs/2.2.3#footnote-link-7","child":[{"body":"The set\n    ","tag":"#text"},{"body":"$S-x$","tag":"LATEX"},{"body":" is the set of all elements of\n    ","tag":"#text"},{"body":"$S$","tag":"LATEX"},{"body":", excluding\n    ","tag":"#text"},{"body":"$x$","tag":"LATEX"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-8","count":8,"href":"/sicpjs/2.2.3#footnote-link-8","child":[{"body":"The character sequence ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"//"},{"body":"\n      in JavaScript programs is\n    used to introduce ","tag":"#text"},{"tag":"EM","child":[{"body":"comments","tag":"#text"}]},{"body":". Everything from\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"//"},{"body":"\n    to the end of the line is ignored by the interpreter.  In this book we\n    don't use many comments; we try to make our programs self-documenting\n    by using descriptive names.","tag":"#text"}]}]