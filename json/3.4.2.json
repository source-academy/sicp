[{"id":"/sicpjs/3.4.2","tag":"TITLE","body":"3.4.2  \n    Mechanisms for Controlling Concurrency"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n    We've seen that the difficulty in dealing with concurrent \n    threads \n    is rooted in the need to consider the interleaving of the order of events\n    in the different \n    threads.  \n    For example, suppose we have two\n    threads, \n    one with three ordered events ","tag":"#text"},{"body":"$(a,b,c)$","tag":"LATEX"},{"body":"\n    and one with three ordered events ","tag":"#text"},{"body":"$(x,y,z)$","tag":"LATEX"},{"body":".\n    If the two \n    threads \n    run concurrently, with no constraints on how their execution is\n    interleaved, then there are 20 different possible orderings for the events\n    that are consistent with the individual orderings for the two \n    threads:\n    ","tag":"#text"},{"body":"\n      \\[ \\begin{array}{cccc}\n      (a,b,c,x,y,z) & (a,x,b,y,c,z) & (x,a,b,c,y,z) & (x,a,y,z,b,c)\\\\\n      (a,b,x,c,y,z) & (a,x,b,y,z,c) & (x,a,b,y,c,z) & (x,y,a,b,c,z)\\\\\n      (a,b,x,y,c,z) & (a,x,y,b,c,z) & (x,a,b,y,z,c) & (x,y,a,b,z,c)\\\\\n      (a,b,x,y,z,c) & (a,x,y,b,z,c) & (x,a,y,b,c,z) & (x,y,a,z,b,c)\\\\\n      (a,x,b,c,y,z) & (a,x,y,z,b,c) & (x,a,y,b,z,c) & (x,y,z,a,b,c)\n      \\end{array} \\]\n    ","tag":"LATEX"},{"body":"\n    As programmers designing this system, we would have to consider the\n    effects of each of these 20 orderings and check that each behavior is\n    acceptable.  Such an approach rapidly becomes unwieldy as the numbers of \n    threads and events increase.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n    A more practical approach to the design of concurrent systems is to\n    devise general mechanisms that allow us to constrain the interleaving\n    of concurrent \n    threads \n    so that we can be sure that the program\n    behavior is correct.  Many mechanisms have been developed for this\n    purpose.  In this section, we describe one of them, the ","tag":"#text"},{"tag":"EM","child":[{"body":"\n    serializer","tag":"#text"}]},{"body":".\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h1","child":[{"body":"Serializing access to shared state","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n    Serialization implements the following idea: \n    Threads \n    will execute concurrently, but there will be certain collections of\n    functions\n    that cannot be executed concurrently.  More precisely, serialization\n    creates distinguished sets of\n    functions\n    such that only one execution of a\n    function\n    in each serialized set is permitted to happen at a time. If some\n    function\n    in the set is being executed, then a \n    thread \n    that attempts to execute any\n    function\n    in the set will be forced to wait\n    until the first execution has finished.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n    We can use serialization to control access to shared variables.\n    For example, if we want to update a shared variable based on the\n    previous value of that variable, we put the access to the previous\n    value of the variable and the assignment of the new value to the\n    variable in the same\n    function.\n    We then ensure that no other\n    function\n    that assigns to the variable can run concurrently with this\n    function\n    by serializing all of these\n    functions\n    with the same serializer.  This guarantees that the value of the\n    variable cannot be changed between an access and the corresponding\n    assignment.\n  ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h2","child":[{"body":"Serializers","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n    To make the above mechanism more concrete, suppose that we have\n    extended \n    JavaScript\n    to include a\n    function\n    called \n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"concurrent_execute"},{"body":":\n      ","tag":"#text"},{"tag":"SNIPPET","latex":true,"eval":false,"body":"\nconcurrent_execute($f_{1}$, $f_{2}$, $\\ldots$, $f_{k}$)\n      "},{"body":"\n        Each ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" must be a function of no arguments.\n        The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"concurrent_execute"},{"body":"\n        creates a separate thread for each\n        ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":", which applies\n        ","tag":"#text"},{"body":"$f$","tag":"LATEX"},{"body":" (to no arguments).\n      \n    These \n    threads \n    all run concurrently.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-1","body":"1","href":"/sicpjs/3.4.2#footnote-1"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n    As an example of how this is used, consider\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":1,"eval":true,"prependLength":0,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAbAUwBdQAPUAXlAEYAGAbnwGMB7AOxYFcAnXohxIB9IuSI8SRABTSAlNQB8oAN4Vq6gFQVGoAL4AaXKBOmz5s-KWr1NSgGo6uvXMZA","body":"let x = 10;\n\nconcurrent_execute(() => { x = x * x; },\n                   () => { x = x + 1; }); "},{"body":"\n        This creates two concurrent\n\tthreads—","tag":"#text"},{"body":"$T_1$","tag":"LATEX"},{"body":", which sets\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" times\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":", and ","tag":"#text"},{"body":"$T_2$","tag":"LATEX"},{"body":",\n\twhich increments ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":".  After execution is\n\tcomplete, ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" will be left with one of five\n\tpossible values, depending on the interleaving of the events of\n        ","tag":"#text"},{"body":"$T_1$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$T_2$","tag":"LATEX"},{"body":":\n        ","tag":"#text"},{"tag":"TABLE","child":[{"tag":"TR","child":[{"tag":"TD","child":[{"body":"101:","tag":"#text"}]},{"tag":"TD","child":[{"body":"$T_1$","tag":"LATEX"},{"body":"\n            sets ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" to 100 and then\n            ","tag":"#text"},{"body":"$T_2$","tag":"LATEX"},{"body":" increments\n            ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" to 101.","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"121:","tag":"#text"}]},{"tag":"TD","child":[{"body":"$T_2$","tag":"LATEX"},{"body":" increments\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" to 11 and then\n            ","tag":"#text"},{"body":"$T_1$","tag":"LATEX"},{"body":" sets ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":"\n\t    to ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" times\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":".","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"110:","tag":"#text"}]},{"tag":"TD","child":[{"body":"$T_2$","tag":"LATEX"},{"body":" changes\n            ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" from 10 to 11 between the two\n            times that ","tag":"#text"},{"body":"$T_1$","tag":"LATEX"}]}]},{"tag":"TR","child":[{"tag":"TD"},{"tag":"TD","child":[{"body":"\n\t      accesses the value of\n              ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" during the evaluation of\n              ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x * x"},{"body":".\n\t    ","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"  11:","tag":"#text"}]},{"tag":"TD","child":[{"body":"$T_2$","tag":"LATEX"},{"body":" accesses\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":", then\n            ","tag":"#text"},{"body":"$T_1$","tag":"LATEX"},{"body":" sets ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":"\n\t    to 100,\n            then ","tag":"#text"},{"body":"$T_2$","tag":"LATEX"},{"body":" sets\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":".","tag":"#text"}]}]},{"tag":"TR","child":[{"tag":"TD","child":[{"body":"100:","tag":"#text"}]},{"tag":"TD","child":[{"body":"$T_1$","tag":"LATEX"},{"body":" accesses\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" (twice),\n            then ","tag":"#text"},{"body":"$T_2$","tag":"LATEX"},{"body":" sets\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":" to 11,\n            then ","tag":"#text"},{"body":"$T_1$","tag":"LATEX"},{"body":" sets\n\t    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":".","tag":"#text"}]}]}]}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n    We can constrain the concurrency by using serialized\n    functions,\n    which are created by ","tag":"#text"},{"tag":"EM","child":[{"body":"serializers","tag":"#text"}]},{"body":". Serializers are constructed by\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_serializer"},{"body":",\n      \n    whose implementation is given below.  A serializer takes a\n    function\n    as argument and returns a serialized\n    function\n    that behaves like the original\n    function.\n    All calls to a given serializer return serialized\n    functions\n    in the same set.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n    Thus, in contrast to the example above, executing\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":2,"eval":true,"prependLength":31,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxuCmCj4zIAjAAGUy4HUKWTM5jsXI7SUUqkfON0Mh+bwkCgcfhsXO8ASyATUtSC0SgcMacMAKjrfs+QkOAc2FarNbrzPDAGpQBHW0ITEA","body":"let x = 10;\n\nconst s = make_serializer();\n\nconcurrent_execute(s(() => { x = x * x; }),\n                   s(() => { x = x + 1; })); "},{"body":"\n    can produce only two possible values for\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":", 101 or 121.\n    The other possibilities are eliminated, because the execution of\n    ","tag":"#text"},{"body":"$T_1$","tag":"LATEX"},{"body":" and\n      ","tag":"#text"},{"body":"$T_2$","tag":"LATEX"},{"body":" cannot be interleaved.","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n    Here is a version of the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account"},{"body":"function\n    from section ","tag":"#text"},{"tag":"REF","body":"3.1.1","href":"/sicpjs/3.1.1"},{"body":",\n    where the deposits and withdrawals have been\n    \n    serialized:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":3,"eval":true,"prependLength":31,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+JZ7AyZBkpHyACN9JlCvD3HiIaBLlQ7FlPExLgImAwaDHk4kqHyBPGlIm2KBBQWiyQKCXhpXq8zW+Qa896zHnV13aAO4U++5PqBlIYhfMByFIPSiAQCFQyFQ2I3QBYsrIQiOpK696VU9YsmwAA40WSZ-OF4tThJDmsaB+gADUoB7jd3dp8PMHCc7fb7pIOoKKeey8JQzLMBGnpSlSNqSEe9BZNop5MBQZC2AILh3h4A5jMEJwZlmOaXCEoABmUKRgTQEH5MRtjZrmGwKqMQShCe56XhQcwKtR4FsJQAicRemYscKbHjCcD68cKKQPpRiTbLs+zYccpwkOcVw3GwdwMk84acOE0aNhqXw-D+-wobIaEYbYwYgYwbSRiZCgaNBRlRg2+QAIwAAx+R8uB0mQfjeI2HD8IJ1QCKU1JqIK8oJNZp5Vm02HOcZ3m1DJQjqQAKj5f5Vp2ZllAwmVeTGtQMUxZFCAIACsgVfqAKVpRlLnZSEuUFUVuWtRVXXVSEInce8Aj+S1XyHHFIgJWIbWoR1Q1ZSNvUnPl2DFdWZWJKtVWNjVmaMaRE3NQhHjtUw6UHa5OX-oU7wFdtA2UXd3VjZmE1TZd3wmEAA","body":"function make_account(balance) {\n    function withdraw(amount) {\n        if (balance > amount) {\n            balance = balance - amount;\n            return balance;\n        } else {\n            return \"Insufficient funds\";\n        }\n    }\n    function deposit(amount) {\n        balance = balance + amount;\n        return balance;\n    }\n    const protect = make_serializer();\n    function dispatch(m) {\n        return m === \"withdraw\" \n               ? protect(withdraw)\n               : m === \"deposit\"\n               ? protect(deposit)\n               : m === \"balance\"\n               ? balance\n               : error(m, \"unknown request -- make_account\");\n    }\n    return dispatch;\n} "},{"body":"\n    With this implementation, two \n    threads \n    cannot be withdrawing from or\n    depositing into a single account concurrently.  This eliminates the source\n    of the error illustrated in figure ","tag":"#text"},{"tag":"REF","body":"3.29","href":"/sicpjs/3.4.1#fig-3.29"},{"body":",\n    where Peter changes the account balance between the times when Paul accesses\n    the balance to compute the new value and when Paul actually performs the\n    assignment.  On the other hand, each account has its own serializer,\n    so that deposits and withdrawals for different accounts can proceed\n    concurrently.\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.39","id":"#ex-3.39","child":[{"body":"\n    Which of the five possibilities in the \n    concurrent \n    execution shown above remain if we instead serialize execution as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":4,"eval":true,"prependLength":31,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxuCmCj4zIAjAAGUy4HUKWTM5jsXI7SUUqkfON0Mh+bwkCgcfhsXO8ASSalqQWiUDhjSyASVwXhgBUtaEHNAn0OAc2DabYlrzPDAGpQBG-ZtPkITEA","body":"let x = 10;\n\nconst s = make_serializer();\n\nconcurrent_execute(  () => { x = s(() => x * x)(); },\n                   s(() => { x = x + 1;             })); "}]},{"tag":"EXERCISE","title":"Exercise 3.40","id":"#ex-3.40","child":[{"body":"\n    Give all possible values of ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x"},{"body":"\n    that can result from executing\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":5,"eval":true,"prependLength":0,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAbAUwBdQAPUAXlAEYAGAbnwGMB7AOxYFcAnXohxIB9IuSI8SRABTSAlNQB8oAN4Vq6gFQVGoAL4AaULlCmz5i+flLV6mpW0Od+uYyA","body":"let x = 10;\n\nconcurrent_execute(() => { x = x * x; }, \n                   () => { x = x * x * x; }); "},{"body":" Which of these possibilities remain if we instead use serialized\n    functions:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":6,"eval":true,"prependLength":31,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxuCmCj4zIAjAAGUy4HUKWTM5jsXI7SUUqkfON0Mh+bwkCgcfhsXO8ASyATUtSC0SgcMacMAKjrfvcnyEhwDmwrVZrdeZTf7zb4fvbJiAA","body":"let x = 10;\n\nconst s = make_serializer();\n\nconcurrent_execute(s(() => { x = x * x;     }),\n                   s(() => { x = x * x * x; })); "}]},{"tag":"EXERCISE","title":"Exercise 3.41","id":"#ex-3.41","child":[{"body":"\n    Ben Bitdiddle worries that it would be better to implement the bank\n    account as follows (where the commented line has been changed):\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":7,"eval":true,"prependLength":31,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+JZ7AyZBkpHyACN9JlCvD3HiIaBLlQ7FlPExLgImAwaDHk4kqHyBPGlIm2KBBQWiyQKCXhpXq8zW+Qa896zHnV13aAO4U++5PqBlIYhfMByFIPSiAQCFQyFQ2I3QBYsrIQiOpK696VU9YsmwAA40WSZ-OF4tThJDmsaB+gADUoB7jd3dp8PMHCc7fb7pIOoKKeey8JQzLMBGnpSlSNqSEe9BZNop5MBQZC2AILh3h4A5jMEJwZlmOaXHMCopGBNAQfkxG2NmuYbAqoxBKEJ7npeFDkcKlHgWwlACOxF6ZkxwoseMJwPtxmy8dR-H5NSaiCg+QgCKQJ5LiQbBZE0YCwRS2kBmU2y7Ps2HHKcJDnFcNxsHcDJPOGnDhNGjYal8Pw-v8KGyGhGG2MGIGMG0kauQoGjQc5UYNvkACMAAM8UfLgdJkH43iNhw-D8dUAilIpgrygkPmnlWbTYSFLkxbUUlCBZAAqsV-lWnbuWUDCVdFMa1HRDFkapACsSVfqAJVlRVoXVSEtUNU1tUjR1k3dSEQmce8AgJcNXyHPlIhKWIo2oeNi1VctM0nPV2DNdWbWJCdXWNj1mb0aR61DQhHhjUw5X3WFNX-oU7wNVd81Gb9U2rZm62bR93wmEAA","body":"function make_account(balance) {\n    function withdraw(amount) {\n        if (balance > amount) {\n            balance = balance - amount;\n            return balance;\n        } else {\n            return \"Insufficient funds\";\n        }\n    }\n    function deposit(amount) {\n        balance = balance + amount;\n        return balance;\n    }\n    const protect = make_serializer();\n    function dispatch(m) {\n        return m === \"withdraw\"\n               ? protect(withdraw)\n               : m === \"deposit\"\n               ? protect(deposit)\n               : m === \"balance\"\n               ? protect(() => balance)(undefined) // serialized\n               : error(m, \"unknown request -- make_account\");\n    }\n    return dispatch;\n} "},{"body":"\n    because allowing unserialized access to the bank balance can\n    result in anomalous behavior.  Do you agree?  Is there any\n    scenario that demonstrates Ben's concern?\n  ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.42","id":"#ex-3.42","child":[{"body":"\n    Ben Bitdiddle suggests that it's a waste of time to\n    create a new serialized\n    function\n    in response to every ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"withdraw"},{"body":" and\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"deposit"},{"body":" message.  He says that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account"},{"body":"\n    could be changed so that the calls to\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"protect"},{"body":"\n    are done outside the ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"dispatch"},{"body":"function.\n    That is, an account would return the same serialized\n    function\n    (which was created at the same time as the account) each time\n    it is asked for a withdrawal\n    function.","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":8,"eval":true,"prependLength":31,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+JZ7AyZBkpHyACN9JlCvD3HiIaBLlQ7FlPExLgImAwaDHk4kqHyBPGlIm2KBBQWiyQKCXhpXq8zW+Qa896zHnV13aAO4U++5PqBlIYhfMByFIPSiAQCFQyFQ2I3QBYsrIQiOpK696VU9YsmwAA40WSZ-OF4tThJDmsaB+gADUoB7jd3dp8PMHCc7fb7pIOoKKeey8JQzLMBGnpSlSNrAXIoHgWwlAcBmWY5pczJgTQEH5BhtjZrmCHSEhoC4fhHAnuel4KBolGofkNEXpmpFHvQWTaKeTAUGQtgCC4d4eAOYzBCchHEZccwKikjFoZJWEBmUoxBKELF0TJwpyShaEaZmymJKp4wnA+WmbCkD6GQk2y7PsgnHKcJDnFcNxsHcDJPOGnDhNGjYal8Pw-v8XGyDxfG2MGIGMG0kZ+fR3lxQ2+QAIwAAxpR8uB0mQfjeI2HD8Kh1QCKU1JqIK8oJKFp5Vm0gmxb5yW1GZQiOQAKilf5Vp2AVlAwjVRs1ISKbm7wCAArJlX6gDVdUNUlMYtf+hTvB1XWtTNA2LY2tT6RQ43pdNXyHGVIgVWIs3cfN21NUtIStR12DddWfWJLdQ33aN0lCJNx1lHNTD1R98XLT1q1tSc7XPZtykg8N+2HRlpHfCYQA","body":"function make_account(balance) {\n    function withdraw(amount) {\n        if (balance > amount) {\n            balance = balance - amount;\n            return balance;\n        } else {\n            return \"Insufficient funds\";\n        }\n    }\n    function deposit(amount) {\n        balance = balance + amount;\n        return balance;\n    }\n    const protect = make_serializer();\n    const protect_withdraw = protect(withdraw);\n    const protect_deposit = protect(deposit);\n    function dispatch(m) {\n        return m === \"withdraw\"\n               ? protect_withdraw\n               : m === \"deposit\"\n               ? protect_deposit\n               : m === \"balance\"\n               ? balance\n               : error(m, \"unknown request -- make_account\");\n    }\n    return dispatch;\n} "},{"body":"\n    Is this a safe change to make?  In particular, is there any difference\n    in what concurrency is allowed by these two versions of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account"},{"body":"?\n    ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h3","child":[{"body":"Complexity of using multiple shared resources","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n    Serializers provide a powerful abstraction that helps isolate the\n    complexities of concurrent programs so that they can be dealt with\n    carefully and (hopefully) correctly.  However, while using serializers\n    is relatively straightforward when there is only a single shared\n    resource (such as a single bank account), concurrent programming can\n    be treacherously difficult when there are multiple shared resources.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n    To illustrate one of the difficulties that can arise, suppose we wish to\n    \n    swap the balances in two bank accounts.  We access each account to find\n    the balance, compute the difference between the balances, withdraw this\n    difference from one account, and deposit it in the other account.\n    We could implement this as\n    follows:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-2","body":"2","href":"/sicpjs/3.4.2#footnote-2"},{"tag":"SNIPPET","latex":false,"id":9,"eval":true,"prependLength":57,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+JZ7AyZBkpHyACN9JlCvD3HiIaBLlQ7FlPExLgImAwaDHk4kqHyBPGlIm2KBBQWiyQKCXhpXq8zW+Qa896zHnV13aAO4U++5PqBlIYhfMByFIPSiAQCFQyFQ2I3QBYsrIQiOpK696VU9YsmwAA40WSZ-OF4tThJDmsaB+gADUoB7jd3dp8PMHCc7fb7pIOoKKeey8JQzLMBGnpSlSNqSEe9BZNop5MBQZC2AILh3h4A5jMEJwZlmOaXCEoABmUKRgTQEH5MRtjZrmGwKqMQShCe56XhQcwKtR4FsJQAicRemYscKbHjCcD68cKKQPpRiTbLs+zYccpwkOcVw3GwdwMk84acOE0aNhqXw-D+-wobIaEYbYwZIeOfCYZkADmbD5lGDYUAAjMcxnedgzbSHICgoYuOxroUzIBTGPm1DJIjdl5MbYAl-6FGZ7ixY28UhAxTFkUIwllgQkWdgh74pY2aUhCJ3HvCVEXeBVwYge+PlQayOX5D5AAMfUfO1TDYF1EY9QI2ADUNoXvigY1GdV+QoNNpi4HSZB+C1FAcPwgnVAIpTUmogqiBRZTWaeVZtPmeWJepsA+Dsf5Vp2HWDmwBD7OqlXuJd135rV90nI9vCeC9bYjR9X2NF+TkuSQ7m3f5QVw-9TA3Uwd0ZT9D1PeDz5Y++BBg1liTo5jQM4+8eNgxDb1Q0wJM7GTkifIcR0iCdYjneTqEA1j6WvZlQgPUwRCqITnWxp932sx4FP5igQvVjTIPi5LONzdDcu-VI-AI0jWP+SgeuSIrgshMDISwBr9PRUTTOk2boAW8rVvU6L6sS-bNZMPNTss5V3wmEAA","body":"function exchange(account1, account2) {\n    const difference = account1(\"balance\") - account2(\"balance\");\n    account1(\"withdraw\")(difference);\n    account2(\"deposit\")(difference);\n} "}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n    This\n    function\n    works well when only a single \n    thread \n    is trying to do the exchange.  Suppose, however, that Peter and Paul both\n    have access to accounts ","tag":"#text"},{"body":"$a_1$","tag":"LATEX"},{"body":",\n    ","tag":"#text"},{"body":"$a_2$","tag":"LATEX"},{"body":", and ","tag":"#text"},{"body":"$a_3$","tag":"LATEX"},{"body":", and\n    that Peter exchanges ","tag":"#text"},{"body":"$a_1$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$a_2$","tag":"LATEX"},{"body":" while Paul concurrently exchanges\n    ","tag":"#text"},{"body":"$a_1$","tag":"LATEX"},{"body":" and ","tag":"#text"},{"body":"$a_3$","tag":"LATEX"},{"body":".\n    Even with account deposits and withdrawals\n    serialized for individual accounts (as in the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account"},{"body":"function\n    shown above in this section), ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"exchange"},{"body":" can\n    still produce incorrect results.  For example, Peter might compute the\n    difference in the balances for ","tag":"#text"},{"body":"$a_1$","tag":"LATEX"},{"body":" and\n    ","tag":"#text"},{"body":"$a_2$","tag":"LATEX"},{"body":", but then Paul might change the balance in\n    ","tag":"#text"},{"body":"$a_1$","tag":"LATEX"},{"body":" before Peter is able to complete the\n    exchange.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-3","body":"3","href":"/sicpjs/3.4.2#footnote-3"},{"body":"\n    For correct behavior, we must arrange for the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"exchange"},{"body":"function\n    to lock out any other concurrent accesses to the accounts during the\n    entire time of the exchange.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n    One way we can accomplish this is by using both accounts' serializers\n    to serialize the entire ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"exchange"},{"body":"function.\n    To do this, we will arrange for access to an account's serializer.\n    Note that we are deliberately breaking the modularity of the bank-account\n    object by exposing the serializer.  The following version of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account"},{"body":"\n    is identical to the original version given in\n    section ","tag":"#text"},{"tag":"REF","body":"3.1.1","href":"/sicpjs/3.1.1"},{"body":", except that a\n    serializer is provided to protect the balance variable, and the serializer\n    is exported via message passing:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":10,"eval":true,"prependLength":31,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+JZ7AyZBkpAoGWyuR2kopVIARvpMoV4e48RDQJcqHYsp4mJcBEwGDQY1nElQ+QI00oM2xQILy5WSBRq8MG03mT3yM3nm2Y86uu7QP3CqP3J9QMpDEL5uOQpB6UQCAQqGQqGwO6ALFlZCFp1JXafSjnrFk2AAHGiyAtlitVxcJSfNjTv0AAalAw47J52j4PITumA6jmekg6go74JiSXo7MyzARp6UpUjaQF-AEAqMEEoT5oWxaXHMWopARthFiWAZdKMeEnNed4PhQJEKikDH3gW1FlLR4wnO+LHCik75cYkPHBCcqHJp4AmbEJYGFHBSaUp4IkJNsuz7AIRwnGcFzXC0dwMk84acOE0YdhquCfEAA","body":"function make_account_and_serializer(balance) {\n    function withdraw(amount) {\n        if (balance > amount) {\n            balance = balance - amount;\n            return balance;\n        } else {\n            return \"Insufficient funds\";\n        }\n    }\n    function deposit(amount) {\n        balance = balance + amount;\n        return balance;\n    }\n    const balance_serializer = make_serializer();\n    return m => m === \"withdraw\"\n                ? withdraw\n                : m === \"deposit\"\n                ? deposit\n                : m === \"balance\"\n                ? balance\n                : m === \"serializer\"\n                ? balance_serializer\n                : error(m, \"unknown request -- make_account\");\n} "}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n    We can use this to do serialized deposits and withdrawals.  However,\n    unlike our earlier serialized account, it is now the responsibility of\n    each user of bank-account objects to explicitly manage the\n    serialization, for example as\n    follows:","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-4","body":"4","href":"/sicpjs/3.4.2#footnote-4"},{"tag":"SNIPPET","latex":false,"id":11,"eval":true,"prependLength":56,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+JZ7AyZBkpAoGWyuR2kopVIARvpMoV4e48RDQJcqHYsp4mJcBEwGDQY1nElQ+QI00oM2xQILy5WSBRq8MG03mT3yM3nm2Y86uu7QP3CqP3J9QMpDEL5uOQpB6UQCAQqGQqGwO6ALFlZCFp1JXafSjnrFk2AAHGiyAtlitVxcJSfNjTv0AAalAw47J52j4PITumA6jmekg6go74JiSXo7MyzARp6UpUjaQF-AEAqMEEoT5oWxaXHMWopARthFiWAZdKMeEnNed4PhQJEKikDH3gW1FlLR4wnO+LHCik75cYkPHBCcqHJp4AmbEJYGFHBSaUp4IkJNsuz7AIRwnGcFzXC0dwMk84acOE0YdhquDfCGli5uxTFllG7YUMc-6dq+0hyAosjMmZzm1JJymWdqXmgFkvlOTGtT2QWwVSLIAiom5QgfNZ0GMG0kbmQoGjIaZkUdnGOSBVSACMAAM5UfLgMX5AwmV+TGxzYJV1VZNoN6Nm0WkNQV+QhPxKXGEAA","body":"function deposit(account, amount) {\n    const s = account(\"serializer\");\n    const d = account(\"deposit\");\n    s(d(amount));\n} "}]},{"tag":"TEXT","id":"#p15","child":[{"body":"\n    Exporting the serializer in this way gives us enough flexibility to\n    implement a serialized exchange program.  We simply serialize the original\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"exchange"},{"body":"function\n    with the serializers for both accounts:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":12,"eval":true,"prependLength":88,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+JZ7AyZBkpAoGWyuR2kopVIARvpMoV4e48RDQJcqHYsp4mJcBEwGDQY1nElQ+QI00oM2xQILy5WSBRq8MG03mT3yM3nm2Y86uu7QP3CqP3J9QMpDEL5uOQpB6UQCAQqGQqGwO6ALFlZCFp1JXafSjnrFk2AAHGiyAtlitVxcJSfNjTv0AAalAw47J52j4PITumA6jmekg6go74JiSXo7MyzARp6UpUjaQF-AEAqMEEoT5oWxaXHMWopARthFiWAZdKMeEnNed4PhQJEKikDH3gW1FlLR4wnO+LHCik75cYkPHBCcqHJp4AmbEJYGFHBSaUp4IkJNsuz7AIRwnGcFzXC0dwMk84acOE0YdhquDfCGli5shplRu2+Tvl2+6hrm5GUaW-6dq+Hi1qA9byc2rbPh2rllF+n7BaAQ5hRQgEeOO76JbO87NvKwzLqusjrpu267goB5HqlXwXu5V63hx+Q+RFUhRaBjYDj+f7xYlyXBRBtJyAoN57LwlBIayknKRy5W2Ve2g3kwFBkLYWl1ZhIFjOJISeURISgKp7gpH1NADfk60lhsCpiaE7FMTJwy7f1bCUAIF0FidwpnXxwVXV0clNYU21SOpewHMcpwkOcVw3GwhmPM89mRuZzEYaAkEtFhoBZFNM1zcGl70Pwc2ZAA5mwZaOTGACMxxmU52CudBqO1gQOy7oUzKU2TtT8SIQ4kx22Ds+9COsx2pO1EdxFCA99OMwOAvcxQvMhI98MSxuUuZljFUeomCE5LjtgE0TgsUOTf6y9Tfm0yNOykyzsvCyElvSQjFta2hnjYDbcPyw7lnuA7wsO7zuv60I4uG8bhvU8GtNMNbGgw4bcY5A7AikwADKnHzR+7cesgnmRJy7UkCNg6eZz1f4oENEZ5-GycoKXpi4HSZB+N4HYcPwd3VAIpTUmogqiFtZRo7IN6Nm0ZZ2xzQOwD4iFfjHE5sAQ+zqgj7gj2PTAT0w8vTycs+8J4jW9rvS8r40iWWzrfB4yQhOTxTkfUZv4+T3z31rzPc-Hwv1tMAQI+PtEiv23mWPe-Nv5HxPs1M+ACgEI0+IcXuIh+5iCHiAqab8Y4fybO8GeTAiCqD-ufVewCEigJ3igXBA58EH0IcQmKTBK4pmXmQ9eUhr4d1vnre+Btw4oA4ZISh78Qj7xCLABhMDmaL3gTschHgRHMJoYUOhEipEL0rnIx2XUTBAA","body":"function serialized_exchange(account1, account2) {\n    const serializer1 = account1(\"serializer\");\n    const serializer2 = account2(\"serializer\");\n    serializer1(serializer2(exchange))(account1, account2);\n} "}]},{"tag":"EXERCISE","title":"Exercise 3.43","id":"#ex-3.43","child":[{"body":"\n    Suppose that the balances in three accounts start out as $10,\n    $20, and $30, and that multiple \n    threads \n    run, exchanging the balances in the accounts.  Argue that if the \n    threads \n    are run sequentially,\n    after any number of concurrent exchanges, the account balances should be \n    $10, $20, and $30 in some order.\n    Draw a timing diagram like the one in\n    figure ","tag":"#text"},{"tag":"REF","body":"3.29","href":"/sicpjs/3.4.1#fig-3.29"},{"body":" to\n    show how this condition can be violated if the exchanges are\n    implemented using the first version of the account-exchange program in\n    this section.  On the other hand, argue that even with this\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"exchange"},{"body":" program, the sum of the balances\n    in the accounts will be preserved.  Draw a timing diagram to show how\n    even this condition would be violated if we did not serialize the\n    transactions on individual accounts.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.44","id":"#ex-3.44","child":[{"body":"\n    Consider the problem of\n    \n    transferring an amount from one account to\n    another.  Ben Bitdiddle claims that this can be accomplished with the\n    following\n    function,\n    even if there are multiple people concurrently\n    transferring money among multiple accounts, using any account\n    mechanism that serializes deposit and withdrawal transactions, for\n    example, the version of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account"},{"body":"\n    in the text above.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":13,"eval":true,"prependLength":82,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+JZ7AyZBkpAoGWyuR2kopVIARvpMoV4e48RDQJcqHYsp4mJcBEwGDQY1nElQ+QI00oM2xQILy5WSBRq8MG03mT3yM3nm2Y86uu7QP3CqP3J9QMpDEL5uOQpB6UQCAQqGQqGwO6ALFlZCFp1JXafSjnrFk2AAHGiyAtlitVxcJSfNjTv0AAalAw47J52j4PITumA6jmekg6go74JiSXo7MyzARp6UpUjaQF-AEAqMEEoT5oWxaXHMWopARthFiWAZdKMeEnNed4PhQJEKikDH3gW1FlLR4wnO+LHCik75cYkPHBCcqHJp4AmbEJYGFHBSaUp4IkJNsuz7AIRwnGcFzXC0dwMk84acOE0YdhquDfCGli5shplRu2+Tvl2+6hrm5GUaW-6dq+Hi1qA9byc2rbPh2rllF+n7BaAQ5hRQgEeOO76JbO87NvKwzLqusjrpu267goB5HqlXwXu5V63hx+Q+RFUhRaBjYDj+f7xYlyXBRBtJyAoN57LwlBIayknKRy5W2Ve2g3kwFBkLYWl1ZhIFjOJISeURISgKp7gpH1NADfk60lhsCpiaE7FMTJwy7f1bCUAIF0FidwpnXxwVXV0clNYU21SOpewHMcpwkOcVw3GwhmPM89mRuZzEYaAkEtFhoBZFNM1zcGl70BQxb0gQVIEHsDCw05xwUDQpMxsctV+UTNAk2ZTm1EdxFCE+TkIxTVMdrUj3wxzVbBtBf4AIxDRGTMxgIGAAAyyx8ItMNgEsOXDAii-LHy4HSZB+N4HYcPwd3VAIpTUmogqZR4aOyDejZtGWou1PxQhA7APiIV+TDiymbAEPs6oI+4tv20wjvKy771uycHu8J4jW9srE7+4HlllLjmSyATqw+zT2DHAArAriWhw7TtR99Qfu57Cfe+LTAEPH6eJGX4dltgldNu8Nfx4nzXJ43zcI58hzmyIltiFtZRtxHzshK77tMEQqj1y3CSzx3XcDj3sfL6vMXK+vNtTeXPvb4Uu8hLA+-94UYvHyHp-t5HC-R0vK9382R-B1Im-n2-KuV8b6fzXr-SQ-9O6AO7jHa+t9vbYGPt8EwQA","body":"function transfer(from_account, to_account, amount) {\n    from_account(\"withdraw\")(amount);\n    to_account(\"deposit\")(amount);\n} "},{"body":"Louis Reasoner claims that there is a problem here, and that we need\n    to use a more sophisticated method, such as the one required for\n    dealing with the exchange problem.  Is Louis right?  If not, what is\n    the essential difference between the transfer problem and the exchange\n    problem?  (You should assume that the balance in\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"from_account"},{"body":"\n    is at least ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"amount"},{"body":".)\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.45","id":"#ex-3.45","child":[{"body":"\n    Louis Reasoner thinks our bank-account system is unnecessarily complex\n    and error-prone now that deposits and withdrawals aren't\n    automatically serialized. He suggests that\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account_and_serializer"},{"body":"\n    should have exported the serializer \n    \n        (for use by such functions as\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"serialized_exchange"},{"body":")        \n      \n    in addition to (rather than instead of) using it to serialize accounts and\n    deposits as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account"},{"body":"\n    did. He proposes to redefine accounts as follows:\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":14,"eval":true,"prependLength":35,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+NAWTYAAcaLIqPlwjJSBRjkwGDQk-D3An0yR8iEI9HYxR3gJUzmKB9viHLBCWewMmRE7mMtlcjtJRSqQAjfSZQqZkU16yXOO2LKeJiXUtpjNCxJUPkCHtKPtsUCCsuz+XDZer5m78hr56b3OmACQXJ8PNAB8KzsDoGUhjnw3dJ0g9KIBAIVDIVDYuagBYWSyCE97uK6UiQZIeK1gWMZxtO5YDgkt5rhoaGgAA1KAJ4UOBUhvmh97QdIcgKGhbYkl6OzMsw9aelKVI2naV7-GMgpjMEJwjnY46TnMWopJRjGdqsvFjhOlwbFqoxBKE8FFoJCrCb2h5UR2lKrIpcYyQqcnjCcaHKcKqkroeAZdAZ3EhKJWkmZsZmrhpNGeJZZTbLs+wCEcJxnBc1wtHcDJPHWnDZkmGq4FWOoKAwbQNk2CgaPR4WNuWLY5HZVIoAADLlHw6fk8WJeWxwAIz5SYZ64Fk2iRiubQ+QlEW5rUxlCCYQA","body":"function make_account_and_serializer(balance) {\n    function withdraw(amount) {\n        if (balance > amount) {\n            balance = balance - amount;\n\t    return balance;\n        } else {\n            return \"Insufficient funds\";\n        }\n    }\n    function deposit(amount) {\n        balance = balance + amount;\n        return balance;\n    }\n    const balance_serializer = make_serializer();\n    return m => m === \"withdraw\"\n                ? balance_serializer(withdraw)\n                : m === \"deposit\"\n                ? balance_serializer(deposit)\n                : m === \"balance\"\n                ? balance\n                : m === \"serializer\"\n                ? balance_serializer\n                : error(m, \"unknown request -- make_account\");\n} "},{"body":"\n    Then deposits are handled as with the original\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account"},{"body":":","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":15,"eval":true,"prependLength":56,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxxhFF+JZ7AyZBkpAoGWyuR2kopVIARvpMoV4e48RDQJcqHYsp4mJcBEwGDQY1nElQ+QI00oM2xQILy5WSBRq8MG03mT3yM3nm2Y6YAJBcnw80D9wrOwOgZSGIXzd0nSD0ogEAhUMhUNgd0AWLKyEJz9yuqQXyQ56xZNgABxosgLZYrVeXCRnzY0X9AAGpQGHDszykVcvznK9pDkBQvwTEkvR2ZlmAjT0pSpG07Unf4xkFMZghOfNC2LS45i1FJYNQ5NVkI2wixLDYtVGIJQjvR9nwoUiFXI9MBzgpNKVWVinwLBiFSY8YTi-TjhW4xsBwDLpxPwkJKIE6TNlkps+IQzwFLKbZdn2AQjhOM4LmuFo7gZJ5w04cJow7DVcG+ENLFzIT2LLKN2woY4gM7D9AO8mNag8gt3lfHyPhcnUFAYNpIwchQNGQuzgo7OMclUqkUAABlyj4wvyeLEp844AEZ8pMUdcCybR70bNpjIS+yfNqKShBMIA","body":"function deposit(account, amount) {\n    account(\"deposit\")(amount);\n} "},{"body":"\n    Explain what is wrong with Louis's reasoning.  In particular,\n    consider what happens when\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"serialized_exchange"},{"body":"\n    is called.\n    ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h4","child":[{"body":"Implementing serializers","tag":"#text"}]},{"tag":"TEXT","id":"#p16","child":[{"body":"\n    We implement serializers in terms of a more primitive synchronization\n    mechanism called a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"mutex","tag":"#text"}]},{"body":".  A mutex is an object that supports two\n    operations—the mutex can be \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"acquired","tag":"#text"}]},{"body":", and the mutex can be\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"released","tag":"#text"}]},{"body":".  Once a mutex has been acquired, no other acquire\n    operations on that mutex may proceed until the mutex is\n    released.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-5","body":"5","href":"/sicpjs/3.4.2#footnote-5"},{"body":"\n    In our implementation, each serializer has an associated mutex.  Given a\n    \n\tfunction\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":",\n      \n    the serializer returns a\n    function\n    that acquires the mutex, runs\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":",\n      \n    and then releases the mutex.  This ensures that only one of the\n    functions\n    produced by the serializer can be running at once, which is\n    precisely the serialization property that we need to guarantee.\n    \n\tTo apply serializers to functions that take an arbitrary number of arguments,\n\twe use JavaScript's ","tag":"#text"},{"tag":"EM","child":[{"body":"rest","tag":"#text"}]},{"body":" parameter and ","tag":"#text"},{"tag":"EM","child":[{"body":"spread","tag":"#text"}]},{"body":" syntax.\n\t    \n\tThe ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"..."},{"body":" in front of the\n\tparameter ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"args"},{"body":" collects\n\tthe rest (here all) of the arguments of any call of the function\n\tinto a ","tag":"#text"},{"tag":"EM","child":[{"body":"vector","tag":"#text"}]},{"body":" data structure.\n\tThe\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"..."},{"body":" in front of\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"args"},{"body":" in\n\tthe application\n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f(...args)"},{"body":"\n\tspreads the elements of \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"args"},{"body":" so that\n\tthey become separate arguments of \n\t","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"f"},{"body":".\n      ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":16,"eval":true,"prependLength":18,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhB+DBVgCrE4hk8VH0VAAXjthGJSjISPIXk51IxCUCnMJTO5fn56AR1AA+GmbcykcHWYmkrSUnIEaluYUeRw1OpRGJsd6chXuOkMgBu+mZso+WvcSsEIUm01mxpNkm5-31Sk1wu+Wvt9AlZOlHAIxmGQw8nxBQA","body":"function make_serializer() {\n    const mutex = make_mutex();\n    return f => {\n               function serialized_f(...args) {\n                   mutex(\"acquire\");\n                   const val = f(...args);\n                   mutex(\"release\");\n                   return val;\n               }\n               return serialized_f;          \n           };\n} "}]},{"tag":"TEXT","id":"#p17","child":[{"body":"\n    The mutex is a mutable object (here we'll use a one-element list,\n    which we'll refer to as a \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"cell","tag":"#text"}]},{"body":") that can hold the value true or false.  When the value is\n    false, the mutex is available to be acquired.  When the value is true, the\n    mutex is unavailable, and any\n    thread \n    that attempts to acquire the mutex must wait.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p18","child":[{"body":"\n    Our mutex constructor\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_mutex"},{"body":"\n    begins by initializing the cell contents to false.  To acquire the mutex,\n    we test the cell.  If the mutex is available, we set the cell contents to\n    true and proceed. Otherwise, we wait in a loop, attempting to acquire over\n    and over again, until we find that the mutex is available.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-6","body":"6","href":"/sicpjs/3.4.2#footnote-6"},{"body":"\n    To release the mutex, we set the cell contents to false.\n    ","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":17,"eval":true,"prependLength":0,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0AWwEMBrAUwH0GiK2APABQBKUAG9coSaDJ0AzhWlsANktABeUEqryBBJktlshAbglTi5anVAUAFp269BDEeKnvQAJzYUin+gzqahoARExkAI5EVN4hZh4JkgD8NmzyHEwkACYchhQCZMpKQvGJiSl2Djz8AmGR0bEiIF4+ngCepWUeAFw2nkRsnV2gvYHBod5KbEyGccMeKWRTTJ4FRSXz7r1snp40qwwANKAhpCwkNADu9N5RaQoAtA+M1XwhJqUAvqXevv429i4r1M3wslFo9CW01WhRUrlKeQ49iYWTWKmOegMRhBQA","body":"function make_mutex() {\n    const cell = list(false);\n    function the_mutex(m) {\n        return m === \"acquire\"\n               ? test_and_set(cell)\n                 ? the_mutex(\"acquire\") // retry\n                 : true\n               : m === \"release\"\n               ? clear(cell)\n               : error(m, \"unknown request -- mutex\");\n    }\n    return the_mutex;\n}\nfunction clear(cell) {\n    set_head(cell, false);\n} "}]},{"tag":"TEXT","id":"#p19","child":[{"body":"The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test_and_set"},{"body":"\n    tests the cell and returns the result of the test.  In addition, if the\n    test was false,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test_and_set"},{"body":"\n    sets the cell contents to true before returning false.  We can express this\n    behavior as the following\n    function:","tag":"#text"},{"tag":"SNIPPET","latex":false,"id":18,"eval":true,"prependLength":0,"program":"chap=3&variant=concurrent&prgrm=PTAEGUEkGEAVQFLlAZgHQBY0CYBQuAzAVwDsBjAFwEsB7E0CgUwGcKB9AQxIBM3nGKACjKMANqICUoAN65Q80FQKhBAC0YduwsZKmyFB0ACcBRI-QpGijANxyFAX1Bj+M+4dD926zdvEAaBitGCTsPeRMKM3oCDlF+MMdcByA","body":"function test_and_set(cell) {\n    if (head(cell)) {\n        return true;\n    } else {\n        set_head(cell, true);\n        return false;\n    }\n} "}]},{"tag":"TEXT","id":"#p20","child":[{"body":"\n    However, this implementation of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test_and_set"},{"body":"\n    does not suffice as it stands.  There is a crucial subtlety here, which is\n    the essential place where concurrency control enters the system: The\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test_and_set"},{"body":"\n    operation must be performed \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"atomically","tag":"#text"}]},{"body":". That is, we must guarantee that, once a \n    thread \n    has tested the cell and found it to be false, the cell contents will\n    actually be set to true before any other \n    thread \n    can test the cell.  If we do not make this guarantee, then the mutex can\n    fail in a way similar to the bank-account failure in\n    figure ","tag":"#text"},{"tag":"REF","body":"3.29","href":"/sicpjs/3.4.1#fig-3.29"},{"body":". (See\n    exercise ","tag":"#text"},{"tag":"REF","body":"3.46","href":"/sicpjs/3.4.2#ex-3.46"},{"body":".)\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p21","child":[{"body":"\n    The actual implementation of\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test_and_set"},{"body":"\n    depends on the details of how our system runs concurrent \n    threads.\n    For example, we might be executing concurrent \n    threads \n    on a sequential processor using a \n    \n    time-slicing mechanism that cycles through the \n    threads,\n    permitting each \n    thread \n    to run for a short time before interrupting it\n    and moving on to the next \n    thread.\n    In that case,\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test_and_set"},{"body":"\n    can work by disabling time slicing during the testing and\n    setting.\n    Alternatively, multiprocessing computers provide instructions that\n    support atomic operations directly in hardware.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-7","body":"7","href":"/sicpjs/3.4.2#footnote-7"}]},{"tag":"EXERCISE","title":"Exercise 3.46","id":"#ex-3.46","child":[{"body":"\n    Suppose that we implement\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test_and_set"},{"body":"\n    using an ordinary\n    function\n    as shown in the text, without attempting to make the operation atomic.\n    Draw a timing diagram like the one in\n    figure ","tag":"#text"},{"tag":"REF","body":"3.29","href":"/sicpjs/3.4.1#fig-3.29"},{"body":" to demonstrate how the mutex\n    implementation can fail by allowing two \n    threads \n    to acquire the mutex at the same time.\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.47","id":"#ex-3.47","child":[{"body":"\n    A semaphore\n    \n    (of size ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":") is a generalization of\n    a mutex. Like a mutex, a semaphore supports acquire and release operations,\n    but it is more general in that up to ","tag":"#text"},{"body":"$n$","tag":"LATEX"},{"body":"threads \n    can acquire it\n    concurrently.  Additional \n    threads \n    that attempt to acquire the semaphore must wait for release operations.  \n    Give implementations of semaphores\n    ","tag":"#text"},{"tag":"OL","child":[{"tag":"LI","child":[{"body":"in terms of mutexes\n      ","tag":"#text"}]},{"tag":"LI","child":[{"body":"\n        in terms of atomic\n        ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test_and_set"},{"body":"\n        operations.\n      ","tag":"#text"}]}]}]},{"tag":"SUBHEADING","id":"#h5","child":[{"body":"Deadlock","tag":"#text"}]},{"tag":"TEXT","id":"#p22","child":[{"body":"\n    Now that we have seen how to implement serializers, we can see\n    that account exchanging still has a problem, even with the\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"serialized_exchange"},{"body":"function\n    above.\n    Imagine that Peter attempts to exchange ","tag":"#text"},{"body":"$a_1$","tag":"LATEX"},{"body":"\n    with ","tag":"#text"},{"body":"$a_2$","tag":"LATEX"},{"body":" while Paul concurrently attempts to\n    exchange ","tag":"#text"},{"body":"$a_2$","tag":"LATEX"},{"body":" with\n    ","tag":"#text"},{"body":"$a_1$","tag":"LATEX"},{"body":". Suppose that Peter's \n    thread \n    reaches the point where it has entered a serialized\n    function\n    protecting ","tag":"#text"},{"body":"$a_1$","tag":"LATEX"},{"body":" and, just after that,\n    Paul's \n    thread \n    enters a serialized\n    function\n    protecting ","tag":"#text"},{"body":"$a_2$","tag":"LATEX"},{"body":".  Now Peter cannot proceed (to\n    enter a serialized\n    function\n    protecting ","tag":"#text"},{"body":"$a_2$","tag":"LATEX"},{"body":") until Paul exits the serialized\n    function\n    protecting ","tag":"#text"},{"body":"$a_2$","tag":"LATEX"},{"body":".  Similarly, Paul cannot proceed\n    until Peter exits the serialized\n    function\n    protecting ","tag":"#text"},{"body":"$a_1$","tag":"LATEX"},{"body":".  Each\n    thread \n    is stalled forever, waiting for the other.  This situation is called a\n    ","tag":"#text"},{"tag":"EM","child":[{"body":"deadlock","tag":"#text"}]},{"body":".  Deadlock is always a danger in systems that provide\n    concurrent access to multiple shared resources.\n  ","tag":"#text"}]},{"tag":"TEXT","id":"#p23","child":[{"body":"\n    One way to avoid the\n    \n    deadlock in this situation is to give each account a\n    unique identification number and rewrite\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"serialized_exchange"},{"body":"\n    so that a \n    thread \n    will always attempt to enter a\n    function\n    protecting the lowest-numbered account first.  Although this method works\n    well for the exchange problem, there are other situations that require more\n    sophisticated deadlock-avoidance techniques, or where deadlock cannot\n    be avoided at all.  (See exercises ","tag":"#text"},{"tag":"REF","body":"3.48","href":"/sicpjs/3.4.2#ex-3.48"},{"body":"\n    and ","tag":"#text"},{"tag":"REF","body":"3.49","href":"/sicpjs/3.4.2#ex-3.49"},{"body":".)","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-8","body":"8","href":"/sicpjs/3.4.2#footnote-8"}]},{"tag":"EXERCISE","title":"Exercise 3.48","id":"#ex-3.48","child":[{"body":"\n    Explain in detail why the\n    \n    deadlock-avoidance method described above,\n    (i.e., the accounts are numbered, and each \n    thread \n    attempts to acquire the smaller-numbered account first) avoids \n    deadlock in the exchange problem.  Rewrite\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"serialized_exchange"},{"body":"\n    to incorporate this idea. (You will also need to modify\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"make_account"},{"body":"\n    so that each account is created with a number, which can be accessed by\n    sending an appropriate message.)\n    ","tag":"#text"}]},{"tag":"EXERCISE","title":"Exercise 3.49","id":"#ex-3.49","child":[{"body":"\n    Give a scenario where the deadlock-avoidance mechanism described\n    above does not work.  (Hint: In the exchange problem, each \n    thread\n    knows in advance which accounts it will need to get access to.  Consider a\n    situation where a \n    thread \n    must get access to some shared resources before it can know which additional\n    shared resources it will require.)\n    ","tag":"#text"}]},{"tag":"SUBHEADING","id":"#h6","child":[{"body":"Concurrency, time, and communication","tag":"#text"}]},{"tag":"TEXT","id":"#p24","child":[{"body":"\n    We've seen how programming concurrent systems requires controlling\n    the ordering of events when different \n    threads \n    access shared state, and we've seen how to achieve this control \n    through judicious use of serializers.  But the problems of concurrency\n    lie deeper than this, because, from a fundamental point of view, it's\n    not always clear what is meant by \"","tag":"#text"},{"body":"shared state.","tag":"#text"},{"body":"\"","tag":"#text"}]},{"tag":"TEXT","id":"#p25","child":[{"body":"\n    Mechanisms such as\n    ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"test_and_set"},{"body":"\n    require \n    threads \n    to examine a global shared flag at arbitrary times.  This is problematic \n    and inefficient to implement in modern high-speed processors, where\n    due to optimization techniques such as pipelining and cached memory,\n    the contents of memory may not be in a consistent state at every instant.\n    In\n    some\n    multiprocessing systems, therefore, the serializer paradigm\n    is being supplanted by\n    other\n    approaches to concurrency\n    control.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-9","body":"9","href":"/sicpjs/3.4.2#footnote-9"}]},{"tag":"TEXT","id":"#p26","child":[{"body":"\n    The problematic aspects of shared state also arise in large, distributed\n    systems.  For instance, imagine a distributed banking system where\n    individual branch banks maintain local values for bank balances and\n    periodically compare these with values maintained by other branches.  In\n    such a system the value of \"","tag":"#text"},{"body":"the account balance","tag":"#text"},{"body":"\" would be\n    undetermined, except right after synchronization.  If Peter deposits money\n    in an account he holds jointly with Paul, when should we say that the\n    account balance has changed—when the balance in the local branch\n    changes, or not until after the synchronization?  And if Paul accesses the\n    account from a different branch, what are the reasonable constraints to\n    place on the banking system such that the behavior is\n    \"","tag":"#text"},{"body":"correct","tag":"#text"},{"body":"\"?  The only thing that might matter for correctness\n    is the behavior observed by Peter and Paul individually and the\n    \"","tag":"#text"},{"body":"state","tag":"#text"},{"body":"\" of the account immediately after synchronization.\n    Questions about the \"","tag":"#text"},{"body":"real","tag":"#text"},{"body":"\" account balance or the order of\n    events between synchronizations may be irrelevant or\n    meaningless.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-10","body":"10","href":"/sicpjs/3.4.2#footnote-10"}]},{"tag":"TEXT","id":"#p27","child":[{"body":"\n    The basic phenomenon here is that synchronizing different \n    threads,\n    establishing shared state, or imposing an order on events requires\n    communication among the \n    threads.\n    In essence, any notion of time in concurrency control must be intimately\n    tied to communication.","tag":"#text"},{"tag":"FOOTNOTE_REF","id":"#footnote-link-11","body":"11","href":"/sicpjs/3.4.2#footnote-11"},{"body":" It is intriguing that a similar\n    connection between time and communication also arises in the \n    \n    Theory of Relativity, where the speed of light (the fastest signal that can\n    be used to synchronize events) is a fundamental constant relating time and\n    space.  The complexities we encounter in dealing with time and state in our\n    computational models may in fact mirror a fundamental complexity of\n    the physical universe.\n\n    ","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-1","count":1,"href":"/sicpjs/3.4.2#footnote-link-1","child":[{"body":"\n        The function ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"concurrent_execute"},{"body":" is\n\tnot part of the JavaScript standard, but the examples in this section\n\tcan be implemented in ECMAScript 2020.\n\t","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-2","count":2,"href":"/sicpjs/3.4.2#footnote-link-2","child":[{"body":"We have simplified ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"exchange"},{"body":"\n    by exploiting the fact that our ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"deposit"},{"body":"\n    message accepts negative amounts.  (This is a serious bug in our banking\n    system!)","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-3","count":3,"href":"/sicpjs/3.4.2#footnote-link-3","child":[{"body":"If the account balances start out as $10,\n    $20, and $30, then after any number of concurrent exchanges,\n    the balances should still be $10, $20, and $30 in\n    some order.  Serializing the deposits to individual accounts is not\n    sufficient to guarantee this. See\n    exercise ","tag":"#text"},{"tag":"REF","body":"3.43","href":"/sicpjs/3.4.2#ex-3.43"},{"body":".","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-4","count":4,"href":"/sicpjs/3.4.2#footnote-link-4","child":[{"body":"Exercise ","tag":"#text"},{"tag":"REF","body":"3.45","href":"/sicpjs/3.4.2#ex-3.45"},{"body":"\n    investigates why deposits and withdrawals are no longer automatically\n    serialized by the account.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-5","count":5,"href":"/sicpjs/3.4.2#footnote-link-5","child":[{"body":"The term \"","tag":"#text"},{"body":"mutex","tag":"#text"},{"body":"\" is an abbreviation for \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"mutual exclusion","tag":"#text"}]},{"body":".  The general problem of arranging a mechanism\n    that permits concurrent \n    threads \n    to safely share resources is called the mutual exclusion problem.  Our\n    mutex is a simple variant of the \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"semaphore","tag":"#text"}]},{"body":" mechanism (see\n    exercise ","tag":"#text"},{"tag":"REF","body":"3.47","href":"/sicpjs/3.4.2#ex-3.47"},{"body":"), which was introduced in the \n    \"","tag":"#text"},{"body":"THE","tag":"#text"},{"body":"\" Multiprogramming System developed at the\n    \n    Technological University of Eindhoven and named for the university's\n    initials in Dutch\n    \n    (Dijkstra 1968a).  The acquire and\n    release operations were originally called \n    \n    P and V, from the Dutch\n    words ","tag":"#text"},{"tag":"EM","child":[{"body":"passeren","tag":"#text"}]},{"body":" (to pass) and ","tag":"#text"},{"tag":"EM","child":[{"body":"vrijgeven","tag":"#text"}]},{"body":" (to release), in\n    reference to the semaphores used on railroad systems.  Dijkstra's\n    classic exposition (1968b) was one of the first to clearly present the\n    issues of concurrency control, and showed how to use semaphores to\n    handle a variety of concurrency problems.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-6","count":6,"href":"/sicpjs/3.4.2#footnote-link-6","child":[{"body":"In most\n    time-shared operating systems,\n    threads \n    that are\n    \n    blocked by a mutex do\n    not waste time\n    \"","tag":"#text"},{"body":"busy-waiting","tag":"#text"},{"body":"\" as above.  Instead, the system\n    schedules another \n    thread \n    to run while the first is waiting, and the blocked\n    thread \n    is awakened when the mutex becomes available.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-7","count":7,"href":"/sicpjs/3.4.2#footnote-link-7","child":[{"body":"There are many\n    variants of such\n    \n    instructions—including test-and-set, test-and-clear, swap,\n    compare-and-exchange, load-reserve, and store-conditional—whose\n    design must be carefully matched to the machine's\n    processor–memory interface. One issue that arises here is to\n    determine what happens if two \n    threads \n    attempt to acquire the same resource at exactly the same time by using such\n    an instruction. This requires some mechanism for making a decision about\n    which \n    thread \n    gets control. Such a mechanism is called an \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"arbiter","tag":"#text"}]},{"body":".  Arbiters usually boil down to some sort of hardware\n    device. Unfortunately, it is possible to prove that one cannot physically\n    construct a fair arbiter that works 100% of the time unless one\n    allows the arbiter an arbitrarily long time to make its decision.\n    The fundamental phenomenon here was originally observed by the\n    fourteenth-century French philosopher \n    \n    Jean Buridan in his commentary on\n    \n    Aristotle's ","tag":"#text"},{"tag":"EM","child":[{"body":"De caelo","tag":"#text"}]},{"body":". Buridan argued that a perfectly rational\n    \n    dog placed between two equally attractive sources of food will starve to\n    death, because it is incapable of deciding which to go to first.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-8","count":8,"href":"/sicpjs/3.4.2#footnote-link-8","child":[{"body":"The general\n    technique for avoiding\n    \n    deadlock by numbering the\n    shared resources and acquiring them in order is due to \n    Havender (1968).  Situations where deadlock cannot be\n    avoided require ","tag":"#text"},{"tag":"EM","child":[{"body":"deadlock-recovery","tag":"#text"}]},{"body":" methods, which entail having \n    threads\"","tag":"#text"},{"body":"back out","tag":"#text"},{"body":"\" of the deadlocked state and try again.\n    Deadlock-recovery mechanisms are widely used in\n    data-base-management systems, a topic that is treated in detail in\n    Gray and Reuter 1993.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-9","count":9,"href":"/sicpjs/3.4.2#footnote-link-9","child":[{"body":"One such alternative to serialization is called \n    ","tag":"#text"},{"tag":"EM","child":[{"body":"barrier synchronization","tag":"#text"}]},{"body":".  The programmer permits concurrent \n    threads\n    to execute as they please, but establishes certain synchronization points\n    (\"","tag":"#text"},{"body":"barriers","tag":"#text"},{"body":"\") through which no \n    thread \n    can proceed until all the\n    threads \n    have reached the barrier.\n    Some\n    processors provide machine instructions\n    that permit programmers to establish synchronization points at places where\n    consistency is required.  The \n    \n    PowerPC","tag":"#text"},{"body":"$^{\\textrm{TM}}$","tag":"LATEX"},{"body":", for example, includes\n    for this purpose two instructions called\n    \n    SYNC and \n    \n    EIEIO (Enforced In-order Execution of Input/Output).","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-10","count":10,"href":"/sicpjs/3.4.2#footnote-link-10","child":[{"body":"This may seem like a strange point of view, but there\n    are\n    systems that work this way.\n    \n    International charges to credit-card accounts,\n    for example, are normally cleared on a per-country basis, and the charges\n    made in different countries are periodically reconciled.  Thus the account\n    balance may be different in different countries.","tag":"#text"}]},{"tag":"DISPLAYFOOTNOTE","id":"#footnote-11","count":11,"href":"/sicpjs/3.4.2#footnote-link-11","child":[{"body":"For distributed systems, this perspective\n    was pursued by \n    \n    Lamport (1978), who showed how to use communication to establish\n    \"","tag":"#text"},{"body":"global clocks","tag":"#text"},{"body":"\" that can be used to establish orderings on\n    events in distributed systems.","tag":"#text"}]}]