<SUBSECTION>
   <NAME>示例：牛顿法的平方根<APOS></APOS>方法</NAME> 
  <LABEL NAME="sec:sqrt"></LABEL>

   <TEXT>
    <SPLITINLINE>
      
	<INDEX>过程<SUBINDEX>数学函数与<OPEN></OPEN></SUBINDEX></INDEX>
	<INDEX>函数（数学）<SUBINDEX>过程与<OPEN></OPEN></SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>数学函数与<OPEN></OPEN></SUBINDEX></INDEX>
	<INDEX>函数（数学）<SUBINDEX>JavaScript函数与<OPEN></OPEN></SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      过程，
      <JAVASCRIPT>函数，</JAVASCRIPT>
    </SPLITINLINE>
    如上所述，过程与普通数学函数非常相似。它们
    指定由一个或多个参数决定的值。但数学函数与计算机
    <SPLITINLINE>
      过程之间有一个重要区别。
      <JAVASCRIPT>函数之间存在一个重要区别。</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      
        过程
      
      <JAVASCRIPT>
        计算机函数
      </JAVASCRIPT>
    </SPLITINLINE>
    必须是有效的。
  </TEXT> 
   <TEXT>
    作为一个例子，考虑计算平方根的问题。我们可以将平方根函数定义为
    
      \[
      \sqrt{x}\ =\text{ 使 }y\text{ 满足 }y \geq 0\text{ 且 }
      y^2\ =\ x
      \]
    
    这描述了一个完全合法的数学函数。我们可以用它来识别一个数字是否是另一个数字的平方根，或者推导出有关平方根的一般事实。另一方面，这个定义并没有描述一个
    <SPLITINLINE>
      过程。
      <JAVASCRIPT>计算机函数。</JAVASCRIPT>
    </SPLITINLINE>
    实际上，它几乎没有告诉我们如何实际找到给定数字的平方根。仅仅用
    <SPLITINLINE>
      伪Lisp：
      <JAVASCRIPT>伪JavaScript：</JAVASCRIPT>
    </SPLITINLINE>
    
      
(define (sqrt x)
  (the y (and (&gt;= y 0)
              (= (square y) x))))
      
      <JAVASCRIPT>
function sqrt(x) {
    return the y $\texttt{with}$ y &gt;= 0 &amp;&amp; square(y) === x;
}
      </JAVASCRIPT>
    
    这只会引发问题。
  </TEXT> 
   <SHORT_PAGE LINES="2"></SHORT_PAGE> 
  <TEXT> 
     function 和过程
    <SPLITINLINE>
      
        数学函数和计算机函数
      
      <JAVASCRIPT>
        数学函数和计算机函数
      </JAVASCRIPT>
    </SPLITINLINE>
    之间的对比反映了描述事物属性与描述如何做事之间的普遍区别，或者有时也称为
    <INDEX>声明性知识与<SPACE></SPACE>命令性知识</INDEX>
    <INDEX>命令性知识与<SPACE></SPACE>声明性知识</INDEX>
    声明性知识和命令性知识之间的区别。在
    <INDEX>数学<SUBINDEX>计算机科学与</SUBINDEX></INDEX>
    <INDEX>计算机科学<SUBINDEX>数学与</SUBINDEX></INDEX>
    数学中，我们通常关注声明性（是什么）
    描述，而在计算机科学中，我们通常关注
    命令性（如何）描述。 
 <FOOTNOTE>声明性和命令性描述是密切相关的，正如数学和计算机科学一样。例如，说明一个程序产生的答案是
    <INDEX>程序正确性</INDEX>
    <QUOTE>正确</QUOTE>就是对程序做出声明性陈述。有大量的研究旨在建立
    <INDEX>程序正确性证明</INDEX>
    证明程序正确性的技术，而这个主题的许多技术难点与在命令性语句（程序构建的基础）和声明性语句（可以用于推导事物）之间的转换有关。
    <SPLITINLINE>
      
	在相关方面，编程语言设计中的一个重要领域是探索所谓的
	<INDEX>编程语言<SUBINDEX>超高级</SUBINDEX></INDEX>
	<INDEX>超高级语言</INDEX>
	超高级语言，其中实际以声明性语句进行编程。
      
      <JAVASCRIPT>
	在相关方面，编程语言设计者探索了所谓的
	<INDEX>编程语言<SUBINDEX>超高级</SUBINDEX></INDEX>
	<INDEX>超高级语言</INDEX>
	超高级语言，其中实际以声明性语句进行编程。
      </JAVASCRIPT>
    </SPLITINLINE>
    这个想法是使解释器足够复杂，以便在程序员指定的<QUOTE>是什么</QUOTE>知识的基础上，自动生成<QUOTE>如何做</QUOTE>知识。这在一般情况下是无法实现的，但在某些重要领域已经取得了进展。我们将在第<SPACE></SPACE><REF NAME="chap:meta"></REF>章中重新讨论这个想法。</FOOTNOTE>
 <SPLITINLINE>
      
	<INDEX>过程<SUBINDEX>数学函数与<CLOSE></CLOSE></SUBINDEX></INDEX>
	<INDEX>函数（数学）<SUBINDEX>过程与<CLOSE></CLOSE></SUBINDEX></INDEX>
      
      <JAVASCRIPT>
	<INDEX><FUNCTION></FUNCTION><SUBINDEX>数学函数与<CLOSE></CLOSE></SUBINDEX></INDEX>
	<INDEX>函数（数学）<SUBINDEX>JavaScript函数与<CLOSE></CLOSE></SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
   </TEXT>
  <TEXT> 
    如何计算
    <INDEX>平方根<OPEN></OPEN></INDEX>
    <INDEX>牛顿<APOS></APOS>法<SUBINDEX><ORDER>平方</ORDER>的平方根<OPEN></OPEN></SUBINDEX></INDEX>
    平方根？最常见的方法是使用牛顿<APOS></APOS>法的逐次逼近，该方法指出，每当我们有一个猜测时 
<LATEXINLINE>$y$</LATEXINLINE>  一个数的平方根的值  <LATEXINLINE>$x$</LATEXINLINE> ，我们可以进行简单的操作，以获得更好的猜测（更接近实际平方根），通过平均  <LATEXINLINE>$y$</LATEXINLINE>  与 <LATEXINLINE>$x/y$</LATEXINLINE>. <FOOTNOTE>这个平方根算法实际上是牛顿法的一种特例，牛顿法是一种求解方程根的一般技术。平方根算法本身是由公元一世纪的亚历山大里亚的希罗（Heron of Alexandria）发展而来的。我们将看到如何在第<SPACE></SPACE><REF NAME="sec:proc-returned-values"></REF>节中将一般的牛顿法表示为
    <SPLITINLINE>
      
        Lisp 过程
      
      <JAVASCRIPT>
        JavaScript 函数
      </JAVASCRIPT>
    </SPLITINLINE>
    例如，我们可以按如下方式计算 2 的平方根。假设我们的初始猜测是<SPACE></SPACE>1：</FOOTNOTE> <LATEX>
      \[
      \begin{array}{lll}
      \textrm{Guess} &amp; \textrm{Quotient} &amp; \textrm{Average}\\[1em]
      1      &amp; {\displaystyle \frac{2}{1} = 2}           &amp; {\displaystyle \frac{(2+1)}{2} = 1.5} \\[1em]
      1.5    &amp; {\displaystyle \frac{2}{1.5} = 1.3333}    &amp; {\displaystyle \frac{(1.3333+1.5)}{2} = 1.4167} \\[1em]
      1.4167 &amp; {\displaystyle \frac{2}{1.4167} = 1.4118} &amp; {\displaystyle \frac{(1.4167+1.4118)}{2} = 1.4142} \\[1em]
      1.4142 &amp; \ldots &amp; \ldots
      \end{array}
      \]
    </LATEX> 
    继续这个过程，我们将获得越来越接近平方根的更好近似值。
</TEXT>
  <TEXT> 
    现在让我们将这个过程形式化为函数。我们从一个被开方数<INDEX>radicand</INDEX>（我们试图计算平方根的数字）的值和一个猜测值开始。如果该猜测对我们的目的足够好，我们就完成了；如果不够好，我们必须用改进的猜测重复该过程。我们将这个基本策略写成一个
    <SPLITINLINE>
      
        过程：
      
      <JAVASCRIPT>
        函数：
      </JAVASCRIPT>
    </SPLITINLINE>
<SNIPPET>
      <NAME>sqrt_iter</NAME>
      <REQUIRES>is_good_enough</REQUIRES>
      <REQUIRES>improve</REQUIRES>
      <EXAMPLE>sqrt_iter_example</EXAMPLE>
      <SCHEME>
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
      </SCHEME>
      <JAVASCRIPT>
function sqrt_iter(guess, x) {
    return is_good_enough(guess, x)
           ? guess
           : sqrt_iter(improve(guess, x), x);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>sqrt_iter_example</NAME>
      <SCHEME>
(sqrt-iter 3 25)
      </SCHEME>
      <JAVASCRIPT>
sqrt_iter(3, 25);
      </JAVASCRIPT>
    </SNIPPET> 
    通过将猜测值与被开方数和旧猜测的商相平均，可以改善猜测：
<SNIPPET>
      <NAME>improve</NAME>
      <REQUIRES>average_definition</REQUIRES>
      <EXAMPLE>improve_example</EXAMPLE>
      <SCHEME>
(define (improve guess x)
  (average guess (/ x guess)))
      </SCHEME>
      <JAVASCRIPT>
function improve(guess, x) {
    return average(guess, x / guess);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>improve_example</NAME>
      <SCHEME>
(improve 3 25)
      </SCHEME>
      <JAVASCRIPT>
improve(3, 25);
      </JAVASCRIPT>
    </SNIPPET> 
    其中
<SNIPPET>
      <INDEX><DECLARATION>average</DECLARATION></INDEX>
      <NAME>average_definition</NAME>
      <EXAMPLE>average_example</EXAMPLE>
      <SCHEME>
(define (average x y)
  (/ (+ x y) 2))
      </SCHEME>
      <JAVASCRIPT>
function average(x, y) {
    return (x + y) / 2;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>average_example</NAME>
      <SCHEME>
(average 3 6)
      </SCHEME>
      <JAVASCRIPT>
average(3, 6);
      </JAVASCRIPT>
    </SNIPPET> 
    我们还需要说明“足够好的”含义。以下的描述可以作为说明，但实际上这并不是一个很好的测试。（见习题<SPACE></SPACE><REF NAME="ex:ex-sqrt-end-test"></REF>。）这个想法是改善答案，直到它足够接近，使得其平方与被开方数之间的差距小于预定的容差（这里是0.001）：<SPLIT><FOOTNOTE>我们通常给出
    <INDEX>谓词<SUBINDEX>命名约定</SUBINDEX></INDEX>
    <INDEX>命名约定<SUBINDEX><ORDER>?</ORDER>?用于谓词</SUBINDEX></INDEX>
    <INDEX>问号，作为谓词名称</INDEX>
    <INDEX><USE>?</USE>, 作为谓词名称</INDEX>
    以帮助我们记住它们是谓词。这仅是一个风格约定。就解释器而言，问号只是一个普通字符。</FOOTNOTE><JAVASCRIPT><FOOTNOTE>我们通常给出
    <INDEX>谓词<SUBINDEX>命名约定</SUBINDEX></INDEX>
    <INDEX>命名约定<SUBINDEX><ORDER>是</ORDER><JAVASCRIPTINLINE>is_</JAVASCRIPTINLINE>用于谓词</SUBINDEX></INDEX>
    <INDEX><JAVASCRIPTINLINE>is_</JAVASCRIPTINLINE>, 作为谓词名称的开始<ORDER>是</ORDER></INDEX>
    以帮助我们记住它们是谓词。</FOOTNOTE></JAVASCRIPT></SPLIT>
<SNIPPET>
      <NAME>is_good_enough</NAME>
      <REQUIRES>abs_definition</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <EXAMPLE>is_good_enough_example</EXAMPLE>
      <SCHEME>
(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
      </SCHEME>
      <JAVASCRIPT>
function is_good_enough(guess, x) {
    return abs(square(guess) - x) &lt; 0.001;
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>is_good_enough_example</NAME>
      <SCHEME>
(good-enough? 1.41 2)
      </SCHEME>
      <JAVASCRIPT>
is_good_enough(1.41, 2);
      </JAVASCRIPT>
    </SNIPPET> 
    最后，我们需要一种方法来开始。例如，我们可以总是假设任何数字的平方根为<SPACE></SPACE>1:<SPLITINLINE><FOOTNOTE>请注意，我们将初始猜测表达为1.0而不是1。这在许多Lisp实现中不会有什么区别。
    <INDEX>有理数<SUBINDEX><ORDER>MIT</ORDER>在MIT Scheme中</SUBINDEX></INDEX>
    <INDEX>精确整数</INDEX>
    <INDEX>整数<SUBINDEX>精确</SUBINDEX></INDEX>
    <INDEX>整数的除法</INDEX>
    <INDEX>整数<SUBINDEX>除法</SUBINDEX></INDEX>
    <INDEX>数字<SUBINDEX>有理数</SUBINDEX></INDEX>
    <INDEX>数字<SUBINDEX>整数，精确</SUBINDEX></INDEX>
    <INDEX>数字<SUBINDEX>小数点</SUBINDEX></INDEX>
    <INDEX>数字中的小数点</INDEX>
    <INDEX>MIT Scheme<SUBINDEX>数字</SUBINDEX></INDEX>
    <INDEX>实现依赖<SUBINDEX>数字</SUBINDEX></INDEX>
    <INDEX>数字<SUBINDEX>实现依赖</SUBINDEX></INDEX> 
    然而，MIT Scheme区分精确整数和小数值，两个整数的除法产生有理数而不是小数。例如，10除以6得到5/3，而10.0除以6.0得到1.6666666666666667。（我们将在第<SPACE></SPACE><REF NAME="sec:rationals"></REF>节中学习如何对有理数进行算术运算。）如果我们在平方根程序中从初始猜测1开始，而$x$是一个精确整数，则在平方根计算中产生的所有后续值将是有理数而不是小数。在有理数和小数的混合操作中，总是会产生小数，因此以1.0作为初始猜测会迫使所有后续值都是小数。</FOOTNOTE></SPLITINLINE>
<SNIPPET>
      <INDEX><DECLARATION>sqrt</DECLARATION></INDEX>
      <NAME>sqrt</NAME>
      <REQUIRES>sqrt_iter</REQUIRES>
      <EXAMPLE>sqrt_example_2</EXAMPLE>
      <EXPECTED>2.2360688956433634</EXPECTED>
      <SCHEME>
(define (sqrt x)
  (sqrt-iter 1.0 x))
                </SCHEME>
                <JAVASCRIPT>
function sqrt(x) {
    return sqrt_iter(1, x);
}
                </JAVASCRIPT>
    </SNIPPET> 
    如果我们将这些
    <SPLITINLINE>
      
        定义
      
      <JAVASCRIPT>
        声明
      </JAVASCRIPT>
    </SPLITINLINE>
    输入到解释器中，我们就可以使用 
<SCHEMEINLINE>sqrt</SCHEMEINLINE> 
    就像我们可以使用任何
    <SPLITINLINE>
      
        过程：
      
      <JAVASCRIPT>
        函数：
      </JAVASCRIPT>
    </SPLITINLINE>
<SNIPPET PAGE="24">
      <NAME>sqrt_example</NAME>
      <REQUIRES>sqrt</REQUIRES>
      <SCHEME>
(sqrt 9)
      </SCHEME>
      <SCHEMEOUTPUT>
3.00009155413138
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
sqrt(9);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
3.00009155413138
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET PAGE="24" HIDE="yes">
      <NAME>sqrt_example_2</NAME>
      <SCHEME>
(sqrt 5)
      </SCHEME>
      <JAVASCRIPT>
sqrt(5);
      </JAVASCRIPT>
    </SNIPPET>

    <SNIPPET>
      <NAME>sqrt_example_3</NAME>
      <REQUIRES>sqrt</REQUIRES>
      <SCHEME>
(sqrt (+ 100 37))
      </SCHEME>
      <SCHEMEOUTPUT>
11.704699917758145
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
sqrt(100 + 37);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
11.704699917758145
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>sqrt_example_4</NAME>
      <EXPECTED>1.7739279023207892</EXPECTED>
      <REQUIRES>sqrt</REQUIRES>
      <SCHEME>
(sqrt (+ (sqrt 2) (sqrt 3)))
      </SCHEME>
      <SCHEMEOUTPUT>
1.7739279023207892
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
sqrt(sqrt(2) + sqrt(3));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
1.7739279023207892		
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <NAME>sqrt_example_5</NAME>
      <REQUIRES>sqrt</REQUIRES>
      <SCHEME>
(square (sqrt 1000))
      </SCHEME>
      <SCHEMEOUTPUT>
1000.000369924366
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
square(sqrt(1000));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
1000.000369924366
      </JAVASCRIPT_OUTPUT>
      <INDEX>square root<CLOSE></CLOSE></INDEX>
      <INDEX>Newton<APOS></APOS>s method<SUBINDEX><ORDER>square</ORDER>for square roots<CLOSE></CLOSE></SUBINDEX></INDEX>
    </SNIPPET>
  </TEXT>
   
    如果我们输入这些
    <SPLITINLINE>
      
        定义
      
      <JAVASCRIPT>
        声明
      </JAVASCRIPT>
    </SPLITINLINE>
    到解释器中，我们可以使用 


  <EXERCISE>
    <SPLIT>
      <SCHEME>
        Alyssa P. Hacker doesn<APOS></APOS>t see why <SCHEMEINLINE>if</SCHEMEINLINE>
	needs to be provided as a
        <INDEX><DECLARATION>if</DECLARATION><SUBINDEX>why a special form</SUBINDEX></INDEX>
        <INDEX>special form<SUBINDEX>need for</SUBINDEX></INDEX>
	special form.  <QUOTE>Why can<APOS></APOS>t I just
	define it as an ordinary procedure in terms of
        <SCHEMEINLINE>cond</SCHEMEINLINE>?</QUOTE> she asks.
        Alyssa<APOS></APOS>s friend Eva Lu Ator claims this can indeed be done, and
        she defines a new version of <SCHEMEINLINE>if</SCHEMEINLINE>:
        <SNIPPET>
          <NAME>new_if</NAME>
          <SCHEME>
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
          </SCHEME>
        </SNIPPET>
        Eva demonstrates the program for Alyssa:
        <SNIPPET>
          <REQUIRES>new_if</REQUIRES>
          <SCHEME>
(new-if (= 2 3) 0 5)
          </SCHEME>
          <SCHEMEOUTPUT>
5
          </SCHEMEOUTPUT>
        </SNIPPET>
        <SNIPPET>
          <REQUIRES>new_if</REQUIRES>
          <SCHEME>
(new-if (= 1 1) 0 5)
          </SCHEME>
          <SCHEMEOUTPUT>
0
          </SCHEMEOUTPUT>
        </SNIPPET>
        Delighted, Alyssa uses <SCHEMEINLINE>new-if</SCHEMEINLINE> to rewrite
	the square-root program:
        <SNIPPET>
          <REQUIRES>new_if</REQUIRES>
          <REQUIRES>is_good_enough</REQUIRES>
          <REQUIRES>improve</REQUIRES>
          <EXAMPLE>sqrt_iter_example</EXAMPLE>
          <SCHEME>
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
          </SCHEME>
        </SNIPPET>
        What happens when Alyssa attempts to use this to compute square roots?
        Explain.
        <LABEL NAME="ex:new-if"></LABEL>
      </SCHEME>
      <JAVASCRIPT> 
    Alyssa P. Hacker不喜欢
    <INDEX>语法形式<SUBINDEX>所需的</SUBINDEX></INDEX>
    <INDEX>条件表达式<SUBINDEX>为何是语法形式</SUBINDEX></INDEX>
    条件表达式的语法，涉及到的字符 
<SCHEMEINLINE>?</SCHEMEINLINE> 
和  
<SCHEMEINLINE>:</SCHEMEINLINE>.
	 
    “我为什么不能仅仅声明一个普通的条件函数，它的应用方式就像条件表达式一样？”她问道。<FOOTNOTE>
    作为最初的《计算机程序的结构与解释》的Lisp黑客，Alyssa更喜欢一种更简单、更统一的语法。</FOOTNOTE>
    Alyssa的朋友Eva Lu Ator声称这确实可以做到，她声明了一个<JAVASCRIPTINLINE>条件</JAVASCRIPTINLINE>函数，内容如下：
<SNIPPET>
          <NAME>conditional</NAME>
          <JAVASCRIPT>
function conditional(predicate, then_clause, else_clause) {		    
    return predicate ? then_clause : else_clause;
}
	  </JAVASCRIPT>
        </SNIPPET> 
        Eva为Alyssa演示了程序：
<SNIPPET>
          <REQUIRES>conditional</REQUIRES>
          <JAVASCRIPT>
conditional(2 === 3, 0, 5);
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
5
	  </JAVASCRIPT_OUTPUT>
        </SNIPPET>
        <SNIPPET>
          <REQUIRES>conditional</REQUIRES>
          <JAVASCRIPT>
conditional(1 === 1, 0, 5);
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
0
	  </JAVASCRIPT_OUTPUT>
        </SNIPPET> 
    高兴的Alyssa使用 
<SCHEMEINLINE>conditional</SCHEMEINLINE> 
    以重写平方根程序：
<SNIPPET>
	  <NAME>delighted</NAME>
          <REQUIRES>conditional</REQUIRES>
          <REQUIRES>is_good_enough</REQUIRES>
          <REQUIRES>improve</REQUIRES>
          <EXAMPLE>sqrt_iter_example</EXAMPLE>
          <JAVASCRIPT>
function sqrt_iter(guess, x) {
    return conditional(is_good_enough(guess, x),
                       guess,
                       sqrt_iter(improve(guess, x),
                                 x));
}
	  </JAVASCRIPT>
        </SNIPPET> 
    当Alyssa尝试使用这个计算平方根时会发生什么？解释一下。
<LABEL NAME="ex:new-if"></LABEL>
	 <SOLUTION>
    调用<JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>会立即导致无限循环。原因在于我们的应用序求值。<JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>的返回表达式的求值需要先评估其参数，包括对<JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>的递归调用，无论谓词的求值结果是<EM>真的</EM>还是<EM>假的</EM>。当然，递归调用也会发生同样的情况，因此<JAVASCRIPTINLINE>conditional</JAVASCRIPTINLINE>函数实际上并没有被应用。
</SOLUTION>
</JAVASCRIPT>
    </SPLIT>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:ex-sqrt-end-test"></LABEL> 
    用于计算平方根的
    <SPLITINLINE>
      
        good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    测试对于寻找非常小的数字的平方根并不十分有效。此外，在实际计算机中，算术运算几乎总是以有限的精度进行。这使得我们的测试对于非常大的数字不够充分。解释这些陈述，并用示例说明测试如何在小数字和大数字中失败。 
    实现
    <SPLITINLINE>
      
        good-enough?
      
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>is_good_enough</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    的另一种策略是观察如何 
<SCHEMEINLINE>guess</SCHEMEINLINE> 
    从一个迭代到下一个迭代的变化，并在变化仅是猜测的一小部分时停止。设计一个平方根
    <SPLITINLINE>
      
        过程
      
      <JAVASCRIPT>
        函数
      </JAVASCRIPT>
    </SPLITINLINE>
    ，使用这种结束测试。这对于小号码和大号码的效果如何？
    <SOLUTION>
      当计算小值的平方根时，绝对容差0.001太大。例如，
      <JAVASCRIPTINLINE>sqrt(0.0001)</JAVASCRIPTINLINE>
      结果为0.03230844833048122，而不是期望值0.01，误差超过200%。
      <P></P>
      另一方面，对于非常大的值，舍入误差可能导致算法无法接近平方根，在这种情况下它将不会终止。
      <P></P>
      以下程序通过用相对容差替代绝对容差来缓解这个问题。
      
        <REQUIRES>abs_definition</REQUIRES>
        <REQUIRES>average_definition</REQUIRES>
        <REQUIRES>sqrt</REQUIRES>
        <REQUIRES>improve</REQUIRES>
        <REQUIRES>sqrt_iter</REQUIRES>	
        <REQUIRES>square_definition</REQUIRES>	
	<EXAMPLE>example_1.8</EXAMPLE>
	<JAVASCRIPT>
const relative_tolerance = 0.0001;
function is_good_enough(guess, x) {
    return abs(square(guess) - x) &lt; guess * relative_tolerance;
}
	</JAVASCRIPT>
      
    </SOLUTION>
<SNIPPET HIDE="yes">
      <NAME>example_1.8</NAME>
      <JAVASCRIPT>
display(sqrt(0.0001));
display(sqrt(4000000000000));
      </JAVASCRIPT>
      <SCHEME>
      </SCHEME>
    </SNIPPET>
  </EXERCISE>

   <EXERCISE>
    
    牛顿法用于
    <INDEX>立方根<SUBINDEX><ORDER>牛顿</ORDER>通过牛顿法</SUBINDEX></INDEX>
    <INDEX>牛顿法<SUBINDEX><ORDER>立方</ORDER>用于立方根</SUBINDEX></INDEX>
    立方根的计算基于以下事实：如果
    $y$是$x$的立方根的近似值，则更好的近似值由以下值给出：
    
      \[
      \begin{array}{lll}
      \dfrac{x/y^{2}+2y} {3}
      \end{array}
      \]
    
    使用这个公式来实现一个立方根
    <SPLITINLINE>
      
        过程
      
      <JAVASCRIPT>
        函数
      </JAVASCRIPT>
    </SPLITINLINE>
    类似于平方根
    <SPLITINLINE>
      过程。
      <JAVASCRIPT>函数。</JAVASCRIPT>
    </SPLITINLINE>
    （在第<SPACE></SPACE><REF NAME="sec:proc-returned-values"></REF>节中，我们将看到如何将牛顿法一般性地实现为这些
    平方根和立方根的
    <SPLITINLINE>
      过程的抽象。
      <JAVASCRIPT>函数的抽象。</JAVASCRIPT>
    </SPLITINLINE>
    <SOLUTION>
      
	<EXAMPLE>example_1.9</EXAMPLE>
	<REQUIRES>abs_definition</REQUIRES>
	<REQUIRES>cube_definition</REQUIRES>
	<JAVASCRIPT>
function is_good_enough(guess, x) {
    return abs(cube(guess) - x) &lt; 0.001;
}
function div3(x, y) {
     return (x + y) / 3;
}
function improve(guess, x) {
    return div3(x / (guess * guess), 2 * guess);
}
function cube_root(guess, x) {
    return is_good_enough(guess, x)
           ? guess
           : cube_root(improve(guess, x), x);
}
	</JAVASCRIPT>
	
	
      
    </SOLUTION>
    
      <NAME>example_1.9</NAME>
      <JAVASCRIPT>
	cube_root(3, 27);
      </JAVASCRIPT>
    
  </EXERCISE> 
</SUBSECTION>
