[{"id":"/sicpjs/foreword02","tag":"TITLE","body":"Foreword"},{"tag":"TEXT","id":"#p1","child":[{"body":"\n      I had the pleasure of meeting the amazing Alan Perlis and\n      talking with him a few times, when I was still a student. He and\n      I had in common a deep love and respect for two very different\n      programming languages: Lisp and APL. Following in his footsteps\n      is a daunting task, even though he blazed an excellent\n      trail. Still, I would like to reexamine one comment he made in\n      the original foreword to this book (and, please, I suggest that\n      you read ","tag":"#text"},{"tag":"EM","child":[{"body":"his","tag":"#text"}]},{"body":" foreword, which immediately follows this one,\n      before you finish this one). Is it really true that it is better\n      to have 100 functions operate on one data structure than to have\n      10 functions operate on 10 data structures?\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p2","child":[{"body":"\n      To answer that question carefully, we first need to ask whether\n      that one data structure is \"","tag":"#text"},{"body":"universal","tag":"#text"},{"body":"\": can it\n      conveniently fulfill the roles of those 10 more specialized data\n      structures?\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p3","child":[{"body":"\n      For that matter, we can also ask: do we really need 100\n      functions? Is there a single universal function that can fulfill\n      the roles of all those other functions?\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p4","child":[{"body":"\n      The surprising answer to that last question is\n      \"","tag":"#text"},{"body":"yes","tag":"#text"},{"body":"\"; it is only slightly tricky to construct a\n      function that accepts (1) a data structure that serves as a\n      description of some other function, and (2) a list of arguments,\n      and behaves exactly as that other function would when applied to\n      the given arguments. And it is only slightly tricky to design a\n      data structure capable of describing any computation\n      whatsoever. One such data structure (the tagged-list\n      representation of expressions and statements, paired with\n      environments that associate names with values) and one such\n      universal function (","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"apply"},{"body":")\n      are described in Chapter 4 of this book. So maybe we need only\n      one function and one data structure.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p5","child":[{"body":"\n      That is true in theory. In practice, we find it convenient to\n      draw distinctions that help us, as human beings constructing\n      descriptions of computations, to organize the structure of our\n      code so that we can better understand them. I believe that\n      Perlis was making a remark not about computational capability,\n      but about human abilities and human limitations.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p6","child":[{"body":"\n      One thing the human mind seems to do well is to name things; we\n      have powerful associative memories. Given a name, we can quickly\n      recall some associated thing to mind. This is why we typically\n      find it easier to work with the lambda calculus than the\n      combinatory calculus; it is much easier for most people to\n      interpret the Lisp expression\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"(lambda (x) (lambda (y) (+ x y)))"},{"body":"\n      or the JavaScript expression\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"x => y => x + y"},{"body":"\n      than the combinatory expression\n      ","tag":"#text"},{"tag":"EPIGRAPH","child":[{"body":"\n\t((S ((S (K S)) ((S ((S (K S)) ((S (K K)) (K +)))) ((S (K K)) I)))) (K I))\n      ","tag":"#text"}]},{"body":"\n      even though there is a direct structural correspondence, easily\n      expressed in five lines of Lisp code.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p7","child":[{"body":"\n      So while in principle we could get by with just one universal\n      function, we prefer to modularize our code, to give names to the\n      various pieces, and to mention the names of function descriptions\n      rather than constantly feeding the descriptions themselves to the\n      universal function.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p8","child":[{"body":"\n      In my 1998 talk \"","tag":"#text"},{"body":"Growing a Language,","tag":"#text"},{"body":"\" I commented\n      that a good programmer \"","tag":"#text"},{"body":"does not just write programs. A good\n      programmer builds a working vocabulary.","tag":"#text"},{"body":"\" As we design and\n      define more and more parts of our programs, we give names to\n      those parts, and the result is that we have a richer language in\n      \n      which to write the rest.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p9","child":[{"body":"\n      But we also find it natural to draw distinctions among data\n      structures, and to give them names.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p10","child":[{"body":"\n      It may be that nested lists are a universal data structure (and\n      it is worth noting that many modern and widely used data\n      structures, such as HTML and XML and JSON, are also\n      parenthetically nested representations, only slightly more\n      elaborate than Lisp's bare parentheses).  There are also\n      many functions, such as finding the length of a list or applying\n      a function to every element of a list and getting back a list of\n      the results, that are useful in a wide variety of\n      situations. And yet, when I am thinking about a specific\n      computation, I often say to myself, \"","tag":"#text"},{"body":"This list of two\n      things I expect to be a personal name and a surname, but that\n      list of two things I expect to be the real and imaginary parts\n      of a complex number, and that other list of two things I will\n      regard as the numerator and denominator of a fraction.","tag":"#text"},{"body":"\"\n      In other words, I draw distinctions—and it may be useful\n      to represent those distinctions explicitly in the data\n      structure, in part to prevent mistakes such as accidentally\n      treating a complex number as a fraction. (Again, this is a\n      comment about human abilities and human limitations.)\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p11","child":[{"body":"\n      Since the first edition of this book was written, almost four decades\n      ago, a lot more ways of organizing data have become relatively\n      standard, in particular the \"","tag":"#text"},{"body":"object-oriented","tag":"#text"},{"body":"\" approach, and many\n      languages, including JavaScript, support specialized data structures\n      such as objects and strings and heaps and maps with a variety of\n      built-in mechanisms and libraries. But in doing so, many languages\n      abandoned support for more general, universal notions. Java, for\n      example, originally did not support first-class functions, and has\n      incorporated them only relatively recently, greatly increasing its\n      expressive power.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p12","child":[{"body":"\n      APL, likewise, originally did not support first-class functions, and\n      moreover its original single data structure—arrays of any number of\n      dimensions—was not so conveniently useful as a universal data\n      structure because arrays could not contain other arrays as\n      elements. More recent versions of APL do support anonymous function\n      values and nested arrays, and these have made APL dramatically more\n      expressive. (The original design of APL did have two very good things\n      going for it: a comprehensive set of functions applicable to that one\n      data structure, and moreover an extremely well chosen set of names for\n      those functions. I'm not talking about the funny symbols and Greek\n      letters, but the spoken words that APL programmers use when mentioning\n      them, words like\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"shape"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"reshape"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"compress"},{"body":",\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"expand"},{"body":", and\n      ","tag":"#text"},{"tag":"JAVASCRIPTINLINE","body":"laminate"},{"body":";\n      these are names not for the\n      symbols, but for the functions they represent. Ken Iverson had a real\n      knack for choosing short, memorable, vivid names for functions on\n      arrays.)\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p13","child":[{"body":"\n      While JavaScript, like Java, was originally designed with objects and\n      methods in mind, it also incorporated first-class functions from the\n      beginning, and it is not difficult to use its objects to define a\n      universal data structure. As a result, JavaScript is not as distant\n      from Lisp as you would think, and as this edition of\n      ","tag":"#text"},{"tag":"EM","child":[{"body":"Structure and Interpretation of Computer Programs","tag":"#text"}]},{"body":"\n      demonstrates, it is a good\n      alternate framework for presenting the key ideas.\n      ","tag":"#text"},{"tag":"EM","child":[{"body":"SICP","tag":"#text"}]},{"body":"\n      was never about a programming language; it presents powerful, general\n      ideas for program organization that ought to be useful in any\n      language.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p14","child":[{"body":"\n      What do Lisp and JavaScript have in common?  The ability to abstract a\n      computation (code plus some associated data) for later execution as a\n      function; the ability to embed references to such functions within\n      data structures; the ability to invoke functions on arguments; the\n      ability to draw a distinction (conditional execution); a convenient\n      universal data structure; completely automatic storage management for\n      that data (which seems like a no-brainer, given everything else, until\n      you realize that many widely used programming languages don't have\n      it); a large set of useful functions for operating on that universal\n      data structure; and standard strategies for using the universal data\n      structure to represent more specialized data structures.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p15","child":[{"body":"\n      So maybe the truth is somewhere in between the extremes that Perlis so\n      eloquently posited. Maybe the sweet spot is something more like 40\n      functions general enough to operate usefully on a universal data\n      structure such as lists, but also 10 sets of 6 functions each that are\n      relevant when we take one of 10 specialized views of that universal\n      data structure. This is manageable if we give good names to these\n      functions and specialized views.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p16","child":[{"body":"\n      As you read this book, please pay attention not only to the\n      programming language constructs and how they are used, but also to the\n      ","tag":"#text"},{"tag":"EM","child":[{"body":"names","tag":"#text"}]},{"body":" given to functions and variables and data\n      structures. They are not all as short and vivid as the names Iverson\n      chose for his APL functions, but they have been chosen in a deliberate\n      and systematic way to enhance your understanding of the overall\n      program structure.\n    ","tag":"#text"}]},{"tag":"TEXT","id":"#p17","child":[{"body":"\n      Primitives, means of combination, functional abstraction, naming, and\n      conventions for using a universal data structure in specialized ways\n      by drawing distinctions: these are the fundamental building blocks of\n      a good programming language. From there, imagination and good\n      engineering judgment based on experience can do the rest.\n    ","tag":"#text"}]},{"tag":"EPIGRAPH","child":[{}],"author":" Guy L. Steele Jr., ","title":"Lexington, Massachusetts, 2021"}]